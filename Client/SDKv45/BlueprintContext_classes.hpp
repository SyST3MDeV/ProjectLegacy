#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BlueprintContext

#include "Basic.hpp"

#include "CoreUObject_classes.hpp"
#include "Party_structs.hpp"
#include "OrionGame_structs.hpp"
#include "Engine_classes.hpp"
#include "Account_structs.hpp"
#include "BlueprintContext_structs.hpp"


namespace SDK
{

// Class BlueprintContext.BlueprintContextBase
// 0x0008 (0x0030 - 0x0028)
class UBlueprintContextBase : public UObject
{
public:
	int32                                         LocalPlayerIndex;                                  // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlueprintContextBase">();
	}
	static class UBlueprintContextBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlueprintContextBase>();
	}
};
static_assert(alignof(UBlueprintContextBase) == 0x000008, "Wrong alignment on UBlueprintContextBase");
static_assert(sizeof(UBlueprintContextBase) == 0x000030, "Wrong size on UBlueprintContextBase");
static_assert(offsetof(UBlueprintContextBase, LocalPlayerIndex) == 0x000028, "Member 'UBlueprintContextBase::LocalPlayerIndex' has a wrong offset!");

// Class BlueprintContext.AnalogCursorContext
// 0x0140 (0x0170 - 0x0030)
class UAnalogCursorContext final : public UBlueprintContextBase
{
public:
	uint8                                         Pad_30[0x80];                                      // 0x0030(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnAnalogCursorToggle;                              // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnAnalogCursorHovered;                             // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnFaceButtonClick;                                 // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0x90];                                      // 0x00E0(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableAnalogCursor();
	void EnableAnalogCursor(bool bEnableParallax);
	void OnAnalogCursorEnabledToggle__DelegateSignature(bool bIsEnabled);
	void OnAnalogCursorHovered__DelegateSignature(bool bIsHovering);
	void OnAnalogCursorToggle__DelegateSignature(bool UsingAnalog);
	void OnFaceButtonClick__DelegateSignature();
	void SetControllingAnalogStick(EOrionAnalogStick NewAnalogStick);
	void SetIsListeningForGestures(bool bNewlyListening);
	void SetNormalizedPosition(const struct FVector2D& NewRelativePosition);

	struct FVector2D GetAnalogStickValues() const;
	struct FVector2D GetCurrentPosition() const;
	EOrionGestureDirection GetDirectionFromVector(const struct FVector2D& Vector) const;
	void GetGestureInfo(EOrionGestureDirection* Direction0, EOrionGestureDirection* Direction1) const;
	class FName GetHoveredWidgetName() const;
	bool GetIsInFastMode() const;
	bool GetIsUsingGamePad() const;
	struct FVector2D GetLastCursorDirection() const;
	struct FVector2D GetNormalizedPosition() const;
	float GetRadius() const;
	float GetRightTriggerValue() const;
	struct FVector2D GetVelocity() const;
	bool IsDelegateToggleBound() const;
	bool IsHovering() const;
	bool IsUsingAnalogCursor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnalogCursorContext">();
	}
	static class UAnalogCursorContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnalogCursorContext>();
	}
};
static_assert(alignof(UAnalogCursorContext) == 0x000008, "Wrong alignment on UAnalogCursorContext");
static_assert(sizeof(UAnalogCursorContext) == 0x000170, "Wrong size on UAnalogCursorContext");
static_assert(offsetof(UAnalogCursorContext, OnAnalogCursorToggle) == 0x0000B0, "Member 'UAnalogCursorContext::OnAnalogCursorToggle' has a wrong offset!");
static_assert(offsetof(UAnalogCursorContext, OnAnalogCursorHovered) == 0x0000C0, "Member 'UAnalogCursorContext::OnAnalogCursorHovered' has a wrong offset!");
static_assert(offsetof(UAnalogCursorContext, OnFaceButtonClick) == 0x0000D0, "Member 'UAnalogCursorContext::OnFaceButtonClick' has a wrong offset!");

// Class BlueprintContext.ArcadeContext
// 0x0420 (0x0450 - 0x0030)
class UArcadeContext final : public UBlueprintContextBase
{
public:
	uint8                                         Pad_30[0x390];                                     // 0x0030(0x0390)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionArcadeScoreInfo                  ScoreInfo;                                         // 0x03C0(0x0048)(Protected, NativeAccessSpecifierProtected)
	TArray<struct FArcadeEffectEvent>             ArcadeEffectEvents;                                // 0x0408(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_418[0x38];                                     // 0x0418(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearScore();
	void StartCountdown();

	int32 GetCurrentRoundIndex() const;
	float GetCurrentRoundTime() const;
	struct FArcadeRoundState GetRoundState() const;
	int32 GetVictoryPoints() const;
	bool InOvertime() const;
	bool IsInArcade() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArcadeContext">();
	}
	static class UArcadeContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArcadeContext>();
	}
};
static_assert(alignof(UArcadeContext) == 0x000008, "Wrong alignment on UArcadeContext");
static_assert(sizeof(UArcadeContext) == 0x000450, "Wrong size on UArcadeContext");
static_assert(offsetof(UArcadeContext, ScoreInfo) == 0x0003C0, "Member 'UArcadeContext::ScoreInfo' has a wrong offset!");
static_assert(offsetof(UArcadeContext, ArcadeEffectEvents) == 0x000408, "Member 'UArcadeContext::ArcadeEffectEvents' has a wrong offset!");

// Class BlueprintContext.AutomationContext
// 0x0018 (0x0048 - 0x0030)
class UAutomationContext final : public UBlueprintContextBase
{
public:
	UMulticastDelegateProperty_                   OnOrionCharSpawned;                                // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateAbilityForPawn(class AOrionChar* InChar, const EOrionAbilityBinding InputID, const bool bPressed);
	void ActivateAIAbility(class AOrionChar* InChar, const EOrionAbilityBinding InputID);
	void AddPawnMovementInput(class AOrionChar* InChar, const struct FVector& WorldDirection, float ScaleValue, bool bForce);
	void CancelAbilityForPawn(class AOrionChar* InChar);
	void CancelAllAbilities(class AOrionChar* InChar);
	void ConfirmAbilityForPawn(class AOrionChar* InChar);
	float GetRemainingCooldownForAbility(class UOrionAbilitySystemComponent* AbilitySystem, const EOrionAbilityBinding InputID);
	void OnOrionCharSpawned__DelegateSignature(class AOrionChar* NewOrionChar);
	void RegisterForActorSpawnCallbacks();
	void ResetAFKTime();
	void ScriptAIBehavior(class AOrionChar* InChar, class UAIScriptedBehavior* ScriptedBehavior);
	void SetHealth(class AOrionChar* InChar, const float InPercent);
	void TeleportCharTo(class AOrionChar* InChar, const struct FVector& DestLocation, const struct FRotator& DestRotation);
	void ViewTarget(class AActor* ActorToFace);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutomationContext">();
	}
	static class UAutomationContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutomationContext>();
	}
};
static_assert(alignof(UAutomationContext) == 0x000008, "Wrong alignment on UAutomationContext");
static_assert(sizeof(UAutomationContext) == 0x000048, "Wrong size on UAutomationContext");
static_assert(offsetof(UAutomationContext, OnOrionCharSpawned) == 0x000030, "Member 'UAutomationContext::OnOrionCharSpawned' has a wrong offset!");

// Class BlueprintContext.BannerContext
// 0x0080 (0x00B0 - 0x0030)
class UBannerContext final : public UBlueprintContextBase
{
public:
	uint8                                         Pad_30[0x80];                                      // 0x0030(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void AddRandomAlterationsToSocket(struct FSingleBannerEntry* Socket, const int32 NumRandomAlterations);
	static void AddRandomItemToSocketSlot(struct FSingleBannerEntry* Socket);
	static int32 CountOverlapAlterations(const struct FBannerItemIdent& BannerItem);
	static int32 CountValidAlterations(const TArray<class FString>& Alterations);
	static bool CreateDefaultBannerSpec(struct FBannerSpec* DefaultBanner);
	static bool CreateRandomBannerSpec(struct FBannerSpec* RandomBanner);
	static int32 GetMaxAlterations();
	static bool IsValidAlteration(const class FString& AlterationId);

	void BuildListOfExistingItemAllocations(const class UOrionMcpProfileAccount* McpProfile, TArray<struct FBannerItemIdent>* AllocatedBannerIdents, TArray<struct FBannerItemIdent>* OwnedBannerItems);
	class UOrionMcpBannerItem* FindActiveBanner(const class UOrionMcpProfileAccount* McpProfile);
	void GenerateBannerItemIDs(class AOrionPlayerController_Game* PlayerController, const TArray<struct FBannerItemIdent>& ItemIdents, struct FBannerSpec* BannerEntry);
	void GeneratePrototypeBannerItemIDs(class AOrionPlayerController_Game* PlayerController, const TArray<struct FBannerItemIdent>& ItemIdents);
	bool SetPrototypeSocketAlteration(int32 SocketIndex, int32 AlterationIndex, const class FString& Ident, EOrionBannerType SocketType);
	bool SetPrototypeSocketIdent(int32 SocketIndex, const class FString& Ident, EOrionBannerType SocketType);
	void SetPrototypeSocketIdentFromArray(const TArray<class FString>& SocketIdentArray, EOrionBannerType SocketType);
	void SetPrototypeStaffFromIdent(const class FString& BannerIdent, bool bRetainSocketID);
	void SetupPrototypeFromDef(class UOrionMcpBannerItemDefinition* BannerSpec);

	const class FString GetBannerAlterationDisplayNameFromName(const class FString& Ident) const;
	const class FString GetBannerAlterationNameFromDisplayName(const class FString& Ident) const;
	void GetBannerAlterationStrings(TArray<class FString>* OutArray, bool bMustOwn) const;
	const class FString GetBannerItemDisplayNameFromName(EOrionBannerType ItemType, const class FString& Ident) const;
	const class FString GetBannerItemNameFromDisplayName(EOrionBannerType ItemType, const class FString& Ident) const;
	TArray<class UOrionMcpBannerItemDefinition*> GetBannerItemsOfType(EOrionBannerType ItemType) const;
	bool GetBannerItemStringsOfType(EOrionBannerType ItemTypes, TArray<class FString>* OutArray, bool bMustOwn) const;
	const class FString GetDisplayNameFromName(EOrionBannerType ItemType, const class FString& Ident) const;
	const class FString GetNameFromDisplayName(EOrionBannerType ItemType, const class FString& Ident) const;
	int32 GetNumAlterationsOnPrototypeSocket(int32 SocketIndex, EOrionBannerType SocketType) const;
	int32 GetNumSockets(const struct FBannerSpec& BannerEntry) const;
	int32 GetNumSocketsOfType(const struct FBannerSpec& BannerEntry, EOrionBannerType ItemType) const;
	int32 GetOwnedIDBannerItem(const TArray<class UOrionMcpBannerItem*>& Banners, const class FString& InItemIdent, struct FBannerItemIdent* OutItemID) const;
	void GetPrototypeAlterationIdentArray(TArray<class FString>* AlterationIdentArray, int32 SocketIndex, EOrionBannerType SocketType) const;
	bool GetPrototypeSocketAlteration(int32 SocketIndex, int32 AlterationIndex, class FString* SocketIdent, EOrionBannerType SocketType) const;
	bool GetPrototypeSocketIdent(int32 SocketIndex, class FString* SocketIdent, EOrionBannerType SocketType) const;
	void GetPrototypeSocketIdentArray(TArray<class FString>* SocketIdentArray, EOrionBannerType SocketType) const;
	void GetProtoypeBanner(struct FBannerSpec* BannerSpec) const;
	bool SetupBannerSocketFromIdent(struct FSingleBannerEntry* Socket, const class FString& BannerIdent, bool bRetainSocketID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BannerContext">();
	}
	static class UBannerContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBannerContext>();
	}
};
static_assert(alignof(UBannerContext) == 0x000008, "Wrong alignment on UBannerContext");
static_assert(sizeof(UBannerContext) == 0x0000B0, "Wrong size on UBannerContext");

// Class BlueprintContext.BaseHUDContext
// 0x09B8 (0x09E8 - 0x0030)
#pragma pack(push, 0x1)
class alignas(0x08) UBaseHUDContext : public UBlueprintContextBase
{
public:
	uint8                                         Pad_30[0x160];                                     // 0x0030(0x0160)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnCardPointsUpdatedDel;                            // 0x0190(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnUltimateReady;                                   // 0x01A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnAbilityFinishedCooldown;                         // 0x01B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnAbilityUnlocked;                                 // 0x01C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnUpdateCursorStateDelegate;                       // 0x01D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E0[0x238];                                    // 0x01E0(0x0238)(Fixing Size After Last Property [ Dumper-7 ])
	EOrionMenuSlotTypes                           CurrentMenu;                                       // 0x0418(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_419[0x7];                                      // 0x0419(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOrionAbilityUIData>            AbilityUIData;                                     // 0x0420(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_430[0x10];                                     // 0x0430(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnCannotActivateAbility;                           // 0x0440(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_450[0x10];                                     // 0x0450(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnLevelUpDel;                                      // 0x0460(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_470[0x2A0];                                    // 0x0470(0x02A0)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnPlayerXPUpdateDel;                               // 0x0710(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnCardXPUpdateDelegate;                            // 0x0720(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnAbilityUpdateDel;                                // 0x0730(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnKDAUpdateDel;                                    // 0x0740(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnHeroDeath;                                       // 0x0750(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_760[0x210];                                    // 0x0760(0x0210)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UHUDAlertAsset*>                 HUDAlertQueue;                                     // 0x0970(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_980[0x10];                                     // 0x0980(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionCoreInfo                         MyCoreInfo;                                        // 0x0990(0x0028)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FOrionCoreInfo                         EnemyCoreInfo;                                     // 0x09B8(0x0028)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9E0[0x8];                                      // 0x09E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeMenuOpenState(EOrionMenuSlotTypes MenuSlot, bool bNewlyOpen);
	float GetCurrentMatchTime();
	void OnAbilityFinishedCooldown__DelegateSignature(EOrionAbilityBinding InputID, const struct FOrionAbilityUIData& AbilityData);
	void OnAbilityUnlocked__DelegateSignature(EOrionAbilityBinding InputID, const struct FOrionAbilityUIData& AbilityData);
	void OnAbilityUpdate__DelegateSignature(EOrionAbilityBinding InputID, const struct FOrionAbilityUIData& AbilityData);
	void OnCannotActivateAbility__DelegateSignature(int32 InputID, const struct FGameplayTagContainer& RelevantTags);
	void OnCardPointsUpdated__DelegateSignature(int32 NewCardActivationPointsSpent, int32 NewCardActivationPointsMax);
	void OnCardXPUpdate__DelegateSignature(float NewXP, float NewXPMax);
	void OnHeroDeathOrSpawnEvent__DelegateSignature(const struct FOrionHUDTeamStatusInfo& NewTeamInfo);
	void OnKDAUpdate__DelegateSignature(int32 Kills, int32 Deaths, int32 Assists, int32 Minions);
	void OnLevelUp__DelegateSignature(int32 NewLevel);
	void OnPlayerXPUpdate__DelegateSignature(int32 XP, int32 MaxXP);
	void OnUltimateReady__DelegateSignature(int32 InputID);
	void QueueHUDAlert(const class UHUDAlertAsset* AlertAsset);
	void SetMatchInfoText(const class FText& NewMatchInfoText);
	void SetMatchInfoTextVisibility(bool bIsNewlyVisible);

	const struct FOrionAbilityUIData GetAbilityData(EOrionAbilityBinding InputID) const;
	struct FOrionCoreInfo GetCoreInfo(EOrionTeam TeamNum) const;
	void GetCurrentMenu(EOrionMenuSlotTypes* ActiveMenu) const;
	EOrionTeam GetEnemyTeam() const;
	const struct FOrionBaseHUDPlayerInfo GetHUDPlayerInfo() const;
	bool GetIsMenuVisible(EOrionMenuSlotTypes MenuType) const;
	bool GetMenuExists(EOrionMenuSlotTypes MenuType) const;
	EOrionTeam GetMyTeam() const;
	class UWidget* GetTopOpenMenu() const;
	EOrionDesiredAnalogCursorState GetTopOpenMenuInputMode() const;
	bool IsUltimateReady() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseHUDContext">();
	}
	static class UBaseHUDContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseHUDContext>();
	}
};
#pragma pack(pop)
static_assert(alignof(UBaseHUDContext) == 0x000008, "Wrong alignment on UBaseHUDContext");
static_assert(sizeof(UBaseHUDContext) == 0x0009E8, "Wrong size on UBaseHUDContext");
static_assert(offsetof(UBaseHUDContext, OnCardPointsUpdatedDel) == 0x000190, "Member 'UBaseHUDContext::OnCardPointsUpdatedDel' has a wrong offset!");
static_assert(offsetof(UBaseHUDContext, OnUltimateReady) == 0x0001A0, "Member 'UBaseHUDContext::OnUltimateReady' has a wrong offset!");
static_assert(offsetof(UBaseHUDContext, OnAbilityFinishedCooldown) == 0x0001B0, "Member 'UBaseHUDContext::OnAbilityFinishedCooldown' has a wrong offset!");
static_assert(offsetof(UBaseHUDContext, OnAbilityUnlocked) == 0x0001C0, "Member 'UBaseHUDContext::OnAbilityUnlocked' has a wrong offset!");
static_assert(offsetof(UBaseHUDContext, OnUpdateCursorStateDelegate) == 0x0001D0, "Member 'UBaseHUDContext::OnUpdateCursorStateDelegate' has a wrong offset!");
static_assert(offsetof(UBaseHUDContext, CurrentMenu) == 0x000418, "Member 'UBaseHUDContext::CurrentMenu' has a wrong offset!");
static_assert(offsetof(UBaseHUDContext, AbilityUIData) == 0x000420, "Member 'UBaseHUDContext::AbilityUIData' has a wrong offset!");
static_assert(offsetof(UBaseHUDContext, OnCannotActivateAbility) == 0x000440, "Member 'UBaseHUDContext::OnCannotActivateAbility' has a wrong offset!");
static_assert(offsetof(UBaseHUDContext, OnLevelUpDel) == 0x000460, "Member 'UBaseHUDContext::OnLevelUpDel' has a wrong offset!");
static_assert(offsetof(UBaseHUDContext, OnPlayerXPUpdateDel) == 0x000710, "Member 'UBaseHUDContext::OnPlayerXPUpdateDel' has a wrong offset!");
static_assert(offsetof(UBaseHUDContext, OnCardXPUpdateDelegate) == 0x000720, "Member 'UBaseHUDContext::OnCardXPUpdateDelegate' has a wrong offset!");
static_assert(offsetof(UBaseHUDContext, OnAbilityUpdateDel) == 0x000730, "Member 'UBaseHUDContext::OnAbilityUpdateDel' has a wrong offset!");
static_assert(offsetof(UBaseHUDContext, OnKDAUpdateDel) == 0x000740, "Member 'UBaseHUDContext::OnKDAUpdateDel' has a wrong offset!");
static_assert(offsetof(UBaseHUDContext, OnHeroDeath) == 0x000750, "Member 'UBaseHUDContext::OnHeroDeath' has a wrong offset!");
static_assert(offsetof(UBaseHUDContext, HUDAlertQueue) == 0x000970, "Member 'UBaseHUDContext::HUDAlertQueue' has a wrong offset!");
static_assert(offsetof(UBaseHUDContext, MyCoreInfo) == 0x000990, "Member 'UBaseHUDContext::MyCoreInfo' has a wrong offset!");
static_assert(offsetof(UBaseHUDContext, EnemyCoreInfo) == 0x0009B8, "Member 'UBaseHUDContext::EnemyCoreInfo' has a wrong offset!");

// Class BlueprintContext.BlueprintContextLibrary
// 0x0000 (0x0028 - 0x0028)
class UBlueprintContextLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UBlueprintContextBase* GetContext(class UObject* ContextObject, TSubclassOf<class UBlueprintContextBase> Class_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlueprintContextLibrary">();
	}
	static class UBlueprintContextLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlueprintContextLibrary>();
	}
};
static_assert(alignof(UBlueprintContextLibrary) == 0x000008, "Wrong alignment on UBlueprintContextLibrary");
static_assert(sizeof(UBlueprintContextLibrary) == 0x000028, "Wrong size on UBlueprintContextLibrary");

// Class BlueprintContext.PlayerAwareContext
// 0x0010 (0x0040 - 0x0030)
class UPlayerAwareContext : public UBlueprintContextBase
{
public:
	UMulticastDelegateProperty_                   OnMcpError;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	void OnMcpError__DelegateSignature(const class FText& ErrorMessage);

	struct FDateTime GetMCPTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerAwareContext">();
	}
	static class UPlayerAwareContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerAwareContext>();
	}
};
static_assert(alignof(UPlayerAwareContext) == 0x000008, "Wrong alignment on UPlayerAwareContext");
static_assert(sizeof(UPlayerAwareContext) == 0x000040, "Wrong size on UPlayerAwareContext");
static_assert(offsetof(UPlayerAwareContext, OnMcpError) == 0x000030, "Member 'UPlayerAwareContext::OnMcpError' has a wrong offset!");

// Class BlueprintContext.BoostContext
// 0x0060 (0x00A0 - 0x0040)
class UBoostContext final : public UPlayerAwareContext
{
public:
	UMulticastDelegateProperty_                   OnBoostsChanged;                                   // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x50];                                      // 0x0050(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FDateTime GetBoostExpirationTime(EOrionBoostType BoostType);
	void GetBoosts(TArray<class UOrionMcpBoostItem*>& Boosts);

	int32 GetUsesRemaining(EOrionBoostType BoostType) const;
	bool IsAnyBoostActive(int32* NumActive) const;
	bool IsBoostActive(EOrionBoostType BoostType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BoostContext">();
	}
	static class UBoostContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBoostContext>();
	}
};
static_assert(alignof(UBoostContext) == 0x000008, "Wrong alignment on UBoostContext");
static_assert(sizeof(UBoostContext) == 0x0000A0, "Wrong size on UBoostContext");
static_assert(offsetof(UBoostContext, OnBoostsChanged) == 0x000040, "Member 'UBoostContext::OnBoostsChanged' has a wrong offset!");

// Class BlueprintContext.ChunkInstallContext
// 0x0018 (0x0048 - 0x0030)
class UChunkInstallContext final : public UBlueprintContextBase
{
public:
	UMulticastDelegateProperty_                   OnInstallComplete;                                 // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Prioritize(EOrionChunkId InChunk, EInstallPriority InPriority);
	void SetInstallSpeed(EInstallSpeed NewSpeed);

	EInstallSpeed GetInstallSpeed() const;
	float GetProgress(EOrionChunkId InChunk) const;
	EInstallStatus GetStatus(EOrionChunkId InChunk) const;
	struct FTimespan GetTimeRemaining(EOrionChunkId InChunk) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChunkInstallContext">();
	}
	static class UChunkInstallContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChunkInstallContext>();
	}
};
static_assert(alignof(UChunkInstallContext) == 0x000008, "Wrong alignment on UChunkInstallContext");
static_assert(sizeof(UChunkInstallContext) == 0x000048, "Wrong size on UChunkInstallContext");
static_assert(offsetof(UChunkInstallContext, OnInstallComplete) == 0x000030, "Member 'UChunkInstallContext::OnInstallComplete' has a wrong offset!");

// Class BlueprintContext.FriendsContext
// 0x00D8 (0x0108 - 0x0030)
class UFriendsContext final : public UBlueprintContextBase
{
public:
	UMulticastDelegateProperty_                   OnQuickInviteListChanged;                          // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0xC8];                                      // 0x0040(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AcceptFriendRequest(const struct FUniqueNetIdRepl& PlayerNetId);
	void CancelFriendRequest(const struct FUniqueNetIdRepl& PlayerNetId);
	void GetQuickInviteList(TArray<class UOrionFriendItem*>* QuickInviteFriends);
	void HandleFriendsChanged();
	void InitiateWhisperToFriend(const struct FUniqueNetIdRepl& FriendNetID);
	void OnFriendsListChanged__DelegateSignature(const TArray<class UOrionFriendItem*>& Friends);
	void RejectFriendRequest(const struct FUniqueNetIdRepl& PlayerNetId);
	void SendFriendRequest(const struct FUniqueNetIdRepl& PlayerNetId);

	EOrionFriendshipStatus GetFriendshipStatus(const struct FUniqueNetIdRepl& PlayerNetId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FriendsContext">();
	}
	static class UFriendsContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFriendsContext>();
	}
};
static_assert(alignof(UFriendsContext) == 0x000008, "Wrong alignment on UFriendsContext");
static_assert(sizeof(UFriendsContext) == 0x000108, "Wrong size on UFriendsContext");
static_assert(offsetof(UFriendsContext, OnQuickInviteListChanged) == 0x000030, "Member 'UFriendsContext::OnQuickInviteListChanged' has a wrong offset!");

// Class BlueprintContext.HeroContext
// 0x0030 (0x0070 - 0x0040)
class UHeroContext final : public UPlayerAwareContext
{
public:
	uint8                                         Pad_40[0x30];                                      // 0x0040(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyPreviewHeroChanged(class UOrionHeroData* NewHero);
	void NotifyPreviewSkinChanged(class UOrionSkinItemDefinition* Skin);
	void OnSelectedSkinChanged__DelegateSignature(const class UOrionSkinItemDefinition* Skin);
	void SetSelectedSkin(class UOrionSkinItemDefinition* Skin);

	TArray<class UOrionHeroData*> FilterAvailableHeroes(const class FText& SearchText) const;
	class UOrionAbility* GetAbility(class UOrionHeroData* Hero, EOrionAbilityBinding Slot) const;
	TArray<class UOrionHeroData*> GetAllAvailableHeroes() const;
	class UOrionHeroData* GetHeroByString(const class FString& HeroName) const;
	class FText GetQueueTimeFor(class UOrionHeroData* InHero, int32 PlaylistId, int32* OutNumSamples) const;
	struct FOrionCosmeticPlayerChoices GetSelectedCosmeticOptions() const;
	class UOrionHeroData* GetSelectedHero() const;
	struct FOrionHeroDataSpec GetSelectedHeroDataSpec() const;
	class UOrionSkinItemDefinition* GetSelectedSkinForHero(const class UOrionHeroData* HeroData) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeroContext">();
	}
	static class UHeroContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeroContext>();
	}
};
static_assert(alignof(UHeroContext) == 0x000008, "Wrong alignment on UHeroContext");
static_assert(sizeof(UHeroContext) == 0x000070, "Wrong size on UHeroContext");

// Class BlueprintContext.HUDContext
// 0x0DE8 (0x17D0 - 0x09E8)
class UHUDContext final : public UBaseHUDContext
{
public:
	uint8                                         Pad_9E8[0x938];                                    // 0x09E8(0x0938)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnMatchInfoTextChangeDel;                          // 0x1320(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnMatchInfoTextVisibilityChangeDel;                // 0x1330(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnTeamNumChangeDel;                                // 0x1340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnBuffInfoAdded;                                   // 0x1350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnBuffInfoUpdated;                                 // 0x1360(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnBuffInfoRemoved;                                 // 0x1370(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnTeamInfoUpdateDel;                               // 0x1380(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnHeroSpawn;                                       // 0x1390(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnLocalHeroDeath;                                  // 0x13A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnLocalHeroSpawn;                                  // 0x13B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnLocalPlayerHeroSetDel;                           // 0x13C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnTeamSurrenderStatusUpdateDel;                    // 0x13D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnPlayerSurrenderStatusUpdateDel;                  // 0x13E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnDamageEventDelegate;                             // 0x13F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   UpdateAnalogCursorStateDelegate;                   // 0x1400(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnSpectatorFollowedHeroChange;                     // 0x1410(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnSpectatorCameraModeChange;                       // 0x1420(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnSpectatorToggleControllerCursor;                 // 0x1430(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnConsoleOpenStateChangeDelegate;                  // 0x1440(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnCriticallyWoundedChanged;                        // 0x1450(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnDangerZoneDamageChanged;                         // 0x1460(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnMatchStartDelegate;                              // 0x1470(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnIsInBaseChangeDelegate;                          // 0x1480(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnCanShopChangeDelegate;                           // 0x1490(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnTowerInfoUpdateDel;                              // 0x14A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnTargeted;                                        // 0x14B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnNewGameEventMessage;                             // 0x14C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnMiniMapModeChanged;                              // 0x14D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14E0[0xE0];                                    // 0x14E0(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionLocalPlayerUIInfo                LocalPlayerInfo;                                   // 0x15C0(0x00D8)(NativeAccessSpecifierPrivate)
	int32                                         LastSeenDeathLogSerialNumber;                      // 0x1698(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LastSeenDeathLogExpansionState;                    // 0x169C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FOrionJungleBuffInfo>           BuffInfoArray;                                     // 0x16A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FOrionHUDTeamStatusInfo>        FriendlyTeamStatusInfo;                            // 0x16B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FOrionHUDTeamStatusInfo>        EnemyTeamStatusInfo;                               // 0x16C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FOrionTowerTargetingInfo               TowerTargetingInfo;                                // 0x16D0(0x0050)(NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class AOrionDamageableObjective_Base>> OverlappingTargetingActors;                        // 0x1720(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1730[0x8];                                     // 0x1730(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UOrionUserWidget_GameEventMessage> CurrentMessageWidget;                              // 0x1738(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAbilitySystemComponent*                WatchedAbilityComponent;                           // 0x1740(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FOrionHUDInputInfo                     HUDInputInfo;                                      // 0x1748(0x0014)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_175C[0x74];                                    // 0x175C(0x0074)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FVector2D GetSafeZonePadding(ESafeZonePadding PaddingType);

	void AddDamageEvent(const struct FOrionUIDamageEventInfo& DamageEventInfo);
	void AddStatusEffectEvent(const bool bForceCardShopToClose);
	void CancelAllAbilities();
	void FadeHUDIn(bool bFadeFast);
	void FadeHUDOut(float FadeInWorldTime, bool bFadeFast);
	void FlushPressedActionBindingKeys(class FName ActionBindingName);
	void HandleInput_Blueprint(class FName ActionBindingName);
	void HideVictoryScreen();
	void HUDAnimationEnding(class FName RequestingName);
	void HUDAnimationStarting(class FName RequestingName);
	void InvalidateHUDCache();
	bool IsLocalHeroDead();
	void SetAutoConfirmEndTime(float EndTime);
	void SetIsHUDHitTestable(bool bNewIsHitTestable);
	void SetScoreDisplayEnemyText(const class FText& NewText);
	void SetScoreDisplayFriendlyText(const class FText& NewText);
	void SetSprintCastingEndTime(float EndTime);
	void ShowCardTutorialDialog();

	struct FOrionLocalPlayerUIInfo BP_GetLocalPlayerInfo() const;
	bool GetAllowCardMenu() const;
	float GetDamageIndicatorRotation(const struct FVector& PlayerLocation, const struct FVector& InstigatorLocation) const;
	EOrionTeam GetEnemyTeam() const;
	struct FOrionHUDInputActionNames GetHUDInputActionNames() const;
	EOrionTeam GetMyTeam() const;
	struct FOrionHUDTeamStatusInfo GetTeamUIInfo(int32 Index_0, EOrionTeam TeamNum) const;
	struct FOrionTowerTargetingInfo GetTowerTargetingInfo() const;
	bool IsSurrenderEnabled() const;
	bool IsTutorial() const;
	bool ShouldShowMatchTimer() const;
	bool ShouldShowTeamScores() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDContext">();
	}
	static class UHUDContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDContext>();
	}
};
static_assert(alignof(UHUDContext) == 0x000008, "Wrong alignment on UHUDContext");
static_assert(sizeof(UHUDContext) == 0x0017D0, "Wrong size on UHUDContext");
static_assert(offsetof(UHUDContext, OnMatchInfoTextChangeDel) == 0x001320, "Member 'UHUDContext::OnMatchInfoTextChangeDel' has a wrong offset!");
static_assert(offsetof(UHUDContext, OnMatchInfoTextVisibilityChangeDel) == 0x001330, "Member 'UHUDContext::OnMatchInfoTextVisibilityChangeDel' has a wrong offset!");
static_assert(offsetof(UHUDContext, OnTeamNumChangeDel) == 0x001340, "Member 'UHUDContext::OnTeamNumChangeDel' has a wrong offset!");
static_assert(offsetof(UHUDContext, OnBuffInfoAdded) == 0x001350, "Member 'UHUDContext::OnBuffInfoAdded' has a wrong offset!");
static_assert(offsetof(UHUDContext, OnBuffInfoUpdated) == 0x001360, "Member 'UHUDContext::OnBuffInfoUpdated' has a wrong offset!");
static_assert(offsetof(UHUDContext, OnBuffInfoRemoved) == 0x001370, "Member 'UHUDContext::OnBuffInfoRemoved' has a wrong offset!");
static_assert(offsetof(UHUDContext, OnTeamInfoUpdateDel) == 0x001380, "Member 'UHUDContext::OnTeamInfoUpdateDel' has a wrong offset!");
static_assert(offsetof(UHUDContext, OnHeroSpawn) == 0x001390, "Member 'UHUDContext::OnHeroSpawn' has a wrong offset!");
static_assert(offsetof(UHUDContext, OnLocalHeroDeath) == 0x0013A0, "Member 'UHUDContext::OnLocalHeroDeath' has a wrong offset!");
static_assert(offsetof(UHUDContext, OnLocalHeroSpawn) == 0x0013B0, "Member 'UHUDContext::OnLocalHeroSpawn' has a wrong offset!");
static_assert(offsetof(UHUDContext, OnLocalPlayerHeroSetDel) == 0x0013C0, "Member 'UHUDContext::OnLocalPlayerHeroSetDel' has a wrong offset!");
static_assert(offsetof(UHUDContext, OnTeamSurrenderStatusUpdateDel) == 0x0013D0, "Member 'UHUDContext::OnTeamSurrenderStatusUpdateDel' has a wrong offset!");
static_assert(offsetof(UHUDContext, OnPlayerSurrenderStatusUpdateDel) == 0x0013E0, "Member 'UHUDContext::OnPlayerSurrenderStatusUpdateDel' has a wrong offset!");
static_assert(offsetof(UHUDContext, OnDamageEventDelegate) == 0x0013F0, "Member 'UHUDContext::OnDamageEventDelegate' has a wrong offset!");
static_assert(offsetof(UHUDContext, UpdateAnalogCursorStateDelegate) == 0x001400, "Member 'UHUDContext::UpdateAnalogCursorStateDelegate' has a wrong offset!");
static_assert(offsetof(UHUDContext, OnSpectatorFollowedHeroChange) == 0x001410, "Member 'UHUDContext::OnSpectatorFollowedHeroChange' has a wrong offset!");
static_assert(offsetof(UHUDContext, OnSpectatorCameraModeChange) == 0x001420, "Member 'UHUDContext::OnSpectatorCameraModeChange' has a wrong offset!");
static_assert(offsetof(UHUDContext, OnSpectatorToggleControllerCursor) == 0x001430, "Member 'UHUDContext::OnSpectatorToggleControllerCursor' has a wrong offset!");
static_assert(offsetof(UHUDContext, OnConsoleOpenStateChangeDelegate) == 0x001440, "Member 'UHUDContext::OnConsoleOpenStateChangeDelegate' has a wrong offset!");
static_assert(offsetof(UHUDContext, OnCriticallyWoundedChanged) == 0x001450, "Member 'UHUDContext::OnCriticallyWoundedChanged' has a wrong offset!");
static_assert(offsetof(UHUDContext, OnDangerZoneDamageChanged) == 0x001460, "Member 'UHUDContext::OnDangerZoneDamageChanged' has a wrong offset!");
static_assert(offsetof(UHUDContext, OnMatchStartDelegate) == 0x001470, "Member 'UHUDContext::OnMatchStartDelegate' has a wrong offset!");
static_assert(offsetof(UHUDContext, OnIsInBaseChangeDelegate) == 0x001480, "Member 'UHUDContext::OnIsInBaseChangeDelegate' has a wrong offset!");
static_assert(offsetof(UHUDContext, OnCanShopChangeDelegate) == 0x001490, "Member 'UHUDContext::OnCanShopChangeDelegate' has a wrong offset!");
static_assert(offsetof(UHUDContext, OnTowerInfoUpdateDel) == 0x0014A0, "Member 'UHUDContext::OnTowerInfoUpdateDel' has a wrong offset!");
static_assert(offsetof(UHUDContext, OnTargeted) == 0x0014B0, "Member 'UHUDContext::OnTargeted' has a wrong offset!");
static_assert(offsetof(UHUDContext, OnNewGameEventMessage) == 0x0014C0, "Member 'UHUDContext::OnNewGameEventMessage' has a wrong offset!");
static_assert(offsetof(UHUDContext, OnMiniMapModeChanged) == 0x0014D0, "Member 'UHUDContext::OnMiniMapModeChanged' has a wrong offset!");
static_assert(offsetof(UHUDContext, LocalPlayerInfo) == 0x0015C0, "Member 'UHUDContext::LocalPlayerInfo' has a wrong offset!");
static_assert(offsetof(UHUDContext, LastSeenDeathLogSerialNumber) == 0x001698, "Member 'UHUDContext::LastSeenDeathLogSerialNumber' has a wrong offset!");
static_assert(offsetof(UHUDContext, LastSeenDeathLogExpansionState) == 0x00169C, "Member 'UHUDContext::LastSeenDeathLogExpansionState' has a wrong offset!");
static_assert(offsetof(UHUDContext, BuffInfoArray) == 0x0016A0, "Member 'UHUDContext::BuffInfoArray' has a wrong offset!");
static_assert(offsetof(UHUDContext, FriendlyTeamStatusInfo) == 0x0016B0, "Member 'UHUDContext::FriendlyTeamStatusInfo' has a wrong offset!");
static_assert(offsetof(UHUDContext, EnemyTeamStatusInfo) == 0x0016C0, "Member 'UHUDContext::EnemyTeamStatusInfo' has a wrong offset!");
static_assert(offsetof(UHUDContext, TowerTargetingInfo) == 0x0016D0, "Member 'UHUDContext::TowerTargetingInfo' has a wrong offset!");
static_assert(offsetof(UHUDContext, OverlappingTargetingActors) == 0x001720, "Member 'UHUDContext::OverlappingTargetingActors' has a wrong offset!");
static_assert(offsetof(UHUDContext, CurrentMessageWidget) == 0x001738, "Member 'UHUDContext::CurrentMessageWidget' has a wrong offset!");
static_assert(offsetof(UHUDContext, WatchedAbilityComponent) == 0x001740, "Member 'UHUDContext::WatchedAbilityComponent' has a wrong offset!");
static_assert(offsetof(UHUDContext, HUDInputInfo) == 0x001748, "Member 'UHUDContext::HUDInputInfo' has a wrong offset!");

// Class BlueprintContext.InventoryContext
// 0x0028 (0x0068 - 0x0040)
class UInventoryContext final : public UPlayerAwareContext
{
public:
	UMulticastDelegateProperty_                   OnCardPackOpened;                                  // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnGiftBoxOpened;                                   // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bMcpOperationPending;                              // 0x0060(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetActiveBanner(struct FActiveBannerStruct* ActiveBanner);
	void GetBannerAlterations(TArray<class UOrionMcpBannerAlterationItem*>& BannerAlterations);
	void GetBanners(TArray<class UOrionMcpBannerItem*>& Banners);
	void GetHeroes(TArray<class UOrionMcpHeroItem*>& Heroes);
	class UOrionMcpItem* GetItemFromDefinition(class UOrionMcpItemDefinition* Definition);
	int32 GetItemQuantityFromDefinition(class UOrionMcpItemDefinition* Definition);
	void OnCardPacksChanged__DelegateSignature();
	void OnGiftBoxOpened__DelegateSignature(const struct FOrionLootNotification& LootNotification, bool bShowFanfare);
	void OpenGiftBox(const class FString& GiftBoxID, bool bShowFanfare);

	void GetActiveBannerID(class FString* ActiveID) const;
	class UOrionSkinItemDefinition* GetActiveSkinForHero(const class UOrionHeroData* HeroData) const;
	class UOrionMcpHeroItem* GetHeroFromData(class UOrionHeroData* HeroData) const;
	class UOrionMcpCardPackItem* GetNextCardPack(EOrionCardPackType CardPackType) const;
	int32 GetNumCardPacks(EOrionCardPackType CardPackType) const;
	bool IsHeroLocked(const class UOrionMcpHeroItem* HeroItem) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryContext">();
	}
	static class UInventoryContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryContext>();
	}
};
static_assert(alignof(UInventoryContext) == 0x000008, "Wrong alignment on UInventoryContext");
static_assert(sizeof(UInventoryContext) == 0x000068, "Wrong size on UInventoryContext");
static_assert(offsetof(UInventoryContext, OnCardPackOpened) == 0x000040, "Member 'UInventoryContext::OnCardPackOpened' has a wrong offset!");
static_assert(offsetof(UInventoryContext, OnGiftBoxOpened) == 0x000050, "Member 'UInventoryContext::OnGiftBoxOpened' has a wrong offset!");
static_assert(offsetof(UInventoryContext, bMcpOperationPending) == 0x000060, "Member 'UInventoryContext::bMcpOperationPending' has a wrong offset!");

// Class BlueprintContext.OrionAsyncAction_OpenCardPack
// 0x0038 (0x0060 - 0x0028)
class UOrionAsyncAction_OpenCardPack final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnSuccess;                                         // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFailure;                                         // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UOrionMcpCardPackItem*                  CardPack;                                          // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionMcpTokenItem*                     KeyItem;                                           // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInventoryContext*                      InventoryContext;                                  // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UOrionAsyncAction_OpenCardPack* OpenCardPack(class UInventoryContext* LibraryContext, class UOrionMcpCardPackItem* CardPackToOpen, class UOrionMcpTokenItem* KeyItem_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAsyncAction_OpenCardPack">();
	}
	static class UOrionAsyncAction_OpenCardPack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAsyncAction_OpenCardPack>();
	}
};
static_assert(alignof(UOrionAsyncAction_OpenCardPack) == 0x000008, "Wrong alignment on UOrionAsyncAction_OpenCardPack");
static_assert(sizeof(UOrionAsyncAction_OpenCardPack) == 0x000060, "Wrong size on UOrionAsyncAction_OpenCardPack");
static_assert(offsetof(UOrionAsyncAction_OpenCardPack, OnSuccess) == 0x000028, "Member 'UOrionAsyncAction_OpenCardPack::OnSuccess' has a wrong offset!");
static_assert(offsetof(UOrionAsyncAction_OpenCardPack, OnFailure) == 0x000038, "Member 'UOrionAsyncAction_OpenCardPack::OnFailure' has a wrong offset!");
static_assert(offsetof(UOrionAsyncAction_OpenCardPack, CardPack) == 0x000048, "Member 'UOrionAsyncAction_OpenCardPack::CardPack' has a wrong offset!");
static_assert(offsetof(UOrionAsyncAction_OpenCardPack, KeyItem) == 0x000050, "Member 'UOrionAsyncAction_OpenCardPack::KeyItem' has a wrong offset!");
static_assert(offsetof(UOrionAsyncAction_OpenCardPack, InventoryContext) == 0x000058, "Member 'UOrionAsyncAction_OpenCardPack::InventoryContext' has a wrong offset!");

// Class BlueprintContext.MatchmakingRegion
// 0x0030 (0x0058 - 0x0028)
class UMatchmakingRegion final : public UObject
{
public:
	class FText                                   DisplayName;                                       // 0x0028(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 RegionId;                                          // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AveragePingMs;                                     // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchmakingRegion">();
	}
	static class UMatchmakingRegion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchmakingRegion>();
	}
};
static_assert(alignof(UMatchmakingRegion) == 0x000008, "Wrong alignment on UMatchmakingRegion");
static_assert(sizeof(UMatchmakingRegion) == 0x000058, "Wrong size on UMatchmakingRegion");
static_assert(offsetof(UMatchmakingRegion, DisplayName) == 0x000028, "Member 'UMatchmakingRegion::DisplayName' has a wrong offset!");
static_assert(offsetof(UMatchmakingRegion, RegionId) == 0x000040, "Member 'UMatchmakingRegion::RegionId' has a wrong offset!");
static_assert(offsetof(UMatchmakingRegion, AveragePingMs) == 0x000050, "Member 'UMatchmakingRegion::AveragePingMs' has a wrong offset!");

// Class BlueprintContext.MatchmakingContext
// 0x0040 (0x0070 - 0x0030)
class UMatchmakingContext final : public UBlueprintContextBase
{
public:
	UMulticastDelegateProperty_                   OnRegionChanged;                                   // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UOrionLobbyBuilder*                     LobbyBuilder;                                      // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x28];                                      // 0x0048(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddMatchmakingCustomKeyToSession();
	void GetAvailableRegions(TArray<class UMatchmakingRegion*>* OutRegionOptions, int32* OutSelectedRegion);
	void OnRejoinAttemptComplete__DelegateSignature(bool bSuccess);
	void RefreshRegionPings(const TDelegate<void()>& InCompletionDelgate);
	bool SelectRegion(const class FString& RegionId, bool bSaveRegion);
	void StartRejoin(TDelegate<void(bool bSuccess)> InCompletionDelegate);

	EOrionBanReason GetCurrentBanInfo(struct FTimespan* TimeLeft) const;
	int32 GetCurrentPlaylistId() const;
	const struct FNativePlaylistIDs GetNativePlaylistIDs() const;
	EPingQuality GetPingQuality(class UMatchmakingRegion* Region) const;
	class FString GetSelectedRegionId() const;
	bool HasValidOnlinePresence(class FText* ErrorString) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchmakingContext">();
	}
	static class UMatchmakingContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchmakingContext>();
	}
};
static_assert(alignof(UMatchmakingContext) == 0x000008, "Wrong alignment on UMatchmakingContext");
static_assert(sizeof(UMatchmakingContext) == 0x000070, "Wrong size on UMatchmakingContext");
static_assert(offsetof(UMatchmakingContext, OnRegionChanged) == 0x000030, "Member 'UMatchmakingContext::OnRegionChanged' has a wrong offset!");
static_assert(offsetof(UMatchmakingContext, LobbyBuilder) == 0x000040, "Member 'UMatchmakingContext::LobbyBuilder' has a wrong offset!");

// Class BlueprintContext.MatchTutorialContext
// 0x00F0 (0x0120 - 0x0030)
class UMatchTutorialContext final : public UBlueprintContextBase
{
public:
	TMap<class FString, bool>                     RunTimeValues;                                     // 0x0030(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x70];                                      // 0x0080(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnHUDTutorialCompleteDelegate;                     // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UOrionTutorial*                         CurrentTutorial;                                   // 0x0100(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CurrentFocusedTutorialID;                          // 0x0108(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_110[0x10];                                     // 0x0110(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearPathToActor();
	void EndTutorial(TSubclassOf<class UOrionTutorial> TutorialClass);
	void RequestFade(class FName TutorialID, EOrionHUDFadeRequest FadeType);
	void RequestPathToActor(class AActor* TargetActor);
	void StartTutorial(TSubclassOf<class UOrionTutorial> TutorialClass);

	bool CurrentlyPlayingTutorial() const;
	struct FOrionHUDTutorialWidgetNames GetHUDTutorialWidgetNames() const;
	bool InTutorialMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchTutorialContext">();
	}
	static class UMatchTutorialContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchTutorialContext>();
	}
};
static_assert(alignof(UMatchTutorialContext) == 0x000008, "Wrong alignment on UMatchTutorialContext");
static_assert(sizeof(UMatchTutorialContext) == 0x000120, "Wrong size on UMatchTutorialContext");
static_assert(offsetof(UMatchTutorialContext, RunTimeValues) == 0x000030, "Member 'UMatchTutorialContext::RunTimeValues' has a wrong offset!");
static_assert(offsetof(UMatchTutorialContext, OnHUDTutorialCompleteDelegate) == 0x0000F0, "Member 'UMatchTutorialContext::OnHUDTutorialCompleteDelegate' has a wrong offset!");
static_assert(offsetof(UMatchTutorialContext, CurrentTutorial) == 0x000100, "Member 'UMatchTutorialContext::CurrentTutorial' has a wrong offset!");
static_assert(offsetof(UMatchTutorialContext, CurrentFocusedTutorialID) == 0x000108, "Member 'UMatchTutorialContext::CurrentFocusedTutorialID' has a wrong offset!");

// Class BlueprintContext.McpContext
// 0x0168 (0x0198 - 0x0030)
class UMcpContext final : public UBlueprintContextBase
{
public:
	TArray<struct FWebEnvironmentUrl>             WebCreateEpicAccountUrl;                           // 0x0030(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FWebEnvironmentUrl>             WebUpgradeEpicAccountUrl;                          // 0x0040(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FWebEnvironmentUrl>             WebForgotPasswordEpicAccountUrl;                   // 0x0050(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FWebEnvironmentUrl>             WebManageEpicAccountUrl;                           // 0x0060(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEulaAvailable;                                   // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLinkedConsoleAccount;                            // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FFriendCode>                    CachedFriendCodes;                                 // 0x0090(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	class FText                                   FriendCodeGiftMessageTitle;                        // 0x00A0(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	TArray<struct FFriendCodeLocString>           FriendCodeGiftMessageTitleLocTexts;                // 0x00B8(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	class FText                                   FriendCodeGiftMessageBody;                         // 0x00C8(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	class FText                                   FriendCodeGiftMessageDetails;                      // 0x00E0(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	TArray<struct FFriendCodeLocString>           FriendCodeGiftMessageDetailsLocTexts;              // 0x00F8(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x90];                                     // 0x0108(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AcceptEula();
	void AutoLogin(const TDelegate<void(ELoginResult Result, class FText& MESSAGE)>& OnCompleteDelegate);
	void OnLoginRequestComplete__DelegateSignature(ELoginResult Result, const class FText& MESSAGE);
	void CheckHasRedeemForAccess(const TDelegate<void(bool bHasInvite, bool bHasPurchase)>& OnCompleteDelegate);
	void OnCheckHasRedeemForAccess__DelegateSignature(bool bHasInvite, bool bHasPurchase);
	void CheckPurchaseRequiredForAccess(const TDelegate<void(bool bPurchaseRequired)>& OnCompleteDelegate);
	void OnCheckPurchaseRequiredForAccess__DelegateSignature(bool bPurchaseRequired);
	void CreateHeadlessAccount(const class FText& DisplayName, const TDelegate<void(ECreateAccountResult Result, class FText& MESSAGE)>& OnCompleteDelegate);
	void OnCreateAccountRequestComplete__DelegateSignature(ECreateAccountResult Result, const class FText& MESSAGE);
	void DeclineEula();
	class FText GetEULAText();
	class FText GetFriendCodeDescription(const struct FFriendCode& FriendCode);
	class FText GetFriendCodeDisplayName(const struct FFriendCode& FriendCode);
	void HACK_SetDisplayName(const class FString& DisplayName);
	void IssueFriendCode(const TDelegate<void(bool bSuccess, struct FFriendCode& FriendCode)>& OnCompleteDelegate);
	void OnIssueFriendCodeComplete__DelegateSignature(bool bSuccess, const struct FFriendCode& FriendCode);
	void Login(const class FText& Username, const class FText& Password, bool bRememberMe, const TDelegate<void(ELoginResult Result, class FText& MESSAGE)>& OnCompleteDelegate);
	void LoginAuthCode(const class FString& AuthCode, const TDelegate<void(ELoginResult Result, class FText& MESSAGE)>& OnCompleteDelegate);
	void Logout();
	void OnDisplayNameUpdated__DelegateSignature(bool bSuccess, const class FText& MESSAGE);
	void OnEulaAvailable__DelegateSignature(const class FText& EulaText);
	void OnLinkedConsoleAccount__DelegateSignature(const class FText& DisplayName, const class FText& ConsoleDisplayName);
	void OnQueryUnredeemedFriendCodesComplete__DelegateSignature(bool bSuccess, const TArray<struct FFriendCode>& FriendCodes);
	void OnSendFriendCodePlatformMessageComplete__DelegateSignature(bool bMessageSent);
	void OnUnlinkAccountRequestComplete__DelegateSignature(bool bSuccess, const class FText& MESSAGE);
	void OnWebCreateEpicAccountRequestComplete__DelegateSignature(bool bSuccess, const class FText& MESSAGE, const class FString& AuthCode);
	void OnWebForgotPasswordRequestComplete__DelegateSignature(bool bSuccess, const class FText& MESSAGE);
	void OnWebUpgradeEpicAccountRequestComplete__DelegateSignature(bool bSuccess, const class FText& MESSAGE);
	void QueryUnredeemedFriendCodes(const TDelegate<void(bool bSuccess, TArray<struct FFriendCode>& FriendCodes)>& OnCompleteDelegate);
	void SendFriendCodePlatformMessage(const struct FFriendCode& FriendCode, const TDelegate<void(bool bMessageSent)>& OnCompleteDelegate);
	void UnLinkConsoleAccount(const TDelegate<void(bool bSuccess, class FText& MESSAGE)>& OnCompleteDelegate);
	void UpdateDisplayName(const class FString& DisplayName, const TDelegate<void(bool bSuccess, class FText& MESSAGE)>& OnCompleteDelegate);
	void WebCreateEpicAccount(const class FText& Email, const TDelegate<void(bool bSuccess, class FText& MESSAGE, const class FString& AuthCode)>& OnCompleteDelegate);
	void WebForgotPasswordEpicAccount(const class FText& Email, const TDelegate<void(bool bSuccess, class FText& MESSAGE)>& OnCompleteDelegate);
	void WebManageEpicAccount();
	void WebUpgradeEpicAccount(const class FText& Email, const TDelegate<void(bool bSuccess, class FText& MESSAGE)>& OnCompleteDelegate);

	bool DisplayNameUpdateAllowed() const;
	class FString GetAppName() const;
	class FText GetGameSessionWatermarkText() const;
	class FText GetLoginStatus() const;
	int32 GetNumFriendCodesToIssue() const;
	class FText GetUsername() const;
	bool HasPlaystationPlus() const;
	bool IsBusy() const;
	bool IsHeadlessAccount() const;
	bool IsHeadlessAccountAllowed() const;
	bool IsLoggedIn() const;
	bool IsRememberMeAllowed() const;
	bool IsRememberMeChecked() const;
	bool IsUnlinkConsoleAccountAllowed() const;
	bool IsValidEmail(const class FText& InEmail) const;
	bool ShouldShowWatermark() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"McpContext">();
	}
	static class UMcpContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMcpContext>();
	}
};
static_assert(alignof(UMcpContext) == 0x000008, "Wrong alignment on UMcpContext");
static_assert(sizeof(UMcpContext) == 0x000198, "Wrong size on UMcpContext");
static_assert(offsetof(UMcpContext, WebCreateEpicAccountUrl) == 0x000030, "Member 'UMcpContext::WebCreateEpicAccountUrl' has a wrong offset!");
static_assert(offsetof(UMcpContext, WebUpgradeEpicAccountUrl) == 0x000040, "Member 'UMcpContext::WebUpgradeEpicAccountUrl' has a wrong offset!");
static_assert(offsetof(UMcpContext, WebForgotPasswordEpicAccountUrl) == 0x000050, "Member 'UMcpContext::WebForgotPasswordEpicAccountUrl' has a wrong offset!");
static_assert(offsetof(UMcpContext, WebManageEpicAccountUrl) == 0x000060, "Member 'UMcpContext::WebManageEpicAccountUrl' has a wrong offset!");
static_assert(offsetof(UMcpContext, OnEulaAvailable) == 0x000070, "Member 'UMcpContext::OnEulaAvailable' has a wrong offset!");
static_assert(offsetof(UMcpContext, OnLinkedConsoleAccount) == 0x000080, "Member 'UMcpContext::OnLinkedConsoleAccount' has a wrong offset!");
static_assert(offsetof(UMcpContext, CachedFriendCodes) == 0x000090, "Member 'UMcpContext::CachedFriendCodes' has a wrong offset!");
static_assert(offsetof(UMcpContext, FriendCodeGiftMessageTitle) == 0x0000A0, "Member 'UMcpContext::FriendCodeGiftMessageTitle' has a wrong offset!");
static_assert(offsetof(UMcpContext, FriendCodeGiftMessageTitleLocTexts) == 0x0000B8, "Member 'UMcpContext::FriendCodeGiftMessageTitleLocTexts' has a wrong offset!");
static_assert(offsetof(UMcpContext, FriendCodeGiftMessageBody) == 0x0000C8, "Member 'UMcpContext::FriendCodeGiftMessageBody' has a wrong offset!");
static_assert(offsetof(UMcpContext, FriendCodeGiftMessageDetails) == 0x0000E0, "Member 'UMcpContext::FriendCodeGiftMessageDetails' has a wrong offset!");
static_assert(offsetof(UMcpContext, FriendCodeGiftMessageDetailsLocTexts) == 0x0000F8, "Member 'UMcpContext::FriendCodeGiftMessageDetailsLocTexts' has a wrong offset!");

// Class BlueprintContext.MenuContext
// 0x0158 (0x0188 - 0x0030)
class UMenuContext final : public UBlueprintContextBase
{
public:
	UMulticastDelegateProperty_                   OnMenuCategoryChanged;                             // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMenuSceneChanged;                                // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFrontEndTabActivated;                            // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnShowMTXReplenish;                                // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnShowPostGameSummary;                             // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFrontEndContentFlowComplete;                     // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnShowHeroDetails;                                 // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnShowDeckBuilder;                                 // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnShowBundlePurchaseScreen;                        // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnShowLootCrateOpeningScreen;                      // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnShowPackOpenScreen;                              // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnShowVaultScreen;                                 // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnShowRefineGemScreen;                             // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnReturnToHomeScreen;                              // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnReturnToPlayScreen;                              // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnNavigateToStoreItem;                             // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnShowArcadeLadderScreen;                          // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_140[0x48];                                     // 0x0140(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastFrontEndTabActivated(const class FName& TabId);
	void BroadcastSceneChange(const class FName& SceneName);
	void DisplayReturnToMainMenuReason();
	bool DisplayReturnToTitleScreenReason(const TDelegate<void()>& OnDialogClosed);
	void OnReturnToTitleScreenReasonClosed__DelegateSignature();
	bool IsFrontEndContentFlowComplete();
	void NavigateToHomeScreen();
	void NavigateToPlayScreen();
	void NavigateToStoreOffer(const class FString& OfferId);
	void NavigationRequest(const class FString& NavigationPath);
	void OnFrontEndTabActivated__DelegateSignature(class FName TabId);
	void OnMenuCategoryPushed__DelegateSignature(class UUserWidget* Widget, const class FName MenuCategory);
	void OnMenuSceneChanged__DelegateSignature(class FName NewScene);
	void OnNavigateToStoreItem__DelegateSignature(const class FString& OfferId);
	void OnNavigateToTab__DelegateSignature();
	void OnShowArcadeLadderScreen__DelegateSignature(class UOrionArcadeLadderSetupData* ArcadeLadder);
	void OnShowBundlePurchaseScreen__DelegateSignature(const class FString& OfferId, const class FName InPurchaseContext);
	void OnShowDeckBuilder__DelegateSignature(class UOrionMcpDeckItem* Deck);
	void OnShowFrontEndContent__DelegateSignature();
	void OnShowHeroDetails__DelegateSignature(class UOrionHeroData* HeroData, class UOrionSkinItemDefinition* SkinToShow);
	void OnShowLootCrateOpeningScreen__DelegateSignature();
	void OnShowMTXReplenish__DelegateSignature();
	void OnShowPackOpenScreen__DelegateSignature(class UOrionMcpCardPackItem* CardPack);
	void OnShowPostGameSummary__DelegateSignature();
	void OnShowRefineGemScreen__DelegateSignature(const class UOrionMcpGemItem* GemItem, class UOrionCardInspectScreen* CardInspectScreen);
	void OnShowVaultScreen__DelegateSignature();
	void RefreshCurrentScene();
	void RegisterMTXConfirmation(class UOrionPurchaseConfirmationWidget* MTXConfirmationWidget);
	void RegisterPurchaseConfirmation(class UOrionPurchaseConfirmationWidget* PurchaseConfirmationWidget);
	void RegisterTabListWidget(class UOrionTabListWidget* TabListWidget);
	bool ReturnToTitleDueToRequiredUpdate(EReturnToMainMenuReason Reason, const TDelegate<void()>& OnDialogClosed);
	void ShowPostGame();
	void ShowVoiceChatUI(bool bShowUI);
	void UnregisterTabListWidget(class UOrionTabListWidget* TabListWidget);

	class FName GetCurrentSceneName() const;
	bool ShouldDisplayWUIUI() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuContext">();
	}
	static class UMenuContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuContext>();
	}
};
static_assert(alignof(UMenuContext) == 0x000008, "Wrong alignment on UMenuContext");
static_assert(sizeof(UMenuContext) == 0x000188, "Wrong size on UMenuContext");
static_assert(offsetof(UMenuContext, OnMenuCategoryChanged) == 0x000030, "Member 'UMenuContext::OnMenuCategoryChanged' has a wrong offset!");
static_assert(offsetof(UMenuContext, OnMenuSceneChanged) == 0x000040, "Member 'UMenuContext::OnMenuSceneChanged' has a wrong offset!");
static_assert(offsetof(UMenuContext, OnFrontEndTabActivated) == 0x000050, "Member 'UMenuContext::OnFrontEndTabActivated' has a wrong offset!");
static_assert(offsetof(UMenuContext, OnShowMTXReplenish) == 0x000060, "Member 'UMenuContext::OnShowMTXReplenish' has a wrong offset!");
static_assert(offsetof(UMenuContext, OnShowPostGameSummary) == 0x000070, "Member 'UMenuContext::OnShowPostGameSummary' has a wrong offset!");
static_assert(offsetof(UMenuContext, OnFrontEndContentFlowComplete) == 0x000080, "Member 'UMenuContext::OnFrontEndContentFlowComplete' has a wrong offset!");
static_assert(offsetof(UMenuContext, OnShowHeroDetails) == 0x000090, "Member 'UMenuContext::OnShowHeroDetails' has a wrong offset!");
static_assert(offsetof(UMenuContext, OnShowDeckBuilder) == 0x0000A0, "Member 'UMenuContext::OnShowDeckBuilder' has a wrong offset!");
static_assert(offsetof(UMenuContext, OnShowBundlePurchaseScreen) == 0x0000B0, "Member 'UMenuContext::OnShowBundlePurchaseScreen' has a wrong offset!");
static_assert(offsetof(UMenuContext, OnShowLootCrateOpeningScreen) == 0x0000C0, "Member 'UMenuContext::OnShowLootCrateOpeningScreen' has a wrong offset!");
static_assert(offsetof(UMenuContext, OnShowPackOpenScreen) == 0x0000D0, "Member 'UMenuContext::OnShowPackOpenScreen' has a wrong offset!");
static_assert(offsetof(UMenuContext, OnShowVaultScreen) == 0x0000E0, "Member 'UMenuContext::OnShowVaultScreen' has a wrong offset!");
static_assert(offsetof(UMenuContext, OnShowRefineGemScreen) == 0x0000F0, "Member 'UMenuContext::OnShowRefineGemScreen' has a wrong offset!");
static_assert(offsetof(UMenuContext, OnReturnToHomeScreen) == 0x000100, "Member 'UMenuContext::OnReturnToHomeScreen' has a wrong offset!");
static_assert(offsetof(UMenuContext, OnReturnToPlayScreen) == 0x000110, "Member 'UMenuContext::OnReturnToPlayScreen' has a wrong offset!");
static_assert(offsetof(UMenuContext, OnNavigateToStoreItem) == 0x000120, "Member 'UMenuContext::OnNavigateToStoreItem' has a wrong offset!");
static_assert(offsetof(UMenuContext, OnShowArcadeLadderScreen) == 0x000130, "Member 'UMenuContext::OnShowArcadeLadderScreen' has a wrong offset!");

// Class BlueprintContext.NotificationContext
// 0x0020 (0x0050 - 0x0030)
class UNotificationContext final : public UBlueprintContextBase
{
public:
	UMulticastDelegateProperty_                   OnNewNotification;                                 // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnRemoveNotification;                              // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NotificationContext">();
	}
	static class UNotificationContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNotificationContext>();
	}
};
static_assert(alignof(UNotificationContext) == 0x000008, "Wrong alignment on UNotificationContext");
static_assert(sizeof(UNotificationContext) == 0x000050, "Wrong size on UNotificationContext");
static_assert(offsetof(UNotificationContext, OnNewNotification) == 0x000030, "Member 'UNotificationContext::OnNewNotification' has a wrong offset!");
static_assert(offsetof(UNotificationContext, OnRemoveNotification) == 0x000040, "Member 'UNotificationContext::OnRemoveNotification' has a wrong offset!");

// Class BlueprintContext.OrionGameContext
// 0x0030 (0x0070 - 0x0040)
class UOrionGameContext final : public UPlayerAwareContext
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnLocalPlayerDeathDel;                             // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnLocalPlayerSpawnDel;                             // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UOrionHeroData* GetHeroData() const;
	bool GetIsUsingGamePad() const;
	struct FVector2D GetLeftAnalogStickValues() const;
	struct FVector2D GetRightAnalogStickValues() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameContext">();
	}
	static class UOrionGameContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionGameContext>();
	}
};
static_assert(alignof(UOrionGameContext) == 0x000008, "Wrong alignment on UOrionGameContext");
static_assert(sizeof(UOrionGameContext) == 0x000070, "Wrong size on UOrionGameContext");
static_assert(offsetof(UOrionGameContext, OnLocalPlayerDeathDel) == 0x000048, "Member 'UOrionGameContext::OnLocalPlayerDeathDel' has a wrong offset!");
static_assert(offsetof(UOrionGameContext, OnLocalPlayerSpawnDel) == 0x000058, "Member 'UOrionGameContext::OnLocalPlayerSpawnDel' has a wrong offset!");

// Class BlueprintContext.PartyContext
// 0x0150 (0x0180 - 0x0030)
class UPartyContext final : public UBlueprintContextBase
{
public:
	UMulticastDelegateProperty_                   OnPlaylistIDChangedDelegate;                       // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPartyMatchmakingCustomKeyChanged;                // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPartyChanged;                                    // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLocalPlayerMMRUpdated;                           // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPartyTypeChangedDelegate;                        // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLeaderFriendsOnlyChangedDelegate;                // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLeaderInvitesOnlyChangedDelegate;                // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPartyDataChangedDelegate;                        // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0xD0];                                      // 0x00B0(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void GetUniqueNetID(class UOrionPartyMemberState* PartyMember, struct FUniqueNetIdRepl* UniqueNetId);

	bool GetPartyPrivacySetting(EPartyType* OutPartyType, bool* OutLeaderFriendsOnly, bool* OutLeaderInvitesOnly);
	void JoinAsSpectator();
	void KickFromParty(class UOrionPartyMemberState* PartyMember);
	void LeaveParty();
	void OnLeaderFriendsOnlyChanged__DelegateSignature(bool bLeaderFriendsOnly);
	void OnLeaderInvitesOnlyChanged__DelegateSignature(bool bLeaderInviteOnly);
	void OnMatchmakingCustomKeyChanged__DelegateSignature(const class FString& CustomKey);
	void OnMMRUpdated__DelegateSignature(bool bIsValid);
	void OnPartyChanged__DelegateSignature();
	void OnPartyDataChanged__DelegateSignature(const struct FPartyState& PartyData);
	void OnPartyTypeChanged__DelegateSignature(EPartyType PartyType);
	void OnPlaylistIDChanged__DelegateSignature(int32 PlaylistId);
	void PromoteToPartyLeader(class UOrionPartyMemberState* PartyMember);
	void SendConsoleFriendInvite();
	void SendPartyInvite(class UOrionFriendItem* FriendItem);
	void SetMatchmakingCustomKey(const class FString& CustomKey);
	void SetPartyPrivacySetting(EPartyType PartyType, bool bLeaderFriendsOnly, bool bLeaderInvitesOnly);
	void SetPlaylistID(int32 NewPlaylistID);

	bool AmIPartyLeader() const;
	class FString GetMatchmakingCustomKey() const;
	class UOrionPersistentPartyMember* GetMyPersistentPartyEntry() const;
	void GetPartyMembers(TArray<class UOrionPersistentPartyMember*>* PartyMembers) const;
	int32 GetPlaylistID() const;
	bool IsHeroPickedByOtherPlayer(const class UOrionHeroData* InHero) const;
	bool IsMatchmakingCustomKeyActive() const;
	bool IsPartyLeader(class UOrionPartyMemberState* PartyMember) const;
	int32 MaxPartyMembers() const;
	int32 NumPartyMembers() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PartyContext">();
	}
	static class UPartyContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPartyContext>();
	}
};
static_assert(alignof(UPartyContext) == 0x000008, "Wrong alignment on UPartyContext");
static_assert(sizeof(UPartyContext) == 0x000180, "Wrong size on UPartyContext");
static_assert(offsetof(UPartyContext, OnPlaylistIDChangedDelegate) == 0x000030, "Member 'UPartyContext::OnPlaylistIDChangedDelegate' has a wrong offset!");
static_assert(offsetof(UPartyContext, OnPartyMatchmakingCustomKeyChanged) == 0x000040, "Member 'UPartyContext::OnPartyMatchmakingCustomKeyChanged' has a wrong offset!");
static_assert(offsetof(UPartyContext, OnPartyChanged) == 0x000050, "Member 'UPartyContext::OnPartyChanged' has a wrong offset!");
static_assert(offsetof(UPartyContext, OnLocalPlayerMMRUpdated) == 0x000060, "Member 'UPartyContext::OnLocalPlayerMMRUpdated' has a wrong offset!");
static_assert(offsetof(UPartyContext, OnPartyTypeChangedDelegate) == 0x000070, "Member 'UPartyContext::OnPartyTypeChangedDelegate' has a wrong offset!");
static_assert(offsetof(UPartyContext, OnLeaderFriendsOnlyChangedDelegate) == 0x000080, "Member 'UPartyContext::OnLeaderFriendsOnlyChangedDelegate' has a wrong offset!");
static_assert(offsetof(UPartyContext, OnLeaderInvitesOnlyChangedDelegate) == 0x000090, "Member 'UPartyContext::OnLeaderInvitesOnlyChangedDelegate' has a wrong offset!");
static_assert(offsetof(UPartyContext, OnPartyDataChangedDelegate) == 0x0000A0, "Member 'UPartyContext::OnPartyDataChangedDelegate' has a wrong offset!");

// Class BlueprintContext.PlayerContext
// 0x00A8 (0x00E8 - 0x0040)
class UPlayerContext final : public UPlayerAwareContext
{
public:
	UMulticastDelegateProperty_                   OnProfileStatsUpdated;                             // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnClientGameplaySettingsChanged;                   // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnClientHUDSettingsChanged;                        // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnRangeIndicatorValueChanged;                      // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bMcpOperationPending;                              // 0x0090(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnPrestigeAccountComplete;                         // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class FText                                   DeckBuilderLockedMessage;                          // 0x00A8(0x0018)(Config, Protected, NativeAccessSpecifierProtected)
	class FText                                   PVPLockedMessage;                                  // 0x00C0(0x0018)(Config, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x10];                                      // 0x00D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyAllClientSettings();
	void ApplyClientAudioSettings();
	void ApplyClientGameplaySettings();
	void ApplyClientHUDSettings();
	void ChangeLanguage(const class FString& LanguageCode, bool bSave);
	struct FBoundKeys GetBoundKeysByNameAndType(class FName BindingName, EKeyBindingType BindingType);
	void OnMcpResult__DelegateSignature(bool bSuccess, const class FText& ErrorMessage);
	void OnPrestigeAccountComplete__DelegateSignature();
	void OverrideBoundKeyByNameAndType(class FName BindingName, EKeyBindingType BindingType, const struct FInputChord& PreviousKey, const struct FInputChord& NewKey);
	void ResetClientAudioSettings();
	void ResetClientGameplaySettings();
	void ResetClientHUDSettings();
	void RevertToCurrentClientAudioSettings();
	void RevertToCurrentClientGameplaySettings();
	void SaveClientSettings();
	void SetAutoPlayInstantReplay(bool NewValue);
	void SetContinuousMusic(bool NewValue);
	void SetDisplayCardOverLocalPlayer(bool bOn);
	void SetEnableDeathcam(int32 NewValue);
	void SetEngineGammaValue(float NewValue);
	void SetGamepadAbilityConfirmOnRelease(int32 NewValue);
	void SetGamepadConfigIndex(int32 NewValue);
	void SetGamepadHandednessConfigIndex(int32 NewValue);
	void SetGamepadInvertPitch(int32 NewValue);
	void SetGamepadInvertYaw(int32 NewValue);
	void SetGamepadPitchSensitivity(int32 NewValue);
	void SetGamepadRadialSelectEnabled(int32 NewValue);
	void SetGamepadYawSensitivity(int32 NewValue);
	void SetHealthBarOverhead(bool bOn);
	void SetInvertedMouse(bool bOn);
	void SetMasterGameVolume(float NewValue);
	void SetMouseLookSensitivity(float NewValue);
	void SetMusicGameVolume(float NewValue);
	void SetOtherGameVolume(float NewValue);
	void SetShowAbilityConfirmWidget(int32 NewValue);
	void SetShowAddedItemsInChat(bool bOn);
	void SetShowBasicAttackRangeIndicator(int32 NewValue);
	void SetShowCompletedItemsInChat(bool bOn);
	void SetShowDiscardedItemsInChat(bool bOn);
	void SetShowPingAndFPSOnHUD(int32 NewValue);
	void SetShowXPPerMinOnHUD(int32 NewValue);
	void SetThemeMusic(const class FString& NewTheme);
	void SetVeterancy(EOrionVeterancy Veterancy, TDelegate<void(bool bSuccess, class FText ErrorMessage)> Callback);
	void SetVoiceGameVolume(float NewValue);

	float GammaToSlider(float Gamma) const;
	class FString GetAccountCountryCode() const;
	int32 GetAccountLevel() const;
	void GetAccountLevelInfo(struct FOrionLevelInfo* AccountLevelInfo) const;
	bool GetAutoOpenCardShop() const;
	bool GetAutoPlayInstantReplay() const;
	bool GetContinuousMusic() const;
	bool GetDisplayCardOverLocalPlayer() const;
	int32 GetEnableDeathcam() const;
	float GetEngineGammaValue() const;
	int32 GetGamepadAbilityConfirmOnRelease() const;
	int32 GetGamepadConfigIndex() const;
	int32 GetGamepadHandednessConfigIndex() const;
	int32 GetGamepadInvertPitch() const;
	int32 GetGamepadInvertYaw() const;
	int32 GetGamepadPitchSensitivity() const;
	int32 GetGamepadRadialSelectEnabled() const;
	int32 GetGamepadYawSensitivity() const;
	bool GetHealthBarOverhead() const;
	bool GetInvertedMouse() const;
	float GetMasterGameVolume() const;
	struct FDateTime GetMinorCanPlayAtTime() const;
	struct FDateTime GetMinorShutDownAtTime() const;
	float GetMouseLookSensitivity() const;
	float GetMusicGameVolume() const;
	class FText GetName() const;
	int32 GetNewDawnGamesPlayed() const;
	float GetOtherGameVolume() const;
	struct FDateTime GetPlayerLoginTime() const;
	int32 GetShowAbilityConfirmWidget() const;
	bool GetShowAddedItemsInChat() const;
	int32 GetShowBasicAttackRangeIndicator() const;
	bool GetShowCompletedItemsInChat() const;
	bool GetShowDiscardedItemsInChat() const;
	int32 GetShowPingAndFPSOnHUD() const;
	int32 GetShowXPPerMinOnHUD() const;
	class FString GetThemeMusic() const;
	float GetVoiceGameVolume() const;
	float SliderToGamma(float SliderPosition) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerContext">();
	}
	static class UPlayerContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerContext>();
	}
};
static_assert(alignof(UPlayerContext) == 0x000008, "Wrong alignment on UPlayerContext");
static_assert(sizeof(UPlayerContext) == 0x0000E8, "Wrong size on UPlayerContext");
static_assert(offsetof(UPlayerContext, OnProfileStatsUpdated) == 0x000040, "Member 'UPlayerContext::OnProfileStatsUpdated' has a wrong offset!");
static_assert(offsetof(UPlayerContext, OnClientGameplaySettingsChanged) == 0x000050, "Member 'UPlayerContext::OnClientGameplaySettingsChanged' has a wrong offset!");
static_assert(offsetof(UPlayerContext, OnClientHUDSettingsChanged) == 0x000060, "Member 'UPlayerContext::OnClientHUDSettingsChanged' has a wrong offset!");
static_assert(offsetof(UPlayerContext, OnRangeIndicatorValueChanged) == 0x000080, "Member 'UPlayerContext::OnRangeIndicatorValueChanged' has a wrong offset!");
static_assert(offsetof(UPlayerContext, bMcpOperationPending) == 0x000090, "Member 'UPlayerContext::bMcpOperationPending' has a wrong offset!");
static_assert(offsetof(UPlayerContext, OnPrestigeAccountComplete) == 0x000098, "Member 'UPlayerContext::OnPrestigeAccountComplete' has a wrong offset!");
static_assert(offsetof(UPlayerContext, DeckBuilderLockedMessage) == 0x0000A8, "Member 'UPlayerContext::DeckBuilderLockedMessage' has a wrong offset!");
static_assert(offsetof(UPlayerContext, PVPLockedMessage) == 0x0000C0, "Member 'UPlayerContext::PVPLockedMessage' has a wrong offset!");

// Class BlueprintContext.QuestContext
// 0x00E0 (0x0120 - 0x0040)
class UQuestContext final : public UPlayerAwareContext
{
public:
	uint8                                         Pad_40[0xE0];                                      // 0x0040(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestContext">();
	}
	static class UQuestContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuestContext>();
	}
};
static_assert(alignof(UQuestContext) == 0x000008, "Wrong alignment on UQuestContext");
static_assert(sizeof(UQuestContext) == 0x000120, "Wrong size on UQuestContext");

// Class BlueprintContext.ReticleContext
// 0x0310 (0x0340 - 0x0030)
class UReticleContext final : public UBlueprintContextBase
{
public:
	uint8                                         Pad_30[0x2B0];                                     // 0x0030(0x02B0)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnSuccessfulHitDel;                                // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnActivelyTargetingDelegate;                       // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TArray<struct FReticleInfo>                   ReticleInfoArray;                                  // 0x0300(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UOrionUserWidget_Reticle> DefaultReticle;                                    // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_318[0x28];                                     // 0x0318(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddReticle(class UOrionAbilitySystemComponent* AbilityComp, const class UOrionAbility* Ability, TSubclassOf<class UOrionUserWidget_Reticle> OptionalReticleClass);
	void HideReticle(const class UOrionAbility* Ability);
	void OnActivelyTargeting__DelegateSignature(bool CurrentlyTargeting);
	void OnSuccessfulHit(const class AActor* TargetActor, const class AActor* Instigator);
	void OnSuccessfulHit__DelegateSignature();
	void SetDefaultReticle(class UOrionUserWidget_Reticle* NewDefaultReticle);
	void ShowReticle(const class UOrionAbility* Ability);

	int32 GetHideCount() const;
	TSubclassOf<class UOrionUserWidget_Reticle> GetReticleClass() const;
	class UOrionUserWidget_Reticle* GetReticleWidget(const class UOrionAbility* Ability) const;
	bool IsActivelyTargetingAnyActor() const;
	bool IsReticleHidden() const;
	bool IsUsingUMGReticle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReticleContext">();
	}
	static class UReticleContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReticleContext>();
	}
};
static_assert(alignof(UReticleContext) == 0x000008, "Wrong alignment on UReticleContext");
static_assert(sizeof(UReticleContext) == 0x000340, "Wrong size on UReticleContext");
static_assert(offsetof(UReticleContext, OnSuccessfulHitDel) == 0x0002E0, "Member 'UReticleContext::OnSuccessfulHitDel' has a wrong offset!");
static_assert(offsetof(UReticleContext, OnActivelyTargetingDelegate) == 0x0002F0, "Member 'UReticleContext::OnActivelyTargetingDelegate' has a wrong offset!");
static_assert(offsetof(UReticleContext, ReticleInfoArray) == 0x000300, "Member 'UReticleContext::ReticleInfoArray' has a wrong offset!");
static_assert(offsetof(UReticleContext, DefaultReticle) == 0x000310, "Member 'UReticleContext::DefaultReticle' has a wrong offset!");

// Class BlueprintContext.SandboxContext
// 0x0008 (0x0038 - 0x0030)
class USandboxContext final : public UBlueprintContextBase
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SandboxContext">();
	}
	static class USandboxContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<USandboxContext>();
	}
};
static_assert(alignof(USandboxContext) == 0x000008, "Wrong alignment on USandboxContext");
static_assert(sizeof(USandboxContext) == 0x000038, "Wrong size on USandboxContext");

// Class BlueprintContext.ScoreboardContext
// 0x05E0 (0x0620 - 0x0040)
class UScoreboardContext final : public UPlayerAwareContext
{
public:
	uint8                                         Pad_40[0x4D0];                                     // 0x0040(0x04D0)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionScoreboardUIInfo                 ScoreboardInfo;                                    // 0x0510(0x0088)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_598[0x88];                                     // 0x0598(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceUpdateAllEntries();

	float GetCurrentMatchTime() const;
	EOrionTeam GetEnemyTeam() const;
	struct FOrionScoreboardPlayerEntryInfo GetLocalPlayerScoreboardEntry() const;
	struct FOrionPlayerStateUIID GetLocalPlayerUIID() const;
	EOrionTeam GetMyTeam() const;
	struct FOrionScoreboardPlayerEntryInfo GetScoreboardPlayerEntry(EOrionTeam TeamNum, int32 PlayerIndex) const;
	struct FOrionScoreboardPlayerEntryInfo GetScoreboardPlayerEntryFromUIID(const struct FOrionPlayerStateUIID& PlayerStateUIID) const;
	struct FOrionScoreboardTeamEntryInfo GetScoreboardTeamEntry(EOrionTeam TeamNum) const;
	bool IsSpectatorScoreboard() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScoreboardContext">();
	}
	static class UScoreboardContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScoreboardContext>();
	}
};
static_assert(alignof(UScoreboardContext) == 0x000008, "Wrong alignment on UScoreboardContext");
static_assert(sizeof(UScoreboardContext) == 0x000620, "Wrong size on UScoreboardContext");
static_assert(offsetof(UScoreboardContext, ScoreboardInfo) == 0x000510, "Member 'UScoreboardContext::ScoreboardInfo' has a wrong offset!");

// Class BlueprintContext.SpectatorHUDContext
// 0x00E8 (0x0AD0 - 0x09E8)
class USpectatorHUDContext final : public UBaseHUDContext
{
public:
	UMulticastDelegateProperty_                   OnSpectatorWatchedHeroChange;                      // 0x09E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnAnselSessionStartDelegate;                       // 0x09F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnAnselSessionEndDelegate;                         // 0x0A08(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnAnselMultiPartCaptureStartDelegate;              // 0x0A18(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnAnselMultiPartCaptureEndDelegate;                // 0x0A28(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   UpdateAnalogCursorStateDelegate;                   // 0x0A38(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnPlayerInfoUpdateDel;                             // 0x0A48(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnSpectatorCameraModeChange;                       // 0x0A58(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnSpectatorToggleControllerCursor;                 // 0x0A68(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnSetHudVisibilityDel;                             // 0x0A78(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TArray<struct FOrionSpectatorHUDPlayerInfo>   RedTeamPlayerInfo;                                 // 0x0A88(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FOrionSpectatorHUDPlayerInfo>   BlueTeamPlayerInfo;                                // 0x0A98(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AA8[0x28];                                     // 0x0AA8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetCurrentMatchTime();
	void OnAnselEvent__DelegateSignature();
	void OnPlayerInfoUpdateDelegate__DelegateSignature(EOrionTeam TeamNum, int32 PlayerIndex, const struct FOrionSpectatorHUDPlayerInfo& NewPlayerInfo);
	void OnSetHudVisibility__DelegateSignature(bool bMainVisible, bool bIndicatorsVisible);
	void OnSpectatorCameraModeChange__DelegateSignature(ESpectatorCameraType NewCameraMode);
	void OnSpectatorToggleControllerCursor__DelegateSignature();
	void OnSpectatorWatchedHeroChange__DelegateSignature(EOrionTeam HeroTeam, int32 HeroIndex);

	EOrionTeam GetEnemyTeam() const;
	const struct FOrionBaseHUDPlayerInfo GetHUDPlayerInfo() const;
	EOrionTeam GetMyTeam() const;
	struct FOrionSpectatorHUDPlayerInfo GetSpectatorHUDPlayerInfo(EOrionTeam Team, int32 Index_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpectatorHUDContext">();
	}
	static class USpectatorHUDContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpectatorHUDContext>();
	}
};
static_assert(alignof(USpectatorHUDContext) == 0x000008, "Wrong alignment on USpectatorHUDContext");
static_assert(sizeof(USpectatorHUDContext) == 0x000AD0, "Wrong size on USpectatorHUDContext");
static_assert(offsetof(USpectatorHUDContext, OnSpectatorWatchedHeroChange) == 0x0009E8, "Member 'USpectatorHUDContext::OnSpectatorWatchedHeroChange' has a wrong offset!");
static_assert(offsetof(USpectatorHUDContext, OnAnselSessionStartDelegate) == 0x0009F8, "Member 'USpectatorHUDContext::OnAnselSessionStartDelegate' has a wrong offset!");
static_assert(offsetof(USpectatorHUDContext, OnAnselSessionEndDelegate) == 0x000A08, "Member 'USpectatorHUDContext::OnAnselSessionEndDelegate' has a wrong offset!");
static_assert(offsetof(USpectatorHUDContext, OnAnselMultiPartCaptureStartDelegate) == 0x000A18, "Member 'USpectatorHUDContext::OnAnselMultiPartCaptureStartDelegate' has a wrong offset!");
static_assert(offsetof(USpectatorHUDContext, OnAnselMultiPartCaptureEndDelegate) == 0x000A28, "Member 'USpectatorHUDContext::OnAnselMultiPartCaptureEndDelegate' has a wrong offset!");
static_assert(offsetof(USpectatorHUDContext, UpdateAnalogCursorStateDelegate) == 0x000A38, "Member 'USpectatorHUDContext::UpdateAnalogCursorStateDelegate' has a wrong offset!");
static_assert(offsetof(USpectatorHUDContext, OnPlayerInfoUpdateDel) == 0x000A48, "Member 'USpectatorHUDContext::OnPlayerInfoUpdateDel' has a wrong offset!");
static_assert(offsetof(USpectatorHUDContext, OnSpectatorCameraModeChange) == 0x000A58, "Member 'USpectatorHUDContext::OnSpectatorCameraModeChange' has a wrong offset!");
static_assert(offsetof(USpectatorHUDContext, OnSpectatorToggleControllerCursor) == 0x000A68, "Member 'USpectatorHUDContext::OnSpectatorToggleControllerCursor' has a wrong offset!");
static_assert(offsetof(USpectatorHUDContext, OnSetHudVisibilityDel) == 0x000A78, "Member 'USpectatorHUDContext::OnSetHudVisibilityDel' has a wrong offset!");
static_assert(offsetof(USpectatorHUDContext, RedTeamPlayerInfo) == 0x000A88, "Member 'USpectatorHUDContext::RedTeamPlayerInfo' has a wrong offset!");
static_assert(offsetof(USpectatorHUDContext, BlueTeamPlayerInfo) == 0x000A98, "Member 'USpectatorHUDContext::BlueTeamPlayerInfo' has a wrong offset!");

// Class BlueprintContext.StoreContext
// 0x0098 (0x00D8 - 0x0040)
class UStoreContext final : public UPlayerAwareContext
{
public:
	class FString                                 FoundersPackStoreCategory;                         // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnCurrencyChanged;                                 // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnRebuildStorefront;                               // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnCatalogFlushed;                                  // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FOrionDailyRewardInfo>          DailyRewards;                                      // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnDailyRewardsUpdated;                             // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(class UWidget* WebWidget, const class FString& OfferId)> DisplayPurchaseWidget;                             // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPrivate)
	TDelegate<void()>                             DismissPurchaseWidget;                             // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void CancelEpicPurchasingDisplay();
	void CheckForStuff();
	void FlushStoreCatalogCache();
	void OnEpicPurchasingWidgetDismissed__DelegateSignature();
	void OnEpicPurchasingWidgetDisplay__DelegateSignature(class UWidget* WebWidget, const class FString& OfferId);
	void OnOrionCatalogChanged__DelegateSignature();
	void OnPlatformStoreClosed__DelegateSignature(bool bPurchased);
	void RegisterForEpicPurchasingDisplay(const TDelegate<void(class UWidget* WebWidget, const class FString& OfferId)>& DisplayCallback, const TDelegate<void()>& DismissCallback);
	void ReportEnterRealMoneyStore();
	void ReportExitRealMoneyStore();
	bool ReportNoOffersAvailable();
	void ShowPlatformStore(const class FString& Category, const TDelegate<void(bool bPurchased)>& OnClosedDelegate);
	void ToggleCurrencyUpdate(bool bBroadcastCurrencyChange);

	bool BP_GetBannerOffer(class UOrionMcpBannerItemDefinition* Banner, struct FStoreOfferBP* BannerOffer) const;
	bool BP_GetSkinOffer(class UOrionSkinItemDefinition* Skin, struct FStoreOfferBP* SkinOffer) const;
	bool CanAfford(const struct FOrionStorePrice& Price, int32 Quantity) const;
	void GetBannerOffers(TArray<struct FStoreOfferBP>* BannerOffers) const;
	void GetBoostOffers(TArray<struct FStoreOfferBP>* BoostOffers, bool bShowIneligibleOffers) const;
	bool GetBundleByTag(const class FString& BundleTag, struct FStoreOfferBP* StoreOffer) const;
	bool GetBundleForHero(const class UOrionHeroData* Hero, const class FString& BundleTag, struct FStoreOfferBP* StoreOffer) const;
	void GetBundleOffers(TArray<struct FStoreOfferBP>* BundleOffers, bool bShowIneligibleOffers) const;
	void GetCardpackOffers(TArray<struct FStoreOfferBP>* CardpackOffers, bool bShowIneligibleOffers) const;
	void GetCrateOffers(TArray<struct FStoreOfferBP>* CrateOffers, bool bShowIneligibleOffers) const;
	int32 GetCurrencyBalance(EOrionCurrencyType Type) const;
	bool GetDailyRewardInfo(TArray<struct FOrionDailyRewardInfo>* UpcomingRewards) const;
	void GetDeckOffers(TArray<struct FStoreOfferBP>* DeckOffers, bool bShowIneligibleOffers) const;
	void GetEmoteOffers(TArray<struct FStoreOfferBP>* EmoteOffers, bool bShowIneligibleOffers) const;
	void GetFounderOffers(TArray<struct FStoreOfferBP>* FounderOffers) const;
	bool GetHeroOffer(const class FString& HeroPersistentName, struct FStoreOfferBP* HeroOffer) const;
	void GetHeroOffers(TArray<struct FStoreOfferBP>* HeroOffers, bool bShowIneligibleOffers) const;
	int32 GetMtxCurrency() const;
	void GetMtxOffers(TArray<struct FStoreOfferBP>* MtxOffers, bool bShowIneligibleOffers) const;
	bool GetOffer(const class UOrionMcpItemDefinition* ItemDefinition, struct FStoreOfferBP* StoreOffer) const;
	void GetSkinOffers(TArray<struct FStoreOfferBP>* SkinOffers, bool bShowIneligibleOffers) const;
	int32 GetTimeCurrency() const;
	struct FTimespan GetTimeUntilNextDailyReward() const;
	void GetVaultKeyOffers(TArray<struct FStoreOfferBP>* VaultKeyOffers, bool bShowIneligibleOffers) const;
	bool IsCatalogDownloadInProgress() const;
	bool IsDailyRewardAvailable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreContext">();
	}
	static class UStoreContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreContext>();
	}
};
static_assert(alignof(UStoreContext) == 0x000008, "Wrong alignment on UStoreContext");
static_assert(sizeof(UStoreContext) == 0x0000D8, "Wrong size on UStoreContext");
static_assert(offsetof(UStoreContext, FoundersPackStoreCategory) == 0x000040, "Member 'UStoreContext::FoundersPackStoreCategory' has a wrong offset!");
static_assert(offsetof(UStoreContext, OnCurrencyChanged) == 0x000050, "Member 'UStoreContext::OnCurrencyChanged' has a wrong offset!");
static_assert(offsetof(UStoreContext, OnRebuildStorefront) == 0x000060, "Member 'UStoreContext::OnRebuildStorefront' has a wrong offset!");
static_assert(offsetof(UStoreContext, OnCatalogFlushed) == 0x000070, "Member 'UStoreContext::OnCatalogFlushed' has a wrong offset!");
static_assert(offsetof(UStoreContext, DailyRewards) == 0x000080, "Member 'UStoreContext::DailyRewards' has a wrong offset!");
static_assert(offsetof(UStoreContext, OnDailyRewardsUpdated) == 0x000090, "Member 'UStoreContext::OnDailyRewardsUpdated' has a wrong offset!");
static_assert(offsetof(UStoreContext, DisplayPurchaseWidget) == 0x0000B8, "Member 'UStoreContext::DisplayPurchaseWidget' has a wrong offset!");
static_assert(offsetof(UStoreContext, DismissPurchaseWidget) == 0x0000C8, "Member 'UStoreContext::DismissPurchaseWidget' has a wrong offset!");

// Class BlueprintContext.OrionAsyncAction_RefreshCatalog
// 0x0028 (0x0050 - 0x0028)
class UOrionAsyncAction_RefreshCatalog final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnSuccess;                                         // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnError;                                           // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UStoreContext*                          StoreContext;                                      // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UOrionAsyncAction_RefreshCatalog* RefreshCatalog(class UStoreContext* InStoreContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAsyncAction_RefreshCatalog">();
	}
	static class UOrionAsyncAction_RefreshCatalog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAsyncAction_RefreshCatalog>();
	}
};
static_assert(alignof(UOrionAsyncAction_RefreshCatalog) == 0x000008, "Wrong alignment on UOrionAsyncAction_RefreshCatalog");
static_assert(sizeof(UOrionAsyncAction_RefreshCatalog) == 0x000050, "Wrong size on UOrionAsyncAction_RefreshCatalog");
static_assert(offsetof(UOrionAsyncAction_RefreshCatalog, OnSuccess) == 0x000028, "Member 'UOrionAsyncAction_RefreshCatalog::OnSuccess' has a wrong offset!");
static_assert(offsetof(UOrionAsyncAction_RefreshCatalog, OnError) == 0x000038, "Member 'UOrionAsyncAction_RefreshCatalog::OnError' has a wrong offset!");
static_assert(offsetof(UOrionAsyncAction_RefreshCatalog, StoreContext) == 0x000048, "Member 'UOrionAsyncAction_RefreshCatalog::StoreContext' has a wrong offset!");

// Class BlueprintContext.TeamCommsContext
// 0x00A0 (0x00D0 - 0x0030)
class UTeamCommsContext final : public UBlueprintContextBase
{
public:
	uint8                                         Pad_30[0xA0];                                      // 0x0030(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamCommsContext">();
	}
	static class UTeamCommsContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamCommsContext>();
	}
};
static_assert(alignof(UTeamCommsContext) == 0x000008, "Wrong alignment on UTeamCommsContext");
static_assert(sizeof(UTeamCommsContext) == 0x0000D0, "Wrong size on UTeamCommsContext");

// Class BlueprintContext.TencentContext
// 0x0060 (0x0090 - 0x0030)
class UTencentContext final : public UBlueprintContextBase
{
public:
	uint8                                         Pad_30[0x60];                                      // 0x0030(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSensitivityBrowserClosed();
	void OnSensitivityBrowserWidgetDisplay__DelegateSignature(class UWidget* WebWidget, const class FText& Title, const class FText& Text);
	void OnTencentLoginComplete();
	void OpenSensitivitySettingsBrowser(ETencentSensitivityType SensitivityType);
	void RegisterForSensitivityBrowserDisplay(const TDelegate<void(class UWidget* WebWidget, class FText Title, class FText Text)>& DisplayCallback);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TencentContext">();
	}
	static class UTencentContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTencentContext>();
	}
};
static_assert(alignof(UTencentContext) == 0x000008, "Wrong alignment on UTencentContext");
static_assert(sizeof(UTencentContext) == 0x000090, "Wrong size on UTencentContext");

// Class BlueprintContext.TooltipContext
// 0x00A8 (0x00E8 - 0x0040)
class UTooltipContext final : public UPlayerAwareContext
{
public:
	struct FOrionTooltipHelper                    TooltipHelper;                                     // 0x0040(0x00A8)(NativeAccessSpecifierPrivate)

public:
	void CalculateHeroTooltip(class UOrionHeroData* InHeroData, const EOrionAbilityBinding InAbilityKeyBind, const int32 InAbilityLevel, const class UAbilitySystemComponent* ASC);

	void GetField(class FName InFieldName, class FText* FieldText) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TooltipContext">();
	}
	static class UTooltipContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTooltipContext>();
	}
};
static_assert(alignof(UTooltipContext) == 0x000008, "Wrong alignment on UTooltipContext");
static_assert(sizeof(UTooltipContext) == 0x0000E8, "Wrong size on UTooltipContext");
static_assert(offsetof(UTooltipContext, TooltipHelper) == 0x000040, "Member 'UTooltipContext::TooltipHelper' has a wrong offset!");

// Class BlueprintContext.UserFeedbackContext
// 0x0048 (0x0078 - 0x0030)
class UUserFeedbackContext final : public UBlueprintContextBase
{
public:
	UMulticastDelegateProperty_                   OnFeedbackScreenshotReady;                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x38];                                      // 0x0040(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinishTakeScreenshotAndInitializeFeedback();
	void SendFeedback(const class FText& Body);
	void TakeScreenshotAndInitializeFeedback(EFeedbackType FeedbackType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserFeedbackContext">();
	}
	static class UUserFeedbackContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserFeedbackContext>();
	}
};
static_assert(alignof(UUserFeedbackContext) == 0x000008, "Wrong alignment on UUserFeedbackContext");
static_assert(sizeof(UUserFeedbackContext) == 0x000078, "Wrong size on UUserFeedbackContext");
static_assert(offsetof(UUserFeedbackContext, OnFeedbackScreenshotReady) == 0x000030, "Member 'UUserFeedbackContext::OnFeedbackScreenshotReady' has a wrong offset!");

// Class BlueprintContext.VideoContext
// 0x0000 (0x0030 - 0x0030)
class UVideoContext final : public UBlueprintContextBase
{
public:
	bool IsFullscreen() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VideoContext">();
	}
	static class UVideoContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVideoContext>();
	}
};
static_assert(alignof(UVideoContext) == 0x000008, "Wrong alignment on UVideoContext");
static_assert(sizeof(UVideoContext) == 0x000030, "Wrong size on UVideoContext");

}

