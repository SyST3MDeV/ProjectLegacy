#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: OrionGame

#include "Basic.hpp"

#include "OrionGame_structs.hpp"
#include "OnlineSubsystemUtils_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "Engine_structs.hpp"
#include "InputCore_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "FunctionalTesting_structs.hpp"
#include "SlateCore_structs.hpp"
#include "BlueprintContext_structs.hpp"
#include "AIModule_structs.hpp"
#include "Slate_structs.hpp"
#include "McpProfileSys_structs.hpp"


namespace SDK::Params
{

// Function OrionGame.FunctionalTestPhase.GetCleanupStatus
// 0x0001 (0x0001 - 0x0000)
struct FunctionalTestPhase_GetCleanupStatus final
{
public:
	EFunctionalTestResult                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FunctionalTestPhase_GetCleanupStatus) == 0x000001, "Wrong alignment on FunctionalTestPhase_GetCleanupStatus");
static_assert(sizeof(FunctionalTestPhase_GetCleanupStatus) == 0x000001, "Wrong size on FunctionalTestPhase_GetCleanupStatus");
static_assert(offsetof(FunctionalTestPhase_GetCleanupStatus, ReturnValue) == 0x000000, "Member 'FunctionalTestPhase_GetCleanupStatus::ReturnValue' has a wrong offset!");

// Function OrionGame.FunctionalTestPhase.GetExecuteStatus
// 0x0001 (0x0001 - 0x0000)
struct FunctionalTestPhase_GetExecuteStatus final
{
public:
	EFunctionalTestResult                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FunctionalTestPhase_GetExecuteStatus) == 0x000001, "Wrong alignment on FunctionalTestPhase_GetExecuteStatus");
static_assert(sizeof(FunctionalTestPhase_GetExecuteStatus) == 0x000001, "Wrong size on FunctionalTestPhase_GetExecuteStatus");
static_assert(offsetof(FunctionalTestPhase_GetExecuteStatus, ReturnValue) == 0x000000, "Member 'FunctionalTestPhase_GetExecuteStatus::ReturnValue' has a wrong offset!");

// Function OrionGame.FunctionalTestPhase.GetSetupStatus
// 0x0001 (0x0001 - 0x0000)
struct FunctionalTestPhase_GetSetupStatus final
{
public:
	EFunctionalTestResult                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FunctionalTestPhase_GetSetupStatus) == 0x000001, "Wrong alignment on FunctionalTestPhase_GetSetupStatus");
static_assert(sizeof(FunctionalTestPhase_GetSetupStatus) == 0x000001, "Wrong size on FunctionalTestPhase_GetSetupStatus");
static_assert(offsetof(FunctionalTestPhase_GetSetupStatus, ReturnValue) == 0x000000, "Member 'FunctionalTestPhase_GetSetupStatus::ReturnValue' has a wrong offset!");

// Function OrionGame.FunctionalTestPhase.GetTest
// 0x0008 (0x0008 - 0x0000)
struct FunctionalTestPhase_GetTest final
{
public:
	class APhasedFunctionalTest*                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FunctionalTestPhase_GetTest) == 0x000008, "Wrong alignment on FunctionalTestPhase_GetTest");
static_assert(sizeof(FunctionalTestPhase_GetTest) == 0x000008, "Wrong size on FunctionalTestPhase_GetTest");
static_assert(offsetof(FunctionalTestPhase_GetTest, ReturnValue) == 0x000000, "Member 'FunctionalTestPhase_GetTest::ReturnValue' has a wrong offset!");

// Function OrionGame.FunctionalTestPhase.HasEncounteredError
// 0x0001 (0x0001 - 0x0000)
struct FunctionalTestPhase_HasEncounteredError final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FunctionalTestPhase_HasEncounteredError) == 0x000001, "Wrong alignment on FunctionalTestPhase_HasEncounteredError");
static_assert(sizeof(FunctionalTestPhase_HasEncounteredError) == 0x000001, "Wrong size on FunctionalTestPhase_HasEncounteredError");
static_assert(offsetof(FunctionalTestPhase_HasEncounteredError, ReturnValue) == 0x000000, "Member 'FunctionalTestPhase_HasEncounteredError::ReturnValue' has a wrong offset!");

// Function OrionGame.FunctionalTestPhase.HasFailed
// 0x0001 (0x0001 - 0x0000)
struct FunctionalTestPhase_HasFailed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FunctionalTestPhase_HasFailed) == 0x000001, "Wrong alignment on FunctionalTestPhase_HasFailed");
static_assert(sizeof(FunctionalTestPhase_HasFailed) == 0x000001, "Wrong size on FunctionalTestPhase_HasFailed");
static_assert(offsetof(FunctionalTestPhase_HasFailed, ReturnValue) == 0x000000, "Member 'FunctionalTestPhase_HasFailed::ReturnValue' has a wrong offset!");

// Function OrionGame.FunctionalTestPhase.IsCleanupFinished
// 0x0001 (0x0001 - 0x0000)
struct FunctionalTestPhase_IsCleanupFinished final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FunctionalTestPhase_IsCleanupFinished) == 0x000001, "Wrong alignment on FunctionalTestPhase_IsCleanupFinished");
static_assert(sizeof(FunctionalTestPhase_IsCleanupFinished) == 0x000001, "Wrong size on FunctionalTestPhase_IsCleanupFinished");
static_assert(offsetof(FunctionalTestPhase_IsCleanupFinished, ReturnValue) == 0x000000, "Member 'FunctionalTestPhase_IsCleanupFinished::ReturnValue' has a wrong offset!");

// Function OrionGame.FunctionalTestPhase.IsExecuteFinished
// 0x0001 (0x0001 - 0x0000)
struct FunctionalTestPhase_IsExecuteFinished final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FunctionalTestPhase_IsExecuteFinished) == 0x000001, "Wrong alignment on FunctionalTestPhase_IsExecuteFinished");
static_assert(sizeof(FunctionalTestPhase_IsExecuteFinished) == 0x000001, "Wrong size on FunctionalTestPhase_IsExecuteFinished");
static_assert(offsetof(FunctionalTestPhase_IsExecuteFinished, ReturnValue) == 0x000000, "Member 'FunctionalTestPhase_IsExecuteFinished::ReturnValue' has a wrong offset!");

// Function OrionGame.FunctionalTestPhase.IsPhaseRunningInEditor
// 0x0001 (0x0001 - 0x0000)
struct FunctionalTestPhase_IsPhaseRunningInEditor final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FunctionalTestPhase_IsPhaseRunningInEditor) == 0x000001, "Wrong alignment on FunctionalTestPhase_IsPhaseRunningInEditor");
static_assert(sizeof(FunctionalTestPhase_IsPhaseRunningInEditor) == 0x000001, "Wrong size on FunctionalTestPhase_IsPhaseRunningInEditor");
static_assert(offsetof(FunctionalTestPhase_IsPhaseRunningInEditor, ReturnValue) == 0x000000, "Member 'FunctionalTestPhase_IsPhaseRunningInEditor::ReturnValue' has a wrong offset!");

// Function OrionGame.FunctionalTestPhase.IsSetupFinished
// 0x0001 (0x0001 - 0x0000)
struct FunctionalTestPhase_IsSetupFinished final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FunctionalTestPhase_IsSetupFinished) == 0x000001, "Wrong alignment on FunctionalTestPhase_IsSetupFinished");
static_assert(sizeof(FunctionalTestPhase_IsSetupFinished) == 0x000001, "Wrong size on FunctionalTestPhase_IsSetupFinished");
static_assert(offsetof(FunctionalTestPhase_IsSetupFinished, ReturnValue) == 0x000000, "Member 'FunctionalTestPhase_IsSetupFinished::ReturnValue' has a wrong offset!");

// Function OrionGame.FunctionalTestPhase.LogError
// 0x0010 (0x0010 - 0x0000)
struct FunctionalTestPhase_LogError final
{
public:
	class FString                                 MESSAGE;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FunctionalTestPhase_LogError) == 0x000008, "Wrong alignment on FunctionalTestPhase_LogError");
static_assert(sizeof(FunctionalTestPhase_LogError) == 0x000010, "Wrong size on FunctionalTestPhase_LogError");
static_assert(offsetof(FunctionalTestPhase_LogError, MESSAGE) == 0x000000, "Member 'FunctionalTestPhase_LogError::MESSAGE' has a wrong offset!");

// Function OrionGame.FunctionalTestPhase.LogInfo
// 0x0010 (0x0010 - 0x0000)
struct FunctionalTestPhase_LogInfo final
{
public:
	class FString                                 MESSAGE;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FunctionalTestPhase_LogInfo) == 0x000008, "Wrong alignment on FunctionalTestPhase_LogInfo");
static_assert(sizeof(FunctionalTestPhase_LogInfo) == 0x000010, "Wrong size on FunctionalTestPhase_LogInfo");
static_assert(offsetof(FunctionalTestPhase_LogInfo, MESSAGE) == 0x000000, "Member 'FunctionalTestPhase_LogInfo::MESSAGE' has a wrong offset!");

// Function OrionGame.FunctionalTestPhase.LogVerbose
// 0x0010 (0x0010 - 0x0000)
struct FunctionalTestPhase_LogVerbose final
{
public:
	class FString                                 MESSAGE;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FunctionalTestPhase_LogVerbose) == 0x000008, "Wrong alignment on FunctionalTestPhase_LogVerbose");
static_assert(sizeof(FunctionalTestPhase_LogVerbose) == 0x000010, "Wrong size on FunctionalTestPhase_LogVerbose");
static_assert(offsetof(FunctionalTestPhase_LogVerbose, MESSAGE) == 0x000000, "Member 'FunctionalTestPhase_LogVerbose::MESSAGE' has a wrong offset!");

// Function OrionGame.FunctionalTestPhase.LogWarning
// 0x0010 (0x0010 - 0x0000)
struct FunctionalTestPhase_LogWarning final
{
public:
	class FString                                 MESSAGE;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FunctionalTestPhase_LogWarning) == 0x000008, "Wrong alignment on FunctionalTestPhase_LogWarning");
static_assert(sizeof(FunctionalTestPhase_LogWarning) == 0x000010, "Wrong size on FunctionalTestPhase_LogWarning");
static_assert(offsetof(FunctionalTestPhase_LogWarning, MESSAGE) == 0x000000, "Member 'FunctionalTestPhase_LogWarning::MESSAGE' has a wrong offset!");

// Function OrionGame.FunctionalTestPhase.SetCleanupStatus
// 0x0001 (0x0001 - 0x0000)
struct FunctionalTestPhase_SetCleanupStatus final
{
public:
	EFunctionalTestResult                         Status;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FunctionalTestPhase_SetCleanupStatus) == 0x000001, "Wrong alignment on FunctionalTestPhase_SetCleanupStatus");
static_assert(sizeof(FunctionalTestPhase_SetCleanupStatus) == 0x000001, "Wrong size on FunctionalTestPhase_SetCleanupStatus");
static_assert(offsetof(FunctionalTestPhase_SetCleanupStatus, Status) == 0x000000, "Member 'FunctionalTestPhase_SetCleanupStatus::Status' has a wrong offset!");

// Function OrionGame.FunctionalTestPhase.SetExecuteStatus
// 0x0001 (0x0001 - 0x0000)
struct FunctionalTestPhase_SetExecuteStatus final
{
public:
	EFunctionalTestResult                         Status;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FunctionalTestPhase_SetExecuteStatus) == 0x000001, "Wrong alignment on FunctionalTestPhase_SetExecuteStatus");
static_assert(sizeof(FunctionalTestPhase_SetExecuteStatus) == 0x000001, "Wrong size on FunctionalTestPhase_SetExecuteStatus");
static_assert(offsetof(FunctionalTestPhase_SetExecuteStatus, Status) == 0x000000, "Member 'FunctionalTestPhase_SetExecuteStatus::Status' has a wrong offset!");

// Function OrionGame.FunctionalTestPhase.SetSetupStatus
// 0x0001 (0x0001 - 0x0000)
struct FunctionalTestPhase_SetSetupStatus final
{
public:
	EFunctionalTestResult                         Status;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FunctionalTestPhase_SetSetupStatus) == 0x000001, "Wrong alignment on FunctionalTestPhase_SetSetupStatus");
static_assert(sizeof(FunctionalTestPhase_SetSetupStatus) == 0x000001, "Wrong size on FunctionalTestPhase_SetSetupStatus");
static_assert(offsetof(FunctionalTestPhase_SetSetupStatus, Status) == 0x000000, "Member 'FunctionalTestPhase_SetSetupStatus::Status' has a wrong offset!");

// Function OrionGame.AITeamComm.RequestAITeamComm
// 0x0010 (0x0010 - 0x0000)
struct AITeamComm_RequestAITeamComm final
{
public:
	const class AOrionAIBot*                      BotController;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAITeamCommEvent                              Event;                                             // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreTimeouts;                                   // 0x0009(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TriggerDelay;                                      // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AITeamComm_RequestAITeamComm) == 0x000008, "Wrong alignment on AITeamComm_RequestAITeamComm");
static_assert(sizeof(AITeamComm_RequestAITeamComm) == 0x000010, "Wrong size on AITeamComm_RequestAITeamComm");
static_assert(offsetof(AITeamComm_RequestAITeamComm, BotController) == 0x000000, "Member 'AITeamComm_RequestAITeamComm::BotController' has a wrong offset!");
static_assert(offsetof(AITeamComm_RequestAITeamComm, Event) == 0x000008, "Member 'AITeamComm_RequestAITeamComm::Event' has a wrong offset!");
static_assert(offsetof(AITeamComm_RequestAITeamComm, bIgnoreTimeouts) == 0x000009, "Member 'AITeamComm_RequestAITeamComm::bIgnoreTimeouts' has a wrong offset!");
static_assert(offsetof(AITeamComm_RequestAITeamComm, TriggerDelay) == 0x00000C, "Member 'AITeamComm_RequestAITeamComm::TriggerDelay' has a wrong offset!");

// Function OrionGame.FunctionalTestCondition.GetTest
// 0x0008 (0x0008 - 0x0000)
struct FunctionalTestCondition_GetTest final
{
public:
	class APhasedFunctionalTest*                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FunctionalTestCondition_GetTest) == 0x000008, "Wrong alignment on FunctionalTestCondition_GetTest");
static_assert(sizeof(FunctionalTestCondition_GetTest) == 0x000008, "Wrong size on FunctionalTestCondition_GetTest");
static_assert(offsetof(FunctionalTestCondition_GetTest, ReturnValue) == 0x000000, "Member 'FunctionalTestCondition_GetTest::ReturnValue' has a wrong offset!");

// Function OrionGame.AIInfluenceSourceComponent.K2_SetInfluenceValues
// 0x0008 (0x0008 - 0x0000)
struct AIInfluenceSourceComponent_K2_SetInfluenceValues final
{
public:
	float                                         Radius;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InStrength;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIInfluenceSourceComponent_K2_SetInfluenceValues) == 0x000004, "Wrong alignment on AIInfluenceSourceComponent_K2_SetInfluenceValues");
static_assert(sizeof(AIInfluenceSourceComponent_K2_SetInfluenceValues) == 0x000008, "Wrong size on AIInfluenceSourceComponent_K2_SetInfluenceValues");
static_assert(offsetof(AIInfluenceSourceComponent_K2_SetInfluenceValues, Radius) == 0x000000, "Member 'AIInfluenceSourceComponent_K2_SetInfluenceValues::Radius' has a wrong offset!");
static_assert(offsetof(AIInfluenceSourceComponent_K2_SetInfluenceValues, InStrength) == 0x000004, "Member 'AIInfluenceSourceComponent_K2_SetInfluenceValues::InStrength' has a wrong offset!");

// Function OrionGame.OrionGameMode_Base.ChangeTeam
// 0x0010 (0x0010 - 0x0000)
struct OrionGameMode_Base_ChangeTeam final
{
public:
	class AController*                            InController;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    TeamIndex;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionGameMode_Base_ChangeTeam) == 0x000008, "Wrong alignment on OrionGameMode_Base_ChangeTeam");
static_assert(sizeof(OrionGameMode_Base_ChangeTeam) == 0x000010, "Wrong size on OrionGameMode_Base_ChangeTeam");
static_assert(offsetof(OrionGameMode_Base_ChangeTeam, InController) == 0x000000, "Member 'OrionGameMode_Base_ChangeTeam::InController' has a wrong offset!");
static_assert(offsetof(OrionGameMode_Base_ChangeTeam, TeamIndex) == 0x000008, "Member 'OrionGameMode_Base_ChangeTeam::TeamIndex' has a wrong offset!");
static_assert(offsetof(OrionGameMode_Base_ChangeTeam, ReturnValue) == 0x000009, "Member 'OrionGameMode_Base_ChangeTeam::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameMode_Base.ExecuteGameplayCue
// 0x00C8 (0x00C8 - 0x0000)
struct OrionGameMode_Base_ExecuteGameplayCue final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 Parameters;                                        // 0x0008(0x00B8)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x00C0(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameMode_Base_ExecuteGameplayCue) == 0x000008, "Wrong alignment on OrionGameMode_Base_ExecuteGameplayCue");
static_assert(sizeof(OrionGameMode_Base_ExecuteGameplayCue) == 0x0000C8, "Wrong size on OrionGameMode_Base_ExecuteGameplayCue");
static_assert(offsetof(OrionGameMode_Base_ExecuteGameplayCue, GameplayCueTag) == 0x000000, "Member 'OrionGameMode_Base_ExecuteGameplayCue::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(OrionGameMode_Base_ExecuteGameplayCue, Parameters) == 0x000008, "Member 'OrionGameMode_Base_ExecuteGameplayCue::Parameters' has a wrong offset!");
static_assert(offsetof(OrionGameMode_Base_ExecuteGameplayCue, TargetActor) == 0x0000C0, "Member 'OrionGameMode_Base_ExecuteGameplayCue::TargetActor' has a wrong offset!");

// Function OrionGame.OrionGameMode_MOBA.ForceMatchWinCondition
// 0x0001 (0x0001 - 0x0000)
struct OrionGameMode_MOBA_ForceMatchWinCondition final
{
public:
	EOrionTeam                                    TeamNum;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameMode_MOBA_ForceMatchWinCondition) == 0x000001, "Wrong alignment on OrionGameMode_MOBA_ForceMatchWinCondition");
static_assert(sizeof(OrionGameMode_MOBA_ForceMatchWinCondition) == 0x000001, "Wrong size on OrionGameMode_MOBA_ForceMatchWinCondition");
static_assert(offsetof(OrionGameMode_MOBA_ForceMatchWinCondition, TeamNum) == 0x000000, "Member 'OrionGameMode_MOBA_ForceMatchWinCondition::TeamNum' has a wrong offset!");

// Function OrionGame.OrionGameMode_MOBA.GetWinningTeamNum
// 0x0001 (0x0001 - 0x0000)
struct OrionGameMode_MOBA_GetWinningTeamNum final
{
public:
	EOrionTeam                                    ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameMode_MOBA_GetWinningTeamNum) == 0x000001, "Wrong alignment on OrionGameMode_MOBA_GetWinningTeamNum");
static_assert(sizeof(OrionGameMode_MOBA_GetWinningTeamNum) == 0x000001, "Wrong size on OrionGameMode_MOBA_GetWinningTeamNum");
static_assert(offsetof(OrionGameMode_MOBA_GetWinningTeamNum, ReturnValue) == 0x000000, "Member 'OrionGameMode_MOBA_GetWinningTeamNum::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameMode_MOBA.IsMatchObjectiveCompleted
// 0x0001 (0x0001 - 0x0000)
struct OrionGameMode_MOBA_IsMatchObjectiveCompleted final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameMode_MOBA_IsMatchObjectiveCompleted) == 0x000001, "Wrong alignment on OrionGameMode_MOBA_IsMatchObjectiveCompleted");
static_assert(sizeof(OrionGameMode_MOBA_IsMatchObjectiveCompleted) == 0x000001, "Wrong size on OrionGameMode_MOBA_IsMatchObjectiveCompleted");
static_assert(offsetof(OrionGameMode_MOBA_IsMatchObjectiveCompleted, ReturnValue) == 0x000000, "Member 'OrionGameMode_MOBA_IsMatchObjectiveCompleted::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameMode_MOBA.ReceiveCoreKilled
// 0x0010 (0x0010 - 0x0000)
struct OrionGameMode_MOBA_ReceiveCoreKilled final
{
public:
	class AController*                            Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionDamageableActor*                  KilledCore;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameMode_MOBA_ReceiveCoreKilled) == 0x000008, "Wrong alignment on OrionGameMode_MOBA_ReceiveCoreKilled");
static_assert(sizeof(OrionGameMode_MOBA_ReceiveCoreKilled) == 0x000010, "Wrong size on OrionGameMode_MOBA_ReceiveCoreKilled");
static_assert(offsetof(OrionGameMode_MOBA_ReceiveCoreKilled, Killer) == 0x000000, "Member 'OrionGameMode_MOBA_ReceiveCoreKilled::Killer' has a wrong offset!");
static_assert(offsetof(OrionGameMode_MOBA_ReceiveCoreKilled, KilledCore) == 0x000008, "Member 'OrionGameMode_MOBA_ReceiveCoreKilled::KilledCore' has a wrong offset!");

// Function OrionGame.OrionGameMode_MOBA.ReceiveInhibitorKilled
// 0x0010 (0x0010 - 0x0000)
struct OrionGameMode_MOBA_ReceiveInhibitorKilled final
{
public:
	class AController*                            Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionDamageableActor*                  KilledInhibitor;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameMode_MOBA_ReceiveInhibitorKilled) == 0x000008, "Wrong alignment on OrionGameMode_MOBA_ReceiveInhibitorKilled");
static_assert(sizeof(OrionGameMode_MOBA_ReceiveInhibitorKilled) == 0x000010, "Wrong size on OrionGameMode_MOBA_ReceiveInhibitorKilled");
static_assert(offsetof(OrionGameMode_MOBA_ReceiveInhibitorKilled, Killer) == 0x000000, "Member 'OrionGameMode_MOBA_ReceiveInhibitorKilled::Killer' has a wrong offset!");
static_assert(offsetof(OrionGameMode_MOBA_ReceiveInhibitorKilled, KilledInhibitor) == 0x000008, "Member 'OrionGameMode_MOBA_ReceiveInhibitorKilled::KilledInhibitor' has a wrong offset!");

// Function OrionGame.OrionGameMode_MOBA.ReceiveMinionKilled
// 0x0018 (0x0018 - 0x0000)
struct OrionGameMode_MOBA_ReceiveMinionKilled final
{
public:
	class AController*                            Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            KilledMinion;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  KilledPawn;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameMode_MOBA_ReceiveMinionKilled) == 0x000008, "Wrong alignment on OrionGameMode_MOBA_ReceiveMinionKilled");
static_assert(sizeof(OrionGameMode_MOBA_ReceiveMinionKilled) == 0x000018, "Wrong size on OrionGameMode_MOBA_ReceiveMinionKilled");
static_assert(offsetof(OrionGameMode_MOBA_ReceiveMinionKilled, Killer) == 0x000000, "Member 'OrionGameMode_MOBA_ReceiveMinionKilled::Killer' has a wrong offset!");
static_assert(offsetof(OrionGameMode_MOBA_ReceiveMinionKilled, KilledMinion) == 0x000008, "Member 'OrionGameMode_MOBA_ReceiveMinionKilled::KilledMinion' has a wrong offset!");
static_assert(offsetof(OrionGameMode_MOBA_ReceiveMinionKilled, KilledPawn) == 0x000010, "Member 'OrionGameMode_MOBA_ReceiveMinionKilled::KilledPawn' has a wrong offset!");

// Function OrionGame.OrionGameMode_MOBA.ReceiveOtherStructureKilled
// 0x0010 (0x0010 - 0x0000)
struct OrionGameMode_MOBA_ReceiveOtherStructureKilled final
{
public:
	class AController*                            Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionDamageableActor*                  KilledActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameMode_MOBA_ReceiveOtherStructureKilled) == 0x000008, "Wrong alignment on OrionGameMode_MOBA_ReceiveOtherStructureKilled");
static_assert(sizeof(OrionGameMode_MOBA_ReceiveOtherStructureKilled) == 0x000010, "Wrong size on OrionGameMode_MOBA_ReceiveOtherStructureKilled");
static_assert(offsetof(OrionGameMode_MOBA_ReceiveOtherStructureKilled, Killer) == 0x000000, "Member 'OrionGameMode_MOBA_ReceiveOtherStructureKilled::Killer' has a wrong offset!");
static_assert(offsetof(OrionGameMode_MOBA_ReceiveOtherStructureKilled, KilledActor) == 0x000008, "Member 'OrionGameMode_MOBA_ReceiveOtherStructureKilled::KilledActor' has a wrong offset!");

// Function OrionGame.OrionGameMode_MOBA.ReceivePlayerKilled
// 0x0020 (0x0020 - 0x0000)
struct OrionGameMode_MOBA_ReceivePlayerKilled final
{
public:
	class AController*                            Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            KilledPlayer;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  KilledPawn;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MultiKillCount;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KillStreakCount;                                   // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameMode_MOBA_ReceivePlayerKilled) == 0x000008, "Wrong alignment on OrionGameMode_MOBA_ReceivePlayerKilled");
static_assert(sizeof(OrionGameMode_MOBA_ReceivePlayerKilled) == 0x000020, "Wrong size on OrionGameMode_MOBA_ReceivePlayerKilled");
static_assert(offsetof(OrionGameMode_MOBA_ReceivePlayerKilled, Killer) == 0x000000, "Member 'OrionGameMode_MOBA_ReceivePlayerKilled::Killer' has a wrong offset!");
static_assert(offsetof(OrionGameMode_MOBA_ReceivePlayerKilled, KilledPlayer) == 0x000008, "Member 'OrionGameMode_MOBA_ReceivePlayerKilled::KilledPlayer' has a wrong offset!");
static_assert(offsetof(OrionGameMode_MOBA_ReceivePlayerKilled, KilledPawn) == 0x000010, "Member 'OrionGameMode_MOBA_ReceivePlayerKilled::KilledPawn' has a wrong offset!");
static_assert(offsetof(OrionGameMode_MOBA_ReceivePlayerKilled, MultiKillCount) == 0x000018, "Member 'OrionGameMode_MOBA_ReceivePlayerKilled::MultiKillCount' has a wrong offset!");
static_assert(offsetof(OrionGameMode_MOBA_ReceivePlayerKilled, KillStreakCount) == 0x00001C, "Member 'OrionGameMode_MOBA_ReceivePlayerKilled::KillStreakCount' has a wrong offset!");

// Function OrionGame.OrionGameMode_MOBA.ReceivePlayerKillStreakShutdown
// 0x0018 (0x0018 - 0x0000)
struct OrionGameMode_MOBA_ReceivePlayerKillStreakShutdown final
{
public:
	class AController*                            Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            Killer;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KillStreakCount;                                   // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionGameMode_MOBA_ReceivePlayerKillStreakShutdown) == 0x000008, "Wrong alignment on OrionGameMode_MOBA_ReceivePlayerKillStreakShutdown");
static_assert(sizeof(OrionGameMode_MOBA_ReceivePlayerKillStreakShutdown) == 0x000018, "Wrong size on OrionGameMode_MOBA_ReceivePlayerKillStreakShutdown");
static_assert(offsetof(OrionGameMode_MOBA_ReceivePlayerKillStreakShutdown, Victim) == 0x000000, "Member 'OrionGameMode_MOBA_ReceivePlayerKillStreakShutdown::Victim' has a wrong offset!");
static_assert(offsetof(OrionGameMode_MOBA_ReceivePlayerKillStreakShutdown, Killer) == 0x000008, "Member 'OrionGameMode_MOBA_ReceivePlayerKillStreakShutdown::Killer' has a wrong offset!");
static_assert(offsetof(OrionGameMode_MOBA_ReceivePlayerKillStreakShutdown, KillStreakCount) == 0x000010, "Member 'OrionGameMode_MOBA_ReceivePlayerKillStreakShutdown::KillStreakCount' has a wrong offset!");

// Function OrionGame.OrionGameMode_MOBA.ReceivePlayerSpawned
// 0x0010 (0x0010 - 0x0000)
struct OrionGameMode_MOBA_ReceivePlayerSpawned final
{
public:
	class AOrionChar*                             SpawnedChar;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    Team;                                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionGameMode_MOBA_ReceivePlayerSpawned) == 0x000008, "Wrong alignment on OrionGameMode_MOBA_ReceivePlayerSpawned");
static_assert(sizeof(OrionGameMode_MOBA_ReceivePlayerSpawned) == 0x000010, "Wrong size on OrionGameMode_MOBA_ReceivePlayerSpawned");
static_assert(offsetof(OrionGameMode_MOBA_ReceivePlayerSpawned, SpawnedChar) == 0x000000, "Member 'OrionGameMode_MOBA_ReceivePlayerSpawned::SpawnedChar' has a wrong offset!");
static_assert(offsetof(OrionGameMode_MOBA_ReceivePlayerSpawned, Team) == 0x000008, "Member 'OrionGameMode_MOBA_ReceivePlayerSpawned::Team' has a wrong offset!");

// Function OrionGame.OrionGameMode_MOBA.ReceiveTowerKilled
// 0x0010 (0x0010 - 0x0000)
struct OrionGameMode_MOBA_ReceiveTowerKilled final
{
public:
	class AController*                            Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionDamageableActor*                  KilledTower;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameMode_MOBA_ReceiveTowerKilled) == 0x000008, "Wrong alignment on OrionGameMode_MOBA_ReceiveTowerKilled");
static_assert(sizeof(OrionGameMode_MOBA_ReceiveTowerKilled) == 0x000010, "Wrong size on OrionGameMode_MOBA_ReceiveTowerKilled");
static_assert(offsetof(OrionGameMode_MOBA_ReceiveTowerKilled, Killer) == 0x000000, "Member 'OrionGameMode_MOBA_ReceiveTowerKilled::Killer' has a wrong offset!");
static_assert(offsetof(OrionGameMode_MOBA_ReceiveTowerKilled, KilledTower) == 0x000008, "Member 'OrionGameMode_MOBA_ReceiveTowerKilled::KilledTower' has a wrong offset!");

// Function OrionGame.OrionGameMode_MOBA.GetBotDifficulty
// 0x0002 (0x0002 - 0x0000)
struct OrionGameMode_MOBA_GetBotDifficulty final
{
public:
	EAIBotDifficulty                              EnemyBotDifficulty;                                // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIBotDifficulty                              FriendlyBotDifficulty;                             // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameMode_MOBA_GetBotDifficulty) == 0x000001, "Wrong alignment on OrionGameMode_MOBA_GetBotDifficulty");
static_assert(sizeof(OrionGameMode_MOBA_GetBotDifficulty) == 0x000002, "Wrong size on OrionGameMode_MOBA_GetBotDifficulty");
static_assert(offsetof(OrionGameMode_MOBA_GetBotDifficulty, EnemyBotDifficulty) == 0x000000, "Member 'OrionGameMode_MOBA_GetBotDifficulty::EnemyBotDifficulty' has a wrong offset!");
static_assert(offsetof(OrionGameMode_MOBA_GetBotDifficulty, FriendlyBotDifficulty) == 0x000001, "Member 'OrionGameMode_MOBA_GetBotDifficulty::FriendlyBotDifficulty' has a wrong offset!");

// Function OrionGame.OrionGameMode_MOBA.GetBotTeams
// 0x0020 (0x0020 - 0x0000)
struct OrionGameMode_MOBA_GetBotTeams final
{
public:
	TArray<class AOrionPlayerState_Game*>         OutEnemyTeam;                                      // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AOrionPlayerState_Game*>         OutFriendlyTeam;                                   // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameMode_MOBA_GetBotTeams) == 0x000008, "Wrong alignment on OrionGameMode_MOBA_GetBotTeams");
static_assert(sizeof(OrionGameMode_MOBA_GetBotTeams) == 0x000020, "Wrong size on OrionGameMode_MOBA_GetBotTeams");
static_assert(offsetof(OrionGameMode_MOBA_GetBotTeams, OutEnemyTeam) == 0x000000, "Member 'OrionGameMode_MOBA_GetBotTeams::OutEnemyTeam' has a wrong offset!");
static_assert(offsetof(OrionGameMode_MOBA_GetBotTeams, OutFriendlyTeam) == 0x000010, "Member 'OrionGameMode_MOBA_GetBotTeams::OutFriendlyTeam' has a wrong offset!");

// Function OrionGame.OrionGameMode_Sandbox.OnEnter_FightPractice
// 0x0010 (0x0010 - 0x0000)
struct OrionGameMode_Sandbox_OnEnter_FightPractice final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameMode_Sandbox_OnEnter_FightPractice) == 0x000008, "Wrong alignment on OrionGameMode_Sandbox_OnEnter_FightPractice");
static_assert(sizeof(OrionGameMode_Sandbox_OnEnter_FightPractice) == 0x000010, "Wrong size on OrionGameMode_Sandbox_OnEnter_FightPractice");
static_assert(offsetof(OrionGameMode_Sandbox_OnEnter_FightPractice, OverlappedActor) == 0x000000, "Member 'OrionGameMode_Sandbox_OnEnter_FightPractice::OverlappedActor' has a wrong offset!");
static_assert(offsetof(OrionGameMode_Sandbox_OnEnter_FightPractice, OtherActor) == 0x000008, "Member 'OrionGameMode_Sandbox_OnEnter_FightPractice::OtherActor' has a wrong offset!");

// Function OrionGame.OrionGameMode_Sandbox.OnEnter_FightPractice_LineupSelect
// 0x0018 (0x0018 - 0x0000)
struct OrionGameMode_Sandbox_OnEnter_FightPractice_LineupSelect final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionPosition                                Enemy_0;                                           // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionPosition                                Enemy_1;                                           // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionPosition                                Friendly;                                          // 0x0012(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionGameMode_Sandbox_OnEnter_FightPractice_LineupSelect) == 0x000008, "Wrong alignment on OrionGameMode_Sandbox_OnEnter_FightPractice_LineupSelect");
static_assert(sizeof(OrionGameMode_Sandbox_OnEnter_FightPractice_LineupSelect) == 0x000018, "Wrong size on OrionGameMode_Sandbox_OnEnter_FightPractice_LineupSelect");
static_assert(offsetof(OrionGameMode_Sandbox_OnEnter_FightPractice_LineupSelect, OverlappedActor) == 0x000000, "Member 'OrionGameMode_Sandbox_OnEnter_FightPractice_LineupSelect::OverlappedActor' has a wrong offset!");
static_assert(offsetof(OrionGameMode_Sandbox_OnEnter_FightPractice_LineupSelect, OtherActor) == 0x000008, "Member 'OrionGameMode_Sandbox_OnEnter_FightPractice_LineupSelect::OtherActor' has a wrong offset!");
static_assert(offsetof(OrionGameMode_Sandbox_OnEnter_FightPractice_LineupSelect, Enemy_0) == 0x000010, "Member 'OrionGameMode_Sandbox_OnEnter_FightPractice_LineupSelect::Enemy_0' has a wrong offset!");
static_assert(offsetof(OrionGameMode_Sandbox_OnEnter_FightPractice_LineupSelect, Enemy_1) == 0x000011, "Member 'OrionGameMode_Sandbox_OnEnter_FightPractice_LineupSelect::Enemy_1' has a wrong offset!");
static_assert(offsetof(OrionGameMode_Sandbox_OnEnter_FightPractice_LineupSelect, Friendly) == 0x000012, "Member 'OrionGameMode_Sandbox_OnEnter_FightPractice_LineupSelect::Friendly' has a wrong offset!");

// Function OrionGame.OrionGameMode_Sandbox.OnEnter_LastHitting
// 0x0010 (0x0010 - 0x0000)
struct OrionGameMode_Sandbox_OnEnter_LastHitting final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameMode_Sandbox_OnEnter_LastHitting) == 0x000008, "Wrong alignment on OrionGameMode_Sandbox_OnEnter_LastHitting");
static_assert(sizeof(OrionGameMode_Sandbox_OnEnter_LastHitting) == 0x000010, "Wrong size on OrionGameMode_Sandbox_OnEnter_LastHitting");
static_assert(offsetof(OrionGameMode_Sandbox_OnEnter_LastHitting, OverlappedActor) == 0x000000, "Member 'OrionGameMode_Sandbox_OnEnter_LastHitting::OverlappedActor' has a wrong offset!");
static_assert(offsetof(OrionGameMode_Sandbox_OnEnter_LastHitting, OtherActor) == 0x000008, "Member 'OrionGameMode_Sandbox_OnEnter_LastHitting::OtherActor' has a wrong offset!");

// Function OrionGame.OrionGameMode_Sandbox.OnEnter_LevelUp
// 0x0010 (0x0010 - 0x0000)
struct OrionGameMode_Sandbox_OnEnter_LevelUp final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameMode_Sandbox_OnEnter_LevelUp) == 0x000008, "Wrong alignment on OrionGameMode_Sandbox_OnEnter_LevelUp");
static_assert(sizeof(OrionGameMode_Sandbox_OnEnter_LevelUp) == 0x000010, "Wrong size on OrionGameMode_Sandbox_OnEnter_LevelUp");
static_assert(offsetof(OrionGameMode_Sandbox_OnEnter_LevelUp, OverlappedActor) == 0x000000, "Member 'OrionGameMode_Sandbox_OnEnter_LevelUp::OverlappedActor' has a wrong offset!");
static_assert(offsetof(OrionGameMode_Sandbox_OnEnter_LevelUp, OtherActor) == 0x000008, "Member 'OrionGameMode_Sandbox_OnEnter_LevelUp::OtherActor' has a wrong offset!");

// Function OrionGame.OrionGameMode_Sandbox.OnEnter_ShootingRange
// 0x0010 (0x0010 - 0x0000)
struct OrionGameMode_Sandbox_OnEnter_ShootingRange final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameMode_Sandbox_OnEnter_ShootingRange) == 0x000008, "Wrong alignment on OrionGameMode_Sandbox_OnEnter_ShootingRange");
static_assert(sizeof(OrionGameMode_Sandbox_OnEnter_ShootingRange) == 0x000010, "Wrong size on OrionGameMode_Sandbox_OnEnter_ShootingRange");
static_assert(offsetof(OrionGameMode_Sandbox_OnEnter_ShootingRange, OverlappedActor) == 0x000000, "Member 'OrionGameMode_Sandbox_OnEnter_ShootingRange::OverlappedActor' has a wrong offset!");
static_assert(offsetof(OrionGameMode_Sandbox_OnEnter_ShootingRange, OtherActor) == 0x000008, "Member 'OrionGameMode_Sandbox_OnEnter_ShootingRange::OtherActor' has a wrong offset!");

// Function OrionGame.OrionGameMode_Sandbox.OnEnter_TowerDefense
// 0x0010 (0x0010 - 0x0000)
struct OrionGameMode_Sandbox_OnEnter_TowerDefense final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameMode_Sandbox_OnEnter_TowerDefense) == 0x000008, "Wrong alignment on OrionGameMode_Sandbox_OnEnter_TowerDefense");
static_assert(sizeof(OrionGameMode_Sandbox_OnEnter_TowerDefense) == 0x000010, "Wrong size on OrionGameMode_Sandbox_OnEnter_TowerDefense");
static_assert(offsetof(OrionGameMode_Sandbox_OnEnter_TowerDefense, OverlappedActor) == 0x000000, "Member 'OrionGameMode_Sandbox_OnEnter_TowerDefense::OverlappedActor' has a wrong offset!");
static_assert(offsetof(OrionGameMode_Sandbox_OnEnter_TowerDefense, OtherActor) == 0x000008, "Member 'OrionGameMode_Sandbox_OnEnter_TowerDefense::OtherActor' has a wrong offset!");

// Function OrionGame.OrionGameMode_Sandbox.OnExit_FightPractice
// 0x0010 (0x0010 - 0x0000)
struct OrionGameMode_Sandbox_OnExit_FightPractice final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameMode_Sandbox_OnExit_FightPractice) == 0x000008, "Wrong alignment on OrionGameMode_Sandbox_OnExit_FightPractice");
static_assert(sizeof(OrionGameMode_Sandbox_OnExit_FightPractice) == 0x000010, "Wrong size on OrionGameMode_Sandbox_OnExit_FightPractice");
static_assert(offsetof(OrionGameMode_Sandbox_OnExit_FightPractice, OverlappedActor) == 0x000000, "Member 'OrionGameMode_Sandbox_OnExit_FightPractice::OverlappedActor' has a wrong offset!");
static_assert(offsetof(OrionGameMode_Sandbox_OnExit_FightPractice, OtherActor) == 0x000008, "Member 'OrionGameMode_Sandbox_OnExit_FightPractice::OtherActor' has a wrong offset!");

// Function OrionGame.OrionGameMode_Sandbox.OnExit_LastHitting
// 0x0010 (0x0010 - 0x0000)
struct OrionGameMode_Sandbox_OnExit_LastHitting final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameMode_Sandbox_OnExit_LastHitting) == 0x000008, "Wrong alignment on OrionGameMode_Sandbox_OnExit_LastHitting");
static_assert(sizeof(OrionGameMode_Sandbox_OnExit_LastHitting) == 0x000010, "Wrong size on OrionGameMode_Sandbox_OnExit_LastHitting");
static_assert(offsetof(OrionGameMode_Sandbox_OnExit_LastHitting, OverlappedActor) == 0x000000, "Member 'OrionGameMode_Sandbox_OnExit_LastHitting::OverlappedActor' has a wrong offset!");
static_assert(offsetof(OrionGameMode_Sandbox_OnExit_LastHitting, OtherActor) == 0x000008, "Member 'OrionGameMode_Sandbox_OnExit_LastHitting::OtherActor' has a wrong offset!");

// Function OrionGame.OrionGameMode_Sandbox.OnExit_LevelUp
// 0x0010 (0x0010 - 0x0000)
struct OrionGameMode_Sandbox_OnExit_LevelUp final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameMode_Sandbox_OnExit_LevelUp) == 0x000008, "Wrong alignment on OrionGameMode_Sandbox_OnExit_LevelUp");
static_assert(sizeof(OrionGameMode_Sandbox_OnExit_LevelUp) == 0x000010, "Wrong size on OrionGameMode_Sandbox_OnExit_LevelUp");
static_assert(offsetof(OrionGameMode_Sandbox_OnExit_LevelUp, OverlappedActor) == 0x000000, "Member 'OrionGameMode_Sandbox_OnExit_LevelUp::OverlappedActor' has a wrong offset!");
static_assert(offsetof(OrionGameMode_Sandbox_OnExit_LevelUp, OtherActor) == 0x000008, "Member 'OrionGameMode_Sandbox_OnExit_LevelUp::OtherActor' has a wrong offset!");

// Function OrionGame.OrionGameMode_Sandbox.OnExit_ShootingRange
// 0x0010 (0x0010 - 0x0000)
struct OrionGameMode_Sandbox_OnExit_ShootingRange final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameMode_Sandbox_OnExit_ShootingRange) == 0x000008, "Wrong alignment on OrionGameMode_Sandbox_OnExit_ShootingRange");
static_assert(sizeof(OrionGameMode_Sandbox_OnExit_ShootingRange) == 0x000010, "Wrong size on OrionGameMode_Sandbox_OnExit_ShootingRange");
static_assert(offsetof(OrionGameMode_Sandbox_OnExit_ShootingRange, OverlappedActor) == 0x000000, "Member 'OrionGameMode_Sandbox_OnExit_ShootingRange::OverlappedActor' has a wrong offset!");
static_assert(offsetof(OrionGameMode_Sandbox_OnExit_ShootingRange, OtherActor) == 0x000008, "Member 'OrionGameMode_Sandbox_OnExit_ShootingRange::OtherActor' has a wrong offset!");

// Function OrionGame.OrionGameMode_Sandbox.OnExit_TowerDefense
// 0x0010 (0x0010 - 0x0000)
struct OrionGameMode_Sandbox_OnExit_TowerDefense final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameMode_Sandbox_OnExit_TowerDefense) == 0x000008, "Wrong alignment on OrionGameMode_Sandbox_OnExit_TowerDefense");
static_assert(sizeof(OrionGameMode_Sandbox_OnExit_TowerDefense) == 0x000010, "Wrong size on OrionGameMode_Sandbox_OnExit_TowerDefense");
static_assert(offsetof(OrionGameMode_Sandbox_OnExit_TowerDefense, OverlappedActor) == 0x000000, "Member 'OrionGameMode_Sandbox_OnExit_TowerDefense::OverlappedActor' has a wrong offset!");
static_assert(offsetof(OrionGameMode_Sandbox_OnExit_TowerDefense, OtherActor) == 0x000008, "Member 'OrionGameMode_Sandbox_OnExit_TowerDefense::OtherActor' has a wrong offset!");

// Function OrionGame.OrionGameMode_Sandbox.OnHeroEnterLevelUp
// 0x0008 (0x0008 - 0x0000)
struct OrionGameMode_Sandbox_OnHeroEnterLevelUp final
{
public:
	class AOrionPlayerState_Game*                 PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameMode_Sandbox_OnHeroEnterLevelUp) == 0x000008, "Wrong alignment on OrionGameMode_Sandbox_OnHeroEnterLevelUp");
static_assert(sizeof(OrionGameMode_Sandbox_OnHeroEnterLevelUp) == 0x000008, "Wrong size on OrionGameMode_Sandbox_OnHeroEnterLevelUp");
static_assert(offsetof(OrionGameMode_Sandbox_OnHeroEnterLevelUp, PlayerState) == 0x000000, "Member 'OrionGameMode_Sandbox_OnHeroEnterLevelUp::PlayerState' has a wrong offset!");

// Function OrionGame.OrionGameMode_Sandbox.OnTowerDeath
// 0x0010 (0x0010 - 0x0000)
struct OrionGameMode_Sandbox_OnTowerDeath final
{
public:
	class AController*                            Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameMode_Sandbox_OnTowerDeath) == 0x000008, "Wrong alignment on OrionGameMode_Sandbox_OnTowerDeath");
static_assert(sizeof(OrionGameMode_Sandbox_OnTowerDeath) == 0x000010, "Wrong size on OrionGameMode_Sandbox_OnTowerDeath");
static_assert(offsetof(OrionGameMode_Sandbox_OnTowerDeath, Killer) == 0x000000, "Member 'OrionGameMode_Sandbox_OnTowerDeath::Killer' has a wrong offset!");
static_assert(offsetof(OrionGameMode_Sandbox_OnTowerDeath, DamageCauser) == 0x000008, "Member 'OrionGameMode_Sandbox_OnTowerDeath::DamageCauser' has a wrong offset!");

// Function OrionGame.OrionGameMode_Sandbox.InitOrionSandboxPlayerState
// 0x0008 (0x0008 - 0x0000)
struct OrionGameMode_Sandbox_InitOrionSandboxPlayerState final
{
public:
	class AOrionPlayerState_Game*                 PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameMode_Sandbox_InitOrionSandboxPlayerState) == 0x000008, "Wrong alignment on OrionGameMode_Sandbox_InitOrionSandboxPlayerState");
static_assert(sizeof(OrionGameMode_Sandbox_InitOrionSandboxPlayerState) == 0x000008, "Wrong size on OrionGameMode_Sandbox_InitOrionSandboxPlayerState");
static_assert(offsetof(OrionGameMode_Sandbox_InitOrionSandboxPlayerState, PlayerState) == 0x000000, "Member 'OrionGameMode_Sandbox_InitOrionSandboxPlayerState::PlayerState' has a wrong offset!");

// Function OrionGame.OrionBaseActor.ExecuteGameplayCueLocal
// 0x00C0 (0x00C0 - 0x0000)
struct OrionBaseActor_ExecuteGameplayCueLocal final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 Parameters;                                        // 0x0008(0x00B8)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseActor_ExecuteGameplayCueLocal) == 0x000008, "Wrong alignment on OrionBaseActor_ExecuteGameplayCueLocal");
static_assert(sizeof(OrionBaseActor_ExecuteGameplayCueLocal) == 0x0000C0, "Wrong size on OrionBaseActor_ExecuteGameplayCueLocal");
static_assert(offsetof(OrionBaseActor_ExecuteGameplayCueLocal, GameplayCueTag) == 0x000000, "Member 'OrionBaseActor_ExecuteGameplayCueLocal::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(OrionBaseActor_ExecuteGameplayCueLocal, Parameters) == 0x000008, "Member 'OrionBaseActor_ExecuteGameplayCueLocal::Parameters' has a wrong offset!");

// Function OrionGame.OrionBaseActor.NotifyTeamChanged
// 0x0001 (0x0001 - 0x0000)
struct OrionBaseActor_NotifyTeamChanged final
{
public:
	EOrionTeam                                    NewTeamIdx;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseActor_NotifyTeamChanged) == 0x000001, "Wrong alignment on OrionBaseActor_NotifyTeamChanged");
static_assert(sizeof(OrionBaseActor_NotifyTeamChanged) == 0x000001, "Wrong size on OrionBaseActor_NotifyTeamChanged");
static_assert(offsetof(OrionBaseActor_NotifyTeamChanged, NewTeamIdx) == 0x000000, "Member 'OrionBaseActor_NotifyTeamChanged::NewTeamIdx' has a wrong offset!");

// Function OrionGame.OrionBaseActor.OnCustomHit
// 0x0090 (0x0090 - 0x0000)
struct OrionBaseActor_OnCustomHit final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x0088)(Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EProjectileCustomHitResponseType              ProjectileCustomHitResponseType_0;                 // 0x0088(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Magnitude;                                         // 0x008C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseActor_OnCustomHit) == 0x000008, "Wrong alignment on OrionBaseActor_OnCustomHit");
static_assert(sizeof(OrionBaseActor_OnCustomHit) == 0x000090, "Wrong size on OrionBaseActor_OnCustomHit");
static_assert(offsetof(OrionBaseActor_OnCustomHit, Hit) == 0x000000, "Member 'OrionBaseActor_OnCustomHit::Hit' has a wrong offset!");
static_assert(offsetof(OrionBaseActor_OnCustomHit, ProjectileCustomHitResponseType_0) == 0x000088, "Member 'OrionBaseActor_OnCustomHit::ProjectileCustomHitResponseType_0' has a wrong offset!");
static_assert(offsetof(OrionBaseActor_OnCustomHit, Magnitude) == 0x00008C, "Member 'OrionBaseActor_OnCustomHit::Magnitude' has a wrong offset!");

// Function OrionGame.OrionBaseActor.OnRemovedTracked
// 0x0008 (0x0008 - 0x0000)
struct OrionBaseActor_OnRemovedTracked final
{
public:
	class UOrionAbilitySystemComponent*           AbilityComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseActor_OnRemovedTracked) == 0x000008, "Wrong alignment on OrionBaseActor_OnRemovedTracked");
static_assert(sizeof(OrionBaseActor_OnRemovedTracked) == 0x000008, "Wrong size on OrionBaseActor_OnRemovedTracked");
static_assert(offsetof(OrionBaseActor_OnRemovedTracked, AbilityComponent) == 0x000000, "Member 'OrionBaseActor_OnRemovedTracked::AbilityComponent' has a wrong offset!");

// Function OrionGame.OrionBaseActor.OnRep_ReplicatedVisionData
// 0x0004 (0x0004 - 0x0000)
struct OrionBaseActor_OnRep_ReplicatedVisionData final
{
public:
	struct FOrionReplicatedVisionData             OldData;                                           // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseActor_OnRep_ReplicatedVisionData) == 0x000002, "Wrong alignment on OrionBaseActor_OnRep_ReplicatedVisionData");
static_assert(sizeof(OrionBaseActor_OnRep_ReplicatedVisionData) == 0x000004, "Wrong size on OrionBaseActor_OnRep_ReplicatedVisionData");
static_assert(offsetof(OrionBaseActor_OnRep_ReplicatedVisionData, OldData) == 0x000000, "Member 'OrionBaseActor_OnRep_ReplicatedVisionData::OldData' has a wrong offset!");

// Function OrionGame.OrionBaseActor.OnRep_TeamNum
// 0x0001 (0x0001 - 0x0000)
struct OrionBaseActor_OnRep_TeamNum final
{
public:
	EOrionTeam                                    OldTeamNum;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseActor_OnRep_TeamNum) == 0x000001, "Wrong alignment on OrionBaseActor_OnRep_TeamNum");
static_assert(sizeof(OrionBaseActor_OnRep_TeamNum) == 0x000001, "Wrong size on OrionBaseActor_OnRep_TeamNum");
static_assert(offsetof(OrionBaseActor_OnRep_TeamNum, OldTeamNum) == 0x000000, "Member 'OrionBaseActor_OnRep_TeamNum::OldTeamNum' has a wrong offset!");

// Function OrionGame.OrionBaseActor.OnRep_VisibleToEnemy
// 0x0004 (0x0004 - 0x0000)
struct OrionBaseActor_OnRep_VisibleToEnemy final
{
public:
	struct FOrionReplicatedVisibleToEnemy         OldValue;                                          // 0x0000(0x0004)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseActor_OnRep_VisibleToEnemy) == 0x000001, "Wrong alignment on OrionBaseActor_OnRep_VisibleToEnemy");
static_assert(sizeof(OrionBaseActor_OnRep_VisibleToEnemy) == 0x000004, "Wrong size on OrionBaseActor_OnRep_VisibleToEnemy");
static_assert(offsetof(OrionBaseActor_OnRep_VisibleToEnemy, OldValue) == 0x000000, "Member 'OrionBaseActor_OnRep_VisibleToEnemy::OldValue' has a wrong offset!");

// Function OrionGame.OrionBaseActor.PlaySoundTeamAdjustedForSelf
// 0x0018 (0x0018 - 0x0000)
struct OrionBaseActor_PlaySoundTeamAdjustedForSelf final
{
public:
	class USoundBase*                             SoundToPlay;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Attached;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopWhenAttachedToDestroyed;                      // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseActor_PlaySoundTeamAdjustedForSelf) == 0x000008, "Wrong alignment on OrionBaseActor_PlaySoundTeamAdjustedForSelf");
static_assert(sizeof(OrionBaseActor_PlaySoundTeamAdjustedForSelf) == 0x000018, "Wrong size on OrionBaseActor_PlaySoundTeamAdjustedForSelf");
static_assert(offsetof(OrionBaseActor_PlaySoundTeamAdjustedForSelf, SoundToPlay) == 0x000000, "Member 'OrionBaseActor_PlaySoundTeamAdjustedForSelf::SoundToPlay' has a wrong offset!");
static_assert(offsetof(OrionBaseActor_PlaySoundTeamAdjustedForSelf, Attached) == 0x000008, "Member 'OrionBaseActor_PlaySoundTeamAdjustedForSelf::Attached' has a wrong offset!");
static_assert(offsetof(OrionBaseActor_PlaySoundTeamAdjustedForSelf, bStopWhenAttachedToDestroyed) == 0x000009, "Member 'OrionBaseActor_PlaySoundTeamAdjustedForSelf::bStopWhenAttachedToDestroyed' has a wrong offset!");
static_assert(offsetof(OrionBaseActor_PlaySoundTeamAdjustedForSelf, ReturnValue) == 0x000010, "Member 'OrionBaseActor_PlaySoundTeamAdjustedForSelf::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionBaseActor.SetTargetingTagRequirements
// 0x0040 (0x0040 - 0x0000)
struct OrionBaseActor_SetTargetingTagRequirements final
{
public:
	struct FGameplayTagRequirements               InTargetingTagRequirements;                        // 0x0000(0x0040)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseActor_SetTargetingTagRequirements) == 0x000008, "Wrong alignment on OrionBaseActor_SetTargetingTagRequirements");
static_assert(sizeof(OrionBaseActor_SetTargetingTagRequirements) == 0x000040, "Wrong size on OrionBaseActor_SetTargetingTagRequirements");
static_assert(offsetof(OrionBaseActor_SetTargetingTagRequirements, InTargetingTagRequirements) == 0x000000, "Member 'OrionBaseActor_SetTargetingTagRequirements::InTargetingTagRequirements' has a wrong offset!");

// Function OrionGame.OrionBaseActor.SetupTeamColors
// 0x0001 (0x0001 - 0x0000)
struct OrionBaseActor_SetupTeamColors final
{
public:
	bool                                          bIsDead;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseActor_SetupTeamColors) == 0x000001, "Wrong alignment on OrionBaseActor_SetupTeamColors");
static_assert(sizeof(OrionBaseActor_SetupTeamColors) == 0x000001, "Wrong size on OrionBaseActor_SetupTeamColors");
static_assert(offsetof(OrionBaseActor_SetupTeamColors, bIsDead) == 0x000000, "Member 'OrionBaseActor_SetupTeamColors::bIsDead' has a wrong offset!");

// Function OrionGame.OrionBaseActor.SetVisionRules
// 0x0001 (0x0001 - 0x0000)
struct OrionBaseActor_SetVisionRules final
{
public:
	EOrionVisionIndividualRules                   NewType;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseActor_SetVisionRules) == 0x000001, "Wrong alignment on OrionBaseActor_SetVisionRules");
static_assert(sizeof(OrionBaseActor_SetVisionRules) == 0x000001, "Wrong size on OrionBaseActor_SetVisionRules");
static_assert(offsetof(OrionBaseActor_SetVisionRules, NewType) == 0x000000, "Member 'OrionBaseActor_SetVisionRules::NewType' has a wrong offset!");

// Function OrionGame.OrionBaseActor.GetTeamNum
// 0x0001 (0x0001 - 0x0000)
struct OrionBaseActor_GetTeamNum final
{
public:
	EOrionTeam                                    ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseActor_GetTeamNum) == 0x000001, "Wrong alignment on OrionBaseActor_GetTeamNum");
static_assert(sizeof(OrionBaseActor_GetTeamNum) == 0x000001, "Wrong size on OrionBaseActor_GetTeamNum");
static_assert(offsetof(OrionBaseActor_GetTeamNum, ReturnValue) == 0x000000, "Member 'OrionBaseActor_GetTeamNum::ReturnValue' has a wrong offset!");

// Function OrionGame.AIScriptedBehavior.BehaviorFinished
// 0x0008 (0x0008 - 0x0000)
struct AIScriptedBehavior_BehaviorFinished final
{
public:
	class AOrionAIController*                     AIController;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIScriptedBehavior_BehaviorFinished) == 0x000008, "Wrong alignment on AIScriptedBehavior_BehaviorFinished");
static_assert(sizeof(AIScriptedBehavior_BehaviorFinished) == 0x000008, "Wrong size on AIScriptedBehavior_BehaviorFinished");
static_assert(offsetof(AIScriptedBehavior_BehaviorFinished, AIController) == 0x000000, "Member 'AIScriptedBehavior_BehaviorFinished::AIController' has a wrong offset!");

// Function OrionGame.AIScriptedBehavior.FinishBehavior
// 0x0008 (0x0008 - 0x0000)
struct AIScriptedBehavior_FinishBehavior final
{
public:
	class AOrionAIController*                     AIController;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIScriptedBehavior_FinishBehavior) == 0x000008, "Wrong alignment on AIScriptedBehavior_FinishBehavior");
static_assert(sizeof(AIScriptedBehavior_FinishBehavior) == 0x000008, "Wrong size on AIScriptedBehavior_FinishBehavior");
static_assert(offsetof(AIScriptedBehavior_FinishBehavior, AIController) == 0x000000, "Member 'AIScriptedBehavior_FinishBehavior::AIController' has a wrong offset!");

// Function OrionGame.AIScriptedBehavior.K2_StopAllMovementTasks
// 0x0008 (0x0008 - 0x0000)
struct AIScriptedBehavior_K2_StopAllMovementTasks final
{
public:
	class AOrionAIController*                     AIController;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIScriptedBehavior_K2_StopAllMovementTasks) == 0x000008, "Wrong alignment on AIScriptedBehavior_K2_StopAllMovementTasks");
static_assert(sizeof(AIScriptedBehavior_K2_StopAllMovementTasks) == 0x000008, "Wrong size on AIScriptedBehavior_K2_StopAllMovementTasks");
static_assert(offsetof(AIScriptedBehavior_K2_StopAllMovementTasks, AIController) == 0x000000, "Member 'AIScriptedBehavior_K2_StopAllMovementTasks::AIController' has a wrong offset!");

// Function OrionGame.AIScriptedBehavior.RunBehavior
// 0x0010 (0x0010 - 0x0000)
struct AIScriptedBehavior_RunBehavior final
{
public:
	class AOrionAIController*                     AIController;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AIScriptedBehavior_RunBehavior) == 0x000008, "Wrong alignment on AIScriptedBehavior_RunBehavior");
static_assert(sizeof(AIScriptedBehavior_RunBehavior) == 0x000010, "Wrong size on AIScriptedBehavior_RunBehavior");
static_assert(offsetof(AIScriptedBehavior_RunBehavior, AIController) == 0x000000, "Member 'AIScriptedBehavior_RunBehavior::AIController' has a wrong offset!");
static_assert(offsetof(AIScriptedBehavior_RunBehavior, ReturnValue) == 0x000008, "Member 'AIScriptedBehavior_RunBehavior::ReturnValue' has a wrong offset!");

// Function OrionGame.AIScriptedBehavior.K2_IsFinished
// 0x0001 (0x0001 - 0x0000)
struct AIScriptedBehavior_K2_IsFinished final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIScriptedBehavior_K2_IsFinished) == 0x000001, "Wrong alignment on AIScriptedBehavior_K2_IsFinished");
static_assert(sizeof(AIScriptedBehavior_K2_IsFinished) == 0x000001, "Wrong size on AIScriptedBehavior_K2_IsFinished");
static_assert(offsetof(AIScriptedBehavior_K2_IsFinished, ReturnValue) == 0x000000, "Member 'AIScriptedBehavior_K2_IsFinished::ReturnValue' has a wrong offset!");

// Function OrionGame.AIWardPlacement.CapsuleTouched
// 0x00A8 (0x00A8 - 0x0000)
struct AIWardPlacement_CapsuleTouched final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIWardPlacement_CapsuleTouched) == 0x000008, "Wrong alignment on AIWardPlacement_CapsuleTouched");
static_assert(sizeof(AIWardPlacement_CapsuleTouched) == 0x0000A8, "Wrong size on AIWardPlacement_CapsuleTouched");
static_assert(offsetof(AIWardPlacement_CapsuleTouched, OverlappedComp) == 0x000000, "Member 'AIWardPlacement_CapsuleTouched::OverlappedComp' has a wrong offset!");
static_assert(offsetof(AIWardPlacement_CapsuleTouched, Other) == 0x000008, "Member 'AIWardPlacement_CapsuleTouched::Other' has a wrong offset!");
static_assert(offsetof(AIWardPlacement_CapsuleTouched, OtherComp) == 0x000010, "Member 'AIWardPlacement_CapsuleTouched::OtherComp' has a wrong offset!");
static_assert(offsetof(AIWardPlacement_CapsuleTouched, OtherBodyIndex) == 0x000018, "Member 'AIWardPlacement_CapsuleTouched::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(AIWardPlacement_CapsuleTouched, bFromSweep) == 0x00001C, "Member 'AIWardPlacement_CapsuleTouched::bFromSweep' has a wrong offset!");
static_assert(offsetof(AIWardPlacement_CapsuleTouched, SweepResult) == 0x000020, "Member 'AIWardPlacement_CapsuleTouched::SweepResult' has a wrong offset!");

// Function OrionGame.AIWardPlacement.GetScriptedRoleForTeam
// 0x0002 (0x0002 - 0x0000)
struct AIWardPlacement_GetScriptedRoleForTeam final
{
public:
	EOrionTeam                                    Team;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELaneRoleSlot                                 ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIWardPlacement_GetScriptedRoleForTeam) == 0x000001, "Wrong alignment on AIWardPlacement_GetScriptedRoleForTeam");
static_assert(sizeof(AIWardPlacement_GetScriptedRoleForTeam) == 0x000002, "Wrong size on AIWardPlacement_GetScriptedRoleForTeam");
static_assert(offsetof(AIWardPlacement_GetScriptedRoleForTeam, Team) == 0x000000, "Member 'AIWardPlacement_GetScriptedRoleForTeam::Team' has a wrong offset!");
static_assert(offsetof(AIWardPlacement_GetScriptedRoleForTeam, ReturnValue) == 0x000001, "Member 'AIWardPlacement_GetScriptedRoleForTeam::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCraftingDevice.OnActiveActionSelected
// 0x0004 (0x0004 - 0x0000)
struct OrionCraftingDevice_OnActiveActionSelected final
{
public:
	int32                                         NumCards;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCraftingDevice_OnActiveActionSelected) == 0x000004, "Wrong alignment on OrionCraftingDevice_OnActiveActionSelected");
static_assert(sizeof(OrionCraftingDevice_OnActiveActionSelected) == 0x000004, "Wrong size on OrionCraftingDevice_OnActiveActionSelected");
static_assert(offsetof(OrionCraftingDevice_OnActiveActionSelected, NumCards) == 0x000000, "Member 'OrionCraftingDevice_OnActiveActionSelected::NumCards' has a wrong offset!");

// Function OrionGame.OrionCraftingDevice.OnActiveCraftingActionChanged
// 0x0001 (0x0001 - 0x0000)
struct OrionCraftingDevice_OnActiveCraftingActionChanged final
{
public:
	EOrionCraftingAction                          ActionType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCraftingDevice_OnActiveCraftingActionChanged) == 0x000001, "Wrong alignment on OrionCraftingDevice_OnActiveCraftingActionChanged");
static_assert(sizeof(OrionCraftingDevice_OnActiveCraftingActionChanged) == 0x000001, "Wrong size on OrionCraftingDevice_OnActiveCraftingActionChanged");
static_assert(offsetof(OrionCraftingDevice_OnActiveCraftingActionChanged, ActionType) == 0x000000, "Member 'OrionCraftingDevice_OnActiveCraftingActionChanged::ActionType' has a wrong offset!");

// Function OrionGame.OrionCraftingDevice.OnConstellationComplete
// 0x0010 (0x0010 - 0x0000)
struct OrionCraftingDevice_OnConstellationComplete final
{
public:
	TArray<class UParticleSystemComponent*>       ActiveEdgeBeams;                                   // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCraftingDevice_OnConstellationComplete) == 0x000008, "Wrong alignment on OrionCraftingDevice_OnConstellationComplete");
static_assert(sizeof(OrionCraftingDevice_OnConstellationComplete) == 0x000010, "Wrong size on OrionCraftingDevice_OnConstellationComplete");
static_assert(offsetof(OrionCraftingDevice_OnConstellationComplete, ActiveEdgeBeams) == 0x000000, "Member 'OrionCraftingDevice_OnConstellationComplete::ActiveEdgeBeams' has a wrong offset!");

// Function OrionGame.OrionCraftingDevice.OnConstellationEdgeCreated
// 0x0018 (0x0018 - 0x0000)
struct OrionCraftingDevice_OnConstellationEdgeCreated final
{
public:
	class UParticleSystemComponent*               EdgeBeamParticle;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionCraftingDeviceNode*               SourceNode;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionCraftingDeviceNode*               DestinationNode;                                   // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCraftingDevice_OnConstellationEdgeCreated) == 0x000008, "Wrong alignment on OrionCraftingDevice_OnConstellationEdgeCreated");
static_assert(sizeof(OrionCraftingDevice_OnConstellationEdgeCreated) == 0x000018, "Wrong size on OrionCraftingDevice_OnConstellationEdgeCreated");
static_assert(offsetof(OrionCraftingDevice_OnConstellationEdgeCreated, EdgeBeamParticle) == 0x000000, "Member 'OrionCraftingDevice_OnConstellationEdgeCreated::EdgeBeamParticle' has a wrong offset!");
static_assert(offsetof(OrionCraftingDevice_OnConstellationEdgeCreated, SourceNode) == 0x000008, "Member 'OrionCraftingDevice_OnConstellationEdgeCreated::SourceNode' has a wrong offset!");
static_assert(offsetof(OrionCraftingDevice_OnConstellationEdgeCreated, DestinationNode) == 0x000010, "Member 'OrionCraftingDevice_OnConstellationEdgeCreated::DestinationNode' has a wrong offset!");

// Function OrionGame.OrionCraftingDevice.OnCurrentCardDataChanged
// 0x0008 (0x0008 - 0x0000)
struct OrionCraftingDevice_OnCurrentCardDataChanged final
{
public:
	class UOrionLegacyCardItemDefinition*         NewCardData;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCraftingDevice_OnCurrentCardDataChanged) == 0x000008, "Wrong alignment on OrionCraftingDevice_OnCurrentCardDataChanged");
static_assert(sizeof(OrionCraftingDevice_OnCurrentCardDataChanged) == 0x000008, "Wrong size on OrionCraftingDevice_OnCurrentCardDataChanged");
static_assert(offsetof(OrionCraftingDevice_OnCurrentCardDataChanged, NewCardData) == 0x000000, "Member 'OrionCraftingDevice_OnCurrentCardDataChanged::NewCardData' has a wrong offset!");

// Function OrionGame.OrionCraftingDevice.OnResetToIdle
// 0x0001 (0x0001 - 0x0000)
struct OrionCraftingDevice_OnResetToIdle final
{
public:
	bool                                          bPostFanfare;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCraftingDevice_OnResetToIdle) == 0x000001, "Wrong alignment on OrionCraftingDevice_OnResetToIdle");
static_assert(sizeof(OrionCraftingDevice_OnResetToIdle) == 0x000001, "Wrong size on OrionCraftingDevice_OnResetToIdle");
static_assert(offsetof(OrionCraftingDevice_OnResetToIdle, bPostFanfare) == 0x000000, "Member 'OrionCraftingDevice_OnResetToIdle::bPostFanfare' has a wrong offset!");

// Function OrionGame.ARHUD.OnAbilityStatusChanged
// 0x00C8 (0x00C8 - 0x0000)
struct ARHUD_OnAbilityStatusChanged final
{
public:
	EOrionAbilityBinding                          BindingId;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionAbilityUIData                    Data;                                              // 0x0008(0x00C0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ARHUD_OnAbilityStatusChanged) == 0x000008, "Wrong alignment on ARHUD_OnAbilityStatusChanged");
static_assert(sizeof(ARHUD_OnAbilityStatusChanged) == 0x0000C8, "Wrong size on ARHUD_OnAbilityStatusChanged");
static_assert(offsetof(ARHUD_OnAbilityStatusChanged, BindingId) == 0x000000, "Member 'ARHUD_OnAbilityStatusChanged::BindingId' has a wrong offset!");
static_assert(offsetof(ARHUD_OnAbilityStatusChanged, Data) == 0x000008, "Member 'ARHUD_OnAbilityStatusChanged::Data' has a wrong offset!");

// Function OrionGame.ARHUD.OnEnergyChanged
// 0x0004 (0x0004 - 0x0000)
struct ARHUD_OnEnergyChanged final
{
public:
	float                                         EnergyValue;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ARHUD_OnEnergyChanged) == 0x000004, "Wrong alignment on ARHUD_OnEnergyChanged");
static_assert(sizeof(ARHUD_OnEnergyChanged) == 0x000004, "Wrong size on ARHUD_OnEnergyChanged");
static_assert(offsetof(ARHUD_OnEnergyChanged, EnergyValue) == 0x000000, "Member 'ARHUD_OnEnergyChanged::EnergyValue' has a wrong offset!");

// Function OrionGame.ARHUD.OnHealthChanged
// 0x0004 (0x0004 - 0x0000)
struct ARHUD_OnHealthChanged final
{
public:
	float                                         HealthValue;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ARHUD_OnHealthChanged) == 0x000004, "Wrong alignment on ARHUD_OnHealthChanged");
static_assert(sizeof(ARHUD_OnHealthChanged) == 0x000004, "Wrong size on ARHUD_OnHealthChanged");
static_assert(offsetof(ARHUD_OnHealthChanged, HealthValue) == 0x000000, "Member 'ARHUD_OnHealthChanged::HealthValue' has a wrong offset!");

// Function OrionGame.OrionPickup.CleanUpAppliedGameplayEffects
// 0x0008 (0x0008 - 0x0000)
struct OrionPickup_CleanUpAppliedGameplayEffects final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPickup_CleanUpAppliedGameplayEffects) == 0x000008, "Wrong alignment on OrionPickup_CleanUpAppliedGameplayEffects");
static_assert(sizeof(OrionPickup_CleanUpAppliedGameplayEffects) == 0x000008, "Wrong size on OrionPickup_CleanUpAppliedGameplayEffects");
static_assert(offsetof(OrionPickup_CleanUpAppliedGameplayEffects, InActor) == 0x000000, "Member 'OrionPickup_CleanUpAppliedGameplayEffects::InActor' has a wrong offset!");

// Function OrionGame.OrionPickup.GetCurrentMaxLifeSpan
// 0x0004 (0x0004 - 0x0000)
struct OrionPickup_GetCurrentMaxLifeSpan final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPickup_GetCurrentMaxLifeSpan) == 0x000004, "Wrong alignment on OrionPickup_GetCurrentMaxLifeSpan");
static_assert(sizeof(OrionPickup_GetCurrentMaxLifeSpan) == 0x000004, "Wrong size on OrionPickup_GetCurrentMaxLifeSpan");
static_assert(offsetof(OrionPickup_GetCurrentMaxLifeSpan, ReturnValue) == 0x000000, "Member 'OrionPickup_GetCurrentMaxLifeSpan::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPickup.GetInterpolationEndLocation
// 0x000C (0x000C - 0x0000)
struct OrionPickup_GetInterpolationEndLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPickup_GetInterpolationEndLocation) == 0x000004, "Wrong alignment on OrionPickup_GetInterpolationEndLocation");
static_assert(sizeof(OrionPickup_GetInterpolationEndLocation) == 0x00000C, "Wrong size on OrionPickup_GetInterpolationEndLocation");
static_assert(offsetof(OrionPickup_GetInterpolationEndLocation, ReturnValue) == 0x000000, "Member 'OrionPickup_GetInterpolationEndLocation::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPickup.HandleHomingDeath
// 0x0008 (0x0008 - 0x0000)
struct OrionPickup_HandleHomingDeath final
{
public:
	class AOrionChar*                             DeadChar;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPickup_HandleHomingDeath) == 0x000008, "Wrong alignment on OrionPickup_HandleHomingDeath");
static_assert(sizeof(OrionPickup_HandleHomingDeath) == 0x000008, "Wrong size on OrionPickup_HandleHomingDeath");
static_assert(offsetof(OrionPickup_HandleHomingDeath, DeadChar) == 0x000000, "Member 'OrionPickup_HandleHomingDeath::DeadChar' has a wrong offset!");

// Function OrionGame.OrionPickup.HandleHomingEnterPhaseShift
// 0x0008 (0x0008 - 0x0000)
struct OrionPickup_HandleHomingEnterPhaseShift final
{
public:
	class AOrionChar*                             PhaseShifedChar;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPickup_HandleHomingEnterPhaseShift) == 0x000008, "Wrong alignment on OrionPickup_HandleHomingEnterPhaseShift");
static_assert(sizeof(OrionPickup_HandleHomingEnterPhaseShift) == 0x000008, "Wrong size on OrionPickup_HandleHomingEnterPhaseShift");
static_assert(offsetof(OrionPickup_HandleHomingEnterPhaseShift, PhaseShifedChar) == 0x000000, "Member 'OrionPickup_HandleHomingEnterPhaseShift::PhaseShifedChar' has a wrong offset!");

// Function OrionGame.OrionPickup.OnLockOnTagretTagAdded
// 0x0010 (0x0010 - 0x0000)
struct OrionPickup_OnLockOnTagretTagAdded final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewCount;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionPickup_OnLockOnTagretTagAdded) == 0x000008, "Wrong alignment on OrionPickup_OnLockOnTagretTagAdded");
static_assert(sizeof(OrionPickup_OnLockOnTagretTagAdded) == 0x000010, "Wrong size on OrionPickup_OnLockOnTagretTagAdded");
static_assert(offsetof(OrionPickup_OnLockOnTagretTagAdded, Tag) == 0x000000, "Member 'OrionPickup_OnLockOnTagretTagAdded::Tag' has a wrong offset!");
static_assert(offsetof(OrionPickup_OnLockOnTagretTagAdded, NewCount) == 0x000008, "Member 'OrionPickup_OnLockOnTagretTagAdded::NewCount' has a wrong offset!");

// Function OrionGame.OrionPickup.OnLockOnTagretTagRemoved
// 0x0008 (0x0008 - 0x0000)
struct OrionPickup_OnLockOnTagretTagRemoved final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPickup_OnLockOnTagretTagRemoved) == 0x000008, "Wrong alignment on OrionPickup_OnLockOnTagretTagRemoved");
static_assert(sizeof(OrionPickup_OnLockOnTagretTagRemoved) == 0x000008, "Wrong size on OrionPickup_OnLockOnTagretTagRemoved");
static_assert(offsetof(OrionPickup_OnLockOnTagretTagRemoved, Tag) == 0x000000, "Member 'OrionPickup_OnLockOnTagretTagRemoved::Tag' has a wrong offset!");

// Function OrionGame.OrionPickup.OnOverlapBegin
// 0x00A8 (0x00A8 - 0x0000)
struct OrionPickup_OnOverlapBegin final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPickup_OnOverlapBegin) == 0x000008, "Wrong alignment on OrionPickup_OnOverlapBegin");
static_assert(sizeof(OrionPickup_OnOverlapBegin) == 0x0000A8, "Wrong size on OrionPickup_OnOverlapBegin");
static_assert(offsetof(OrionPickup_OnOverlapBegin, OverlappedComp) == 0x000000, "Member 'OrionPickup_OnOverlapBegin::OverlappedComp' has a wrong offset!");
static_assert(offsetof(OrionPickup_OnOverlapBegin, OtherActor) == 0x000008, "Member 'OrionPickup_OnOverlapBegin::OtherActor' has a wrong offset!");
static_assert(offsetof(OrionPickup_OnOverlapBegin, OtherComp) == 0x000010, "Member 'OrionPickup_OnOverlapBegin::OtherComp' has a wrong offset!");
static_assert(offsetof(OrionPickup_OnOverlapBegin, OtherBodyIndex) == 0x000018, "Member 'OrionPickup_OnOverlapBegin::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(OrionPickup_OnOverlapBegin, bFromSweep) == 0x00001C, "Member 'OrionPickup_OnOverlapBegin::bFromSweep' has a wrong offset!");
static_assert(offsetof(OrionPickup_OnOverlapBegin, SweepResult) == 0x000020, "Member 'OrionPickup_OnOverlapBegin::SweepResult' has a wrong offset!");

// Function OrionGame.OrionPickup.OnPickedUp
// 0x0008 (0x0008 - 0x0000)
struct OrionPickup_OnPickedUp final
{
public:
	class AOrionChar*                             Pawn;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPickup_OnPickedUp) == 0x000008, "Wrong alignment on OrionPickup_OnPickedUp");
static_assert(sizeof(OrionPickup_OnPickedUp) == 0x000008, "Wrong size on OrionPickup_OnPickedUp");
static_assert(offsetof(OrionPickup_OnPickedUp, Pawn) == 0x000000, "Member 'OrionPickup_OnPickedUp::Pawn' has a wrong offset!");

// Function OrionGame.OrionPickup.SetLockOnActor
// 0x0008 (0x0008 - 0x0000)
struct OrionPickup_SetLockOnActor final
{
public:
	class AActor*                                 InNewLockOnActor;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPickup_SetLockOnActor) == 0x000008, "Wrong alignment on OrionPickup_SetLockOnActor");
static_assert(sizeof(OrionPickup_SetLockOnActor) == 0x000008, "Wrong size on OrionPickup_SetLockOnActor");
static_assert(offsetof(OrionPickup_SetLockOnActor, InNewLockOnActor) == 0x000000, "Member 'OrionPickup_SetLockOnActor::InNewLockOnActor' has a wrong offset!");

// Function OrionGame.OrionPickup.TryToApplyGameplayEffectSpecToTarget
// 0x0028 (0x0028 - 0x0000)
struct OrionPickup_TryToApplyGameplayEffectSpecToTarget final
{
public:
	struct FGameplayEffectSpecHandle              EffectSpecHandle;                                  // 0x0000(0x0018)(ConstParm, Parm, NativeAccessSpecifierPublic)
	class AActor*                                 Source;                                            // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Target;                                            // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPickup_TryToApplyGameplayEffectSpecToTarget) == 0x000008, "Wrong alignment on OrionPickup_TryToApplyGameplayEffectSpecToTarget");
static_assert(sizeof(OrionPickup_TryToApplyGameplayEffectSpecToTarget) == 0x000028, "Wrong size on OrionPickup_TryToApplyGameplayEffectSpecToTarget");
static_assert(offsetof(OrionPickup_TryToApplyGameplayEffectSpecToTarget, EffectSpecHandle) == 0x000000, "Member 'OrionPickup_TryToApplyGameplayEffectSpecToTarget::EffectSpecHandle' has a wrong offset!");
static_assert(offsetof(OrionPickup_TryToApplyGameplayEffectSpecToTarget, Source) == 0x000018, "Member 'OrionPickup_TryToApplyGameplayEffectSpecToTarget::Source' has a wrong offset!");
static_assert(offsetof(OrionPickup_TryToApplyGameplayEffectSpecToTarget, Target) == 0x000020, "Member 'OrionPickup_TryToApplyGameplayEffectSpecToTarget::Target' has a wrong offset!");

// Function OrionGame.OrionPickup.UpdateInterpolation
// 0x0004 (0x0004 - 0x0000)
struct OrionPickup_UpdateInterpolation final
{
public:
	float                                         InElapsedTime;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPickup_UpdateInterpolation) == 0x000004, "Wrong alignment on OrionPickup_UpdateInterpolation");
static_assert(sizeof(OrionPickup_UpdateInterpolation) == 0x000004, "Wrong size on OrionPickup_UpdateInterpolation");
static_assert(offsetof(OrionPickup_UpdateInterpolation, InElapsedTime) == 0x000000, "Member 'OrionPickup_UpdateInterpolation::InElapsedTime' has a wrong offset!");

// Function OrionGame.OrionPickup.GetMaxLifeSpan
// 0x0004 (0x0004 - 0x0000)
struct OrionPickup_GetMaxLifeSpan final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPickup_GetMaxLifeSpan) == 0x000004, "Wrong alignment on OrionPickup_GetMaxLifeSpan");
static_assert(sizeof(OrionPickup_GetMaxLifeSpan) == 0x000004, "Wrong size on OrionPickup_GetMaxLifeSpan");
static_assert(offsetof(OrionPickup_GetMaxLifeSpan, ReturnValue) == 0x000000, "Member 'OrionPickup_GetMaxLifeSpan::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCoin.HandleHomingDeath
// 0x0008 (0x0008 - 0x0000)
struct OrionCoin_HandleHomingDeath final
{
public:
	class AOrionChar*                             DeadChar;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCoin_HandleHomingDeath) == 0x000008, "Wrong alignment on OrionCoin_HandleHomingDeath");
static_assert(sizeof(OrionCoin_HandleHomingDeath) == 0x000008, "Wrong size on OrionCoin_HandleHomingDeath");
static_assert(offsetof(OrionCoin_HandleHomingDeath, DeadChar) == 0x000000, "Member 'OrionCoin_HandleHomingDeath::DeadChar' has a wrong offset!");

// Function OrionGame.OrionCoin.HandleHomingEnterPhaseShift
// 0x0008 (0x0008 - 0x0000)
struct OrionCoin_HandleHomingEnterPhaseShift final
{
public:
	class AOrionChar*                             PhaseShifedChar;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCoin_HandleHomingEnterPhaseShift) == 0x000008, "Wrong alignment on OrionCoin_HandleHomingEnterPhaseShift");
static_assert(sizeof(OrionCoin_HandleHomingEnterPhaseShift) == 0x000008, "Wrong size on OrionCoin_HandleHomingEnterPhaseShift");
static_assert(offsetof(OrionCoin_HandleHomingEnterPhaseShift, PhaseShifedChar) == 0x000000, "Member 'OrionCoin_HandleHomingEnterPhaseShift::PhaseShifedChar' has a wrong offset!");

// Function OrionGame.OrionCoin.OnCoinVisualScalar
// 0x0010 (0x0010 - 0x0000)
struct OrionCoin_OnCoinVisualScalar final
{
public:
	EOrionCoinSize                                Size;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               CoinMID;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCoin_OnCoinVisualScalar) == 0x000008, "Wrong alignment on OrionCoin_OnCoinVisualScalar");
static_assert(sizeof(OrionCoin_OnCoinVisualScalar) == 0x000010, "Wrong size on OrionCoin_OnCoinVisualScalar");
static_assert(offsetof(OrionCoin_OnCoinVisualScalar, Size) == 0x000000, "Member 'OrionCoin_OnCoinVisualScalar::Size' has a wrong offset!");
static_assert(offsetof(OrionCoin_OnCoinVisualScalar, CoinMID) == 0x000008, "Member 'OrionCoin_OnCoinVisualScalar::CoinMID' has a wrong offset!");

// Function OrionGame.AutomationPerfMontiorManager.GetPerfMonitorInstance
// 0x0008 (0x0008 - 0x0000)
struct AutomationPerfMontiorManager_GetPerfMonitorInstance final
{
public:
	class UAutomationPerfMontiorManager*          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AutomationPerfMontiorManager_GetPerfMonitorInstance) == 0x000008, "Wrong alignment on AutomationPerfMontiorManager_GetPerfMonitorInstance");
static_assert(sizeof(AutomationPerfMontiorManager_GetPerfMonitorInstance) == 0x000008, "Wrong size on AutomationPerfMontiorManager_GetPerfMonitorInstance");
static_assert(offsetof(AutomationPerfMontiorManager_GetPerfMonitorInstance, ReturnValue) == 0x000000, "Member 'AutomationPerfMontiorManager_GetPerfMonitorInstance::ReturnValue' has a wrong offset!");

// Function OrionGame.AutomationPerfMontiorManager.IsRecordingFTestPerf
// 0x0001 (0x0001 - 0x0000)
struct AutomationPerfMontiorManager_IsRecordingFTestPerf final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AutomationPerfMontiorManager_IsRecordingFTestPerf) == 0x000001, "Wrong alignment on AutomationPerfMontiorManager_IsRecordingFTestPerf");
static_assert(sizeof(AutomationPerfMontiorManager_IsRecordingFTestPerf) == 0x000001, "Wrong size on AutomationPerfMontiorManager_IsRecordingFTestPerf");
static_assert(offsetof(AutomationPerfMontiorManager_IsRecordingFTestPerf, ReturnValue) == 0x000000, "Member 'AutomationPerfMontiorManager_IsRecordingFTestPerf::ReturnValue' has a wrong offset!");

// Function OrionGame.AutomationPerfMontiorManager.StartRecordingFTestPerf
// 0x0030 (0x0030 - 0x0000)
struct AutomationPerfMontiorManager_StartRecordingFTestPerf final
{
public:
	class FString                                 Filename;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TestName;                                          // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         StatsToRecord;                                     // 0x0020(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(AutomationPerfMontiorManager_StartRecordingFTestPerf) == 0x000008, "Wrong alignment on AutomationPerfMontiorManager_StartRecordingFTestPerf");
static_assert(sizeof(AutomationPerfMontiorManager_StartRecordingFTestPerf) == 0x000030, "Wrong size on AutomationPerfMontiorManager_StartRecordingFTestPerf");
static_assert(offsetof(AutomationPerfMontiorManager_StartRecordingFTestPerf, Filename) == 0x000000, "Member 'AutomationPerfMontiorManager_StartRecordingFTestPerf::Filename' has a wrong offset!");
static_assert(offsetof(AutomationPerfMontiorManager_StartRecordingFTestPerf, TestName) == 0x000010, "Member 'AutomationPerfMontiorManager_StartRecordingFTestPerf::TestName' has a wrong offset!");
static_assert(offsetof(AutomationPerfMontiorManager_StartRecordingFTestPerf, StatsToRecord) == 0x000020, "Member 'AutomationPerfMontiorManager_StartRecordingFTestPerf::StatsToRecord' has a wrong offset!");

// Function OrionGame.OrionGameplayCueNotify_Actor.OnEnterShadowplane
// 0x0010 (0x0010 - 0x0000)
struct OrionGameplayCueNotify_Actor_OnEnterShadowplane final
{
public:
	class AActor*                                 MyTarget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVisibleToMe;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionGameplayCueNotify_Actor_OnEnterShadowplane) == 0x000008, "Wrong alignment on OrionGameplayCueNotify_Actor_OnEnterShadowplane");
static_assert(sizeof(OrionGameplayCueNotify_Actor_OnEnterShadowplane) == 0x000010, "Wrong size on OrionGameplayCueNotify_Actor_OnEnterShadowplane");
static_assert(offsetof(OrionGameplayCueNotify_Actor_OnEnterShadowplane, MyTarget) == 0x000000, "Member 'OrionGameplayCueNotify_Actor_OnEnterShadowplane::MyTarget' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Actor_OnEnterShadowplane, bVisibleToMe) == 0x000008, "Member 'OrionGameplayCueNotify_Actor_OnEnterShadowplane::bVisibleToMe' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Actor_OnEnterShadowplane, ReturnValue) == 0x000009, "Member 'OrionGameplayCueNotify_Actor_OnEnterShadowplane::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameplayCueNotify_Actor.OnExitShadowplane
// 0x0010 (0x0010 - 0x0000)
struct OrionGameplayCueNotify_Actor_OnExitShadowplane final
{
public:
	class AActor*                                 MyTarget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionGameplayCueNotify_Actor_OnExitShadowplane) == 0x000008, "Wrong alignment on OrionGameplayCueNotify_Actor_OnExitShadowplane");
static_assert(sizeof(OrionGameplayCueNotify_Actor_OnExitShadowplane) == 0x000010, "Wrong size on OrionGameplayCueNotify_Actor_OnExitShadowplane");
static_assert(offsetof(OrionGameplayCueNotify_Actor_OnExitShadowplane, MyTarget) == 0x000000, "Member 'OrionGameplayCueNotify_Actor_OnExitShadowplane::MyTarget' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Actor_OnExitShadowplane, ReturnValue) == 0x000008, "Member 'OrionGameplayCueNotify_Actor_OnExitShadowplane::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameplayCueNotify_Actor.SetShadowplaneVisibility
// 0x0010 (0x0010 - 0x0000)
struct OrionGameplayCueNotify_Actor_SetShadowplaneVisibility final
{
public:
	class AActor*                                 MyTarget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocalVisiblityState                          ShadowPlaneVisibility;                             // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionGameplayCueNotify_Actor_SetShadowplaneVisibility) == 0x000008, "Wrong alignment on OrionGameplayCueNotify_Actor_SetShadowplaneVisibility");
static_assert(sizeof(OrionGameplayCueNotify_Actor_SetShadowplaneVisibility) == 0x000010, "Wrong size on OrionGameplayCueNotify_Actor_SetShadowplaneVisibility");
static_assert(offsetof(OrionGameplayCueNotify_Actor_SetShadowplaneVisibility, MyTarget) == 0x000000, "Member 'OrionGameplayCueNotify_Actor_SetShadowplaneVisibility::MyTarget' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Actor_SetShadowplaneVisibility, ShadowPlaneVisibility) == 0x000008, "Member 'OrionGameplayCueNotify_Actor_SetShadowplaneVisibility::ShadowPlaneVisibility' has a wrong offset!");

// Function OrionGame.OrionGameplayCueNotify_Actor.SpawnBurstGameplayCueNiagaraParticleInfo
// 0x0118 (0x0118 - 0x0000)
struct OrionGameplayCueNotify_Actor_SpawnBurstGameplayCueNiagaraParticleInfo final
{
public:
	struct FGameplayCueNiagaraParticleInfo        ParticleEffect;                                    // 0x0000(0x0040)(Parm, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0040(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 Parameters;                                        // 0x0048(0x00B8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class USceneComponent*                        OptionalAttachToComponent;                         // 0x0100(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UNiagaraComponent*>              ReturnValue;                                       // 0x0108(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameplayCueNotify_Actor_SpawnBurstGameplayCueNiagaraParticleInfo) == 0x000008, "Wrong alignment on OrionGameplayCueNotify_Actor_SpawnBurstGameplayCueNiagaraParticleInfo");
static_assert(sizeof(OrionGameplayCueNotify_Actor_SpawnBurstGameplayCueNiagaraParticleInfo) == 0x000118, "Wrong size on OrionGameplayCueNotify_Actor_SpawnBurstGameplayCueNiagaraParticleInfo");
static_assert(offsetof(OrionGameplayCueNotify_Actor_SpawnBurstGameplayCueNiagaraParticleInfo, ParticleEffect) == 0x000000, "Member 'OrionGameplayCueNotify_Actor_SpawnBurstGameplayCueNiagaraParticleInfo::ParticleEffect' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Actor_SpawnBurstGameplayCueNiagaraParticleInfo, TargetActor) == 0x000040, "Member 'OrionGameplayCueNotify_Actor_SpawnBurstGameplayCueNiagaraParticleInfo::TargetActor' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Actor_SpawnBurstGameplayCueNiagaraParticleInfo, Parameters) == 0x000048, "Member 'OrionGameplayCueNotify_Actor_SpawnBurstGameplayCueNiagaraParticleInfo::Parameters' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Actor_SpawnBurstGameplayCueNiagaraParticleInfo, OptionalAttachToComponent) == 0x000100, "Member 'OrionGameplayCueNotify_Actor_SpawnBurstGameplayCueNiagaraParticleInfo::OptionalAttachToComponent' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Actor_SpawnBurstGameplayCueNiagaraParticleInfo, ReturnValue) == 0x000108, "Member 'OrionGameplayCueNotify_Actor_SpawnBurstGameplayCueNiagaraParticleInfo::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameplayCueNotify_Actor.SpawnBurstGameplayCueParticleInfo
// 0x0118 (0x0118 - 0x0000)
struct OrionGameplayCueNotify_Actor_SpawnBurstGameplayCueParticleInfo final
{
public:
	struct FGameplayCueParticleInfo               ParticleEffect;                                    // 0x0000(0x0040)(Parm, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0040(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 Parameters;                                        // 0x0048(0x00B8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class USceneComponent*                        OptionalAttachToComponent;                         // 0x0100(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UParticleSystemComponent*>       ReturnValue;                                       // 0x0108(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameplayCueNotify_Actor_SpawnBurstGameplayCueParticleInfo) == 0x000008, "Wrong alignment on OrionGameplayCueNotify_Actor_SpawnBurstGameplayCueParticleInfo");
static_assert(sizeof(OrionGameplayCueNotify_Actor_SpawnBurstGameplayCueParticleInfo) == 0x000118, "Wrong size on OrionGameplayCueNotify_Actor_SpawnBurstGameplayCueParticleInfo");
static_assert(offsetof(OrionGameplayCueNotify_Actor_SpawnBurstGameplayCueParticleInfo, ParticleEffect) == 0x000000, "Member 'OrionGameplayCueNotify_Actor_SpawnBurstGameplayCueParticleInfo::ParticleEffect' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Actor_SpawnBurstGameplayCueParticleInfo, TargetActor) == 0x000040, "Member 'OrionGameplayCueNotify_Actor_SpawnBurstGameplayCueParticleInfo::TargetActor' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Actor_SpawnBurstGameplayCueParticleInfo, Parameters) == 0x000048, "Member 'OrionGameplayCueNotify_Actor_SpawnBurstGameplayCueParticleInfo::Parameters' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Actor_SpawnBurstGameplayCueParticleInfo, OptionalAttachToComponent) == 0x000100, "Member 'OrionGameplayCueNotify_Actor_SpawnBurstGameplayCueParticleInfo::OptionalAttachToComponent' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Actor_SpawnBurstGameplayCueParticleInfo, ReturnValue) == 0x000108, "Member 'OrionGameplayCueNotify_Actor_SpawnBurstGameplayCueParticleInfo::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameplayCueNotify_Actor.UpdateGameplayCueVisuals_Hidden
// 0x0010 (0x0010 - 0x0000)
struct OrionGameplayCueNotify_Actor_UpdateGameplayCueVisuals_Hidden final
{
public:
	class AActor*                                 MyTarget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHidden;                                         // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionGameplayCueNotify_Actor_UpdateGameplayCueVisuals_Hidden) == 0x000008, "Wrong alignment on OrionGameplayCueNotify_Actor_UpdateGameplayCueVisuals_Hidden");
static_assert(sizeof(OrionGameplayCueNotify_Actor_UpdateGameplayCueVisuals_Hidden) == 0x000010, "Wrong size on OrionGameplayCueNotify_Actor_UpdateGameplayCueVisuals_Hidden");
static_assert(offsetof(OrionGameplayCueNotify_Actor_UpdateGameplayCueVisuals_Hidden, MyTarget) == 0x000000, "Member 'OrionGameplayCueNotify_Actor_UpdateGameplayCueVisuals_Hidden::MyTarget' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Actor_UpdateGameplayCueVisuals_Hidden, bIsHidden) == 0x000008, "Member 'OrionGameplayCueNotify_Actor_UpdateGameplayCueVisuals_Hidden::bIsHidden' has a wrong offset!");

// Function OrionGame.OrionGameplayCueNotify_Actor.UpdateGameplayCueVisuals_Shadowplane
// 0x0010 (0x0010 - 0x0000)
struct OrionGameplayCueNotify_Actor_UpdateGameplayCueVisuals_Shadowplane final
{
public:
	class AActor*                                 MyTarget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInShadowplane;                                    // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionGameplayCueNotify_Actor_UpdateGameplayCueVisuals_Shadowplane) == 0x000008, "Wrong alignment on OrionGameplayCueNotify_Actor_UpdateGameplayCueVisuals_Shadowplane");
static_assert(sizeof(OrionGameplayCueNotify_Actor_UpdateGameplayCueVisuals_Shadowplane) == 0x000010, "Wrong size on OrionGameplayCueNotify_Actor_UpdateGameplayCueVisuals_Shadowplane");
static_assert(offsetof(OrionGameplayCueNotify_Actor_UpdateGameplayCueVisuals_Shadowplane, MyTarget) == 0x000000, "Member 'OrionGameplayCueNotify_Actor_UpdateGameplayCueVisuals_Shadowplane::MyTarget' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Actor_UpdateGameplayCueVisuals_Shadowplane, bInShadowplane) == 0x000008, "Member 'OrionGameplayCueNotify_Actor_UpdateGameplayCueVisuals_Shadowplane::bInShadowplane' has a wrong offset!");

// Function OrionGame.BotObjective_WholeLane.AttackTower
// 0x0010 (0x0010 - 0x0000)
struct BotObjective_WholeLane_AttackTower final
{
public:
	class UBotPlaybook*                           Playbook;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAITowerClassification                        Tower;                                             // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIGenericLocation                            Location;                                          // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BotObjective_WholeLane_AttackTower) == 0x000008, "Wrong alignment on BotObjective_WholeLane_AttackTower");
static_assert(sizeof(BotObjective_WholeLane_AttackTower) == 0x000010, "Wrong size on BotObjective_WholeLane_AttackTower");
static_assert(offsetof(BotObjective_WholeLane_AttackTower, Playbook) == 0x000000, "Member 'BotObjective_WholeLane_AttackTower::Playbook' has a wrong offset!");
static_assert(offsetof(BotObjective_WholeLane_AttackTower, Tower) == 0x000008, "Member 'BotObjective_WholeLane_AttackTower::Tower' has a wrong offset!");
static_assert(offsetof(BotObjective_WholeLane_AttackTower, Location) == 0x000009, "Member 'BotObjective_WholeLane_AttackTower::Location' has a wrong offset!");

// Function OrionGame.BotObjective_WholeLane.DefendTower
// 0x0010 (0x0010 - 0x0000)
struct BotObjective_WholeLane_DefendTower final
{
public:
	class UBotPlaybook*                           Playbook;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAITowerClassification                        Tower;                                             // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIGenericLocation                            Location;                                          // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BotObjective_WholeLane_DefendTower) == 0x000008, "Wrong alignment on BotObjective_WholeLane_DefendTower");
static_assert(sizeof(BotObjective_WholeLane_DefendTower) == 0x000010, "Wrong size on BotObjective_WholeLane_DefendTower");
static_assert(offsetof(BotObjective_WholeLane_DefendTower, Playbook) == 0x000000, "Member 'BotObjective_WholeLane_DefendTower::Playbook' has a wrong offset!");
static_assert(offsetof(BotObjective_WholeLane_DefendTower, Tower) == 0x000008, "Member 'BotObjective_WholeLane_DefendTower::Tower' has a wrong offset!");
static_assert(offsetof(BotObjective_WholeLane_DefendTower, Location) == 0x000009, "Member 'BotObjective_WholeLane_DefendTower::Location' has a wrong offset!");

// Function OrionGame.BotObjective_WholeLane.PushLane
// 0x0010 (0x0010 - 0x0000)
struct BotObjective_WholeLane_PushLane final
{
public:
	class UBotPlaybook*                           Playbook;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIGenericLocation                            Lane;                                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ToLaneProgress;                                    // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BotObjective_WholeLane_PushLane) == 0x000008, "Wrong alignment on BotObjective_WholeLane_PushLane");
static_assert(sizeof(BotObjective_WholeLane_PushLane) == 0x000010, "Wrong size on BotObjective_WholeLane_PushLane");
static_assert(offsetof(BotObjective_WholeLane_PushLane, Playbook) == 0x000000, "Member 'BotObjective_WholeLane_PushLane::Playbook' has a wrong offset!");
static_assert(offsetof(BotObjective_WholeLane_PushLane, Lane) == 0x000008, "Member 'BotObjective_WholeLane_PushLane::Lane' has a wrong offset!");
static_assert(offsetof(BotObjective_WholeLane_PushLane, ToLaneProgress) == 0x00000C, "Member 'BotObjective_WholeLane_PushLane::ToLaneProgress' has a wrong offset!");

// Function OrionGame.BotObjective_WholeLane.TowerObjective
// 0x0010 (0x0010 - 0x0000)
struct BotObjective_WholeLane_TowerObjective final
{
public:
	class UBotPlaybook*                           Playbook;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAITowerClassification                        Tower;                                             // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIOwnership                                  Ownership;                                         // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIGenericLocation                            Location;                                          // 0x000A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BotObjective_WholeLane_TowerObjective) == 0x000008, "Wrong alignment on BotObjective_WholeLane_TowerObjective");
static_assert(sizeof(BotObjective_WholeLane_TowerObjective) == 0x000010, "Wrong size on BotObjective_WholeLane_TowerObjective");
static_assert(offsetof(BotObjective_WholeLane_TowerObjective, Playbook) == 0x000000, "Member 'BotObjective_WholeLane_TowerObjective::Playbook' has a wrong offset!");
static_assert(offsetof(BotObjective_WholeLane_TowerObjective, Tower) == 0x000008, "Member 'BotObjective_WholeLane_TowerObjective::Tower' has a wrong offset!");
static_assert(offsetof(BotObjective_WholeLane_TowerObjective, Ownership) == 0x000009, "Member 'BotObjective_WholeLane_TowerObjective::Ownership' has a wrong offset!");
static_assert(offsetof(BotObjective_WholeLane_TowerObjective, Location) == 0x00000A, "Member 'BotObjective_WholeLane_TowerObjective::Location' has a wrong offset!");

// Function OrionGame.BotObjective_AttackJungleCamp.ClearCamp
// 0x0018 (0x0018 - 0x0000)
struct BotObjective_AttackJungleCamp_ClearCamp final
{
public:
	class UBotPlaybook*                           Playbook;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAICampType                                   Camp;                                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIGenericLocation                            Location;                                          // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIOwnership                                  Ownership;                                         // 0x000A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MinCreeps;                                         // 0x000B(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeAbandonedForSameType;                        // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDistance;                                       // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFinishClearing;                                   // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BotObjective_AttackJungleCamp_ClearCamp) == 0x000008, "Wrong alignment on BotObjective_AttackJungleCamp_ClearCamp");
static_assert(sizeof(BotObjective_AttackJungleCamp_ClearCamp) == 0x000018, "Wrong size on BotObjective_AttackJungleCamp_ClearCamp");
static_assert(offsetof(BotObjective_AttackJungleCamp_ClearCamp, Playbook) == 0x000000, "Member 'BotObjective_AttackJungleCamp_ClearCamp::Playbook' has a wrong offset!");
static_assert(offsetof(BotObjective_AttackJungleCamp_ClearCamp, Camp) == 0x000008, "Member 'BotObjective_AttackJungleCamp_ClearCamp::Camp' has a wrong offset!");
static_assert(offsetof(BotObjective_AttackJungleCamp_ClearCamp, Location) == 0x000009, "Member 'BotObjective_AttackJungleCamp_ClearCamp::Location' has a wrong offset!");
static_assert(offsetof(BotObjective_AttackJungleCamp_ClearCamp, Ownership) == 0x00000A, "Member 'BotObjective_AttackJungleCamp_ClearCamp::Ownership' has a wrong offset!");
static_assert(offsetof(BotObjective_AttackJungleCamp_ClearCamp, MinCreeps) == 0x00000B, "Member 'BotObjective_AttackJungleCamp_ClearCamp::MinCreeps' has a wrong offset!");
static_assert(offsetof(BotObjective_AttackJungleCamp_ClearCamp, bCanBeAbandonedForSameType) == 0x00000C, "Member 'BotObjective_AttackJungleCamp_ClearCamp::bCanBeAbandonedForSameType' has a wrong offset!");
static_assert(offsetof(BotObjective_AttackJungleCamp_ClearCamp, MaxDistance) == 0x000010, "Member 'BotObjective_AttackJungleCamp_ClearCamp::MaxDistance' has a wrong offset!");
static_assert(offsetof(BotObjective_AttackJungleCamp_ClearCamp, bFinishClearing) == 0x000014, "Member 'BotObjective_AttackJungleCamp_ClearCamp::bFinishClearing' has a wrong offset!");

// Function OrionGame.BotObjective_AttackJungleCamp.GroupAttackCamp
// 0x0018 (0x0018 - 0x0000)
struct BotObjective_AttackJungleCamp_GroupAttackCamp final
{
public:
	class UBotPlaybook*                           Playbook;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAICampType                                   Camp;                                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinAgents;                                         // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFinishClearing;                                   // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BotObjective_AttackJungleCamp_GroupAttackCamp) == 0x000008, "Wrong alignment on BotObjective_AttackJungleCamp_GroupAttackCamp");
static_assert(sizeof(BotObjective_AttackJungleCamp_GroupAttackCamp) == 0x000018, "Wrong size on BotObjective_AttackJungleCamp_GroupAttackCamp");
static_assert(offsetof(BotObjective_AttackJungleCamp_GroupAttackCamp, Playbook) == 0x000000, "Member 'BotObjective_AttackJungleCamp_GroupAttackCamp::Playbook' has a wrong offset!");
static_assert(offsetof(BotObjective_AttackJungleCamp_GroupAttackCamp, Camp) == 0x000008, "Member 'BotObjective_AttackJungleCamp_GroupAttackCamp::Camp' has a wrong offset!");
static_assert(offsetof(BotObjective_AttackJungleCamp_GroupAttackCamp, MinAgents) == 0x00000C, "Member 'BotObjective_AttackJungleCamp_GroupAttackCamp::MinAgents' has a wrong offset!");
static_assert(offsetof(BotObjective_AttackJungleCamp_GroupAttackCamp, bFinishClearing) == 0x000010, "Member 'BotObjective_AttackJungleCamp_GroupAttackCamp::bFinishClearing' has a wrong offset!");

// Function OrionGame.BotObjective_AttackJungleCamp.OnCampFinishedSpawning
// 0x0008 (0x0008 - 0x0000)
struct BotObjective_AttackJungleCamp_OnCampFinishedSpawning final
{
public:
	class AOrionCharAISpawner*                    AISpawner;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BotObjective_AttackJungleCamp_OnCampFinishedSpawning) == 0x000008, "Wrong alignment on BotObjective_AttackJungleCamp_OnCampFinishedSpawning");
static_assert(sizeof(BotObjective_AttackJungleCamp_OnCampFinishedSpawning) == 0x000008, "Wrong size on BotObjective_AttackJungleCamp_OnCampFinishedSpawning");
static_assert(offsetof(BotObjective_AttackJungleCamp_OnCampFinishedSpawning, AISpawner) == 0x000000, "Member 'BotObjective_AttackJungleCamp_OnCampFinishedSpawning::AISpawner' has a wrong offset!");

// Function OrionGame.BotObjective_AttackJungleCamp.OnCampKilled
// 0x0010 (0x0010 - 0x0000)
struct BotObjective_AttackJungleCamp_OnCampKilled final
{
public:
	class AOrionCharAISpawner*                    AISpawner;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            Killer;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BotObjective_AttackJungleCamp_OnCampKilled) == 0x000008, "Wrong alignment on BotObjective_AttackJungleCamp_OnCampKilled");
static_assert(sizeof(BotObjective_AttackJungleCamp_OnCampKilled) == 0x000010, "Wrong size on BotObjective_AttackJungleCamp_OnCampKilled");
static_assert(offsetof(BotObjective_AttackJungleCamp_OnCampKilled, AISpawner) == 0x000000, "Member 'BotObjective_AttackJungleCamp_OnCampKilled::AISpawner' has a wrong offset!");
static_assert(offsetof(BotObjective_AttackJungleCamp_OnCampKilled, Killer) == 0x000008, "Member 'BotObjective_AttackJungleCamp_OnCampKilled::Killer' has a wrong offset!");

// Function OrionGame.BotObjective_PlaceWard.PlaceWard
// 0x0010 (0x0010 - 0x0000)
struct BotObjective_PlaceWard_PlaceWard final
{
public:
	class UBotPlaybook*                           Playbook;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIMapSide                                    MapSide;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIWardLocation                               Location;                                          // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BotObjective_PlaceWard_PlaceWard) == 0x000008, "Wrong alignment on BotObjective_PlaceWard_PlaceWard");
static_assert(sizeof(BotObjective_PlaceWard_PlaceWard) == 0x000010, "Wrong size on BotObjective_PlaceWard_PlaceWard");
static_assert(offsetof(BotObjective_PlaceWard_PlaceWard, Playbook) == 0x000000, "Member 'BotObjective_PlaceWard_PlaceWard::Playbook' has a wrong offset!");
static_assert(offsetof(BotObjective_PlaceWard_PlaceWard, MapSide) == 0x000008, "Member 'BotObjective_PlaceWard_PlaceWard::MapSide' has a wrong offset!");
static_assert(offsetof(BotObjective_PlaceWard_PlaceWard, Location) == 0x000009, "Member 'BotObjective_PlaceWard_PlaceWard::Location' has a wrong offset!");

// Function OrionGame.OrionGameplayCueNotify_Burst_Latent.K2_OnExecute
// 0x00F0 (0x00F0 - 0x0000)
struct OrionGameplayCueNotify_Burst_Latent_K2_OnExecute final
{
public:
	class AActor*                                 MyTarget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 Parameters;                                        // 0x0008(0x00B8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               BurstParticleSystems;                              // 0x00C0(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UParticleSystemComponent*>       AdditionalParticleSystems;                         // 0x00C8(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      BurstNiagaraParticleSystems;                       // 0x00D8(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UNiagaraComponent*>              AdditionalNiagaraParticleSystems;                  // 0x00E0(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameplayCueNotify_Burst_Latent_K2_OnExecute) == 0x000008, "Wrong alignment on OrionGameplayCueNotify_Burst_Latent_K2_OnExecute");
static_assert(sizeof(OrionGameplayCueNotify_Burst_Latent_K2_OnExecute) == 0x0000F0, "Wrong size on OrionGameplayCueNotify_Burst_Latent_K2_OnExecute");
static_assert(offsetof(OrionGameplayCueNotify_Burst_Latent_K2_OnExecute, MyTarget) == 0x000000, "Member 'OrionGameplayCueNotify_Burst_Latent_K2_OnExecute::MyTarget' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Burst_Latent_K2_OnExecute, Parameters) == 0x000008, "Member 'OrionGameplayCueNotify_Burst_Latent_K2_OnExecute::Parameters' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Burst_Latent_K2_OnExecute, BurstParticleSystems) == 0x0000C0, "Member 'OrionGameplayCueNotify_Burst_Latent_K2_OnExecute::BurstParticleSystems' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Burst_Latent_K2_OnExecute, AdditionalParticleSystems) == 0x0000C8, "Member 'OrionGameplayCueNotify_Burst_Latent_K2_OnExecute::AdditionalParticleSystems' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Burst_Latent_K2_OnExecute, BurstNiagaraParticleSystems) == 0x0000D8, "Member 'OrionGameplayCueNotify_Burst_Latent_K2_OnExecute::BurstNiagaraParticleSystems' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Burst_Latent_K2_OnExecute, AdditionalNiagaraParticleSystems) == 0x0000E0, "Member 'OrionGameplayCueNotify_Burst_Latent_K2_OnExecute::AdditionalNiagaraParticleSystems' has a wrong offset!");

// Function OrionGame.BotObjective_Patrol.Patrol
// 0x0008 (0x0008 - 0x0000)
struct BotObjective_Patrol_Patrol final
{
public:
	class UBotPlaybook*                           Playbook;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BotObjective_Patrol_Patrol) == 0x000008, "Wrong alignment on BotObjective_Patrol_Patrol");
static_assert(sizeof(BotObjective_Patrol_Patrol) == 0x000008, "Wrong size on BotObjective_Patrol_Patrol");
static_assert(offsetof(BotObjective_Patrol_Patrol, Playbook) == 0x000000, "Member 'BotObjective_Patrol_Patrol::Playbook' has a wrong offset!");

// Function OrionGame.BotObjective_GroupPushLane.GroupPushLane
// 0x0018 (0x0018 - 0x0000)
struct BotObjective_GroupPushLane_GroupPushLane final
{
public:
	class UBotPlaybook*                           Playbook;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIGenericLocation                            Location;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ToLaneProgress;                                    // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinAgents;                                         // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BotObjective_GroupPushLane_GroupPushLane) == 0x000008, "Wrong alignment on BotObjective_GroupPushLane_GroupPushLane");
static_assert(sizeof(BotObjective_GroupPushLane_GroupPushLane) == 0x000018, "Wrong size on BotObjective_GroupPushLane_GroupPushLane");
static_assert(offsetof(BotObjective_GroupPushLane_GroupPushLane, Playbook) == 0x000000, "Member 'BotObjective_GroupPushLane_GroupPushLane::Playbook' has a wrong offset!");
static_assert(offsetof(BotObjective_GroupPushLane_GroupPushLane, Location) == 0x000008, "Member 'BotObjective_GroupPushLane_GroupPushLane::Location' has a wrong offset!");
static_assert(offsetof(BotObjective_GroupPushLane_GroupPushLane, ToLaneProgress) == 0x00000C, "Member 'BotObjective_GroupPushLane_GroupPushLane::ToLaneProgress' has a wrong offset!");
static_assert(offsetof(BotObjective_GroupPushLane_GroupPushLane, MinAgents) == 0x000010, "Member 'BotObjective_GroupPushLane_GroupPushLane::MinAgents' has a wrong offset!");

// Function OrionGame.BotObjective_Gank.Gank
// 0x0010 (0x0010 - 0x0000)
struct BotObjective_Gank_Gank final
{
public:
	class UBotPlaybook*                           Playbook;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BotObjective_Gank_Gank) == 0x000008, "Wrong alignment on BotObjective_Gank_Gank");
static_assert(sizeof(BotObjective_Gank_Gank) == 0x000010, "Wrong size on BotObjective_Gank_Gank");
static_assert(offsetof(BotObjective_Gank_Gank, Playbook) == 0x000000, "Member 'BotObjective_Gank_Gank::Playbook' has a wrong offset!");
static_assert(offsetof(BotObjective_Gank_Gank, MaxDistance) == 0x000008, "Member 'BotObjective_Gank_Gank::MaxDistance' has a wrong offset!");

// Function OrionGame.OrionDamageableActor.CustomMatch_RemoveOnDeath
// 0x0540 (0x0540 - 0x0000)
struct OrionDamageableActor_CustomMatch_RemoveOnDeath final
{
public:
	struct FActiveGameplayEffect                  Effect;                                            // 0x0000(0x0530)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0530(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_531[0xF];                                      // 0x0531(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionDamageableActor_CustomMatch_RemoveOnDeath) == 0x000010, "Wrong alignment on OrionDamageableActor_CustomMatch_RemoveOnDeath");
static_assert(sizeof(OrionDamageableActor_CustomMatch_RemoveOnDeath) == 0x000540, "Wrong size on OrionDamageableActor_CustomMatch_RemoveOnDeath");
static_assert(offsetof(OrionDamageableActor_CustomMatch_RemoveOnDeath, Effect) == 0x000000, "Member 'OrionDamageableActor_CustomMatch_RemoveOnDeath::Effect' has a wrong offset!");
static_assert(offsetof(OrionDamageableActor_CustomMatch_RemoveOnDeath, ReturnValue) == 0x000530, "Member 'OrionDamageableActor_CustomMatch_RemoveOnDeath::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionDamageableActor.GetHighlightableMeshes
// 0x0010 (0x0010 - 0x0000)
struct OrionDamageableActor_GetHighlightableMeshes final
{
public:
	TArray<class UMeshComponent*>                 ReturnValue;                                       // 0x0000(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableActor_GetHighlightableMeshes) == 0x000008, "Wrong alignment on OrionDamageableActor_GetHighlightableMeshes");
static_assert(sizeof(OrionDamageableActor_GetHighlightableMeshes) == 0x000010, "Wrong size on OrionDamageableActor_GetHighlightableMeshes");
static_assert(offsetof(OrionDamageableActor_GetHighlightableMeshes, ReturnValue) == 0x000000, "Member 'OrionDamageableActor_GetHighlightableMeshes::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionDamageableActor.K2_AddGameplayCue
// 0x0008 (0x0008 - 0x0000)
struct OrionDamageableActor_K2_AddGameplayCue final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableActor_K2_AddGameplayCue) == 0x000008, "Wrong alignment on OrionDamageableActor_K2_AddGameplayCue");
static_assert(sizeof(OrionDamageableActor_K2_AddGameplayCue) == 0x000008, "Wrong size on OrionDamageableActor_K2_AddGameplayCue");
static_assert(offsetof(OrionDamageableActor_K2_AddGameplayCue, GameplayCueTag) == 0x000000, "Member 'OrionDamageableActor_K2_AddGameplayCue::GameplayCueTag' has a wrong offset!");

// Function OrionGame.OrionDamageableActor.K2_ExecuteGameplayCue
// 0x00C0 (0x00C0 - 0x0000)
struct OrionDamageableActor_K2_ExecuteGameplayCue final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 Parameters;                                        // 0x0008(0x00B8)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableActor_K2_ExecuteGameplayCue) == 0x000008, "Wrong alignment on OrionDamageableActor_K2_ExecuteGameplayCue");
static_assert(sizeof(OrionDamageableActor_K2_ExecuteGameplayCue) == 0x0000C0, "Wrong size on OrionDamageableActor_K2_ExecuteGameplayCue");
static_assert(offsetof(OrionDamageableActor_K2_ExecuteGameplayCue, GameplayCueTag) == 0x000000, "Member 'OrionDamageableActor_K2_ExecuteGameplayCue::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(OrionDamageableActor_K2_ExecuteGameplayCue, Parameters) == 0x000008, "Member 'OrionDamageableActor_K2_ExecuteGameplayCue::Parameters' has a wrong offset!");

// Function OrionGame.OrionDamageableActor.K2_ExecuteGameplayCueOnTarget
// 0x00C8 (0x00C8 - 0x0000)
struct OrionDamageableActor_K2_ExecuteGameplayCueOnTarget final
{
public:
	class AController*                            Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 Parameters;                                        // 0x0010(0x00B8)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableActor_K2_ExecuteGameplayCueOnTarget) == 0x000008, "Wrong alignment on OrionDamageableActor_K2_ExecuteGameplayCueOnTarget");
static_assert(sizeof(OrionDamageableActor_K2_ExecuteGameplayCueOnTarget) == 0x0000C8, "Wrong size on OrionDamageableActor_K2_ExecuteGameplayCueOnTarget");
static_assert(offsetof(OrionDamageableActor_K2_ExecuteGameplayCueOnTarget, Target) == 0x000000, "Member 'OrionDamageableActor_K2_ExecuteGameplayCueOnTarget::Target' has a wrong offset!");
static_assert(offsetof(OrionDamageableActor_K2_ExecuteGameplayCueOnTarget, GameplayCueTag) == 0x000008, "Member 'OrionDamageableActor_K2_ExecuteGameplayCueOnTarget::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(OrionDamageableActor_K2_ExecuteGameplayCueOnTarget, Parameters) == 0x000010, "Member 'OrionDamageableActor_K2_ExecuteGameplayCueOnTarget::Parameters' has a wrong offset!");

// Function OrionGame.OrionDamageableActor.K2_RemoveGameplayCue
// 0x0008 (0x0008 - 0x0000)
struct OrionDamageableActor_K2_RemoveGameplayCue final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableActor_K2_RemoveGameplayCue) == 0x000008, "Wrong alignment on OrionDamageableActor_K2_RemoveGameplayCue");
static_assert(sizeof(OrionDamageableActor_K2_RemoveGameplayCue) == 0x000008, "Wrong size on OrionDamageableActor_K2_RemoveGameplayCue");
static_assert(offsetof(OrionDamageableActor_K2_RemoveGameplayCue, GameplayCueTag) == 0x000000, "Member 'OrionDamageableActor_K2_RemoveGameplayCue::GameplayCueTag' has a wrong offset!");

// Function OrionGame.OrionDamageableActor.OnDamageTaken
// 0x0010 (0x0010 - 0x0000)
struct OrionDamageableActor_OnDamageTaken final
{
public:
	float                                         Damage;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 DamageInstigator;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableActor_OnDamageTaken) == 0x000008, "Wrong alignment on OrionDamageableActor_OnDamageTaken");
static_assert(sizeof(OrionDamageableActor_OnDamageTaken) == 0x000010, "Wrong size on OrionDamageableActor_OnDamageTaken");
static_assert(offsetof(OrionDamageableActor_OnDamageTaken, Damage) == 0x000000, "Member 'OrionDamageableActor_OnDamageTaken::Damage' has a wrong offset!");
static_assert(offsetof(OrionDamageableActor_OnDamageTaken, DamageInstigator) == 0x000008, "Member 'OrionDamageableActor_OnDamageTaken::DamageInstigator' has a wrong offset!");

// Function OrionGame.OrionDamageableActor.OnHealthReceived
// 0x0010 (0x0010 - 0x0000)
struct OrionDamageableActor_OnHealthReceived final
{
public:
	float                                         HealthReceived;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 HealthReceivedInstigator;                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableActor_OnHealthReceived) == 0x000008, "Wrong alignment on OrionDamageableActor_OnHealthReceived");
static_assert(sizeof(OrionDamageableActor_OnHealthReceived) == 0x000010, "Wrong size on OrionDamageableActor_OnHealthReceived");
static_assert(offsetof(OrionDamageableActor_OnHealthReceived, HealthReceived) == 0x000000, "Member 'OrionDamageableActor_OnHealthReceived::HealthReceived' has a wrong offset!");
static_assert(offsetof(OrionDamageableActor_OnHealthReceived, HealthReceivedInstigator) == 0x000008, "Member 'OrionDamageableActor_OnHealthReceived::HealthReceivedInstigator' has a wrong offset!");

// Function OrionGame.OrionDamageableActor.OnShieldDamageTaken
// 0x0010 (0x0010 - 0x0000)
struct OrionDamageableActor_OnShieldDamageTaken final
{
public:
	float                                         Damage;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 DamageInstigator;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableActor_OnShieldDamageTaken) == 0x000008, "Wrong alignment on OrionDamageableActor_OnShieldDamageTaken");
static_assert(sizeof(OrionDamageableActor_OnShieldDamageTaken) == 0x000010, "Wrong size on OrionDamageableActor_OnShieldDamageTaken");
static_assert(offsetof(OrionDamageableActor_OnShieldDamageTaken, Damage) == 0x000000, "Member 'OrionDamageableActor_OnShieldDamageTaken::Damage' has a wrong offset!");
static_assert(offsetof(OrionDamageableActor_OnShieldDamageTaken, DamageInstigator) == 0x000008, "Member 'OrionDamageableActor_OnShieldDamageTaken::DamageInstigator' has a wrong offset!");

// Function OrionGame.OrionDamageableActor.OnShieldReceived
// 0x0010 (0x0010 - 0x0000)
struct OrionDamageableActor_OnShieldReceived final
{
public:
	float                                         ShieldReceived;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ShieldReceivedInstigator;                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableActor_OnShieldReceived) == 0x000008, "Wrong alignment on OrionDamageableActor_OnShieldReceived");
static_assert(sizeof(OrionDamageableActor_OnShieldReceived) == 0x000010, "Wrong size on OrionDamageableActor_OnShieldReceived");
static_assert(offsetof(OrionDamageableActor_OnShieldReceived, ShieldReceived) == 0x000000, "Member 'OrionDamageableActor_OnShieldReceived::ShieldReceived' has a wrong offset!");
static_assert(offsetof(OrionDamageableActor_OnShieldReceived, ShieldReceivedInstigator) == 0x000008, "Member 'OrionDamageableActor_OnShieldReceived::ShieldReceivedInstigator' has a wrong offset!");

// Function OrionGame.OrionDamageableActor.SetVisionRadius
// 0x0004 (0x0004 - 0x0000)
struct OrionDamageableActor_SetVisionRadius final
{
public:
	float                                         Radius;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableActor_SetVisionRadius) == 0x000004, "Wrong alignment on OrionDamageableActor_SetVisionRadius");
static_assert(sizeof(OrionDamageableActor_SetVisionRadius) == 0x000004, "Wrong size on OrionDamageableActor_SetVisionRadius");
static_assert(offsetof(OrionDamageableActor_SetVisionRadius, Radius) == 0x000000, "Member 'OrionDamageableActor_SetVisionRadius::Radius' has a wrong offset!");

// Function OrionGame.OrionDamageableActor.GetHealth
// 0x0004 (0x0004 - 0x0000)
struct OrionDamageableActor_GetHealth final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableActor_GetHealth) == 0x000004, "Wrong alignment on OrionDamageableActor_GetHealth");
static_assert(sizeof(OrionDamageableActor_GetHealth) == 0x000004, "Wrong size on OrionDamageableActor_GetHealth");
static_assert(offsetof(OrionDamageableActor_GetHealth, ReturnValue) == 0x000000, "Member 'OrionDamageableActor_GetHealth::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionDamageableActor.GetHealthPercent
// 0x0004 (0x0004 - 0x0000)
struct OrionDamageableActor_GetHealthPercent final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableActor_GetHealthPercent) == 0x000004, "Wrong alignment on OrionDamageableActor_GetHealthPercent");
static_assert(sizeof(OrionDamageableActor_GetHealthPercent) == 0x000004, "Wrong size on OrionDamageableActor_GetHealthPercent");
static_assert(offsetof(OrionDamageableActor_GetHealthPercent, ReturnValue) == 0x000000, "Member 'OrionDamageableActor_GetHealthPercent::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionDamageableActor.GetKiller
// 0x0008 (0x0008 - 0x0000)
struct OrionDamageableActor_GetKiller final
{
public:
	class AController*                            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableActor_GetKiller) == 0x000008, "Wrong alignment on OrionDamageableActor_GetKiller");
static_assert(sizeof(OrionDamageableActor_GetKiller) == 0x000008, "Wrong size on OrionDamageableActor_GetKiller");
static_assert(offsetof(OrionDamageableActor_GetKiller, ReturnValue) == 0x000000, "Member 'OrionDamageableActor_GetKiller::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionDamageableActor.GetMaxHealth
// 0x0004 (0x0004 - 0x0000)
struct OrionDamageableActor_GetMaxHealth final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableActor_GetMaxHealth) == 0x000004, "Wrong alignment on OrionDamageableActor_GetMaxHealth");
static_assert(sizeof(OrionDamageableActor_GetMaxHealth) == 0x000004, "Wrong size on OrionDamageableActor_GetMaxHealth");
static_assert(offsetof(OrionDamageableActor_GetMaxHealth, ReturnValue) == 0x000000, "Member 'OrionDamageableActor_GetMaxHealth::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionDamageableActor.GetMaxShield
// 0x0004 (0x0004 - 0x0000)
struct OrionDamageableActor_GetMaxShield final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableActor_GetMaxShield) == 0x000004, "Wrong alignment on OrionDamageableActor_GetMaxShield");
static_assert(sizeof(OrionDamageableActor_GetMaxShield) == 0x000004, "Wrong size on OrionDamageableActor_GetMaxShield");
static_assert(offsetof(OrionDamageableActor_GetMaxShield, ReturnValue) == 0x000000, "Member 'OrionDamageableActor_GetMaxShield::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionDamageableActor.GetShield
// 0x0004 (0x0004 - 0x0000)
struct OrionDamageableActor_GetShield final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableActor_GetShield) == 0x000004, "Wrong alignment on OrionDamageableActor_GetShield");
static_assert(sizeof(OrionDamageableActor_GetShield) == 0x000004, "Wrong size on OrionDamageableActor_GetShield");
static_assert(offsetof(OrionDamageableActor_GetShield, ReturnValue) == 0x000000, "Member 'OrionDamageableActor_GetShield::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionDamageableActor.GetShieldPercent
// 0x0004 (0x0004 - 0x0000)
struct OrionDamageableActor_GetShieldPercent final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableActor_GetShieldPercent) == 0x000004, "Wrong alignment on OrionDamageableActor_GetShieldPercent");
static_assert(sizeof(OrionDamageableActor_GetShieldPercent) == 0x000004, "Wrong size on OrionDamageableActor_GetShieldPercent");
static_assert(offsetof(OrionDamageableActor_GetShieldPercent, ReturnValue) == 0x000000, "Member 'OrionDamageableActor_GetShieldPercent::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionDamageableActor.MakeGameplayCueParameters
// 0x00B8 (0x00B8 - 0x0000)
struct OrionDamageableActor_MakeGameplayCueParameters final
{
public:
	struct FGameplayCueParameters                 ReturnValue;                                       // 0x0000(0x00B8)(Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableActor_MakeGameplayCueParameters) == 0x000008, "Wrong alignment on OrionDamageableActor_MakeGameplayCueParameters");
static_assert(sizeof(OrionDamageableActor_MakeGameplayCueParameters) == 0x0000B8, "Wrong size on OrionDamageableActor_MakeGameplayCueParameters");
static_assert(offsetof(OrionDamageableActor_MakeGameplayCueParameters, ReturnValue) == 0x000000, "Member 'OrionDamageableActor_MakeGameplayCueParameters::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionDamageableObjective_Base.CanTargetActor
// 0x0010 (0x0010 - 0x0000)
struct OrionDamageableObjective_Base_CanTargetActor final
{
public:
	class AActor*                                 InTarget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInIgnoreHeight;                                   // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionDamageableObjective_Base_CanTargetActor) == 0x000008, "Wrong alignment on OrionDamageableObjective_Base_CanTargetActor");
static_assert(sizeof(OrionDamageableObjective_Base_CanTargetActor) == 0x000010, "Wrong size on OrionDamageableObjective_Base_CanTargetActor");
static_assert(offsetof(OrionDamageableObjective_Base_CanTargetActor, InTarget) == 0x000000, "Member 'OrionDamageableObjective_Base_CanTargetActor::InTarget' has a wrong offset!");
static_assert(offsetof(OrionDamageableObjective_Base_CanTargetActor, bInIgnoreHeight) == 0x000008, "Member 'OrionDamageableObjective_Base_CanTargetActor::bInIgnoreHeight' has a wrong offset!");
static_assert(offsetof(OrionDamageableObjective_Base_CanTargetActor, ReturnValue) == 0x000009, "Member 'OrionDamageableObjective_Base_CanTargetActor::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionDamageableObjective_Base.GetAllValidTargets
// 0x0018 (0x0018 - 0x0000)
struct OrionDamageableObjective_Base_GetAllValidTargets final
{
public:
	TArray<class AActor*>                         OutTargetArray;                                    // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bInIgnoreHeight;                                   // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionDamageableObjective_Base_GetAllValidTargets) == 0x000008, "Wrong alignment on OrionDamageableObjective_Base_GetAllValidTargets");
static_assert(sizeof(OrionDamageableObjective_Base_GetAllValidTargets) == 0x000018, "Wrong size on OrionDamageableObjective_Base_GetAllValidTargets");
static_assert(offsetof(OrionDamageableObjective_Base_GetAllValidTargets, OutTargetArray) == 0x000000, "Member 'OrionDamageableObjective_Base_GetAllValidTargets::OutTargetArray' has a wrong offset!");
static_assert(offsetof(OrionDamageableObjective_Base_GetAllValidTargets, bInIgnoreHeight) == 0x000010, "Member 'OrionDamageableObjective_Base_GetAllValidTargets::bInIgnoreHeight' has a wrong offset!");

// Function OrionGame.OrionDamageableObjective_Base.GetBaseAttackingMesh
// 0x0008 (0x0008 - 0x0000)
struct OrionDamageableObjective_Base_GetBaseAttackingMesh final
{
public:
	class UMeshComponent*                         ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableObjective_Base_GetBaseAttackingMesh) == 0x000008, "Wrong alignment on OrionDamageableObjective_Base_GetBaseAttackingMesh");
static_assert(sizeof(OrionDamageableObjective_Base_GetBaseAttackingMesh) == 0x000008, "Wrong size on OrionDamageableObjective_Base_GetBaseAttackingMesh");
static_assert(offsetof(OrionDamageableObjective_Base_GetBaseAttackingMesh, ReturnValue) == 0x000000, "Member 'OrionDamageableObjective_Base_GetBaseAttackingMesh::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionDamageableObjective_Base.GetBaseAttackingSocketName
// 0x0008 (0x0008 - 0x0000)
struct OrionDamageableObjective_Base_GetBaseAttackingSocketName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableObjective_Base_GetBaseAttackingSocketName) == 0x000004, "Wrong alignment on OrionDamageableObjective_Base_GetBaseAttackingSocketName");
static_assert(sizeof(OrionDamageableObjective_Base_GetBaseAttackingSocketName) == 0x000008, "Wrong size on OrionDamageableObjective_Base_GetBaseAttackingSocketName");
static_assert(offsetof(OrionDamageableObjective_Base_GetBaseAttackingSocketName, ReturnValue) == 0x000000, "Member 'OrionDamageableObjective_Base_GetBaseAttackingSocketName::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionDamageableObjective_Base.GetNumberOfTargetsToAttack
// 0x0004 (0x0004 - 0x0000)
struct OrionDamageableObjective_Base_GetNumberOfTargetsToAttack final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableObjective_Base_GetNumberOfTargetsToAttack) == 0x000004, "Wrong alignment on OrionDamageableObjective_Base_GetNumberOfTargetsToAttack");
static_assert(sizeof(OrionDamageableObjective_Base_GetNumberOfTargetsToAttack) == 0x000004, "Wrong size on OrionDamageableObjective_Base_GetNumberOfTargetsToAttack");
static_assert(offsetof(OrionDamageableObjective_Base_GetNumberOfTargetsToAttack, ReturnValue) == 0x000000, "Member 'OrionDamageableObjective_Base_GetNumberOfTargetsToAttack::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionDamageableObjective_Base.GetTargetsToAttack
// 0x0010 (0x0010 - 0x0000)
struct OrionDamageableObjective_Base_GetTargetsToAttack final
{
public:
	TArray<class AActor*>                         OutTargetArray;                                    // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableObjective_Base_GetTargetsToAttack) == 0x000008, "Wrong alignment on OrionDamageableObjective_Base_GetTargetsToAttack");
static_assert(sizeof(OrionDamageableObjective_Base_GetTargetsToAttack) == 0x000010, "Wrong size on OrionDamageableObjective_Base_GetTargetsToAttack");
static_assert(offsetof(OrionDamageableObjective_Base_GetTargetsToAttack, OutTargetArray) == 0x000000, "Member 'OrionDamageableObjective_Base_GetTargetsToAttack::OutTargetArray' has a wrong offset!");

// Function OrionGame.OrionDamageableObjective_Base.HandleCallForHelp
// 0x02A8 (0x02A8 - 0x0000)
struct OrionDamageableObjective_Base_HandleCallForHelp final
{
public:
	class AActor*                                 DamagedActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 AttackingActor;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpec                    EffectSpec;                                        // 0x0010(0x0298)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableObjective_Base_HandleCallForHelp) == 0x000008, "Wrong alignment on OrionDamageableObjective_Base_HandleCallForHelp");
static_assert(sizeof(OrionDamageableObjective_Base_HandleCallForHelp) == 0x0002A8, "Wrong size on OrionDamageableObjective_Base_HandleCallForHelp");
static_assert(offsetof(OrionDamageableObjective_Base_HandleCallForHelp, DamagedActor) == 0x000000, "Member 'OrionDamageableObjective_Base_HandleCallForHelp::DamagedActor' has a wrong offset!");
static_assert(offsetof(OrionDamageableObjective_Base_HandleCallForHelp, AttackingActor) == 0x000008, "Member 'OrionDamageableObjective_Base_HandleCallForHelp::AttackingActor' has a wrong offset!");
static_assert(offsetof(OrionDamageableObjective_Base_HandleCallForHelp, EffectSpec) == 0x000010, "Member 'OrionDamageableObjective_Base_HandleCallForHelp::EffectSpec' has a wrong offset!");

// Function OrionGame.OrionDamageableObjective_Base.HandleTargetActorTeamChanged
// 0x0010 (0x0010 - 0x0000)
struct OrionDamageableObjective_Base_HandleTargetActorTeamChanged final
{
public:
	class AOrionChar*                             TeamChangeChar;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    NewTeamNum;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionDamageableObjective_Base_HandleTargetActorTeamChanged) == 0x000008, "Wrong alignment on OrionDamageableObjective_Base_HandleTargetActorTeamChanged");
static_assert(sizeof(OrionDamageableObjective_Base_HandleTargetActorTeamChanged) == 0x000010, "Wrong size on OrionDamageableObjective_Base_HandleTargetActorTeamChanged");
static_assert(offsetof(OrionDamageableObjective_Base_HandleTargetActorTeamChanged, TeamChangeChar) == 0x000000, "Member 'OrionDamageableObjective_Base_HandleTargetActorTeamChanged::TeamChangeChar' has a wrong offset!");
static_assert(offsetof(OrionDamageableObjective_Base_HandleTargetActorTeamChanged, NewTeamNum) == 0x000008, "Member 'OrionDamageableObjective_Base_HandleTargetActorTeamChanged::NewTeamNum' has a wrong offset!");

// Function OrionGame.OrionDamageableObjective_Base.OnBackdoorProtectionChanged
// 0x0001 (0x0001 - 0x0000)
struct OrionDamageableObjective_Base_OnBackdoorProtectionChanged final
{
public:
	bool                                          bOn;                                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableObjective_Base_OnBackdoorProtectionChanged) == 0x000001, "Wrong alignment on OrionDamageableObjective_Base_OnBackdoorProtectionChanged");
static_assert(sizeof(OrionDamageableObjective_Base_OnBackdoorProtectionChanged) == 0x000001, "Wrong size on OrionDamageableObjective_Base_OnBackdoorProtectionChanged");
static_assert(offsetof(OrionDamageableObjective_Base_OnBackdoorProtectionChanged, bOn) == 0x000000, "Member 'OrionDamageableObjective_Base_OnBackdoorProtectionChanged::bOn' has a wrong offset!");

// Function OrionGame.OrionDamageableObjective_Base.OnRep_TargetingVolume
// 0x0008 (0x0008 - 0x0000)
struct OrionDamageableObjective_Base_OnRep_TargetingVolume final
{
public:
	class AVolume*                                OldTargetingVolume;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableObjective_Base_OnRep_TargetingVolume) == 0x000008, "Wrong alignment on OrionDamageableObjective_Base_OnRep_TargetingVolume");
static_assert(sizeof(OrionDamageableObjective_Base_OnRep_TargetingVolume) == 0x000008, "Wrong size on OrionDamageableObjective_Base_OnRep_TargetingVolume");
static_assert(offsetof(OrionDamageableObjective_Base_OnRep_TargetingVolume, OldTargetingVolume) == 0x000000, "Member 'OrionDamageableObjective_Base_OnRep_TargetingVolume::OldTargetingVolume' has a wrong offset!");

// Function OrionGame.OrionDamageableObjective_Base.SetCurrentTarget
// 0x0008 (0x0008 - 0x0000)
struct OrionDamageableObjective_Base_SetCurrentTarget final
{
public:
	class AActor*                                 InNewTarget;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableObjective_Base_SetCurrentTarget) == 0x000008, "Wrong alignment on OrionDamageableObjective_Base_SetCurrentTarget");
static_assert(sizeof(OrionDamageableObjective_Base_SetCurrentTarget) == 0x000008, "Wrong size on OrionDamageableObjective_Base_SetCurrentTarget");
static_assert(offsetof(OrionDamageableObjective_Base_SetCurrentTarget, InNewTarget) == 0x000000, "Member 'OrionDamageableObjective_Base_SetCurrentTarget::InNewTarget' has a wrong offset!");

// Function OrionGame.OrionDamageableObjective_Base.SetTargetingBeamComp
// 0x0008 (0x0008 - 0x0000)
struct OrionDamageableObjective_Base_SetTargetingBeamComp final
{
public:
	class UParticleSystemComponent*               InTargetingBeam;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableObjective_Base_SetTargetingBeamComp) == 0x000008, "Wrong alignment on OrionDamageableObjective_Base_SetTargetingBeamComp");
static_assert(sizeof(OrionDamageableObjective_Base_SetTargetingBeamComp) == 0x000008, "Wrong size on OrionDamageableObjective_Base_SetTargetingBeamComp");
static_assert(offsetof(OrionDamageableObjective_Base_SetTargetingBeamComp, InTargetingBeam) == 0x000000, "Member 'OrionDamageableObjective_Base_SetTargetingBeamComp::InTargetingBeam' has a wrong offset!");

// Function OrionGame.OrionDamageableObjective_Base.TargetAcquired
// 0x0008 (0x0008 - 0x0000)
struct OrionDamageableObjective_Base_TargetAcquired final
{
public:
	class AActor*                                 NewTarget;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableObjective_Base_TargetAcquired) == 0x000008, "Wrong alignment on OrionDamageableObjective_Base_TargetAcquired");
static_assert(sizeof(OrionDamageableObjective_Base_TargetAcquired) == 0x000008, "Wrong size on OrionDamageableObjective_Base_TargetAcquired");
static_assert(offsetof(OrionDamageableObjective_Base_TargetAcquired, NewTarget) == 0x000000, "Member 'OrionDamageableObjective_Base_TargetAcquired::NewTarget' has a wrong offset!");

// Function OrionGame.OrionDamageableObjective_Base.TargetEndOverlap
// 0x0010 (0x0010 - 0x0000)
struct OrionDamageableObjective_Base_TargetEndOverlap final
{
public:
	class AActor*                                 SelfActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableObjective_Base_TargetEndOverlap) == 0x000008, "Wrong alignment on OrionDamageableObjective_Base_TargetEndOverlap");
static_assert(sizeof(OrionDamageableObjective_Base_TargetEndOverlap) == 0x000010, "Wrong size on OrionDamageableObjective_Base_TargetEndOverlap");
static_assert(offsetof(OrionDamageableObjective_Base_TargetEndOverlap, SelfActor) == 0x000000, "Member 'OrionDamageableObjective_Base_TargetEndOverlap::SelfActor' has a wrong offset!");
static_assert(offsetof(OrionDamageableObjective_Base_TargetEndOverlap, OtherActor) == 0x000008, "Member 'OrionDamageableObjective_Base_TargetEndOverlap::OtherActor' has a wrong offset!");

// Function OrionGame.OrionDamageableObjective_Base.TargetStartOverlap
// 0x0010 (0x0010 - 0x0000)
struct OrionDamageableObjective_Base_TargetStartOverlap final
{
public:
	class AActor*                                 SelfActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableObjective_Base_TargetStartOverlap) == 0x000008, "Wrong alignment on OrionDamageableObjective_Base_TargetStartOverlap");
static_assert(sizeof(OrionDamageableObjective_Base_TargetStartOverlap) == 0x000010, "Wrong size on OrionDamageableObjective_Base_TargetStartOverlap");
static_assert(offsetof(OrionDamageableObjective_Base_TargetStartOverlap, SelfActor) == 0x000000, "Member 'OrionDamageableObjective_Base_TargetStartOverlap::SelfActor' has a wrong offset!");
static_assert(offsetof(OrionDamageableObjective_Base_TargetStartOverlap, OtherActor) == 0x000008, "Member 'OrionDamageableObjective_Base_TargetStartOverlap::OtherActor' has a wrong offset!");

// Function OrionGame.OrionDamageableObjective_Base.UpdateTargeting
// 0x0001 (0x0001 - 0x0000)
struct OrionDamageableObjective_Base_UpdateTargeting final
{
public:
	bool                                          bInIgnoreHeight;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableObjective_Base_UpdateTargeting) == 0x000001, "Wrong alignment on OrionDamageableObjective_Base_UpdateTargeting");
static_assert(sizeof(OrionDamageableObjective_Base_UpdateTargeting) == 0x000001, "Wrong size on OrionDamageableObjective_Base_UpdateTargeting");
static_assert(offsetof(OrionDamageableObjective_Base_UpdateTargeting, bInIgnoreHeight) == 0x000000, "Member 'OrionDamageableObjective_Base_UpdateTargeting::bInIgnoreHeight' has a wrong offset!");

// Function OrionGame.OrionDamageableObjective_Base.GetAttackHeight
// 0x0004 (0x0004 - 0x0000)
struct OrionDamageableObjective_Base_GetAttackHeight final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableObjective_Base_GetAttackHeight) == 0x000004, "Wrong alignment on OrionDamageableObjective_Base_GetAttackHeight");
static_assert(sizeof(OrionDamageableObjective_Base_GetAttackHeight) == 0x000004, "Wrong size on OrionDamageableObjective_Base_GetAttackHeight");
static_assert(offsetof(OrionDamageableObjective_Base_GetAttackHeight, ReturnValue) == 0x000000, "Member 'OrionDamageableObjective_Base_GetAttackHeight::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionDamageableObjective_Base.GetAttackRadius
// 0x0004 (0x0004 - 0x0000)
struct OrionDamageableObjective_Base_GetAttackRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableObjective_Base_GetAttackRadius) == 0x000004, "Wrong alignment on OrionDamageableObjective_Base_GetAttackRadius");
static_assert(sizeof(OrionDamageableObjective_Base_GetAttackRadius) == 0x000004, "Wrong size on OrionDamageableObjective_Base_GetAttackRadius");
static_assert(offsetof(OrionDamageableObjective_Base_GetAttackRadius, ReturnValue) == 0x000000, "Member 'OrionDamageableObjective_Base_GetAttackRadius::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionDamageableObjective_Base.GetAttackSpeed
// 0x0004 (0x0004 - 0x0000)
struct OrionDamageableObjective_Base_GetAttackSpeed final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableObjective_Base_GetAttackSpeed) == 0x000004, "Wrong alignment on OrionDamageableObjective_Base_GetAttackSpeed");
static_assert(sizeof(OrionDamageableObjective_Base_GetAttackSpeed) == 0x000004, "Wrong size on OrionDamageableObjective_Base_GetAttackSpeed");
static_assert(offsetof(OrionDamageableObjective_Base_GetAttackSpeed, ReturnValue) == 0x000000, "Member 'OrionDamageableObjective_Base_GetAttackSpeed::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionDamageableObjective_Base.GetCollisionCapsuleComponent
// 0x0008 (0x0008 - 0x0000)
struct OrionDamageableObjective_Base_GetCollisionCapsuleComponent final
{
public:
	class UCapsuleComponent*                      ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableObjective_Base_GetCollisionCapsuleComponent) == 0x000008, "Wrong alignment on OrionDamageableObjective_Base_GetCollisionCapsuleComponent");
static_assert(sizeof(OrionDamageableObjective_Base_GetCollisionCapsuleComponent) == 0x000008, "Wrong size on OrionDamageableObjective_Base_GetCollisionCapsuleComponent");
static_assert(offsetof(OrionDamageableObjective_Base_GetCollisionCapsuleComponent, ReturnValue) == 0x000000, "Member 'OrionDamageableObjective_Base_GetCollisionCapsuleComponent::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionDamageableObjective_Base.GetCurrentTarget
// 0x0008 (0x0008 - 0x0000)
struct OrionDamageableObjective_Base_GetCurrentTarget final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableObjective_Base_GetCurrentTarget) == 0x000008, "Wrong alignment on OrionDamageableObjective_Base_GetCurrentTarget");
static_assert(sizeof(OrionDamageableObjective_Base_GetCurrentTarget) == 0x000008, "Wrong size on OrionDamageableObjective_Base_GetCurrentTarget");
static_assert(offsetof(OrionDamageableObjective_Base_GetCurrentTarget, ReturnValue) == 0x000000, "Member 'OrionDamageableObjective_Base_GetCurrentTarget::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionDamageableObjective_Base.GetDisplayName
// 0x0018 (0x0018 - 0x0000)
struct OrionDamageableObjective_Base_GetDisplayName final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableObjective_Base_GetDisplayName) == 0x000008, "Wrong alignment on OrionDamageableObjective_Base_GetDisplayName");
static_assert(sizeof(OrionDamageableObjective_Base_GetDisplayName) == 0x000018, "Wrong size on OrionDamageableObjective_Base_GetDisplayName");
static_assert(offsetof(OrionDamageableObjective_Base_GetDisplayName, ReturnValue) == 0x000000, "Member 'OrionDamageableObjective_Base_GetDisplayName::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionDamageableObjective_Base.GetEffectiveAttackRange
// 0x0004 (0x0004 - 0x0000)
struct OrionDamageableObjective_Base_GetEffectiveAttackRange final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableObjective_Base_GetEffectiveAttackRange) == 0x000004, "Wrong alignment on OrionDamageableObjective_Base_GetEffectiveAttackRange");
static_assert(sizeof(OrionDamageableObjective_Base_GetEffectiveAttackRange) == 0x000004, "Wrong size on OrionDamageableObjective_Base_GetEffectiveAttackRange");
static_assert(offsetof(OrionDamageableObjective_Base_GetEffectiveAttackRange, ReturnValue) == 0x000000, "Member 'OrionDamageableObjective_Base_GetEffectiveAttackRange::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionDamageableObjective_Base.GetIcon
// 0x0028 (0x0028 - 0x0000)
struct OrionDamageableObjective_Base_GetIcon final
{
public:
	TSoftObjectPtr<class UObject>                 ReturnValue;                                       // 0x0000(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableObjective_Base_GetIcon) == 0x000008, "Wrong alignment on OrionDamageableObjective_Base_GetIcon");
static_assert(sizeof(OrionDamageableObjective_Base_GetIcon) == 0x000028, "Wrong size on OrionDamageableObjective_Base_GetIcon");
static_assert(offsetof(OrionDamageableObjective_Base_GetIcon, ReturnValue) == 0x000000, "Member 'OrionDamageableObjective_Base_GetIcon::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionDamageableObjective_Base.GetNumberOfTargetedMinions
// 0x0004 (0x0004 - 0x0000)
struct OrionDamageableObjective_Base_GetNumberOfTargetedMinions final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableObjective_Base_GetNumberOfTargetedMinions) == 0x000004, "Wrong alignment on OrionDamageableObjective_Base_GetNumberOfTargetedMinions");
static_assert(sizeof(OrionDamageableObjective_Base_GetNumberOfTargetedMinions) == 0x000004, "Wrong size on OrionDamageableObjective_Base_GetNumberOfTargetedMinions");
static_assert(offsetof(OrionDamageableObjective_Base_GetNumberOfTargetedMinions, ReturnValue) == 0x000000, "Member 'OrionDamageableObjective_Base_GetNumberOfTargetedMinions::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionDamageableObjective_Base.GetReviveSelfTimer
// 0x0004 (0x0004 - 0x0000)
struct OrionDamageableObjective_Base_GetReviveSelfTimer final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableObjective_Base_GetReviveSelfTimer) == 0x000004, "Wrong alignment on OrionDamageableObjective_Base_GetReviveSelfTimer");
static_assert(sizeof(OrionDamageableObjective_Base_GetReviveSelfTimer) == 0x000004, "Wrong size on OrionDamageableObjective_Base_GetReviveSelfTimer");
static_assert(offsetof(OrionDamageableObjective_Base_GetReviveSelfTimer, ReturnValue) == 0x000000, "Member 'OrionDamageableObjective_Base_GetReviveSelfTimer::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionDamageableObjective_Base.GetTargetingTime
// 0x0004 (0x0004 - 0x0000)
struct OrionDamageableObjective_Base_GetTargetingTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableObjective_Base_GetTargetingTime) == 0x000004, "Wrong alignment on OrionDamageableObjective_Base_GetTargetingTime");
static_assert(sizeof(OrionDamageableObjective_Base_GetTargetingTime) == 0x000004, "Wrong size on OrionDamageableObjective_Base_GetTargetingTime");
static_assert(offsetof(OrionDamageableObjective_Base_GetTargetingTime, ReturnValue) == 0x000000, "Member 'OrionDamageableObjective_Base_GetTargetingTime::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionDamageableObjectiveTurret.SetSkeletalMesh
// 0x0008 (0x0008 - 0x0000)
struct OrionDamageableObjectiveTurret_SetSkeletalMesh final
{
public:
	class USkeletalMeshComponent*                 InMesh;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDamageableObjectiveTurret_SetSkeletalMesh) == 0x000008, "Wrong alignment on OrionDamageableObjectiveTurret_SetSkeletalMesh");
static_assert(sizeof(OrionDamageableObjectiveTurret_SetSkeletalMesh) == 0x000008, "Wrong size on OrionDamageableObjectiveTurret_SetSkeletalMesh");
static_assert(offsetof(OrionDamageableObjectiveTurret_SetSkeletalMesh, InMesh) == 0x000000, "Member 'OrionDamageableObjectiveTurret_SetSkeletalMesh::InMesh' has a wrong offset!");

// Function OrionGame.BotObjective_Recall.CardRecall
// 0x0008 (0x0008 - 0x0000)
struct BotObjective_Recall_CardRecall final
{
public:
	class UBotPlaybook*                           Playbook;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BotObjective_Recall_CardRecall) == 0x000008, "Wrong alignment on BotObjective_Recall_CardRecall");
static_assert(sizeof(BotObjective_Recall_CardRecall) == 0x000008, "Wrong size on BotObjective_Recall_CardRecall");
static_assert(offsetof(BotObjective_Recall_CardRecall, Playbook) == 0x000000, "Member 'BotObjective_Recall_CardRecall::Playbook' has a wrong offset!");

// Function OrionGame.BotObjective_Recall.CXPRecall
// 0x0010 (0x0010 - 0x0000)
struct BotObjective_Recall_CXPRecall final
{
public:
	class UBotPlaybook*                           Playbook;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MinCardPointsToRecall;                             // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BotObjective_Recall_CXPRecall) == 0x000008, "Wrong alignment on BotObjective_Recall_CXPRecall");
static_assert(sizeof(BotObjective_Recall_CXPRecall) == 0x000010, "Wrong size on BotObjective_Recall_CXPRecall");
static_assert(offsetof(BotObjective_Recall_CXPRecall, Playbook) == 0x000000, "Member 'BotObjective_Recall_CXPRecall::Playbook' has a wrong offset!");
static_assert(offsetof(BotObjective_Recall_CXPRecall, MinCardPointsToRecall) == 0x000008, "Member 'BotObjective_Recall_CXPRecall::MinCardPointsToRecall' has a wrong offset!");

// Function OrionGame.BotObjective_Recall.GoldRecall
// 0x0010 (0x0010 - 0x0000)
struct BotObjective_Recall_GoldRecall final
{
public:
	class UBotPlaybook*                           Playbook;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinGoldToRecall;                                   // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BotObjective_Recall_GoldRecall) == 0x000008, "Wrong alignment on BotObjective_Recall_GoldRecall");
static_assert(sizeof(BotObjective_Recall_GoldRecall) == 0x000010, "Wrong size on BotObjective_Recall_GoldRecall");
static_assert(offsetof(BotObjective_Recall_GoldRecall, Playbook) == 0x000000, "Member 'BotObjective_Recall_GoldRecall::Playbook' has a wrong offset!");
static_assert(offsetof(BotObjective_Recall_GoldRecall, MinGoldToRecall) == 0x000008, "Member 'BotObjective_Recall_GoldRecall::MinGoldToRecall' has a wrong offset!");

// Function OrionGame.BotObjective_Bodyguard.BodyGuard
// 0x0010 (0x0010 - 0x0000)
struct BotObjective_Bodyguard_BodyGuard final
{
public:
	class UBotPlaybook*                           Playbook;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELaneRoleSlot                                 Role;                                              // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TetherDistance;                                    // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BotObjective_Bodyguard_BodyGuard) == 0x000008, "Wrong alignment on BotObjective_Bodyguard_BodyGuard");
static_assert(sizeof(BotObjective_Bodyguard_BodyGuard) == 0x000010, "Wrong size on BotObjective_Bodyguard_BodyGuard");
static_assert(offsetof(BotObjective_Bodyguard_BodyGuard, Playbook) == 0x000000, "Member 'BotObjective_Bodyguard_BodyGuard::Playbook' has a wrong offset!");
static_assert(offsetof(BotObjective_Bodyguard_BodyGuard, Role) == 0x000008, "Member 'BotObjective_Bodyguard_BodyGuard::Role' has a wrong offset!");
static_assert(offsetof(BotObjective_Bodyguard_BodyGuard, TetherDistance) == 0x00000C, "Member 'BotObjective_Bodyguard_BodyGuard::TetherDistance' has a wrong offset!");

// Function OrionGame.OrionTargetingMode_Base.GetTargets
// 0x0010 (0x0010 - 0x0000)
struct OrionTargetingMode_Base_GetTargets final
{
public:
	TArray<class AActor*>                         ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTargetingMode_Base_GetTargets) == 0x000008, "Wrong alignment on OrionTargetingMode_Base_GetTargets");
static_assert(sizeof(OrionTargetingMode_Base_GetTargets) == 0x000010, "Wrong size on OrionTargetingMode_Base_GetTargets");
static_assert(offsetof(OrionTargetingMode_Base_GetTargets, ReturnValue) == 0x000000, "Member 'OrionTargetingMode_Base_GetTargets::ReturnValue' has a wrong offset!");

// Function OrionGame.PhasedFunctionalTest.AddCondition
// 0x0008 (0x0008 - 0x0000)
struct PhasedFunctionalTest_AddCondition final
{
public:
	class UFunctionalTestCondition*               Condition;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhasedFunctionalTest_AddCondition) == 0x000008, "Wrong alignment on PhasedFunctionalTest_AddCondition");
static_assert(sizeof(PhasedFunctionalTest_AddCondition) == 0x000008, "Wrong size on PhasedFunctionalTest_AddCondition");
static_assert(offsetof(PhasedFunctionalTest_AddCondition, Condition) == 0x000000, "Member 'PhasedFunctionalTest_AddCondition::Condition' has a wrong offset!");

// Function OrionGame.PhasedFunctionalTest.CheckConditions
// 0x0001 (0x0001 - 0x0000)
struct PhasedFunctionalTest_CheckConditions final
{
public:
	bool                                          FinalCheck;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhasedFunctionalTest_CheckConditions) == 0x000001, "Wrong alignment on PhasedFunctionalTest_CheckConditions");
static_assert(sizeof(PhasedFunctionalTest_CheckConditions) == 0x000001, "Wrong size on PhasedFunctionalTest_CheckConditions");
static_assert(offsetof(PhasedFunctionalTest_CheckConditions, FinalCheck) == 0x000000, "Member 'PhasedFunctionalTest_CheckConditions::FinalCheck' has a wrong offset!");

// Function OrionGame.PhasedFunctionalTest.GetNextPhaseIndex
// 0x0004 (0x0004 - 0x0000)
struct PhasedFunctionalTest_GetNextPhaseIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhasedFunctionalTest_GetNextPhaseIndex) == 0x000004, "Wrong alignment on PhasedFunctionalTest_GetNextPhaseIndex");
static_assert(sizeof(PhasedFunctionalTest_GetNextPhaseIndex) == 0x000004, "Wrong size on PhasedFunctionalTest_GetNextPhaseIndex");
static_assert(offsetof(PhasedFunctionalTest_GetNextPhaseIndex, ReturnValue) == 0x000000, "Member 'PhasedFunctionalTest_GetNextPhaseIndex::ReturnValue' has a wrong offset!");

// Function OrionGame.PhasedFunctionalTest.GetPhaseLoopEnd
// 0x0008 (0x0008 - 0x0000)
struct PhasedFunctionalTest_GetPhaseLoopEnd final
{
public:
	int32                                         StartIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhasedFunctionalTest_GetPhaseLoopEnd) == 0x000004, "Wrong alignment on PhasedFunctionalTest_GetPhaseLoopEnd");
static_assert(sizeof(PhasedFunctionalTest_GetPhaseLoopEnd) == 0x000008, "Wrong size on PhasedFunctionalTest_GetPhaseLoopEnd");
static_assert(offsetof(PhasedFunctionalTest_GetPhaseLoopEnd, StartIndex) == 0x000000, "Member 'PhasedFunctionalTest_GetPhaseLoopEnd::StartIndex' has a wrong offset!");
static_assert(offsetof(PhasedFunctionalTest_GetPhaseLoopEnd, ReturnValue) == 0x000004, "Member 'PhasedFunctionalTest_GetPhaseLoopEnd::ReturnValue' has a wrong offset!");

// Function OrionGame.PhasedFunctionalTest.GetPhaseLoopStart
// 0x0008 (0x0008 - 0x0000)
struct PhasedFunctionalTest_GetPhaseLoopStart final
{
public:
	int32                                         EndIndex;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhasedFunctionalTest_GetPhaseLoopStart) == 0x000004, "Wrong alignment on PhasedFunctionalTest_GetPhaseLoopStart");
static_assert(sizeof(PhasedFunctionalTest_GetPhaseLoopStart) == 0x000008, "Wrong size on PhasedFunctionalTest_GetPhaseLoopStart");
static_assert(offsetof(PhasedFunctionalTest_GetPhaseLoopStart, EndIndex) == 0x000000, "Member 'PhasedFunctionalTest_GetPhaseLoopStart::EndIndex' has a wrong offset!");
static_assert(offsetof(PhasedFunctionalTest_GetPhaseLoopStart, ReturnValue) == 0x000004, "Member 'PhasedFunctionalTest_GetPhaseLoopStart::ReturnValue' has a wrong offset!");

// Function OrionGame.PhasedFunctionalTest.LogError
// 0x0010 (0x0010 - 0x0000)
struct PhasedFunctionalTest_LogError final
{
public:
	class FString                                 MESSAGE;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhasedFunctionalTest_LogError) == 0x000008, "Wrong alignment on PhasedFunctionalTest_LogError");
static_assert(sizeof(PhasedFunctionalTest_LogError) == 0x000010, "Wrong size on PhasedFunctionalTest_LogError");
static_assert(offsetof(PhasedFunctionalTest_LogError, MESSAGE) == 0x000000, "Member 'PhasedFunctionalTest_LogError::MESSAGE' has a wrong offset!");

// Function OrionGame.PhasedFunctionalTest.LogInfo
// 0x0010 (0x0010 - 0x0000)
struct PhasedFunctionalTest_LogInfo final
{
public:
	class FString                                 MESSAGE;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhasedFunctionalTest_LogInfo) == 0x000008, "Wrong alignment on PhasedFunctionalTest_LogInfo");
static_assert(sizeof(PhasedFunctionalTest_LogInfo) == 0x000010, "Wrong size on PhasedFunctionalTest_LogInfo");
static_assert(offsetof(PhasedFunctionalTest_LogInfo, MESSAGE) == 0x000000, "Member 'PhasedFunctionalTest_LogInfo::MESSAGE' has a wrong offset!");

// Function OrionGame.PhasedFunctionalTest.LogVerbose
// 0x0010 (0x0010 - 0x0000)
struct PhasedFunctionalTest_LogVerbose final
{
public:
	class FString                                 MESSAGE;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhasedFunctionalTest_LogVerbose) == 0x000008, "Wrong alignment on PhasedFunctionalTest_LogVerbose");
static_assert(sizeof(PhasedFunctionalTest_LogVerbose) == 0x000010, "Wrong size on PhasedFunctionalTest_LogVerbose");
static_assert(offsetof(PhasedFunctionalTest_LogVerbose, MESSAGE) == 0x000000, "Member 'PhasedFunctionalTest_LogVerbose::MESSAGE' has a wrong offset!");

// Function OrionGame.PhasedFunctionalTest.LogWarning
// 0x0010 (0x0010 - 0x0000)
struct PhasedFunctionalTest_LogWarning final
{
public:
	class FString                                 MESSAGE;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhasedFunctionalTest_LogWarning) == 0x000008, "Wrong alignment on PhasedFunctionalTest_LogWarning");
static_assert(sizeof(PhasedFunctionalTest_LogWarning) == 0x000010, "Wrong size on PhasedFunctionalTest_LogWarning");
static_assert(offsetof(PhasedFunctionalTest_LogWarning, MESSAGE) == 0x000000, "Member 'PhasedFunctionalTest_LogWarning::MESSAGE' has a wrong offset!");

// Function OrionGame.PhasedFunctionalTest.SetUpPhaseLooping
// 0x0010 (0x0010 - 0x0000)
struct PhasedFunctionalTest_SetUpPhaseLooping final
{
public:
	class UPhaseLoopStart*                        StartPhase;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PhasedFunctionalTest_SetUpPhaseLooping) == 0x000008, "Wrong alignment on PhasedFunctionalTest_SetUpPhaseLooping");
static_assert(sizeof(PhasedFunctionalTest_SetUpPhaseLooping) == 0x000010, "Wrong size on PhasedFunctionalTest_SetUpPhaseLooping");
static_assert(offsetof(PhasedFunctionalTest_SetUpPhaseLooping, StartPhase) == 0x000000, "Member 'PhasedFunctionalTest_SetUpPhaseLooping::StartPhase' has a wrong offset!");
static_assert(offsetof(PhasedFunctionalTest_SetUpPhaseLooping, ReturnValue) == 0x000008, "Member 'PhasedFunctionalTest_SetUpPhaseLooping::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPhasedFunctionalTest.CacheFloat
// 0x0018 (0x0018 - 0x0000)
struct OrionPhasedFunctionalTest_CacheFloat final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionPhasedFunctionalTest_CacheFloat) == 0x000008, "Wrong alignment on OrionPhasedFunctionalTest_CacheFloat");
static_assert(sizeof(OrionPhasedFunctionalTest_CacheFloat) == 0x000018, "Wrong size on OrionPhasedFunctionalTest_CacheFloat");
static_assert(offsetof(OrionPhasedFunctionalTest_CacheFloat, Key) == 0x000000, "Member 'OrionPhasedFunctionalTest_CacheFloat::Key' has a wrong offset!");
static_assert(offsetof(OrionPhasedFunctionalTest_CacheFloat, Value) == 0x000010, "Member 'OrionPhasedFunctionalTest_CacheFloat::Value' has a wrong offset!");

// Function OrionGame.OrionPhasedFunctionalTest.FindCachedFloat
// 0x0018 (0x0018 - 0x0000)
struct OrionPhasedFunctionalTest_FindCachedFloat final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutValue;                                          // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionPhasedFunctionalTest_FindCachedFloat) == 0x000008, "Wrong alignment on OrionPhasedFunctionalTest_FindCachedFloat");
static_assert(sizeof(OrionPhasedFunctionalTest_FindCachedFloat) == 0x000018, "Wrong size on OrionPhasedFunctionalTest_FindCachedFloat");
static_assert(offsetof(OrionPhasedFunctionalTest_FindCachedFloat, Key) == 0x000000, "Member 'OrionPhasedFunctionalTest_FindCachedFloat::Key' has a wrong offset!");
static_assert(offsetof(OrionPhasedFunctionalTest_FindCachedFloat, OutValue) == 0x000010, "Member 'OrionPhasedFunctionalTest_FindCachedFloat::OutValue' has a wrong offset!");
static_assert(offsetof(OrionPhasedFunctionalTest_FindCachedFloat, ReturnValue) == 0x000014, "Member 'OrionPhasedFunctionalTest_FindCachedFloat::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPhasedFunctionalTest.GetAutomationContext
// 0x0008 (0x0008 - 0x0000)
struct OrionPhasedFunctionalTest_GetAutomationContext final
{
public:
	class UAutomationContext*                     ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPhasedFunctionalTest_GetAutomationContext) == 0x000008, "Wrong alignment on OrionPhasedFunctionalTest_GetAutomationContext");
static_assert(sizeof(OrionPhasedFunctionalTest_GetAutomationContext) == 0x000008, "Wrong size on OrionPhasedFunctionalTest_GetAutomationContext");
static_assert(offsetof(OrionPhasedFunctionalTest_GetAutomationContext, ReturnValue) == 0x000000, "Member 'OrionPhasedFunctionalTest_GetAutomationContext::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPhasedFunctionalTest.GetMapObjective
// 0x0010 (0x0010 - 0x0000)
struct OrionPhasedFunctionalTest_GetMapObjective final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrionDamageableActor*                  ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPhasedFunctionalTest_GetMapObjective) == 0x000008, "Wrong alignment on OrionPhasedFunctionalTest_GetMapObjective");
static_assert(sizeof(OrionPhasedFunctionalTest_GetMapObjective) == 0x000010, "Wrong size on OrionPhasedFunctionalTest_GetMapObjective");
static_assert(offsetof(OrionPhasedFunctionalTest_GetMapObjective, Index_0) == 0x000000, "Member 'OrionPhasedFunctionalTest_GetMapObjective::Index_0' has a wrong offset!");
static_assert(offsetof(OrionPhasedFunctionalTest_GetMapObjective, ReturnValue) == 0x000008, "Member 'OrionPhasedFunctionalTest_GetMapObjective::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPhasedFunctionalTest.GetPawnInfo
// 0x0020 (0x0020 - 0x0000)
struct OrionPhasedFunctionalTest_GetPawnInfo final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAutomationPawnInfo                    ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPhasedFunctionalTest_GetPawnInfo) == 0x000008, "Wrong alignment on OrionPhasedFunctionalTest_GetPawnInfo");
static_assert(sizeof(OrionPhasedFunctionalTest_GetPawnInfo) == 0x000020, "Wrong size on OrionPhasedFunctionalTest_GetPawnInfo");
static_assert(offsetof(OrionPhasedFunctionalTest_GetPawnInfo, Index_0) == 0x000000, "Member 'OrionPhasedFunctionalTest_GetPawnInfo::Index_0' has a wrong offset!");
static_assert(offsetof(OrionPhasedFunctionalTest_GetPawnInfo, ReturnValue) == 0x000008, "Member 'OrionPhasedFunctionalTest_GetPawnInfo::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPhasedFunctionalTest.GetSharedConfig
// 0x0008 (0x0008 - 0x0000)
struct OrionPhasedFunctionalTest_GetSharedConfig final
{
public:
	class UOrionFunctionalTestConfig*             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPhasedFunctionalTest_GetSharedConfig) == 0x000008, "Wrong alignment on OrionPhasedFunctionalTest_GetSharedConfig");
static_assert(sizeof(OrionPhasedFunctionalTest_GetSharedConfig) == 0x000008, "Wrong size on OrionPhasedFunctionalTest_GetSharedConfig");
static_assert(offsetof(OrionPhasedFunctionalTest_GetSharedConfig, ReturnValue) == 0x000000, "Member 'OrionPhasedFunctionalTest_GetSharedConfig::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPhasedFunctionalTest.GetSublevelViewTargetCollector_Internal
// 0x0008 (0x0008 - 0x0000)
struct OrionPhasedFunctionalTest_GetSublevelViewTargetCollector_Internal final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPhasedFunctionalTest_GetSublevelViewTargetCollector_Internal) == 0x000008, "Wrong alignment on OrionPhasedFunctionalTest_GetSublevelViewTargetCollector_Internal");
static_assert(sizeof(OrionPhasedFunctionalTest_GetSublevelViewTargetCollector_Internal) == 0x000008, "Wrong size on OrionPhasedFunctionalTest_GetSublevelViewTargetCollector_Internal");
static_assert(offsetof(OrionPhasedFunctionalTest_GetSublevelViewTargetCollector_Internal, ReturnValue) == 0x000000, "Member 'OrionPhasedFunctionalTest_GetSublevelViewTargetCollector_Internal::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPhasedFunctionalTest.GetTestActor
// 0x0018 (0x0018 - 0x0000)
struct OrionPhasedFunctionalTest_GetTestActor final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPhasedFunctionalTest_GetTestActor) == 0x000008, "Wrong alignment on OrionPhasedFunctionalTest_GetTestActor");
static_assert(sizeof(OrionPhasedFunctionalTest_GetTestActor) == 0x000018, "Wrong size on OrionPhasedFunctionalTest_GetTestActor");
static_assert(offsetof(OrionPhasedFunctionalTest_GetTestActor, Key) == 0x000000, "Member 'OrionPhasedFunctionalTest_GetTestActor::Key' has a wrong offset!");
static_assert(offsetof(OrionPhasedFunctionalTest_GetTestActor, ReturnValue) == 0x000010, "Member 'OrionPhasedFunctionalTest_GetTestActor::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPhasedFunctionalTest.ListenToGameplayCueRoutedEvent
// 0x0001 (0x0001 - 0x0000)
struct OrionPhasedFunctionalTest_ListenToGameplayCueRoutedEvent final
{
public:
	bool                                          EnableGameplayCueLogging;                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPhasedFunctionalTest_ListenToGameplayCueRoutedEvent) == 0x000001, "Wrong alignment on OrionPhasedFunctionalTest_ListenToGameplayCueRoutedEvent");
static_assert(sizeof(OrionPhasedFunctionalTest_ListenToGameplayCueRoutedEvent) == 0x000001, "Wrong size on OrionPhasedFunctionalTest_ListenToGameplayCueRoutedEvent");
static_assert(offsetof(OrionPhasedFunctionalTest_ListenToGameplayCueRoutedEvent, EnableGameplayCueLogging) == 0x000000, "Member 'OrionPhasedFunctionalTest_ListenToGameplayCueRoutedEvent::EnableGameplayCueLogging' has a wrong offset!");

// Function OrionGame.OrionPhasedFunctionalTest.RecordGameplayCueDebugString
// 0x00D0 (0x00D0 - 0x0000)
struct OrionPhasedFunctionalTest_RecordGameplayCueDebugString final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayCueEvent                             EventType;                                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayCueParameters                 Parameters;                                        // 0x0018(0x00B8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPhasedFunctionalTest_RecordGameplayCueDebugString) == 0x000008, "Wrong alignment on OrionPhasedFunctionalTest_RecordGameplayCueDebugString");
static_assert(sizeof(OrionPhasedFunctionalTest_RecordGameplayCueDebugString) == 0x0000D0, "Wrong size on OrionPhasedFunctionalTest_RecordGameplayCueDebugString");
static_assert(offsetof(OrionPhasedFunctionalTest_RecordGameplayCueDebugString, TargetActor) == 0x000000, "Member 'OrionPhasedFunctionalTest_RecordGameplayCueDebugString::TargetActor' has a wrong offset!");
static_assert(offsetof(OrionPhasedFunctionalTest_RecordGameplayCueDebugString, GameplayCueTag) == 0x000008, "Member 'OrionPhasedFunctionalTest_RecordGameplayCueDebugString::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(OrionPhasedFunctionalTest_RecordGameplayCueDebugString, EventType) == 0x000010, "Member 'OrionPhasedFunctionalTest_RecordGameplayCueDebugString::EventType' has a wrong offset!");
static_assert(offsetof(OrionPhasedFunctionalTest_RecordGameplayCueDebugString, Parameters) == 0x000018, "Member 'OrionPhasedFunctionalTest_RecordGameplayCueDebugString::Parameters' has a wrong offset!");

// Function OrionGame.OrionPhasedFunctionalTest.SetPawnInfo
// 0x0010 (0x0010 - 0x0000)
struct OrionPhasedFunctionalTest_SetPawnInfo final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrionChar*                             OrionChar;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPhasedFunctionalTest_SetPawnInfo) == 0x000008, "Wrong alignment on OrionPhasedFunctionalTest_SetPawnInfo");
static_assert(sizeof(OrionPhasedFunctionalTest_SetPawnInfo) == 0x000010, "Wrong size on OrionPhasedFunctionalTest_SetPawnInfo");
static_assert(offsetof(OrionPhasedFunctionalTest_SetPawnInfo, Index_0) == 0x000000, "Member 'OrionPhasedFunctionalTest_SetPawnInfo::Index_0' has a wrong offset!");
static_assert(offsetof(OrionPhasedFunctionalTest_SetPawnInfo, OrionChar) == 0x000008, "Member 'OrionPhasedFunctionalTest_SetPawnInfo::OrionChar' has a wrong offset!");

// Function OrionGame.OrionPhasedFunctionalTest.SetSublevelViewTargetCollector
// 0x0008 (0x0008 - 0x0000)
struct OrionPhasedFunctionalTest_SetSublevelViewTargetCollector final
{
public:
	class AActor*                                 NewCollector;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPhasedFunctionalTest_SetSublevelViewTargetCollector) == 0x000008, "Wrong alignment on OrionPhasedFunctionalTest_SetSublevelViewTargetCollector");
static_assert(sizeof(OrionPhasedFunctionalTest_SetSublevelViewTargetCollector) == 0x000008, "Wrong size on OrionPhasedFunctionalTest_SetSublevelViewTargetCollector");
static_assert(offsetof(OrionPhasedFunctionalTest_SetSublevelViewTargetCollector, NewCollector) == 0x000000, "Member 'OrionPhasedFunctionalTest_SetSublevelViewTargetCollector::NewCollector' has a wrong offset!");

// Function OrionGame.OrionPhasedFunctionalTest.SetTestActor
// 0x0018 (0x0018 - 0x0000)
struct OrionPhasedFunctionalTest_SetTestActor final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPhasedFunctionalTest_SetTestActor) == 0x000008, "Wrong alignment on OrionPhasedFunctionalTest_SetTestActor");
static_assert(sizeof(OrionPhasedFunctionalTest_SetTestActor) == 0x000018, "Wrong size on OrionPhasedFunctionalTest_SetTestActor");
static_assert(offsetof(OrionPhasedFunctionalTest_SetTestActor, Key) == 0x000000, "Member 'OrionPhasedFunctionalTest_SetTestActor::Key' has a wrong offset!");
static_assert(offsetof(OrionPhasedFunctionalTest_SetTestActor, Actor) == 0x000010, "Member 'OrionPhasedFunctionalTest_SetTestActor::Actor' has a wrong offset!");

// Function OrionGame.OrionDynamicWall.ConstructWall
// 0x0024 (0x0024 - 0x0000)
struct OrionDynamicWall_ConstructWall final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         InAbilityLevel;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SegmentCountClamp;                                 // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionDynamicWall_ConstructWall) == 0x000004, "Wrong alignment on OrionDynamicWall_ConstructWall");
static_assert(sizeof(OrionDynamicWall_ConstructWall) == 0x000024, "Wrong size on OrionDynamicWall_ConstructWall");
static_assert(offsetof(OrionDynamicWall_ConstructWall, Location) == 0x000000, "Member 'OrionDynamicWall_ConstructWall::Location' has a wrong offset!");
static_assert(offsetof(OrionDynamicWall_ConstructWall, Rotation) == 0x00000C, "Member 'OrionDynamicWall_ConstructWall::Rotation' has a wrong offset!");
static_assert(offsetof(OrionDynamicWall_ConstructWall, InAbilityLevel) == 0x000018, "Member 'OrionDynamicWall_ConstructWall::InAbilityLevel' has a wrong offset!");
static_assert(offsetof(OrionDynamicWall_ConstructWall, SegmentCountClamp) == 0x00001C, "Member 'OrionDynamicWall_ConstructWall::SegmentCountClamp' has a wrong offset!");
static_assert(offsetof(OrionDynamicWall_ConstructWall, ReturnValue) == 0x000020, "Member 'OrionDynamicWall_ConstructWall::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionDynamicWall.ConstructWallWithTargetData
// 0x0030 (0x0030 - 0x0000)
struct OrionDynamicWall_ConstructWallWithTargetData final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0000(0x0020)(Parm, NativeAccessSpecifierPublic)
	int32                                         InAbilityLevel;                                    // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SegmentCountClamp;                                 // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionDynamicWall_ConstructWallWithTargetData) == 0x000008, "Wrong alignment on OrionDynamicWall_ConstructWallWithTargetData");
static_assert(sizeof(OrionDynamicWall_ConstructWallWithTargetData) == 0x000030, "Wrong size on OrionDynamicWall_ConstructWallWithTargetData");
static_assert(offsetof(OrionDynamicWall_ConstructWallWithTargetData, TargetData) == 0x000000, "Member 'OrionDynamicWall_ConstructWallWithTargetData::TargetData' has a wrong offset!");
static_assert(offsetof(OrionDynamicWall_ConstructWallWithTargetData, InAbilityLevel) == 0x000020, "Member 'OrionDynamicWall_ConstructWallWithTargetData::InAbilityLevel' has a wrong offset!");
static_assert(offsetof(OrionDynamicWall_ConstructWallWithTargetData, SegmentCountClamp) == 0x000024, "Member 'OrionDynamicWall_ConstructWallWithTargetData::SegmentCountClamp' has a wrong offset!");
static_assert(offsetof(OrionDynamicWall_ConstructWallWithTargetData, ReturnValue) == 0x000028, "Member 'OrionDynamicWall_ConstructWallWithTargetData::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionDynamicWall.OnRep_ConstructionToggle
// 0x0001 (0x0001 - 0x0000)
struct OrionDynamicWall_OnRep_ConstructionToggle final
{
public:
	bool                                          OldConstructionToggle;                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDynamicWall_OnRep_ConstructionToggle) == 0x000001, "Wrong alignment on OrionDynamicWall_OnRep_ConstructionToggle");
static_assert(sizeof(OrionDynamicWall_OnRep_ConstructionToggle) == 0x000001, "Wrong size on OrionDynamicWall_OnRep_ConstructionToggle");
static_assert(offsetof(OrionDynamicWall_OnRep_ConstructionToggle, OldConstructionToggle) == 0x000000, "Member 'OrionDynamicWall_OnRep_ConstructionToggle::OldConstructionToggle' has a wrong offset!");

// Function OrionGame.OrionDamageNumberManager.GetDamageNumberOffset
// 0x0118 (0x0118 - 0x0000)
struct OrionDamageNumberManager_GetDamageNumberOffset final
{
public:
	struct FOrionDamageNumberInfo                 DamageNumberInfo;                                  // 0x0000(0x0108)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0108(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionDamageNumberManager_GetDamageNumberOffset) == 0x000008, "Wrong alignment on OrionDamageNumberManager_GetDamageNumberOffset");
static_assert(sizeof(OrionDamageNumberManager_GetDamageNumberOffset) == 0x000118, "Wrong size on OrionDamageNumberManager_GetDamageNumberOffset");
static_assert(offsetof(OrionDamageNumberManager_GetDamageNumberOffset, DamageNumberInfo) == 0x000000, "Member 'OrionDamageNumberManager_GetDamageNumberOffset::DamageNumberInfo' has a wrong offset!");
static_assert(offsetof(OrionDamageNumberManager_GetDamageNumberOffset, ReturnValue) == 0x000108, "Member 'OrionDamageNumberManager_GetDamageNumberOffset::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionDamageNumberManager.GetDamageNumberStartLocation
// 0x0118 (0x0118 - 0x0000)
struct OrionDamageNumberManager_GetDamageNumberStartLocation final
{
public:
	struct FOrionDamageNumberInfo                 DamageNumberInfo;                                  // 0x0000(0x0108)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0108(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionDamageNumberManager_GetDamageNumberStartLocation) == 0x000008, "Wrong alignment on OrionDamageNumberManager_GetDamageNumberStartLocation");
static_assert(sizeof(OrionDamageNumberManager_GetDamageNumberStartLocation) == 0x000118, "Wrong size on OrionDamageNumberManager_GetDamageNumberStartLocation");
static_assert(offsetof(OrionDamageNumberManager_GetDamageNumberStartLocation, DamageNumberInfo) == 0x000000, "Member 'OrionDamageNumberManager_GetDamageNumberStartLocation::DamageNumberInfo' has a wrong offset!");
static_assert(offsetof(OrionDamageNumberManager_GetDamageNumberStartLocation, ReturnValue) == 0x000108, "Member 'OrionDamageNumberManager_GetDamageNumberStartLocation::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTeamActorInterface.OnTeamChanged
// 0x0001 (0x0001 - 0x0000)
struct OrionTeamActorInterface_OnTeamChanged final
{
public:
	EOrionTeam                                    NewTeamIdx;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamActorInterface_OnTeamChanged) == 0x000001, "Wrong alignment on OrionTeamActorInterface_OnTeamChanged");
static_assert(sizeof(OrionTeamActorInterface_OnTeamChanged) == 0x000001, "Wrong size on OrionTeamActorInterface_OnTeamChanged");
static_assert(offsetof(OrionTeamActorInterface_OnTeamChanged, NewTeamIdx) == 0x000000, "Member 'OrionTeamActorInterface_OnTeamChanged::NewTeamIdx' has a wrong offset!");

// Function OrionGame.OrionTeamActorInterface.GetTeamNum
// 0x0001 (0x0001 - 0x0000)
struct OrionTeamActorInterface_GetTeamNum final
{
public:
	EOrionTeam                                    ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamActorInterface_GetTeamNum) == 0x000001, "Wrong alignment on OrionTeamActorInterface_GetTeamNum");
static_assert(sizeof(OrionTeamActorInterface_GetTeamNum) == 0x000001, "Wrong size on OrionTeamActorInterface_GetTeamNum");
static_assert(offsetof(OrionTeamActorInterface_GetTeamNum, ReturnValue) == 0x000000, "Member 'OrionTeamActorInterface_GetTeamNum::ReturnValue' has a wrong offset!");

// Function OrionGame.BotPlaybook.AdditionalCondition
// 0x0010 (0x0010 - 0x0000)
struct BotPlaybook_AdditionalCondition final
{
public:
	struct FOrionGenericAITest                    Condition;                                         // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BotPlaybook_AdditionalCondition) == 0x000008, "Wrong alignment on BotPlaybook_AdditionalCondition");
static_assert(sizeof(BotPlaybook_AdditionalCondition) == 0x000010, "Wrong size on BotPlaybook_AdditionalCondition");
static_assert(offsetof(BotPlaybook_AdditionalCondition, Condition) == 0x000000, "Member 'BotPlaybook_AdditionalCondition::Condition' has a wrong offset!");

// Function OrionGame.BotPlaybook.AdditionalConditions
// 0x0010 (0x0010 - 0x0000)
struct BotPlaybook_AdditionalConditions final
{
public:
	TArray<struct FOrionGenericAITest>            Conditions;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BotPlaybook_AdditionalConditions) == 0x000008, "Wrong alignment on BotPlaybook_AdditionalConditions");
static_assert(sizeof(BotPlaybook_AdditionalConditions) == 0x000010, "Wrong size on BotPlaybook_AdditionalConditions");
static_assert(offsetof(BotPlaybook_AdditionalConditions, Conditions) == 0x000000, "Member 'BotPlaybook_AdditionalConditions::Conditions' has a wrong offset!");

// Function OrionGame.BotPlaybook.AddTeamCommAssignOverride
// 0x0001 (0x0001 - 0x0000)
struct BotPlaybook_AddTeamCommAssignOverride final
{
public:
	EAITeamCommEvent                              AssignCommOverride;                                // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BotPlaybook_AddTeamCommAssignOverride) == 0x000001, "Wrong alignment on BotPlaybook_AddTeamCommAssignOverride");
static_assert(sizeof(BotPlaybook_AddTeamCommAssignOverride) == 0x000001, "Wrong size on BotPlaybook_AddTeamCommAssignOverride");
static_assert(offsetof(BotPlaybook_AddTeamCommAssignOverride, AssignCommOverride) == 0x000000, "Member 'BotPlaybook_AddTeamCommAssignOverride::AssignCommOverride' has a wrong offset!");

// Function OrionGame.BotPlaybook.AddTeamCommConfirmOverride
// 0x0001 (0x0001 - 0x0000)
struct BotPlaybook_AddTeamCommConfirmOverride final
{
public:
	EAITeamCommEvent                              ConfirmCommOverride;                               // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BotPlaybook_AddTeamCommConfirmOverride) == 0x000001, "Wrong alignment on BotPlaybook_AddTeamCommConfirmOverride");
static_assert(sizeof(BotPlaybook_AddTeamCommConfirmOverride) == 0x000001, "Wrong size on BotPlaybook_AddTeamCommConfirmOverride");
static_assert(offsetof(BotPlaybook_AddTeamCommConfirmOverride, ConfirmCommOverride) == 0x000000, "Member 'BotPlaybook_AddTeamCommConfirmOverride::ConfirmCommOverride' has a wrong offset!");

// Function OrionGame.BotPlaybook.GetAgentDifficulty
// 0x0001 (0x0001 - 0x0000)
struct BotPlaybook_GetAgentDifficulty final
{
public:
	EAIBotDifficulty                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BotPlaybook_GetAgentDifficulty) == 0x000001, "Wrong alignment on BotPlaybook_GetAgentDifficulty");
static_assert(sizeof(BotPlaybook_GetAgentDifficulty) == 0x000001, "Wrong size on BotPlaybook_GetAgentDifficulty");
static_assert(offsetof(BotPlaybook_GetAgentDifficulty, ReturnValue) == 0x000000, "Member 'BotPlaybook_GetAgentDifficulty::ReturnValue' has a wrong offset!");

// Function OrionGame.BotPlaybook.GetMatchPhase
// 0x0001 (0x0001 - 0x0000)
struct BotPlaybook_GetMatchPhase final
{
public:
	EAIMatchProgress                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BotPlaybook_GetMatchPhase) == 0x000001, "Wrong alignment on BotPlaybook_GetMatchPhase");
static_assert(sizeof(BotPlaybook_GetMatchPhase) == 0x000001, "Wrong size on BotPlaybook_GetMatchPhase");
static_assert(offsetof(BotPlaybook_GetMatchPhase, ReturnValue) == 0x000000, "Member 'BotPlaybook_GetMatchPhase::ReturnValue' has a wrong offset!");

// Function OrionGame.BotPlaybook.IsRole
// 0x0002 (0x0002 - 0x0000)
struct BotPlaybook_IsRole final
{
public:
	ELaneRoleSlot                                 Role;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BotPlaybook_IsRole) == 0x000001, "Wrong alignment on BotPlaybook_IsRole");
static_assert(sizeof(BotPlaybook_IsRole) == 0x000002, "Wrong size on BotPlaybook_IsRole");
static_assert(offsetof(BotPlaybook_IsRole, Role) == 0x000000, "Member 'BotPlaybook_IsRole::Role' has a wrong offset!");
static_assert(offsetof(BotPlaybook_IsRole, ReturnValue) == 0x000001, "Member 'BotPlaybook_IsRole::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionDummySpawner.OnDeath
// 0x0018 (0x0018 - 0x0000)
struct OrionDummySpawner_OnDeath final
{
public:
	class AOrionChar*                             DeadChar;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            Killer;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDummySpawner_OnDeath) == 0x000008, "Wrong alignment on OrionDummySpawner_OnDeath");
static_assert(sizeof(OrionDummySpawner_OnDeath) == 0x000018, "Wrong size on OrionDummySpawner_OnDeath");
static_assert(offsetof(OrionDummySpawner_OnDeath, DeadChar) == 0x000000, "Member 'OrionDummySpawner_OnDeath::DeadChar' has a wrong offset!");
static_assert(offsetof(OrionDummySpawner_OnDeath, Killer) == 0x000008, "Member 'OrionDummySpawner_OnDeath::Killer' has a wrong offset!");
static_assert(offsetof(OrionDummySpawner_OnDeath, DamageCauser) == 0x000010, "Member 'OrionDummySpawner_OnDeath::DamageCauser' has a wrong offset!");

// Function OrionGame.ClientSettingsRecord.SetGamepadAbilityConfirmOnRelease
// 0x0004 (0x0004 - 0x0000)
struct ClientSettingsRecord_SetGamepadAbilityConfirmOnRelease final
{
public:
	int32                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClientSettingsRecord_SetGamepadAbilityConfirmOnRelease) == 0x000004, "Wrong alignment on ClientSettingsRecord_SetGamepadAbilityConfirmOnRelease");
static_assert(sizeof(ClientSettingsRecord_SetGamepadAbilityConfirmOnRelease) == 0x000004, "Wrong size on ClientSettingsRecord_SetGamepadAbilityConfirmOnRelease");
static_assert(offsetof(ClientSettingsRecord_SetGamepadAbilityConfirmOnRelease, NewValue) == 0x000000, "Member 'ClientSettingsRecord_SetGamepadAbilityConfirmOnRelease::NewValue' has a wrong offset!");

// Function OrionGame.ClientSettingsRecord.SetGamepadInvertPitch
// 0x0004 (0x0004 - 0x0000)
struct ClientSettingsRecord_SetGamepadInvertPitch final
{
public:
	int32                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClientSettingsRecord_SetGamepadInvertPitch) == 0x000004, "Wrong alignment on ClientSettingsRecord_SetGamepadInvertPitch");
static_assert(sizeof(ClientSettingsRecord_SetGamepadInvertPitch) == 0x000004, "Wrong size on ClientSettingsRecord_SetGamepadInvertPitch");
static_assert(offsetof(ClientSettingsRecord_SetGamepadInvertPitch, NewValue) == 0x000000, "Member 'ClientSettingsRecord_SetGamepadInvertPitch::NewValue' has a wrong offset!");

// Function OrionGame.ClientSettingsRecord.SetGamepadInvertYaw
// 0x0004 (0x0004 - 0x0000)
struct ClientSettingsRecord_SetGamepadInvertYaw final
{
public:
	int32                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClientSettingsRecord_SetGamepadInvertYaw) == 0x000004, "Wrong alignment on ClientSettingsRecord_SetGamepadInvertYaw");
static_assert(sizeof(ClientSettingsRecord_SetGamepadInvertYaw) == 0x000004, "Wrong size on ClientSettingsRecord_SetGamepadInvertYaw");
static_assert(offsetof(ClientSettingsRecord_SetGamepadInvertYaw, NewValue) == 0x000000, "Member 'ClientSettingsRecord_SetGamepadInvertYaw::NewValue' has a wrong offset!");

// Function OrionGame.ClientSettingsRecord.SetGamepadPitchSensitivity
// 0x0004 (0x0004 - 0x0000)
struct ClientSettingsRecord_SetGamepadPitchSensitivity final
{
public:
	int32                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClientSettingsRecord_SetGamepadPitchSensitivity) == 0x000004, "Wrong alignment on ClientSettingsRecord_SetGamepadPitchSensitivity");
static_assert(sizeof(ClientSettingsRecord_SetGamepadPitchSensitivity) == 0x000004, "Wrong size on ClientSettingsRecord_SetGamepadPitchSensitivity");
static_assert(offsetof(ClientSettingsRecord_SetGamepadPitchSensitivity, NewValue) == 0x000000, "Member 'ClientSettingsRecord_SetGamepadPitchSensitivity::NewValue' has a wrong offset!");

// Function OrionGame.ClientSettingsRecord.SetGamepadRadialSelectEnabled
// 0x0004 (0x0004 - 0x0000)
struct ClientSettingsRecord_SetGamepadRadialSelectEnabled final
{
public:
	int32                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClientSettingsRecord_SetGamepadRadialSelectEnabled) == 0x000004, "Wrong alignment on ClientSettingsRecord_SetGamepadRadialSelectEnabled");
static_assert(sizeof(ClientSettingsRecord_SetGamepadRadialSelectEnabled) == 0x000004, "Wrong size on ClientSettingsRecord_SetGamepadRadialSelectEnabled");
static_assert(offsetof(ClientSettingsRecord_SetGamepadRadialSelectEnabled, NewValue) == 0x000000, "Member 'ClientSettingsRecord_SetGamepadRadialSelectEnabled::NewValue' has a wrong offset!");

// Function OrionGame.ClientSettingsRecord.SetGamepadYawSensitivity
// 0x0004 (0x0004 - 0x0000)
struct ClientSettingsRecord_SetGamepadYawSensitivity final
{
public:
	int32                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClientSettingsRecord_SetGamepadYawSensitivity) == 0x000004, "Wrong alignment on ClientSettingsRecord_SetGamepadYawSensitivity");
static_assert(sizeof(ClientSettingsRecord_SetGamepadYawSensitivity) == 0x000004, "Wrong size on ClientSettingsRecord_SetGamepadYawSensitivity");
static_assert(offsetof(ClientSettingsRecord_SetGamepadYawSensitivity, NewValue) == 0x000000, "Member 'ClientSettingsRecord_SetGamepadYawSensitivity::NewValue' has a wrong offset!");

// Function OrionGame.ClientSettingsRecord.SetInvertedMouse
// 0x0001 (0x0001 - 0x0000)
struct ClientSettingsRecord_SetInvertedMouse final
{
public:
	bool                                          bInvert;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClientSettingsRecord_SetInvertedMouse) == 0x000001, "Wrong alignment on ClientSettingsRecord_SetInvertedMouse");
static_assert(sizeof(ClientSettingsRecord_SetInvertedMouse) == 0x000001, "Wrong size on ClientSettingsRecord_SetInvertedMouse");
static_assert(offsetof(ClientSettingsRecord_SetInvertedMouse, bInvert) == 0x000000, "Member 'ClientSettingsRecord_SetInvertedMouse::bInvert' has a wrong offset!");

// Function OrionGame.ClientSettingsRecord.SetMouseLookSensitivity
// 0x0004 (0x0004 - 0x0000)
struct ClientSettingsRecord_SetMouseLookSensitivity final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClientSettingsRecord_SetMouseLookSensitivity) == 0x000004, "Wrong alignment on ClientSettingsRecord_SetMouseLookSensitivity");
static_assert(sizeof(ClientSettingsRecord_SetMouseLookSensitivity) == 0x000004, "Wrong size on ClientSettingsRecord_SetMouseLookSensitivity");
static_assert(offsetof(ClientSettingsRecord_SetMouseLookSensitivity, NewValue) == 0x000000, "Member 'ClientSettingsRecord_SetMouseLookSensitivity::NewValue' has a wrong offset!");

// Function OrionGame.ClientSettingsRecord.SetShowPingAndFPS
// 0x0004 (0x0004 - 0x0000)
struct ClientSettingsRecord_SetShowPingAndFPS final
{
public:
	int32                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClientSettingsRecord_SetShowPingAndFPS) == 0x000004, "Wrong alignment on ClientSettingsRecord_SetShowPingAndFPS");
static_assert(sizeof(ClientSettingsRecord_SetShowPingAndFPS) == 0x000004, "Wrong size on ClientSettingsRecord_SetShowPingAndFPS");
static_assert(offsetof(ClientSettingsRecord_SetShowPingAndFPS, NewValue) == 0x000000, "Member 'ClientSettingsRecord_SetShowPingAndFPS::NewValue' has a wrong offset!");

// Function OrionGame.ClientSettingsRecord.SetShowXPPerMinute
// 0x0004 (0x0004 - 0x0000)
struct ClientSettingsRecord_SetShowXPPerMinute final
{
public:
	int32                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClientSettingsRecord_SetShowXPPerMinute) == 0x000004, "Wrong alignment on ClientSettingsRecord_SetShowXPPerMinute");
static_assert(sizeof(ClientSettingsRecord_SetShowXPPerMinute) == 0x000004, "Wrong size on ClientSettingsRecord_SetShowXPPerMinute");
static_assert(offsetof(ClientSettingsRecord_SetShowXPPerMinute, NewValue) == 0x000000, "Member 'ClientSettingsRecord_SetShowXPPerMinute::NewValue' has a wrong offset!");

// Function OrionGame.ClientSettingsRecord.GetGamepadAbilityConfirmOnRelease
// 0x0004 (0x0004 - 0x0000)
struct ClientSettingsRecord_GetGamepadAbilityConfirmOnRelease final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClientSettingsRecord_GetGamepadAbilityConfirmOnRelease) == 0x000004, "Wrong alignment on ClientSettingsRecord_GetGamepadAbilityConfirmOnRelease");
static_assert(sizeof(ClientSettingsRecord_GetGamepadAbilityConfirmOnRelease) == 0x000004, "Wrong size on ClientSettingsRecord_GetGamepadAbilityConfirmOnRelease");
static_assert(offsetof(ClientSettingsRecord_GetGamepadAbilityConfirmOnRelease, ReturnValue) == 0x000000, "Member 'ClientSettingsRecord_GetGamepadAbilityConfirmOnRelease::ReturnValue' has a wrong offset!");

// Function OrionGame.ClientSettingsRecord.GetGamepadInvertPitch
// 0x0004 (0x0004 - 0x0000)
struct ClientSettingsRecord_GetGamepadInvertPitch final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClientSettingsRecord_GetGamepadInvertPitch) == 0x000004, "Wrong alignment on ClientSettingsRecord_GetGamepadInvertPitch");
static_assert(sizeof(ClientSettingsRecord_GetGamepadInvertPitch) == 0x000004, "Wrong size on ClientSettingsRecord_GetGamepadInvertPitch");
static_assert(offsetof(ClientSettingsRecord_GetGamepadInvertPitch, ReturnValue) == 0x000000, "Member 'ClientSettingsRecord_GetGamepadInvertPitch::ReturnValue' has a wrong offset!");

// Function OrionGame.ClientSettingsRecord.GetGamepadInvertYaw
// 0x0004 (0x0004 - 0x0000)
struct ClientSettingsRecord_GetGamepadInvertYaw final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClientSettingsRecord_GetGamepadInvertYaw) == 0x000004, "Wrong alignment on ClientSettingsRecord_GetGamepadInvertYaw");
static_assert(sizeof(ClientSettingsRecord_GetGamepadInvertYaw) == 0x000004, "Wrong size on ClientSettingsRecord_GetGamepadInvertYaw");
static_assert(offsetof(ClientSettingsRecord_GetGamepadInvertYaw, ReturnValue) == 0x000000, "Member 'ClientSettingsRecord_GetGamepadInvertYaw::ReturnValue' has a wrong offset!");

// Function OrionGame.ClientSettingsRecord.GetGamepadPitchSensitivity
// 0x0004 (0x0004 - 0x0000)
struct ClientSettingsRecord_GetGamepadPitchSensitivity final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClientSettingsRecord_GetGamepadPitchSensitivity) == 0x000004, "Wrong alignment on ClientSettingsRecord_GetGamepadPitchSensitivity");
static_assert(sizeof(ClientSettingsRecord_GetGamepadPitchSensitivity) == 0x000004, "Wrong size on ClientSettingsRecord_GetGamepadPitchSensitivity");
static_assert(offsetof(ClientSettingsRecord_GetGamepadPitchSensitivity, ReturnValue) == 0x000000, "Member 'ClientSettingsRecord_GetGamepadPitchSensitivity::ReturnValue' has a wrong offset!");

// Function OrionGame.ClientSettingsRecord.GetGamepadRadialSelectEnabled
// 0x0004 (0x0004 - 0x0000)
struct ClientSettingsRecord_GetGamepadRadialSelectEnabled final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClientSettingsRecord_GetGamepadRadialSelectEnabled) == 0x000004, "Wrong alignment on ClientSettingsRecord_GetGamepadRadialSelectEnabled");
static_assert(sizeof(ClientSettingsRecord_GetGamepadRadialSelectEnabled) == 0x000004, "Wrong size on ClientSettingsRecord_GetGamepadRadialSelectEnabled");
static_assert(offsetof(ClientSettingsRecord_GetGamepadRadialSelectEnabled, ReturnValue) == 0x000000, "Member 'ClientSettingsRecord_GetGamepadRadialSelectEnabled::ReturnValue' has a wrong offset!");

// Function OrionGame.ClientSettingsRecord.GetGamepadYawSensitivity
// 0x0004 (0x0004 - 0x0000)
struct ClientSettingsRecord_GetGamepadYawSensitivity final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClientSettingsRecord_GetGamepadYawSensitivity) == 0x000004, "Wrong alignment on ClientSettingsRecord_GetGamepadYawSensitivity");
static_assert(sizeof(ClientSettingsRecord_GetGamepadYawSensitivity) == 0x000004, "Wrong size on ClientSettingsRecord_GetGamepadYawSensitivity");
static_assert(offsetof(ClientSettingsRecord_GetGamepadYawSensitivity, ReturnValue) == 0x000000, "Member 'ClientSettingsRecord_GetGamepadYawSensitivity::ReturnValue' has a wrong offset!");

// Function OrionGame.ClientSettingsRecord.GetInvertedMouse
// 0x0001 (0x0001 - 0x0000)
struct ClientSettingsRecord_GetInvertedMouse final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClientSettingsRecord_GetInvertedMouse) == 0x000001, "Wrong alignment on ClientSettingsRecord_GetInvertedMouse");
static_assert(sizeof(ClientSettingsRecord_GetInvertedMouse) == 0x000001, "Wrong size on ClientSettingsRecord_GetInvertedMouse");
static_assert(offsetof(ClientSettingsRecord_GetInvertedMouse, ReturnValue) == 0x000000, "Member 'ClientSettingsRecord_GetInvertedMouse::ReturnValue' has a wrong offset!");

// Function OrionGame.ClientSettingsRecord.GetMouseLookSensitivity
// 0x0004 (0x0004 - 0x0000)
struct ClientSettingsRecord_GetMouseLookSensitivity final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClientSettingsRecord_GetMouseLookSensitivity) == 0x000004, "Wrong alignment on ClientSettingsRecord_GetMouseLookSensitivity");
static_assert(sizeof(ClientSettingsRecord_GetMouseLookSensitivity) == 0x000004, "Wrong size on ClientSettingsRecord_GetMouseLookSensitivity");
static_assert(offsetof(ClientSettingsRecord_GetMouseLookSensitivity, ReturnValue) == 0x000000, "Member 'ClientSettingsRecord_GetMouseLookSensitivity::ReturnValue' has a wrong offset!");

// Function OrionGame.ClientSettingsRecord.GetShowPingAndFPS
// 0x0004 (0x0004 - 0x0000)
struct ClientSettingsRecord_GetShowPingAndFPS final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClientSettingsRecord_GetShowPingAndFPS) == 0x000004, "Wrong alignment on ClientSettingsRecord_GetShowPingAndFPS");
static_assert(sizeof(ClientSettingsRecord_GetShowPingAndFPS) == 0x000004, "Wrong size on ClientSettingsRecord_GetShowPingAndFPS");
static_assert(offsetof(ClientSettingsRecord_GetShowPingAndFPS, ReturnValue) == 0x000000, "Member 'ClientSettingsRecord_GetShowPingAndFPS::ReturnValue' has a wrong offset!");

// Function OrionGame.ClientSettingsRecord.GetShowXPPerMinute
// 0x0004 (0x0004 - 0x0000)
struct ClientSettingsRecord_GetShowXPPerMinute final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClientSettingsRecord_GetShowXPPerMinute) == 0x000004, "Wrong alignment on ClientSettingsRecord_GetShowXPPerMinute");
static_assert(sizeof(ClientSettingsRecord_GetShowXPPerMinute) == 0x000004, "Wrong size on ClientSettingsRecord_GetShowXPPerMinute");
static_assert(offsetof(ClientSettingsRecord_GetShowXPPerMinute, ReturnValue) == 0x000000, "Member 'ClientSettingsRecord_GetShowXPPerMinute::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAnimInstance.ShouldRateLimitBlueprintTicks
// 0x000C (0x000C - 0x0000)
struct OrionAnimInstance_ShouldRateLimitBlueprintTicks final
{
public:
	bool                                          bIsHero;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Amount;                                            // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionAnimInstance_ShouldRateLimitBlueprintTicks) == 0x000004, "Wrong alignment on OrionAnimInstance_ShouldRateLimitBlueprintTicks");
static_assert(sizeof(OrionAnimInstance_ShouldRateLimitBlueprintTicks) == 0x00000C, "Wrong size on OrionAnimInstance_ShouldRateLimitBlueprintTicks");
static_assert(offsetof(OrionAnimInstance_ShouldRateLimitBlueprintTicks, bIsHero) == 0x000000, "Member 'OrionAnimInstance_ShouldRateLimitBlueprintTicks::bIsHero' has a wrong offset!");
static_assert(offsetof(OrionAnimInstance_ShouldRateLimitBlueprintTicks, Amount) == 0x000004, "Member 'OrionAnimInstance_ShouldRateLimitBlueprintTicks::Amount' has a wrong offset!");
static_assert(offsetof(OrionAnimInstance_ShouldRateLimitBlueprintTicks, ReturnValue) == 0x000008, "Member 'OrionAnimInstance_ShouldRateLimitBlueprintTicks::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAnimInstance.AnimNotify_LeftFootStep
// 0x0008 (0x0008 - 0x0000)
struct OrionAnimInstance_AnimNotify_LeftFootStep final
{
public:
	const class UAnimNotify*                      Notify;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAnimInstance_AnimNotify_LeftFootStep) == 0x000008, "Wrong alignment on OrionAnimInstance_AnimNotify_LeftFootStep");
static_assert(sizeof(OrionAnimInstance_AnimNotify_LeftFootStep) == 0x000008, "Wrong size on OrionAnimInstance_AnimNotify_LeftFootStep");
static_assert(offsetof(OrionAnimInstance_AnimNotify_LeftFootStep, Notify) == 0x000000, "Member 'OrionAnimInstance_AnimNotify_LeftFootStep::Notify' has a wrong offset!");

// Function OrionGame.OrionAnimInstance.AnimNotify_RightFootStep
// 0x0008 (0x0008 - 0x0000)
struct OrionAnimInstance_AnimNotify_RightFootStep final
{
public:
	const class UAnimNotify*                      Notify;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAnimInstance_AnimNotify_RightFootStep) == 0x000008, "Wrong alignment on OrionAnimInstance_AnimNotify_RightFootStep");
static_assert(sizeof(OrionAnimInstance_AnimNotify_RightFootStep) == 0x000008, "Wrong size on OrionAnimInstance_AnimNotify_RightFootStep");
static_assert(offsetof(OrionAnimInstance_AnimNotify_RightFootStep, Notify) == 0x000000, "Member 'OrionAnimInstance_AnimNotify_RightFootStep::Notify' has a wrong offset!");

// Function OrionGame.OrionAnimInstance.OnHit
// 0x00D8 (0x00D8 - 0x0000)
struct OrionAnimInstance_OnHit final
{
public:
	struct FGameplayTagContainer                  TargetTags;                                        // 0x0000(0x0020)(Parm, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 GameplayCueParameters;                             // 0x0020(0x00B8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAnimInstance_OnHit) == 0x000008, "Wrong alignment on OrionAnimInstance_OnHit");
static_assert(sizeof(OrionAnimInstance_OnHit) == 0x0000D8, "Wrong size on OrionAnimInstance_OnHit");
static_assert(offsetof(OrionAnimInstance_OnHit, TargetTags) == 0x000000, "Member 'OrionAnimInstance_OnHit::TargetTags' has a wrong offset!");
static_assert(offsetof(OrionAnimInstance_OnHit, GameplayCueParameters) == 0x000020, "Member 'OrionAnimInstance_OnHit::GameplayCueParameters' has a wrong offset!");

// Function OrionGame.OrionAnimInstance.IsGameplayCueActive
// 0x0010 (0x0010 - 0x0000)
struct OrionAnimInstance_IsGameplayCueActive final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionAnimInstance_IsGameplayCueActive) == 0x000008, "Wrong alignment on OrionAnimInstance_IsGameplayCueActive");
static_assert(sizeof(OrionAnimInstance_IsGameplayCueActive) == 0x000010, "Wrong size on OrionAnimInstance_IsGameplayCueActive");
static_assert(offsetof(OrionAnimInstance_IsGameplayCueActive, GameplayCueTag) == 0x000000, "Member 'OrionAnimInstance_IsGameplayCueActive::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(OrionAnimInstance_IsGameplayCueActive, ReturnValue) == 0x000008, "Member 'OrionAnimInstance_IsGameplayCueActive::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAnimInstance.IsSlotNodePlayingAMontage
// 0x0010 (0x0010 - 0x0000)
struct OrionAnimInstance_IsSlotNodePlayingAMontage final
{
public:
	class FName                                   SlotNodeName;                                      // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionAnimInstance_IsSlotNodePlayingAMontage) == 0x000004, "Wrong alignment on OrionAnimInstance_IsSlotNodePlayingAMontage");
static_assert(sizeof(OrionAnimInstance_IsSlotNodePlayingAMontage) == 0x000010, "Wrong size on OrionAnimInstance_IsSlotNodePlayingAMontage");
static_assert(offsetof(OrionAnimInstance_IsSlotNodePlayingAMontage, SlotNodeName) == 0x000000, "Member 'OrionAnimInstance_IsSlotNodePlayingAMontage::SlotNodeName' has a wrong offset!");
static_assert(offsetof(OrionAnimInstance_IsSlotNodePlayingAMontage, ReturnValue) == 0x000008, "Member 'OrionAnimInstance_IsSlotNodePlayingAMontage::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAnimInstance.OwnerHasMatchingGameplayTag
// 0x0010 (0x0010 - 0x0000)
struct OrionAnimInstance_OwnerHasMatchingGameplayTag final
{
public:
	struct FGameplayTag                           TagToCheck;                                        // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionAnimInstance_OwnerHasMatchingGameplayTag) == 0x000008, "Wrong alignment on OrionAnimInstance_OwnerHasMatchingGameplayTag");
static_assert(sizeof(OrionAnimInstance_OwnerHasMatchingGameplayTag) == 0x000010, "Wrong size on OrionAnimInstance_OwnerHasMatchingGameplayTag");
static_assert(offsetof(OrionAnimInstance_OwnerHasMatchingGameplayTag, TagToCheck) == 0x000000, "Member 'OrionAnimInstance_OwnerHasMatchingGameplayTag::TagToCheck' has a wrong offset!");
static_assert(offsetof(OrionAnimInstance_OwnerHasMatchingGameplayTag, ReturnValue) == 0x000008, "Member 'OrionAnimInstance_OwnerHasMatchingGameplayTag::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAnimInstance.TryGetOrionChar
// 0x0008 (0x0008 - 0x0000)
struct OrionAnimInstance_TryGetOrionChar final
{
public:
	class AOrionChar*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAnimInstance_TryGetOrionChar) == 0x000008, "Wrong alignment on OrionAnimInstance_TryGetOrionChar");
static_assert(sizeof(OrionAnimInstance_TryGetOrionChar) == 0x000008, "Wrong size on OrionAnimInstance_TryGetOrionChar");
static_assert(offsetof(OrionAnimInstance_TryGetOrionChar, ReturnValue) == 0x000000, "Member 'OrionAnimInstance_TryGetOrionChar::ReturnValue' has a wrong offset!");

// Function OrionGame.FrontEndManager.GetScene
// 0x0010 (0x0010 - 0x0000)
struct FrontEndManager_GetScene final
{
public:
	class FName                                   SceneName;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FrontEndManager_GetScene) == 0x000008, "Wrong alignment on FrontEndManager_GetScene");
static_assert(sizeof(FrontEndManager_GetScene) == 0x000010, "Wrong size on FrontEndManager_GetScene");
static_assert(offsetof(FrontEndManager_GetScene, SceneName) == 0x000000, "Member 'FrontEndManager_GetScene::SceneName' has a wrong offset!");
static_assert(offsetof(FrontEndManager_GetScene, ReturnValue) == 0x000008, "Member 'FrontEndManager_GetScene::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionEQSTestingPawn.GetTeamNum
// 0x0001 (0x0001 - 0x0000)
struct OrionEQSTestingPawn_GetTeamNum final
{
public:
	EOrionTeam                                    ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionEQSTestingPawn_GetTeamNum) == 0x000001, "Wrong alignment on OrionEQSTestingPawn_GetTeamNum");
static_assert(sizeof(OrionEQSTestingPawn_GetTeamNum) == 0x000001, "Wrong size on OrionEQSTestingPawn_GetTeamNum");
static_assert(offsetof(OrionEQSTestingPawn_GetTeamNum, ReturnValue) == 0x000000, "Member 'OrionEQSTestingPawn_GetTeamNum::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlayerState_Base.ClientFailedToPickHero
// 0x00A8 (0x00A8 - 0x0000)
struct OrionPlayerState_Base_ClientFailedToPickHero final
{
public:
	struct FOrionHeroDataSpec                     InHeroDataSpec;                                    // 0x0000(0x00A8)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerState_Base_ClientFailedToPickHero) == 0x000008, "Wrong alignment on OrionPlayerState_Base_ClientFailedToPickHero");
static_assert(sizeof(OrionPlayerState_Base_ClientFailedToPickHero) == 0x0000A8, "Wrong size on OrionPlayerState_Base_ClientFailedToPickHero");
static_assert(offsetof(OrionPlayerState_Base_ClientFailedToPickHero, InHeroDataSpec) == 0x000000, "Member 'OrionPlayerState_Base_ClientFailedToPickHero::InHeroDataSpec' has a wrong offset!");

// Function OrionGame.OrionPlayerState_Base.OnRep_Team
// 0x0008 (0x0008 - 0x0000)
struct OrionPlayerState_Base_OnRep_Team final
{
public:
	const class AOrionTeamInfo*                   OldTeamInfo;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerState_Base_OnRep_Team) == 0x000008, "Wrong alignment on OrionPlayerState_Base_OnRep_Team");
static_assert(sizeof(OrionPlayerState_Base_OnRep_Team) == 0x000008, "Wrong size on OrionPlayerState_Base_OnRep_Team");
static_assert(offsetof(OrionPlayerState_Base_OnRep_Team, OldTeamInfo) == 0x000000, "Member 'OrionPlayerState_Base_OnRep_Team::OldTeamInfo' has a wrong offset!");

// Function OrionGame.OrionPlayerState_Base.ServerSetPlayerHeroDataSpec
// 0x00A8 (0x00A8 - 0x0000)
struct OrionPlayerState_Base_ServerSetPlayerHeroDataSpec final
{
public:
	struct FOrionHeroDataSpec                     InHeroDataSpec;                                    // 0x0000(0x00A8)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerState_Base_ServerSetPlayerHeroDataSpec) == 0x000008, "Wrong alignment on OrionPlayerState_Base_ServerSetPlayerHeroDataSpec");
static_assert(sizeof(OrionPlayerState_Base_ServerSetPlayerHeroDataSpec) == 0x0000A8, "Wrong size on OrionPlayerState_Base_ServerSetPlayerHeroDataSpec");
static_assert(offsetof(OrionPlayerState_Base_ServerSetPlayerHeroDataSpec, InHeroDataSpec) == 0x000000, "Member 'OrionPlayerState_Base_ServerSetPlayerHeroDataSpec::InHeroDataSpec' has a wrong offset!");

// Function OrionGame.OrionPlayerState_Base._BPGetHeroData
// 0x0008 (0x0008 - 0x0000)
struct OrionPlayerState_Base__BPGetHeroData final
{
public:
	class UOrionHeroData*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerState_Base__BPGetHeroData) == 0x000008, "Wrong alignment on OrionPlayerState_Base__BPGetHeroData");
static_assert(sizeof(OrionPlayerState_Base__BPGetHeroData) == 0x000008, "Wrong size on OrionPlayerState_Base__BPGetHeroData");
static_assert(offsetof(OrionPlayerState_Base__BPGetHeroData, ReturnValue) == 0x000000, "Member 'OrionPlayerState_Base__BPGetHeroData::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlayerState_Base.GetPlayerPosition
// 0x0001 (0x0001 - 0x0000)
struct OrionPlayerState_Base_GetPlayerPosition final
{
public:
	EOrionPosition                                ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerState_Base_GetPlayerPosition) == 0x000001, "Wrong alignment on OrionPlayerState_Base_GetPlayerPosition");
static_assert(sizeof(OrionPlayerState_Base_GetPlayerPosition) == 0x000001, "Wrong size on OrionPlayerState_Base_GetPlayerPosition");
static_assert(offsetof(OrionPlayerState_Base_GetPlayerPosition, ReturnValue) == 0x000000, "Member 'OrionPlayerState_Base_GetPlayerPosition::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlayerState_Base.GetTeamNum
// 0x0001 (0x0001 - 0x0000)
struct OrionPlayerState_Base_GetTeamNum final
{
public:
	EOrionTeam                                    ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerState_Base_GetTeamNum) == 0x000001, "Wrong alignment on OrionPlayerState_Base_GetTeamNum");
static_assert(sizeof(OrionPlayerState_Base_GetTeamNum) == 0x000001, "Wrong size on OrionPlayerState_Base_GetTeamNum");
static_assert(offsetof(OrionPlayerState_Base_GetTeamNum, ReturnValue) == 0x000000, "Member 'OrionPlayerState_Base_GetTeamNum::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameMode_MOBA_Tutorial.TutorialPause
// 0x0010 (0x0010 - 0x0000)
struct OrionGameMode_MOBA_Tutorial_TutorialPause final
{
public:
	class APlayerController*                      Pauser;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPause;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionGameMode_MOBA_Tutorial_TutorialPause) == 0x000008, "Wrong alignment on OrionGameMode_MOBA_Tutorial_TutorialPause");
static_assert(sizeof(OrionGameMode_MOBA_Tutorial_TutorialPause) == 0x000010, "Wrong size on OrionGameMode_MOBA_Tutorial_TutorialPause");
static_assert(offsetof(OrionGameMode_MOBA_Tutorial_TutorialPause, Pauser) == 0x000000, "Member 'OrionGameMode_MOBA_Tutorial_TutorialPause::Pauser' has a wrong offset!");
static_assert(offsetof(OrionGameMode_MOBA_Tutorial_TutorialPause, bPause) == 0x000008, "Member 'OrionGameMode_MOBA_Tutorial_TutorialPause::bPause' has a wrong offset!");

// Function OrionGame.OrionGameplayCueNotify_Looping.K2_OnActive
// 0x00F8 (0x00F8 - 0x0000)
struct OrionGameplayCueNotify_Looping_K2_OnActive final
{
public:
	class AActor*                                 MyTarget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 Parameters;                                        // 0x0008(0x00B8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               ApplicationParticleSystem;                         // 0x00C0(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UParticleSystemComponent*>       AdditionalParticleSystems;                         // 0x00C8(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UCameraShake*                           ApplicationCameraShakeInstance;                    // 0x00D8(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      ApplicationNiagaraParticleSystem;                  // 0x00E0(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UNiagaraComponent*>              AdditionalNiagaraParticleSystems;                  // 0x00E8(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameplayCueNotify_Looping_K2_OnActive) == 0x000008, "Wrong alignment on OrionGameplayCueNotify_Looping_K2_OnActive");
static_assert(sizeof(OrionGameplayCueNotify_Looping_K2_OnActive) == 0x0000F8, "Wrong size on OrionGameplayCueNotify_Looping_K2_OnActive");
static_assert(offsetof(OrionGameplayCueNotify_Looping_K2_OnActive, MyTarget) == 0x000000, "Member 'OrionGameplayCueNotify_Looping_K2_OnActive::MyTarget' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Looping_K2_OnActive, Parameters) == 0x000008, "Member 'OrionGameplayCueNotify_Looping_K2_OnActive::Parameters' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Looping_K2_OnActive, ApplicationParticleSystem) == 0x0000C0, "Member 'OrionGameplayCueNotify_Looping_K2_OnActive::ApplicationParticleSystem' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Looping_K2_OnActive, AdditionalParticleSystems) == 0x0000C8, "Member 'OrionGameplayCueNotify_Looping_K2_OnActive::AdditionalParticleSystems' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Looping_K2_OnActive, ApplicationCameraShakeInstance) == 0x0000D8, "Member 'OrionGameplayCueNotify_Looping_K2_OnActive::ApplicationCameraShakeInstance' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Looping_K2_OnActive, ApplicationNiagaraParticleSystem) == 0x0000E0, "Member 'OrionGameplayCueNotify_Looping_K2_OnActive::ApplicationNiagaraParticleSystem' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Looping_K2_OnActive, AdditionalNiagaraParticleSystems) == 0x0000E8, "Member 'OrionGameplayCueNotify_Looping_K2_OnActive::AdditionalNiagaraParticleSystems' has a wrong offset!");

// Function OrionGame.OrionGameplayCueNotify_Looping.K2_OnExecute
// 0x00F0 (0x00F0 - 0x0000)
struct OrionGameplayCueNotify_Looping_K2_OnExecute final
{
public:
	class AActor*                                 MyTarget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 Parameters;                                        // 0x0008(0x00B8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               RecurringParticleSystem;                           // 0x00C0(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UParticleSystemComponent*>       AdditionalParticleSystems;                         // 0x00C8(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      RecurringNiagaraParticleSystem;                    // 0x00D8(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UNiagaraComponent*>              AdditionalNiagaraParticleSystems;                  // 0x00E0(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameplayCueNotify_Looping_K2_OnExecute) == 0x000008, "Wrong alignment on OrionGameplayCueNotify_Looping_K2_OnExecute");
static_assert(sizeof(OrionGameplayCueNotify_Looping_K2_OnExecute) == 0x0000F0, "Wrong size on OrionGameplayCueNotify_Looping_K2_OnExecute");
static_assert(offsetof(OrionGameplayCueNotify_Looping_K2_OnExecute, MyTarget) == 0x000000, "Member 'OrionGameplayCueNotify_Looping_K2_OnExecute::MyTarget' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Looping_K2_OnExecute, Parameters) == 0x000008, "Member 'OrionGameplayCueNotify_Looping_K2_OnExecute::Parameters' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Looping_K2_OnExecute, RecurringParticleSystem) == 0x0000C0, "Member 'OrionGameplayCueNotify_Looping_K2_OnExecute::RecurringParticleSystem' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Looping_K2_OnExecute, AdditionalParticleSystems) == 0x0000C8, "Member 'OrionGameplayCueNotify_Looping_K2_OnExecute::AdditionalParticleSystems' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Looping_K2_OnExecute, RecurringNiagaraParticleSystem) == 0x0000D8, "Member 'OrionGameplayCueNotify_Looping_K2_OnExecute::RecurringNiagaraParticleSystem' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Looping_K2_OnExecute, AdditionalNiagaraParticleSystems) == 0x0000E0, "Member 'OrionGameplayCueNotify_Looping_K2_OnExecute::AdditionalNiagaraParticleSystems' has a wrong offset!");

// Function OrionGame.OrionGameplayCueNotify_Looping.K2_OnRemove
// 0x00F0 (0x00F0 - 0x0000)
struct OrionGameplayCueNotify_Looping_K2_OnRemove final
{
public:
	class AActor*                                 MyTarget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 Parameters;                                        // 0x0008(0x00B8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               RemovalParticleSystem;                             // 0x00C0(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UParticleSystemComponent*>       AdditionalParticleSystems;                         // 0x00C8(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      RemovalNiagaraParticleSystem;                      // 0x00D8(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UNiagaraComponent*>              AdditionalNiagaraParticleSystems;                  // 0x00E0(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameplayCueNotify_Looping_K2_OnRemove) == 0x000008, "Wrong alignment on OrionGameplayCueNotify_Looping_K2_OnRemove");
static_assert(sizeof(OrionGameplayCueNotify_Looping_K2_OnRemove) == 0x0000F0, "Wrong size on OrionGameplayCueNotify_Looping_K2_OnRemove");
static_assert(offsetof(OrionGameplayCueNotify_Looping_K2_OnRemove, MyTarget) == 0x000000, "Member 'OrionGameplayCueNotify_Looping_K2_OnRemove::MyTarget' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Looping_K2_OnRemove, Parameters) == 0x000008, "Member 'OrionGameplayCueNotify_Looping_K2_OnRemove::Parameters' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Looping_K2_OnRemove, RemovalParticleSystem) == 0x0000C0, "Member 'OrionGameplayCueNotify_Looping_K2_OnRemove::RemovalParticleSystem' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Looping_K2_OnRemove, AdditionalParticleSystems) == 0x0000C8, "Member 'OrionGameplayCueNotify_Looping_K2_OnRemove::AdditionalParticleSystems' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Looping_K2_OnRemove, RemovalNiagaraParticleSystem) == 0x0000D8, "Member 'OrionGameplayCueNotify_Looping_K2_OnRemove::RemovalNiagaraParticleSystem' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Looping_K2_OnRemove, AdditionalNiagaraParticleSystems) == 0x0000E0, "Member 'OrionGameplayCueNotify_Looping_K2_OnRemove::AdditionalNiagaraParticleSystems' has a wrong offset!");

// Function OrionGame.OrionGameplayCueNotify_Looping.K2_WhileActive
// 0x00F0 (0x00F0 - 0x0000)
struct OrionGameplayCueNotify_Looping_K2_WhileActive final
{
public:
	class AActor*                                 MyTarget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 Parameters;                                        // 0x0008(0x00B8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               LoopingParticleSystem;                             // 0x00C0(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UParticleSystemComponent*>       AdditionalParticleSystem;                          // 0x00C8(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopingNiagaraParticleSystem;                      // 0x00D8(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UNiagaraComponent*>              AdditionalNiagaraParticleSystems;                  // 0x00E0(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameplayCueNotify_Looping_K2_WhileActive) == 0x000008, "Wrong alignment on OrionGameplayCueNotify_Looping_K2_WhileActive");
static_assert(sizeof(OrionGameplayCueNotify_Looping_K2_WhileActive) == 0x0000F0, "Wrong size on OrionGameplayCueNotify_Looping_K2_WhileActive");
static_assert(offsetof(OrionGameplayCueNotify_Looping_K2_WhileActive, MyTarget) == 0x000000, "Member 'OrionGameplayCueNotify_Looping_K2_WhileActive::MyTarget' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Looping_K2_WhileActive, Parameters) == 0x000008, "Member 'OrionGameplayCueNotify_Looping_K2_WhileActive::Parameters' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Looping_K2_WhileActive, LoopingParticleSystem) == 0x0000C0, "Member 'OrionGameplayCueNotify_Looping_K2_WhileActive::LoopingParticleSystem' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Looping_K2_WhileActive, AdditionalParticleSystem) == 0x0000C8, "Member 'OrionGameplayCueNotify_Looping_K2_WhileActive::AdditionalParticleSystem' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Looping_K2_WhileActive, LoopingNiagaraParticleSystem) == 0x0000D8, "Member 'OrionGameplayCueNotify_Looping_K2_WhileActive::LoopingNiagaraParticleSystem' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Looping_K2_WhileActive, AdditionalNiagaraParticleSystems) == 0x0000E0, "Member 'OrionGameplayCueNotify_Looping_K2_WhileActive::AdditionalNiagaraParticleSystems' has a wrong offset!");

// Function OrionGame.OrionGameplayCueNotify_Looping.ReceiveTick
// 0x0004 (0x0004 - 0x0000)
struct OrionGameplayCueNotify_Looping_ReceiveTick final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameplayCueNotify_Looping_ReceiveTick) == 0x000004, "Wrong alignment on OrionGameplayCueNotify_Looping_ReceiveTick");
static_assert(sizeof(OrionGameplayCueNotify_Looping_ReceiveTick) == 0x000004, "Wrong size on OrionGameplayCueNotify_Looping_ReceiveTick");
static_assert(offsetof(OrionGameplayCueNotify_Looping_ReceiveTick, DeltaSeconds) == 0x000000, "Member 'OrionGameplayCueNotify_Looping_ReceiveTick::DeltaSeconds' has a wrong offset!");

// Function OrionGame.OrionGameplayCueNotify_Looping.GetGameplayCueLoopingAnimationDuration
// 0x0004 (0x0004 - 0x0000)
struct OrionGameplayCueNotify_Looping_GetGameplayCueLoopingAnimationDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameplayCueNotify_Looping_GetGameplayCueLoopingAnimationDuration) == 0x000004, "Wrong alignment on OrionGameplayCueNotify_Looping_GetGameplayCueLoopingAnimationDuration");
static_assert(sizeof(OrionGameplayCueNotify_Looping_GetGameplayCueLoopingAnimationDuration) == 0x000004, "Wrong size on OrionGameplayCueNotify_Looping_GetGameplayCueLoopingAnimationDuration");
static_assert(offsetof(OrionGameplayCueNotify_Looping_GetGameplayCueLoopingAnimationDuration, ReturnValue) == 0x000000, "Member 'OrionGameplayCueNotify_Looping_GetGameplayCueLoopingAnimationDuration::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameplayCueNotify_Looping.GetTrailParticleSystem
// 0x0008 (0x0008 - 0x0000)
struct OrionGameplayCueNotify_Looping_GetTrailParticleSystem final
{
public:
	class UParticleSystemComponent*               ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameplayCueNotify_Looping_GetTrailParticleSystem) == 0x000008, "Wrong alignment on OrionGameplayCueNotify_Looping_GetTrailParticleSystem");
static_assert(sizeof(OrionGameplayCueNotify_Looping_GetTrailParticleSystem) == 0x000008, "Wrong size on OrionGameplayCueNotify_Looping_GetTrailParticleSystem");
static_assert(offsetof(OrionGameplayCueNotify_Looping_GetTrailParticleSystem, ReturnValue) == 0x000000, "Member 'OrionGameplayCueNotify_Looping_GetTrailParticleSystem::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionRichTextInlineWidget.OnApplyMetaData
// 0x0020 (0x0020 - 0x0000)
struct OrionRichTextInlineWidget_OnApplyMetaData final
{
public:
	class FString                                 Tag;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Value;                                             // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRichTextInlineWidget_OnApplyMetaData) == 0x000008, "Wrong alignment on OrionRichTextInlineWidget_OnApplyMetaData");
static_assert(sizeof(OrionRichTextInlineWidget_OnApplyMetaData) == 0x000020, "Wrong size on OrionRichTextInlineWidget_OnApplyMetaData");
static_assert(offsetof(OrionRichTextInlineWidget_OnApplyMetaData, Tag) == 0x000000, "Member 'OrionRichTextInlineWidget_OnApplyMetaData::Tag' has a wrong offset!");
static_assert(offsetof(OrionRichTextInlineWidget_OnApplyMetaData, Value) == 0x000010, "Member 'OrionRichTextInlineWidget_OnApplyMetaData::Value' has a wrong offset!");

// Function OrionGame.OrionGameplayStatsLibrary.GetCoreTakedowns
// 0x0110 (0x0110 - 0x0000)
struct OrionGameplayStatsLibrary_GetCoreTakedowns final
{
public:
	struct FGameplayStats                         GameplayStats;                                     // 0x0000(0x0108)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bUseTrackedStat;                                   // 0x0108(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x010C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameplayStatsLibrary_GetCoreTakedowns) == 0x000008, "Wrong alignment on OrionGameplayStatsLibrary_GetCoreTakedowns");
static_assert(sizeof(OrionGameplayStatsLibrary_GetCoreTakedowns) == 0x000110, "Wrong size on OrionGameplayStatsLibrary_GetCoreTakedowns");
static_assert(offsetof(OrionGameplayStatsLibrary_GetCoreTakedowns, GameplayStats) == 0x000000, "Member 'OrionGameplayStatsLibrary_GetCoreTakedowns::GameplayStats' has a wrong offset!");
static_assert(offsetof(OrionGameplayStatsLibrary_GetCoreTakedowns, bUseTrackedStat) == 0x000108, "Member 'OrionGameplayStatsLibrary_GetCoreTakedowns::bUseTrackedStat' has a wrong offset!");
static_assert(offsetof(OrionGameplayStatsLibrary_GetCoreTakedowns, ReturnValue) == 0x00010C, "Member 'OrionGameplayStatsLibrary_GetCoreTakedowns::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameplayStatsLibrary.GetHarvesterTakedowns
// 0x0110 (0x0110 - 0x0000)
struct OrionGameplayStatsLibrary_GetHarvesterTakedowns final
{
public:
	struct FGameplayStats                         GameplayStats;                                     // 0x0000(0x0108)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bUseTrackedStat;                                   // 0x0108(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x010C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameplayStatsLibrary_GetHarvesterTakedowns) == 0x000008, "Wrong alignment on OrionGameplayStatsLibrary_GetHarvesterTakedowns");
static_assert(sizeof(OrionGameplayStatsLibrary_GetHarvesterTakedowns) == 0x000110, "Wrong size on OrionGameplayStatsLibrary_GetHarvesterTakedowns");
static_assert(offsetof(OrionGameplayStatsLibrary_GetHarvesterTakedowns, GameplayStats) == 0x000000, "Member 'OrionGameplayStatsLibrary_GetHarvesterTakedowns::GameplayStats' has a wrong offset!");
static_assert(offsetof(OrionGameplayStatsLibrary_GetHarvesterTakedowns, bUseTrackedStat) == 0x000108, "Member 'OrionGameplayStatsLibrary_GetHarvesterTakedowns::bUseTrackedStat' has a wrong offset!");
static_assert(offsetof(OrionGameplayStatsLibrary_GetHarvesterTakedowns, ReturnValue) == 0x00010C, "Member 'OrionGameplayStatsLibrary_GetHarvesterTakedowns::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameplayStatsLibrary.GetHeroTakedowns
// 0x0110 (0x0110 - 0x0000)
struct OrionGameplayStatsLibrary_GetHeroTakedowns final
{
public:
	struct FGameplayStats                         GameplayStats;                                     // 0x0000(0x0108)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bUseTrackedStat;                                   // 0x0108(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x010C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameplayStatsLibrary_GetHeroTakedowns) == 0x000008, "Wrong alignment on OrionGameplayStatsLibrary_GetHeroTakedowns");
static_assert(sizeof(OrionGameplayStatsLibrary_GetHeroTakedowns) == 0x000110, "Wrong size on OrionGameplayStatsLibrary_GetHeroTakedowns");
static_assert(offsetof(OrionGameplayStatsLibrary_GetHeroTakedowns, GameplayStats) == 0x000000, "Member 'OrionGameplayStatsLibrary_GetHeroTakedowns::GameplayStats' has a wrong offset!");
static_assert(offsetof(OrionGameplayStatsLibrary_GetHeroTakedowns, bUseTrackedStat) == 0x000108, "Member 'OrionGameplayStatsLibrary_GetHeroTakedowns::bUseTrackedStat' has a wrong offset!");
static_assert(offsetof(OrionGameplayStatsLibrary_GetHeroTakedowns, ReturnValue) == 0x00010C, "Member 'OrionGameplayStatsLibrary_GetHeroTakedowns::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameplayStatsLibrary.GetInhibitorTakedowns
// 0x0110 (0x0110 - 0x0000)
struct OrionGameplayStatsLibrary_GetInhibitorTakedowns final
{
public:
	struct FGameplayStats                         GameplayStats;                                     // 0x0000(0x0108)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bUseTrackedStat;                                   // 0x0108(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x010C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameplayStatsLibrary_GetInhibitorTakedowns) == 0x000008, "Wrong alignment on OrionGameplayStatsLibrary_GetInhibitorTakedowns");
static_assert(sizeof(OrionGameplayStatsLibrary_GetInhibitorTakedowns) == 0x000110, "Wrong size on OrionGameplayStatsLibrary_GetInhibitorTakedowns");
static_assert(offsetof(OrionGameplayStatsLibrary_GetInhibitorTakedowns, GameplayStats) == 0x000000, "Member 'OrionGameplayStatsLibrary_GetInhibitorTakedowns::GameplayStats' has a wrong offset!");
static_assert(offsetof(OrionGameplayStatsLibrary_GetInhibitorTakedowns, bUseTrackedStat) == 0x000108, "Member 'OrionGameplayStatsLibrary_GetInhibitorTakedowns::bUseTrackedStat' has a wrong offset!");
static_assert(offsetof(OrionGameplayStatsLibrary_GetInhibitorTakedowns, ReturnValue) == 0x00010C, "Member 'OrionGameplayStatsLibrary_GetInhibitorTakedowns::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameplayStatsLibrary.GetMatchStatValue
// 0x0120 (0x0120 - 0x0000)
struct OrionGameplayStatsLibrary_GetMatchStatValue final
{
public:
	struct FGameplayStats                         GameplayStats;                                     // 0x0000(0x0108)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayStatTag                       Stat;                                              // 0x0108(0x0010)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionStatTrackType                           TrackType;                                         // 0x0118(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0x3];                                      // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x011C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameplayStatsLibrary_GetMatchStatValue) == 0x000008, "Wrong alignment on OrionGameplayStatsLibrary_GetMatchStatValue");
static_assert(sizeof(OrionGameplayStatsLibrary_GetMatchStatValue) == 0x000120, "Wrong size on OrionGameplayStatsLibrary_GetMatchStatValue");
static_assert(offsetof(OrionGameplayStatsLibrary_GetMatchStatValue, GameplayStats) == 0x000000, "Member 'OrionGameplayStatsLibrary_GetMatchStatValue::GameplayStats' has a wrong offset!");
static_assert(offsetof(OrionGameplayStatsLibrary_GetMatchStatValue, Stat) == 0x000108, "Member 'OrionGameplayStatsLibrary_GetMatchStatValue::Stat' has a wrong offset!");
static_assert(offsetof(OrionGameplayStatsLibrary_GetMatchStatValue, TrackType) == 0x000118, "Member 'OrionGameplayStatsLibrary_GetMatchStatValue::TrackType' has a wrong offset!");
static_assert(offsetof(OrionGameplayStatsLibrary_GetMatchStatValue, ReturnValue) == 0x00011C, "Member 'OrionGameplayStatsLibrary_GetMatchStatValue::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameplayStatsLibrary.GetPersistentStatValue
// 0x0120 (0x0120 - 0x0000)
struct OrionGameplayStatsLibrary_GetPersistentStatValue final
{
public:
	struct FGameplayStats                         GameplayStats;                                     // 0x0000(0x0108)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayStatTag                       Stat;                                              // 0x0108(0x0010)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0118(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionGameplayStatsLibrary_GetPersistentStatValue) == 0x000008, "Wrong alignment on OrionGameplayStatsLibrary_GetPersistentStatValue");
static_assert(sizeof(OrionGameplayStatsLibrary_GetPersistentStatValue) == 0x000120, "Wrong size on OrionGameplayStatsLibrary_GetPersistentStatValue");
static_assert(offsetof(OrionGameplayStatsLibrary_GetPersistentStatValue, GameplayStats) == 0x000000, "Member 'OrionGameplayStatsLibrary_GetPersistentStatValue::GameplayStats' has a wrong offset!");
static_assert(offsetof(OrionGameplayStatsLibrary_GetPersistentStatValue, Stat) == 0x000108, "Member 'OrionGameplayStatsLibrary_GetPersistentStatValue::Stat' has a wrong offset!");
static_assert(offsetof(OrionGameplayStatsLibrary_GetPersistentStatValue, ReturnValue) == 0x000118, "Member 'OrionGameplayStatsLibrary_GetPersistentStatValue::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameplayStatsLibrary.GetTotalAssists
// 0x0110 (0x0110 - 0x0000)
struct OrionGameplayStatsLibrary_GetTotalAssists final
{
public:
	struct FGameplayStats                         GameplayStats;                                     // 0x0000(0x0108)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bUseTrackedStat;                                   // 0x0108(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x010C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameplayStatsLibrary_GetTotalAssists) == 0x000008, "Wrong alignment on OrionGameplayStatsLibrary_GetTotalAssists");
static_assert(sizeof(OrionGameplayStatsLibrary_GetTotalAssists) == 0x000110, "Wrong size on OrionGameplayStatsLibrary_GetTotalAssists");
static_assert(offsetof(OrionGameplayStatsLibrary_GetTotalAssists, GameplayStats) == 0x000000, "Member 'OrionGameplayStatsLibrary_GetTotalAssists::GameplayStats' has a wrong offset!");
static_assert(offsetof(OrionGameplayStatsLibrary_GetTotalAssists, bUseTrackedStat) == 0x000108, "Member 'OrionGameplayStatsLibrary_GetTotalAssists::bUseTrackedStat' has a wrong offset!");
static_assert(offsetof(OrionGameplayStatsLibrary_GetTotalAssists, ReturnValue) == 0x00010C, "Member 'OrionGameplayStatsLibrary_GetTotalAssists::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameplayStatsLibrary.GetTotalDeaths
// 0x0110 (0x0110 - 0x0000)
struct OrionGameplayStatsLibrary_GetTotalDeaths final
{
public:
	struct FGameplayStats                         GameplayStats;                                     // 0x0000(0x0108)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bUseTrackedStat;                                   // 0x0108(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x010C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameplayStatsLibrary_GetTotalDeaths) == 0x000008, "Wrong alignment on OrionGameplayStatsLibrary_GetTotalDeaths");
static_assert(sizeof(OrionGameplayStatsLibrary_GetTotalDeaths) == 0x000110, "Wrong size on OrionGameplayStatsLibrary_GetTotalDeaths");
static_assert(offsetof(OrionGameplayStatsLibrary_GetTotalDeaths, GameplayStats) == 0x000000, "Member 'OrionGameplayStatsLibrary_GetTotalDeaths::GameplayStats' has a wrong offset!");
static_assert(offsetof(OrionGameplayStatsLibrary_GetTotalDeaths, bUseTrackedStat) == 0x000108, "Member 'OrionGameplayStatsLibrary_GetTotalDeaths::bUseTrackedStat' has a wrong offset!");
static_assert(offsetof(OrionGameplayStatsLibrary_GetTotalDeaths, ReturnValue) == 0x00010C, "Member 'OrionGameplayStatsLibrary_GetTotalDeaths::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameplayStatsLibrary.GetTotalKills
// 0x0110 (0x0110 - 0x0000)
struct OrionGameplayStatsLibrary_GetTotalKills final
{
public:
	struct FGameplayStats                         GameplayStats;                                     // 0x0000(0x0108)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bUseTrackedStat;                                   // 0x0108(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x010C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameplayStatsLibrary_GetTotalKills) == 0x000008, "Wrong alignment on OrionGameplayStatsLibrary_GetTotalKills");
static_assert(sizeof(OrionGameplayStatsLibrary_GetTotalKills) == 0x000110, "Wrong size on OrionGameplayStatsLibrary_GetTotalKills");
static_assert(offsetof(OrionGameplayStatsLibrary_GetTotalKills, GameplayStats) == 0x000000, "Member 'OrionGameplayStatsLibrary_GetTotalKills::GameplayStats' has a wrong offset!");
static_assert(offsetof(OrionGameplayStatsLibrary_GetTotalKills, bUseTrackedStat) == 0x000108, "Member 'OrionGameplayStatsLibrary_GetTotalKills::bUseTrackedStat' has a wrong offset!");
static_assert(offsetof(OrionGameplayStatsLibrary_GetTotalKills, ReturnValue) == 0x00010C, "Member 'OrionGameplayStatsLibrary_GetTotalKills::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameplayStatsLibrary.GetTowerTakedowns
// 0x0110 (0x0110 - 0x0000)
struct OrionGameplayStatsLibrary_GetTowerTakedowns final
{
public:
	struct FGameplayStats                         GameplayStats;                                     // 0x0000(0x0108)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bUseTrackedStat;                                   // 0x0108(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x010C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameplayStatsLibrary_GetTowerTakedowns) == 0x000008, "Wrong alignment on OrionGameplayStatsLibrary_GetTowerTakedowns");
static_assert(sizeof(OrionGameplayStatsLibrary_GetTowerTakedowns) == 0x000110, "Wrong size on OrionGameplayStatsLibrary_GetTowerTakedowns");
static_assert(offsetof(OrionGameplayStatsLibrary_GetTowerTakedowns, GameplayStats) == 0x000000, "Member 'OrionGameplayStatsLibrary_GetTowerTakedowns::GameplayStats' has a wrong offset!");
static_assert(offsetof(OrionGameplayStatsLibrary_GetTowerTakedowns, bUseTrackedStat) == 0x000108, "Member 'OrionGameplayStatsLibrary_GetTowerTakedowns::bUseTrackedStat' has a wrong offset!");
static_assert(offsetof(OrionGameplayStatsLibrary_GetTowerTakedowns, ReturnValue) == 0x00010C, "Member 'OrionGameplayStatsLibrary_GetTowerTakedowns::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameplayVolumeComponent.CanStillApplyEffectsToTargets
// 0x0001 (0x0001 - 0x0000)
struct OrionGameplayVolumeComponent_CanStillApplyEffectsToTargets final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameplayVolumeComponent_CanStillApplyEffectsToTargets) == 0x000001, "Wrong alignment on OrionGameplayVolumeComponent_CanStillApplyEffectsToTargets");
static_assert(sizeof(OrionGameplayVolumeComponent_CanStillApplyEffectsToTargets) == 0x000001, "Wrong size on OrionGameplayVolumeComponent_CanStillApplyEffectsToTargets");
static_assert(offsetof(OrionGameplayVolumeComponent_CanStillApplyEffectsToTargets, ReturnValue) == 0x000000, "Member 'OrionGameplayVolumeComponent_CanStillApplyEffectsToTargets::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameplayVolumeComponent.DisableGameplayVolume
// 0x0001 (0x0001 - 0x0000)
struct OrionGameplayVolumeComponent_DisableGameplayVolume final
{
public:
	bool                                          ResetInternalState;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameplayVolumeComponent_DisableGameplayVolume) == 0x000001, "Wrong alignment on OrionGameplayVolumeComponent_DisableGameplayVolume");
static_assert(sizeof(OrionGameplayVolumeComponent_DisableGameplayVolume) == 0x000001, "Wrong size on OrionGameplayVolumeComponent_DisableGameplayVolume");
static_assert(offsetof(OrionGameplayVolumeComponent_DisableGameplayVolume, ResetInternalState) == 0x000000, "Member 'OrionGameplayVolumeComponent_DisableGameplayVolume::ResetInternalState' has a wrong offset!");

// Function OrionGame.OrionGameplayVolumeComponent.EnableLinkedCollisionViaPrimitive
// 0x0018 (0x0018 - 0x0000)
struct OrionGameplayVolumeComponent_EnableLinkedCollisionViaPrimitive final
{
public:
	TArray<class UPrimitiveComponent*>            LinkedPrimitives;                                  // 0x0000(0x0010)(Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bEnablePrimitiveOverlap;                           // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionGameplayVolumeComponent_EnableLinkedCollisionViaPrimitive) == 0x000008, "Wrong alignment on OrionGameplayVolumeComponent_EnableLinkedCollisionViaPrimitive");
static_assert(sizeof(OrionGameplayVolumeComponent_EnableLinkedCollisionViaPrimitive) == 0x000018, "Wrong size on OrionGameplayVolumeComponent_EnableLinkedCollisionViaPrimitive");
static_assert(offsetof(OrionGameplayVolumeComponent_EnableLinkedCollisionViaPrimitive, LinkedPrimitives) == 0x000000, "Member 'OrionGameplayVolumeComponent_EnableLinkedCollisionViaPrimitive::LinkedPrimitives' has a wrong offset!");
static_assert(offsetof(OrionGameplayVolumeComponent_EnableLinkedCollisionViaPrimitive, bEnablePrimitiveOverlap) == 0x000010, "Member 'OrionGameplayVolumeComponent_EnableLinkedCollisionViaPrimitive::bEnablePrimitiveOverlap' has a wrong offset!");

// Function OrionGame.OrionGameplayVolumeComponent.EnableLinkedCollisionViaTags
// 0x0028 (0x0028 - 0x0000)
struct OrionGameplayVolumeComponent_EnableLinkedCollisionViaTags final
{
public:
	struct FGameplayTagContainer                  LinkedVolumeTag;                                   // 0x0000(0x0020)(Parm, NativeAccessSpecifierPublic)
	bool                                          bEnablePrimitiveOverlap;                           // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0021(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionGameplayVolumeComponent_EnableLinkedCollisionViaTags) == 0x000008, "Wrong alignment on OrionGameplayVolumeComponent_EnableLinkedCollisionViaTags");
static_assert(sizeof(OrionGameplayVolumeComponent_EnableLinkedCollisionViaTags) == 0x000028, "Wrong size on OrionGameplayVolumeComponent_EnableLinkedCollisionViaTags");
static_assert(offsetof(OrionGameplayVolumeComponent_EnableLinkedCollisionViaTags, LinkedVolumeTag) == 0x000000, "Member 'OrionGameplayVolumeComponent_EnableLinkedCollisionViaTags::LinkedVolumeTag' has a wrong offset!");
static_assert(offsetof(OrionGameplayVolumeComponent_EnableLinkedCollisionViaTags, bEnablePrimitiveOverlap) == 0x000020, "Member 'OrionGameplayVolumeComponent_EnableLinkedCollisionViaTags::bEnablePrimitiveOverlap' has a wrong offset!");
static_assert(offsetof(OrionGameplayVolumeComponent_EnableLinkedCollisionViaTags, ReturnValue) == 0x000021, "Member 'OrionGameplayVolumeComponent_EnableLinkedCollisionViaTags::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameplayVolumeComponent.GetNumAppliedEffectsLeftToApply
// 0x0004 (0x0004 - 0x0000)
struct OrionGameplayVolumeComponent_GetNumAppliedEffectsLeftToApply final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameplayVolumeComponent_GetNumAppliedEffectsLeftToApply) == 0x000004, "Wrong alignment on OrionGameplayVolumeComponent_GetNumAppliedEffectsLeftToApply");
static_assert(sizeof(OrionGameplayVolumeComponent_GetNumAppliedEffectsLeftToApply) == 0x000004, "Wrong size on OrionGameplayVolumeComponent_GetNumAppliedEffectsLeftToApply");
static_assert(offsetof(OrionGameplayVolumeComponent_GetNumAppliedEffectsLeftToApply, ReturnValue) == 0x000000, "Member 'OrionGameplayVolumeComponent_GetNumAppliedEffectsLeftToApply::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameplayVolumeComponent.IsValidTarget
// 0x0010 (0x0010 - 0x0000)
struct OrionGameplayVolumeComponent_IsValidTarget final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionGameplayVolumeComponent_IsValidTarget) == 0x000008, "Wrong alignment on OrionGameplayVolumeComponent_IsValidTarget");
static_assert(sizeof(OrionGameplayVolumeComponent_IsValidTarget) == 0x000010, "Wrong size on OrionGameplayVolumeComponent_IsValidTarget");
static_assert(offsetof(OrionGameplayVolumeComponent_IsValidTarget, Actor) == 0x000000, "Member 'OrionGameplayVolumeComponent_IsValidTarget::Actor' has a wrong offset!");
static_assert(offsetof(OrionGameplayVolumeComponent_IsValidTarget, ReturnValue) == 0x000008, "Member 'OrionGameplayVolumeComponent_IsValidTarget::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameplayVolumeComponent.OnBeginOverlapCallback
// 0x00A8 (0x00A8 - 0x0000)
struct OrionGameplayVolumeComponent_OnBeginOverlapCallback final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameplayVolumeComponent_OnBeginOverlapCallback) == 0x000008, "Wrong alignment on OrionGameplayVolumeComponent_OnBeginOverlapCallback");
static_assert(sizeof(OrionGameplayVolumeComponent_OnBeginOverlapCallback) == 0x0000A8, "Wrong size on OrionGameplayVolumeComponent_OnBeginOverlapCallback");
static_assert(offsetof(OrionGameplayVolumeComponent_OnBeginOverlapCallback, OverlappedComp) == 0x000000, "Member 'OrionGameplayVolumeComponent_OnBeginOverlapCallback::OverlappedComp' has a wrong offset!");
static_assert(offsetof(OrionGameplayVolumeComponent_OnBeginOverlapCallback, OtherActor) == 0x000008, "Member 'OrionGameplayVolumeComponent_OnBeginOverlapCallback::OtherActor' has a wrong offset!");
static_assert(offsetof(OrionGameplayVolumeComponent_OnBeginOverlapCallback, OtherComp) == 0x000010, "Member 'OrionGameplayVolumeComponent_OnBeginOverlapCallback::OtherComp' has a wrong offset!");
static_assert(offsetof(OrionGameplayVolumeComponent_OnBeginOverlapCallback, OtherBodyIndex) == 0x000018, "Member 'OrionGameplayVolumeComponent_OnBeginOverlapCallback::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(OrionGameplayVolumeComponent_OnBeginOverlapCallback, bFromSweep) == 0x00001C, "Member 'OrionGameplayVolumeComponent_OnBeginOverlapCallback::bFromSweep' has a wrong offset!");
static_assert(offsetof(OrionGameplayVolumeComponent_OnBeginOverlapCallback, SweepResult) == 0x000020, "Member 'OrionGameplayVolumeComponent_OnBeginOverlapCallback::SweepResult' has a wrong offset!");

// Function OrionGame.OrionGameplayVolumeComponent.OnEndOverlapCallback
// 0x0020 (0x0020 - 0x0000)
struct OrionGameplayVolumeComponent_OnEndOverlapCallback final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionGameplayVolumeComponent_OnEndOverlapCallback) == 0x000008, "Wrong alignment on OrionGameplayVolumeComponent_OnEndOverlapCallback");
static_assert(sizeof(OrionGameplayVolumeComponent_OnEndOverlapCallback) == 0x000020, "Wrong size on OrionGameplayVolumeComponent_OnEndOverlapCallback");
static_assert(offsetof(OrionGameplayVolumeComponent_OnEndOverlapCallback, OverlappedComp) == 0x000000, "Member 'OrionGameplayVolumeComponent_OnEndOverlapCallback::OverlappedComp' has a wrong offset!");
static_assert(offsetof(OrionGameplayVolumeComponent_OnEndOverlapCallback, OtherActor) == 0x000008, "Member 'OrionGameplayVolumeComponent_OnEndOverlapCallback::OtherActor' has a wrong offset!");
static_assert(offsetof(OrionGameplayVolumeComponent_OnEndOverlapCallback, OtherComp) == 0x000010, "Member 'OrionGameplayVolumeComponent_OnEndOverlapCallback::OtherComp' has a wrong offset!");
static_assert(offsetof(OrionGameplayVolumeComponent_OnEndOverlapCallback, OtherBodyIndex) == 0x000018, "Member 'OrionGameplayVolumeComponent_OnEndOverlapCallback::OtherBodyIndex' has a wrong offset!");

// Function OrionGame.OrionGameplayVolumeComponent.OnOwnerChangedDimension
// 0x0008 (0x0008 - 0x0000)
struct OrionGameplayVolumeComponent_OnOwnerChangedDimension final
{
public:
	class AOrionChar*                             CharInChangedDimension;                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameplayVolumeComponent_OnOwnerChangedDimension) == 0x000008, "Wrong alignment on OrionGameplayVolumeComponent_OnOwnerChangedDimension");
static_assert(sizeof(OrionGameplayVolumeComponent_OnOwnerChangedDimension) == 0x000008, "Wrong size on OrionGameplayVolumeComponent_OnOwnerChangedDimension");
static_assert(offsetof(OrionGameplayVolumeComponent_OnOwnerChangedDimension, CharInChangedDimension) == 0x000000, "Member 'OrionGameplayVolumeComponent_OnOwnerChangedDimension::CharInChangedDimension' has a wrong offset!");

// Function OrionGame.OrionGameplayVolumeComponent.ProcessLinkedBeginOverlapCallback
// 0x00A8 (0x00A8 - 0x0000)
struct OrionGameplayVolumeComponent_ProcessLinkedBeginOverlapCallback final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameplayVolumeComponent_ProcessLinkedBeginOverlapCallback) == 0x000008, "Wrong alignment on OrionGameplayVolumeComponent_ProcessLinkedBeginOverlapCallback");
static_assert(sizeof(OrionGameplayVolumeComponent_ProcessLinkedBeginOverlapCallback) == 0x0000A8, "Wrong size on OrionGameplayVolumeComponent_ProcessLinkedBeginOverlapCallback");
static_assert(offsetof(OrionGameplayVolumeComponent_ProcessLinkedBeginOverlapCallback, OverlappedComp) == 0x000000, "Member 'OrionGameplayVolumeComponent_ProcessLinkedBeginOverlapCallback::OverlappedComp' has a wrong offset!");
static_assert(offsetof(OrionGameplayVolumeComponent_ProcessLinkedBeginOverlapCallback, OtherActor) == 0x000008, "Member 'OrionGameplayVolumeComponent_ProcessLinkedBeginOverlapCallback::OtherActor' has a wrong offset!");
static_assert(offsetof(OrionGameplayVolumeComponent_ProcessLinkedBeginOverlapCallback, OtherComp) == 0x000010, "Member 'OrionGameplayVolumeComponent_ProcessLinkedBeginOverlapCallback::OtherComp' has a wrong offset!");
static_assert(offsetof(OrionGameplayVolumeComponent_ProcessLinkedBeginOverlapCallback, OtherBodyIndex) == 0x000018, "Member 'OrionGameplayVolumeComponent_ProcessLinkedBeginOverlapCallback::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(OrionGameplayVolumeComponent_ProcessLinkedBeginOverlapCallback, bFromSweep) == 0x00001C, "Member 'OrionGameplayVolumeComponent_ProcessLinkedBeginOverlapCallback::bFromSweep' has a wrong offset!");
static_assert(offsetof(OrionGameplayVolumeComponent_ProcessLinkedBeginOverlapCallback, SweepResult) == 0x000020, "Member 'OrionGameplayVolumeComponent_ProcessLinkedBeginOverlapCallback::SweepResult' has a wrong offset!");

// Function OrionGame.OrionGameplayVolumeComponent.ProcessLinkedEndOverlapCallback
// 0x0020 (0x0020 - 0x0000)
struct OrionGameplayVolumeComponent_ProcessLinkedEndOverlapCallback final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionGameplayVolumeComponent_ProcessLinkedEndOverlapCallback) == 0x000008, "Wrong alignment on OrionGameplayVolumeComponent_ProcessLinkedEndOverlapCallback");
static_assert(sizeof(OrionGameplayVolumeComponent_ProcessLinkedEndOverlapCallback) == 0x000020, "Wrong size on OrionGameplayVolumeComponent_ProcessLinkedEndOverlapCallback");
static_assert(offsetof(OrionGameplayVolumeComponent_ProcessLinkedEndOverlapCallback, OverlappedComp) == 0x000000, "Member 'OrionGameplayVolumeComponent_ProcessLinkedEndOverlapCallback::OverlappedComp' has a wrong offset!");
static_assert(offsetof(OrionGameplayVolumeComponent_ProcessLinkedEndOverlapCallback, OtherActor) == 0x000008, "Member 'OrionGameplayVolumeComponent_ProcessLinkedEndOverlapCallback::OtherActor' has a wrong offset!");
static_assert(offsetof(OrionGameplayVolumeComponent_ProcessLinkedEndOverlapCallback, OtherComp) == 0x000010, "Member 'OrionGameplayVolumeComponent_ProcessLinkedEndOverlapCallback::OtherComp' has a wrong offset!");
static_assert(offsetof(OrionGameplayVolumeComponent_ProcessLinkedEndOverlapCallback, OtherBodyIndex) == 0x000018, "Member 'OrionGameplayVolumeComponent_ProcessLinkedEndOverlapCallback::OtherBodyIndex' has a wrong offset!");

// Function OrionGame.HoverDronePawn.GetAltitude
// 0x0004 (0x0004 - 0x0000)
struct HoverDronePawn_GetAltitude final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HoverDronePawn_GetAltitude) == 0x000004, "Wrong alignment on HoverDronePawn_GetAltitude");
static_assert(sizeof(HoverDronePawn_GetAltitude) == 0x000004, "Wrong size on HoverDronePawn_GetAltitude");
static_assert(offsetof(HoverDronePawn_GetAltitude, ReturnValue) == 0x000000, "Member 'HoverDronePawn_GetAltitude::ReturnValue' has a wrong offset!");

// Function OrionGame.HoverDronePawn.IsMaintainingConstantAltitude
// 0x0001 (0x0001 - 0x0000)
struct HoverDronePawn_IsMaintainingConstantAltitude final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HoverDronePawn_IsMaintainingConstantAltitude) == 0x000001, "Wrong alignment on HoverDronePawn_IsMaintainingConstantAltitude");
static_assert(sizeof(HoverDronePawn_IsMaintainingConstantAltitude) == 0x000001, "Wrong size on HoverDronePawn_IsMaintainingConstantAltitude");
static_assert(offsetof(HoverDronePawn_IsMaintainingConstantAltitude, ReturnValue) == 0x000000, "Member 'HoverDronePawn_IsMaintainingConstantAltitude::ReturnValue' has a wrong offset!");

// Function OrionGame.HUDAlertAsset.GetAlertText
// 0x0018 (0x0018 - 0x0000)
struct HUDAlertAsset_GetAlertText final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUDAlertAsset_GetAlertText) == 0x000008, "Wrong alignment on HUDAlertAsset_GetAlertText");
static_assert(sizeof(HUDAlertAsset_GetAlertText) == 0x000018, "Wrong size on HUDAlertAsset_GetAlertText");
static_assert(offsetof(HUDAlertAsset_GetAlertText, ReturnValue) == 0x000000, "Member 'HUDAlertAsset_GetAlertText::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameState_Base.AnnouncerSay
// 0x0018 (0x0018 - 0x0000)
struct OrionGameState_Base_AnnouncerSay final
{
public:
	class AActor*                                 SoundInstigator;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Ident;                                             // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameState_Base_AnnouncerSay) == 0x000008, "Wrong alignment on OrionGameState_Base_AnnouncerSay");
static_assert(sizeof(OrionGameState_Base_AnnouncerSay) == 0x000018, "Wrong size on OrionGameState_Base_AnnouncerSay");
static_assert(offsetof(OrionGameState_Base_AnnouncerSay, SoundInstigator) == 0x000000, "Member 'OrionGameState_Base_AnnouncerSay::SoundInstigator' has a wrong offset!");
static_assert(offsetof(OrionGameState_Base_AnnouncerSay, Ident) == 0x000008, "Member 'OrionGameState_Base_AnnouncerSay::Ident' has a wrong offset!");

// Function OrionGame.OrionGameState_Base.ExecuteGameplayCue
// 0x00C8 (0x00C8 - 0x0000)
struct OrionGameState_Base_ExecuteGameplayCue final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 CueParameters;                                     // 0x0008(0x00B8)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x00C0(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameState_Base_ExecuteGameplayCue) == 0x000008, "Wrong alignment on OrionGameState_Base_ExecuteGameplayCue");
static_assert(sizeof(OrionGameState_Base_ExecuteGameplayCue) == 0x0000C8, "Wrong size on OrionGameState_Base_ExecuteGameplayCue");
static_assert(offsetof(OrionGameState_Base_ExecuteGameplayCue, GameplayCueTag) == 0x000000, "Member 'OrionGameState_Base_ExecuteGameplayCue::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(OrionGameState_Base_ExecuteGameplayCue, CueParameters) == 0x000008, "Member 'OrionGameState_Base_ExecuteGameplayCue::CueParameters' has a wrong offset!");
static_assert(offsetof(OrionGameState_Base_ExecuteGameplayCue, TargetActor) == 0x0000C0, "Member 'OrionGameState_Base_ExecuteGameplayCue::TargetActor' has a wrong offset!");

// Function OrionGame.OrionGameState_Base.AreRootMotionSourcesEnabled
// 0x0001 (0x0001 - 0x0000)
struct OrionGameState_Base_AreRootMotionSourcesEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameState_Base_AreRootMotionSourcesEnabled) == 0x000001, "Wrong alignment on OrionGameState_Base_AreRootMotionSourcesEnabled");
static_assert(sizeof(OrionGameState_Base_AreRootMotionSourcesEnabled) == 0x000001, "Wrong size on OrionGameState_Base_AreRootMotionSourcesEnabled");
static_assert(offsetof(OrionGameState_Base_AreRootMotionSourcesEnabled, ReturnValue) == 0x000000, "Member 'OrionGameState_Base_AreRootMotionSourcesEnabled::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameState_Base.GetTeamByIndex
// 0x0010 (0x0010 - 0x0000)
struct OrionGameState_Base_GetTeamByIndex final
{
public:
	EOrionTeam                                    TeamIndex;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrionTeamInfo*                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameState_Base_GetTeamByIndex) == 0x000008, "Wrong alignment on OrionGameState_Base_GetTeamByIndex");
static_assert(sizeof(OrionGameState_Base_GetTeamByIndex) == 0x000010, "Wrong size on OrionGameState_Base_GetTeamByIndex");
static_assert(offsetof(OrionGameState_Base_GetTeamByIndex, TeamIndex) == 0x000000, "Member 'OrionGameState_Base_GetTeamByIndex::TeamIndex' has a wrong offset!");
static_assert(offsetof(OrionGameState_Base_GetTeamByIndex, ReturnValue) == 0x000008, "Member 'OrionGameState_Base_GetTeamByIndex::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCPPHeroBaseAnimInstance.AnimNotify_EnteredDefaultIdle
// 0x0008 (0x0008 - 0x0000)
struct OrionCPPHeroBaseAnimInstance_AnimNotify_EnteredDefaultIdle final
{
public:
	const class UAnimNotify*                      Notify;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCPPHeroBaseAnimInstance_AnimNotify_EnteredDefaultIdle) == 0x000008, "Wrong alignment on OrionCPPHeroBaseAnimInstance_AnimNotify_EnteredDefaultIdle");
static_assert(sizeof(OrionCPPHeroBaseAnimInstance_AnimNotify_EnteredDefaultIdle) == 0x000008, "Wrong size on OrionCPPHeroBaseAnimInstance_AnimNotify_EnteredDefaultIdle");
static_assert(offsetof(OrionCPPHeroBaseAnimInstance_AnimNotify_EnteredDefaultIdle, Notify) == 0x000000, "Member 'OrionCPPHeroBaseAnimInstance_AnimNotify_EnteredDefaultIdle::Notify' has a wrong offset!");

// Function OrionGame.OrionBaseHeroAnimInstance.AnimNotify_EnteredIdle
// 0x0008 (0x0008 - 0x0000)
struct OrionBaseHeroAnimInstance_AnimNotify_EnteredIdle final
{
public:
	const class UAnimNotify*                      Notify;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseHeroAnimInstance_AnimNotify_EnteredIdle) == 0x000008, "Wrong alignment on OrionBaseHeroAnimInstance_AnimNotify_EnteredIdle");
static_assert(sizeof(OrionBaseHeroAnimInstance_AnimNotify_EnteredIdle) == 0x000008, "Wrong size on OrionBaseHeroAnimInstance_AnimNotify_EnteredIdle");
static_assert(offsetof(OrionBaseHeroAnimInstance_AnimNotify_EnteredIdle, Notify) == 0x000000, "Member 'OrionBaseHeroAnimInstance_AnimNotify_EnteredIdle::Notify' has a wrong offset!");

// Function OrionGame.OrionBaseHeroAnimInstance.AnimNotify_EnteredTurnInPlace
// 0x0008 (0x0008 - 0x0000)
struct OrionBaseHeroAnimInstance_AnimNotify_EnteredTurnInPlace final
{
public:
	const class UAnimNotify*                      Notify;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseHeroAnimInstance_AnimNotify_EnteredTurnInPlace) == 0x000008, "Wrong alignment on OrionBaseHeroAnimInstance_AnimNotify_EnteredTurnInPlace");
static_assert(sizeof(OrionBaseHeroAnimInstance_AnimNotify_EnteredTurnInPlace) == 0x000008, "Wrong size on OrionBaseHeroAnimInstance_AnimNotify_EnteredTurnInPlace");
static_assert(offsetof(OrionBaseHeroAnimInstance_AnimNotify_EnteredTurnInPlace, Notify) == 0x000000, "Member 'OrionBaseHeroAnimInstance_AnimNotify_EnteredTurnInPlace::Notify' has a wrong offset!");

// Function OrionGame.OrionBaseHeroAnimInstance.AnimNotify_ExitedIdle
// 0x0008 (0x0008 - 0x0000)
struct OrionBaseHeroAnimInstance_AnimNotify_ExitedIdle final
{
public:
	const class UAnimNotify*                      Notify;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseHeroAnimInstance_AnimNotify_ExitedIdle) == 0x000008, "Wrong alignment on OrionBaseHeroAnimInstance_AnimNotify_ExitedIdle");
static_assert(sizeof(OrionBaseHeroAnimInstance_AnimNotify_ExitedIdle) == 0x000008, "Wrong size on OrionBaseHeroAnimInstance_AnimNotify_ExitedIdle");
static_assert(offsetof(OrionBaseHeroAnimInstance_AnimNotify_ExitedIdle, Notify) == 0x000000, "Member 'OrionBaseHeroAnimInstance_AnimNotify_ExitedIdle::Notify' has a wrong offset!");

// Function OrionGame.OrionBaseHeroAnimInstance.AnimNotify_ExitedTurnInPlace
// 0x0008 (0x0008 - 0x0000)
struct OrionBaseHeroAnimInstance_AnimNotify_ExitedTurnInPlace final
{
public:
	const class UAnimNotify*                      Notify;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseHeroAnimInstance_AnimNotify_ExitedTurnInPlace) == 0x000008, "Wrong alignment on OrionBaseHeroAnimInstance_AnimNotify_ExitedTurnInPlace");
static_assert(sizeof(OrionBaseHeroAnimInstance_AnimNotify_ExitedTurnInPlace) == 0x000008, "Wrong size on OrionBaseHeroAnimInstance_AnimNotify_ExitedTurnInPlace");
static_assert(offsetof(OrionBaseHeroAnimInstance_AnimNotify_ExitedTurnInPlace, Notify) == 0x000000, "Member 'OrionBaseHeroAnimInstance_AnimNotify_ExitedTurnInPlace::Notify' has a wrong offset!");

// Function OrionGame.OrionBaseHeroAnimInstance.AnimNotify_HitReactEnd
// 0x0008 (0x0008 - 0x0000)
struct OrionBaseHeroAnimInstance_AnimNotify_HitReactEnd final
{
public:
	const class UAnimNotify*                      Notify;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseHeroAnimInstance_AnimNotify_HitReactEnd) == 0x000008, "Wrong alignment on OrionBaseHeroAnimInstance_AnimNotify_HitReactEnd");
static_assert(sizeof(OrionBaseHeroAnimInstance_AnimNotify_HitReactEnd) == 0x000008, "Wrong size on OrionBaseHeroAnimInstance_AnimNotify_HitReactEnd");
static_assert(offsetof(OrionBaseHeroAnimInstance_AnimNotify_HitReactEnd, Notify) == 0x000000, "Member 'OrionBaseHeroAnimInstance_AnimNotify_HitReactEnd::Notify' has a wrong offset!");

// Function OrionGame.OrionBaseHeroAnimInstance.AnimNotify_IdleToJog
// 0x0008 (0x0008 - 0x0000)
struct OrionBaseHeroAnimInstance_AnimNotify_IdleToJog final
{
public:
	const class UAnimNotify*                      Notify;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseHeroAnimInstance_AnimNotify_IdleToJog) == 0x000008, "Wrong alignment on OrionBaseHeroAnimInstance_AnimNotify_IdleToJog");
static_assert(sizeof(OrionBaseHeroAnimInstance_AnimNotify_IdleToJog) == 0x000008, "Wrong size on OrionBaseHeroAnimInstance_AnimNotify_IdleToJog");
static_assert(offsetof(OrionBaseHeroAnimInstance_AnimNotify_IdleToJog, Notify) == 0x000000, "Member 'OrionBaseHeroAnimInstance_AnimNotify_IdleToJog::Notify' has a wrong offset!");

// Function OrionGame.OrionBaseHeroAnimInstance.AnimNotify_JogToIdle
// 0x0008 (0x0008 - 0x0000)
struct OrionBaseHeroAnimInstance_AnimNotify_JogToIdle final
{
public:
	const class UAnimNotify*                      Notify;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseHeroAnimInstance_AnimNotify_JogToIdle) == 0x000008, "Wrong alignment on OrionBaseHeroAnimInstance_AnimNotify_JogToIdle");
static_assert(sizeof(OrionBaseHeroAnimInstance_AnimNotify_JogToIdle) == 0x000008, "Wrong size on OrionBaseHeroAnimInstance_AnimNotify_JogToIdle");
static_assert(offsetof(OrionBaseHeroAnimInstance_AnimNotify_JogToIdle, Notify) == 0x000000, "Member 'OrionBaseHeroAnimInstance_AnimNotify_JogToIdle::Notify' has a wrong offset!");

// Function OrionGame.OrionBaseHeroAnimInstance.AnimNotify_JumpExit
// 0x0008 (0x0008 - 0x0000)
struct OrionBaseHeroAnimInstance_AnimNotify_JumpExit final
{
public:
	const class UAnimNotify*                      Notify;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseHeroAnimInstance_AnimNotify_JumpExit) == 0x000008, "Wrong alignment on OrionBaseHeroAnimInstance_AnimNotify_JumpExit");
static_assert(sizeof(OrionBaseHeroAnimInstance_AnimNotify_JumpExit) == 0x000008, "Wrong size on OrionBaseHeroAnimInstance_AnimNotify_JumpExit");
static_assert(offsetof(OrionBaseHeroAnimInstance_AnimNotify_JumpExit, Notify) == 0x000000, "Member 'OrionBaseHeroAnimInstance_AnimNotify_JumpExit::Notify' has a wrong offset!");

// Function OrionGame.OrionBaseHeroAnimInstance.AnimNotify_JumpLandingExit
// 0x0008 (0x0008 - 0x0000)
struct OrionBaseHeroAnimInstance_AnimNotify_JumpLandingExit final
{
public:
	const class UAnimNotify*                      Notify;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseHeroAnimInstance_AnimNotify_JumpLandingExit) == 0x000008, "Wrong alignment on OrionBaseHeroAnimInstance_AnimNotify_JumpLandingExit");
static_assert(sizeof(OrionBaseHeroAnimInstance_AnimNotify_JumpLandingExit) == 0x000008, "Wrong size on OrionBaseHeroAnimInstance_AnimNotify_JumpLandingExit");
static_assert(offsetof(OrionBaseHeroAnimInstance_AnimNotify_JumpLandingExit, Notify) == 0x000000, "Member 'OrionBaseHeroAnimInstance_AnimNotify_JumpLandingExit::Notify' has a wrong offset!");

// Function OrionGame.OrionBaseHeroAnimInstance.AnimNotify_MeleeFullBody
// 0x0008 (0x0008 - 0x0000)
struct OrionBaseHeroAnimInstance_AnimNotify_MeleeFullBody final
{
public:
	const class UAnimNotify*                      Notify;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseHeroAnimInstance_AnimNotify_MeleeFullBody) == 0x000008, "Wrong alignment on OrionBaseHeroAnimInstance_AnimNotify_MeleeFullBody");
static_assert(sizeof(OrionBaseHeroAnimInstance_AnimNotify_MeleeFullBody) == 0x000008, "Wrong size on OrionBaseHeroAnimInstance_AnimNotify_MeleeFullBody");
static_assert(offsetof(OrionBaseHeroAnimInstance_AnimNotify_MeleeFullBody, Notify) == 0x000000, "Member 'OrionBaseHeroAnimInstance_AnimNotify_MeleeFullBody::Notify' has a wrong offset!");

// Function OrionGame.OrionBaseHeroAnimInstance.AnimNotify_MeleeUpperBody
// 0x0008 (0x0008 - 0x0000)
struct OrionBaseHeroAnimInstance_AnimNotify_MeleeUpperBody final
{
public:
	const class UAnimNotify*                      Notify;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseHeroAnimInstance_AnimNotify_MeleeUpperBody) == 0x000008, "Wrong alignment on OrionBaseHeroAnimInstance_AnimNotify_MeleeUpperBody");
static_assert(sizeof(OrionBaseHeroAnimInstance_AnimNotify_MeleeUpperBody) == 0x000008, "Wrong size on OrionBaseHeroAnimInstance_AnimNotify_MeleeUpperBody");
static_assert(offsetof(OrionBaseHeroAnimInstance_AnimNotify_MeleeUpperBody, Notify) == 0x000000, "Member 'OrionBaseHeroAnimInstance_AnimNotify_MeleeUpperBody::Notify' has a wrong offset!");

// Function OrionGame.OrionInputHandlerWidget.HandleRequestedInput
// 0x0020 (0x0020 - 0x0000)
struct OrionInputHandlerWidget_HandleRequestedInput final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputEvent                                   EventType;                                         // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionInputHandlerWidget_HandleRequestedInput) == 0x000008, "Wrong alignment on OrionInputHandlerWidget_HandleRequestedInput");
static_assert(sizeof(OrionInputHandlerWidget_HandleRequestedInput) == 0x000020, "Wrong size on OrionInputHandlerWidget_HandleRequestedInput");
static_assert(offsetof(OrionInputHandlerWidget_HandleRequestedInput, Key) == 0x000000, "Member 'OrionInputHandlerWidget_HandleRequestedInput::Key' has a wrong offset!");
static_assert(offsetof(OrionInputHandlerWidget_HandleRequestedInput, EventType) == 0x000018, "Member 'OrionInputHandlerWidget_HandleRequestedInput::EventType' has a wrong offset!");

// Function OrionGame.OrionProjectile.AddGameplayCueLocal
// 0x00C0 (0x00C0 - 0x0000)
struct OrionProjectile_AddGameplayCueLocal final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 Parameters;                                        // 0x0008(0x00B8)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjectile_AddGameplayCueLocal) == 0x000008, "Wrong alignment on OrionProjectile_AddGameplayCueLocal");
static_assert(sizeof(OrionProjectile_AddGameplayCueLocal) == 0x0000C0, "Wrong size on OrionProjectile_AddGameplayCueLocal");
static_assert(offsetof(OrionProjectile_AddGameplayCueLocal, GameplayCueTag) == 0x000000, "Member 'OrionProjectile_AddGameplayCueLocal::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(OrionProjectile_AddGameplayCueLocal, Parameters) == 0x000008, "Member 'OrionProjectile_AddGameplayCueLocal::Parameters' has a wrong offset!");

// Function OrionGame.OrionProjectile.EndTimeDilation
// 0x000C (0x000C - 0x0000)
struct OrionProjectile_EndTimeDilation final
{
public:
	int32                                         WhichDilationChannel;                              // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpOutSeconds;                                    // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Delay;                                             // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjectile_EndTimeDilation) == 0x000004, "Wrong alignment on OrionProjectile_EndTimeDilation");
static_assert(sizeof(OrionProjectile_EndTimeDilation) == 0x00000C, "Wrong size on OrionProjectile_EndTimeDilation");
static_assert(offsetof(OrionProjectile_EndTimeDilation, WhichDilationChannel) == 0x000000, "Member 'OrionProjectile_EndTimeDilation::WhichDilationChannel' has a wrong offset!");
static_assert(offsetof(OrionProjectile_EndTimeDilation, LerpOutSeconds) == 0x000004, "Member 'OrionProjectile_EndTimeDilation::LerpOutSeconds' has a wrong offset!");
static_assert(offsetof(OrionProjectile_EndTimeDilation, Delay) == 0x000008, "Member 'OrionProjectile_EndTimeDilation::Delay' has a wrong offset!");

// Function OrionGame.OrionProjectile.ExecuteGameplayCueLocal
// 0x00C0 (0x00C0 - 0x0000)
struct OrionProjectile_ExecuteGameplayCueLocal final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 Parameters;                                        // 0x0008(0x00B8)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjectile_ExecuteGameplayCueLocal) == 0x000008, "Wrong alignment on OrionProjectile_ExecuteGameplayCueLocal");
static_assert(sizeof(OrionProjectile_ExecuteGameplayCueLocal) == 0x0000C0, "Wrong size on OrionProjectile_ExecuteGameplayCueLocal");
static_assert(offsetof(OrionProjectile_ExecuteGameplayCueLocal, GameplayCueTag) == 0x000000, "Member 'OrionProjectile_ExecuteGameplayCueLocal::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(OrionProjectile_ExecuteGameplayCueLocal, Parameters) == 0x000008, "Member 'OrionProjectile_ExecuteGameplayCueLocal::Parameters' has a wrong offset!");

// Function OrionGame.OrionProjectile.HandleHomingEnterPhaseShift
// 0x0008 (0x0008 - 0x0000)
struct OrionProjectile_HandleHomingEnterPhaseShift final
{
public:
	class AOrionChar*                             PhaseShifedChar;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjectile_HandleHomingEnterPhaseShift) == 0x000008, "Wrong alignment on OrionProjectile_HandleHomingEnterPhaseShift");
static_assert(sizeof(OrionProjectile_HandleHomingEnterPhaseShift) == 0x000008, "Wrong size on OrionProjectile_HandleHomingEnterPhaseShift");
static_assert(offsetof(OrionProjectile_HandleHomingEnterPhaseShift, PhaseShifedChar) == 0x000000, "Member 'OrionProjectile_HandleHomingEnterPhaseShift::PhaseShifedChar' has a wrong offset!");

// Function OrionGame.OrionProjectile.K2_InitProjectileFilters
// 0x0028 (0x0028 - 0x0000)
struct OrionProjectile_K2_InitProjectileFilters final
{
public:
	class AActor*                                 InInstigator;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InSource;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InLevel;                                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayAbility*                       InAbility;                                         // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionProjectile_K2_InitProjectileFilters) == 0x000008, "Wrong alignment on OrionProjectile_K2_InitProjectileFilters");
static_assert(sizeof(OrionProjectile_K2_InitProjectileFilters) == 0x000028, "Wrong size on OrionProjectile_K2_InitProjectileFilters");
static_assert(offsetof(OrionProjectile_K2_InitProjectileFilters, InInstigator) == 0x000000, "Member 'OrionProjectile_K2_InitProjectileFilters::InInstigator' has a wrong offset!");
static_assert(offsetof(OrionProjectile_K2_InitProjectileFilters, InSource) == 0x000008, "Member 'OrionProjectile_K2_InitProjectileFilters::InSource' has a wrong offset!");
static_assert(offsetof(OrionProjectile_K2_InitProjectileFilters, InLevel) == 0x000010, "Member 'OrionProjectile_K2_InitProjectileFilters::InLevel' has a wrong offset!");
static_assert(offsetof(OrionProjectile_K2_InitProjectileFilters, InAbility) == 0x000018, "Member 'OrionProjectile_K2_InitProjectileFilters::InAbility' has a wrong offset!");
static_assert(offsetof(OrionProjectile_K2_InitProjectileFilters, ReturnValue) == 0x000020, "Member 'OrionProjectile_K2_InitProjectileFilters::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionProjectile.NetSync_HitActor
// 0x0090 (0x0090 - 0x0000)
struct OrionProjectile_NetSync_HitActor final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x0088)(Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         UserStateID;                                       // 0x0088(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSyncClientToServerPosAndVel;                      // 0x008C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionProjectile_NetSync_HitActor) == 0x000008, "Wrong alignment on OrionProjectile_NetSync_HitActor");
static_assert(sizeof(OrionProjectile_NetSync_HitActor) == 0x000090, "Wrong size on OrionProjectile_NetSync_HitActor");
static_assert(offsetof(OrionProjectile_NetSync_HitActor, Hit) == 0x000000, "Member 'OrionProjectile_NetSync_HitActor::Hit' has a wrong offset!");
static_assert(offsetof(OrionProjectile_NetSync_HitActor, UserStateID) == 0x000088, "Member 'OrionProjectile_NetSync_HitActor::UserStateID' has a wrong offset!");
static_assert(offsetof(OrionProjectile_NetSync_HitActor, bSyncClientToServerPosAndVel) == 0x00008C, "Member 'OrionProjectile_NetSync_HitActor::bSyncClientToServerPosAndVel' has a wrong offset!");

// Function OrionGame.OrionProjectile.NetSync_SetNewTarget
// 0x0028 (0x0028 - 0x0000)
struct OrionProjectile_NetSync_SetNewTarget final
{
public:
	class AActor*                                 NewTargetActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NewSourceLocation;                                 // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NewTargetLocation;                                 // 0x0014(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UserStateID;                                       // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSyncClientToServerPosAndVel;                      // 0x0024(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionProjectile_NetSync_SetNewTarget) == 0x000008, "Wrong alignment on OrionProjectile_NetSync_SetNewTarget");
static_assert(sizeof(OrionProjectile_NetSync_SetNewTarget) == 0x000028, "Wrong size on OrionProjectile_NetSync_SetNewTarget");
static_assert(offsetof(OrionProjectile_NetSync_SetNewTarget, NewTargetActor) == 0x000000, "Member 'OrionProjectile_NetSync_SetNewTarget::NewTargetActor' has a wrong offset!");
static_assert(offsetof(OrionProjectile_NetSync_SetNewTarget, NewSourceLocation) == 0x000008, "Member 'OrionProjectile_NetSync_SetNewTarget::NewSourceLocation' has a wrong offset!");
static_assert(offsetof(OrionProjectile_NetSync_SetNewTarget, NewTargetLocation) == 0x000014, "Member 'OrionProjectile_NetSync_SetNewTarget::NewTargetLocation' has a wrong offset!");
static_assert(offsetof(OrionProjectile_NetSync_SetNewTarget, UserStateID) == 0x000020, "Member 'OrionProjectile_NetSync_SetNewTarget::UserStateID' has a wrong offset!");
static_assert(offsetof(OrionProjectile_NetSync_SetNewTarget, bSyncClientToServerPosAndVel) == 0x000024, "Member 'OrionProjectile_NetSync_SetNewTarget::bSyncClientToServerPosAndVel' has a wrong offset!");

// Function OrionGame.OrionProjectile.NetSync_WorldCollision
// 0x00A0 (0x00A0 - 0x0000)
struct OrionProjectile_NetSync_WorldCollision final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                ImpactVelocity;                                    // 0x0088(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InWorldCollisionCount;                             // 0x0094(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSyncClientToServerPosAndVel;                      // 0x0098(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionProjectile_NetSync_WorldCollision) == 0x000008, "Wrong alignment on OrionProjectile_NetSync_WorldCollision");
static_assert(sizeof(OrionProjectile_NetSync_WorldCollision) == 0x0000A0, "Wrong size on OrionProjectile_NetSync_WorldCollision");
static_assert(offsetof(OrionProjectile_NetSync_WorldCollision, Hit) == 0x000000, "Member 'OrionProjectile_NetSync_WorldCollision::Hit' has a wrong offset!");
static_assert(offsetof(OrionProjectile_NetSync_WorldCollision, ImpactVelocity) == 0x000088, "Member 'OrionProjectile_NetSync_WorldCollision::ImpactVelocity' has a wrong offset!");
static_assert(offsetof(OrionProjectile_NetSync_WorldCollision, InWorldCollisionCount) == 0x000094, "Member 'OrionProjectile_NetSync_WorldCollision::InWorldCollisionCount' has a wrong offset!");
static_assert(offsetof(OrionProjectile_NetSync_WorldCollision, bSyncClientToServerPosAndVel) == 0x000098, "Member 'OrionProjectile_NetSync_WorldCollision::bSyncClientToServerPosAndVel' has a wrong offset!");

// Function OrionGame.OrionProjectile.OnActorDestroy
// 0x0008 (0x0008 - 0x0000)
struct OrionProjectile_OnActorDestroy final
{
public:
	class AActor*                                 DestroyedActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjectile_OnActorDestroy) == 0x000008, "Wrong alignment on OrionProjectile_OnActorDestroy");
static_assert(sizeof(OrionProjectile_OnActorDestroy) == 0x000008, "Wrong size on OrionProjectile_OnActorDestroy");
static_assert(offsetof(OrionProjectile_OnActorDestroy, DestroyedActor) == 0x000000, "Member 'OrionProjectile_OnActorDestroy::DestroyedActor' has a wrong offset!");

// Function OrionGame.OrionProjectile.OnBounce
// 0x0088 (0x0088 - 0x0000)
struct OrionProjectile_OnBounce final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjectile_OnBounce) == 0x000008, "Wrong alignment on OrionProjectile_OnBounce");
static_assert(sizeof(OrionProjectile_OnBounce) == 0x000088, "Wrong size on OrionProjectile_OnBounce");
static_assert(offsetof(OrionProjectile_OnBounce, Hit) == 0x000000, "Member 'OrionProjectile_OnBounce::Hit' has a wrong offset!");

// Function OrionGame.OrionProjectile.OnBounceCallback
// 0x0098 (0x0098 - 0x0000)
struct OrionProjectile_OnBounceCallback final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                ImpactVelocity;                                    // 0x0088(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionProjectile_OnBounceCallback) == 0x000008, "Wrong alignment on OrionProjectile_OnBounceCallback");
static_assert(sizeof(OrionProjectile_OnBounceCallback) == 0x000098, "Wrong size on OrionProjectile_OnBounceCallback");
static_assert(offsetof(OrionProjectile_OnBounceCallback, Hit) == 0x000000, "Member 'OrionProjectile_OnBounceCallback::Hit' has a wrong offset!");
static_assert(offsetof(OrionProjectile_OnBounceCallback, ImpactVelocity) == 0x000088, "Member 'OrionProjectile_OnBounceCallback::ImpactVelocity' has a wrong offset!");

// Function OrionGame.OrionProjectile.OnBounceCallbackInternal
// 0x0098 (0x0098 - 0x0000)
struct OrionProjectile_OnBounceCallbackInternal final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                ImpactVelocity;                                    // 0x0088(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InNewWorldCollisionCount;                          // 0x0094(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjectile_OnBounceCallbackInternal) == 0x000008, "Wrong alignment on OrionProjectile_OnBounceCallbackInternal");
static_assert(sizeof(OrionProjectile_OnBounceCallbackInternal) == 0x000098, "Wrong size on OrionProjectile_OnBounceCallbackInternal");
static_assert(offsetof(OrionProjectile_OnBounceCallbackInternal, Hit) == 0x000000, "Member 'OrionProjectile_OnBounceCallbackInternal::Hit' has a wrong offset!");
static_assert(offsetof(OrionProjectile_OnBounceCallbackInternal, ImpactVelocity) == 0x000088, "Member 'OrionProjectile_OnBounceCallbackInternal::ImpactVelocity' has a wrong offset!");
static_assert(offsetof(OrionProjectile_OnBounceCallbackInternal, InNewWorldCollisionCount) == 0x000094, "Member 'OrionProjectile_OnBounceCallbackInternal::InNewWorldCollisionCount' has a wrong offset!");

// Function OrionGame.OrionProjectile.OnCloned
// 0x0020 (0x0020 - 0x0000)
struct OrionProjectile_OnCloned final
{
public:
	class AActor*                                 InNewInstigator;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InNewSourceActor;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionProjectile*                       SourceProjectile;                                  // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionProjectileMovementComponent*      SourceMovementComponent;                           // 0x0018(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjectile_OnCloned) == 0x000008, "Wrong alignment on OrionProjectile_OnCloned");
static_assert(sizeof(OrionProjectile_OnCloned) == 0x000020, "Wrong size on OrionProjectile_OnCloned");
static_assert(offsetof(OrionProjectile_OnCloned, InNewInstigator) == 0x000000, "Member 'OrionProjectile_OnCloned::InNewInstigator' has a wrong offset!");
static_assert(offsetof(OrionProjectile_OnCloned, InNewSourceActor) == 0x000008, "Member 'OrionProjectile_OnCloned::InNewSourceActor' has a wrong offset!");
static_assert(offsetof(OrionProjectile_OnCloned, SourceProjectile) == 0x000010, "Member 'OrionProjectile_OnCloned::SourceProjectile' has a wrong offset!");
static_assert(offsetof(OrionProjectile_OnCloned, SourceMovementComponent) == 0x000018, "Member 'OrionProjectile_OnCloned::SourceMovementComponent' has a wrong offset!");

// Function OrionGame.OrionProjectile.OnCustomHit
// 0x0090 (0x0090 - 0x0000)
struct OrionProjectile_OnCustomHit final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EProjectileCustomHitResponseType              ProjectileCustomHitResponseType;                   // 0x0088(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConsumeEvent;                                     // 0x0089(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConsumeDestroy;                                   // 0x008A(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8B[0x5];                                       // 0x008B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionProjectile_OnCustomHit) == 0x000008, "Wrong alignment on OrionProjectile_OnCustomHit");
static_assert(sizeof(OrionProjectile_OnCustomHit) == 0x000090, "Wrong size on OrionProjectile_OnCustomHit");
static_assert(offsetof(OrionProjectile_OnCustomHit, Hit) == 0x000000, "Member 'OrionProjectile_OnCustomHit::Hit' has a wrong offset!");
static_assert(offsetof(OrionProjectile_OnCustomHit, ProjectileCustomHitResponseType) == 0x000088, "Member 'OrionProjectile_OnCustomHit::ProjectileCustomHitResponseType' has a wrong offset!");
static_assert(offsetof(OrionProjectile_OnCustomHit, bConsumeEvent) == 0x000089, "Member 'OrionProjectile_OnCustomHit::bConsumeEvent' has a wrong offset!");
static_assert(offsetof(OrionProjectile_OnCustomHit, bConsumeDestroy) == 0x00008A, "Member 'OrionProjectile_OnCustomHit::bConsumeDestroy' has a wrong offset!");

// Function OrionGame.OrionProjectile.OnExplode
// 0x0010 (0x0010 - 0x0000)
struct OrionProjectile_OnExplode final
{
public:
	TArray<class AActor*>                         EffectedActors;                                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjectile_OnExplode) == 0x000008, "Wrong alignment on OrionProjectile_OnExplode");
static_assert(sizeof(OrionProjectile_OnExplode) == 0x000010, "Wrong size on OrionProjectile_OnExplode");
static_assert(offsetof(OrionProjectile_OnExplode, EffectedActors) == 0x000000, "Member 'OrionProjectile_OnExplode::EffectedActors' has a wrong offset!");

// Function OrionGame.OrionProjectile.OnHitActor
// 0x0088 (0x0088 - 0x0000)
struct OrionProjectile_OnHitActor final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjectile_OnHitActor) == 0x000008, "Wrong alignment on OrionProjectile_OnHitActor");
static_assert(sizeof(OrionProjectile_OnHitActor) == 0x000088, "Wrong size on OrionProjectile_OnHitActor");
static_assert(offsetof(OrionProjectile_OnHitActor, Hit) == 0x000000, "Member 'OrionProjectile_OnHitActor::Hit' has a wrong offset!");

// Function OrionGame.OrionProjectile.OnNetSync_HitActor
// 0x0090 (0x0090 - 0x0000)
struct OrionProjectile_OnNetSync_HitActor final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x0088)(Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         UserStateID;                                       // 0x0088(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionProjectile_OnNetSync_HitActor) == 0x000008, "Wrong alignment on OrionProjectile_OnNetSync_HitActor");
static_assert(sizeof(OrionProjectile_OnNetSync_HitActor) == 0x000090, "Wrong size on OrionProjectile_OnNetSync_HitActor");
static_assert(offsetof(OrionProjectile_OnNetSync_HitActor, Hit) == 0x000000, "Member 'OrionProjectile_OnNetSync_HitActor::Hit' has a wrong offset!");
static_assert(offsetof(OrionProjectile_OnNetSync_HitActor, UserStateID) == 0x000088, "Member 'OrionProjectile_OnNetSync_HitActor::UserStateID' has a wrong offset!");

// Function OrionGame.OrionProjectile.OnNetSync_SetNewTarget
// 0x0028 (0x0028 - 0x0000)
struct OrionProjectile_OnNetSync_SetNewTarget final
{
public:
	class AActor*                                 NewTargetActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NewSourceLocation;                                 // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NewTargetLocation;                                 // 0x0014(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UserStateID;                                       // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionProjectile_OnNetSync_SetNewTarget) == 0x000008, "Wrong alignment on OrionProjectile_OnNetSync_SetNewTarget");
static_assert(sizeof(OrionProjectile_OnNetSync_SetNewTarget) == 0x000028, "Wrong size on OrionProjectile_OnNetSync_SetNewTarget");
static_assert(offsetof(OrionProjectile_OnNetSync_SetNewTarget, NewTargetActor) == 0x000000, "Member 'OrionProjectile_OnNetSync_SetNewTarget::NewTargetActor' has a wrong offset!");
static_assert(offsetof(OrionProjectile_OnNetSync_SetNewTarget, NewSourceLocation) == 0x000008, "Member 'OrionProjectile_OnNetSync_SetNewTarget::NewSourceLocation' has a wrong offset!");
static_assert(offsetof(OrionProjectile_OnNetSync_SetNewTarget, NewTargetLocation) == 0x000014, "Member 'OrionProjectile_OnNetSync_SetNewTarget::NewTargetLocation' has a wrong offset!");
static_assert(offsetof(OrionProjectile_OnNetSync_SetNewTarget, UserStateID) == 0x000020, "Member 'OrionProjectile_OnNetSync_SetNewTarget::UserStateID' has a wrong offset!");

// Function OrionGame.OrionProjectile.OnNetSync_WorldCollision
// 0x00A0 (0x00A0 - 0x0000)
struct OrionProjectile_OnNetSync_WorldCollision final
{
public:
	int32                                         InWorldCollisionCount;                             // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             Hit;                                               // 0x0008(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                ImpactVelocity;                                    // 0x0090(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionProjectile_OnNetSync_WorldCollision) == 0x000008, "Wrong alignment on OrionProjectile_OnNetSync_WorldCollision");
static_assert(sizeof(OrionProjectile_OnNetSync_WorldCollision) == 0x0000A0, "Wrong size on OrionProjectile_OnNetSync_WorldCollision");
static_assert(offsetof(OrionProjectile_OnNetSync_WorldCollision, InWorldCollisionCount) == 0x000000, "Member 'OrionProjectile_OnNetSync_WorldCollision::InWorldCollisionCount' has a wrong offset!");
static_assert(offsetof(OrionProjectile_OnNetSync_WorldCollision, Hit) == 0x000008, "Member 'OrionProjectile_OnNetSync_WorldCollision::Hit' has a wrong offset!");
static_assert(offsetof(OrionProjectile_OnNetSync_WorldCollision, ImpactVelocity) == 0x000090, "Member 'OrionProjectile_OnNetSync_WorldCollision::ImpactVelocity' has a wrong offset!");

// Function OrionGame.OrionProjectile.OnOverlapCallback
// 0x00A8 (0x00A8 - 0x0000)
struct OrionProjectile_OnOverlapCallback final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjectile_OnOverlapCallback) == 0x000008, "Wrong alignment on OrionProjectile_OnOverlapCallback");
static_assert(sizeof(OrionProjectile_OnOverlapCallback) == 0x0000A8, "Wrong size on OrionProjectile_OnOverlapCallback");
static_assert(offsetof(OrionProjectile_OnOverlapCallback, OverlappedComp) == 0x000000, "Member 'OrionProjectile_OnOverlapCallback::OverlappedComp' has a wrong offset!");
static_assert(offsetof(OrionProjectile_OnOverlapCallback, OtherActor) == 0x000008, "Member 'OrionProjectile_OnOverlapCallback::OtherActor' has a wrong offset!");
static_assert(offsetof(OrionProjectile_OnOverlapCallback, OtherComp) == 0x000010, "Member 'OrionProjectile_OnOverlapCallback::OtherComp' has a wrong offset!");
static_assert(offsetof(OrionProjectile_OnOverlapCallback, OtherBodyIndex) == 0x000018, "Member 'OrionProjectile_OnOverlapCallback::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(OrionProjectile_OnOverlapCallback, bFromSweep) == 0x00001C, "Member 'OrionProjectile_OnOverlapCallback::bFromSweep' has a wrong offset!");
static_assert(offsetof(OrionProjectile_OnOverlapCallback, SweepResult) == 0x000020, "Member 'OrionProjectile_OnOverlapCallback::SweepResult' has a wrong offset!");

// Function OrionGame.OrionProjectile.OnOverlappedLockOnActor
// 0x0008 (0x0008 - 0x0000)
struct OrionProjectile_OnOverlappedLockOnActor final
{
public:
	class AActor*                                 PreviousLockOnActor;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjectile_OnOverlappedLockOnActor) == 0x000008, "Wrong alignment on OrionProjectile_OnOverlappedLockOnActor");
static_assert(sizeof(OrionProjectile_OnOverlappedLockOnActor) == 0x000008, "Wrong size on OrionProjectile_OnOverlappedLockOnActor");
static_assert(offsetof(OrionProjectile_OnOverlappedLockOnActor, PreviousLockOnActor) == 0x000000, "Member 'OrionProjectile_OnOverlappedLockOnActor::PreviousLockOnActor' has a wrong offset!");

// Function OrionGame.OrionProjectile.OnStop
// 0x0088 (0x0088 - 0x0000)
struct OrionProjectile_OnStop final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjectile_OnStop) == 0x000008, "Wrong alignment on OrionProjectile_OnStop");
static_assert(sizeof(OrionProjectile_OnStop) == 0x000088, "Wrong size on OrionProjectile_OnStop");
static_assert(offsetof(OrionProjectile_OnStop, Hit) == 0x000000, "Member 'OrionProjectile_OnStop::Hit' has a wrong offset!");

// Function OrionGame.OrionProjectile.OnStopCallback
// 0x0088 (0x0088 - 0x0000)
struct OrionProjectile_OnStopCallback final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjectile_OnStopCallback) == 0x000008, "Wrong alignment on OrionProjectile_OnStopCallback");
static_assert(sizeof(OrionProjectile_OnStopCallback) == 0x000088, "Wrong size on OrionProjectile_OnStopCallback");
static_assert(offsetof(OrionProjectile_OnStopCallback, Hit) == 0x000000, "Member 'OrionProjectile_OnStopCallback::Hit' has a wrong offset!");

// DelegateFunction OrionGame.OrionProjectile.ProjectileHitDelegate__DelegateSignature
// 0x0088 (0x0088 - 0x0000)
struct OrionProjectile_ProjectileHitDelegate__DelegateSignature final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjectile_ProjectileHitDelegate__DelegateSignature) == 0x000008, "Wrong alignment on OrionProjectile_ProjectileHitDelegate__DelegateSignature");
static_assert(sizeof(OrionProjectile_ProjectileHitDelegate__DelegateSignature) == 0x000088, "Wrong size on OrionProjectile_ProjectileHitDelegate__DelegateSignature");
static_assert(offsetof(OrionProjectile_ProjectileHitDelegate__DelegateSignature, HitResult) == 0x000000, "Member 'OrionProjectile_ProjectileHitDelegate__DelegateSignature::HitResult' has a wrong offset!");

// Function OrionGame.OrionProjectile.RemoveGameplayCueLocal
// 0x00C0 (0x00C0 - 0x0000)
struct OrionProjectile_RemoveGameplayCueLocal final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 Parameters;                                        // 0x0008(0x00B8)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjectile_RemoveGameplayCueLocal) == 0x000008, "Wrong alignment on OrionProjectile_RemoveGameplayCueLocal");
static_assert(sizeof(OrionProjectile_RemoveGameplayCueLocal) == 0x0000C0, "Wrong size on OrionProjectile_RemoveGameplayCueLocal");
static_assert(offsetof(OrionProjectile_RemoveGameplayCueLocal, GameplayCueTag) == 0x000000, "Member 'OrionProjectile_RemoveGameplayCueLocal::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(OrionProjectile_RemoveGameplayCueLocal, Parameters) == 0x000008, "Member 'OrionProjectile_RemoveGameplayCueLocal::Parameters' has a wrong offset!");

// Function OrionGame.OrionProjectile.SetAutoDestroyTime
// 0x0004 (0x0004 - 0x0000)
struct OrionProjectile_SetAutoDestroyTime final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjectile_SetAutoDestroyTime) == 0x000004, "Wrong alignment on OrionProjectile_SetAutoDestroyTime");
static_assert(sizeof(OrionProjectile_SetAutoDestroyTime) == 0x000004, "Wrong size on OrionProjectile_SetAutoDestroyTime");
static_assert(offsetof(OrionProjectile_SetAutoDestroyTime, Time) == 0x000000, "Member 'OrionProjectile_SetAutoDestroyTime::Time' has a wrong offset!");

// Function OrionGame.OrionProjectile.SetExplosionFilterAndEffectsContainer
// 0x0020 (0x0020 - 0x0000)
struct OrionProjectile_SetExplosionFilterAndEffectsContainer final
{
public:
	struct FOrionFilterAndEffectsContainer        NewFilterContainer;                                // 0x0000(0x0020)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjectile_SetExplosionFilterAndEffectsContainer) == 0x000008, "Wrong alignment on OrionProjectile_SetExplosionFilterAndEffectsContainer");
static_assert(sizeof(OrionProjectile_SetExplosionFilterAndEffectsContainer) == 0x000020, "Wrong size on OrionProjectile_SetExplosionFilterAndEffectsContainer");
static_assert(offsetof(OrionProjectile_SetExplosionFilterAndEffectsContainer, NewFilterContainer) == 0x000000, "Member 'OrionProjectile_SetExplosionFilterAndEffectsContainer::NewFilterContainer' has a wrong offset!");

// Function OrionGame.OrionProjectile.SetHitFilterAndEffectsContainter
// 0x0020 (0x0020 - 0x0000)
struct OrionProjectile_SetHitFilterAndEffectsContainter final
{
public:
	struct FOrionFilterAndEffectsContainer        NewFilterContainer;                                // 0x0000(0x0020)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjectile_SetHitFilterAndEffectsContainter) == 0x000008, "Wrong alignment on OrionProjectile_SetHitFilterAndEffectsContainter");
static_assert(sizeof(OrionProjectile_SetHitFilterAndEffectsContainter) == 0x000020, "Wrong size on OrionProjectile_SetHitFilterAndEffectsContainter");
static_assert(offsetof(OrionProjectile_SetHitFilterAndEffectsContainter, NewFilterContainer) == 0x000000, "Member 'OrionProjectile_SetHitFilterAndEffectsContainter::NewFilterContainer' has a wrong offset!");

// Function OrionGame.OrionProjectile.SetLockOnActor
// 0x0018 (0x0018 - 0x0000)
struct OrionProjectile_SetLockOnActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InHomingOffset;                                    // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionProjectile_SetLockOnActor) == 0x000008, "Wrong alignment on OrionProjectile_SetLockOnActor");
static_assert(sizeof(OrionProjectile_SetLockOnActor) == 0x000018, "Wrong size on OrionProjectile_SetLockOnActor");
static_assert(offsetof(OrionProjectile_SetLockOnActor, Actor) == 0x000000, "Member 'OrionProjectile_SetLockOnActor::Actor' has a wrong offset!");
static_assert(offsetof(OrionProjectile_SetLockOnActor, InHomingOffset) == 0x000008, "Member 'OrionProjectile_SetLockOnActor::InHomingOffset' has a wrong offset!");

// Function OrionGame.OrionProjectile.SetNotifyRange
// 0x0004 (0x0004 - 0x0000)
struct OrionProjectile_SetNotifyRange final
{
public:
	float                                         Range_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjectile_SetNotifyRange) == 0x000004, "Wrong alignment on OrionProjectile_SetNotifyRange");
static_assert(sizeof(OrionProjectile_SetNotifyRange) == 0x000004, "Wrong size on OrionProjectile_SetNotifyRange");
static_assert(offsetof(OrionProjectile_SetNotifyRange, Range_0) == 0x000000, "Member 'OrionProjectile_SetNotifyRange::Range_0' has a wrong offset!");

// Function OrionGame.OrionProjectile.SetNotifyTime
// 0x0004 (0x0004 - 0x0000)
struct OrionProjectile_SetNotifyTime final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjectile_SetNotifyTime) == 0x000004, "Wrong alignment on OrionProjectile_SetNotifyTime");
static_assert(sizeof(OrionProjectile_SetNotifyTime) == 0x000004, "Wrong size on OrionProjectile_SetNotifyTime");
static_assert(offsetof(OrionProjectile_SetNotifyTime, Time) == 0x000000, "Member 'OrionProjectile_SetNotifyTime::Time' has a wrong offset!");

// Function OrionGame.OrionProjectile.SetTargetingTagRequirements
// 0x0040 (0x0040 - 0x0000)
struct OrionProjectile_SetTargetingTagRequirements final
{
public:
	struct FGameplayTagRequirements               InTargetingTagRequirements;                        // 0x0000(0x0040)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjectile_SetTargetingTagRequirements) == 0x000008, "Wrong alignment on OrionProjectile_SetTargetingTagRequirements");
static_assert(sizeof(OrionProjectile_SetTargetingTagRequirements) == 0x000040, "Wrong size on OrionProjectile_SetTargetingTagRequirements");
static_assert(offsetof(OrionProjectile_SetTargetingTagRequirements, InTargetingTagRequirements) == 0x000000, "Member 'OrionProjectile_SetTargetingTagRequirements::InTargetingTagRequirements' has a wrong offset!");

// Function OrionGame.OrionProjectile.StartTimeDilation
// 0x0018 (0x0018 - 0x0000)
struct OrionProjectile_StartTimeDilation final
{
public:
	int32                                         WhichDilationChannel;                              // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetDilation;                                    // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpInSeconds;                                     // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpOutSeconds;                                    // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Opt_StartDilation;                                 // 0x0014(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjectile_StartTimeDilation) == 0x000004, "Wrong alignment on OrionProjectile_StartTimeDilation");
static_assert(sizeof(OrionProjectile_StartTimeDilation) == 0x000018, "Wrong size on OrionProjectile_StartTimeDilation");
static_assert(offsetof(OrionProjectile_StartTimeDilation, WhichDilationChannel) == 0x000000, "Member 'OrionProjectile_StartTimeDilation::WhichDilationChannel' has a wrong offset!");
static_assert(offsetof(OrionProjectile_StartTimeDilation, TargetDilation) == 0x000004, "Member 'OrionProjectile_StartTimeDilation::TargetDilation' has a wrong offset!");
static_assert(offsetof(OrionProjectile_StartTimeDilation, LerpInSeconds) == 0x000008, "Member 'OrionProjectile_StartTimeDilation::LerpInSeconds' has a wrong offset!");
static_assert(offsetof(OrionProjectile_StartTimeDilation, Duration) == 0x00000C, "Member 'OrionProjectile_StartTimeDilation::Duration' has a wrong offset!");
static_assert(offsetof(OrionProjectile_StartTimeDilation, LerpOutSeconds) == 0x000010, "Member 'OrionProjectile_StartTimeDilation::LerpOutSeconds' has a wrong offset!");
static_assert(offsetof(OrionProjectile_StartTimeDilation, Opt_StartDilation) == 0x000014, "Member 'OrionProjectile_StartTimeDilation::Opt_StartDilation' has a wrong offset!");

// Function OrionGame.OrionProjectile.SyncHitActor
// 0x00A8 (0x00A8 - 0x0000)
struct OrionProjectile_SyncHitActor final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x0088)(Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         UserStateID;                                       // 0x0088(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ServerPosition;                                    // 0x008C(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ServerVelocity;                                    // 0x0098(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionProjectile_SyncHitActor) == 0x000008, "Wrong alignment on OrionProjectile_SyncHitActor");
static_assert(sizeof(OrionProjectile_SyncHitActor) == 0x0000A8, "Wrong size on OrionProjectile_SyncHitActor");
static_assert(offsetof(OrionProjectile_SyncHitActor, Hit) == 0x000000, "Member 'OrionProjectile_SyncHitActor::Hit' has a wrong offset!");
static_assert(offsetof(OrionProjectile_SyncHitActor, UserStateID) == 0x000088, "Member 'OrionProjectile_SyncHitActor::UserStateID' has a wrong offset!");
static_assert(offsetof(OrionProjectile_SyncHitActor, ServerPosition) == 0x00008C, "Member 'OrionProjectile_SyncHitActor::ServerPosition' has a wrong offset!");
static_assert(offsetof(OrionProjectile_SyncHitActor, ServerVelocity) == 0x000098, "Member 'OrionProjectile_SyncHitActor::ServerVelocity' has a wrong offset!");

// Function OrionGame.OrionProjectile.SyncSetNewTarget
// 0x0040 (0x0040 - 0x0000)
struct OrionProjectile_SyncSetNewTarget final
{
public:
	class AActor*                                 NewTargetActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NewSourceLocation;                                 // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NewTargetLocation;                                 // 0x0014(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UserStateID;                                       // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ServerPosition;                                    // 0x0024(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ServerVelocity;                                    // 0x0030(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionProjectile_SyncSetNewTarget) == 0x000008, "Wrong alignment on OrionProjectile_SyncSetNewTarget");
static_assert(sizeof(OrionProjectile_SyncSetNewTarget) == 0x000040, "Wrong size on OrionProjectile_SyncSetNewTarget");
static_assert(offsetof(OrionProjectile_SyncSetNewTarget, NewTargetActor) == 0x000000, "Member 'OrionProjectile_SyncSetNewTarget::NewTargetActor' has a wrong offset!");
static_assert(offsetof(OrionProjectile_SyncSetNewTarget, NewSourceLocation) == 0x000008, "Member 'OrionProjectile_SyncSetNewTarget::NewSourceLocation' has a wrong offset!");
static_assert(offsetof(OrionProjectile_SyncSetNewTarget, NewTargetLocation) == 0x000014, "Member 'OrionProjectile_SyncSetNewTarget::NewTargetLocation' has a wrong offset!");
static_assert(offsetof(OrionProjectile_SyncSetNewTarget, UserStateID) == 0x000020, "Member 'OrionProjectile_SyncSetNewTarget::UserStateID' has a wrong offset!");
static_assert(offsetof(OrionProjectile_SyncSetNewTarget, ServerPosition) == 0x000024, "Member 'OrionProjectile_SyncSetNewTarget::ServerPosition' has a wrong offset!");
static_assert(offsetof(OrionProjectile_SyncSetNewTarget, ServerVelocity) == 0x000030, "Member 'OrionProjectile_SyncSetNewTarget::ServerVelocity' has a wrong offset!");

// Function OrionGame.OrionProjectile.SyncStartTimeDilation
// 0x0030 (0x0030 - 0x0000)
struct OrionProjectile_SyncStartTimeDilation final
{
public:
	struct FVector                                ServerPosition;                                    // 0x0000(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ServerVelocity;                                    // 0x000C(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WhichDilationChannel;                              // 0x0018(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetDilation;                                    // 0x001C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpInSeconds;                                     // 0x0020(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0024(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpOutSeconds;                                    // 0x0028(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Opt_StartDilation;                                 // 0x002C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjectile_SyncStartTimeDilation) == 0x000004, "Wrong alignment on OrionProjectile_SyncStartTimeDilation");
static_assert(sizeof(OrionProjectile_SyncStartTimeDilation) == 0x000030, "Wrong size on OrionProjectile_SyncStartTimeDilation");
static_assert(offsetof(OrionProjectile_SyncStartTimeDilation, ServerPosition) == 0x000000, "Member 'OrionProjectile_SyncStartTimeDilation::ServerPosition' has a wrong offset!");
static_assert(offsetof(OrionProjectile_SyncStartTimeDilation, ServerVelocity) == 0x00000C, "Member 'OrionProjectile_SyncStartTimeDilation::ServerVelocity' has a wrong offset!");
static_assert(offsetof(OrionProjectile_SyncStartTimeDilation, WhichDilationChannel) == 0x000018, "Member 'OrionProjectile_SyncStartTimeDilation::WhichDilationChannel' has a wrong offset!");
static_assert(offsetof(OrionProjectile_SyncStartTimeDilation, TargetDilation) == 0x00001C, "Member 'OrionProjectile_SyncStartTimeDilation::TargetDilation' has a wrong offset!");
static_assert(offsetof(OrionProjectile_SyncStartTimeDilation, LerpInSeconds) == 0x000020, "Member 'OrionProjectile_SyncStartTimeDilation::LerpInSeconds' has a wrong offset!");
static_assert(offsetof(OrionProjectile_SyncStartTimeDilation, Duration) == 0x000024, "Member 'OrionProjectile_SyncStartTimeDilation::Duration' has a wrong offset!");
static_assert(offsetof(OrionProjectile_SyncStartTimeDilation, LerpOutSeconds) == 0x000028, "Member 'OrionProjectile_SyncStartTimeDilation::LerpOutSeconds' has a wrong offset!");
static_assert(offsetof(OrionProjectile_SyncStartTimeDilation, Opt_StartDilation) == 0x00002C, "Member 'OrionProjectile_SyncStartTimeDilation::Opt_StartDilation' has a wrong offset!");

// Function OrionGame.OrionProjectile.SyncTimeDilationArrivedAtTarget
// 0x001C (0x001C - 0x0000)
struct OrionProjectile_SyncTimeDilationArrivedAtTarget final
{
public:
	int32                                         WhichDilationChannel;                              // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ServerPosition;                                    // 0x0004(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ServerVelocity;                                    // 0x0010(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjectile_SyncTimeDilationArrivedAtTarget) == 0x000004, "Wrong alignment on OrionProjectile_SyncTimeDilationArrivedAtTarget");
static_assert(sizeof(OrionProjectile_SyncTimeDilationArrivedAtTarget) == 0x00001C, "Wrong size on OrionProjectile_SyncTimeDilationArrivedAtTarget");
static_assert(offsetof(OrionProjectile_SyncTimeDilationArrivedAtTarget, WhichDilationChannel) == 0x000000, "Member 'OrionProjectile_SyncTimeDilationArrivedAtTarget::WhichDilationChannel' has a wrong offset!");
static_assert(offsetof(OrionProjectile_SyncTimeDilationArrivedAtTarget, ServerPosition) == 0x000004, "Member 'OrionProjectile_SyncTimeDilationArrivedAtTarget::ServerPosition' has a wrong offset!");
static_assert(offsetof(OrionProjectile_SyncTimeDilationArrivedAtTarget, ServerVelocity) == 0x000010, "Member 'OrionProjectile_SyncTimeDilationArrivedAtTarget::ServerVelocity' has a wrong offset!");

// Function OrionGame.OrionProjectile.SyncWorldCollision
// 0x00B0 (0x00B0 - 0x0000)
struct OrionProjectile_SyncWorldCollision final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x0088)(ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                ImpactVelocity;                                    // 0x0088(0x000C)(ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InWorldCollisionCount;                             // 0x0094(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ServerPosition;                                    // 0x0098(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ServerVelocity;                                    // 0x00A4(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjectile_SyncWorldCollision) == 0x000008, "Wrong alignment on OrionProjectile_SyncWorldCollision");
static_assert(sizeof(OrionProjectile_SyncWorldCollision) == 0x0000B0, "Wrong size on OrionProjectile_SyncWorldCollision");
static_assert(offsetof(OrionProjectile_SyncWorldCollision, Hit) == 0x000000, "Member 'OrionProjectile_SyncWorldCollision::Hit' has a wrong offset!");
static_assert(offsetof(OrionProjectile_SyncWorldCollision, ImpactVelocity) == 0x000088, "Member 'OrionProjectile_SyncWorldCollision::ImpactVelocity' has a wrong offset!");
static_assert(offsetof(OrionProjectile_SyncWorldCollision, InWorldCollisionCount) == 0x000094, "Member 'OrionProjectile_SyncWorldCollision::InWorldCollisionCount' has a wrong offset!");
static_assert(offsetof(OrionProjectile_SyncWorldCollision, ServerPosition) == 0x000098, "Member 'OrionProjectile_SyncWorldCollision::ServerPosition' has a wrong offset!");
static_assert(offsetof(OrionProjectile_SyncWorldCollision, ServerVelocity) == 0x0000A4, "Member 'OrionProjectile_SyncWorldCollision::ServerVelocity' has a wrong offset!");

// Function OrionGame.OrionProjectile.GetNotifyRange
// 0x0004 (0x0004 - 0x0000)
struct OrionProjectile_GetNotifyRange final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjectile_GetNotifyRange) == 0x000004, "Wrong alignment on OrionProjectile_GetNotifyRange");
static_assert(sizeof(OrionProjectile_GetNotifyRange) == 0x000004, "Wrong size on OrionProjectile_GetNotifyRange");
static_assert(offsetof(OrionProjectile_GetNotifyRange, ReturnValue) == 0x000000, "Member 'OrionProjectile_GetNotifyRange::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionProjectile.GetTeamNum
// 0x0001 (0x0001 - 0x0000)
struct OrionProjectile_GetTeamNum final
{
public:
	EOrionTeam                                    ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjectile_GetTeamNum) == 0x000001, "Wrong alignment on OrionProjectile_GetTeamNum");
static_assert(sizeof(OrionProjectile_GetTeamNum) == 0x000001, "Wrong size on OrionProjectile_GetTeamNum");
static_assert(offsetof(OrionProjectile_GetTeamNum, ReturnValue) == 0x000000, "Member 'OrionProjectile_GetTeamNum::ReturnValue' has a wrong offset!");

// Function OrionGame.MessageOfTheDay.GetMessageOfTheDay
// 0x0008 (0x0008 - 0x0000)
struct MessageOfTheDay_GetMessageOfTheDay final
{
public:
	class UMessageOfTheDay*                       ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MessageOfTheDay_GetMessageOfTheDay) == 0x000008, "Wrong alignment on MessageOfTheDay_GetMessageOfTheDay");
static_assert(sizeof(MessageOfTheDay_GetMessageOfTheDay) == 0x000008, "Wrong size on MessageOfTheDay_GetMessageOfTheDay");
static_assert(offsetof(MessageOfTheDay_GetMessageOfTheDay, ReturnValue) == 0x000000, "Member 'MessageOfTheDay_GetMessageOfTheDay::ReturnValue' has a wrong offset!");

// Function OrionGame.MessageOfTheDay.ShouldShowMOTD
// 0x0001 (0x0001 - 0x0000)
struct MessageOfTheDay_ShouldShowMOTD final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MessageOfTheDay_ShouldShowMOTD) == 0x000001, "Wrong alignment on MessageOfTheDay_ShouldShowMOTD");
static_assert(sizeof(MessageOfTheDay_ShouldShowMOTD) == 0x000001, "Wrong size on MessageOfTheDay_ShouldShowMOTD");
static_assert(offsetof(MessageOfTheDay_ShouldShowMOTD, ReturnValue) == 0x000000, "Member 'MessageOfTheDay_ShouldShowMOTD::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbility.BeginAura
// 0x0078 (0x0078 - 0x0000)
struct OrionAbility_BeginAura final
{
public:
	struct FOrionFilterAndEffectsContainer        FilterAndEffectsContainers;                        // 0x0000(0x0020)(Parm, NativeAccessSpecifierPublic)
	struct FOrionFilterAndEffectsContainer        PeriodicFilterAndEffectsContainers;                // 0x0020(0x0020)(Parm, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         Period;                                            // 0x0048(0x0028)(Parm, NativeAccessSpecifierPublic)
	bool                                          ReapplyEffectOnRemoval;                            // 0x0070(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EndWhenAbilityEnds;                                // 0x0071(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x2];                                       // 0x0072(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionAuraHandle                       ReturnValue;                                       // 0x0074(0x0004)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_BeginAura) == 0x000008, "Wrong alignment on OrionAbility_BeginAura");
static_assert(sizeof(OrionAbility_BeginAura) == 0x000078, "Wrong size on OrionAbility_BeginAura");
static_assert(offsetof(OrionAbility_BeginAura, FilterAndEffectsContainers) == 0x000000, "Member 'OrionAbility_BeginAura::FilterAndEffectsContainers' has a wrong offset!");
static_assert(offsetof(OrionAbility_BeginAura, PeriodicFilterAndEffectsContainers) == 0x000020, "Member 'OrionAbility_BeginAura::PeriodicFilterAndEffectsContainers' has a wrong offset!");
static_assert(offsetof(OrionAbility_BeginAura, Radius) == 0x000040, "Member 'OrionAbility_BeginAura::Radius' has a wrong offset!");
static_assert(offsetof(OrionAbility_BeginAura, Period) == 0x000048, "Member 'OrionAbility_BeginAura::Period' has a wrong offset!");
static_assert(offsetof(OrionAbility_BeginAura, ReapplyEffectOnRemoval) == 0x000070, "Member 'OrionAbility_BeginAura::ReapplyEffectOnRemoval' has a wrong offset!");
static_assert(offsetof(OrionAbility_BeginAura, EndWhenAbilityEnds) == 0x000071, "Member 'OrionAbility_BeginAura::EndWhenAbilityEnds' has a wrong offset!");
static_assert(offsetof(OrionAbility_BeginAura, ReturnValue) == 0x000074, "Member 'OrionAbility_BeginAura::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbility.BlockMovementInput
// 0x0001 (0x0001 - 0x0000)
struct OrionAbility_BlockMovementInput final
{
public:
	bool                                          bResetOnDeath;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_BlockMovementInput) == 0x000001, "Wrong alignment on OrionAbility_BlockMovementInput");
static_assert(sizeof(OrionAbility_BlockMovementInput) == 0x000001, "Wrong size on OrionAbility_BlockMovementInput");
static_assert(offsetof(OrionAbility_BlockMovementInput, bResetOnDeath) == 0x000000, "Member 'OrionAbility_BlockMovementInput::bResetOnDeath' has a wrong offset!");

// Function OrionGame.OrionAbility.BP_ApplyGameplayEffectToOwner_Cached
// 0x0010 (0x0010 - 0x0000)
struct OrionAbility_BP_ApplyGameplayEffectToOwner_Cached final
{
public:
	TSubclassOf<class UGameplayEffect>            GameplayEffectClass;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_BP_ApplyGameplayEffectToOwner_Cached) == 0x000008, "Wrong alignment on OrionAbility_BP_ApplyGameplayEffectToOwner_Cached");
static_assert(sizeof(OrionAbility_BP_ApplyGameplayEffectToOwner_Cached) == 0x000010, "Wrong size on OrionAbility_BP_ApplyGameplayEffectToOwner_Cached");
static_assert(offsetof(OrionAbility_BP_ApplyGameplayEffectToOwner_Cached, GameplayEffectClass) == 0x000000, "Member 'OrionAbility_BP_ApplyGameplayEffectToOwner_Cached::GameplayEffectClass' has a wrong offset!");
static_assert(offsetof(OrionAbility_BP_ApplyGameplayEffectToOwner_Cached, ReturnValue) == 0x000008, "Member 'OrionAbility_BP_ApplyGameplayEffectToOwner_Cached::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbility.BP_CommitConsumableStack
// 0x0001 (0x0001 - 0x0000)
struct OrionAbility_BP_CommitConsumableStack final
{
public:
	bool                                          BroadcastCommitEvent;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_BP_CommitConsumableStack) == 0x000001, "Wrong alignment on OrionAbility_BP_CommitConsumableStack");
static_assert(sizeof(OrionAbility_BP_CommitConsumableStack) == 0x000001, "Wrong size on OrionAbility_BP_CommitConsumableStack");
static_assert(offsetof(OrionAbility_BP_CommitConsumableStack, BroadcastCommitEvent) == 0x000000, "Member 'OrionAbility_BP_CommitConsumableStack::BroadcastCommitEvent' has a wrong offset!");

// Function OrionGame.OrionAbility.BP_GetCachedGameplayEffeectSpec
// 0x0020 (0x0020 - 0x0000)
struct OrionAbility_BP_GetCachedGameplayEffeectSpec final
{
public:
	TSubclassOf<class UGameplayEffect>            GameplayEffectClass;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpecHandle              ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_BP_GetCachedGameplayEffeectSpec) == 0x000008, "Wrong alignment on OrionAbility_BP_GetCachedGameplayEffeectSpec");
static_assert(sizeof(OrionAbility_BP_GetCachedGameplayEffeectSpec) == 0x000020, "Wrong size on OrionAbility_BP_GetCachedGameplayEffeectSpec");
static_assert(offsetof(OrionAbility_BP_GetCachedGameplayEffeectSpec, GameplayEffectClass) == 0x000000, "Member 'OrionAbility_BP_GetCachedGameplayEffeectSpec::GameplayEffectClass' has a wrong offset!");
static_assert(offsetof(OrionAbility_BP_GetCachedGameplayEffeectSpec, ReturnValue) == 0x000008, "Member 'OrionAbility_BP_GetCachedGameplayEffeectSpec::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbility.ChangeActivationGroup
// 0x0001 (0x0001 - 0x0000)
struct OrionAbility_ChangeActivationGroup final
{
public:
	EOrionAbilityActivationGroup                  NewGroup;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_ChangeActivationGroup) == 0x000001, "Wrong alignment on OrionAbility_ChangeActivationGroup");
static_assert(sizeof(OrionAbility_ChangeActivationGroup) == 0x000001, "Wrong size on OrionAbility_ChangeActivationGroup");
static_assert(offsetof(OrionAbility_ChangeActivationGroup, NewGroup) == 0x000000, "Member 'OrionAbility_ChangeActivationGroup::NewGroup' has a wrong offset!");

// Function OrionGame.OrionAbility.ClearLookAtActor
// 0x0001 (0x0001 - 0x0000)
struct OrionAbility_ClearLookAtActor final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_ClearLookAtActor) == 0x000001, "Wrong alignment on OrionAbility_ClearLookAtActor");
static_assert(sizeof(OrionAbility_ClearLookAtActor) == 0x000001, "Wrong size on OrionAbility_ClearLookAtActor");
static_assert(offsetof(OrionAbility_ClearLookAtActor, ReturnValue) == 0x000000, "Member 'OrionAbility_ClearLookAtActor::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbility.EndAura
// 0x0004 (0x0004 - 0x0000)
struct OrionAbility_EndAura final
{
public:
	struct FOrionAuraHandle                       Handle;                                            // 0x0000(0x0004)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_EndAura) == 0x000004, "Wrong alignment on OrionAbility_EndAura");
static_assert(sizeof(OrionAbility_EndAura) == 0x000004, "Wrong size on OrionAbility_EndAura");
static_assert(offsetof(OrionAbility_EndAura, Handle) == 0x000000, "Member 'OrionAbility_EndAura::Handle' has a wrong offset!");

// Function OrionGame.OrionAbility.GetExternalAbilityLevel
// 0x0010 (0x0010 - 0x0000)
struct OrionAbility_GetExternalAbilityLevel final
{
public:
	struct FGameplayTag                           AbilityTag;                                        // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionAbility_GetExternalAbilityLevel) == 0x000008, "Wrong alignment on OrionAbility_GetExternalAbilityLevel");
static_assert(sizeof(OrionAbility_GetExternalAbilityLevel) == 0x000010, "Wrong size on OrionAbility_GetExternalAbilityLevel");
static_assert(offsetof(OrionAbility_GetExternalAbilityLevel, AbilityTag) == 0x000000, "Member 'OrionAbility_GetExternalAbilityLevel::AbilityTag' has a wrong offset!");
static_assert(offsetof(OrionAbility_GetExternalAbilityLevel, ReturnValue) == 0x000008, "Member 'OrionAbility_GetExternalAbilityLevel::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbility.GetTargets
// 0x0020 (0x0020 - 0x0000)
struct OrionAbility_GetTargets final
{
public:
	struct FGameplayAbilityTargetDataHandle       ReturnValue;                                       // 0x0000(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_GetTargets) == 0x000008, "Wrong alignment on OrionAbility_GetTargets");
static_assert(sizeof(OrionAbility_GetTargets) == 0x000020, "Wrong size on OrionAbility_GetTargets");
static_assert(offsetof(OrionAbility_GetTargets, ReturnValue) == 0x000000, "Member 'OrionAbility_GetTargets::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbility.InitAndApplyFilterContainerToTargetData
// 0x0070 (0x0070 - 0x0000)
struct OrionAbility_InitAndApplyFilterContainerToTargetData final
{
public:
	struct FOrionFilterAndEffectsContainer        FilterContainer;                                   // 0x0000(0x0020)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0020(0x0020)(Parm, NativeAccessSpecifierPublic)
	TArray<struct FActiveGameplayEffectHandle>    AppliedEffectHandles;                              // 0x0040(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FOrionFilterAndEffectsContainer        ReturnValue;                                       // 0x0050(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_InitAndApplyFilterContainerToTargetData) == 0x000008, "Wrong alignment on OrionAbility_InitAndApplyFilterContainerToTargetData");
static_assert(sizeof(OrionAbility_InitAndApplyFilterContainerToTargetData) == 0x000070, "Wrong size on OrionAbility_InitAndApplyFilterContainerToTargetData");
static_assert(offsetof(OrionAbility_InitAndApplyFilterContainerToTargetData, FilterContainer) == 0x000000, "Member 'OrionAbility_InitAndApplyFilterContainerToTargetData::FilterContainer' has a wrong offset!");
static_assert(offsetof(OrionAbility_InitAndApplyFilterContainerToTargetData, TargetData) == 0x000020, "Member 'OrionAbility_InitAndApplyFilterContainerToTargetData::TargetData' has a wrong offset!");
static_assert(offsetof(OrionAbility_InitAndApplyFilterContainerToTargetData, AppliedEffectHandles) == 0x000040, "Member 'OrionAbility_InitAndApplyFilterContainerToTargetData::AppliedEffectHandles' has a wrong offset!");
static_assert(offsetof(OrionAbility_InitAndApplyFilterContainerToTargetData, ReturnValue) == 0x000050, "Member 'OrionAbility_InitAndApplyFilterContainerToTargetData::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbility.InitFilterAndEffectsContainer
// 0x0040 (0x0040 - 0x0000)
struct OrionAbility_InitFilterAndEffectsContainer final
{
public:
	struct FOrionFilterAndEffectsContainer        FilterContainer;                                   // 0x0000(0x0020)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FOrionFilterAndEffectsContainer        ReturnValue;                                       // 0x0020(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_InitFilterAndEffectsContainer) == 0x000008, "Wrong alignment on OrionAbility_InitFilterAndEffectsContainer");
static_assert(sizeof(OrionAbility_InitFilterAndEffectsContainer) == 0x000040, "Wrong size on OrionAbility_InitFilterAndEffectsContainer");
static_assert(offsetof(OrionAbility_InitFilterAndEffectsContainer, FilterContainer) == 0x000000, "Member 'OrionAbility_InitFilterAndEffectsContainer::FilterContainer' has a wrong offset!");
static_assert(offsetof(OrionAbility_InitFilterAndEffectsContainer, ReturnValue) == 0x000020, "Member 'OrionAbility_InitFilterAndEffectsContainer::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbility.K2_OrionAddGameplayCue
// 0x0028 (0x0028 - 0x0000)
struct OrionAbility_K2_OrionAddGameplayCue final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectContextHandle           Context;                                           // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
	bool                                          bRemoveOnAbilityEnd;                               // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionAbility_K2_OrionAddGameplayCue) == 0x000008, "Wrong alignment on OrionAbility_K2_OrionAddGameplayCue");
static_assert(sizeof(OrionAbility_K2_OrionAddGameplayCue) == 0x000028, "Wrong size on OrionAbility_K2_OrionAddGameplayCue");
static_assert(offsetof(OrionAbility_K2_OrionAddGameplayCue, GameplayCueTag) == 0x000000, "Member 'OrionAbility_K2_OrionAddGameplayCue::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(OrionAbility_K2_OrionAddGameplayCue, Context) == 0x000008, "Member 'OrionAbility_K2_OrionAddGameplayCue::Context' has a wrong offset!");
static_assert(offsetof(OrionAbility_K2_OrionAddGameplayCue, bRemoveOnAbilityEnd) == 0x000020, "Member 'OrionAbility_K2_OrionAddGameplayCue::bRemoveOnAbilityEnd' has a wrong offset!");

// Function OrionGame.OrionAbility.K2_OrionExecuteGameplayCue
// 0x0020 (0x0020 - 0x0000)
struct OrionAbility_K2_OrionExecuteGameplayCue final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectContextHandle           Context;                                           // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_K2_OrionExecuteGameplayCue) == 0x000008, "Wrong alignment on OrionAbility_K2_OrionExecuteGameplayCue");
static_assert(sizeof(OrionAbility_K2_OrionExecuteGameplayCue) == 0x000020, "Wrong size on OrionAbility_K2_OrionExecuteGameplayCue");
static_assert(offsetof(OrionAbility_K2_OrionExecuteGameplayCue, GameplayCueTag) == 0x000000, "Member 'OrionAbility_K2_OrionExecuteGameplayCue::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(OrionAbility_K2_OrionExecuteGameplayCue, Context) == 0x000008, "Member 'OrionAbility_K2_OrionExecuteGameplayCue::Context' has a wrong offset!");

// Function OrionGame.OrionAbility.K2_OrionExecuteGameplayCueWithParams
// 0x00C0 (0x00C0 - 0x0000)
struct OrionAbility_K2_OrionExecuteGameplayCueWithParams final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 GameplayCueParameters;                             // 0x0008(0x00B8)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_K2_OrionExecuteGameplayCueWithParams) == 0x000008, "Wrong alignment on OrionAbility_K2_OrionExecuteGameplayCueWithParams");
static_assert(sizeof(OrionAbility_K2_OrionExecuteGameplayCueWithParams) == 0x0000C0, "Wrong size on OrionAbility_K2_OrionExecuteGameplayCueWithParams");
static_assert(offsetof(OrionAbility_K2_OrionExecuteGameplayCueWithParams, GameplayCueTag) == 0x000000, "Member 'OrionAbility_K2_OrionExecuteGameplayCueWithParams::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(OrionAbility_K2_OrionExecuteGameplayCueWithParams, GameplayCueParameters) == 0x000008, "Member 'OrionAbility_K2_OrionExecuteGameplayCueWithParams::GameplayCueParameters' has a wrong offset!");

// Function OrionGame.OrionAbility.K2_OrionRemoveGameplayCue
// 0x0008 (0x0008 - 0x0000)
struct OrionAbility_K2_OrionRemoveGameplayCue final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_K2_OrionRemoveGameplayCue) == 0x000008, "Wrong alignment on OrionAbility_K2_OrionRemoveGameplayCue");
static_assert(sizeof(OrionAbility_K2_OrionRemoveGameplayCue) == 0x000008, "Wrong size on OrionAbility_K2_OrionRemoveGameplayCue");
static_assert(offsetof(OrionAbility_K2_OrionRemoveGameplayCue, GameplayCueTag) == 0x000000, "Member 'OrionAbility_K2_OrionRemoveGameplayCue::GameplayCueTag' has a wrong offset!");

// Function OrionGame.OrionAbility.K2_SetUseFixedSkeletalBounds
// 0x0001 (0x0001 - 0x0000)
struct OrionAbility_K2_SetUseFixedSkeletalBounds final
{
public:
	bool                                          UseFixedSkeletalBounds;                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_K2_SetUseFixedSkeletalBounds) == 0x000001, "Wrong alignment on OrionAbility_K2_SetUseFixedSkeletalBounds");
static_assert(sizeof(OrionAbility_K2_SetUseFixedSkeletalBounds) == 0x000001, "Wrong size on OrionAbility_K2_SetUseFixedSkeletalBounds");
static_assert(offsetof(OrionAbility_K2_SetUseFixedSkeletalBounds, UseFixedSkeletalBounds) == 0x000000, "Member 'OrionAbility_K2_SetUseFixedSkeletalBounds::UseFixedSkeletalBounds' has a wrong offset!");

// Function OrionGame.OrionAbility.LockCameraRotation
// 0x0001 (0x0001 - 0x0000)
struct OrionAbility_LockCameraRotation final
{
public:
	bool                                          bResetOnDeath;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_LockCameraRotation) == 0x000001, "Wrong alignment on OrionAbility_LockCameraRotation");
static_assert(sizeof(OrionAbility_LockCameraRotation) == 0x000001, "Wrong size on OrionAbility_LockCameraRotation");
static_assert(offsetof(OrionAbility_LockCameraRotation, bResetOnDeath) == 0x000000, "Member 'OrionAbility_LockCameraRotation::bResetOnDeath' has a wrong offset!");

// Function OrionGame.OrionAbility.SetCameraMode
// 0x0008 (0x0008 - 0x0000)
struct OrionAbility_SetCameraMode final
{
public:
	TSubclassOf<class UOrionCameraMode>           CameraModeClass;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_SetCameraMode) == 0x000008, "Wrong alignment on OrionAbility_SetCameraMode");
static_assert(sizeof(OrionAbility_SetCameraMode) == 0x000008, "Wrong size on OrionAbility_SetCameraMode");
static_assert(offsetof(OrionAbility_SetCameraMode, CameraModeClass) == 0x000000, "Member 'OrionAbility_SetCameraMode::CameraModeClass' has a wrong offset!");

// Function OrionGame.OrionAbility.SetLookAtActor
// 0x0020 (0x0020 - 0x0000)
struct OrionAbility_SetLookAtActor final
{
public:
	const class AActor*                           LookTarget;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LookSocket;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookLerp;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAccel;                                         // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionAbility_SetLookAtActor) == 0x000008, "Wrong alignment on OrionAbility_SetLookAtActor");
static_assert(sizeof(OrionAbility_SetLookAtActor) == 0x000020, "Wrong size on OrionAbility_SetLookAtActor");
static_assert(offsetof(OrionAbility_SetLookAtActor, LookTarget) == 0x000000, "Member 'OrionAbility_SetLookAtActor::LookTarget' has a wrong offset!");
static_assert(offsetof(OrionAbility_SetLookAtActor, LookSocket) == 0x000008, "Member 'OrionAbility_SetLookAtActor::LookSocket' has a wrong offset!");
static_assert(offsetof(OrionAbility_SetLookAtActor, LookLerp) == 0x000010, "Member 'OrionAbility_SetLookAtActor::LookLerp' has a wrong offset!");
static_assert(offsetof(OrionAbility_SetLookAtActor, LookAccel) == 0x000014, "Member 'OrionAbility_SetLookAtActor::LookAccel' has a wrong offset!");
static_assert(offsetof(OrionAbility_SetLookAtActor, ReturnValue) == 0x000018, "Member 'OrionAbility_SetLookAtActor::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbility.SetPassiveTargetingMode
// 0x0004 (0x0004 - 0x0000)
struct OrionAbility_SetPassiveTargetingMode final
{
public:
	int32                                         TargetingModeIndex;                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_SetPassiveTargetingMode) == 0x000004, "Wrong alignment on OrionAbility_SetPassiveTargetingMode");
static_assert(sizeof(OrionAbility_SetPassiveTargetingMode) == 0x000004, "Wrong size on OrionAbility_SetPassiveTargetingMode");
static_assert(offsetof(OrionAbility_SetPassiveTargetingMode, TargetingModeIndex) == 0x000000, "Member 'OrionAbility_SetPassiveTargetingMode::TargetingModeIndex' has a wrong offset!");

// Function OrionGame.OrionAbility.SetReticleVisibility
// 0x0001 (0x0001 - 0x0000)
struct OrionAbility_SetReticleVisibility final
{
public:
	EReticleVisibility                            Visibility;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_SetReticleVisibility) == 0x000001, "Wrong alignment on OrionAbility_SetReticleVisibility");
static_assert(sizeof(OrionAbility_SetReticleVisibility) == 0x000001, "Wrong size on OrionAbility_SetReticleVisibility");
static_assert(offsetof(OrionAbility_SetReticleVisibility, Visibility) == 0x000000, "Member 'OrionAbility_SetReticleVisibility::Visibility' has a wrong offset!");

// Function OrionGame.OrionAbility.SpawnCharHeroDecoy
// 0x0020 (0x0020 - 0x0000)
struct OrionAbility_SpawnCharHeroDecoy final
{
public:
	class AController*                            Controller;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AOrionCharHero_Decoy>       OrionCharHeroDecoyClass;                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UOrionVisionDef>            VisionData;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionChar*                             ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_SpawnCharHeroDecoy) == 0x000008, "Wrong alignment on OrionAbility_SpawnCharHeroDecoy");
static_assert(sizeof(OrionAbility_SpawnCharHeroDecoy) == 0x000020, "Wrong size on OrionAbility_SpawnCharHeroDecoy");
static_assert(offsetof(OrionAbility_SpawnCharHeroDecoy, Controller) == 0x000000, "Member 'OrionAbility_SpawnCharHeroDecoy::Controller' has a wrong offset!");
static_assert(offsetof(OrionAbility_SpawnCharHeroDecoy, OrionCharHeroDecoyClass) == 0x000008, "Member 'OrionAbility_SpawnCharHeroDecoy::OrionCharHeroDecoyClass' has a wrong offset!");
static_assert(offsetof(OrionAbility_SpawnCharHeroDecoy, VisionData) == 0x000010, "Member 'OrionAbility_SpawnCharHeroDecoy::VisionData' has a wrong offset!");
static_assert(offsetof(OrionAbility_SpawnCharHeroDecoy, ReturnValue) == 0x000018, "Member 'OrionAbility_SpawnCharHeroDecoy::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbility.TrackActor
// 0x0008 (0x0008 - 0x0000)
struct OrionAbility_TrackActor final
{
public:
	class AActor*                                 ActorToTrack;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_TrackActor) == 0x000008, "Wrong alignment on OrionAbility_TrackActor");
static_assert(sizeof(OrionAbility_TrackActor) == 0x000008, "Wrong size on OrionAbility_TrackActor");
static_assert(offsetof(OrionAbility_TrackActor, ActorToTrack) == 0x000000, "Member 'OrionAbility_TrackActor::ActorToTrack' has a wrong offset!");

// Function OrionGame.OrionAbility.TrackGroupedActor
// 0x0010 (0x0010 - 0x0000)
struct OrionAbility_TrackGroupedActor final
{
public:
	class AActor*                                 ActorToTrack;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GroupingTag;                                       // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_TrackGroupedActor) == 0x000008, "Wrong alignment on OrionAbility_TrackGroupedActor");
static_assert(sizeof(OrionAbility_TrackGroupedActor) == 0x000010, "Wrong size on OrionAbility_TrackGroupedActor");
static_assert(offsetof(OrionAbility_TrackGroupedActor, ActorToTrack) == 0x000000, "Member 'OrionAbility_TrackGroupedActor::ActorToTrack' has a wrong offset!");
static_assert(offsetof(OrionAbility_TrackGroupedActor, GroupingTag) == 0x000008, "Member 'OrionAbility_TrackGroupedActor::GroupingTag' has a wrong offset!");

// Function OrionGame.OrionAbility.UnBlockMovementInput
// 0x0001 (0x0001 - 0x0000)
struct OrionAbility_UnBlockMovementInput final
{
public:
	bool                                          bResetOnDeath;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_UnBlockMovementInput) == 0x000001, "Wrong alignment on OrionAbility_UnBlockMovementInput");
static_assert(sizeof(OrionAbility_UnBlockMovementInput) == 0x000001, "Wrong size on OrionAbility_UnBlockMovementInput");
static_assert(offsetof(OrionAbility_UnBlockMovementInput, bResetOnDeath) == 0x000000, "Member 'OrionAbility_UnBlockMovementInput::bResetOnDeath' has a wrong offset!");

// Function OrionGame.OrionAbility.UnlockCameraRotation
// 0x0001 (0x0001 - 0x0000)
struct OrionAbility_UnlockCameraRotation final
{
public:
	bool                                          bResetOnDeath;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_UnlockCameraRotation) == 0x000001, "Wrong alignment on OrionAbility_UnlockCameraRotation");
static_assert(sizeof(OrionAbility_UnlockCameraRotation) == 0x000001, "Wrong size on OrionAbility_UnlockCameraRotation");
static_assert(offsetof(OrionAbility_UnlockCameraRotation, bResetOnDeath) == 0x000000, "Member 'OrionAbility_UnlockCameraRotation::bResetOnDeath' has a wrong offset!");

// Function OrionGame.OrionAbility.AbilityHasTag
// 0x0010 (0x0010 - 0x0000)
struct OrionAbility_AbilityHasTag final
{
public:
	struct FGameplayTag                           TagToCheck;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionAbility_AbilityHasTag) == 0x000008, "Wrong alignment on OrionAbility_AbilityHasTag");
static_assert(sizeof(OrionAbility_AbilityHasTag) == 0x000010, "Wrong size on OrionAbility_AbilityHasTag");
static_assert(offsetof(OrionAbility_AbilityHasTag, TagToCheck) == 0x000000, "Member 'OrionAbility_AbilityHasTag::TagToCheck' has a wrong offset!");
static_assert(offsetof(OrionAbility_AbilityHasTag, ReturnValue) == 0x000008, "Member 'OrionAbility_AbilityHasTag::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbility.GetAbilitiesByTag
// 0x0030 (0x0030 - 0x0000)
struct OrionAbility_GetAbilitiesByTag final
{
public:
	struct FGameplayTagContainer                  TagContainer;                                      // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FGameplayAbilitySpecHandle>     ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_GetAbilitiesByTag) == 0x000008, "Wrong alignment on OrionAbility_GetAbilitiesByTag");
static_assert(sizeof(OrionAbility_GetAbilitiesByTag) == 0x000030, "Wrong size on OrionAbility_GetAbilitiesByTag");
static_assert(offsetof(OrionAbility_GetAbilitiesByTag, TagContainer) == 0x000000, "Member 'OrionAbility_GetAbilitiesByTag::TagContainer' has a wrong offset!");
static_assert(offsetof(OrionAbility_GetAbilitiesByTag, ReturnValue) == 0x000020, "Member 'OrionAbility_GetAbilitiesByTag::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbility.GetMontageForEmoteByInputID
// 0x0008 (0x0008 - 0x0000)
struct OrionAbility_GetMontageForEmoteByInputID final
{
public:
	class UAnimMontage*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_GetMontageForEmoteByInputID) == 0x000008, "Wrong alignment on OrionAbility_GetMontageForEmoteByInputID");
static_assert(sizeof(OrionAbility_GetMontageForEmoteByInputID) == 0x000008, "Wrong size on OrionAbility_GetMontageForEmoteByInputID");
static_assert(offsetof(OrionAbility_GetMontageForEmoteByInputID, ReturnValue) == 0x000000, "Member 'OrionAbility_GetMontageForEmoteByInputID::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbility.GetMontageForEmoteType
// 0x0010 (0x0010 - 0x0000)
struct OrionAbility_GetMontageForEmoteType final
{
public:
	EOrionEmoteType                               EmoteType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_GetMontageForEmoteType) == 0x000008, "Wrong alignment on OrionAbility_GetMontageForEmoteType");
static_assert(sizeof(OrionAbility_GetMontageForEmoteType) == 0x000010, "Wrong size on OrionAbility_GetMontageForEmoteType");
static_assert(offsetof(OrionAbility_GetMontageForEmoteType, EmoteType) == 0x000000, "Member 'OrionAbility_GetMontageForEmoteType::EmoteType' has a wrong offset!");
static_assert(offsetof(OrionAbility_GetMontageForEmoteType, ReturnValue) == 0x000008, "Member 'OrionAbility_GetMontageForEmoteType::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbility.GetOrionCharAIFromActorInfo
// 0x0008 (0x0008 - 0x0000)
struct OrionAbility_GetOrionCharAIFromActorInfo final
{
public:
	class AOrionCharAI*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_GetOrionCharAIFromActorInfo) == 0x000008, "Wrong alignment on OrionAbility_GetOrionCharAIFromActorInfo");
static_assert(sizeof(OrionAbility_GetOrionCharAIFromActorInfo) == 0x000008, "Wrong size on OrionAbility_GetOrionCharAIFromActorInfo");
static_assert(offsetof(OrionAbility_GetOrionCharAIFromActorInfo, ReturnValue) == 0x000000, "Member 'OrionAbility_GetOrionCharAIFromActorInfo::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbility.GetOrionCharFromActorInfo
// 0x0008 (0x0008 - 0x0000)
struct OrionAbility_GetOrionCharFromActorInfo final
{
public:
	class AOrionChar*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_GetOrionCharFromActorInfo) == 0x000008, "Wrong alignment on OrionAbility_GetOrionCharFromActorInfo");
static_assert(sizeof(OrionAbility_GetOrionCharFromActorInfo) == 0x000008, "Wrong size on OrionAbility_GetOrionCharFromActorInfo");
static_assert(offsetof(OrionAbility_GetOrionCharFromActorInfo, ReturnValue) == 0x000000, "Member 'OrionAbility_GetOrionCharFromActorInfo::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbility.GetOrionCharHeroFromActorInfo
// 0x0008 (0x0008 - 0x0000)
struct OrionAbility_GetOrionCharHeroFromActorInfo final
{
public:
	class AOrionCharHero*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_GetOrionCharHeroFromActorInfo) == 0x000008, "Wrong alignment on OrionAbility_GetOrionCharHeroFromActorInfo");
static_assert(sizeof(OrionAbility_GetOrionCharHeroFromActorInfo) == 0x000008, "Wrong size on OrionAbility_GetOrionCharHeroFromActorInfo");
static_assert(offsetof(OrionAbility_GetOrionCharHeroFromActorInfo, ReturnValue) == 0x000000, "Member 'OrionAbility_GetOrionCharHeroFromActorInfo::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbility.IsCharacterFalling
// 0x0001 (0x0001 - 0x0000)
struct OrionAbility_IsCharacterFalling final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_IsCharacterFalling) == 0x000001, "Wrong alignment on OrionAbility_IsCharacterFalling");
static_assert(sizeof(OrionAbility_IsCharacterFalling) == 0x000001, "Wrong size on OrionAbility_IsCharacterFalling");
static_assert(offsetof(OrionAbility_IsCharacterFalling, ReturnValue) == 0x000000, "Member 'OrionAbility_IsCharacterFalling::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbility.K2_GetAttackSpeedMultiplier
// 0x0004 (0x0004 - 0x0000)
struct OrionAbility_K2_GetAttackSpeedMultiplier final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_K2_GetAttackSpeedMultiplier) == 0x000004, "Wrong alignment on OrionAbility_K2_GetAttackSpeedMultiplier");
static_assert(sizeof(OrionAbility_K2_GetAttackSpeedMultiplier) == 0x000004, "Wrong size on OrionAbility_K2_GetAttackSpeedMultiplier");
static_assert(offsetof(OrionAbility_K2_GetAttackSpeedMultiplier, ReturnValue) == 0x000000, "Member 'OrionAbility_K2_GetAttackSpeedMultiplier::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbility.K2_GetBestMontageForAttackSpeed
// 0x0020 (0x0020 - 0x0000)
struct OrionAbility_K2_GetBestMontageForAttackSpeed final
{
public:
	struct FOrionAbilityMontageContainer          MontageContainer;                                  // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         OutPlayRate;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_K2_GetBestMontageForAttackSpeed) == 0x000008, "Wrong alignment on OrionAbility_K2_GetBestMontageForAttackSpeed");
static_assert(sizeof(OrionAbility_K2_GetBestMontageForAttackSpeed) == 0x000020, "Wrong size on OrionAbility_K2_GetBestMontageForAttackSpeed");
static_assert(offsetof(OrionAbility_K2_GetBestMontageForAttackSpeed, MontageContainer) == 0x000000, "Member 'OrionAbility_K2_GetBestMontageForAttackSpeed::MontageContainer' has a wrong offset!");
static_assert(offsetof(OrionAbility_K2_GetBestMontageForAttackSpeed, OutPlayRate) == 0x000010, "Member 'OrionAbility_K2_GetBestMontageForAttackSpeed::OutPlayRate' has a wrong offset!");
static_assert(offsetof(OrionAbility_K2_GetBestMontageForAttackSpeed, ReturnValue) == 0x000018, "Member 'OrionAbility_K2_GetBestMontageForAttackSpeed::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbility.K2_GetRateForAttackSpeedMontage
// 0x0018 (0x0018 - 0x0000)
struct OrionAbility_K2_GetRateForAttackSpeedMontage final
{
public:
	const class UAnimMontage*                     Montage;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SectionName;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FillEntireAttackTime;                              // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_K2_GetRateForAttackSpeedMontage) == 0x000008, "Wrong alignment on OrionAbility_K2_GetRateForAttackSpeedMontage");
static_assert(sizeof(OrionAbility_K2_GetRateForAttackSpeedMontage) == 0x000018, "Wrong size on OrionAbility_K2_GetRateForAttackSpeedMontage");
static_assert(offsetof(OrionAbility_K2_GetRateForAttackSpeedMontage, Montage) == 0x000000, "Member 'OrionAbility_K2_GetRateForAttackSpeedMontage::Montage' has a wrong offset!");
static_assert(offsetof(OrionAbility_K2_GetRateForAttackSpeedMontage, SectionName) == 0x000008, "Member 'OrionAbility_K2_GetRateForAttackSpeedMontage::SectionName' has a wrong offset!");
static_assert(offsetof(OrionAbility_K2_GetRateForAttackSpeedMontage, FillEntireAttackTime) == 0x000010, "Member 'OrionAbility_K2_GetRateForAttackSpeedMontage::FillEntireAttackTime' has a wrong offset!");
static_assert(offsetof(OrionAbility_K2_GetRateForAttackSpeedMontage, ReturnValue) == 0x000014, "Member 'OrionAbility_K2_GetRateForAttackSpeedMontage::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbility.K2_GetTotalAttackTime
// 0x0004 (0x0004 - 0x0000)
struct OrionAbility_K2_GetTotalAttackTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_K2_GetTotalAttackTime) == 0x000004, "Wrong alignment on OrionAbility_K2_GetTotalAttackTime");
static_assert(sizeof(OrionAbility_K2_GetTotalAttackTime) == 0x000004, "Wrong size on OrionAbility_K2_GetTotalAttackTime");
static_assert(offsetof(OrionAbility_K2_GetTotalAttackTime, ReturnValue) == 0x000000, "Member 'OrionAbility_K2_GetTotalAttackTime::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbility.K2_ScaleTimeByAttackSpeed
// 0x0008 (0x0008 - 0x0000)
struct OrionAbility_K2_ScaleTimeByAttackSpeed final
{
public:
	float                                         BaseTime;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_K2_ScaleTimeByAttackSpeed) == 0x000004, "Wrong alignment on OrionAbility_K2_ScaleTimeByAttackSpeed");
static_assert(sizeof(OrionAbility_K2_ScaleTimeByAttackSpeed) == 0x000008, "Wrong size on OrionAbility_K2_ScaleTimeByAttackSpeed");
static_assert(offsetof(OrionAbility_K2_ScaleTimeByAttackSpeed, BaseTime) == 0x000000, "Member 'OrionAbility_K2_ScaleTimeByAttackSpeed::BaseTime' has a wrong offset!");
static_assert(offsetof(OrionAbility_K2_ScaleTimeByAttackSpeed, ReturnValue) == 0x000004, "Member 'OrionAbility_K2_ScaleTimeByAttackSpeed::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbility.MakeGameplayCueParameters
// 0x00D8 (0x00D8 - 0x0000)
struct OrionAbility_MakeGameplayCueParameters final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0000(0x0020)(Parm, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 ReturnValue;                                       // 0x0020(0x00B8)(Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_MakeGameplayCueParameters) == 0x000008, "Wrong alignment on OrionAbility_MakeGameplayCueParameters");
static_assert(sizeof(OrionAbility_MakeGameplayCueParameters) == 0x0000D8, "Wrong size on OrionAbility_MakeGameplayCueParameters");
static_assert(offsetof(OrionAbility_MakeGameplayCueParameters, TargetData) == 0x000000, "Member 'OrionAbility_MakeGameplayCueParameters::TargetData' has a wrong offset!");
static_assert(offsetof(OrionAbility_MakeGameplayCueParameters, ReturnValue) == 0x000020, "Member 'OrionAbility_MakeGameplayCueParameters::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbility_EventEvaluator.OnAbilityActivatedOrCommitCallback
// 0x0008 (0x0008 - 0x0000)
struct OrionAbility_EventEvaluator_OnAbilityActivatedOrCommitCallback final
{
public:
	class UGameplayAbility*                       AbilityThatActivated;                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_EventEvaluator_OnAbilityActivatedOrCommitCallback) == 0x000008, "Wrong alignment on OrionAbility_EventEvaluator_OnAbilityActivatedOrCommitCallback");
static_assert(sizeof(OrionAbility_EventEvaluator_OnAbilityActivatedOrCommitCallback) == 0x000008, "Wrong size on OrionAbility_EventEvaluator_OnAbilityActivatedOrCommitCallback");
static_assert(offsetof(OrionAbility_EventEvaluator_OnAbilityActivatedOrCommitCallback, AbilityThatActivated) == 0x000000, "Member 'OrionAbility_EventEvaluator_OnAbilityActivatedOrCommitCallback::AbilityThatActivated' has a wrong offset!");

// Function OrionGame.OrionAbility_EventEvaluator.OnGameplayEffectAppliedSelf
// 0x0028 (0x0028 - 0x0000)
struct OrionAbility_EventEvaluator_OnGameplayEffectAppliedSelf final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpecHandle              SpecHandle;                                        // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            ActiveHandle;                                      // 0x0020(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_EventEvaluator_OnGameplayEffectAppliedSelf) == 0x000008, "Wrong alignment on OrionAbility_EventEvaluator_OnGameplayEffectAppliedSelf");
static_assert(sizeof(OrionAbility_EventEvaluator_OnGameplayEffectAppliedSelf) == 0x000028, "Wrong size on OrionAbility_EventEvaluator_OnGameplayEffectAppliedSelf");
static_assert(offsetof(OrionAbility_EventEvaluator_OnGameplayEffectAppliedSelf, Target) == 0x000000, "Member 'OrionAbility_EventEvaluator_OnGameplayEffectAppliedSelf::Target' has a wrong offset!");
static_assert(offsetof(OrionAbility_EventEvaluator_OnGameplayEffectAppliedSelf, SpecHandle) == 0x000008, "Member 'OrionAbility_EventEvaluator_OnGameplayEffectAppliedSelf::SpecHandle' has a wrong offset!");
static_assert(offsetof(OrionAbility_EventEvaluator_OnGameplayEffectAppliedSelf, ActiveHandle) == 0x000020, "Member 'OrionAbility_EventEvaluator_OnGameplayEffectAppliedSelf::ActiveHandle' has a wrong offset!");

// Function OrionGame.OrionAbility_EventEvaluator.OnGameplayEffectAppliedTarget
// 0x0028 (0x0028 - 0x0000)
struct OrionAbility_EventEvaluator_OnGameplayEffectAppliedTarget final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpecHandle              SpecHandle;                                        // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            ActiveHandle;                                      // 0x0020(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_EventEvaluator_OnGameplayEffectAppliedTarget) == 0x000008, "Wrong alignment on OrionAbility_EventEvaluator_OnGameplayEffectAppliedTarget");
static_assert(sizeof(OrionAbility_EventEvaluator_OnGameplayEffectAppliedTarget) == 0x000028, "Wrong size on OrionAbility_EventEvaluator_OnGameplayEffectAppliedTarget");
static_assert(offsetof(OrionAbility_EventEvaluator_OnGameplayEffectAppliedTarget, Target) == 0x000000, "Member 'OrionAbility_EventEvaluator_OnGameplayEffectAppliedTarget::Target' has a wrong offset!");
static_assert(offsetof(OrionAbility_EventEvaluator_OnGameplayEffectAppliedTarget, SpecHandle) == 0x000008, "Member 'OrionAbility_EventEvaluator_OnGameplayEffectAppliedTarget::SpecHandle' has a wrong offset!");
static_assert(offsetof(OrionAbility_EventEvaluator_OnGameplayEffectAppliedTarget, ActiveHandle) == 0x000020, "Member 'OrionAbility_EventEvaluator_OnGameplayEffectAppliedTarget::ActiveHandle' has a wrong offset!");

// Function OrionGame.OrionAbility_EventEvaluator.OnGameplayEventCallback
// 0x00A8 (0x00A8 - 0x0000)
struct OrionAbility_EventEvaluator_OnGameplayEventCallback final
{
public:
	struct FGameplayEventData                     Payload;                                           // 0x0000(0x00A8)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_EventEvaluator_OnGameplayEventCallback) == 0x000008, "Wrong alignment on OrionAbility_EventEvaluator_OnGameplayEventCallback");
static_assert(sizeof(OrionAbility_EventEvaluator_OnGameplayEventCallback) == 0x0000A8, "Wrong size on OrionAbility_EventEvaluator_OnGameplayEventCallback");
static_assert(offsetof(OrionAbility_EventEvaluator_OnGameplayEventCallback, Payload) == 0x000000, "Member 'OrionAbility_EventEvaluator_OnGameplayEventCallback::Payload' has a wrong offset!");

// Function OrionGame.OrionAbility_MeleeAttack.OnMeleeTouch
// 0x00A8 (0x00A8 - 0x0000)
struct OrionAbility_MeleeAttack_OnMeleeTouch final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_MeleeAttack_OnMeleeTouch) == 0x000008, "Wrong alignment on OrionAbility_MeleeAttack_OnMeleeTouch");
static_assert(sizeof(OrionAbility_MeleeAttack_OnMeleeTouch) == 0x0000A8, "Wrong size on OrionAbility_MeleeAttack_OnMeleeTouch");
static_assert(offsetof(OrionAbility_MeleeAttack_OnMeleeTouch, OverlappedComp) == 0x000000, "Member 'OrionAbility_MeleeAttack_OnMeleeTouch::OverlappedComp' has a wrong offset!");
static_assert(offsetof(OrionAbility_MeleeAttack_OnMeleeTouch, OtherActor) == 0x000008, "Member 'OrionAbility_MeleeAttack_OnMeleeTouch::OtherActor' has a wrong offset!");
static_assert(offsetof(OrionAbility_MeleeAttack_OnMeleeTouch, OtherComp) == 0x000010, "Member 'OrionAbility_MeleeAttack_OnMeleeTouch::OtherComp' has a wrong offset!");
static_assert(offsetof(OrionAbility_MeleeAttack_OnMeleeTouch, OtherBodyIndex) == 0x000018, "Member 'OrionAbility_MeleeAttack_OnMeleeTouch::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(OrionAbility_MeleeAttack_OnMeleeTouch, bFromSweep) == 0x00001C, "Member 'OrionAbility_MeleeAttack_OnMeleeTouch::bFromSweep' has a wrong offset!");
static_assert(offsetof(OrionAbility_MeleeAttack_OnMeleeTouch, SweepResult) == 0x000020, "Member 'OrionAbility_MeleeAttack_OnMeleeTouch::SweepResult' has a wrong offset!");

// Function OrionGame.OrionAbility_MeleeAttack.OnMontageEnded
// 0x0010 (0x0010 - 0x0000)
struct OrionAbility_MeleeAttack_OnMontageEnded final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterrupted;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionAbility_MeleeAttack_OnMontageEnded) == 0x000008, "Wrong alignment on OrionAbility_MeleeAttack_OnMontageEnded");
static_assert(sizeof(OrionAbility_MeleeAttack_OnMontageEnded) == 0x000010, "Wrong size on OrionAbility_MeleeAttack_OnMontageEnded");
static_assert(offsetof(OrionAbility_MeleeAttack_OnMontageEnded, Montage) == 0x000000, "Member 'OrionAbility_MeleeAttack_OnMontageEnded::Montage' has a wrong offset!");
static_assert(offsetof(OrionAbility_MeleeAttack_OnMontageEnded, bInterrupted) == 0x000008, "Member 'OrionAbility_MeleeAttack_OnMontageEnded::bInterrupted' has a wrong offset!");

// Function OrionGame.OrionAbility_MeleeAttack.ServerMeleeTouch
// 0x0090 (0x0090 - 0x0000)
struct OrionAbility_MeleeAttack_ServerMeleeTouch final
{
public:
	class AActor*                                 MeleeTarget;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0008(0x0088)(ConstParm, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbility_MeleeAttack_ServerMeleeTouch) == 0x000008, "Wrong alignment on OrionAbility_MeleeAttack_ServerMeleeTouch");
static_assert(sizeof(OrionAbility_MeleeAttack_ServerMeleeTouch) == 0x000090, "Wrong size on OrionAbility_MeleeAttack_ServerMeleeTouch");
static_assert(offsetof(OrionAbility_MeleeAttack_ServerMeleeTouch, MeleeTarget) == 0x000000, "Member 'OrionAbility_MeleeAttack_ServerMeleeTouch::MeleeTarget' has a wrong offset!");
static_assert(offsetof(OrionAbility_MeleeAttack_ServerMeleeTouch, Hit) == 0x000008, "Member 'OrionAbility_MeleeAttack_ServerMeleeTouch::Hit' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_StartTargeting.StartTargeting
// 0x0020 (0x0020 - 0x0000)
struct OrionAbilityTask_StartTargeting_StartTargeting final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayTargetingConfirmation                ConfirmationType;                                  // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Index_0;                                           // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionAbilityTask_StartTargeting*       ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_StartTargeting_StartTargeting) == 0x000008, "Wrong alignment on OrionAbilityTask_StartTargeting_StartTargeting");
static_assert(sizeof(OrionAbilityTask_StartTargeting_StartTargeting) == 0x000020, "Wrong size on OrionAbilityTask_StartTargeting_StartTargeting");
static_assert(offsetof(OrionAbilityTask_StartTargeting_StartTargeting, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_StartTargeting_StartTargeting::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_StartTargeting_StartTargeting, TaskInstanceName) == 0x000008, "Member 'OrionAbilityTask_StartTargeting_StartTargeting::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_StartTargeting_StartTargeting, ConfirmationType) == 0x000010, "Member 'OrionAbilityTask_StartTargeting_StartTargeting::ConfirmationType' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_StartTargeting_StartTargeting, Index_0) == 0x000014, "Member 'OrionAbilityTask_StartTargeting_StartTargeting::Index_0' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_StartTargeting_StartTargeting, ReturnValue) == 0x000018, "Member 'OrionAbilityTask_StartTargeting_StartTargeting::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityAITask_ExecuteGameplayAbility.AIExecuteAvailableGameplayAbility
// 0x0018 (0x0018 - 0x0000)
struct OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteAvailableGameplayAbility final
{
public:
	class AAIController*                          AIController;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWaitForAbilityEnd_0;                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAbilityAITask_ExecuteGameplayAbility* ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteAvailableGameplayAbility) == 0x000008, "Wrong alignment on OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteAvailableGameplayAbility");
static_assert(sizeof(OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteAvailableGameplayAbility) == 0x000018, "Wrong size on OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteAvailableGameplayAbility");
static_assert(offsetof(OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteAvailableGameplayAbility, AIController) == 0x000000, "Member 'OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteAvailableGameplayAbility::AIController' has a wrong offset!");
static_assert(offsetof(OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteAvailableGameplayAbility, bWaitForAbilityEnd_0) == 0x000008, "Member 'OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteAvailableGameplayAbility::bWaitForAbilityEnd_0' has a wrong offset!");
static_assert(offsetof(OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteAvailableGameplayAbility, ReturnValue) == 0x000010, "Member 'OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteAvailableGameplayAbility::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityAITask_ExecuteGameplayAbility.AIExecuteGameplayAbilityByClass
// 0x0020 (0x0020 - 0x0000)
struct OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByClass final
{
public:
	class AAIController*                          AIController;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UOrionAbility>              AbilityClass;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWaitForAbilityEnd_0;                              // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAbilityAITask_ExecuteGameplayAbility* ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByClass) == 0x000008, "Wrong alignment on OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByClass");
static_assert(sizeof(OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByClass) == 0x000020, "Wrong size on OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByClass");
static_assert(offsetof(OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByClass, AIController) == 0x000000, "Member 'OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByClass::AIController' has a wrong offset!");
static_assert(offsetof(OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByClass, AbilityClass) == 0x000008, "Member 'OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByClass::AbilityClass' has a wrong offset!");
static_assert(offsetof(OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByClass, bWaitForAbilityEnd_0) == 0x000010, "Member 'OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByClass::bWaitForAbilityEnd_0' has a wrong offset!");
static_assert(offsetof(OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByClass, ReturnValue) == 0x000018, "Member 'OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByClass::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityAITask_ExecuteGameplayAbility.AIExecuteGameplayAbilityByHandle
// 0x0018 (0x0018 - 0x0000)
struct OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByHandle final
{
public:
	class AAIController*                          AIController;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilitySpecHandle             Handle;                                            // 0x0008(0x0004)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWaitForAbilityEnd_0;                              // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAbilityAITask_ExecuteGameplayAbility* ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByHandle) == 0x000008, "Wrong alignment on OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByHandle");
static_assert(sizeof(OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByHandle) == 0x000018, "Wrong size on OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByHandle");
static_assert(offsetof(OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByHandle, AIController) == 0x000000, "Member 'OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByHandle::AIController' has a wrong offset!");
static_assert(offsetof(OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByHandle, Handle) == 0x000008, "Member 'OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByHandle::Handle' has a wrong offset!");
static_assert(offsetof(OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByHandle, bWaitForAbilityEnd_0) == 0x00000C, "Member 'OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByHandle::bWaitForAbilityEnd_0' has a wrong offset!");
static_assert(offsetof(OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByHandle, ReturnValue) == 0x000010, "Member 'OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByHandle::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityAITask_ExecuteGameplayAbility.AIExecuteGameplayAbilityByTag
// 0x0038 (0x0038 - 0x0000)
struct OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByTag final
{
public:
	class AAIController*                          AIController;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  InGameplayTagContainerOfAbilityTags;               // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bWaitForAbilityEnd_0;                              // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAbilityAITask_ExecuteGameplayAbility* ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByTag) == 0x000008, "Wrong alignment on OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByTag");
static_assert(sizeof(OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByTag) == 0x000038, "Wrong size on OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByTag");
static_assert(offsetof(OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByTag, AIController) == 0x000000, "Member 'OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByTag::AIController' has a wrong offset!");
static_assert(offsetof(OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByTag, InGameplayTagContainerOfAbilityTags) == 0x000008, "Member 'OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByTag::InGameplayTagContainerOfAbilityTags' has a wrong offset!");
static_assert(offsetof(OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByTag, bWaitForAbilityEnd_0) == 0x000028, "Member 'OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByTag::bWaitForAbilityEnd_0' has a wrong offset!");
static_assert(offsetof(OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByTag, ReturnValue) == 0x000030, "Member 'OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByTag::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityAITask_ExecuteGameplayAbility.K2_SetUp
// 0x0008 (0x0008 - 0x0000)
struct OrionAbilityAITask_ExecuteGameplayAbility_K2_SetUp final
{
public:
	class AAIController*                          AIController;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityAITask_ExecuteGameplayAbility_K2_SetUp) == 0x000008, "Wrong alignment on OrionAbilityAITask_ExecuteGameplayAbility_K2_SetUp");
static_assert(sizeof(OrionAbilityAITask_ExecuteGameplayAbility_K2_SetUp) == 0x000008, "Wrong size on OrionAbilityAITask_ExecuteGameplayAbility_K2_SetUp");
static_assert(offsetof(OrionAbilityAITask_ExecuteGameplayAbility_K2_SetUp, AIController) == 0x000000, "Member 'OrionAbilityAITask_ExecuteGameplayAbility_K2_SetUp::AIController' has a wrong offset!");

// Function OrionGame.OrionAbilitySystemComponent.BP_CopyGameplayEffectToSpecForReapply
// 0x0020 (0x0020 - 0x0000)
struct OrionAbilitySystemComponent_BP_CopyGameplayEffectToSpecForReapply final
{
public:
	struct FActiveGameplayEffectHandle            GameplayEffectHandle;                              // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpecHandle              ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilitySystemComponent_BP_CopyGameplayEffectToSpecForReapply) == 0x000008, "Wrong alignment on OrionAbilitySystemComponent_BP_CopyGameplayEffectToSpecForReapply");
static_assert(sizeof(OrionAbilitySystemComponent_BP_CopyGameplayEffectToSpecForReapply) == 0x000020, "Wrong size on OrionAbilitySystemComponent_BP_CopyGameplayEffectToSpecForReapply");
static_assert(offsetof(OrionAbilitySystemComponent_BP_CopyGameplayEffectToSpecForReapply, GameplayEffectHandle) == 0x000000, "Member 'OrionAbilitySystemComponent_BP_CopyGameplayEffectToSpecForReapply::GameplayEffectHandle' has a wrong offset!");
static_assert(offsetof(OrionAbilitySystemComponent_BP_CopyGameplayEffectToSpecForReapply, ReturnValue) == 0x000008, "Member 'OrionAbilitySystemComponent_BP_CopyGameplayEffectToSpecForReapply::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilitySystemComponent.BP_GetGameplayEffectDurationRemaining
// 0x000C (0x000C - 0x0000)
struct OrionAbilitySystemComponent_BP_GetGameplayEffectDurationRemaining final
{
public:
	struct FActiveGameplayEffectHandle            GameplayEffectHandle;                              // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilitySystemComponent_BP_GetGameplayEffectDurationRemaining) == 0x000004, "Wrong alignment on OrionAbilitySystemComponent_BP_GetGameplayEffectDurationRemaining");
static_assert(sizeof(OrionAbilitySystemComponent_BP_GetGameplayEffectDurationRemaining) == 0x00000C, "Wrong size on OrionAbilitySystemComponent_BP_GetGameplayEffectDurationRemaining");
static_assert(offsetof(OrionAbilitySystemComponent_BP_GetGameplayEffectDurationRemaining, GameplayEffectHandle) == 0x000000, "Member 'OrionAbilitySystemComponent_BP_GetGameplayEffectDurationRemaining::GameplayEffectHandle' has a wrong offset!");
static_assert(offsetof(OrionAbilitySystemComponent_BP_GetGameplayEffectDurationRemaining, ReturnValue) == 0x000008, "Member 'OrionAbilitySystemComponent_BP_GetGameplayEffectDurationRemaining::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilitySystemComponent.BP_ReapplyGameplayEffectSpecToSelf
// 0x0028 (0x0028 - 0x0000)
struct OrionAbilitySystemComponent_BP_ReapplyGameplayEffectSpecToSelf final
{
public:
	struct FGameplayEffectSpecHandle              SpecHandle;                                        // 0x0000(0x0018)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         DurationRemaning;                                  // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            ReturnValue;                                       // 0x001C(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionAbilitySystemComponent_BP_ReapplyGameplayEffectSpecToSelf) == 0x000008, "Wrong alignment on OrionAbilitySystemComponent_BP_ReapplyGameplayEffectSpecToSelf");
static_assert(sizeof(OrionAbilitySystemComponent_BP_ReapplyGameplayEffectSpecToSelf) == 0x000028, "Wrong size on OrionAbilitySystemComponent_BP_ReapplyGameplayEffectSpecToSelf");
static_assert(offsetof(OrionAbilitySystemComponent_BP_ReapplyGameplayEffectSpecToSelf, SpecHandle) == 0x000000, "Member 'OrionAbilitySystemComponent_BP_ReapplyGameplayEffectSpecToSelf::SpecHandle' has a wrong offset!");
static_assert(offsetof(OrionAbilitySystemComponent_BP_ReapplyGameplayEffectSpecToSelf, DurationRemaning) == 0x000018, "Member 'OrionAbilitySystemComponent_BP_ReapplyGameplayEffectSpecToSelf::DurationRemaning' has a wrong offset!");
static_assert(offsetof(OrionAbilitySystemComponent_BP_ReapplyGameplayEffectSpecToSelf, ReturnValue) == 0x00001C, "Member 'OrionAbilitySystemComponent_BP_ReapplyGameplayEffectSpecToSelf::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilitySystemComponent.BP_ReapplyGameplayEffectSpecToTarget
// 0x0030 (0x0030 - 0x0000)
struct OrionAbilitySystemComponent_BP_ReapplyGameplayEffectSpecToTarget final
{
public:
	struct FGameplayEffectSpecHandle              SpecHandle;                                        // 0x0000(0x0018)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UAbilitySystemComponent*                Target;                                            // 0x0018(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationRemaning;                                  // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            ReturnValue;                                       // 0x0024(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionAbilitySystemComponent_BP_ReapplyGameplayEffectSpecToTarget) == 0x000008, "Wrong alignment on OrionAbilitySystemComponent_BP_ReapplyGameplayEffectSpecToTarget");
static_assert(sizeof(OrionAbilitySystemComponent_BP_ReapplyGameplayEffectSpecToTarget) == 0x000030, "Wrong size on OrionAbilitySystemComponent_BP_ReapplyGameplayEffectSpecToTarget");
static_assert(offsetof(OrionAbilitySystemComponent_BP_ReapplyGameplayEffectSpecToTarget, SpecHandle) == 0x000000, "Member 'OrionAbilitySystemComponent_BP_ReapplyGameplayEffectSpecToTarget::SpecHandle' has a wrong offset!");
static_assert(offsetof(OrionAbilitySystemComponent_BP_ReapplyGameplayEffectSpecToTarget, Target) == 0x000018, "Member 'OrionAbilitySystemComponent_BP_ReapplyGameplayEffectSpecToTarget::Target' has a wrong offset!");
static_assert(offsetof(OrionAbilitySystemComponent_BP_ReapplyGameplayEffectSpecToTarget, DurationRemaning) == 0x000020, "Member 'OrionAbilitySystemComponent_BP_ReapplyGameplayEffectSpecToTarget::DurationRemaning' has a wrong offset!");
static_assert(offsetof(OrionAbilitySystemComponent_BP_ReapplyGameplayEffectSpecToTarget, ReturnValue) == 0x000024, "Member 'OrionAbilitySystemComponent_BP_ReapplyGameplayEffectSpecToTarget::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilitySystemComponent.ClientBatchedGoldXP
// 0x0018 (0x0018 - 0x0000)
struct OrionAbilitySystemComponent_ClientBatchedGoldXP final
{
public:
	struct FOrionGoldXPGameplayCueBatch           Data;                                              // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilitySystemComponent_ClientBatchedGoldXP) == 0x000008, "Wrong alignment on OrionAbilitySystemComponent_ClientBatchedGoldXP");
static_assert(sizeof(OrionAbilitySystemComponent_ClientBatchedGoldXP) == 0x000018, "Wrong size on OrionAbilitySystemComponent_ClientBatchedGoldXP");
static_assert(offsetof(OrionAbilitySystemComponent_ClientBatchedGoldXP, Data) == 0x000000, "Member 'OrionAbilitySystemComponent_ClientBatchedGoldXP::Data' has a wrong offset!");

// Function OrionGame.OrionAbilitySystemComponent.ClientNotifyPostAbilityLevelUp
// 0x0008 (0x0008 - 0x0000)
struct OrionAbilitySystemComponent_ClientNotifyPostAbilityLevelUp final
{
public:
	struct FGameplayAbilitySpecHandle             AbilitySpecHandle;                                 // 0x0000(0x0004)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilitySystemComponent_ClientNotifyPostAbilityLevelUp) == 0x000004, "Wrong alignment on OrionAbilitySystemComponent_ClientNotifyPostAbilityLevelUp");
static_assert(sizeof(OrionAbilitySystemComponent_ClientNotifyPostAbilityLevelUp) == 0x000008, "Wrong size on OrionAbilitySystemComponent_ClientNotifyPostAbilityLevelUp");
static_assert(offsetof(OrionAbilitySystemComponent_ClientNotifyPostAbilityLevelUp, AbilitySpecHandle) == 0x000000, "Member 'OrionAbilitySystemComponent_ClientNotifyPostAbilityLevelUp::AbilitySpecHandle' has a wrong offset!");
static_assert(offsetof(OrionAbilitySystemComponent_ClientNotifyPostAbilityLevelUp, Level) == 0x000004, "Member 'OrionAbilitySystemComponent_ClientNotifyPostAbilityLevelUp::Level' has a wrong offset!");

// Function OrionGame.OrionAbilitySystemComponent.NetMulticast_OrionGameplayCueExecutedBatch
// 0x00C8 (0x00C8 - 0x0000)
struct OrionAbilitySystemComponent_NetMulticast_OrionGameplayCueExecutedBatch final
{
public:
	struct FOrionGameplayCueBatch                 Data;                                              // 0x0000(0x00C8)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilitySystemComponent_NetMulticast_OrionGameplayCueExecutedBatch) == 0x000008, "Wrong alignment on OrionAbilitySystemComponent_NetMulticast_OrionGameplayCueExecutedBatch");
static_assert(sizeof(OrionAbilitySystemComponent_NetMulticast_OrionGameplayCueExecutedBatch) == 0x0000C8, "Wrong size on OrionAbilitySystemComponent_NetMulticast_OrionGameplayCueExecutedBatch");
static_assert(offsetof(OrionAbilitySystemComponent_NetMulticast_OrionGameplayCueExecutedBatch, Data) == 0x000000, "Member 'OrionAbilitySystemComponent_NetMulticast_OrionGameplayCueExecutedBatch::Data' has a wrong offset!");

// Function OrionGame.OrionAbilitySystemComponent.TrackActor
// 0x0018 (0x0018 - 0x0000)
struct OrionAbilitySystemComponent_TrackActor final
{
public:
	class AActor*                                 ActorToTrack;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilitySpecHandle             Handle;                                            // 0x0008(0x0004)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTracked;                                        // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemovalTime;                                       // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionAbilitySystemComponent_TrackActor) == 0x000008, "Wrong alignment on OrionAbilitySystemComponent_TrackActor");
static_assert(sizeof(OrionAbilitySystemComponent_TrackActor) == 0x000018, "Wrong size on OrionAbilitySystemComponent_TrackActor");
static_assert(offsetof(OrionAbilitySystemComponent_TrackActor, ActorToTrack) == 0x000000, "Member 'OrionAbilitySystemComponent_TrackActor::ActorToTrack' has a wrong offset!");
static_assert(offsetof(OrionAbilitySystemComponent_TrackActor, Handle) == 0x000008, "Member 'OrionAbilitySystemComponent_TrackActor::Handle' has a wrong offset!");
static_assert(offsetof(OrionAbilitySystemComponent_TrackActor, MaxTracked) == 0x00000C, "Member 'OrionAbilitySystemComponent_TrackActor::MaxTracked' has a wrong offset!");
static_assert(offsetof(OrionAbilitySystemComponent_TrackActor, RemovalTime) == 0x000010, "Member 'OrionAbilitySystemComponent_TrackActor::RemovalTime' has a wrong offset!");

// Function OrionGame.OrionAbilitySystemComponent.TrackGroupedActor
// 0x0018 (0x0018 - 0x0000)
struct OrionAbilitySystemComponent_TrackGroupedActor final
{
public:
	class AActor*                                 ActorToTrack;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GroupingTag;                                       // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTracked;                                        // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemovalTime;                                       // 0x0014(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilitySystemComponent_TrackGroupedActor) == 0x000008, "Wrong alignment on OrionAbilitySystemComponent_TrackGroupedActor");
static_assert(sizeof(OrionAbilitySystemComponent_TrackGroupedActor) == 0x000018, "Wrong size on OrionAbilitySystemComponent_TrackGroupedActor");
static_assert(offsetof(OrionAbilitySystemComponent_TrackGroupedActor, ActorToTrack) == 0x000000, "Member 'OrionAbilitySystemComponent_TrackGroupedActor::ActorToTrack' has a wrong offset!");
static_assert(offsetof(OrionAbilitySystemComponent_TrackGroupedActor, GroupingTag) == 0x000008, "Member 'OrionAbilitySystemComponent_TrackGroupedActor::GroupingTag' has a wrong offset!");
static_assert(offsetof(OrionAbilitySystemComponent_TrackGroupedActor, MaxTracked) == 0x000010, "Member 'OrionAbilitySystemComponent_TrackGroupedActor::MaxTracked' has a wrong offset!");
static_assert(offsetof(OrionAbilitySystemComponent_TrackGroupedActor, RemovalTime) == 0x000014, "Member 'OrionAbilitySystemComponent_TrackGroupedActor::RemovalTime' has a wrong offset!");

// Function OrionGame.OrionAbilitySystemComponent.BP_GetActiveGameplayEffects
// 0x0180 (0x0180 - 0x0000)
struct OrionAbilitySystemComponent_BP_GetActiveGameplayEffects final
{
public:
	struct FGameplayEffectQuery                   Query;                                             // 0x0000(0x0170)(ConstParm, Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FActiveGameplayEffectHandle>    ReturnValue;                                       // 0x0170(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilitySystemComponent_BP_GetActiveGameplayEffects) == 0x000010, "Wrong alignment on OrionAbilitySystemComponent_BP_GetActiveGameplayEffects");
static_assert(sizeof(OrionAbilitySystemComponent_BP_GetActiveGameplayEffects) == 0x000180, "Wrong size on OrionAbilitySystemComponent_BP_GetActiveGameplayEffects");
static_assert(offsetof(OrionAbilitySystemComponent_BP_GetActiveGameplayEffects, Query) == 0x000000, "Member 'OrionAbilitySystemComponent_BP_GetActiveGameplayEffects::Query' has a wrong offset!");
static_assert(offsetof(OrionAbilitySystemComponent_BP_GetActiveGameplayEffects, ReturnValue) == 0x000170, "Member 'OrionAbilitySystemComponent_BP_GetActiveGameplayEffects::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilitySystemComponent.DidActiveTargetsChange
// 0x0001 (0x0001 - 0x0000)
struct OrionAbilitySystemComponent_DidActiveTargetsChange final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilitySystemComponent_DidActiveTargetsChange) == 0x000001, "Wrong alignment on OrionAbilitySystemComponent_DidActiveTargetsChange");
static_assert(sizeof(OrionAbilitySystemComponent_DidActiveTargetsChange) == 0x000001, "Wrong size on OrionAbilitySystemComponent_DidActiveTargetsChange");
static_assert(offsetof(OrionAbilitySystemComponent_DidActiveTargetsChange, ReturnValue) == 0x000000, "Member 'OrionAbilitySystemComponent_DidActiveTargetsChange::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilitySystemComponent.GetExternalAbilityLevel
// 0x0010 (0x0010 - 0x0000)
struct OrionAbilitySystemComponent_GetExternalAbilityLevel final
{
public:
	struct FGameplayTag                           AbilityTag;                                        // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionAbilitySystemComponent_GetExternalAbilityLevel) == 0x000008, "Wrong alignment on OrionAbilitySystemComponent_GetExternalAbilityLevel");
static_assert(sizeof(OrionAbilitySystemComponent_GetExternalAbilityLevel) == 0x000010, "Wrong size on OrionAbilitySystemComponent_GetExternalAbilityLevel");
static_assert(offsetof(OrionAbilitySystemComponent_GetExternalAbilityLevel, AbilityTag) == 0x000000, "Member 'OrionAbilitySystemComponent_GetExternalAbilityLevel::AbilityTag' has a wrong offset!");
static_assert(offsetof(OrionAbilitySystemComponent_GetExternalAbilityLevel, ReturnValue) == 0x000008, "Member 'OrionAbilitySystemComponent_GetExternalAbilityLevel::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilitySystemComponent.IsActivelyTargetingAnyActor
// 0x0001 (0x0001 - 0x0000)
struct OrionAbilitySystemComponent_IsActivelyTargetingAnyActor final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilitySystemComponent_IsActivelyTargetingAnyActor) == 0x000001, "Wrong alignment on OrionAbilitySystemComponent_IsActivelyTargetingAnyActor");
static_assert(sizeof(OrionAbilitySystemComponent_IsActivelyTargetingAnyActor) == 0x000001, "Wrong size on OrionAbilitySystemComponent_IsActivelyTargetingAnyActor");
static_assert(offsetof(OrionAbilitySystemComponent_IsActivelyTargetingAnyActor, ReturnValue) == 0x000000, "Member 'OrionAbilitySystemComponent_IsActivelyTargetingAnyActor::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilitySystemComponent.K2_GetActivatableAbilities
// 0x0010 (0x0010 - 0x0000)
struct OrionAbilitySystemComponent_K2_GetActivatableAbilities final
{
public:
	TArray<struct FGameplayAbilitySpec>           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilitySystemComponent_K2_GetActivatableAbilities) == 0x000008, "Wrong alignment on OrionAbilitySystemComponent_K2_GetActivatableAbilities");
static_assert(sizeof(OrionAbilitySystemComponent_K2_GetActivatableAbilities) == 0x000010, "Wrong size on OrionAbilitySystemComponent_K2_GetActivatableAbilities");
static_assert(offsetof(OrionAbilitySystemComponent_K2_GetActivatableAbilities, ReturnValue) == 0x000000, "Member 'OrionAbilitySystemComponent_K2_GetActivatableAbilities::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_AddPlayerScoreListener.CreateAddPlayerScoreListenerTask
// 0x00F8 (0x00F8 - 0x0000)
struct OrionAbilityTask_AddPlayerScoreListener_CreateAddPlayerScoreListenerTask final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ListenerName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionActorFilter                      TargetFilter;                                      // 0x0010(0x0060)(Parm, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               SourceTagRequirements;                             // 0x0070(0x0040)(Parm, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               TargetTagRequirements;                             // 0x00B0(0x0040)(Parm, NativeAccessSpecifierPublic)
	class UOrionAbilityTask_AddPlayerScoreListener* ReturnValue;                                       // 0x00F0(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_AddPlayerScoreListener_CreateAddPlayerScoreListenerTask) == 0x000008, "Wrong alignment on OrionAbilityTask_AddPlayerScoreListener_CreateAddPlayerScoreListenerTask");
static_assert(sizeof(OrionAbilityTask_AddPlayerScoreListener_CreateAddPlayerScoreListenerTask) == 0x0000F8, "Wrong size on OrionAbilityTask_AddPlayerScoreListener_CreateAddPlayerScoreListenerTask");
static_assert(offsetof(OrionAbilityTask_AddPlayerScoreListener_CreateAddPlayerScoreListenerTask, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_AddPlayerScoreListener_CreateAddPlayerScoreListenerTask::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_AddPlayerScoreListener_CreateAddPlayerScoreListenerTask, ListenerName) == 0x000008, "Member 'OrionAbilityTask_AddPlayerScoreListener_CreateAddPlayerScoreListenerTask::ListenerName' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_AddPlayerScoreListener_CreateAddPlayerScoreListenerTask, TargetFilter) == 0x000010, "Member 'OrionAbilityTask_AddPlayerScoreListener_CreateAddPlayerScoreListenerTask::TargetFilter' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_AddPlayerScoreListener_CreateAddPlayerScoreListenerTask, SourceTagRequirements) == 0x000070, "Member 'OrionAbilityTask_AddPlayerScoreListener_CreateAddPlayerScoreListenerTask::SourceTagRequirements' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_AddPlayerScoreListener_CreateAddPlayerScoreListenerTask, TargetTagRequirements) == 0x0000B0, "Member 'OrionAbilityTask_AddPlayerScoreListener_CreateAddPlayerScoreListenerTask::TargetTagRequirements' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_AddPlayerScoreListener_CreateAddPlayerScoreListenerTask, ReturnValue) == 0x0000F0, "Member 'OrionAbilityTask_AddPlayerScoreListener_CreateAddPlayerScoreListenerTask::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_DirectedMovement.DirectedMovement
// 0x0030 (0x0030 - 0x0000)
struct OrionAbilityTask_DirectedMovement_DirectedMovement final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MovementDirection;                                 // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionDirectedMovementSpace                   MovementSpaceType;                                 // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MovementDistance_0;                                // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementDuration;                                  // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdealDistance;                                     // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ModifyZ;                                           // 0x0024(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAbilityTask_DirectedMovement*     ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_DirectedMovement_DirectedMovement) == 0x000008, "Wrong alignment on OrionAbilityTask_DirectedMovement_DirectedMovement");
static_assert(sizeof(OrionAbilityTask_DirectedMovement_DirectedMovement) == 0x000030, "Wrong size on OrionAbilityTask_DirectedMovement_DirectedMovement");
static_assert(offsetof(OrionAbilityTask_DirectedMovement_DirectedMovement, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_DirectedMovement_DirectedMovement::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_DirectedMovement_DirectedMovement, MovementDirection) == 0x000008, "Member 'OrionAbilityTask_DirectedMovement_DirectedMovement::MovementDirection' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_DirectedMovement_DirectedMovement, MovementSpaceType) == 0x000014, "Member 'OrionAbilityTask_DirectedMovement_DirectedMovement::MovementSpaceType' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_DirectedMovement_DirectedMovement, MovementDistance_0) == 0x000018, "Member 'OrionAbilityTask_DirectedMovement_DirectedMovement::MovementDistance_0' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_DirectedMovement_DirectedMovement, MovementDuration) == 0x00001C, "Member 'OrionAbilityTask_DirectedMovement_DirectedMovement::MovementDuration' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_DirectedMovement_DirectedMovement, IdealDistance) == 0x000020, "Member 'OrionAbilityTask_DirectedMovement_DirectedMovement::IdealDistance' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_DirectedMovement_DirectedMovement, ModifyZ) == 0x000024, "Member 'OrionAbilityTask_DirectedMovement_DirectedMovement::ModifyZ' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_DirectedMovement_DirectedMovement, ReturnValue) == 0x000028, "Member 'OrionAbilityTask_DirectedMovement_DirectedMovement::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_DirectedMovement.DirectedMovementToActor
// 0x0028 (0x0028 - 0x0000)
struct OrionAbilityTask_DirectedMovement_DirectedMovementToActor final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxMovementDistance;                               // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementDuration;                                  // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdealDistance;                                     // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ModifyZ;                                           // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAbilityTask_DirectedMovement*     ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_DirectedMovement_DirectedMovementToActor) == 0x000008, "Wrong alignment on OrionAbilityTask_DirectedMovement_DirectedMovementToActor");
static_assert(sizeof(OrionAbilityTask_DirectedMovement_DirectedMovementToActor) == 0x000028, "Wrong size on OrionAbilityTask_DirectedMovement_DirectedMovementToActor");
static_assert(offsetof(OrionAbilityTask_DirectedMovement_DirectedMovementToActor, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_DirectedMovement_DirectedMovementToActor::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_DirectedMovement_DirectedMovementToActor, TargetActor) == 0x000008, "Member 'OrionAbilityTask_DirectedMovement_DirectedMovementToActor::TargetActor' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_DirectedMovement_DirectedMovementToActor, MaxMovementDistance) == 0x000010, "Member 'OrionAbilityTask_DirectedMovement_DirectedMovementToActor::MaxMovementDistance' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_DirectedMovement_DirectedMovementToActor, MovementDuration) == 0x000014, "Member 'OrionAbilityTask_DirectedMovement_DirectedMovementToActor::MovementDuration' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_DirectedMovement_DirectedMovementToActor, IdealDistance) == 0x000018, "Member 'OrionAbilityTask_DirectedMovement_DirectedMovementToActor::IdealDistance' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_DirectedMovement_DirectedMovementToActor, ModifyZ) == 0x00001C, "Member 'OrionAbilityTask_DirectedMovement_DirectedMovementToActor::ModifyZ' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_DirectedMovement_DirectedMovementToActor, ReturnValue) == 0x000020, "Member 'OrionAbilityTask_DirectedMovement_DirectedMovementToActor::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_DirectedMovement.DirectedMovementToComponent
// 0x0028 (0x0028 - 0x0000)
struct OrionAbilityTask_DirectedMovement_DirectedMovementToComponent final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        TargetComponent_0;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxMovementDistance;                               // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementDuration;                                  // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdealDistance;                                     // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ModifyZ;                                           // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAbilityTask_DirectedMovement*     ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_DirectedMovement_DirectedMovementToComponent) == 0x000008, "Wrong alignment on OrionAbilityTask_DirectedMovement_DirectedMovementToComponent");
static_assert(sizeof(OrionAbilityTask_DirectedMovement_DirectedMovementToComponent) == 0x000028, "Wrong size on OrionAbilityTask_DirectedMovement_DirectedMovementToComponent");
static_assert(offsetof(OrionAbilityTask_DirectedMovement_DirectedMovementToComponent, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_DirectedMovement_DirectedMovementToComponent::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_DirectedMovement_DirectedMovementToComponent, TargetComponent_0) == 0x000008, "Member 'OrionAbilityTask_DirectedMovement_DirectedMovementToComponent::TargetComponent_0' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_DirectedMovement_DirectedMovementToComponent, MaxMovementDistance) == 0x000010, "Member 'OrionAbilityTask_DirectedMovement_DirectedMovementToComponent::MaxMovementDistance' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_DirectedMovement_DirectedMovementToComponent, MovementDuration) == 0x000014, "Member 'OrionAbilityTask_DirectedMovement_DirectedMovementToComponent::MovementDuration' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_DirectedMovement_DirectedMovementToComponent, IdealDistance) == 0x000018, "Member 'OrionAbilityTask_DirectedMovement_DirectedMovementToComponent::IdealDistance' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_DirectedMovement_DirectedMovementToComponent, ModifyZ) == 0x00001C, "Member 'OrionAbilityTask_DirectedMovement_DirectedMovementToComponent::ModifyZ' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_DirectedMovement_DirectedMovementToComponent, ReturnValue) == 0x000020, "Member 'OrionAbilityTask_DirectedMovement_DirectedMovementToComponent::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_DirectedMovement.DirectedMovementToLocation
// 0x0030 (0x0030 - 0x0000)
struct OrionAbilityTask_DirectedMovement_DirectedMovementToLocation final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MovementTargetLocation;                            // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionDirectedMovementSpace                   MovementSpaceType;                                 // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MovementDuration;                                  // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloseEnoughDistance;                               // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ModifyZ;                                           // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAbilityTask_DirectedMovement*     ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_DirectedMovement_DirectedMovementToLocation) == 0x000008, "Wrong alignment on OrionAbilityTask_DirectedMovement_DirectedMovementToLocation");
static_assert(sizeof(OrionAbilityTask_DirectedMovement_DirectedMovementToLocation) == 0x000030, "Wrong size on OrionAbilityTask_DirectedMovement_DirectedMovementToLocation");
static_assert(offsetof(OrionAbilityTask_DirectedMovement_DirectedMovementToLocation, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_DirectedMovement_DirectedMovementToLocation::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_DirectedMovement_DirectedMovementToLocation, MovementTargetLocation) == 0x000008, "Member 'OrionAbilityTask_DirectedMovement_DirectedMovementToLocation::MovementTargetLocation' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_DirectedMovement_DirectedMovementToLocation, MovementSpaceType) == 0x000014, "Member 'OrionAbilityTask_DirectedMovement_DirectedMovementToLocation::MovementSpaceType' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_DirectedMovement_DirectedMovementToLocation, MovementDuration) == 0x000018, "Member 'OrionAbilityTask_DirectedMovement_DirectedMovementToLocation::MovementDuration' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_DirectedMovement_DirectedMovementToLocation, CloseEnoughDistance) == 0x00001C, "Member 'OrionAbilityTask_DirectedMovement_DirectedMovementToLocation::CloseEnoughDistance' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_DirectedMovement_DirectedMovementToLocation, ModifyZ) == 0x000020, "Member 'OrionAbilityTask_DirectedMovement_DirectedMovementToLocation::ModifyZ' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_DirectedMovement_DirectedMovementToLocation, ReturnValue) == 0x000028, "Member 'OrionAbilityTask_DirectedMovement_DirectedMovementToLocation::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_InstantTargetData.HitScanTube
// 0x00C0 (0x00C0 - 0x0000)
struct OrionAbilityTask_InstantTargetData_HitScanTube final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityTargetingLocationInfo  StartLocation;                                     // 0x0010(0x0070)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         Range;                                             // 0x0080(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlockingRadius;                                    // 0x0084(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverlapRadius;                                     // 0x0088(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCollisionProfileName                  CollisionProfile;                                  // 0x0090(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayTargetDataFilterHandle        Filter;                                            // 0x0098(0x0010)(Parm, NativeAccessSpecifierPublic)
	bool                                          bMultiHit;                                         // 0x00A8(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebug;                                            // 0x00A9(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAbilityTask_InstantTargetData*    ReturnValue;                                       // 0x00B0(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionAbilityTask_InstantTargetData_HitScanTube) == 0x000010, "Wrong alignment on OrionAbilityTask_InstantTargetData_HitScanTube");
static_assert(sizeof(OrionAbilityTask_InstantTargetData_HitScanTube) == 0x0000C0, "Wrong size on OrionAbilityTask_InstantTargetData_HitScanTube");
static_assert(offsetof(OrionAbilityTask_InstantTargetData_HitScanTube, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_InstantTargetData_HitScanTube::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_InstantTargetData_HitScanTube, StartLocation) == 0x000010, "Member 'OrionAbilityTask_InstantTargetData_HitScanTube::StartLocation' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_InstantTargetData_HitScanTube, Range) == 0x000080, "Member 'OrionAbilityTask_InstantTargetData_HitScanTube::Range' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_InstantTargetData_HitScanTube, BlockingRadius) == 0x000084, "Member 'OrionAbilityTask_InstantTargetData_HitScanTube::BlockingRadius' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_InstantTargetData_HitScanTube, OverlapRadius) == 0x000088, "Member 'OrionAbilityTask_InstantTargetData_HitScanTube::OverlapRadius' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_InstantTargetData_HitScanTube, CollisionProfile) == 0x000090, "Member 'OrionAbilityTask_InstantTargetData_HitScanTube::CollisionProfile' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_InstantTargetData_HitScanTube, Filter) == 0x000098, "Member 'OrionAbilityTask_InstantTargetData_HitScanTube::Filter' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_InstantTargetData_HitScanTube, bMultiHit) == 0x0000A8, "Member 'OrionAbilityTask_InstantTargetData_HitScanTube::bMultiHit' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_InstantTargetData_HitScanTube, bDebug) == 0x0000A9, "Member 'OrionAbilityTask_InstantTargetData_HitScanTube::bDebug' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_InstantTargetData_HitScanTube, ReturnValue) == 0x0000B0, "Member 'OrionAbilityTask_InstantTargetData_HitScanTube::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_PlayMontageAndWaitNotifyName.CreatePlayMontageAndWaitProxy
// 0x0038 (0x0038 - 0x0000)
struct OrionAbilityTask_PlayMontageAndWaitNotifyName_CreatePlayMontageAndWaitProxy final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageToPlay;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rate;                                              // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StartSection;                                      // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopWhenAbilityEnds;                              // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAbilityTask_PlayMontageAndWaitNotifyName* ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_PlayMontageAndWaitNotifyName_CreatePlayMontageAndWaitProxy) == 0x000008, "Wrong alignment on OrionAbilityTask_PlayMontageAndWaitNotifyName_CreatePlayMontageAndWaitProxy");
static_assert(sizeof(OrionAbilityTask_PlayMontageAndWaitNotifyName_CreatePlayMontageAndWaitProxy) == 0x000038, "Wrong size on OrionAbilityTask_PlayMontageAndWaitNotifyName_CreatePlayMontageAndWaitProxy");
static_assert(offsetof(OrionAbilityTask_PlayMontageAndWaitNotifyName_CreatePlayMontageAndWaitProxy, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_PlayMontageAndWaitNotifyName_CreatePlayMontageAndWaitProxy::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_PlayMontageAndWaitNotifyName_CreatePlayMontageAndWaitProxy, TaskInstanceName) == 0x000008, "Member 'OrionAbilityTask_PlayMontageAndWaitNotifyName_CreatePlayMontageAndWaitProxy::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_PlayMontageAndWaitNotifyName_CreatePlayMontageAndWaitProxy, MontageToPlay) == 0x000010, "Member 'OrionAbilityTask_PlayMontageAndWaitNotifyName_CreatePlayMontageAndWaitProxy::MontageToPlay' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_PlayMontageAndWaitNotifyName_CreatePlayMontageAndWaitProxy, Rate) == 0x000018, "Member 'OrionAbilityTask_PlayMontageAndWaitNotifyName_CreatePlayMontageAndWaitProxy::Rate' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_PlayMontageAndWaitNotifyName_CreatePlayMontageAndWaitProxy, StartSection) == 0x000020, "Member 'OrionAbilityTask_PlayMontageAndWaitNotifyName_CreatePlayMontageAndWaitProxy::StartSection' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_PlayMontageAndWaitNotifyName_CreatePlayMontageAndWaitProxy, bStopWhenAbilityEnds) == 0x000028, "Member 'OrionAbilityTask_PlayMontageAndWaitNotifyName_CreatePlayMontageAndWaitProxy::bStopWhenAbilityEnds' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_PlayMontageAndWaitNotifyName_CreatePlayMontageAndWaitProxy, ReturnValue) == 0x000030, "Member 'OrionAbilityTask_PlayMontageAndWaitNotifyName_CreatePlayMontageAndWaitProxy::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_PlayMontageAndWaitNotifyName.PlayMontageAndWaitNotifyName
// 0x0038 (0x0038 - 0x0000)
struct OrionAbilityTask_PlayMontageAndWaitNotifyName_PlayMontageAndWaitNotifyName final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageToPlay;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rate;                                              // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StartSection;                                      // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopWhenAbilityEnds;                              // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAbilityTask_PlayMontageAndWaitNotifyName* ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_PlayMontageAndWaitNotifyName_PlayMontageAndWaitNotifyName) == 0x000008, "Wrong alignment on OrionAbilityTask_PlayMontageAndWaitNotifyName_PlayMontageAndWaitNotifyName");
static_assert(sizeof(OrionAbilityTask_PlayMontageAndWaitNotifyName_PlayMontageAndWaitNotifyName) == 0x000038, "Wrong size on OrionAbilityTask_PlayMontageAndWaitNotifyName_PlayMontageAndWaitNotifyName");
static_assert(offsetof(OrionAbilityTask_PlayMontageAndWaitNotifyName_PlayMontageAndWaitNotifyName, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_PlayMontageAndWaitNotifyName_PlayMontageAndWaitNotifyName::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_PlayMontageAndWaitNotifyName_PlayMontageAndWaitNotifyName, TaskInstanceName) == 0x000008, "Member 'OrionAbilityTask_PlayMontageAndWaitNotifyName_PlayMontageAndWaitNotifyName::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_PlayMontageAndWaitNotifyName_PlayMontageAndWaitNotifyName, MontageToPlay) == 0x000010, "Member 'OrionAbilityTask_PlayMontageAndWaitNotifyName_PlayMontageAndWaitNotifyName::MontageToPlay' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_PlayMontageAndWaitNotifyName_PlayMontageAndWaitNotifyName, Rate) == 0x000018, "Member 'OrionAbilityTask_PlayMontageAndWaitNotifyName_PlayMontageAndWaitNotifyName::Rate' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_PlayMontageAndWaitNotifyName_PlayMontageAndWaitNotifyName, StartSection) == 0x000020, "Member 'OrionAbilityTask_PlayMontageAndWaitNotifyName_PlayMontageAndWaitNotifyName::StartSection' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_PlayMontageAndWaitNotifyName_PlayMontageAndWaitNotifyName, bStopWhenAbilityEnds) == 0x000028, "Member 'OrionAbilityTask_PlayMontageAndWaitNotifyName_PlayMontageAndWaitNotifyName::bStopWhenAbilityEnds' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_PlayMontageAndWaitNotifyName_PlayMontageAndWaitNotifyName, ReturnValue) == 0x000030, "Member 'OrionAbilityTask_PlayMontageAndWaitNotifyName_PlayMontageAndWaitNotifyName::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_PlayMontageAndWaitNotifyName.OnMontageBlendingOut
// 0x0010 (0x0010 - 0x0000)
struct OrionAbilityTask_PlayMontageAndWaitNotifyName_OnMontageBlendingOut final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterrupted;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionAbilityTask_PlayMontageAndWaitNotifyName_OnMontageBlendingOut) == 0x000008, "Wrong alignment on OrionAbilityTask_PlayMontageAndWaitNotifyName_OnMontageBlendingOut");
static_assert(sizeof(OrionAbilityTask_PlayMontageAndWaitNotifyName_OnMontageBlendingOut) == 0x000010, "Wrong size on OrionAbilityTask_PlayMontageAndWaitNotifyName_OnMontageBlendingOut");
static_assert(offsetof(OrionAbilityTask_PlayMontageAndWaitNotifyName_OnMontageBlendingOut, Montage) == 0x000000, "Member 'OrionAbilityTask_PlayMontageAndWaitNotifyName_OnMontageBlendingOut::Montage' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_PlayMontageAndWaitNotifyName_OnMontageBlendingOut, bInterrupted) == 0x000008, "Member 'OrionAbilityTask_PlayMontageAndWaitNotifyName_OnMontageBlendingOut::bInterrupted' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_PlayMontageAndWaitNotifyName.OnMontageEnded
// 0x0010 (0x0010 - 0x0000)
struct OrionAbilityTask_PlayMontageAndWaitNotifyName_OnMontageEnded final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterrupted;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionAbilityTask_PlayMontageAndWaitNotifyName_OnMontageEnded) == 0x000008, "Wrong alignment on OrionAbilityTask_PlayMontageAndWaitNotifyName_OnMontageEnded");
static_assert(sizeof(OrionAbilityTask_PlayMontageAndWaitNotifyName_OnMontageEnded) == 0x000010, "Wrong size on OrionAbilityTask_PlayMontageAndWaitNotifyName_OnMontageEnded");
static_assert(offsetof(OrionAbilityTask_PlayMontageAndWaitNotifyName_OnMontageEnded, Montage) == 0x000000, "Member 'OrionAbilityTask_PlayMontageAndWaitNotifyName_OnMontageEnded::Montage' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_PlayMontageAndWaitNotifyName_OnMontageEnded, bInterrupted) == 0x000008, "Member 'OrionAbilityTask_PlayMontageAndWaitNotifyName_OnMontageEnded::bInterrupted' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_PlayMontageAndWaitNotifyName.OnNotifyBeginReceived
// 0x0028 (0x0028 - 0x0000)
struct OrionAbilityTask_PlayMontageAndWaitNotifyName_OnNotifyBeginReceived final
{
public:
	class FName                                   NotifyName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBranchingPointNotifyPayload           BranchingPointNotifyPayload;                       // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_PlayMontageAndWaitNotifyName_OnNotifyBeginReceived) == 0x000008, "Wrong alignment on OrionAbilityTask_PlayMontageAndWaitNotifyName_OnNotifyBeginReceived");
static_assert(sizeof(OrionAbilityTask_PlayMontageAndWaitNotifyName_OnNotifyBeginReceived) == 0x000028, "Wrong size on OrionAbilityTask_PlayMontageAndWaitNotifyName_OnNotifyBeginReceived");
static_assert(offsetof(OrionAbilityTask_PlayMontageAndWaitNotifyName_OnNotifyBeginReceived, NotifyName) == 0x000000, "Member 'OrionAbilityTask_PlayMontageAndWaitNotifyName_OnNotifyBeginReceived::NotifyName' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_PlayMontageAndWaitNotifyName_OnNotifyBeginReceived, BranchingPointNotifyPayload) == 0x000008, "Member 'OrionAbilityTask_PlayMontageAndWaitNotifyName_OnNotifyBeginReceived::BranchingPointNotifyPayload' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_PlayMontageAndWaitNotifyName.OnNotifyEndReceived
// 0x0028 (0x0028 - 0x0000)
struct OrionAbilityTask_PlayMontageAndWaitNotifyName_OnNotifyEndReceived final
{
public:
	class FName                                   NotifyName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBranchingPointNotifyPayload           BranchingPointNotifyPayload;                       // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_PlayMontageAndWaitNotifyName_OnNotifyEndReceived) == 0x000008, "Wrong alignment on OrionAbilityTask_PlayMontageAndWaitNotifyName_OnNotifyEndReceived");
static_assert(sizeof(OrionAbilityTask_PlayMontageAndWaitNotifyName_OnNotifyEndReceived) == 0x000028, "Wrong size on OrionAbilityTask_PlayMontageAndWaitNotifyName_OnNotifyEndReceived");
static_assert(offsetof(OrionAbilityTask_PlayMontageAndWaitNotifyName_OnNotifyEndReceived, NotifyName) == 0x000000, "Member 'OrionAbilityTask_PlayMontageAndWaitNotifyName_OnNotifyEndReceived::NotifyName' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_PlayMontageAndWaitNotifyName_OnNotifyEndReceived, BranchingPointNotifyPayload) == 0x000008, "Member 'OrionAbilityTask_PlayMontageAndWaitNotifyName_OnNotifyEndReceived::BranchingPointNotifyPayload' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_RepeatedAction.PerformRepeatedAction
// 0x0018 (0x0018 - 0x0000)
struct OrionAbilityTask_RepeatedAction_PerformRepeatedAction final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBetweenActions;                                // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalActionCount;                                  // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionAbilityTask_RepeatedAction*       ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_RepeatedAction_PerformRepeatedAction) == 0x000008, "Wrong alignment on OrionAbilityTask_RepeatedAction_PerformRepeatedAction");
static_assert(sizeof(OrionAbilityTask_RepeatedAction_PerformRepeatedAction) == 0x000018, "Wrong size on OrionAbilityTask_RepeatedAction_PerformRepeatedAction");
static_assert(offsetof(OrionAbilityTask_RepeatedAction_PerformRepeatedAction, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_RepeatedAction_PerformRepeatedAction::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_RepeatedAction_PerformRepeatedAction, TimeBetweenActions) == 0x000008, "Member 'OrionAbilityTask_RepeatedAction_PerformRepeatedAction::TimeBetweenActions' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_RepeatedAction_PerformRepeatedAction, TotalActionCount) == 0x00000C, "Member 'OrionAbilityTask_RepeatedAction_PerformRepeatedAction::TotalActionCount' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_RepeatedAction_PerformRepeatedAction, ReturnValue) == 0x000010, "Member 'OrionAbilityTask_RepeatedAction_PerformRepeatedAction::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_SpawnOrionActor.SpawnOrionActor
// 0x0070 (0x0070 - 0x0000)
struct OrionAbilityTask_SpawnOrionActor_SpawnOrionActor final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     Class_0;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             SpawnTransform;                                    // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0040(0x0020)(Parm, NativeAccessSpecifierPublic)
	class UOrionAbilityTask_SpawnOrionActor*      ReturnValue;                                       // 0x0060(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionAbilityTask_SpawnOrionActor_SpawnOrionActor) == 0x000010, "Wrong alignment on OrionAbilityTask_SpawnOrionActor_SpawnOrionActor");
static_assert(sizeof(OrionAbilityTask_SpawnOrionActor_SpawnOrionActor) == 0x000070, "Wrong size on OrionAbilityTask_SpawnOrionActor_SpawnOrionActor");
static_assert(offsetof(OrionAbilityTask_SpawnOrionActor_SpawnOrionActor, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_SpawnOrionActor_SpawnOrionActor::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnOrionActor_SpawnOrionActor, Class_0) == 0x000008, "Member 'OrionAbilityTask_SpawnOrionActor_SpawnOrionActor::Class_0' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnOrionActor_SpawnOrionActor, SpawnTransform) == 0x000010, "Member 'OrionAbilityTask_SpawnOrionActor_SpawnOrionActor::SpawnTransform' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnOrionActor_SpawnOrionActor, TargetData) == 0x000040, "Member 'OrionAbilityTask_SpawnOrionActor_SpawnOrionActor::TargetData' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnOrionActor_SpawnOrionActor, ReturnValue) == 0x000060, "Member 'OrionAbilityTask_SpawnOrionActor_SpawnOrionActor::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_SpawnOrionActor.SpawnOrionActorTargetData
// 0x0038 (0x0038 - 0x0000)
struct OrionAbilityTask_SpawnOrionActor_SpawnOrionActorTargetData final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     Class_0;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0010(0x0020)(Parm, NativeAccessSpecifierPublic)
	class UOrionAbilityTask_SpawnOrionActor*      ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_SpawnOrionActor_SpawnOrionActorTargetData) == 0x000008, "Wrong alignment on OrionAbilityTask_SpawnOrionActor_SpawnOrionActorTargetData");
static_assert(sizeof(OrionAbilityTask_SpawnOrionActor_SpawnOrionActorTargetData) == 0x000038, "Wrong size on OrionAbilityTask_SpawnOrionActor_SpawnOrionActorTargetData");
static_assert(offsetof(OrionAbilityTask_SpawnOrionActor_SpawnOrionActorTargetData, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_SpawnOrionActor_SpawnOrionActorTargetData::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnOrionActor_SpawnOrionActorTargetData, Class_0) == 0x000008, "Member 'OrionAbilityTask_SpawnOrionActor_SpawnOrionActorTargetData::Class_0' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnOrionActor_SpawnOrionActorTargetData, TargetData) == 0x000010, "Member 'OrionAbilityTask_SpawnOrionActor_SpawnOrionActorTargetData::TargetData' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnOrionActor_SpawnOrionActorTargetData, ReturnValue) == 0x000030, "Member 'OrionAbilityTask_SpawnOrionActor_SpawnOrionActorTargetData::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_SpawnOrionActor.SpawnOrionActorTransform
// 0x0050 (0x0050 - 0x0000)
struct OrionAbilityTask_SpawnOrionActor_SpawnOrionActorTransform final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     Class_0;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             SpawnTransform;                                    // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UOrionAbilityTask_SpawnOrionActor*      ReturnValue;                                       // 0x0040(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionAbilityTask_SpawnOrionActor_SpawnOrionActorTransform) == 0x000010, "Wrong alignment on OrionAbilityTask_SpawnOrionActor_SpawnOrionActorTransform");
static_assert(sizeof(OrionAbilityTask_SpawnOrionActor_SpawnOrionActorTransform) == 0x000050, "Wrong size on OrionAbilityTask_SpawnOrionActor_SpawnOrionActorTransform");
static_assert(offsetof(OrionAbilityTask_SpawnOrionActor_SpawnOrionActorTransform, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_SpawnOrionActor_SpawnOrionActorTransform::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnOrionActor_SpawnOrionActorTransform, Class_0) == 0x000008, "Member 'OrionAbilityTask_SpawnOrionActor_SpawnOrionActorTransform::Class_0' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnOrionActor_SpawnOrionActorTransform, SpawnTransform) == 0x000010, "Member 'OrionAbilityTask_SpawnOrionActor_SpawnOrionActorTransform::SpawnTransform' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnOrionActor_SpawnOrionActorTransform, ReturnValue) == 0x000040, "Member 'OrionAbilityTask_SpawnOrionActor_SpawnOrionActorTransform::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_SpawnOrionActor.BeginSpawningActor
// 0x0020 (0x0020 - 0x0000)
struct OrionAbilityTask_SpawnOrionActor_BeginSpawningActor final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     Class_0;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SpawnedActor;                                      // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionAbilityTask_SpawnOrionActor_BeginSpawningActor) == 0x000008, "Wrong alignment on OrionAbilityTask_SpawnOrionActor_BeginSpawningActor");
static_assert(sizeof(OrionAbilityTask_SpawnOrionActor_BeginSpawningActor) == 0x000020, "Wrong size on OrionAbilityTask_SpawnOrionActor_BeginSpawningActor");
static_assert(offsetof(OrionAbilityTask_SpawnOrionActor_BeginSpawningActor, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_SpawnOrionActor_BeginSpawningActor::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnOrionActor_BeginSpawningActor, Class_0) == 0x000008, "Member 'OrionAbilityTask_SpawnOrionActor_BeginSpawningActor::Class_0' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnOrionActor_BeginSpawningActor, SpawnedActor) == 0x000010, "Member 'OrionAbilityTask_SpawnOrionActor_BeginSpawningActor::SpawnedActor' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnOrionActor_BeginSpawningActor, ReturnValue) == 0x000018, "Member 'OrionAbilityTask_SpawnOrionActor_BeginSpawningActor::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_SpawnOrionActor.FinishSpawningActor
// 0x0010 (0x0010 - 0x0000)
struct OrionAbilityTask_SpawnOrionActor_FinishSpawningActor final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SpawnedActor;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_SpawnOrionActor_FinishSpawningActor) == 0x000008, "Wrong alignment on OrionAbilityTask_SpawnOrionActor_FinishSpawningActor");
static_assert(sizeof(OrionAbilityTask_SpawnOrionActor_FinishSpawningActor) == 0x000010, "Wrong size on OrionAbilityTask_SpawnOrionActor_FinishSpawningActor");
static_assert(offsetof(OrionAbilityTask_SpawnOrionActor_FinishSpawningActor, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_SpawnOrionActor_FinishSpawningActor::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnOrionActor_FinishSpawningActor, SpawnedActor) == 0x000008, "Member 'OrionAbilityTask_SpawnOrionActor_FinishSpawningActor::SpawnedActor' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_SpawnProjectile.CloneProjectile
// 0x0048 (0x0048 - 0x0000)
struct OrionAbilityTask_SpawnProjectile_CloneProjectile final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionProjectile*                       SourceProjectile;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0010(0x0020)(Parm, NativeAccessSpecifierPublic)
	float                                         PitchOffset;                                       // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawOffset;                                         // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AOrionProjectile>           Class_0;                                           // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionAbilityTask_SpawnProjectile*      ReturnValue;                                       // 0x0040(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_SpawnProjectile_CloneProjectile) == 0x000008, "Wrong alignment on OrionAbilityTask_SpawnProjectile_CloneProjectile");
static_assert(sizeof(OrionAbilityTask_SpawnProjectile_CloneProjectile) == 0x000048, "Wrong size on OrionAbilityTask_SpawnProjectile_CloneProjectile");
static_assert(offsetof(OrionAbilityTask_SpawnProjectile_CloneProjectile, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_SpawnProjectile_CloneProjectile::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectile_CloneProjectile, SourceProjectile) == 0x000008, "Member 'OrionAbilityTask_SpawnProjectile_CloneProjectile::SourceProjectile' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectile_CloneProjectile, TargetData) == 0x000010, "Member 'OrionAbilityTask_SpawnProjectile_CloneProjectile::TargetData' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectile_CloneProjectile, PitchOffset) == 0x000030, "Member 'OrionAbilityTask_SpawnProjectile_CloneProjectile::PitchOffset' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectile_CloneProjectile, YawOffset) == 0x000034, "Member 'OrionAbilityTask_SpawnProjectile_CloneProjectile::YawOffset' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectile_CloneProjectile, Class_0) == 0x000038, "Member 'OrionAbilityTask_SpawnProjectile_CloneProjectile::Class_0' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectile_CloneProjectile, ReturnValue) == 0x000040, "Member 'OrionAbilityTask_SpawnProjectile_CloneProjectile::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_SpawnProjectile.SpawnProjectile
// 0x0040 (0x0040 - 0x0000)
struct OrionAbilityTask_SpawnProjectile_SpawnProjectile final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0008(0x0020)(Parm, NativeAccessSpecifierPublic)
	float                                         PitchOffset;                                       // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawOffset;                                         // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AOrionProjectile>           Class_0;                                           // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionAbilityTask_SpawnProjectile*      ReturnValue;                                       // 0x0038(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_SpawnProjectile_SpawnProjectile) == 0x000008, "Wrong alignment on OrionAbilityTask_SpawnProjectile_SpawnProjectile");
static_assert(sizeof(OrionAbilityTask_SpawnProjectile_SpawnProjectile) == 0x000040, "Wrong size on OrionAbilityTask_SpawnProjectile_SpawnProjectile");
static_assert(offsetof(OrionAbilityTask_SpawnProjectile_SpawnProjectile, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_SpawnProjectile_SpawnProjectile::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectile_SpawnProjectile, TargetData) == 0x000008, "Member 'OrionAbilityTask_SpawnProjectile_SpawnProjectile::TargetData' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectile_SpawnProjectile, PitchOffset) == 0x000028, "Member 'OrionAbilityTask_SpawnProjectile_SpawnProjectile::PitchOffset' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectile_SpawnProjectile, YawOffset) == 0x00002C, "Member 'OrionAbilityTask_SpawnProjectile_SpawnProjectile::YawOffset' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectile_SpawnProjectile, Class_0) == 0x000030, "Member 'OrionAbilityTask_SpawnProjectile_SpawnProjectile::Class_0' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectile_SpawnProjectile, ReturnValue) == 0x000038, "Member 'OrionAbilityTask_SpawnProjectile_SpawnProjectile::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_SpawnProjectile.BeginSpawningActor
// 0x0040 (0x0040 - 0x0000)
struct OrionAbilityTask_SpawnProjectile_BeginSpawningActor final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0008(0x0020)(Parm, NativeAccessSpecifierPublic)
	TSubclassOf<class AOrionProjectile>           Class_0;                                           // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionProjectile*                       SpawnedActor;                                      // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionAbilityTask_SpawnProjectile_BeginSpawningActor) == 0x000008, "Wrong alignment on OrionAbilityTask_SpawnProjectile_BeginSpawningActor");
static_assert(sizeof(OrionAbilityTask_SpawnProjectile_BeginSpawningActor) == 0x000040, "Wrong size on OrionAbilityTask_SpawnProjectile_BeginSpawningActor");
static_assert(offsetof(OrionAbilityTask_SpawnProjectile_BeginSpawningActor, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_SpawnProjectile_BeginSpawningActor::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectile_BeginSpawningActor, TargetData) == 0x000008, "Member 'OrionAbilityTask_SpawnProjectile_BeginSpawningActor::TargetData' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectile_BeginSpawningActor, Class_0) == 0x000028, "Member 'OrionAbilityTask_SpawnProjectile_BeginSpawningActor::Class_0' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectile_BeginSpawningActor, SpawnedActor) == 0x000030, "Member 'OrionAbilityTask_SpawnProjectile_BeginSpawningActor::SpawnedActor' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectile_BeginSpawningActor, ReturnValue) == 0x000038, "Member 'OrionAbilityTask_SpawnProjectile_BeginSpawningActor::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_SpawnProjectile.FinishSpawningActor
// 0x0030 (0x0030 - 0x0000)
struct OrionAbilityTask_SpawnProjectile_FinishSpawningActor final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0008(0x0020)(Parm, NativeAccessSpecifierPublic)
	class AOrionProjectile*                       SpawnedActor;                                      // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_SpawnProjectile_FinishSpawningActor) == 0x000008, "Wrong alignment on OrionAbilityTask_SpawnProjectile_FinishSpawningActor");
static_assert(sizeof(OrionAbilityTask_SpawnProjectile_FinishSpawningActor) == 0x000030, "Wrong size on OrionAbilityTask_SpawnProjectile_FinishSpawningActor");
static_assert(offsetof(OrionAbilityTask_SpawnProjectile_FinishSpawningActor, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_SpawnProjectile_FinishSpawningActor::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectile_FinishSpawningActor, TargetData) == 0x000008, "Member 'OrionAbilityTask_SpawnProjectile_FinishSpawningActor::TargetData' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectile_FinishSpawningActor, SpawnedActor) == 0x000028, "Member 'OrionAbilityTask_SpawnProjectile_FinishSpawningActor::SpawnedActor' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_SpawnProjectileMulti.SpawnProjectileMulti
// 0x0038 (0x0038 - 0x0000)
struct OrionAbilityTask_SpawnProjectileMulti_SpawnProjectileMulti final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetDataArray;                                   // 0x0008(0x0020)(Parm, NativeAccessSpecifierPublic)
	TSubclassOf<class AOrionProjectile>           Class_0;                                           // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionAbilityTask_SpawnProjectileMulti* ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_SpawnProjectileMulti_SpawnProjectileMulti) == 0x000008, "Wrong alignment on OrionAbilityTask_SpawnProjectileMulti_SpawnProjectileMulti");
static_assert(sizeof(OrionAbilityTask_SpawnProjectileMulti_SpawnProjectileMulti) == 0x000038, "Wrong size on OrionAbilityTask_SpawnProjectileMulti_SpawnProjectileMulti");
static_assert(offsetof(OrionAbilityTask_SpawnProjectileMulti_SpawnProjectileMulti, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_SpawnProjectileMulti_SpawnProjectileMulti::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectileMulti_SpawnProjectileMulti, TargetDataArray) == 0x000008, "Member 'OrionAbilityTask_SpawnProjectileMulti_SpawnProjectileMulti::TargetDataArray' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectileMulti_SpawnProjectileMulti, Class_0) == 0x000028, "Member 'OrionAbilityTask_SpawnProjectileMulti_SpawnProjectileMulti::Class_0' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectileMulti_SpawnProjectileMulti, ReturnValue) == 0x000030, "Member 'OrionAbilityTask_SpawnProjectileMulti_SpawnProjectileMulti::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_SpawnProjectileMulti.BeginSpawningActorArray
// 0x0050 (0x0050 - 0x0000)
struct OrionAbilityTask_SpawnProjectileMulti_BeginSpawningActorArray final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetDataArray;                                   // 0x0008(0x0020)(Parm, NativeAccessSpecifierPublic)
	TSubclassOf<class AOrionProjectile>           Class_0;                                           // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AOrionProjectile*>               SpawnedActor;                                      // 0x0030(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	class AOrionProjectile*                       SpawnedProjectile;                                 // 0x0040(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0048(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionAbilityTask_SpawnProjectileMulti_BeginSpawningActorArray) == 0x000008, "Wrong alignment on OrionAbilityTask_SpawnProjectileMulti_BeginSpawningActorArray");
static_assert(sizeof(OrionAbilityTask_SpawnProjectileMulti_BeginSpawningActorArray) == 0x000050, "Wrong size on OrionAbilityTask_SpawnProjectileMulti_BeginSpawningActorArray");
static_assert(offsetof(OrionAbilityTask_SpawnProjectileMulti_BeginSpawningActorArray, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_SpawnProjectileMulti_BeginSpawningActorArray::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectileMulti_BeginSpawningActorArray, TargetDataArray) == 0x000008, "Member 'OrionAbilityTask_SpawnProjectileMulti_BeginSpawningActorArray::TargetDataArray' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectileMulti_BeginSpawningActorArray, Class_0) == 0x000028, "Member 'OrionAbilityTask_SpawnProjectileMulti_BeginSpawningActorArray::Class_0' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectileMulti_BeginSpawningActorArray, SpawnedActor) == 0x000030, "Member 'OrionAbilityTask_SpawnProjectileMulti_BeginSpawningActorArray::SpawnedActor' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectileMulti_BeginSpawningActorArray, SpawnedProjectile) == 0x000040, "Member 'OrionAbilityTask_SpawnProjectileMulti_BeginSpawningActorArray::SpawnedProjectile' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectileMulti_BeginSpawningActorArray, ReturnValue) == 0x000048, "Member 'OrionAbilityTask_SpawnProjectileMulti_BeginSpawningActorArray::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_SpawnProjectileMulti.FinishSpawningActorArray
// 0x0038 (0x0038 - 0x0000)
struct OrionAbilityTask_SpawnProjectileMulti_FinishSpawningActorArray final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetDataArray;                                   // 0x0008(0x0020)(Parm, NativeAccessSpecifierPublic)
	TArray<class AOrionProjectile*>               SpawnedActor;                                      // 0x0028(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_SpawnProjectileMulti_FinishSpawningActorArray) == 0x000008, "Wrong alignment on OrionAbilityTask_SpawnProjectileMulti_FinishSpawningActorArray");
static_assert(sizeof(OrionAbilityTask_SpawnProjectileMulti_FinishSpawningActorArray) == 0x000038, "Wrong size on OrionAbilityTask_SpawnProjectileMulti_FinishSpawningActorArray");
static_assert(offsetof(OrionAbilityTask_SpawnProjectileMulti_FinishSpawningActorArray, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_SpawnProjectileMulti_FinishSpawningActorArray::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectileMulti_FinishSpawningActorArray, TargetDataArray) == 0x000008, "Member 'OrionAbilityTask_SpawnProjectileMulti_FinishSpawningActorArray::TargetDataArray' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectileMulti_FinishSpawningActorArray, SpawnedActor) == 0x000028, "Member 'OrionAbilityTask_SpawnProjectileMulti_FinishSpawningActorArray::SpawnedActor' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire.SpawnProjectileMulti_HorizontalSpread
// 0x0050 (0x0050 - 0x0000)
struct OrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire_SpawnProjectileMulti_HorizontalSpread final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0008(0x0020)(Parm, NativeAccessSpecifierPublic)
	int32                                         ProjectileCount;                                   // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchRandom;                                       // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchOffset;                                       // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawRange;                                          // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawOffset;                                         // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AOrionProjectile>           Class_0;                                           // 0x0040(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire* ReturnValue;                                       // 0x0048(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire_SpawnProjectileMulti_HorizontalSpread) == 0x000008, "Wrong alignment on OrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire_SpawnProjectileMulti_HorizontalSpread");
static_assert(sizeof(OrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire_SpawnProjectileMulti_HorizontalSpread) == 0x000050, "Wrong size on OrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire_SpawnProjectileMulti_HorizontalSpread");
static_assert(offsetof(OrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire_SpawnProjectileMulti_HorizontalSpread, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire_SpawnProjectileMulti_HorizontalSpread::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire_SpawnProjectileMulti_HorizontalSpread, TargetData) == 0x000008, "Member 'OrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire_SpawnProjectileMulti_HorizontalSpread::TargetData' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire_SpawnProjectileMulti_HorizontalSpread, ProjectileCount) == 0x000028, "Member 'OrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire_SpawnProjectileMulti_HorizontalSpread::ProjectileCount' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire_SpawnProjectileMulti_HorizontalSpread, PitchRandom) == 0x00002C, "Member 'OrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire_SpawnProjectileMulti_HorizontalSpread::PitchRandom' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire_SpawnProjectileMulti_HorizontalSpread, PitchOffset) == 0x000030, "Member 'OrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire_SpawnProjectileMulti_HorizontalSpread::PitchOffset' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire_SpawnProjectileMulti_HorizontalSpread, YawRange) == 0x000034, "Member 'OrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire_SpawnProjectileMulti_HorizontalSpread::YawRange' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire_SpawnProjectileMulti_HorizontalSpread, YawOffset) == 0x000038, "Member 'OrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire_SpawnProjectileMulti_HorizontalSpread::YawOffset' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire_SpawnProjectileMulti_HorizontalSpread, Class_0) == 0x000040, "Member 'OrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire_SpawnProjectileMulti_HorizontalSpread::Class_0' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire_SpawnProjectileMulti_HorizontalSpread, ReturnValue) == 0x000048, "Member 'OrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire_SpawnProjectileMulti_HorizontalSpread::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_SpawnProjectileMulti_Cone.SpawnProjectileMulti_Cone
// 0x0050 (0x0050 - 0x0000)
struct OrionAbilityTask_SpawnProjectileMulti_Cone_SpawnProjectileMulti_Cone final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0008(0x0020)(Parm, NativeAccessSpecifierPublic)
	int32                                         ProjectileCount;                                   // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchRandom;                                       // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchOffset;                                       // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawRandom;                                         // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawOffset;                                         // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AOrionProjectile>           Class_0;                                           // 0x0040(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionAbilityTask_SpawnProjectileMulti_Cone* ReturnValue;                                       // 0x0048(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_SpawnProjectileMulti_Cone_SpawnProjectileMulti_Cone) == 0x000008, "Wrong alignment on OrionAbilityTask_SpawnProjectileMulti_Cone_SpawnProjectileMulti_Cone");
static_assert(sizeof(OrionAbilityTask_SpawnProjectileMulti_Cone_SpawnProjectileMulti_Cone) == 0x000050, "Wrong size on OrionAbilityTask_SpawnProjectileMulti_Cone_SpawnProjectileMulti_Cone");
static_assert(offsetof(OrionAbilityTask_SpawnProjectileMulti_Cone_SpawnProjectileMulti_Cone, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_SpawnProjectileMulti_Cone_SpawnProjectileMulti_Cone::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectileMulti_Cone_SpawnProjectileMulti_Cone, TargetData) == 0x000008, "Member 'OrionAbilityTask_SpawnProjectileMulti_Cone_SpawnProjectileMulti_Cone::TargetData' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectileMulti_Cone_SpawnProjectileMulti_Cone, ProjectileCount) == 0x000028, "Member 'OrionAbilityTask_SpawnProjectileMulti_Cone_SpawnProjectileMulti_Cone::ProjectileCount' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectileMulti_Cone_SpawnProjectileMulti_Cone, PitchRandom) == 0x00002C, "Member 'OrionAbilityTask_SpawnProjectileMulti_Cone_SpawnProjectileMulti_Cone::PitchRandom' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectileMulti_Cone_SpawnProjectileMulti_Cone, PitchOffset) == 0x000030, "Member 'OrionAbilityTask_SpawnProjectileMulti_Cone_SpawnProjectileMulti_Cone::PitchOffset' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectileMulti_Cone_SpawnProjectileMulti_Cone, YawRandom) == 0x000034, "Member 'OrionAbilityTask_SpawnProjectileMulti_Cone_SpawnProjectileMulti_Cone::YawRandom' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectileMulti_Cone_SpawnProjectileMulti_Cone, YawOffset) == 0x000038, "Member 'OrionAbilityTask_SpawnProjectileMulti_Cone_SpawnProjectileMulti_Cone::YawOffset' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectileMulti_Cone_SpawnProjectileMulti_Cone, Class_0) == 0x000040, "Member 'OrionAbilityTask_SpawnProjectileMulti_Cone_SpawnProjectileMulti_Cone::Class_0' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnProjectileMulti_Cone_SpawnProjectileMulti_Cone, ReturnValue) == 0x000048, "Member 'OrionAbilityTask_SpawnProjectileMulti_Cone_SpawnProjectileMulti_Cone::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_SpawnRig.SpawnRig
// 0x0040 (0x0040 - 0x0000)
struct OrionAbilityTask_SpawnRig_SpawnRig final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0008(0x0020)(Parm, NativeAccessSpecifierPublic)
	EOrionTeam                                    RigTeamNum;                                        // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AOrionRigs>                 Class_0;                                           // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionAbilityTask_SpawnRig*             ReturnValue;                                       // 0x0038(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_SpawnRig_SpawnRig) == 0x000008, "Wrong alignment on OrionAbilityTask_SpawnRig_SpawnRig");
static_assert(sizeof(OrionAbilityTask_SpawnRig_SpawnRig) == 0x000040, "Wrong size on OrionAbilityTask_SpawnRig_SpawnRig");
static_assert(offsetof(OrionAbilityTask_SpawnRig_SpawnRig, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_SpawnRig_SpawnRig::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnRig_SpawnRig, TargetData) == 0x000008, "Member 'OrionAbilityTask_SpawnRig_SpawnRig::TargetData' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnRig_SpawnRig, RigTeamNum) == 0x000028, "Member 'OrionAbilityTask_SpawnRig_SpawnRig::RigTeamNum' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnRig_SpawnRig, Class_0) == 0x000030, "Member 'OrionAbilityTask_SpawnRig_SpawnRig::Class_0' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnRig_SpawnRig, ReturnValue) == 0x000038, "Member 'OrionAbilityTask_SpawnRig_SpawnRig::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_SpawnRig.BeginSpawningActor
// 0x0040 (0x0040 - 0x0000)
struct OrionAbilityTask_SpawnRig_BeginSpawningActor final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0008(0x0020)(Parm, NativeAccessSpecifierPublic)
	TSubclassOf<class AOrionRigs>                 Class_0;                                           // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionRigs*                             SpawnedActor;                                      // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionAbilityTask_SpawnRig_BeginSpawningActor) == 0x000008, "Wrong alignment on OrionAbilityTask_SpawnRig_BeginSpawningActor");
static_assert(sizeof(OrionAbilityTask_SpawnRig_BeginSpawningActor) == 0x000040, "Wrong size on OrionAbilityTask_SpawnRig_BeginSpawningActor");
static_assert(offsetof(OrionAbilityTask_SpawnRig_BeginSpawningActor, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_SpawnRig_BeginSpawningActor::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnRig_BeginSpawningActor, TargetData) == 0x000008, "Member 'OrionAbilityTask_SpawnRig_BeginSpawningActor::TargetData' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnRig_BeginSpawningActor, Class_0) == 0x000028, "Member 'OrionAbilityTask_SpawnRig_BeginSpawningActor::Class_0' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnRig_BeginSpawningActor, SpawnedActor) == 0x000030, "Member 'OrionAbilityTask_SpawnRig_BeginSpawningActor::SpawnedActor' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnRig_BeginSpawningActor, ReturnValue) == 0x000038, "Member 'OrionAbilityTask_SpawnRig_BeginSpawningActor::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_SpawnRig.FinishSpawningActor
// 0x0030 (0x0030 - 0x0000)
struct OrionAbilityTask_SpawnRig_FinishSpawningActor final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0008(0x0020)(Parm, NativeAccessSpecifierPublic)
	class AOrionRigs*                             SpawnedActor;                                      // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_SpawnRig_FinishSpawningActor) == 0x000008, "Wrong alignment on OrionAbilityTask_SpawnRig_FinishSpawningActor");
static_assert(sizeof(OrionAbilityTask_SpawnRig_FinishSpawningActor) == 0x000030, "Wrong size on OrionAbilityTask_SpawnRig_FinishSpawningActor");
static_assert(offsetof(OrionAbilityTask_SpawnRig_FinishSpawningActor, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_SpawnRig_FinishSpawningActor::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnRig_FinishSpawningActor, TargetData) == 0x000008, "Member 'OrionAbilityTask_SpawnRig_FinishSpawningActor::TargetData' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnRig_FinishSpawningActor, SpawnedActor) == 0x000028, "Member 'OrionAbilityTask_SpawnRig_FinishSpawningActor::SpawnedActor' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_SpawnWard.SpawnWard
// 0x0040 (0x0040 - 0x0000)
struct OrionAbilityTask_SpawnWard_SpawnWard final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0008(0x0020)(Parm, NativeAccessSpecifierPublic)
	EOrionTeam                                    TeamNum;                                           // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AOrionVisionWard>           Class_0;                                           // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionAbilityTask_SpawnWard*            ReturnValue;                                       // 0x0038(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_SpawnWard_SpawnWard) == 0x000008, "Wrong alignment on OrionAbilityTask_SpawnWard_SpawnWard");
static_assert(sizeof(OrionAbilityTask_SpawnWard_SpawnWard) == 0x000040, "Wrong size on OrionAbilityTask_SpawnWard_SpawnWard");
static_assert(offsetof(OrionAbilityTask_SpawnWard_SpawnWard, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_SpawnWard_SpawnWard::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnWard_SpawnWard, TargetData) == 0x000008, "Member 'OrionAbilityTask_SpawnWard_SpawnWard::TargetData' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnWard_SpawnWard, TeamNum) == 0x000028, "Member 'OrionAbilityTask_SpawnWard_SpawnWard::TeamNum' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnWard_SpawnWard, Class_0) == 0x000030, "Member 'OrionAbilityTask_SpawnWard_SpawnWard::Class_0' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnWard_SpawnWard, ReturnValue) == 0x000038, "Member 'OrionAbilityTask_SpawnWard_SpawnWard::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_SpawnWard.BeginSpawningActor
// 0x0040 (0x0040 - 0x0000)
struct OrionAbilityTask_SpawnWard_BeginSpawningActor final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0008(0x0020)(Parm, NativeAccessSpecifierPublic)
	TSubclassOf<class AOrionVisionWard>           Class_0;                                           // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionVisionWard*                       SpawnedActor;                                      // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionAbilityTask_SpawnWard_BeginSpawningActor) == 0x000008, "Wrong alignment on OrionAbilityTask_SpawnWard_BeginSpawningActor");
static_assert(sizeof(OrionAbilityTask_SpawnWard_BeginSpawningActor) == 0x000040, "Wrong size on OrionAbilityTask_SpawnWard_BeginSpawningActor");
static_assert(offsetof(OrionAbilityTask_SpawnWard_BeginSpawningActor, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_SpawnWard_BeginSpawningActor::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnWard_BeginSpawningActor, TargetData) == 0x000008, "Member 'OrionAbilityTask_SpawnWard_BeginSpawningActor::TargetData' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnWard_BeginSpawningActor, Class_0) == 0x000028, "Member 'OrionAbilityTask_SpawnWard_BeginSpawningActor::Class_0' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnWard_BeginSpawningActor, SpawnedActor) == 0x000030, "Member 'OrionAbilityTask_SpawnWard_BeginSpawningActor::SpawnedActor' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnWard_BeginSpawningActor, ReturnValue) == 0x000038, "Member 'OrionAbilityTask_SpawnWard_BeginSpawningActor::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_SpawnWard.FinishSpawningActor
// 0x0030 (0x0030 - 0x0000)
struct OrionAbilityTask_SpawnWard_FinishSpawningActor final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0008(0x0020)(Parm, NativeAccessSpecifierPublic)
	class AOrionVisionWard*                       SpawnedActor;                                      // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_SpawnWard_FinishSpawningActor) == 0x000008, "Wrong alignment on OrionAbilityTask_SpawnWard_FinishSpawningActor");
static_assert(sizeof(OrionAbilityTask_SpawnWard_FinishSpawningActor) == 0x000030, "Wrong size on OrionAbilityTask_SpawnWard_FinishSpawningActor");
static_assert(offsetof(OrionAbilityTask_SpawnWard_FinishSpawningActor, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_SpawnWard_FinishSpawningActor::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnWard_FinishSpawningActor, TargetData) == 0x000008, "Member 'OrionAbilityTask_SpawnWard_FinishSpawningActor::TargetData' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_SpawnWard_FinishSpawningActor, SpawnedActor) == 0x000028, "Member 'OrionAbilityTask_SpawnWard_FinishSpawningActor::SpawnedActor' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_WaitAbilityLevelUp.WaitAbilityLevelUp
// 0x0020 (0x0020 - 0x0000)
struct OrionAbilityTask_WaitAbilityLevelUp_WaitAbilityLevelUp final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AbilityTag;                                        // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OnlyTriggerOnce;                                   // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAbilityTask_WaitAbilityLevelUp*   ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_WaitAbilityLevelUp_WaitAbilityLevelUp) == 0x000008, "Wrong alignment on OrionAbilityTask_WaitAbilityLevelUp_WaitAbilityLevelUp");
static_assert(sizeof(OrionAbilityTask_WaitAbilityLevelUp_WaitAbilityLevelUp) == 0x000020, "Wrong size on OrionAbilityTask_WaitAbilityLevelUp_WaitAbilityLevelUp");
static_assert(offsetof(OrionAbilityTask_WaitAbilityLevelUp_WaitAbilityLevelUp, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_WaitAbilityLevelUp_WaitAbilityLevelUp::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitAbilityLevelUp_WaitAbilityLevelUp, AbilityTag) == 0x000008, "Member 'OrionAbilityTask_WaitAbilityLevelUp_WaitAbilityLevelUp::AbilityTag' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitAbilityLevelUp_WaitAbilityLevelUp, OnlyTriggerOnce) == 0x000010, "Member 'OrionAbilityTask_WaitAbilityLevelUp_WaitAbilityLevelUp::OnlyTriggerOnce' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitAbilityLevelUp_WaitAbilityLevelUp, ReturnValue) == 0x000018, "Member 'OrionAbilityTask_WaitAbilityLevelUp_WaitAbilityLevelUp::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_WaitAbilityLevelUp.WaitThisAbilityLevelUp
// 0x0018 (0x0018 - 0x0000)
struct OrionAbilityTask_WaitAbilityLevelUp_WaitThisAbilityLevelUp final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OnlyTriggerOnce;                                   // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAbilityTask_WaitAbilityLevelUp*   ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_WaitAbilityLevelUp_WaitThisAbilityLevelUp) == 0x000008, "Wrong alignment on OrionAbilityTask_WaitAbilityLevelUp_WaitThisAbilityLevelUp");
static_assert(sizeof(OrionAbilityTask_WaitAbilityLevelUp_WaitThisAbilityLevelUp) == 0x000018, "Wrong size on OrionAbilityTask_WaitAbilityLevelUp_WaitThisAbilityLevelUp");
static_assert(offsetof(OrionAbilityTask_WaitAbilityLevelUp_WaitThisAbilityLevelUp, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_WaitAbilityLevelUp_WaitThisAbilityLevelUp::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitAbilityLevelUp_WaitThisAbilityLevelUp, OnlyTriggerOnce) == 0x000008, "Member 'OrionAbilityTask_WaitAbilityLevelUp_WaitThisAbilityLevelUp::OnlyTriggerOnce' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitAbilityLevelUp_WaitThisAbilityLevelUp, ReturnValue) == 0x000010, "Member 'OrionAbilityTask_WaitAbilityLevelUp_WaitThisAbilityLevelUp::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_WaitReactivate.WaitAbilityReactivate
// 0x0060 (0x0060 - 0x0000)
struct OrionAbilityTask_WaitReactivate_WaitAbilityReactivate final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionAbilityActivationGroup                  NewActivationGroup;                                // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagRequirements               AdditionalAbilityInputToListenFor;                 // 0x0010(0x0040)(Parm, NativeAccessSpecifierPublic)
	bool                                          TriggerOnlyOnce;                                   // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAbilityTask_WaitReactivate*       ReturnValue;                                       // 0x0058(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_WaitReactivate_WaitAbilityReactivate) == 0x000008, "Wrong alignment on OrionAbilityTask_WaitReactivate_WaitAbilityReactivate");
static_assert(sizeof(OrionAbilityTask_WaitReactivate_WaitAbilityReactivate) == 0x000060, "Wrong size on OrionAbilityTask_WaitReactivate_WaitAbilityReactivate");
static_assert(offsetof(OrionAbilityTask_WaitReactivate_WaitAbilityReactivate, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_WaitReactivate_WaitAbilityReactivate::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitReactivate_WaitAbilityReactivate, NewActivationGroup) == 0x000008, "Member 'OrionAbilityTask_WaitReactivate_WaitAbilityReactivate::NewActivationGroup' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitReactivate_WaitAbilityReactivate, AdditionalAbilityInputToListenFor) == 0x000010, "Member 'OrionAbilityTask_WaitReactivate_WaitAbilityReactivate::AdditionalAbilityInputToListenFor' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitReactivate_WaitAbilityReactivate, TriggerOnlyOnce) == 0x000050, "Member 'OrionAbilityTask_WaitReactivate_WaitAbilityReactivate::TriggerOnlyOnce' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitReactivate_WaitAbilityReactivate, ReturnValue) == 0x000058, "Member 'OrionAbilityTask_WaitReactivate_WaitAbilityReactivate::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_WaitAnyAbilityInput.WaitAnyAbilityInput
// 0x0058 (0x0058 - 0x0000)
struct OrionAbilityTask_WaitAnyAbilityInput_WaitAnyAbilityInput final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               TagRequirements;                                   // 0x0008(0x0040)(Parm, NativeAccessSpecifierPublic)
	bool                                          bConsumeInput;                                     // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAbilityTask_WaitAnyAbilityInput*  ReturnValue;                                       // 0x0050(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_WaitAnyAbilityInput_WaitAnyAbilityInput) == 0x000008, "Wrong alignment on OrionAbilityTask_WaitAnyAbilityInput_WaitAnyAbilityInput");
static_assert(sizeof(OrionAbilityTask_WaitAnyAbilityInput_WaitAnyAbilityInput) == 0x000058, "Wrong size on OrionAbilityTask_WaitAnyAbilityInput_WaitAnyAbilityInput");
static_assert(offsetof(OrionAbilityTask_WaitAnyAbilityInput_WaitAnyAbilityInput, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_WaitAnyAbilityInput_WaitAnyAbilityInput::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitAnyAbilityInput_WaitAnyAbilityInput, TagRequirements) == 0x000008, "Member 'OrionAbilityTask_WaitAnyAbilityInput_WaitAnyAbilityInput::TagRequirements' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitAnyAbilityInput_WaitAnyAbilityInput, bConsumeInput) == 0x000048, "Member 'OrionAbilityTask_WaitAnyAbilityInput_WaitAnyAbilityInput::bConsumeInput' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitAnyAbilityInput_WaitAnyAbilityInput, ReturnValue) == 0x000050, "Member 'OrionAbilityTask_WaitAnyAbilityInput_WaitAnyAbilityInput::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_WaitDamage.WaitDamageDealt
// 0x0090 (0x0090 - 0x0000)
struct OrionAbilityTask_WaitDamage_WaitDamageDealt final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDamageQualifierKeywordsWithContext    AdditionalQualifiers;                              // 0x0008(0x0078)(Parm, NativeAccessSpecifierPublic)
	bool                                          TriggerOnce;                                       // 0x0080(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAbilityTask_WaitDamage*           ReturnValue;                                       // 0x0088(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_WaitDamage_WaitDamageDealt) == 0x000008, "Wrong alignment on OrionAbilityTask_WaitDamage_WaitDamageDealt");
static_assert(sizeof(OrionAbilityTask_WaitDamage_WaitDamageDealt) == 0x000090, "Wrong size on OrionAbilityTask_WaitDamage_WaitDamageDealt");
static_assert(offsetof(OrionAbilityTask_WaitDamage_WaitDamageDealt, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_WaitDamage_WaitDamageDealt::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitDamage_WaitDamageDealt, AdditionalQualifiers) == 0x000008, "Member 'OrionAbilityTask_WaitDamage_WaitDamageDealt::AdditionalQualifiers' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitDamage_WaitDamageDealt, TriggerOnce) == 0x000080, "Member 'OrionAbilityTask_WaitDamage_WaitDamageDealt::TriggerOnce' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitDamage_WaitDamageDealt, ReturnValue) == 0x000088, "Member 'OrionAbilityTask_WaitDamage_WaitDamageDealt::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_WaitDamage.WaitDamageTaken
// 0x0090 (0x0090 - 0x0000)
struct OrionAbilityTask_WaitDamage_WaitDamageTaken final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDamageQualifierKeywordsWithContext    AdditionalQualifiers;                              // 0x0008(0x0078)(Parm, NativeAccessSpecifierPublic)
	bool                                          TriggerOnce;                                       // 0x0080(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAbilityTask_WaitDamage*           ReturnValue;                                       // 0x0088(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_WaitDamage_WaitDamageTaken) == 0x000008, "Wrong alignment on OrionAbilityTask_WaitDamage_WaitDamageTaken");
static_assert(sizeof(OrionAbilityTask_WaitDamage_WaitDamageTaken) == 0x000090, "Wrong size on OrionAbilityTask_WaitDamage_WaitDamageTaken");
static_assert(offsetof(OrionAbilityTask_WaitDamage_WaitDamageTaken, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_WaitDamage_WaitDamageTaken::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitDamage_WaitDamageTaken, AdditionalQualifiers) == 0x000008, "Member 'OrionAbilityTask_WaitDamage_WaitDamageTaken::AdditionalQualifiers' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitDamage_WaitDamageTaken, TriggerOnce) == 0x000080, "Member 'OrionAbilityTask_WaitDamage_WaitDamageTaken::TriggerOnce' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitDamage_WaitDamageTaken, ReturnValue) == 0x000088, "Member 'OrionAbilityTask_WaitDamage_WaitDamageTaken::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_WaitEventKeyword.WaitEventKeyword
// 0x00A8 (0x00A8 - 0x0000)
struct OrionAbilityTask_WaitEventKeyword_WaitEventKeyword final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEventKeywordWithQualifiers            EventInfo;                                         // 0x0008(0x0090)(Parm, NativeAccessSpecifierPublic)
	bool                                          TriggerOnce;                                       // 0x0098(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAbilityTask_WaitEventKeyword*     ReturnValue;                                       // 0x00A0(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_WaitEventKeyword_WaitEventKeyword) == 0x000008, "Wrong alignment on OrionAbilityTask_WaitEventKeyword_WaitEventKeyword");
static_assert(sizeof(OrionAbilityTask_WaitEventKeyword_WaitEventKeyword) == 0x0000A8, "Wrong size on OrionAbilityTask_WaitEventKeyword_WaitEventKeyword");
static_assert(offsetof(OrionAbilityTask_WaitEventKeyword_WaitEventKeyword, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_WaitEventKeyword_WaitEventKeyword::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitEventKeyword_WaitEventKeyword, EventInfo) == 0x000008, "Member 'OrionAbilityTask_WaitEventKeyword_WaitEventKeyword::EventInfo' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitEventKeyword_WaitEventKeyword, TriggerOnce) == 0x000098, "Member 'OrionAbilityTask_WaitEventKeyword_WaitEventKeyword::TriggerOnce' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitEventKeyword_WaitEventKeyword, ReturnValue) == 0x0000A0, "Member 'OrionAbilityTask_WaitEventKeyword_WaitEventKeyword::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_WaitForCombo.WaitForCombo
// 0x0010 (0x0010 - 0x0000)
struct OrionAbilityTask_WaitForCombo_WaitForCombo final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionAbilityTask_WaitForCombo*         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_WaitForCombo_WaitForCombo) == 0x000008, "Wrong alignment on OrionAbilityTask_WaitForCombo_WaitForCombo");
static_assert(sizeof(OrionAbilityTask_WaitForCombo_WaitForCombo) == 0x000010, "Wrong size on OrionAbilityTask_WaitForCombo_WaitForCombo");
static_assert(offsetof(OrionAbilityTask_WaitForCombo_WaitForCombo, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_WaitForCombo_WaitForCombo::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitForCombo_WaitForCombo, ReturnValue) == 0x000008, "Member 'OrionAbilityTask_WaitForCombo_WaitForCombo::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionButtonStyle.GetButtonPadding
// 0x0014 (0x0014 - 0x0000)
struct OrionButtonStyle_GetButtonPadding final
{
public:
	EOrionWidgetStyleSize                         Size;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMargin                                OutButtonPadding;                                  // 0x0004(0x0010)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionButtonStyle_GetButtonPadding) == 0x000004, "Wrong alignment on OrionButtonStyle_GetButtonPadding");
static_assert(sizeof(OrionButtonStyle_GetButtonPadding) == 0x000014, "Wrong size on OrionButtonStyle_GetButtonPadding");
static_assert(offsetof(OrionButtonStyle_GetButtonPadding, Size) == 0x000000, "Member 'OrionButtonStyle_GetButtonPadding::Size' has a wrong offset!");
static_assert(offsetof(OrionButtonStyle_GetButtonPadding, OutButtonPadding) == 0x000004, "Member 'OrionButtonStyle_GetButtonPadding::OutButtonPadding' has a wrong offset!");

// Function OrionGame.OrionButtonStyle.GetCustomPadding
// 0x0014 (0x0014 - 0x0000)
struct OrionButtonStyle_GetCustomPadding final
{
public:
	EOrionWidgetStyleSize                         Size;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMargin                                OutCustomPadding;                                  // 0x0004(0x0010)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionButtonStyle_GetCustomPadding) == 0x000004, "Wrong alignment on OrionButtonStyle_GetCustomPadding");
static_assert(sizeof(OrionButtonStyle_GetCustomPadding) == 0x000014, "Wrong size on OrionButtonStyle_GetCustomPadding");
static_assert(offsetof(OrionButtonStyle_GetCustomPadding, Size) == 0x000000, "Member 'OrionButtonStyle_GetCustomPadding::Size' has a wrong offset!");
static_assert(offsetof(OrionButtonStyle_GetCustomPadding, OutCustomPadding) == 0x000004, "Member 'OrionButtonStyle_GetCustomPadding::OutCustomPadding' has a wrong offset!");

// Function OrionGame.OrionButtonStyle.GetDisabledBrush
// 0x0080 (0x0080 - 0x0000)
struct OrionButtonStyle_GetDisabledBrush final
{
public:
	EOrionWidgetStyleSize                         Size;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            Brush;                                             // 0x0008(0x0078)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionButtonStyle_GetDisabledBrush) == 0x000008, "Wrong alignment on OrionButtonStyle_GetDisabledBrush");
static_assert(sizeof(OrionButtonStyle_GetDisabledBrush) == 0x000080, "Wrong size on OrionButtonStyle_GetDisabledBrush");
static_assert(offsetof(OrionButtonStyle_GetDisabledBrush, Size) == 0x000000, "Member 'OrionButtonStyle_GetDisabledBrush::Size' has a wrong offset!");
static_assert(offsetof(OrionButtonStyle_GetDisabledBrush, Brush) == 0x000008, "Member 'OrionButtonStyle_GetDisabledBrush::Brush' has a wrong offset!");

// Function OrionGame.OrionButtonStyle.GetDisabledTextStyle
// 0x0008 (0x0008 - 0x0000)
struct OrionButtonStyle_GetDisabledTextStyle final
{
public:
	class UOrionTextStyle*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionButtonStyle_GetDisabledTextStyle) == 0x000008, "Wrong alignment on OrionButtonStyle_GetDisabledTextStyle");
static_assert(sizeof(OrionButtonStyle_GetDisabledTextStyle) == 0x000008, "Wrong size on OrionButtonStyle_GetDisabledTextStyle");
static_assert(offsetof(OrionButtonStyle_GetDisabledTextStyle, ReturnValue) == 0x000000, "Member 'OrionButtonStyle_GetDisabledTextStyle::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionButtonStyle.GetNormalBaseBrush
// 0x0080 (0x0080 - 0x0000)
struct OrionButtonStyle_GetNormalBaseBrush final
{
public:
	EOrionWidgetStyleSize                         Size;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            Brush;                                             // 0x0008(0x0078)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionButtonStyle_GetNormalBaseBrush) == 0x000008, "Wrong alignment on OrionButtonStyle_GetNormalBaseBrush");
static_assert(sizeof(OrionButtonStyle_GetNormalBaseBrush) == 0x000080, "Wrong size on OrionButtonStyle_GetNormalBaseBrush");
static_assert(offsetof(OrionButtonStyle_GetNormalBaseBrush, Size) == 0x000000, "Member 'OrionButtonStyle_GetNormalBaseBrush::Size' has a wrong offset!");
static_assert(offsetof(OrionButtonStyle_GetNormalBaseBrush, Brush) == 0x000008, "Member 'OrionButtonStyle_GetNormalBaseBrush::Brush' has a wrong offset!");

// Function OrionGame.OrionButtonStyle.GetNormalHoveredBrush
// 0x0080 (0x0080 - 0x0000)
struct OrionButtonStyle_GetNormalHoveredBrush final
{
public:
	EOrionWidgetStyleSize                         Size;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            Brush;                                             // 0x0008(0x0078)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionButtonStyle_GetNormalHoveredBrush) == 0x000008, "Wrong alignment on OrionButtonStyle_GetNormalHoveredBrush");
static_assert(sizeof(OrionButtonStyle_GetNormalHoveredBrush) == 0x000080, "Wrong size on OrionButtonStyle_GetNormalHoveredBrush");
static_assert(offsetof(OrionButtonStyle_GetNormalHoveredBrush, Size) == 0x000000, "Member 'OrionButtonStyle_GetNormalHoveredBrush::Size' has a wrong offset!");
static_assert(offsetof(OrionButtonStyle_GetNormalHoveredBrush, Brush) == 0x000008, "Member 'OrionButtonStyle_GetNormalHoveredBrush::Brush' has a wrong offset!");

// Function OrionGame.OrionButtonStyle.GetNormalPressedBrush
// 0x0080 (0x0080 - 0x0000)
struct OrionButtonStyle_GetNormalPressedBrush final
{
public:
	EOrionWidgetStyleSize                         Size;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            Brush;                                             // 0x0008(0x0078)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionButtonStyle_GetNormalPressedBrush) == 0x000008, "Wrong alignment on OrionButtonStyle_GetNormalPressedBrush");
static_assert(sizeof(OrionButtonStyle_GetNormalPressedBrush) == 0x000080, "Wrong size on OrionButtonStyle_GetNormalPressedBrush");
static_assert(offsetof(OrionButtonStyle_GetNormalPressedBrush, Size) == 0x000000, "Member 'OrionButtonStyle_GetNormalPressedBrush::Size' has a wrong offset!");
static_assert(offsetof(OrionButtonStyle_GetNormalPressedBrush, Brush) == 0x000008, "Member 'OrionButtonStyle_GetNormalPressedBrush::Brush' has a wrong offset!");

// Function OrionGame.OrionButtonStyle.GetNormalTextStyle
// 0x0008 (0x0008 - 0x0000)
struct OrionButtonStyle_GetNormalTextStyle final
{
public:
	class UOrionTextStyle*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionButtonStyle_GetNormalTextStyle) == 0x000008, "Wrong alignment on OrionButtonStyle_GetNormalTextStyle");
static_assert(sizeof(OrionButtonStyle_GetNormalTextStyle) == 0x000008, "Wrong size on OrionButtonStyle_GetNormalTextStyle");
static_assert(offsetof(OrionButtonStyle_GetNormalTextStyle, ReturnValue) == 0x000000, "Member 'OrionButtonStyle_GetNormalTextStyle::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionButtonStyle.GetSelectedBaseBrush
// 0x0080 (0x0080 - 0x0000)
struct OrionButtonStyle_GetSelectedBaseBrush final
{
public:
	EOrionWidgetStyleSize                         Size;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            Brush;                                             // 0x0008(0x0078)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionButtonStyle_GetSelectedBaseBrush) == 0x000008, "Wrong alignment on OrionButtonStyle_GetSelectedBaseBrush");
static_assert(sizeof(OrionButtonStyle_GetSelectedBaseBrush) == 0x000080, "Wrong size on OrionButtonStyle_GetSelectedBaseBrush");
static_assert(offsetof(OrionButtonStyle_GetSelectedBaseBrush, Size) == 0x000000, "Member 'OrionButtonStyle_GetSelectedBaseBrush::Size' has a wrong offset!");
static_assert(offsetof(OrionButtonStyle_GetSelectedBaseBrush, Brush) == 0x000008, "Member 'OrionButtonStyle_GetSelectedBaseBrush::Brush' has a wrong offset!");

// Function OrionGame.OrionButtonStyle.GetSelectedHoveredBrush
// 0x0080 (0x0080 - 0x0000)
struct OrionButtonStyle_GetSelectedHoveredBrush final
{
public:
	EOrionWidgetStyleSize                         Size;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            Brush;                                             // 0x0008(0x0078)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionButtonStyle_GetSelectedHoveredBrush) == 0x000008, "Wrong alignment on OrionButtonStyle_GetSelectedHoveredBrush");
static_assert(sizeof(OrionButtonStyle_GetSelectedHoveredBrush) == 0x000080, "Wrong size on OrionButtonStyle_GetSelectedHoveredBrush");
static_assert(offsetof(OrionButtonStyle_GetSelectedHoveredBrush, Size) == 0x000000, "Member 'OrionButtonStyle_GetSelectedHoveredBrush::Size' has a wrong offset!");
static_assert(offsetof(OrionButtonStyle_GetSelectedHoveredBrush, Brush) == 0x000008, "Member 'OrionButtonStyle_GetSelectedHoveredBrush::Brush' has a wrong offset!");

// Function OrionGame.OrionButtonStyle.GetSelectedPressedBrush
// 0x0080 (0x0080 - 0x0000)
struct OrionButtonStyle_GetSelectedPressedBrush final
{
public:
	EOrionWidgetStyleSize                         Size;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            Brush;                                             // 0x0008(0x0078)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionButtonStyle_GetSelectedPressedBrush) == 0x000008, "Wrong alignment on OrionButtonStyle_GetSelectedPressedBrush");
static_assert(sizeof(OrionButtonStyle_GetSelectedPressedBrush) == 0x000080, "Wrong size on OrionButtonStyle_GetSelectedPressedBrush");
static_assert(offsetof(OrionButtonStyle_GetSelectedPressedBrush, Size) == 0x000000, "Member 'OrionButtonStyle_GetSelectedPressedBrush::Size' has a wrong offset!");
static_assert(offsetof(OrionButtonStyle_GetSelectedPressedBrush, Brush) == 0x000008, "Member 'OrionButtonStyle_GetSelectedPressedBrush::Brush' has a wrong offset!");

// Function OrionGame.OrionButtonStyle.GetSelectedTextStyle
// 0x0008 (0x0008 - 0x0000)
struct OrionButtonStyle_GetSelectedTextStyle final
{
public:
	class UOrionTextStyle*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionButtonStyle_GetSelectedTextStyle) == 0x000008, "Wrong alignment on OrionButtonStyle_GetSelectedTextStyle");
static_assert(sizeof(OrionButtonStyle_GetSelectedTextStyle) == 0x000008, "Wrong size on OrionButtonStyle_GetSelectedTextStyle");
static_assert(offsetof(OrionButtonStyle_GetSelectedTextStyle, ReturnValue) == 0x000000, "Member 'OrionButtonStyle_GetSelectedTextStyle::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_WaitForMovementInput.WaitForMovementInput
// 0x0010 (0x0010 - 0x0000)
struct OrionAbilityTask_WaitForMovementInput_WaitForMovementInput final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionAbilityTask_WaitForMovementInput* ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_WaitForMovementInput_WaitForMovementInput) == 0x000008, "Wrong alignment on OrionAbilityTask_WaitForMovementInput_WaitForMovementInput");
static_assert(sizeof(OrionAbilityTask_WaitForMovementInput_WaitForMovementInput) == 0x000010, "Wrong size on OrionAbilityTask_WaitForMovementInput_WaitForMovementInput");
static_assert(offsetof(OrionAbilityTask_WaitForMovementInput_WaitForMovementInput, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_WaitForMovementInput_WaitForMovementInput::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitForMovementInput_WaitForMovementInput, ReturnValue) == 0x000008, "Member 'OrionAbilityTask_WaitForMovementInput_WaitForMovementInput::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_WaitForSpecialAttackRotation.WaitForSpecialAttackRotation
// 0x0018 (0x0018 - 0x0000)
struct OrionAbilityTask_WaitForSpecialAttackRotation_WaitForSpecialAttackRotation final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionJungleTarget                            Mode;                                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAbilityTask_WaitForSpecialAttackRotation* ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_WaitForSpecialAttackRotation_WaitForSpecialAttackRotation) == 0x000008, "Wrong alignment on OrionAbilityTask_WaitForSpecialAttackRotation_WaitForSpecialAttackRotation");
static_assert(sizeof(OrionAbilityTask_WaitForSpecialAttackRotation_WaitForSpecialAttackRotation) == 0x000018, "Wrong size on OrionAbilityTask_WaitForSpecialAttackRotation_WaitForSpecialAttackRotation");
static_assert(offsetof(OrionAbilityTask_WaitForSpecialAttackRotation_WaitForSpecialAttackRotation, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_WaitForSpecialAttackRotation_WaitForSpecialAttackRotation::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitForSpecialAttackRotation_WaitForSpecialAttackRotation, Mode) == 0x000008, "Member 'OrionAbilityTask_WaitForSpecialAttackRotation_WaitForSpecialAttackRotation::Mode' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitForSpecialAttackRotation_WaitForSpecialAttackRotation, ReturnValue) == 0x000010, "Member 'OrionAbilityTask_WaitForSpecialAttackRotation_WaitForSpecialAttackRotation::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_WaitHeroGameplayTag.WaitHeroGameplayTagAdd
// 0x0020 (0x0020 - 0x0000)
struct OrionAbilityTask_WaitHeroGameplayTag_WaitHeroGameplayTagAdd final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllies;                                           // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnemies;                                          // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyTriggerOnce;                                  // 0x0012(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAbilityTask_WaitHeroGameplayTag*  ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_WaitHeroGameplayTag_WaitHeroGameplayTagAdd) == 0x000008, "Wrong alignment on OrionAbilityTask_WaitHeroGameplayTag_WaitHeroGameplayTagAdd");
static_assert(sizeof(OrionAbilityTask_WaitHeroGameplayTag_WaitHeroGameplayTagAdd) == 0x000020, "Wrong size on OrionAbilityTask_WaitHeroGameplayTag_WaitHeroGameplayTagAdd");
static_assert(offsetof(OrionAbilityTask_WaitHeroGameplayTag_WaitHeroGameplayTagAdd, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_WaitHeroGameplayTag_WaitHeroGameplayTagAdd::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitHeroGameplayTag_WaitHeroGameplayTagAdd, Tag) == 0x000008, "Member 'OrionAbilityTask_WaitHeroGameplayTag_WaitHeroGameplayTagAdd::Tag' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitHeroGameplayTag_WaitHeroGameplayTagAdd, bAllies) == 0x000010, "Member 'OrionAbilityTask_WaitHeroGameplayTag_WaitHeroGameplayTagAdd::bAllies' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitHeroGameplayTag_WaitHeroGameplayTagAdd, bEnemies) == 0x000011, "Member 'OrionAbilityTask_WaitHeroGameplayTag_WaitHeroGameplayTagAdd::bEnemies' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitHeroGameplayTag_WaitHeroGameplayTagAdd, bOnlyTriggerOnce) == 0x000012, "Member 'OrionAbilityTask_WaitHeroGameplayTag_WaitHeroGameplayTagAdd::bOnlyTriggerOnce' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitHeroGameplayTag_WaitHeroGameplayTagAdd, ReturnValue) == 0x000018, "Member 'OrionAbilityTask_WaitHeroGameplayTag_WaitHeroGameplayTagAdd::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_WaitHeroGameplayTag.WaitHeroGameplayTagRemove
// 0x0020 (0x0020 - 0x0000)
struct OrionAbilityTask_WaitHeroGameplayTag_WaitHeroGameplayTagRemove final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllies;                                           // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnemies;                                          // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyTriggerOnce;                                  // 0x0012(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAbilityTask_WaitHeroGameplayTag*  ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_WaitHeroGameplayTag_WaitHeroGameplayTagRemove) == 0x000008, "Wrong alignment on OrionAbilityTask_WaitHeroGameplayTag_WaitHeroGameplayTagRemove");
static_assert(sizeof(OrionAbilityTask_WaitHeroGameplayTag_WaitHeroGameplayTagRemove) == 0x000020, "Wrong size on OrionAbilityTask_WaitHeroGameplayTag_WaitHeroGameplayTagRemove");
static_assert(offsetof(OrionAbilityTask_WaitHeroGameplayTag_WaitHeroGameplayTagRemove, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_WaitHeroGameplayTag_WaitHeroGameplayTagRemove::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitHeroGameplayTag_WaitHeroGameplayTagRemove, Tag) == 0x000008, "Member 'OrionAbilityTask_WaitHeroGameplayTag_WaitHeroGameplayTagRemove::Tag' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitHeroGameplayTag_WaitHeroGameplayTagRemove, bAllies) == 0x000010, "Member 'OrionAbilityTask_WaitHeroGameplayTag_WaitHeroGameplayTagRemove::bAllies' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitHeroGameplayTag_WaitHeroGameplayTagRemove, bEnemies) == 0x000011, "Member 'OrionAbilityTask_WaitHeroGameplayTag_WaitHeroGameplayTagRemove::bEnemies' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitHeroGameplayTag_WaitHeroGameplayTagRemove, bOnlyTriggerOnce) == 0x000012, "Member 'OrionAbilityTask_WaitHeroGameplayTag_WaitHeroGameplayTagRemove::bOnlyTriggerOnce' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitHeroGameplayTag_WaitHeroGameplayTagRemove, ReturnValue) == 0x000018, "Member 'OrionAbilityTask_WaitHeroGameplayTag_WaitHeroGameplayTagRemove::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_WaitInputPress_WithState.WaitInputPress_WithState
// 0x0018 (0x0018 - 0x0000)
struct OrionAbilityTask_WaitInputPress_WithState_WaitInputPress_WithState final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTestAlreadyPressed;                               // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceAlreadyPressed;                              // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAbilityTask_WaitInputPress_WithState* ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_WaitInputPress_WithState_WaitInputPress_WithState) == 0x000008, "Wrong alignment on OrionAbilityTask_WaitInputPress_WithState_WaitInputPress_WithState");
static_assert(sizeof(OrionAbilityTask_WaitInputPress_WithState_WaitInputPress_WithState) == 0x000018, "Wrong size on OrionAbilityTask_WaitInputPress_WithState_WaitInputPress_WithState");
static_assert(offsetof(OrionAbilityTask_WaitInputPress_WithState_WaitInputPress_WithState, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_WaitInputPress_WithState_WaitInputPress_WithState::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitInputPress_WithState_WaitInputPress_WithState, bTestAlreadyPressed) == 0x000008, "Member 'OrionAbilityTask_WaitInputPress_WithState_WaitInputPress_WithState::bTestAlreadyPressed' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitInputPress_WithState_WaitInputPress_WithState, bForceAlreadyPressed) == 0x000009, "Member 'OrionAbilityTask_WaitInputPress_WithState_WaitInputPress_WithState::bForceAlreadyPressed' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitInputPress_WithState_WaitInputPress_WithState, ReturnValue) == 0x000010, "Member 'OrionAbilityTask_WaitInputPress_WithState_WaitInputPress_WithState::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_WaitKilled.WaitActorKilled
// 0x00A0 (0x00A0 - 0x0000)
struct OrionAbilityTask_WaitKilled_WaitActorKilled final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               SourceTagRequirements;                             // 0x0010(0x0040)(Parm, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               TargetTagRequirements;                             // 0x0050(0x0040)(Parm, NativeAccessSpecifierPublic)
	bool                                          TriggerOnce;                                       // 0x0090(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAbilityTask_WaitKilled*           ReturnValue;                                       // 0x0098(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_WaitKilled_WaitActorKilled) == 0x000008, "Wrong alignment on OrionAbilityTask_WaitKilled_WaitActorKilled");
static_assert(sizeof(OrionAbilityTask_WaitKilled_WaitActorKilled) == 0x0000A0, "Wrong size on OrionAbilityTask_WaitKilled_WaitActorKilled");
static_assert(offsetof(OrionAbilityTask_WaitKilled_WaitActorKilled, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_WaitKilled_WaitActorKilled::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitKilled_WaitActorKilled, Actor) == 0x000008, "Member 'OrionAbilityTask_WaitKilled_WaitActorKilled::Actor' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitKilled_WaitActorKilled, SourceTagRequirements) == 0x000010, "Member 'OrionAbilityTask_WaitKilled_WaitActorKilled::SourceTagRequirements' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitKilled_WaitActorKilled, TargetTagRequirements) == 0x000050, "Member 'OrionAbilityTask_WaitKilled_WaitActorKilled::TargetTagRequirements' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitKilled_WaitActorKilled, TriggerOnce) == 0x000090, "Member 'OrionAbilityTask_WaitKilled_WaitActorKilled::TriggerOnce' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitKilled_WaitActorKilled, ReturnValue) == 0x000098, "Member 'OrionAbilityTask_WaitKilled_WaitActorKilled::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_WaitKilled.WaitOwnerKilled
// 0x0098 (0x0098 - 0x0000)
struct OrionAbilityTask_WaitKilled_WaitOwnerKilled final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               SourceTagRequirements;                             // 0x0008(0x0040)(Parm, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               TargetTagRequirements;                             // 0x0048(0x0040)(Parm, NativeAccessSpecifierPublic)
	bool                                          TriggerOnce;                                       // 0x0088(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAbilityTask_WaitKilled*           ReturnValue;                                       // 0x0090(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_WaitKilled_WaitOwnerKilled) == 0x000008, "Wrong alignment on OrionAbilityTask_WaitKilled_WaitOwnerKilled");
static_assert(sizeof(OrionAbilityTask_WaitKilled_WaitOwnerKilled) == 0x000098, "Wrong size on OrionAbilityTask_WaitKilled_WaitOwnerKilled");
static_assert(offsetof(OrionAbilityTask_WaitKilled_WaitOwnerKilled, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_WaitKilled_WaitOwnerKilled::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitKilled_WaitOwnerKilled, SourceTagRequirements) == 0x000008, "Member 'OrionAbilityTask_WaitKilled_WaitOwnerKilled::SourceTagRequirements' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitKilled_WaitOwnerKilled, TargetTagRequirements) == 0x000048, "Member 'OrionAbilityTask_WaitKilled_WaitOwnerKilled::TargetTagRequirements' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitKilled_WaitOwnerKilled, TriggerOnce) == 0x000088, "Member 'OrionAbilityTask_WaitKilled_WaitOwnerKilled::TriggerOnce' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitKilled_WaitOwnerKilled, ReturnValue) == 0x000090, "Member 'OrionAbilityTask_WaitKilled_WaitOwnerKilled::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_WaitKilled.OnKilledCallback
// 0x0298 (0x0298 - 0x0000)
struct OrionAbilityTask_WaitKilled_OnKilledCallback final
{
public:
	struct FGameplayEffectSpec                    Spec;                                              // 0x0000(0x0298)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_WaitKilled_OnKilledCallback) == 0x000008, "Wrong alignment on OrionAbilityTask_WaitKilled_OnKilledCallback");
static_assert(sizeof(OrionAbilityTask_WaitKilled_OnKilledCallback) == 0x000298, "Wrong size on OrionAbilityTask_WaitKilled_OnKilledCallback");
static_assert(offsetof(OrionAbilityTask_WaitKilled_OnKilledCallback, Spec) == 0x000000, "Member 'OrionAbilityTask_WaitKilled_OnKilledCallback::Spec' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_WaitLanded.WaitLanded
// 0x0010 (0x0010 - 0x0000)
struct OrionAbilityTask_WaitLanded_WaitLanded final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionAbilityTask_WaitLanded*           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_WaitLanded_WaitLanded) == 0x000008, "Wrong alignment on OrionAbilityTask_WaitLanded_WaitLanded");
static_assert(sizeof(OrionAbilityTask_WaitLanded_WaitLanded) == 0x000010, "Wrong size on OrionAbilityTask_WaitLanded_WaitLanded");
static_assert(offsetof(OrionAbilityTask_WaitLanded_WaitLanded, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_WaitLanded_WaitLanded::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitLanded_WaitLanded, ReturnValue) == 0x000008, "Member 'OrionAbilityTask_WaitLanded_WaitLanded::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_WaitLanded.OnLandedCallback
// 0x0088 (0x0088 - 0x0000)
struct OrionAbilityTask_WaitLanded_OnLandedCallback final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_WaitLanded_OnLandedCallback) == 0x000008, "Wrong alignment on OrionAbilityTask_WaitLanded_OnLandedCallback");
static_assert(sizeof(OrionAbilityTask_WaitLanded_OnLandedCallback) == 0x000088, "Wrong size on OrionAbilityTask_WaitLanded_OnLandedCallback");
static_assert(offsetof(OrionAbilityTask_WaitLanded_OnLandedCallback, Hit) == 0x000000, "Member 'OrionAbilityTask_WaitLanded_OnLandedCallback::Hit' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_WaitMeleeImpact.CreateWaitMovementModeChange
// 0x0010 (0x0010 - 0x0000)
struct OrionAbilityTask_WaitMeleeImpact_CreateWaitMovementModeChange final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionAbilityTask_WaitMeleeImpact*      ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_WaitMeleeImpact_CreateWaitMovementModeChange) == 0x000008, "Wrong alignment on OrionAbilityTask_WaitMeleeImpact_CreateWaitMovementModeChange");
static_assert(sizeof(OrionAbilityTask_WaitMeleeImpact_CreateWaitMovementModeChange) == 0x000010, "Wrong size on OrionAbilityTask_WaitMeleeImpact_CreateWaitMovementModeChange");
static_assert(offsetof(OrionAbilityTask_WaitMeleeImpact_CreateWaitMovementModeChange, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_WaitMeleeImpact_CreateWaitMovementModeChange::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitMeleeImpact_CreateWaitMovementModeChange, ReturnValue) == 0x000008, "Member 'OrionAbilityTask_WaitMeleeImpact_CreateWaitMovementModeChange::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_WaitMeleeImpact.OnMeleeImpact
// 0x0090 (0x0090 - 0x0000)
struct OrionAbilityTask_WaitMeleeImpact_OnMeleeImpact final
{
public:
	class AActor*                                 OtherActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             SweepResult;                                       // 0x0008(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_WaitMeleeImpact_OnMeleeImpact) == 0x000008, "Wrong alignment on OrionAbilityTask_WaitMeleeImpact_OnMeleeImpact");
static_assert(sizeof(OrionAbilityTask_WaitMeleeImpact_OnMeleeImpact) == 0x000090, "Wrong size on OrionAbilityTask_WaitMeleeImpact_OnMeleeImpact");
static_assert(offsetof(OrionAbilityTask_WaitMeleeImpact_OnMeleeImpact, OtherActor) == 0x000000, "Member 'OrionAbilityTask_WaitMeleeImpact_OnMeleeImpact::OtherActor' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitMeleeImpact_OnMeleeImpact, SweepResult) == 0x000008, "Member 'OrionAbilityTask_WaitMeleeImpact_OnMeleeImpact::SweepResult' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_WaitProjectileShutdown.WaitProjectileShutdown
// 0x0018 (0x0018 - 0x0000)
struct OrionAbilityTask_WaitProjectileShutdown_WaitProjectileShutdown final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionProjectile*                       Projectile_0;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionAbilityTask_WaitProjectileShutdown* ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_WaitProjectileShutdown_WaitProjectileShutdown) == 0x000008, "Wrong alignment on OrionAbilityTask_WaitProjectileShutdown_WaitProjectileShutdown");
static_assert(sizeof(OrionAbilityTask_WaitProjectileShutdown_WaitProjectileShutdown) == 0x000018, "Wrong size on OrionAbilityTask_WaitProjectileShutdown_WaitProjectileShutdown");
static_assert(offsetof(OrionAbilityTask_WaitProjectileShutdown_WaitProjectileShutdown, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_WaitProjectileShutdown_WaitProjectileShutdown::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitProjectileShutdown_WaitProjectileShutdown, Projectile_0) == 0x000008, "Member 'OrionAbilityTask_WaitProjectileShutdown_WaitProjectileShutdown::Projectile_0' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitProjectileShutdown_WaitProjectileShutdown, ReturnValue) == 0x000010, "Member 'OrionAbilityTask_WaitProjectileShutdown_WaitProjectileShutdown::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_WaitProjectileHitActor.WaitProjectileHitActor
// 0x0018 (0x0018 - 0x0000)
struct OrionAbilityTask_WaitProjectileHitActor_WaitProjectileHitActor final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionProjectile*                       Projectile_0;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionAbilityTask_WaitProjectileHitActor* ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_WaitProjectileHitActor_WaitProjectileHitActor) == 0x000008, "Wrong alignment on OrionAbilityTask_WaitProjectileHitActor_WaitProjectileHitActor");
static_assert(sizeof(OrionAbilityTask_WaitProjectileHitActor_WaitProjectileHitActor) == 0x000018, "Wrong size on OrionAbilityTask_WaitProjectileHitActor_WaitProjectileHitActor");
static_assert(offsetof(OrionAbilityTask_WaitProjectileHitActor_WaitProjectileHitActor, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_WaitProjectileHitActor_WaitProjectileHitActor::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitProjectileHitActor_WaitProjectileHitActor, Projectile_0) == 0x000008, "Member 'OrionAbilityTask_WaitProjectileHitActor_WaitProjectileHitActor::Projectile_0' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitProjectileHitActor_WaitProjectileHitActor, ReturnValue) == 0x000010, "Member 'OrionAbilityTask_WaitProjectileHitActor_WaitProjectileHitActor::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_WaitProjectileHitActor.OnHitActorCallback
// 0x0088 (0x0088 - 0x0000)
struct OrionAbilityTask_WaitProjectileHitActor_OnHitActorCallback final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_WaitProjectileHitActor_OnHitActorCallback) == 0x000008, "Wrong alignment on OrionAbilityTask_WaitProjectileHitActor_OnHitActorCallback");
static_assert(sizeof(OrionAbilityTask_WaitProjectileHitActor_OnHitActorCallback) == 0x000088, "Wrong size on OrionAbilityTask_WaitProjectileHitActor_OnHitActorCallback");
static_assert(offsetof(OrionAbilityTask_WaitProjectileHitActor_OnHitActorCallback, HitResult) == 0x000000, "Member 'OrionAbilityTask_WaitProjectileHitActor_OnHitActorCallback::HitResult' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_WaitProjectileStop.WaitProjectileStop
// 0x0018 (0x0018 - 0x0000)
struct OrionAbilityTask_WaitProjectileStop_WaitProjectileStop final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionProjectile*                       Projectile_0;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionAbilityTask_WaitProjectileStop*   ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_WaitProjectileStop_WaitProjectileStop) == 0x000008, "Wrong alignment on OrionAbilityTask_WaitProjectileStop_WaitProjectileStop");
static_assert(sizeof(OrionAbilityTask_WaitProjectileStop_WaitProjectileStop) == 0x000018, "Wrong size on OrionAbilityTask_WaitProjectileStop_WaitProjectileStop");
static_assert(offsetof(OrionAbilityTask_WaitProjectileStop_WaitProjectileStop, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_WaitProjectileStop_WaitProjectileStop::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitProjectileStop_WaitProjectileStop, Projectile_0) == 0x000008, "Member 'OrionAbilityTask_WaitProjectileStop_WaitProjectileStop::Projectile_0' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitProjectileStop_WaitProjectileStop, ReturnValue) == 0x000010, "Member 'OrionAbilityTask_WaitProjectileStop_WaitProjectileStop::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_WaitProjectileStop.OnStopCallback
// 0x0088 (0x0088 - 0x0000)
struct OrionAbilityTask_WaitProjectileStop_OnStopCallback final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_WaitProjectileStop_OnStopCallback) == 0x000008, "Wrong alignment on OrionAbilityTask_WaitProjectileStop_OnStopCallback");
static_assert(sizeof(OrionAbilityTask_WaitProjectileStop_OnStopCallback) == 0x000088, "Wrong size on OrionAbilityTask_WaitProjectileStop_OnStopCallback");
static_assert(offsetof(OrionAbilityTask_WaitProjectileStop_OnStopCallback, HitResult) == 0x000000, "Member 'OrionAbilityTask_WaitProjectileStop_OnStopCallback::HitResult' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_WaitSprintCancel.WaitSprintCancel
// 0x0010 (0x0010 - 0x0000)
struct OrionAbilityTask_WaitSprintCancel_WaitSprintCancel final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionAbilityTask_WaitSprintCancel*     ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_WaitSprintCancel_WaitSprintCancel) == 0x000008, "Wrong alignment on OrionAbilityTask_WaitSprintCancel_WaitSprintCancel");
static_assert(sizeof(OrionAbilityTask_WaitSprintCancel_WaitSprintCancel) == 0x000010, "Wrong size on OrionAbilityTask_WaitSprintCancel_WaitSprintCancel");
static_assert(offsetof(OrionAbilityTask_WaitSprintCancel_WaitSprintCancel, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_WaitSprintCancel_WaitSprintCancel::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitSprintCancel_WaitSprintCancel, ReturnValue) == 0x000008, "Member 'OrionAbilityTask_WaitSprintCancel_WaitSprintCancel::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAbilityTask_WaitTowerTargetAcquired.WaitTowerTargetAcquired
// 0x0010 (0x0010 - 0x0000)
struct OrionAbilityTask_WaitTowerTargetAcquired_WaitTowerTargetAcquired final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionAbilityTask_WaitTowerTargetAcquired* ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAbilityTask_WaitTowerTargetAcquired_WaitTowerTargetAcquired) == 0x000008, "Wrong alignment on OrionAbilityTask_WaitTowerTargetAcquired_WaitTowerTargetAcquired");
static_assert(sizeof(OrionAbilityTask_WaitTowerTargetAcquired_WaitTowerTargetAcquired) == 0x000010, "Wrong size on OrionAbilityTask_WaitTowerTargetAcquired_WaitTowerTargetAcquired");
static_assert(offsetof(OrionAbilityTask_WaitTowerTargetAcquired_WaitTowerTargetAcquired, OwningAbility) == 0x000000, "Member 'OrionAbilityTask_WaitTowerTargetAcquired_WaitTowerTargetAcquired::OwningAbility' has a wrong offset!");
static_assert(offsetof(OrionAbilityTask_WaitTowerTargetAcquired_WaitTowerTargetAcquired, ReturnValue) == 0x000008, "Member 'OrionAbilityTask_WaitTowerTargetAcquired_WaitTowerTargetAcquired::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.AddTestNotification
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerBase_AddTestNotification final
{
public:
	int32                                         Count;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_AddTestNotification) == 0x000004, "Wrong alignment on OrionCheatManagerBase_AddTestNotification");
static_assert(sizeof(OrionCheatManagerBase_AddTestNotification) == 0x000004, "Wrong size on OrionCheatManagerBase_AddTestNotification");
static_assert(offsetof(OrionCheatManagerBase_AddTestNotification, Count) == 0x000000, "Member 'OrionCheatManagerBase_AddTestNotification::Count' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.CalculateMaxMMRDelta
// 0x0008 (0x0008 - 0x0000)
struct OrionCheatManagerBase_CalculateMaxMMRDelta final
{
public:
	int32                                         SecondsInQueue;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         YourMMR;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_CalculateMaxMMRDelta) == 0x000004, "Wrong alignment on OrionCheatManagerBase_CalculateMaxMMRDelta");
static_assert(sizeof(OrionCheatManagerBase_CalculateMaxMMRDelta) == 0x000008, "Wrong size on OrionCheatManagerBase_CalculateMaxMMRDelta");
static_assert(offsetof(OrionCheatManagerBase_CalculateMaxMMRDelta, SecondsInQueue) == 0x000000, "Member 'OrionCheatManagerBase_CalculateMaxMMRDelta::SecondsInQueue' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerBase_CalculateMaxMMRDelta, YourMMR) == 0x000004, "Member 'OrionCheatManagerBase_CalculateMaxMMRDelta::YourMMR' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.DraftPick
// 0x0010 (0x0010 - 0x0000)
struct OrionCheatManagerBase_DraftPick final
{
public:
	class FString                                 HeroName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_DraftPick) == 0x000008, "Wrong alignment on OrionCheatManagerBase_DraftPick");
static_assert(sizeof(OrionCheatManagerBase_DraftPick) == 0x000010, "Wrong size on OrionCheatManagerBase_DraftPick");
static_assert(offsetof(OrionCheatManagerBase_DraftPick, HeroName) == 0x000000, "Member 'OrionCheatManagerBase_DraftPick::HeroName' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.EComPurchaseOffer
// 0x0018 (0x0018 - 0x0000)
struct OrionCheatManagerBase_EComPurchaseOffer final
{
public:
	class FString                                 StorefrontName;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OfferIndex;                                        // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_EComPurchaseOffer) == 0x000008, "Wrong alignment on OrionCheatManagerBase_EComPurchaseOffer");
static_assert(sizeof(OrionCheatManagerBase_EComPurchaseOffer) == 0x000018, "Wrong size on OrionCheatManagerBase_EComPurchaseOffer");
static_assert(offsetof(OrionCheatManagerBase_EComPurchaseOffer, StorefrontName) == 0x000000, "Member 'OrionCheatManagerBase_EComPurchaseOffer::StorefrontName' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerBase_EComPurchaseOffer, OfferIndex) == 0x000010, "Member 'OrionCheatManagerBase_EComPurchaseOffer::OfferIndex' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerBase_EComPurchaseOffer, Quantity) == 0x000014, "Member 'OrionCheatManagerBase_EComPurchaseOffer::Quantity' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.ForceRotationalContent
// 0x0010 (0x0010 - 0x0000)
struct OrionCheatManagerBase_ForceRotationalContent final
{
public:
	class FString                                 Msg;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_ForceRotationalContent) == 0x000008, "Wrong alignment on OrionCheatManagerBase_ForceRotationalContent");
static_assert(sizeof(OrionCheatManagerBase_ForceRotationalContent) == 0x000010, "Wrong size on OrionCheatManagerBase_ForceRotationalContent");
static_assert(offsetof(OrionCheatManagerBase_ForceRotationalContent, Msg) == 0x000000, "Member 'OrionCheatManagerBase_ForceRotationalContent::Msg' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.GenerateBotMatchup
// 0x0010 (0x0010 - 0x0000)
struct OrionCheatManagerBase_GenerateBotMatchup final
{
public:
	class FString                                 DifficultyName;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_GenerateBotMatchup) == 0x000008, "Wrong alignment on OrionCheatManagerBase_GenerateBotMatchup");
static_assert(sizeof(OrionCheatManagerBase_GenerateBotMatchup) == 0x000010, "Wrong size on OrionCheatManagerBase_GenerateBotMatchup");
static_assert(offsetof(OrionCheatManagerBase_GenerateBotMatchup, DifficultyName) == 0x000000, "Member 'OrionCheatManagerBase_GenerateBotMatchup::DifficultyName' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.GetAccountMMR
// 0x0010 (0x0010 - 0x0000)
struct OrionCheatManagerBase_GetAccountMMR final
{
public:
	class FString                                 RatingType;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_GetAccountMMR) == 0x000008, "Wrong alignment on OrionCheatManagerBase_GetAccountMMR");
static_assert(sizeof(OrionCheatManagerBase_GetAccountMMR) == 0x000010, "Wrong size on OrionCheatManagerBase_GetAccountMMR");
static_assert(offsetof(OrionCheatManagerBase_GetAccountMMR, RatingType) == 0x000000, "Member 'OrionCheatManagerBase_GetAccountMMR::RatingType' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.IcmpPingAddr
// 0x0018 (0x0018 - 0x0000)
struct OrionCheatManagerBase_IcmpPingAddr final
{
public:
	class FString                                 Target;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timeout;                                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionCheatManagerBase_IcmpPingAddr) == 0x000008, "Wrong alignment on OrionCheatManagerBase_IcmpPingAddr");
static_assert(sizeof(OrionCheatManagerBase_IcmpPingAddr) == 0x000018, "Wrong size on OrionCheatManagerBase_IcmpPingAddr");
static_assert(offsetof(OrionCheatManagerBase_IcmpPingAddr, Target) == 0x000000, "Member 'OrionCheatManagerBase_IcmpPingAddr::Target' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerBase_IcmpPingAddr, Timeout) == 0x000010, "Member 'OrionCheatManagerBase_IcmpPingAddr::Timeout' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.McpIssueCodeToken
// 0x0010 (0x0010 - 0x0000)
struct OrionCheatManagerBase_McpIssueCodeToken final
{
public:
	class FString                                 TokenId;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_McpIssueCodeToken) == 0x000008, "Wrong alignment on OrionCheatManagerBase_McpIssueCodeToken");
static_assert(sizeof(OrionCheatManagerBase_McpIssueCodeToken) == 0x000010, "Wrong size on OrionCheatManagerBase_McpIssueCodeToken");
static_assert(offsetof(OrionCheatManagerBase_McpIssueCodeToken, TokenId) == 0x000000, "Member 'OrionCheatManagerBase_McpIssueCodeToken::TokenId' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.McpLogin
// 0x0020 (0x0020 - 0x0000)
struct OrionCheatManagerBase_McpLogin final
{
public:
	class FString                                 User;                                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Password;                                          // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_McpLogin) == 0x000008, "Wrong alignment on OrionCheatManagerBase_McpLogin");
static_assert(sizeof(OrionCheatManagerBase_McpLogin) == 0x000020, "Wrong size on OrionCheatManagerBase_McpLogin");
static_assert(offsetof(OrionCheatManagerBase_McpLogin, User) == 0x000000, "Member 'OrionCheatManagerBase_McpLogin::User' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerBase_McpLogin, Password) == 0x000010, "Member 'OrionCheatManagerBase_McpLogin::Password' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.McpOpenGiftBox
// 0x0010 (0x0010 - 0x0000)
struct OrionCheatManagerBase_McpOpenGiftBox final
{
public:
	class FString                                 GiftBoxItemID;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_McpOpenGiftBox) == 0x000008, "Wrong alignment on OrionCheatManagerBase_McpOpenGiftBox");
static_assert(sizeof(OrionCheatManagerBase_McpOpenGiftBox) == 0x000010, "Wrong size on OrionCheatManagerBase_McpOpenGiftBox");
static_assert(offsetof(OrionCheatManagerBase_McpOpenGiftBox, GiftBoxItemID) == 0x000000, "Member 'OrionCheatManagerBase_McpOpenGiftBox::GiftBoxItemID' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.McpSimulateMatchComplete
// 0x0018 (0x0018 - 0x0000)
struct OrionCheatManagerBase_McpSimulateMatchComplete final
{
public:
	bool                                          bVictory;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 HeroName;                                          // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_McpSimulateMatchComplete) == 0x000008, "Wrong alignment on OrionCheatManagerBase_McpSimulateMatchComplete");
static_assert(sizeof(OrionCheatManagerBase_McpSimulateMatchComplete) == 0x000018, "Wrong size on OrionCheatManagerBase_McpSimulateMatchComplete");
static_assert(offsetof(OrionCheatManagerBase_McpSimulateMatchComplete, bVictory) == 0x000000, "Member 'OrionCheatManagerBase_McpSimulateMatchComplete::bVictory' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerBase_McpSimulateMatchComplete, HeroName) == 0x000008, "Member 'OrionCheatManagerBase_McpSimulateMatchComplete::HeroName' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.McpSimulateMatchCompleteAbandon
// 0x0018 (0x0018 - 0x0000)
struct OrionCheatManagerBase_McpSimulateMatchCompleteAbandon final
{
public:
	bool                                          bVictory;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 HeroName;                                          // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_McpSimulateMatchCompleteAbandon) == 0x000008, "Wrong alignment on OrionCheatManagerBase_McpSimulateMatchCompleteAbandon");
static_assert(sizeof(OrionCheatManagerBase_McpSimulateMatchCompleteAbandon) == 0x000018, "Wrong size on OrionCheatManagerBase_McpSimulateMatchCompleteAbandon");
static_assert(offsetof(OrionCheatManagerBase_McpSimulateMatchCompleteAbandon, bVictory) == 0x000000, "Member 'OrionCheatManagerBase_McpSimulateMatchCompleteAbandon::bVictory' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerBase_McpSimulateMatchCompleteAbandon, HeroName) == 0x000008, "Member 'OrionCheatManagerBase_McpSimulateMatchCompleteAbandon::HeroName' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.McpTestTeamBuilderTeamSlots
// 0x0018 (0x0018 - 0x0000)
struct OrionCheatManagerBase_McpTestTeamBuilderTeamSlots final
{
public:
	class FString                                 MatchmakingBucket;                                 // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotCount;                                         // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionCheatManagerBase_McpTestTeamBuilderTeamSlots) == 0x000008, "Wrong alignment on OrionCheatManagerBase_McpTestTeamBuilderTeamSlots");
static_assert(sizeof(OrionCheatManagerBase_McpTestTeamBuilderTeamSlots) == 0x000018, "Wrong size on OrionCheatManagerBase_McpTestTeamBuilderTeamSlots");
static_assert(offsetof(OrionCheatManagerBase_McpTestTeamBuilderTeamSlots, MatchmakingBucket) == 0x000000, "Member 'OrionCheatManagerBase_McpTestTeamBuilderTeamSlots::MatchmakingBucket' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerBase_McpTestTeamBuilderTeamSlots, SlotCount) == 0x000010, "Member 'OrionCheatManagerBase_McpTestTeamBuilderTeamSlots::SlotCount' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.OrionDemoMode
// 0x0001 (0x0001 - 0x0000)
struct OrionCheatManagerBase_OrionDemoMode final
{
public:
	bool                                          bDemoMode;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_OrionDemoMode) == 0x000001, "Wrong alignment on OrionCheatManagerBase_OrionDemoMode");
static_assert(sizeof(OrionCheatManagerBase_OrionDemoMode) == 0x000001, "Wrong size on OrionCheatManagerBase_OrionDemoMode");
static_assert(offsetof(OrionCheatManagerBase_OrionDemoMode, bDemoMode) == 0x000000, "Member 'OrionCheatManagerBase_OrionDemoMode::bDemoMode' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.OrionForceCharLOD
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerBase_OrionForceCharLOD final
{
public:
	int32                                         LOD;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_OrionForceCharLOD) == 0x000004, "Wrong alignment on OrionCheatManagerBase_OrionForceCharLOD");
static_assert(sizeof(OrionCheatManagerBase_OrionForceCharLOD) == 0x000004, "Wrong size on OrionCheatManagerBase_OrionForceCharLOD");
static_assert(offsetof(OrionCheatManagerBase_OrionForceCharLOD, LOD) == 0x000000, "Member 'OrionCheatManagerBase_OrionForceCharLOD::LOD' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.OrionWatermark
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerBase_OrionWatermark final
{
public:
	int32                                         Enable;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_OrionWatermark) == 0x000004, "Wrong alignment on OrionCheatManagerBase_OrionWatermark");
static_assert(sizeof(OrionCheatManagerBase_OrionWatermark) == 0x000004, "Wrong size on OrionCheatManagerBase_OrionWatermark");
static_assert(offsetof(OrionCheatManagerBase_OrionWatermark, Enable) == 0x000000, "Member 'OrionCheatManagerBase_OrionWatermark::Enable' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.PlayVideo
// 0x0010 (0x0010 - 0x0000)
struct OrionCheatManagerBase_PlayVideo final
{
public:
	class FString                                 VideoID;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_PlayVideo) == 0x000008, "Wrong alignment on OrionCheatManagerBase_PlayVideo");
static_assert(sizeof(OrionCheatManagerBase_PlayVideo) == 0x000010, "Wrong size on OrionCheatManagerBase_PlayVideo");
static_assert(offsetof(OrionCheatManagerBase_PlayVideo, VideoID) == 0x000000, "Member 'OrionCheatManagerBase_PlayVideo::VideoID' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.ReplaySetAperture
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerBase_ReplaySetAperture final
{
public:
	float                                         FStop;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_ReplaySetAperture) == 0x000004, "Wrong alignment on OrionCheatManagerBase_ReplaySetAperture");
static_assert(sizeof(OrionCheatManagerBase_ReplaySetAperture) == 0x000004, "Wrong size on OrionCheatManagerBase_ReplaySetAperture");
static_assert(offsetof(OrionCheatManagerBase_ReplaySetAperture, FStop) == 0x000000, "Member 'OrionCheatManagerBase_ReplaySetAperture::FStop' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.ReplaySetDroneCollision
// 0x0001 (0x0001 - 0x0000)
struct OrionCheatManagerBase_ReplaySetDroneCollision final
{
public:
	bool                                          bCollides;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_ReplaySetDroneCollision) == 0x000001, "Wrong alignment on OrionCheatManagerBase_ReplaySetDroneCollision");
static_assert(sizeof(OrionCheatManagerBase_ReplaySetDroneCollision) == 0x000001, "Wrong size on OrionCheatManagerBase_ReplaySetDroneCollision");
static_assert(offsetof(OrionCheatManagerBase_ReplaySetDroneCollision, bCollides) == 0x000000, "Member 'OrionCheatManagerBase_ReplaySetDroneCollision::bCollides' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.ReplaySetManualExposure
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerBase_ReplaySetManualExposure final
{
public:
	float                                         ExposureBias;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_ReplaySetManualExposure) == 0x000004, "Wrong alignment on OrionCheatManagerBase_ReplaySetManualExposure");
static_assert(sizeof(OrionCheatManagerBase_ReplaySetManualExposure) == 0x000004, "Wrong size on OrionCheatManagerBase_ReplaySetManualExposure");
static_assert(offsetof(OrionCheatManagerBase_ReplaySetManualExposure, ExposureBias) == 0x000000, "Member 'OrionCheatManagerBase_ReplaySetManualExposure::ExposureBias' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.ReplaySetManualFocus
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerBase_ReplaySetManualFocus final
{
public:
	float                                         NewFocusDistance;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_ReplaySetManualFocus) == 0x000004, "Wrong alignment on OrionCheatManagerBase_ReplaySetManualFocus");
static_assert(sizeof(OrionCheatManagerBase_ReplaySetManualFocus) == 0x000004, "Wrong size on OrionCheatManagerBase_ReplaySetManualFocus");
static_assert(offsetof(OrionCheatManagerBase_ReplaySetManualFocus, NewFocusDistance) == 0x000000, "Member 'OrionCheatManagerBase_ReplaySetManualFocus::NewFocusDistance' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.ReplayShowFocusPlane
// 0x0001 (0x0001 - 0x0000)
struct OrionCheatManagerBase_ReplayShowFocusPlane final
{
public:
	bool                                          bShowFocusPlane;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_ReplayShowFocusPlane) == 0x000001, "Wrong alignment on OrionCheatManagerBase_ReplayShowFocusPlane");
static_assert(sizeof(OrionCheatManagerBase_ReplayShowFocusPlane) == 0x000001, "Wrong size on OrionCheatManagerBase_ReplayShowFocusPlane");
static_assert(offsetof(OrionCheatManagerBase_ReplayShowFocusPlane, bShowFocusPlane) == 0x000000, "Member 'OrionCheatManagerBase_ReplayShowFocusPlane::bShowFocusPlane' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.SetGamepadConfig
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerBase_SetGamepadConfig final
{
public:
	int32                                         ConfigIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_SetGamepadConfig) == 0x000004, "Wrong alignment on OrionCheatManagerBase_SetGamepadConfig");
static_assert(sizeof(OrionCheatManagerBase_SetGamepadConfig) == 0x000004, "Wrong size on OrionCheatManagerBase_SetGamepadConfig");
static_assert(offsetof(OrionCheatManagerBase_SetGamepadConfig, ConfigIndex) == 0x000000, "Member 'OrionCheatManagerBase_SetGamepadConfig::ConfigIndex' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.SetGamepadSensitivity
// 0x0008 (0x0008 - 0x0000)
struct OrionCheatManagerBase_SetGamepadSensitivity final
{
public:
	int32                                         YawIndex;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PitchIndex;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_SetGamepadSensitivity) == 0x000004, "Wrong alignment on OrionCheatManagerBase_SetGamepadSensitivity");
static_assert(sizeof(OrionCheatManagerBase_SetGamepadSensitivity) == 0x000008, "Wrong size on OrionCheatManagerBase_SetGamepadSensitivity");
static_assert(offsetof(OrionCheatManagerBase_SetGamepadSensitivity, YawIndex) == 0x000000, "Member 'OrionCheatManagerBase_SetGamepadSensitivity::YawIndex' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerBase_SetGamepadSensitivity, PitchIndex) == 0x000004, "Member 'OrionCheatManagerBase_SetGamepadSensitivity::PitchIndex' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.SetHomeScreenHero
// 0x0030 (0x0030 - 0x0000)
struct OrionCheatManagerBase_SetHomeScreenHero final
{
public:
	class FString                                 HeroName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Skin;                                              // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SkinVariation;                                     // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_SetHomeScreenHero) == 0x000008, "Wrong alignment on OrionCheatManagerBase_SetHomeScreenHero");
static_assert(sizeof(OrionCheatManagerBase_SetHomeScreenHero) == 0x000030, "Wrong size on OrionCheatManagerBase_SetHomeScreenHero");
static_assert(offsetof(OrionCheatManagerBase_SetHomeScreenHero, HeroName) == 0x000000, "Member 'OrionCheatManagerBase_SetHomeScreenHero::HeroName' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerBase_SetHomeScreenHero, Skin) == 0x000010, "Member 'OrionCheatManagerBase_SetHomeScreenHero::Skin' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerBase_SetHomeScreenHero, SkinVariation) == 0x000020, "Member 'OrionCheatManagerBase_SetHomeScreenHero::SkinVariation' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.SetInputMode
// 0x0001 (0x0001 - 0x0000)
struct OrionCheatManagerBase_SetInputMode final
{
public:
	EOrionInputType                               Mode;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_SetInputMode) == 0x000001, "Wrong alignment on OrionCheatManagerBase_SetInputMode");
static_assert(sizeof(OrionCheatManagerBase_SetInputMode) == 0x000001, "Wrong size on OrionCheatManagerBase_SetInputMode");
static_assert(offsetof(OrionCheatManagerBase_SetInputMode, Mode) == 0x000000, "Member 'OrionCheatManagerBase_SetInputMode::Mode' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.SetNumLobbyPlayers
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerBase_SetNumLobbyPlayers final
{
public:
	int32                                         NumLobbyPlayers;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_SetNumLobbyPlayers) == 0x000004, "Wrong alignment on OrionCheatManagerBase_SetNumLobbyPlayers");
static_assert(sizeof(OrionCheatManagerBase_SetNumLobbyPlayers) == 0x000004, "Wrong size on OrionCheatManagerBase_SetNumLobbyPlayers");
static_assert(offsetof(OrionCheatManagerBase_SetNumLobbyPlayers, NumLobbyPlayers) == 0x000000, "Member 'OrionCheatManagerBase_SetNumLobbyPlayers::NumLobbyPlayers' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.SetParallaxLerpSpeed
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerBase_SetParallaxLerpSpeed final
{
public:
	float                                         LerpSpeed;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_SetParallaxLerpSpeed) == 0x000004, "Wrong alignment on OrionCheatManagerBase_SetParallaxLerpSpeed");
static_assert(sizeof(OrionCheatManagerBase_SetParallaxLerpSpeed) == 0x000004, "Wrong size on OrionCheatManagerBase_SetParallaxLerpSpeed");
static_assert(offsetof(OrionCheatManagerBase_SetParallaxLerpSpeed, LerpSpeed) == 0x000000, "Member 'OrionCheatManagerBase_SetParallaxLerpSpeed::LerpSpeed' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.SetParallaxScaleFactor
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerBase_SetParallaxScaleFactor final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_SetParallaxScaleFactor) == 0x000004, "Wrong alignment on OrionCheatManagerBase_SetParallaxScaleFactor");
static_assert(sizeof(OrionCheatManagerBase_SetParallaxScaleFactor) == 0x000004, "Wrong size on OrionCheatManagerBase_SetParallaxScaleFactor");
static_assert(offsetof(OrionCheatManagerBase_SetParallaxScaleFactor, Factor) == 0x000000, "Member 'OrionCheatManagerBase_SetParallaxScaleFactor::Factor' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.SetPerfBots
// 0x0010 (0x0010 - 0x0000)
struct OrionCheatManagerBase_SetPerfBots final
{
public:
	class FString                                 HeroList;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_SetPerfBots) == 0x000008, "Wrong alignment on OrionCheatManagerBase_SetPerfBots");
static_assert(sizeof(OrionCheatManagerBase_SetPerfBots) == 0x000010, "Wrong size on OrionCheatManagerBase_SetPerfBots");
static_assert(offsetof(OrionCheatManagerBase_SetPerfBots, HeroList) == 0x000000, "Member 'OrionCheatManagerBase_SetPerfBots::HeroList' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.ShowLoadingScreen
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerBase_ShowLoadingScreen final
{
public:
	int32                                         Mode;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_ShowLoadingScreen) == 0x000004, "Wrong alignment on OrionCheatManagerBase_ShowLoadingScreen");
static_assert(sizeof(OrionCheatManagerBase_ShowLoadingScreen) == 0x000004, "Wrong size on OrionCheatManagerBase_ShowLoadingScreen");
static_assert(offsetof(OrionCheatManagerBase_ShowLoadingScreen, Mode) == 0x000000, "Member 'OrionCheatManagerBase_ShowLoadingScreen::Mode' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.ShowLoadingScreenByName
// 0x0010 (0x0010 - 0x0000)
struct OrionCheatManagerBase_ShowLoadingScreenByName final
{
public:
	class FString                                 ModeName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_ShowLoadingScreenByName) == 0x000008, "Wrong alignment on OrionCheatManagerBase_ShowLoadingScreenByName");
static_assert(sizeof(OrionCheatManagerBase_ShowLoadingScreenByName) == 0x000010, "Wrong size on OrionCheatManagerBase_ShowLoadingScreenByName");
static_assert(offsetof(OrionCheatManagerBase_ShowLoadingScreenByName, ModeName) == 0x000000, "Member 'OrionCheatManagerBase_ShowLoadingScreenByName::ModeName' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.TBAcceptSocialInvite
// 0x0001 (0x0001 - 0x0000)
struct OrionCheatManagerBase_TBAcceptSocialInvite final
{
public:
	bool                                          bAccept;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_TBAcceptSocialInvite) == 0x000001, "Wrong alignment on OrionCheatManagerBase_TBAcceptSocialInvite");
static_assert(sizeof(OrionCheatManagerBase_TBAcceptSocialInvite) == 0x000001, "Wrong size on OrionCheatManagerBase_TBAcceptSocialInvite");
static_assert(offsetof(OrionCheatManagerBase_TBAcceptSocialInvite, bAccept) == 0x000000, "Member 'OrionCheatManagerBase_TBAcceptSocialInvite::bAccept' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.TBCancelSlot
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerBase_TBCancelSlot final
{
public:
	int32                                         SlotIdx;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_TBCancelSlot) == 0x000004, "Wrong alignment on OrionCheatManagerBase_TBCancelSlot");
static_assert(sizeof(OrionCheatManagerBase_TBCancelSlot) == 0x000004, "Wrong size on OrionCheatManagerBase_TBCancelSlot");
static_assert(offsetof(OrionCheatManagerBase_TBCancelSlot, SlotIdx) == 0x000000, "Member 'OrionCheatManagerBase_TBCancelSlot::SlotIdx' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.TBCaptainAcceptSlot
// 0x0008 (0x0008 - 0x0000)
struct OrionCheatManagerBase_TBCaptainAcceptSlot final
{
public:
	int32                                         SlotIdx;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAccept;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionCheatManagerBase_TBCaptainAcceptSlot) == 0x000004, "Wrong alignment on OrionCheatManagerBase_TBCaptainAcceptSlot");
static_assert(sizeof(OrionCheatManagerBase_TBCaptainAcceptSlot) == 0x000008, "Wrong size on OrionCheatManagerBase_TBCaptainAcceptSlot");
static_assert(offsetof(OrionCheatManagerBase_TBCaptainAcceptSlot, SlotIdx) == 0x000000, "Member 'OrionCheatManagerBase_TBCaptainAcceptSlot::SlotIdx' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerBase_TBCaptainAcceptSlot, bAccept) == 0x000004, "Member 'OrionCheatManagerBase_TBCaptainAcceptSlot::bAccept' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.TBMultiSoloRider
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerBase_TBMultiSoloRider final
{
public:
	int32                                         NumRiders;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_TBMultiSoloRider) == 0x000004, "Wrong alignment on OrionCheatManagerBase_TBMultiSoloRider");
static_assert(sizeof(OrionCheatManagerBase_TBMultiSoloRider) == 0x000004, "Wrong size on OrionCheatManagerBase_TBMultiSoloRider");
static_assert(offsetof(OrionCheatManagerBase_TBMultiSoloRider, NumRiders) == 0x000000, "Member 'OrionCheatManagerBase_TBMultiSoloRider::NumRiders' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.TBQuickmatch
// 0x0018 (0x0018 - 0x0000)
struct OrionCheatManagerBase_TBQuickmatch final
{
public:
	bool                                          bCoopVsAI;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 HeroName;                                          // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_TBQuickmatch) == 0x000008, "Wrong alignment on OrionCheatManagerBase_TBQuickmatch");
static_assert(sizeof(OrionCheatManagerBase_TBQuickmatch) == 0x000018, "Wrong size on OrionCheatManagerBase_TBQuickmatch");
static_assert(offsetof(OrionCheatManagerBase_TBQuickmatch, bCoopVsAI) == 0x000000, "Member 'OrionCheatManagerBase_TBQuickmatch::bCoopVsAI' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerBase_TBQuickmatch, HeroName) == 0x000008, "Member 'OrionCheatManagerBase_TBQuickmatch::HeroName' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.TBSetReady
// 0x0001 (0x0001 - 0x0000)
struct OrionCheatManagerBase_TBSetReady final
{
public:
	bool                                          bReady;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_TBSetReady) == 0x000001, "Wrong alignment on OrionCheatManagerBase_TBSetReady");
static_assert(sizeof(OrionCheatManagerBase_TBSetReady) == 0x000001, "Wrong size on OrionCheatManagerBase_TBSetReady");
static_assert(offsetof(OrionCheatManagerBase_TBSetReady, bReady) == 0x000000, "Member 'OrionCheatManagerBase_TBSetReady::bReady' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.TBSetSlotChoice
// 0x000C (0x000C - 0x0000)
struct OrionCheatManagerBase_TBSetSlotChoice final
{
public:
	int32                                         SlotIdx;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Position;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Role;                                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_TBSetSlotChoice) == 0x000004, "Wrong alignment on OrionCheatManagerBase_TBSetSlotChoice");
static_assert(sizeof(OrionCheatManagerBase_TBSetSlotChoice) == 0x00000C, "Wrong size on OrionCheatManagerBase_TBSetSlotChoice");
static_assert(offsetof(OrionCheatManagerBase_TBSetSlotChoice, SlotIdx) == 0x000000, "Member 'OrionCheatManagerBase_TBSetSlotChoice::SlotIdx' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerBase_TBSetSlotChoice, Position) == 0x000004, "Member 'OrionCheatManagerBase_TBSetSlotChoice::Position' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerBase_TBSetSlotChoice, Role) == 0x000008, "Member 'OrionCheatManagerBase_TBSetSlotChoice::Role' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.TBUnlockSoloRider
// 0x0010 (0x0010 - 0x0000)
struct OrionCheatManagerBase_TBUnlockSoloRider final
{
public:
	class FString                                 SoloriderUserId;                                   // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_TBUnlockSoloRider) == 0x000008, "Wrong alignment on OrionCheatManagerBase_TBUnlockSoloRider");
static_assert(sizeof(OrionCheatManagerBase_TBUnlockSoloRider) == 0x000010, "Wrong size on OrionCheatManagerBase_TBUnlockSoloRider");
static_assert(offsetof(OrionCheatManagerBase_TBUnlockSoloRider, SoloriderUserId) == 0x000000, "Member 'OrionCheatManagerBase_TBUnlockSoloRider::SoloriderUserId' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.TestChangePartyPrivacy
// 0x0003 (0x0003 - 0x0000)
struct OrionCheatManagerBase_TestChangePartyPrivacy final
{
public:
	bool                                          bPrivate;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeaderFriendsOnly;                                // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeaderInvitesOnly;                                // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_TestChangePartyPrivacy) == 0x000001, "Wrong alignment on OrionCheatManagerBase_TestChangePartyPrivacy");
static_assert(sizeof(OrionCheatManagerBase_TestChangePartyPrivacy) == 0x000003, "Wrong size on OrionCheatManagerBase_TestChangePartyPrivacy");
static_assert(offsetof(OrionCheatManagerBase_TestChangePartyPrivacy, bPrivate) == 0x000000, "Member 'OrionCheatManagerBase_TestChangePartyPrivacy::bPrivate' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerBase_TestChangePartyPrivacy, bLeaderFriendsOnly) == 0x000001, "Member 'OrionCheatManagerBase_TestChangePartyPrivacy::bLeaderFriendsOnly' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerBase_TestChangePartyPrivacy, bLeaderInvitesOnly) == 0x000002, "Member 'OrionCheatManagerBase_TestChangePartyPrivacy::bLeaderInvitesOnly' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.TestChangePartySize
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerBase_TestChangePartySize final
{
public:
	int32                                         NewSize;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_TestChangePartySize) == 0x000004, "Wrong alignment on OrionCheatManagerBase_TestChangePartySize");
static_assert(sizeof(OrionCheatManagerBase_TestChangePartySize) == 0x000004, "Wrong size on OrionCheatManagerBase_TestChangePartySize");
static_assert(offsetof(OrionCheatManagerBase_TestChangePartySize, NewSize) == 0x000000, "Member 'OrionCheatManagerBase_TestChangePartySize::NewSize' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.TestComputeBestTeamComp
// 0x0010 (0x0010 - 0x0000)
struct OrionCheatManagerBase_TestComputeBestTeamComp final
{
public:
	class FString                                 HeroListName;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_TestComputeBestTeamComp) == 0x000008, "Wrong alignment on OrionCheatManagerBase_TestComputeBestTeamComp");
static_assert(sizeof(OrionCheatManagerBase_TestComputeBestTeamComp) == 0x000010, "Wrong size on OrionCheatManagerBase_TestComputeBestTeamComp");
static_assert(offsetof(OrionCheatManagerBase_TestComputeBestTeamComp, HeroListName) == 0x000000, "Member 'OrionCheatManagerBase_TestComputeBestTeamComp::HeroListName' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.TestGracefulShutdownServer
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerBase_TestGracefulShutdownServer final
{
public:
	int32                                         ExitCode;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_TestGracefulShutdownServer) == 0x000004, "Wrong alignment on OrionCheatManagerBase_TestGracefulShutdownServer");
static_assert(sizeof(OrionCheatManagerBase_TestGracefulShutdownServer) == 0x000004, "Wrong size on OrionCheatManagerBase_TestGracefulShutdownServer");
static_assert(offsetof(OrionCheatManagerBase_TestGracefulShutdownServer, ExitCode) == 0x000000, "Member 'OrionCheatManagerBase_TestGracefulShutdownServer::ExitCode' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.TestLobbyBuilderAcceptMatch
// 0x0001 (0x0001 - 0x0000)
struct OrionCheatManagerBase_TestLobbyBuilderAcceptMatch final
{
public:
	bool                                          bAcceptMatch;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_TestLobbyBuilderAcceptMatch) == 0x000001, "Wrong alignment on OrionCheatManagerBase_TestLobbyBuilderAcceptMatch");
static_assert(sizeof(OrionCheatManagerBase_TestLobbyBuilderAcceptMatch) == 0x000001, "Wrong size on OrionCheatManagerBase_TestLobbyBuilderAcceptMatch");
static_assert(offsetof(OrionCheatManagerBase_TestLobbyBuilderAcceptMatch, bAcceptMatch) == 0x000000, "Member 'OrionCheatManagerBase_TestLobbyBuilderAcceptMatch::bAcceptMatch' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.TestLobbyBuilderMatchmake
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerBase_TestLobbyBuilderMatchmake final
{
public:
	int32                                         PlaylistId;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_TestLobbyBuilderMatchmake) == 0x000004, "Wrong alignment on OrionCheatManagerBase_TestLobbyBuilderMatchmake");
static_assert(sizeof(OrionCheatManagerBase_TestLobbyBuilderMatchmake) == 0x000004, "Wrong size on OrionCheatManagerBase_TestLobbyBuilderMatchmake");
static_assert(offsetof(OrionCheatManagerBase_TestLobbyBuilderMatchmake, PlaylistId) == 0x000000, "Member 'OrionCheatManagerBase_TestLobbyBuilderMatchmake::PlaylistId' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.TestSoloRiderAcceptOrRejectInvite
// 0x0008 (0x0008 - 0x0000)
struct OrionCheatManagerBase_TestSoloRiderAcceptOrRejectInvite final
{
public:
	bool                                          bAccept;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RiderIdx;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_TestSoloRiderAcceptOrRejectInvite) == 0x000004, "Wrong alignment on OrionCheatManagerBase_TestSoloRiderAcceptOrRejectInvite");
static_assert(sizeof(OrionCheatManagerBase_TestSoloRiderAcceptOrRejectInvite) == 0x000008, "Wrong size on OrionCheatManagerBase_TestSoloRiderAcceptOrRejectInvite");
static_assert(offsetof(OrionCheatManagerBase_TestSoloRiderAcceptOrRejectInvite, bAccept) == 0x000000, "Member 'OrionCheatManagerBase_TestSoloRiderAcceptOrRejectInvite::bAccept' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerBase_TestSoloRiderAcceptOrRejectInvite, RiderIdx) == 0x000004, "Member 'OrionCheatManagerBase_TestSoloRiderAcceptOrRejectInvite::RiderIdx' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.TestSoloRiderStartAdvertising
// 0x0018 (0x0018 - 0x0000)
struct OrionCheatManagerBase_TestSoloRiderStartAdvertising final
{
public:
	class FString                                 HeroName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Position;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Role;                                              // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_TestSoloRiderStartAdvertising) == 0x000008, "Wrong alignment on OrionCheatManagerBase_TestSoloRiderStartAdvertising");
static_assert(sizeof(OrionCheatManagerBase_TestSoloRiderStartAdvertising) == 0x000018, "Wrong size on OrionCheatManagerBase_TestSoloRiderStartAdvertising");
static_assert(offsetof(OrionCheatManagerBase_TestSoloRiderStartAdvertising, HeroName) == 0x000000, "Member 'OrionCheatManagerBase_TestSoloRiderStartAdvertising::HeroName' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerBase_TestSoloRiderStartAdvertising, Position) == 0x000010, "Member 'OrionCheatManagerBase_TestSoloRiderStartAdvertising::Position' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerBase_TestSoloRiderStartAdvertising, Role) == 0x000014, "Member 'OrionCheatManagerBase_TestSoloRiderStartAdvertising::Role' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.ToggleUI
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerBase_ToggleUI final
{
public:
	int32                                         Enable;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_ToggleUI) == 0x000004, "Wrong alignment on OrionCheatManagerBase_ToggleUI");
static_assert(sizeof(OrionCheatManagerBase_ToggleUI) == 0x000004, "Wrong size on OrionCheatManagerBase_ToggleUI");
static_assert(offsetof(OrionCheatManagerBase_ToggleUI, Enable) == 0x000000, "Member 'OrionCheatManagerBase_ToggleUI::Enable' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.TriggerReturnFromAfk
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerBase_TriggerReturnFromAfk final
{
public:
	int32                                         NewAfkPeriod;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerBase_TriggerReturnFromAfk) == 0x000004, "Wrong alignment on OrionCheatManagerBase_TriggerReturnFromAfk");
static_assert(sizeof(OrionCheatManagerBase_TriggerReturnFromAfk) == 0x000004, "Wrong size on OrionCheatManagerBase_TriggerReturnFromAfk");
static_assert(offsetof(OrionCheatManagerBase_TriggerReturnFromAfk, NewAfkPeriod) == 0x000000, "Member 'OrionCheatManagerBase_TriggerReturnFromAfk::NewAfkPeriod' has a wrong offset!");

// Function OrionGame.OrionCheatManagerBase.UdpPingAddr
// 0x0018 (0x0018 - 0x0000)
struct OrionCheatManagerBase_UdpPingAddr final
{
public:
	class FString                                 Target;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timeout;                                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionCheatManagerBase_UdpPingAddr) == 0x000008, "Wrong alignment on OrionCheatManagerBase_UdpPingAddr");
static_assert(sizeof(OrionCheatManagerBase_UdpPingAddr) == 0x000018, "Wrong size on OrionCheatManagerBase_UdpPingAddr");
static_assert(offsetof(OrionCheatManagerBase_UdpPingAddr, Target) == 0x000000, "Member 'OrionCheatManagerBase_UdpPingAddr::Target' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerBase_UdpPingAddr, Timeout) == 0x000010, "Member 'OrionCheatManagerBase_UdpPingAddr::Timeout' has a wrong offset!");

// Function OrionGame.OrionUserWidgetBase.FireAnalyticsEvent
// 0x0028 (0x0028 - 0x0000)
struct OrionUserWidgetBase_FireAnalyticsEvent final
{
public:
	EOrionUIAnalyticsTrackingLevel                EventTrackingLevel;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 WidgetType;                                        // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EventName;                                         // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUserWidgetBase_FireAnalyticsEvent) == 0x000008, "Wrong alignment on OrionUserWidgetBase_FireAnalyticsEvent");
static_assert(sizeof(OrionUserWidgetBase_FireAnalyticsEvent) == 0x000028, "Wrong size on OrionUserWidgetBase_FireAnalyticsEvent");
static_assert(offsetof(OrionUserWidgetBase_FireAnalyticsEvent, EventTrackingLevel) == 0x000000, "Member 'OrionUserWidgetBase_FireAnalyticsEvent::EventTrackingLevel' has a wrong offset!");
static_assert(offsetof(OrionUserWidgetBase_FireAnalyticsEvent, WidgetType) == 0x000008, "Member 'OrionUserWidgetBase_FireAnalyticsEvent::WidgetType' has a wrong offset!");
static_assert(offsetof(OrionUserWidgetBase_FireAnalyticsEvent, EventName) == 0x000018, "Member 'OrionUserWidgetBase_FireAnalyticsEvent::EventName' has a wrong offset!");

// Function OrionGame.OrionUserWidgetBase.FireAnalyticsEventWithParam
// 0x0048 (0x0048 - 0x0000)
struct OrionUserWidgetBase_FireAnalyticsEventWithParam final
{
public:
	EOrionUIAnalyticsTrackingLevel                EventTrackingLevel;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 WidgetType;                                        // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EventName;                                         // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ParamName;                                         // 0x0028(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ParamValue;                                        // 0x0038(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUserWidgetBase_FireAnalyticsEventWithParam) == 0x000008, "Wrong alignment on OrionUserWidgetBase_FireAnalyticsEventWithParam");
static_assert(sizeof(OrionUserWidgetBase_FireAnalyticsEventWithParam) == 0x000048, "Wrong size on OrionUserWidgetBase_FireAnalyticsEventWithParam");
static_assert(offsetof(OrionUserWidgetBase_FireAnalyticsEventWithParam, EventTrackingLevel) == 0x000000, "Member 'OrionUserWidgetBase_FireAnalyticsEventWithParam::EventTrackingLevel' has a wrong offset!");
static_assert(offsetof(OrionUserWidgetBase_FireAnalyticsEventWithParam, WidgetType) == 0x000008, "Member 'OrionUserWidgetBase_FireAnalyticsEventWithParam::WidgetType' has a wrong offset!");
static_assert(offsetof(OrionUserWidgetBase_FireAnalyticsEventWithParam, EventName) == 0x000018, "Member 'OrionUserWidgetBase_FireAnalyticsEventWithParam::EventName' has a wrong offset!");
static_assert(offsetof(OrionUserWidgetBase_FireAnalyticsEventWithParam, ParamName) == 0x000028, "Member 'OrionUserWidgetBase_FireAnalyticsEventWithParam::ParamName' has a wrong offset!");
static_assert(offsetof(OrionUserWidgetBase_FireAnalyticsEventWithParam, ParamValue) == 0x000038, "Member 'OrionUserWidgetBase_FireAnalyticsEventWithParam::ParamValue' has a wrong offset!");

// Function OrionGame.OrionUserWidgetBase.InitTooltipAnchor
// 0x0001 (0x0001 - 0x0000)
struct OrionUserWidgetBase_InitTooltipAnchor final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUserWidgetBase_InitTooltipAnchor) == 0x000001, "Wrong alignment on OrionUserWidgetBase_InitTooltipAnchor");
static_assert(sizeof(OrionUserWidgetBase_InitTooltipAnchor) == 0x000001, "Wrong size on OrionUserWidgetBase_InitTooltipAnchor");
static_assert(offsetof(OrionUserWidgetBase_InitTooltipAnchor, ReturnValue) == 0x000000, "Member 'OrionUserWidgetBase_InitTooltipAnchor::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUserWidgetBase.SetBasicTooltipInfo
// 0x0030 (0x0030 - 0x0000)
struct OrionUserWidgetBase_SetBasicTooltipInfo final
{
public:
	class FText                                   NewTooltipTitle;                                   // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   NewTooltipText;                                    // 0x0018(0x0018)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUserWidgetBase_SetBasicTooltipInfo) == 0x000008, "Wrong alignment on OrionUserWidgetBase_SetBasicTooltipInfo");
static_assert(sizeof(OrionUserWidgetBase_SetBasicTooltipInfo) == 0x000030, "Wrong size on OrionUserWidgetBase_SetBasicTooltipInfo");
static_assert(offsetof(OrionUserWidgetBase_SetBasicTooltipInfo, NewTooltipTitle) == 0x000000, "Member 'OrionUserWidgetBase_SetBasicTooltipInfo::NewTooltipTitle' has a wrong offset!");
static_assert(offsetof(OrionUserWidgetBase_SetBasicTooltipInfo, NewTooltipText) == 0x000018, "Member 'OrionUserWidgetBase_SetBasicTooltipInfo::NewTooltipText' has a wrong offset!");

// Function OrionGame.OrionUserWidgetBase.SetBasicTooltipText
// 0x0018 (0x0018 - 0x0000)
struct OrionUserWidgetBase_SetBasicTooltipText final
{
public:
	class FText                                   NewTooltipText;                                    // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUserWidgetBase_SetBasicTooltipText) == 0x000008, "Wrong alignment on OrionUserWidgetBase_SetBasicTooltipText");
static_assert(sizeof(OrionUserWidgetBase_SetBasicTooltipText) == 0x000018, "Wrong size on OrionUserWidgetBase_SetBasicTooltipText");
static_assert(offsetof(OrionUserWidgetBase_SetBasicTooltipText, NewTooltipText) == 0x000000, "Member 'OrionUserWidgetBase_SetBasicTooltipText::NewTooltipText' has a wrong offset!");

// Function OrionGame.OrionUserWidgetBase.SetBasicTooltipTitle
// 0x0018 (0x0018 - 0x0000)
struct OrionUserWidgetBase_SetBasicTooltipTitle final
{
public:
	class FText                                   NewTooltipTitle;                                   // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUserWidgetBase_SetBasicTooltipTitle) == 0x000008, "Wrong alignment on OrionUserWidgetBase_SetBasicTooltipTitle");
static_assert(sizeof(OrionUserWidgetBase_SetBasicTooltipTitle) == 0x000018, "Wrong size on OrionUserWidgetBase_SetBasicTooltipTitle");
static_assert(offsetof(OrionUserWidgetBase_SetBasicTooltipTitle, NewTooltipTitle) == 0x000000, "Member 'OrionUserWidgetBase_SetBasicTooltipTitle::NewTooltipTitle' has a wrong offset!");

// Function OrionGame.OrionUserWidgetBase.SetTooltipAnchorPlacement
// 0x0001 (0x0001 - 0x0000)
struct OrionUserWidgetBase_SetTooltipAnchorPlacement final
{
public:
	EMenuPlacement                                TooltipPlacement;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUserWidgetBase_SetTooltipAnchorPlacement) == 0x000001, "Wrong alignment on OrionUserWidgetBase_SetTooltipAnchorPlacement");
static_assert(sizeof(OrionUserWidgetBase_SetTooltipAnchorPlacement) == 0x000001, "Wrong size on OrionUserWidgetBase_SetTooltipAnchorPlacement");
static_assert(offsetof(OrionUserWidgetBase_SetTooltipAnchorPlacement, TooltipPlacement) == 0x000000, "Member 'OrionUserWidgetBase_SetTooltipAnchorPlacement::TooltipPlacement' has a wrong offset!");

// Function OrionGame.OrionUserWidgetBase.BP_OnGetTooltipWidget
// 0x0008 (0x0008 - 0x0000)
struct OrionUserWidgetBase_BP_OnGetTooltipWidget final
{
public:
	class UWidget*                                ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUserWidgetBase_BP_OnGetTooltipWidget) == 0x000008, "Wrong alignment on OrionUserWidgetBase_BP_OnGetTooltipWidget");
static_assert(sizeof(OrionUserWidgetBase_BP_OnGetTooltipWidget) == 0x000008, "Wrong size on OrionUserWidgetBase_BP_OnGetTooltipWidget");
static_assert(offsetof(OrionUserWidgetBase_BP_OnGetTooltipWidget, ReturnValue) == 0x000000, "Member 'OrionUserWidgetBase_BP_OnGetTooltipWidget::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUserWidgetBase.GetBasicTooltipText
// 0x0018 (0x0018 - 0x0000)
struct OrionUserWidgetBase_GetBasicTooltipText final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUserWidgetBase_GetBasicTooltipText) == 0x000008, "Wrong alignment on OrionUserWidgetBase_GetBasicTooltipText");
static_assert(sizeof(OrionUserWidgetBase_GetBasicTooltipText) == 0x000018, "Wrong size on OrionUserWidgetBase_GetBasicTooltipText");
static_assert(offsetof(OrionUserWidgetBase_GetBasicTooltipText, ReturnValue) == 0x000000, "Member 'OrionUserWidgetBase_GetBasicTooltipText::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUserWidgetBase.GetClientSettings
// 0x0008 (0x0008 - 0x0000)
struct OrionUserWidgetBase_GetClientSettings final
{
public:
	class UOrionClientSettingsRecord*             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUserWidgetBase_GetClientSettings) == 0x000008, "Wrong alignment on OrionUserWidgetBase_GetClientSettings");
static_assert(sizeof(OrionUserWidgetBase_GetClientSettings) == 0x000008, "Wrong size on OrionUserWidgetBase_GetClientSettings");
static_assert(offsetof(OrionUserWidgetBase_GetClientSettings, ReturnValue) == 0x000000, "Member 'OrionUserWidgetBase_GetClientSettings::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionActivatableWidget.AddDeactivateAnalyticsParam
// 0x0020 (0x0020 - 0x0000)
struct OrionActivatableWidget_AddDeactivateAnalyticsParam final
{
public:
	class FString                                 ParamName;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ParamValue;                                        // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionActivatableWidget_AddDeactivateAnalyticsParam) == 0x000008, "Wrong alignment on OrionActivatableWidget_AddDeactivateAnalyticsParam");
static_assert(sizeof(OrionActivatableWidget_AddDeactivateAnalyticsParam) == 0x000020, "Wrong size on OrionActivatableWidget_AddDeactivateAnalyticsParam");
static_assert(offsetof(OrionActivatableWidget_AddDeactivateAnalyticsParam, ParamName) == 0x000000, "Member 'OrionActivatableWidget_AddDeactivateAnalyticsParam::ParamName' has a wrong offset!");
static_assert(offsetof(OrionActivatableWidget_AddDeactivateAnalyticsParam, ParamValue) == 0x000010, "Member 'OrionActivatableWidget_AddDeactivateAnalyticsParam::ParamValue' has a wrong offset!");

// Function OrionGame.OrionActivatableWidget.OnHandleBackAction
// 0x0001 (0x0001 - 0x0000)
struct OrionActivatableWidget_OnHandleBackAction final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionActivatableWidget_OnHandleBackAction) == 0x000001, "Wrong alignment on OrionActivatableWidget_OnHandleBackAction");
static_assert(sizeof(OrionActivatableWidget_OnHandleBackAction) == 0x000001, "Wrong size on OrionActivatableWidget_OnHandleBackAction");
static_assert(offsetof(OrionActivatableWidget_OnHandleBackAction, ReturnValue) == 0x000000, "Member 'OrionActivatableWidget_OnHandleBackAction::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTargetingMode_FacetShape.OnConfirmAllowedChange
// 0x0001 (0x0001 - 0x0000)
struct OrionTargetingMode_FacetShape_OnConfirmAllowedChange final
{
public:
	bool                                          ConfirmAllowed;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTargetingMode_FacetShape_OnConfirmAllowedChange) == 0x000001, "Wrong alignment on OrionTargetingMode_FacetShape_OnConfirmAllowedChange");
static_assert(sizeof(OrionTargetingMode_FacetShape_OnConfirmAllowedChange) == 0x000001, "Wrong size on OrionTargetingMode_FacetShape_OnConfirmAllowedChange");
static_assert(offsetof(OrionTargetingMode_FacetShape_OnConfirmAllowedChange, ConfirmAllowed) == 0x000000, "Member 'OrionTargetingMode_FacetShape_OnConfirmAllowedChange::ConfirmAllowed' has a wrong offset!");

// Function OrionGame.OrionTargetingMode_FacetShape.OnFacetBeamBuilt
// 0x001C (0x001C - 0x0000)
struct OrionTargetingMode_FacetShape_OnFacetBeamBuilt final
{
public:
	struct FVector                                Start;                                             // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTargetingMode_FacetShape_OnFacetBeamBuilt) == 0x000004, "Wrong alignment on OrionTargetingMode_FacetShape_OnFacetBeamBuilt");
static_assert(sizeof(OrionTargetingMode_FacetShape_OnFacetBeamBuilt) == 0x00001C, "Wrong size on OrionTargetingMode_FacetShape_OnFacetBeamBuilt");
static_assert(offsetof(OrionTargetingMode_FacetShape_OnFacetBeamBuilt, Start) == 0x000000, "Member 'OrionTargetingMode_FacetShape_OnFacetBeamBuilt::Start' has a wrong offset!");
static_assert(offsetof(OrionTargetingMode_FacetShape_OnFacetBeamBuilt, End) == 0x00000C, "Member 'OrionTargetingMode_FacetShape_OnFacetBeamBuilt::End' has a wrong offset!");
static_assert(offsetof(OrionTargetingMode_FacetShape_OnFacetBeamBuilt, Radius) == 0x000018, "Member 'OrionTargetingMode_FacetShape_OnFacetBeamBuilt::Radius' has a wrong offset!");

// Function OrionGame.OrionTargetingMode_FacetShape.OnFacetBoxBuilt
// 0x0018 (0x0018 - 0x0000)
struct OrionTargetingMode_FacetShape_OnFacetBoxBuilt final
{
public:
	struct FVector                                MinBounds;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MaxBounds;                                         // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTargetingMode_FacetShape_OnFacetBoxBuilt) == 0x000004, "Wrong alignment on OrionTargetingMode_FacetShape_OnFacetBoxBuilt");
static_assert(sizeof(OrionTargetingMode_FacetShape_OnFacetBoxBuilt) == 0x000018, "Wrong size on OrionTargetingMode_FacetShape_OnFacetBoxBuilt");
static_assert(offsetof(OrionTargetingMode_FacetShape_OnFacetBoxBuilt, MinBounds) == 0x000000, "Member 'OrionTargetingMode_FacetShape_OnFacetBoxBuilt::MinBounds' has a wrong offset!");
static_assert(offsetof(OrionTargetingMode_FacetShape_OnFacetBoxBuilt, MaxBounds) == 0x00000C, "Member 'OrionTargetingMode_FacetShape_OnFacetBoxBuilt::MaxBounds' has a wrong offset!");

// Function OrionGame.OrionTargetingMode_FacetShape.OnFacetCharacterBuilt
// 0x0008 (0x0008 - 0x0000)
struct OrionTargetingMode_FacetShape_OnFacetCharacterBuilt final
{
public:
	float                                         Radius;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfHeight;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTargetingMode_FacetShape_OnFacetCharacterBuilt) == 0x000004, "Wrong alignment on OrionTargetingMode_FacetShape_OnFacetCharacterBuilt");
static_assert(sizeof(OrionTargetingMode_FacetShape_OnFacetCharacterBuilt) == 0x000008, "Wrong size on OrionTargetingMode_FacetShape_OnFacetCharacterBuilt");
static_assert(offsetof(OrionTargetingMode_FacetShape_OnFacetCharacterBuilt, Radius) == 0x000000, "Member 'OrionTargetingMode_FacetShape_OnFacetCharacterBuilt::Radius' has a wrong offset!");
static_assert(offsetof(OrionTargetingMode_FacetShape_OnFacetCharacterBuilt, HalfHeight) == 0x000004, "Member 'OrionTargetingMode_FacetShape_OnFacetCharacterBuilt::HalfHeight' has a wrong offset!");

// Function OrionGame.OrionTargetingMode_FacetShape.OnFacetCylinderBuilt
// 0x000C (0x000C - 0x0000)
struct OrionTargetingMode_FacetShape_OnFacetCylinderBuilt final
{
public:
	float                                         Radius;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightMin;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightMax;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTargetingMode_FacetShape_OnFacetCylinderBuilt) == 0x000004, "Wrong alignment on OrionTargetingMode_FacetShape_OnFacetCylinderBuilt");
static_assert(sizeof(OrionTargetingMode_FacetShape_OnFacetCylinderBuilt) == 0x00000C, "Wrong size on OrionTargetingMode_FacetShape_OnFacetCylinderBuilt");
static_assert(offsetof(OrionTargetingMode_FacetShape_OnFacetCylinderBuilt, Radius) == 0x000000, "Member 'OrionTargetingMode_FacetShape_OnFacetCylinderBuilt::Radius' has a wrong offset!");
static_assert(offsetof(OrionTargetingMode_FacetShape_OnFacetCylinderBuilt, HeightMin) == 0x000004, "Member 'OrionTargetingMode_FacetShape_OnFacetCylinderBuilt::HeightMin' has a wrong offset!");
static_assert(offsetof(OrionTargetingMode_FacetShape_OnFacetCylinderBuilt, HeightMax) == 0x000008, "Member 'OrionTargetingMode_FacetShape_OnFacetCylinderBuilt::HeightMax' has a wrong offset!");

// Function OrionGame.OrionTargetingMode_FacetShape.OnFacetSectorBuilt
// 0x0014 (0x0014 - 0x0000)
struct OrionTargetingMode_FacetShape_OnFacetSectorBuilt final
{
public:
	float                                         AngleHorizontal;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiusMin;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiusMax;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightMin;                                         // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightMax;                                         // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTargetingMode_FacetShape_OnFacetSectorBuilt) == 0x000004, "Wrong alignment on OrionTargetingMode_FacetShape_OnFacetSectorBuilt");
static_assert(sizeof(OrionTargetingMode_FacetShape_OnFacetSectorBuilt) == 0x000014, "Wrong size on OrionTargetingMode_FacetShape_OnFacetSectorBuilt");
static_assert(offsetof(OrionTargetingMode_FacetShape_OnFacetSectorBuilt, AngleHorizontal) == 0x000000, "Member 'OrionTargetingMode_FacetShape_OnFacetSectorBuilt::AngleHorizontal' has a wrong offset!");
static_assert(offsetof(OrionTargetingMode_FacetShape_OnFacetSectorBuilt, RadiusMin) == 0x000004, "Member 'OrionTargetingMode_FacetShape_OnFacetSectorBuilt::RadiusMin' has a wrong offset!");
static_assert(offsetof(OrionTargetingMode_FacetShape_OnFacetSectorBuilt, RadiusMax) == 0x000008, "Member 'OrionTargetingMode_FacetShape_OnFacetSectorBuilt::RadiusMax' has a wrong offset!");
static_assert(offsetof(OrionTargetingMode_FacetShape_OnFacetSectorBuilt, HeightMin) == 0x00000C, "Member 'OrionTargetingMode_FacetShape_OnFacetSectorBuilt::HeightMin' has a wrong offset!");
static_assert(offsetof(OrionTargetingMode_FacetShape_OnFacetSectorBuilt, HeightMax) == 0x000010, "Member 'OrionTargetingMode_FacetShape_OnFacetSectorBuilt::HeightMax' has a wrong offset!");

// Function OrionGame.OrionTargetingMode_FacetShape.OnFacetSphereBuilt
// 0x0004 (0x0004 - 0x0000)
struct OrionTargetingMode_FacetShape_OnFacetSphereBuilt final
{
public:
	float                                         Radius;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTargetingMode_FacetShape_OnFacetSphereBuilt) == 0x000004, "Wrong alignment on OrionTargetingMode_FacetShape_OnFacetSphereBuilt");
static_assert(sizeof(OrionTargetingMode_FacetShape_OnFacetSphereBuilt) == 0x000004, "Wrong size on OrionTargetingMode_FacetShape_OnFacetSphereBuilt");
static_assert(offsetof(OrionTargetingMode_FacetShape_OnFacetSphereBuilt, Radius) == 0x000000, "Member 'OrionTargetingMode_FacetShape_OnFacetSphereBuilt::Radius' has a wrong offset!");

// Function OrionGame.OrionTargetingMode_FacetShape.SetPrototypeMeshVisibility
// 0x0001 (0x0001 - 0x0000)
struct OrionTargetingMode_FacetShape_SetPrototypeMeshVisibility final
{
public:
	bool                                          In_bSetVisible;                                    // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTargetingMode_FacetShape_SetPrototypeMeshVisibility) == 0x000001, "Wrong alignment on OrionTargetingMode_FacetShape_SetPrototypeMeshVisibility");
static_assert(sizeof(OrionTargetingMode_FacetShape_SetPrototypeMeshVisibility) == 0x000001, "Wrong size on OrionTargetingMode_FacetShape_SetPrototypeMeshVisibility");
static_assert(offsetof(OrionTargetingMode_FacetShape_SetPrototypeMeshVisibility, In_bSetVisible) == 0x000000, "Member 'OrionTargetingMode_FacetShape_SetPrototypeMeshVisibility::In_bSetVisible' has a wrong offset!");

// Function OrionGame.PlayerControllerCommon.ClientSetInviteFlags
// 0x0018 (0x0018 - 0x0000)
struct PlayerControllerCommon_ClientSetInviteFlags final
{
public:
	struct FJoinabilitySettings                   Settings;                                          // 0x0000(0x0018)(ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerControllerCommon_ClientSetInviteFlags) == 0x000008, "Wrong alignment on PlayerControllerCommon_ClientSetInviteFlags");
static_assert(sizeof(PlayerControllerCommon_ClientSetInviteFlags) == 0x000018, "Wrong size on PlayerControllerCommon_ClientSetInviteFlags");
static_assert(offsetof(PlayerControllerCommon_ClientSetInviteFlags, Settings) == 0x000000, "Member 'PlayerControllerCommon_ClientSetInviteFlags::Settings' has a wrong offset!");

// Function OrionGame.PlayerControllerCommon.ClientUpdateRichPresence
// 0x0002 (0x0002 - 0x0000)
struct PlayerControllerCommon_ClientUpdateRichPresence final
{
public:
	ERichPresenceStateChange                      RichPresenceChange;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImportant;                                        // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerControllerCommon_ClientUpdateRichPresence) == 0x000001, "Wrong alignment on PlayerControllerCommon_ClientUpdateRichPresence");
static_assert(sizeof(PlayerControllerCommon_ClientUpdateRichPresence) == 0x000002, "Wrong size on PlayerControllerCommon_ClientUpdateRichPresence");
static_assert(offsetof(PlayerControllerCommon_ClientUpdateRichPresence, RichPresenceChange) == 0x000000, "Member 'PlayerControllerCommon_ClientUpdateRichPresence::RichPresenceChange' has a wrong offset!");
static_assert(offsetof(PlayerControllerCommon_ClientUpdateRichPresence, bImportant) == 0x000001, "Member 'PlayerControllerCommon_ClientUpdateRichPresence::bImportant' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Base.Cheat
// 0x0010 (0x0010 - 0x0000)
struct OrionPlayerController_Base_Cheat final
{
public:
	class FString                                 Msg;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Base_Cheat) == 0x000008, "Wrong alignment on OrionPlayerController_Base_Cheat");
static_assert(sizeof(OrionPlayerController_Base_Cheat) == 0x000010, "Wrong size on OrionPlayerController_Base_Cheat");
static_assert(offsetof(OrionPlayerController_Base_Cheat, Msg) == 0x000000, "Member 'OrionPlayerController_Base_Cheat::Msg' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Base.CheatAll
// 0x0010 (0x0010 - 0x0000)
struct OrionPlayerController_Base_CheatAll final
{
public:
	class FString                                 Msg;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Base_CheatAll) == 0x000008, "Wrong alignment on OrionPlayerController_Base_CheatAll");
static_assert(sizeof(OrionPlayerController_Base_CheatAll) == 0x000010, "Wrong size on OrionPlayerController_Base_CheatAll");
static_assert(offsetof(OrionPlayerController_Base_CheatAll, Msg) == 0x000000, "Member 'OrionPlayerController_Base_CheatAll::Msg' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Base.ClientDisplayCheatDetectedMessage
// 0x0010 (0x0010 - 0x0000)
struct OrionPlayerController_Base_ClientDisplayCheatDetectedMessage final
{
public:
	class FString                                 CheatMessage;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Base_ClientDisplayCheatDetectedMessage) == 0x000008, "Wrong alignment on OrionPlayerController_Base_ClientDisplayCheatDetectedMessage");
static_assert(sizeof(OrionPlayerController_Base_ClientDisplayCheatDetectedMessage) == 0x000010, "Wrong size on OrionPlayerController_Base_ClientDisplayCheatDetectedMessage");
static_assert(offsetof(OrionPlayerController_Base_ClientDisplayCheatDetectedMessage, CheatMessage) == 0x000000, "Member 'OrionPlayerController_Base_ClientDisplayCheatDetectedMessage::CheatMessage' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Base.ClientExecCheatAll
// 0x0010 (0x0010 - 0x0000)
struct OrionPlayerController_Base_ClientExecCheatAll final
{
public:
	class FString                                 Msg;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Base_ClientExecCheatAll) == 0x000008, "Wrong alignment on OrionPlayerController_Base_ClientExecCheatAll");
static_assert(sizeof(OrionPlayerController_Base_ClientExecCheatAll) == 0x000010, "Wrong size on OrionPlayerController_Base_ClientExecCheatAll");
static_assert(offsetof(OrionPlayerController_Base_ClientExecCheatAll, Msg) == 0x000000, "Member 'OrionPlayerController_Base_ClientExecCheatAll::Msg' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Base.ClientFollowTarget
// 0x0008 (0x0008 - 0x0000)
struct OrionPlayerController_Base_ClientFollowTarget final
{
public:
	class AActor*                                 InTarget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Base_ClientFollowTarget) == 0x000008, "Wrong alignment on OrionPlayerController_Base_ClientFollowTarget");
static_assert(sizeof(OrionPlayerController_Base_ClientFollowTarget) == 0x000008, "Wrong size on OrionPlayerController_Base_ClientFollowTarget");
static_assert(offsetof(OrionPlayerController_Base_ClientFollowTarget, InTarget) == 0x000000, "Member 'OrionPlayerController_Base_ClientFollowTarget::InTarget' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Base.ClientReceiveLoot
// 0x0048 (0x0048 - 0x0000)
struct OrionPlayerController_Base_ClientReceiveLoot final
{
public:
	struct FOrionLootNotification                 LootNotification;                                  // 0x0000(0x0048)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Base_ClientReceiveLoot) == 0x000008, "Wrong alignment on OrionPlayerController_Base_ClientReceiveLoot");
static_assert(sizeof(OrionPlayerController_Base_ClientReceiveLoot) == 0x000048, "Wrong size on OrionPlayerController_Base_ClientReceiveLoot");
static_assert(offsetof(OrionPlayerController_Base_ClientReceiveLoot, LootNotification) == 0x000000, "Member 'OrionPlayerController_Base_ClientReceiveLoot::LootNotification' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Base.ClientReturnToMainMenuReason
// 0x0001 (0x0001 - 0x0000)
struct OrionPlayerController_Base_ClientReturnToMainMenuReason final
{
public:
	EReturnToMainMenuReason                       Reason;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Base_ClientReturnToMainMenuReason) == 0x000001, "Wrong alignment on OrionPlayerController_Base_ClientReturnToMainMenuReason");
static_assert(sizeof(OrionPlayerController_Base_ClientReturnToMainMenuReason) == 0x000001, "Wrong size on OrionPlayerController_Base_ClientReturnToMainMenuReason");
static_assert(offsetof(OrionPlayerController_Base_ClientReturnToMainMenuReason, Reason) == 0x000000, "Member 'OrionPlayerController_Base_ClientReturnToMainMenuReason::Reason' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Base.ClientSendPartyJoinInfoToPlayer
// 0x0010 (0x0010 - 0x0000)
struct OrionPlayerController_Base_ClientSendPartyJoinInfoToPlayer final
{
public:
	class FString                                 JoinInfoStr;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Base_ClientSendPartyJoinInfoToPlayer) == 0x000008, "Wrong alignment on OrionPlayerController_Base_ClientSendPartyJoinInfoToPlayer");
static_assert(sizeof(OrionPlayerController_Base_ClientSendPartyJoinInfoToPlayer) == 0x000010, "Wrong size on OrionPlayerController_Base_ClientSendPartyJoinInfoToPlayer");
static_assert(offsetof(OrionPlayerController_Base_ClientSendPartyJoinInfoToPlayer, JoinInfoStr) == 0x000000, "Member 'OrionPlayerController_Base_ClientSendPartyJoinInfoToPlayer::JoinInfoStr' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Base.ClientStayWithParty
// 0x0002 (0x0002 - 0x0000)
struct OrionPlayerController_Base_ClientStayWithParty final
{
public:
	bool                                          bStayWithSocialParty;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStayWithTeamParty;                                // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Base_ClientStayWithParty) == 0x000001, "Wrong alignment on OrionPlayerController_Base_ClientStayWithParty");
static_assert(sizeof(OrionPlayerController_Base_ClientStayWithParty) == 0x000002, "Wrong size on OrionPlayerController_Base_ClientStayWithParty");
static_assert(offsetof(OrionPlayerController_Base_ClientStayWithParty, bStayWithSocialParty) == 0x000000, "Member 'OrionPlayerController_Base_ClientStayWithParty::bStayWithSocialParty' has a wrong offset!");
static_assert(offsetof(OrionPlayerController_Base_ClientStayWithParty, bStayWithTeamParty) == 0x000001, "Member 'OrionPlayerController_Base_ClientStayWithParty::bStayWithTeamParty' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Base.FollowedPlayerDestroyed
// 0x0008 (0x0008 - 0x0000)
struct OrionPlayerController_Base_FollowedPlayerDestroyed final
{
public:
	class AActor*                                 DestroyedActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Base_FollowedPlayerDestroyed) == 0x000008, "Wrong alignment on OrionPlayerController_Base_FollowedPlayerDestroyed");
static_assert(sizeof(OrionPlayerController_Base_FollowedPlayerDestroyed) == 0x000008, "Wrong size on OrionPlayerController_Base_FollowedPlayerDestroyed");
static_assert(offsetof(OrionPlayerController_Base_FollowedPlayerDestroyed, DestroyedActor) == 0x000000, "Member 'OrionPlayerController_Base_FollowedPlayerDestroyed::DestroyedActor' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Base.FollowedPlayerDied
// 0x0008 (0x0008 - 0x0000)
struct OrionPlayerController_Base_FollowedPlayerDied final
{
public:
	class AOrionChar*                             DeadChar;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Base_FollowedPlayerDied) == 0x000008, "Wrong alignment on OrionPlayerController_Base_FollowedPlayerDied");
static_assert(sizeof(OrionPlayerController_Base_FollowedPlayerDied) == 0x000008, "Wrong size on OrionPlayerController_Base_FollowedPlayerDied");
static_assert(offsetof(OrionPlayerController_Base_FollowedPlayerDied, DeadChar) == 0x000000, "Member 'OrionPlayerController_Base_FollowedPlayerDied::DeadChar' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Base.FollowedPlayerKilled
// 0x0018 (0x0018 - 0x0000)
struct OrionPlayerController_Base_FollowedPlayerKilled final
{
public:
	class AOrionChar*                             DeadChar;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            Killer;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Base_FollowedPlayerKilled) == 0x000008, "Wrong alignment on OrionPlayerController_Base_FollowedPlayerKilled");
static_assert(sizeof(OrionPlayerController_Base_FollowedPlayerKilled) == 0x000018, "Wrong size on OrionPlayerController_Base_FollowedPlayerKilled");
static_assert(offsetof(OrionPlayerController_Base_FollowedPlayerKilled, DeadChar) == 0x000000, "Member 'OrionPlayerController_Base_FollowedPlayerKilled::DeadChar' has a wrong offset!");
static_assert(offsetof(OrionPlayerController_Base_FollowedPlayerKilled, Killer) == 0x000008, "Member 'OrionPlayerController_Base_FollowedPlayerKilled::Killer' has a wrong offset!");
static_assert(offsetof(OrionPlayerController_Base_FollowedPlayerKilled, DamageCauser) == 0x000010, "Member 'OrionPlayerController_Base_FollowedPlayerKilled::DamageCauser' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Base.LocalUserRequestingReturnToMainMenu
// 0x0001 (0x0001 - 0x0000)
struct OrionPlayerController_Base_LocalUserRequestingReturnToMainMenu final
{
public:
	EReturnToMainMenuReason                       Reason;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Base_LocalUserRequestingReturnToMainMenu) == 0x000001, "Wrong alignment on OrionPlayerController_Base_LocalUserRequestingReturnToMainMenu");
static_assert(sizeof(OrionPlayerController_Base_LocalUserRequestingReturnToMainMenu) == 0x000001, "Wrong size on OrionPlayerController_Base_LocalUserRequestingReturnToMainMenu");
static_assert(offsetof(OrionPlayerController_Base_LocalUserRequestingReturnToMainMenu, Reason) == 0x000000, "Member 'OrionPlayerController_Base_LocalUserRequestingReturnToMainMenu::Reason' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Base.OnMenuEntered
// 0x0010 (0x0010 - 0x0000)
struct OrionPlayerController_Base_OnMenuEntered final
{
public:
	class FString                                 MenuName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Base_OnMenuEntered) == 0x000008, "Wrong alignment on OrionPlayerController_Base_OnMenuEntered");
static_assert(sizeof(OrionPlayerController_Base_OnMenuEntered) == 0x000010, "Wrong size on OrionPlayerController_Base_OnMenuEntered");
static_assert(offsetof(OrionPlayerController_Base_OnMenuEntered, MenuName) == 0x000000, "Member 'OrionPlayerController_Base_OnMenuEntered::MenuName' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Base.ServerChangeTeam
// 0x0001 (0x0001 - 0x0000)
struct OrionPlayerController_Base_ServerChangeTeam final
{
public:
	EOrionTeam                                    TeamIndex;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Base_ServerChangeTeam) == 0x000001, "Wrong alignment on OrionPlayerController_Base_ServerChangeTeam");
static_assert(sizeof(OrionPlayerController_Base_ServerChangeTeam) == 0x000001, "Wrong size on OrionPlayerController_Base_ServerChangeTeam");
static_assert(offsetof(OrionPlayerController_Base_ServerChangeTeam, TeamIndex) == 0x000000, "Member 'OrionPlayerController_Base_ServerChangeTeam::TeamIndex' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Base.ServerExecCheat
// 0x0010 (0x0010 - 0x0000)
struct OrionPlayerController_Base_ServerExecCheat final
{
public:
	class FString                                 Msg;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Base_ServerExecCheat) == 0x000008, "Wrong alignment on OrionPlayerController_Base_ServerExecCheat");
static_assert(sizeof(OrionPlayerController_Base_ServerExecCheat) == 0x000010, "Wrong size on OrionPlayerController_Base_ServerExecCheat");
static_assert(offsetof(OrionPlayerController_Base_ServerExecCheat, Msg) == 0x000000, "Member 'OrionPlayerController_Base_ServerExecCheat::Msg' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Base.ServerExecCheatAll
// 0x0010 (0x0010 - 0x0000)
struct OrionPlayerController_Base_ServerExecCheatAll final
{
public:
	class FString                                 Msg;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Base_ServerExecCheatAll) == 0x000008, "Wrong alignment on OrionPlayerController_Base_ServerExecCheatAll");
static_assert(sizeof(OrionPlayerController_Base_ServerExecCheatAll) == 0x000010, "Wrong size on OrionPlayerController_Base_ServerExecCheatAll");
static_assert(offsetof(OrionPlayerController_Base_ServerExecCheatAll, Msg) == 0x000000, "Member 'OrionPlayerController_Base_ServerExecCheatAll::Msg' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Base.ServerRegisterInitialAnalytics
// 0x0008 (0x0008 - 0x0000)
struct OrionPlayerController_Base_ServerRegisterInitialAnalytics final
{
public:
	struct FOrionPlayerInitialAnalytics           InInitialAnalytics;                                // 0x0000(0x0008)(ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Base_ServerRegisterInitialAnalytics) == 0x000004, "Wrong alignment on OrionPlayerController_Base_ServerRegisterInitialAnalytics");
static_assert(sizeof(OrionPlayerController_Base_ServerRegisterInitialAnalytics) == 0x000008, "Wrong size on OrionPlayerController_Base_ServerRegisterInitialAnalytics");
static_assert(offsetof(OrionPlayerController_Base_ServerRegisterInitialAnalytics, InInitialAnalytics) == 0x000000, "Member 'OrionPlayerController_Base_ServerRegisterInitialAnalytics::InInitialAnalytics' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Base.ServerSendPartyJoinInfoToPlayer
// 0x0028 (0x0028 - 0x0000)
struct OrionPlayerController_Base_ServerSendPartyJoinInfoToPlayer final
{
public:
	struct FUniqueNetIdRepl                       RecipientId;                                       // 0x0000(0x0018)(ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 JoinInfoStr;                                       // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Base_ServerSendPartyJoinInfoToPlayer) == 0x000008, "Wrong alignment on OrionPlayerController_Base_ServerSendPartyJoinInfoToPlayer");
static_assert(sizeof(OrionPlayerController_Base_ServerSendPartyJoinInfoToPlayer) == 0x000028, "Wrong size on OrionPlayerController_Base_ServerSendPartyJoinInfoToPlayer");
static_assert(offsetof(OrionPlayerController_Base_ServerSendPartyJoinInfoToPlayer, RecipientId) == 0x000000, "Member 'OrionPlayerController_Base_ServerSendPartyJoinInfoToPlayer::RecipientId' has a wrong offset!");
static_assert(offsetof(OrionPlayerController_Base_ServerSendPartyJoinInfoToPlayer, JoinInfoStr) == 0x000018, "Member 'OrionPlayerController_Base_ServerSendPartyJoinInfoToPlayer::JoinInfoStr' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Base.ServerSetPartyOwner
// 0x0018 (0x0018 - 0x0000)
struct OrionPlayerController_Base_ServerSetPartyOwner final
{
public:
	struct FUniqueNetIdRepl                       PartyOwnerUniqueId;                                // 0x0000(0x0018)(ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Base_ServerSetPartyOwner) == 0x000008, "Wrong alignment on OrionPlayerController_Base_ServerSetPartyOwner");
static_assert(sizeof(OrionPlayerController_Base_ServerSetPartyOwner) == 0x000018, "Wrong size on OrionPlayerController_Base_ServerSetPartyOwner");
static_assert(offsetof(OrionPlayerController_Base_ServerSetPartyOwner, PartyOwnerUniqueId) == 0x000000, "Member 'OrionPlayerController_Base_ServerSetPartyOwner::PartyOwnerUniqueId' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Base.ServerSetReadyToStartMatch
// 0x0001 (0x0001 - 0x0000)
struct OrionPlayerController_Base_ServerSetReadyToStartMatch final
{
public:
	bool                                          bReady;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Base_ServerSetReadyToStartMatch) == 0x000001, "Wrong alignment on OrionPlayerController_Base_ServerSetReadyToStartMatch");
static_assert(sizeof(OrionPlayerController_Base_ServerSetReadyToStartMatch) == 0x000001, "Wrong size on OrionPlayerController_Base_ServerSetReadyToStartMatch");
static_assert(offsetof(OrionPlayerController_Base_ServerSetReadyToStartMatch, bReady) == 0x000000, "Member 'OrionPlayerController_Base_ServerSetReadyToStartMatch::bReady' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Base.ServerTeamChatRoomReady
// 0x0010 (0x0010 - 0x0000)
struct OrionPlayerController_Base_ServerTeamChatRoomReady final
{
public:
	class FString                                 ChatRoomId;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Base_ServerTeamChatRoomReady) == 0x000008, "Wrong alignment on OrionPlayerController_Base_ServerTeamChatRoomReady");
static_assert(sizeof(OrionPlayerController_Base_ServerTeamChatRoomReady) == 0x000010, "Wrong size on OrionPlayerController_Base_ServerTeamChatRoomReady");
static_assert(offsetof(OrionPlayerController_Base_ServerTeamChatRoomReady, ChatRoomId) == 0x000000, "Member 'OrionPlayerController_Base_ServerTeamChatRoomReady::ChatRoomId' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Base.GetOrionClientSettings
// 0x0008 (0x0008 - 0x0000)
struct OrionPlayerController_Base_GetOrionClientSettings final
{
public:
	class UOrionClientSettingsRecord*             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Base_GetOrionClientSettings) == 0x000008, "Wrong alignment on OrionPlayerController_Base_GetOrionClientSettings");
static_assert(sizeof(OrionPlayerController_Base_GetOrionClientSettings) == 0x000008, "Wrong size on OrionPlayerController_Base_GetOrionClientSettings");
static_assert(offsetof(OrionPlayerController_Base_GetOrionClientSettings, ReturnValue) == 0x000000, "Member 'OrionPlayerController_Base_GetOrionClientSettings::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Base.GetTeamNum
// 0x0001 (0x0001 - 0x0000)
struct OrionPlayerController_Base_GetTeamNum final
{
public:
	EOrionTeam                                    ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Base_GetTeamNum) == 0x000001, "Wrong alignment on OrionPlayerController_Base_GetTeamNum");
static_assert(sizeof(OrionPlayerController_Base_GetTeamNum) == 0x000001, "Wrong size on OrionPlayerController_Base_GetTeamNum");
static_assert(offsetof(OrionPlayerController_Base_GetTeamNum, ReturnValue) == 0x000000, "Member 'OrionPlayerController_Base_GetTeamNum::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIController.GetAIFormation
// 0x0008 (0x0008 - 0x0000)
struct OrionAIController_GetAIFormation final
{
public:
	class UOrionAIFormation*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIController_GetAIFormation) == 0x000008, "Wrong alignment on OrionAIController_GetAIFormation");
static_assert(sizeof(OrionAIController_GetAIFormation) == 0x000008, "Wrong size on OrionAIController_GetAIFormation");
static_assert(offsetof(OrionAIController_GetAIFormation, ReturnValue) == 0x000000, "Member 'OrionAIController_GetAIFormation::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIController.GetOrionChar
// 0x0008 (0x0008 - 0x0000)
struct OrionAIController_GetOrionChar final
{
public:
	class AOrionChar*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIController_GetOrionChar) == 0x000008, "Wrong alignment on OrionAIController_GetOrionChar");
static_assert(sizeof(OrionAIController_GetOrionChar) == 0x000008, "Wrong size on OrionAIController_GetOrionChar");
static_assert(offsetof(OrionAIController_GetOrionChar, ReturnValue) == 0x000000, "Member 'OrionAIController_GetOrionChar::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIController.GetTeamNum
// 0x0001 (0x0001 - 0x0000)
struct OrionAIController_GetTeamNum final
{
public:
	EOrionTeam                                    ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIController_GetTeamNum) == 0x000001, "Wrong alignment on OrionAIController_GetTeamNum");
static_assert(sizeof(OrionAIController_GetTeamNum) == 0x000001, "Wrong size on OrionAIController_GetTeamNum");
static_assert(offsetof(OrionAIController_GetTeamNum, ReturnValue) == 0x000000, "Member 'OrionAIController_GetTeamNum::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIBot.K2_SetAbilityToUse
// 0x00C8 (0x00C8 - 0x0000)
struct OrionAIBot_K2_SetAbilityToUse final
{
public:
	struct FGameplayAbilitySpec                   AbilitySpec;                                       // 0x0000(0x00C8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIBot_K2_SetAbilityToUse) == 0x000008, "Wrong alignment on OrionAIBot_K2_SetAbilityToUse");
static_assert(sizeof(OrionAIBot_K2_SetAbilityToUse) == 0x0000C8, "Wrong size on OrionAIBot_K2_SetAbilityToUse");
static_assert(offsetof(OrionAIBot_K2_SetAbilityToUse, AbilitySpec) == 0x000000, "Member 'OrionAIBot_K2_SetAbilityToUse::AbilitySpec' has a wrong offset!");

// Function OrionGame.OrionAIBot.K2_SetDifficultySettings
// 0x00A8 (0x00A8 - 0x0000)
struct OrionAIBot_K2_SetDifficultySettings final
{
public:
	struct FAIBotDifficultySettings               Settings;                                          // 0x0000(0x00A8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIBot_K2_SetDifficultySettings) == 0x000008, "Wrong alignment on OrionAIBot_K2_SetDifficultySettings");
static_assert(sizeof(OrionAIBot_K2_SetDifficultySettings) == 0x0000A8, "Wrong size on OrionAIBot_K2_SetDifficultySettings");
static_assert(offsetof(OrionAIBot_K2_SetDifficultySettings, Settings) == 0x000000, "Member 'OrionAIBot_K2_SetDifficultySettings::Settings' has a wrong offset!");

// Function OrionGame.OrionAIBot.K2_SetEnemy
// 0x0008 (0x0008 - 0x0000)
struct OrionAIBot_K2_SetEnemy final
{
public:
	class AOrionChar*                             NewEnemy;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIBot_K2_SetEnemy) == 0x000008, "Wrong alignment on OrionAIBot_K2_SetEnemy");
static_assert(sizeof(OrionAIBot_K2_SetEnemy) == 0x000008, "Wrong size on OrionAIBot_K2_SetEnemy");
static_assert(offsetof(OrionAIBot_K2_SetEnemy, NewEnemy) == 0x000000, "Member 'OrionAIBot_K2_SetEnemy::NewEnemy' has a wrong offset!");

// Function OrionGame.OrionAIBot.K2_SetIgnoreEnemies
// 0x0001 (0x0001 - 0x0000)
struct OrionAIBot_K2_SetIgnoreEnemies final
{
public:
	bool                                          bNewIgnoreEnemies;                                 // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIBot_K2_SetIgnoreEnemies) == 0x000001, "Wrong alignment on OrionAIBot_K2_SetIgnoreEnemies");
static_assert(sizeof(OrionAIBot_K2_SetIgnoreEnemies) == 0x000001, "Wrong size on OrionAIBot_K2_SetIgnoreEnemies");
static_assert(offsetof(OrionAIBot_K2_SetIgnoreEnemies, bNewIgnoreEnemies) == 0x000000, "Member 'OrionAIBot_K2_SetIgnoreEnemies::bNewIgnoreEnemies' has a wrong offset!");

// Function OrionGame.OrionAIBot.OnCharacterDied
// 0x0018 (0x0018 - 0x0000)
struct OrionAIBot_OnCharacterDied final
{
public:
	class AOrionChar*                             DeadChar;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            Killer;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIBot_OnCharacterDied) == 0x000008, "Wrong alignment on OrionAIBot_OnCharacterDied");
static_assert(sizeof(OrionAIBot_OnCharacterDied) == 0x000018, "Wrong size on OrionAIBot_OnCharacterDied");
static_assert(offsetof(OrionAIBot_OnCharacterDied, DeadChar) == 0x000000, "Member 'OrionAIBot_OnCharacterDied::DeadChar' has a wrong offset!");
static_assert(offsetof(OrionAIBot_OnCharacterDied, Killer) == 0x000008, "Member 'OrionAIBot_OnCharacterDied::Killer' has a wrong offset!");
static_assert(offsetof(OrionAIBot_OnCharacterDied, DamageCauser) == 0x000010, "Member 'OrionAIBot_OnCharacterDied::DamageCauser' has a wrong offset!");

// Function OrionGame.OrionAIBot.PlaceWard
// 0x0001 (0x0001 - 0x0000)
struct OrionAIBot_PlaceWard final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIBot_PlaceWard) == 0x000001, "Wrong alignment on OrionAIBot_PlaceWard");
static_assert(sizeof(OrionAIBot_PlaceWard) == 0x000001, "Wrong size on OrionAIBot_PlaceWard");
static_assert(offsetof(OrionAIBot_PlaceWard, ReturnValue) == 0x000000, "Member 'OrionAIBot_PlaceWard::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIBot.Recall
// 0x0002 (0x0002 - 0x0000)
struct OrionAIBot_Recall final
{
public:
	bool                                          bFailIfUnsafeToRecall;                             // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIBot_Recall) == 0x000001, "Wrong alignment on OrionAIBot_Recall");
static_assert(sizeof(OrionAIBot_Recall) == 0x000002, "Wrong size on OrionAIBot_Recall");
static_assert(offsetof(OrionAIBot_Recall, bFailIfUnsafeToRecall) == 0x000000, "Member 'OrionAIBot_Recall::bFailIfUnsafeToRecall' has a wrong offset!");
static_assert(offsetof(OrionAIBot_Recall, ReturnValue) == 0x000001, "Member 'OrionAIBot_Recall::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIBot.CanActivateAbility
// 0x0028 (0x0028 - 0x0000)
struct OrionAIBot_CanActivateAbility final
{
public:
	struct FGameplayTagContainer                  AbilityTags;                                       // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bRequirePerfectMatch;                              // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0021(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionAIBot_CanActivateAbility) == 0x000008, "Wrong alignment on OrionAIBot_CanActivateAbility");
static_assert(sizeof(OrionAIBot_CanActivateAbility) == 0x000028, "Wrong size on OrionAIBot_CanActivateAbility");
static_assert(offsetof(OrionAIBot_CanActivateAbility, AbilityTags) == 0x000000, "Member 'OrionAIBot_CanActivateAbility::AbilityTags' has a wrong offset!");
static_assert(offsetof(OrionAIBot_CanActivateAbility, bRequirePerfectMatch) == 0x000020, "Member 'OrionAIBot_CanActivateAbility::bRequirePerfectMatch' has a wrong offset!");
static_assert(offsetof(OrionAIBot_CanActivateAbility, ReturnValue) == 0x000021, "Member 'OrionAIBot_CanActivateAbility::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIBot.GetAvatarLocation
// 0x000C (0x000C - 0x0000)
struct OrionAIBot_GetAvatarLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIBot_GetAvatarLocation) == 0x000004, "Wrong alignment on OrionAIBot_GetAvatarLocation");
static_assert(sizeof(OrionAIBot_GetAvatarLocation) == 0x00000C, "Wrong size on OrionAIBot_GetAvatarLocation");
static_assert(offsetof(OrionAIBot_GetAvatarLocation, ReturnValue) == 0x000000, "Member 'OrionAIBot_GetAvatarLocation::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIBot.GetCurrentLaneFrontWaveTeamProgress
// 0x0004 (0x0004 - 0x0000)
struct OrionAIBot_GetCurrentLaneFrontWaveTeamProgress final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIBot_GetCurrentLaneFrontWaveTeamProgress) == 0x000004, "Wrong alignment on OrionAIBot_GetCurrentLaneFrontWaveTeamProgress");
static_assert(sizeof(OrionAIBot_GetCurrentLaneFrontWaveTeamProgress) == 0x000004, "Wrong size on OrionAIBot_GetCurrentLaneFrontWaveTeamProgress");
static_assert(offsetof(OrionAIBot_GetCurrentLaneFrontWaveTeamProgress, ReturnValue) == 0x000000, "Member 'OrionAIBot_GetCurrentLaneFrontWaveTeamProgress::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIBot.GetCurrentObjectiveTeamCommEvent
// 0x0001 (0x0001 - 0x0000)
struct OrionAIBot_GetCurrentObjectiveTeamCommEvent final
{
public:
	EAITeamCommEvent                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIBot_GetCurrentObjectiveTeamCommEvent) == 0x000001, "Wrong alignment on OrionAIBot_GetCurrentObjectiveTeamCommEvent");
static_assert(sizeof(OrionAIBot_GetCurrentObjectiveTeamCommEvent) == 0x000001, "Wrong size on OrionAIBot_GetCurrentObjectiveTeamCommEvent");
static_assert(offsetof(OrionAIBot_GetCurrentObjectiveTeamCommEvent, ReturnValue) == 0x000000, "Member 'OrionAIBot_GetCurrentObjectiveTeamCommEvent::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIBot.GetCurrentScriptedBehavior
// 0x0008 (0x0008 - 0x0000)
struct OrionAIBot_GetCurrentScriptedBehavior final
{
public:
	class UAIScriptedBehavior*                    ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIBot_GetCurrentScriptedBehavior) == 0x000008, "Wrong alignment on OrionAIBot_GetCurrentScriptedBehavior");
static_assert(sizeof(OrionAIBot_GetCurrentScriptedBehavior) == 0x000008, "Wrong size on OrionAIBot_GetCurrentScriptedBehavior");
static_assert(offsetof(OrionAIBot_GetCurrentScriptedBehavior, ReturnValue) == 0x000000, "Member 'OrionAIBot_GetCurrentScriptedBehavior::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIBot.GetLaneProgress
// 0x0004 (0x0004 - 0x0000)
struct OrionAIBot_GetLaneProgress final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIBot_GetLaneProgress) == 0x000004, "Wrong alignment on OrionAIBot_GetLaneProgress");
static_assert(sizeof(OrionAIBot_GetLaneProgress) == 0x000004, "Wrong size on OrionAIBot_GetLaneProgress");
static_assert(offsetof(OrionAIBot_GetLaneProgress, ReturnValue) == 0x000000, "Member 'OrionAIBot_GetLaneProgress::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIBot.GetSpawnLocation
// 0x000C (0x000C - 0x0000)
struct OrionAIBot_GetSpawnLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIBot_GetSpawnLocation) == 0x000004, "Wrong alignment on OrionAIBot_GetSpawnLocation");
static_assert(sizeof(OrionAIBot_GetSpawnLocation) == 0x00000C, "Wrong size on OrionAIBot_GetSpawnLocation");
static_assert(offsetof(OrionAIBot_GetSpawnLocation, ReturnValue) == 0x000000, "Member 'OrionAIBot_GetSpawnLocation::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIBot.HasUsableAbilityAgainstCurrentEnemy
// 0x0001 (0x0001 - 0x0000)
struct OrionAIBot_HasUsableAbilityAgainstCurrentEnemy final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIBot_HasUsableAbilityAgainstCurrentEnemy) == 0x000001, "Wrong alignment on OrionAIBot_HasUsableAbilityAgainstCurrentEnemy");
static_assert(sizeof(OrionAIBot_HasUsableAbilityAgainstCurrentEnemy) == 0x000001, "Wrong size on OrionAIBot_HasUsableAbilityAgainstCurrentEnemy");
static_assert(offsetof(OrionAIBot_HasUsableAbilityAgainstCurrentEnemy, ReturnValue) == 0x000000, "Member 'OrionAIBot_HasUsableAbilityAgainstCurrentEnemy::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIBot.IsAbilityInRage
// 0x0020 (0x0020 - 0x0000)
struct OrionAIBot_IsAbilityInRage final
{
public:
	struct FVector                                WorldLocation;                                     // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UOrionAbility>              AbilityClass;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionAIBot_IsAbilityInRage) == 0x000008, "Wrong alignment on OrionAIBot_IsAbilityInRage");
static_assert(sizeof(OrionAIBot_IsAbilityInRage) == 0x000020, "Wrong size on OrionAIBot_IsAbilityInRage");
static_assert(offsetof(OrionAIBot_IsAbilityInRage, WorldLocation) == 0x000000, "Member 'OrionAIBot_IsAbilityInRage::WorldLocation' has a wrong offset!");
static_assert(offsetof(OrionAIBot_IsAbilityInRage, AbilityClass) == 0x000010, "Member 'OrionAIBot_IsAbilityInRage::AbilityClass' has a wrong offset!");
static_assert(offsetof(OrionAIBot_IsAbilityInRage, ReturnValue) == 0x000018, "Member 'OrionAIBot_IsAbilityInRage::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIBot.IsSafeToRecall
// 0x0001 (0x0001 - 0x0000)
struct OrionAIBot_IsSafeToRecall final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIBot_IsSafeToRecall) == 0x000001, "Wrong alignment on OrionAIBot_IsSafeToRecall");
static_assert(sizeof(OrionAIBot_IsSafeToRecall) == 0x000001, "Wrong size on OrionAIBot_IsSafeToRecall");
static_assert(offsetof(OrionAIBot_IsSafeToRecall, ReturnValue) == 0x000000, "Member 'OrionAIBot_IsSafeToRecall::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIBot.K2_GetAssignedRole
// 0x0001 (0x0001 - 0x0000)
struct OrionAIBot_K2_GetAssignedRole final
{
public:
	ELaneRoleSlot                                 ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIBot_K2_GetAssignedRole) == 0x000001, "Wrong alignment on OrionAIBot_K2_GetAssignedRole");
static_assert(sizeof(OrionAIBot_K2_GetAssignedRole) == 0x000001, "Wrong size on OrionAIBot_K2_GetAssignedRole");
static_assert(offsetof(OrionAIBot_K2_GetAssignedRole, ReturnValue) == 0x000000, "Member 'OrionAIBot_K2_GetAssignedRole::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIBot.K2_GetDifficultySettings
// 0x00A8 (0x00A8 - 0x0000)
struct OrionAIBot_K2_GetDifficultySettings final
{
public:
	struct FAIBotDifficultySettings               ReturnValue;                                       // 0x0000(0x00A8)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIBot_K2_GetDifficultySettings) == 0x000008, "Wrong alignment on OrionAIBot_K2_GetDifficultySettings");
static_assert(sizeof(OrionAIBot_K2_GetDifficultySettings) == 0x0000A8, "Wrong size on OrionAIBot_K2_GetDifficultySettings");
static_assert(offsetof(OrionAIBot_K2_GetDifficultySettings, ReturnValue) == 0x000000, "Member 'OrionAIBot_K2_GetDifficultySettings::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIBot.K2_GetEnemyCharacter
// 0x0008 (0x0008 - 0x0000)
struct OrionAIBot_K2_GetEnemyCharacter final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIBot_K2_GetEnemyCharacter) == 0x000008, "Wrong alignment on OrionAIBot_K2_GetEnemyCharacter");
static_assert(sizeof(OrionAIBot_K2_GetEnemyCharacter) == 0x000008, "Wrong size on OrionAIBot_K2_GetEnemyCharacter");
static_assert(offsetof(OrionAIBot_K2_GetEnemyCharacter, ReturnValue) == 0x000000, "Member 'OrionAIBot_K2_GetEnemyCharacter::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIBot.K2_GetEnemySelectionQuery
// 0x0008 (0x0008 - 0x0000)
struct OrionAIBot_K2_GetEnemySelectionQuery final
{
public:
	class UEnvQuery*                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIBot_K2_GetEnemySelectionQuery) == 0x000008, "Wrong alignment on OrionAIBot_K2_GetEnemySelectionQuery");
static_assert(sizeof(OrionAIBot_K2_GetEnemySelectionQuery) == 0x000008, "Wrong size on OrionAIBot_K2_GetEnemySelectionQuery");
static_assert(offsetof(OrionAIBot_K2_GetEnemySelectionQuery, ReturnValue) == 0x000000, "Member 'OrionAIBot_K2_GetEnemySelectionQuery::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIBot.K2_GetLaneID
// 0x0004 (0x0004 - 0x0000)
struct OrionAIBot_K2_GetLaneID final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIBot_K2_GetLaneID) == 0x000004, "Wrong alignment on OrionAIBot_K2_GetLaneID");
static_assert(sizeof(OrionAIBot_K2_GetLaneID) == 0x000004, "Wrong size on OrionAIBot_K2_GetLaneID");
static_assert(offsetof(OrionAIBot_K2_GetLaneID, ReturnValue) == 0x000000, "Member 'OrionAIBot_K2_GetLaneID::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIBot.K2_GetObjectiveActor
// 0x0008 (0x0008 - 0x0000)
struct OrionAIBot_K2_GetObjectiveActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIBot_K2_GetObjectiveActor) == 0x000008, "Wrong alignment on OrionAIBot_K2_GetObjectiveActor");
static_assert(sizeof(OrionAIBot_K2_GetObjectiveActor) == 0x000008, "Wrong size on OrionAIBot_K2_GetObjectiveActor");
static_assert(offsetof(OrionAIBot_K2_GetObjectiveActor, ReturnValue) == 0x000000, "Member 'OrionAIBot_K2_GetObjectiveActor::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIBot.K2_GetPrimaryAttackHandle
// 0x0004 (0x0004 - 0x0000)
struct OrionAIBot_K2_GetPrimaryAttackHandle final
{
public:
	struct FGameplayAbilitySpecHandle             ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIBot_K2_GetPrimaryAttackHandle) == 0x000004, "Wrong alignment on OrionAIBot_K2_GetPrimaryAttackHandle");
static_assert(sizeof(OrionAIBot_K2_GetPrimaryAttackHandle) == 0x000004, "Wrong size on OrionAIBot_K2_GetPrimaryAttackHandle");
static_assert(offsetof(OrionAIBot_K2_GetPrimaryAttackHandle, ReturnValue) == 0x000000, "Member 'OrionAIBot_K2_GetPrimaryAttackHandle::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIBot.K2_IsInsideTurret
// 0x0001 (0x0001 - 0x0000)
struct OrionAIBot_K2_IsInsideTurret final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIBot_K2_IsInsideTurret) == 0x000001, "Wrong alignment on OrionAIBot_K2_IsInsideTurret");
static_assert(sizeof(OrionAIBot_K2_IsInsideTurret) == 0x000001, "Wrong size on OrionAIBot_K2_IsInsideTurret");
static_assert(offsetof(OrionAIBot_K2_IsInsideTurret, ReturnValue) == 0x000000, "Member 'OrionAIBot_K2_IsInsideTurret::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIBot.K2_IsSafeToApproachOffensiveLaneGoal
// 0x0001 (0x0001 - 0x0000)
struct OrionAIBot_K2_IsSafeToApproachOffensiveLaneGoal final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIBot_K2_IsSafeToApproachOffensiveLaneGoal) == 0x000001, "Wrong alignment on OrionAIBot_K2_IsSafeToApproachOffensiveLaneGoal");
static_assert(sizeof(OrionAIBot_K2_IsSafeToApproachOffensiveLaneGoal) == 0x000001, "Wrong size on OrionAIBot_K2_IsSafeToApproachOffensiveLaneGoal");
static_assert(offsetof(OrionAIBot_K2_IsSafeToApproachOffensiveLaneGoal, ReturnValue) == 0x000000, "Member 'OrionAIBot_K2_IsSafeToApproachOffensiveLaneGoal::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIPerceptionComponent.GetCallForHelpRating
// 0x0010 (0x0010 - 0x0000)
struct OrionAIPerceptionComponent_GetCallForHelpRating final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionAIPerceptionComponent_GetCallForHelpRating) == 0x000008, "Wrong alignment on OrionAIPerceptionComponent_GetCallForHelpRating");
static_assert(sizeof(OrionAIPerceptionComponent_GetCallForHelpRating) == 0x000010, "Wrong size on OrionAIPerceptionComponent_GetCallForHelpRating");
static_assert(offsetof(OrionAIPerceptionComponent_GetCallForHelpRating, Actor) == 0x000000, "Member 'OrionAIPerceptionComponent_GetCallForHelpRating::Actor' has a wrong offset!");
static_assert(offsetof(OrionAIPerceptionComponent_GetCallForHelpRating, ReturnValue) == 0x000008, "Member 'OrionAIPerceptionComponent_GetCallForHelpRating::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIPerceptionComponent.GetRecentDamageTakenFromActor
// 0x0010 (0x0010 - 0x0000)
struct OrionAIPerceptionComponent_GetRecentDamageTakenFromActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionAIPerceptionComponent_GetRecentDamageTakenFromActor) == 0x000008, "Wrong alignment on OrionAIPerceptionComponent_GetRecentDamageTakenFromActor");
static_assert(sizeof(OrionAIPerceptionComponent_GetRecentDamageTakenFromActor) == 0x000010, "Wrong size on OrionAIPerceptionComponent_GetRecentDamageTakenFromActor");
static_assert(offsetof(OrionAIPerceptionComponent_GetRecentDamageTakenFromActor, Actor) == 0x000000, "Member 'OrionAIPerceptionComponent_GetRecentDamageTakenFromActor::Actor' has a wrong offset!");
static_assert(offsetof(OrionAIPerceptionComponent_GetRecentDamageTakenFromActor, ReturnValue) == 0x000008, "Member 'OrionAIPerceptionComponent_GetRecentDamageTakenFromActor::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAICommander.MinionWaveSpawned
// 0x0008 (0x0008 - 0x0000)
struct OrionAICommander_MinionWaveSpawned final
{
public:
	class AOrionCharAISpawner*                    Spawner;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAICommander_MinionWaveSpawned) == 0x000008, "Wrong alignment on OrionAICommander_MinionWaveSpawned");
static_assert(sizeof(OrionAICommander_MinionWaveSpawned) == 0x000008, "Wrong size on OrionAICommander_MinionWaveSpawned");
static_assert(offsetof(OrionAICommander_MinionWaveSpawned, Spawner) == 0x000000, "Member 'OrionAICommander_MinionWaveSpawned::Spawner' has a wrong offset!");

// Function OrionGame.OrionTerminusAnimInstance.AnimNotify_StartLooping
// 0x0008 (0x0008 - 0x0000)
struct OrionTerminusAnimInstance_AnimNotify_StartLooping final
{
public:
	const class UAnimNotify*                      Notify;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTerminusAnimInstance_AnimNotify_StartLooping) == 0x000008, "Wrong alignment on OrionTerminusAnimInstance_AnimNotify_StartLooping");
static_assert(sizeof(OrionTerminusAnimInstance_AnimNotify_StartLooping) == 0x000008, "Wrong size on OrionTerminusAnimInstance_AnimNotify_StartLooping");
static_assert(offsetof(OrionTerminusAnimInstance_AnimNotify_StartLooping, Notify) == 0x000000, "Member 'OrionTerminusAnimInstance_AnimNotify_StartLooping::Notify' has a wrong offset!");

// Function OrionGame.OrionAIController_MinionBaseAdvanced.SetTether
// 0x0018 (0x0018 - 0x0000)
struct OrionAIController_MinionBaseAdvanced_SetTether final
{
public:
	struct FVector                                TetherLocation;                                    // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               TetherRotation;                                    // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIController_MinionBaseAdvanced_SetTether) == 0x000004, "Wrong alignment on OrionAIController_MinionBaseAdvanced_SetTether");
static_assert(sizeof(OrionAIController_MinionBaseAdvanced_SetTether) == 0x000018, "Wrong size on OrionAIController_MinionBaseAdvanced_SetTether");
static_assert(offsetof(OrionAIController_MinionBaseAdvanced_SetTether, TetherLocation) == 0x000000, "Member 'OrionAIController_MinionBaseAdvanced_SetTether::TetherLocation' has a wrong offset!");
static_assert(offsetof(OrionAIController_MinionBaseAdvanced_SetTether, TetherRotation) == 0x00000C, "Member 'OrionAIController_MinionBaseAdvanced_SetTether::TetherRotation' has a wrong offset!");

// Function OrionGame.OrionAIController_MinionBaseAdvanced.GetSpawner
// 0x0008 (0x0008 - 0x0000)
struct OrionAIController_MinionBaseAdvanced_GetSpawner final
{
public:
	class AOrionCharAISpawner*                    ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIController_MinionBaseAdvanced_GetSpawner) == 0x000008, "Wrong alignment on OrionAIController_MinionBaseAdvanced_GetSpawner");
static_assert(sizeof(OrionAIController_MinionBaseAdvanced_GetSpawner) == 0x000008, "Wrong size on OrionAIController_MinionBaseAdvanced_GetSpawner");
static_assert(offsetof(OrionAIController_MinionBaseAdvanced_GetSpawner, ReturnValue) == 0x000000, "Member 'OrionAIController_MinionBaseAdvanced_GetSpawner::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlacementActor.OnLoadingChanged
// 0x0001 (0x0001 - 0x0000)
struct OrionPlacementActor_OnLoadingChanged final
{
public:
	bool                                          bIsLoading;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlacementActor_OnLoadingChanged) == 0x000001, "Wrong alignment on OrionPlacementActor_OnLoadingChanged");
static_assert(sizeof(OrionPlacementActor_OnLoadingChanged) == 0x000001, "Wrong size on OrionPlacementActor_OnLoadingChanged");
static_assert(offsetof(OrionPlacementActor_OnLoadingChanged, bIsLoading) == 0x000000, "Member 'OrionPlacementActor_OnLoadingChanged::bIsLoading' has a wrong offset!");

// Function OrionGame.OrionHeroAnimInstance.OnMontageBlendingOutDelegate
// 0x0010 (0x0010 - 0x0000)
struct OrionHeroAnimInstance_OnMontageBlendingOutDelegate final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterrupted;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionHeroAnimInstance_OnMontageBlendingOutDelegate) == 0x000008, "Wrong alignment on OrionHeroAnimInstance_OnMontageBlendingOutDelegate");
static_assert(sizeof(OrionHeroAnimInstance_OnMontageBlendingOutDelegate) == 0x000010, "Wrong size on OrionHeroAnimInstance_OnMontageBlendingOutDelegate");
static_assert(offsetof(OrionHeroAnimInstance_OnMontageBlendingOutDelegate, Montage) == 0x000000, "Member 'OrionHeroAnimInstance_OnMontageBlendingOutDelegate::Montage' has a wrong offset!");
static_assert(offsetof(OrionHeroAnimInstance_OnMontageBlendingOutDelegate, bInterrupted) == 0x000008, "Member 'OrionHeroAnimInstance_OnMontageBlendingOutDelegate::bInterrupted' has a wrong offset!");

// Function OrionGame.OrionHeroAnimInstance.OnMontageStartedDelegate
// 0x0008 (0x0008 - 0x0000)
struct OrionHeroAnimInstance_OnMontageStartedDelegate final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionHeroAnimInstance_OnMontageStartedDelegate) == 0x000008, "Wrong alignment on OrionHeroAnimInstance_OnMontageStartedDelegate");
static_assert(sizeof(OrionHeroAnimInstance_OnMontageStartedDelegate) == 0x000008, "Wrong size on OrionHeroAnimInstance_OnMontageStartedDelegate");
static_assert(offsetof(OrionHeroAnimInstance_OnMontageStartedDelegate, Montage) == 0x000000, "Member 'OrionHeroAnimInstance_OnMontageStartedDelegate::Montage' has a wrong offset!");

// Function OrionGame.OrionMcpItemDefinition.GetCustomStoreContentWidget
// 0x0008 (0x0008 - 0x0000)
struct OrionMcpItemDefinition_GetCustomStoreContentWidget final
{
public:
	TSubclassOf<class UOrionCustomStoreContentWidget> ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpItemDefinition_GetCustomStoreContentWidget) == 0x000008, "Wrong alignment on OrionMcpItemDefinition_GetCustomStoreContentWidget");
static_assert(sizeof(OrionMcpItemDefinition_GetCustomStoreContentWidget) == 0x000008, "Wrong size on OrionMcpItemDefinition_GetCustomStoreContentWidget");
static_assert(offsetof(OrionMcpItemDefinition_GetCustomStoreContentWidget, ReturnValue) == 0x000000, "Member 'OrionMcpItemDefinition_GetCustomStoreContentWidget::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionMcpItemDefinition.GetIcon
// 0x0008 (0x0008 - 0x0000)
struct OrionMcpItemDefinition_GetIcon final
{
public:
	class UTexture2D*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpItemDefinition_GetIcon) == 0x000008, "Wrong alignment on OrionMcpItemDefinition_GetIcon");
static_assert(sizeof(OrionMcpItemDefinition_GetIcon) == 0x000008, "Wrong size on OrionMcpItemDefinition_GetIcon");
static_assert(offsetof(OrionMcpItemDefinition_GetIcon, ReturnValue) == 0x000000, "Member 'OrionMcpItemDefinition_GetIcon::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionMcpItemDefinition.GetIconAsset
// 0x0028 (0x0028 - 0x0000)
struct OrionMcpItemDefinition_GetIconAsset final
{
public:
	TSoftObjectPtr<class UObject>                 ReturnValue;                                       // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpItemDefinition_GetIconAsset) == 0x000008, "Wrong alignment on OrionMcpItemDefinition_GetIconAsset");
static_assert(sizeof(OrionMcpItemDefinition_GetIconAsset) == 0x000028, "Wrong size on OrionMcpItemDefinition_GetIconAsset");
static_assert(offsetof(OrionMcpItemDefinition_GetIconAsset, ReturnValue) == 0x000000, "Member 'OrionMcpItemDefinition_GetIconAsset::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionMcpItemDefinition.GetIconMaterial
// 0x0008 (0x0008 - 0x0000)
struct OrionMcpItemDefinition_GetIconMaterial final
{
public:
	class UMaterialInterface*                     ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpItemDefinition_GetIconMaterial) == 0x000008, "Wrong alignment on OrionMcpItemDefinition_GetIconMaterial");
static_assert(sizeof(OrionMcpItemDefinition_GetIconMaterial) == 0x000008, "Wrong size on OrionMcpItemDefinition_GetIconMaterial");
static_assert(offsetof(OrionMcpItemDefinition_GetIconMaterial, ReturnValue) == 0x000000, "Member 'OrionMcpItemDefinition_GetIconMaterial::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionMcpItemDefinition.GetPersistentName
// 0x0010 (0x0010 - 0x0000)
struct OrionMcpItemDefinition_GetPersistentName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpItemDefinition_GetPersistentName) == 0x000008, "Wrong alignment on OrionMcpItemDefinition_GetPersistentName");
static_assert(sizeof(OrionMcpItemDefinition_GetPersistentName) == 0x000010, "Wrong size on OrionMcpItemDefinition_GetPersistentName");
static_assert(offsetof(OrionMcpItemDefinition_GetPersistentName, ReturnValue) == 0x000000, "Member 'OrionMcpItemDefinition_GetPersistentName::ReturnValue' has a wrong offset!");

// DelegateFunction OrionGame.OrionCharacterData.OnAbilityDataLoaded__DelegateSignature
// 0x0010 (0x0010 - 0x0000)
struct OrionCharacterData_OnAbilityDataLoaded__DelegateSignature final
{
public:
	TArray<class UOrionAbilitySet*>               Abilities;                                         // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharacterData_OnAbilityDataLoaded__DelegateSignature) == 0x000008, "Wrong alignment on OrionCharacterData_OnAbilityDataLoaded__DelegateSignature");
static_assert(sizeof(OrionCharacterData_OnAbilityDataLoaded__DelegateSignature) == 0x000010, "Wrong size on OrionCharacterData_OnAbilityDataLoaded__DelegateSignature");
static_assert(offsetof(OrionCharacterData_OnAbilityDataLoaded__DelegateSignature, Abilities) == 0x000000, "Member 'OrionCharacterData_OnAbilityDataLoaded__DelegateSignature::Abilities' has a wrong offset!");

// Function OrionGame.OrionCharacterData.LoadAbilityData
// 0x0018 (0x0018 - 0x0000)
struct OrionCharacterData_LoadAbilityData final
{
public:
	TDelegate<void(TArray<class UOrionAbilitySet*>& Abilities)> Callback;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionCharacterData_LoadAbilityData) == 0x000004, "Wrong alignment on OrionCharacterData_LoadAbilityData");
static_assert(sizeof(OrionCharacterData_LoadAbilityData) == 0x000018, "Wrong size on OrionCharacterData_LoadAbilityData");
static_assert(offsetof(OrionCharacterData_LoadAbilityData, Callback) == 0x000000, "Member 'OrionCharacterData_LoadAbilityData::Callback' has a wrong offset!");
static_assert(offsetof(OrionCharacterData_LoadAbilityData, ReturnValue) == 0x000010, "Member 'OrionCharacterData_LoadAbilityData::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIFormation.HandleFormationMemberDeath
// 0x0018 (0x0018 - 0x0000)
struct OrionAIFormation_HandleFormationMemberDeath final
{
public:
	class AOrionChar*                             DeadChar;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            Killer;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIFormation_HandleFormationMemberDeath) == 0x000008, "Wrong alignment on OrionAIFormation_HandleFormationMemberDeath");
static_assert(sizeof(OrionAIFormation_HandleFormationMemberDeath) == 0x000018, "Wrong size on OrionAIFormation_HandleFormationMemberDeath");
static_assert(offsetof(OrionAIFormation_HandleFormationMemberDeath, DeadChar) == 0x000000, "Member 'OrionAIFormation_HandleFormationMemberDeath::DeadChar' has a wrong offset!");
static_assert(offsetof(OrionAIFormation_HandleFormationMemberDeath, Killer) == 0x000008, "Member 'OrionAIFormation_HandleFormationMemberDeath::Killer' has a wrong offset!");
static_assert(offsetof(OrionAIFormation_HandleFormationMemberDeath, DamageCauser) == 0x000010, "Member 'OrionAIFormation_HandleFormationMemberDeath::DamageCauser' has a wrong offset!");

// Function OrionGame.OrionToggleableNavLinkProxy.ServerSetEnabled
// 0x0001 (0x0001 - 0x0000)
struct OrionToggleableNavLinkProxy_ServerSetEnabled final
{
public:
	bool                                          bNewEnabled;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionToggleableNavLinkProxy_ServerSetEnabled) == 0x000001, "Wrong alignment on OrionToggleableNavLinkProxy_ServerSetEnabled");
static_assert(sizeof(OrionToggleableNavLinkProxy_ServerSetEnabled) == 0x000001, "Wrong size on OrionToggleableNavLinkProxy_ServerSetEnabled");
static_assert(offsetof(OrionToggleableNavLinkProxy_ServerSetEnabled, bNewEnabled) == 0x000000, "Member 'OrionToggleableNavLinkProxy_ServerSetEnabled::bNewEnabled' has a wrong offset!");

// Function OrionGame.OrionAIGenerigWorldQuerying.CompareToFloat
// 0x0018 (0x0018 - 0x0000)
struct OrionAIGenerigWorldQuerying_CompareToFloat final
{
public:
	EOrionAISymbolicItem                          LHS;                                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGenericAICheck                               Op;                                                // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RHS;                                               // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionGenericAITest                    ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIGenerigWorldQuerying_CompareToFloat) == 0x000008, "Wrong alignment on OrionAIGenerigWorldQuerying_CompareToFloat");
static_assert(sizeof(OrionAIGenerigWorldQuerying_CompareToFloat) == 0x000018, "Wrong size on OrionAIGenerigWorldQuerying_CompareToFloat");
static_assert(offsetof(OrionAIGenerigWorldQuerying_CompareToFloat, LHS) == 0x000000, "Member 'OrionAIGenerigWorldQuerying_CompareToFloat::LHS' has a wrong offset!");
static_assert(offsetof(OrionAIGenerigWorldQuerying_CompareToFloat, Op) == 0x000001, "Member 'OrionAIGenerigWorldQuerying_CompareToFloat::Op' has a wrong offset!");
static_assert(offsetof(OrionAIGenerigWorldQuerying_CompareToFloat, RHS) == 0x000004, "Member 'OrionAIGenerigWorldQuerying_CompareToFloat::RHS' has a wrong offset!");
static_assert(offsetof(OrionAIGenerigWorldQuerying_CompareToFloat, ReturnValue) == 0x000008, "Member 'OrionAIGenerigWorldQuerying_CompareToFloat::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIGenerigWorldQuerying.CompareToNumber
// 0x0018 (0x0018 - 0x0000)
struct OrionAIGenerigWorldQuerying_CompareToNumber final
{
public:
	EOrionAISymbolicItem                          LHS;                                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGenericAICheck                               Op;                                                // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RHS;                                               // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionGenericAITest                    ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIGenerigWorldQuerying_CompareToNumber) == 0x000008, "Wrong alignment on OrionAIGenerigWorldQuerying_CompareToNumber");
static_assert(sizeof(OrionAIGenerigWorldQuerying_CompareToNumber) == 0x000018, "Wrong size on OrionAIGenerigWorldQuerying_CompareToNumber");
static_assert(offsetof(OrionAIGenerigWorldQuerying_CompareToNumber, LHS) == 0x000000, "Member 'OrionAIGenerigWorldQuerying_CompareToNumber::LHS' has a wrong offset!");
static_assert(offsetof(OrionAIGenerigWorldQuerying_CompareToNumber, Op) == 0x000001, "Member 'OrionAIGenerigWorldQuerying_CompareToNumber::Op' has a wrong offset!");
static_assert(offsetof(OrionAIGenerigWorldQuerying_CompareToNumber, RHS) == 0x000004, "Member 'OrionAIGenerigWorldQuerying_CompareToNumber::RHS' has a wrong offset!");
static_assert(offsetof(OrionAIGenerigWorldQuerying_CompareToNumber, ReturnValue) == 0x000008, "Member 'OrionAIGenerigWorldQuerying_CompareToNumber::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIGenerigWorldQuerying.CompareToSymbol
// 0x0018 (0x0018 - 0x0000)
struct OrionAIGenerigWorldQuerying_CompareToSymbol final
{
public:
	EOrionAISymbolicItem                          LHS;                                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGenericAICheck                               Op;                                                // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionAISymbolicItem                          RHS;                                               // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionGenericAITest                    ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIGenerigWorldQuerying_CompareToSymbol) == 0x000008, "Wrong alignment on OrionAIGenerigWorldQuerying_CompareToSymbol");
static_assert(sizeof(OrionAIGenerigWorldQuerying_CompareToSymbol) == 0x000018, "Wrong size on OrionAIGenerigWorldQuerying_CompareToSymbol");
static_assert(offsetof(OrionAIGenerigWorldQuerying_CompareToSymbol, LHS) == 0x000000, "Member 'OrionAIGenerigWorldQuerying_CompareToSymbol::LHS' has a wrong offset!");
static_assert(offsetof(OrionAIGenerigWorldQuerying_CompareToSymbol, Op) == 0x000001, "Member 'OrionAIGenerigWorldQuerying_CompareToSymbol::Op' has a wrong offset!");
static_assert(offsetof(OrionAIGenerigWorldQuerying_CompareToSymbol, RHS) == 0x000002, "Member 'OrionAIGenerigWorldQuerying_CompareToSymbol::RHS' has a wrong offset!");
static_assert(offsetof(OrionAIGenerigWorldQuerying_CompareToSymbol, ReturnValue) == 0x000008, "Member 'OrionAIGenerigWorldQuerying_CompareToSymbol::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIGenerigWorldQuerying.Evaluate
// 0x0020 (0x0020 - 0x0000)
struct OrionAIGenerigWorldQuerying_Evaluate final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionGenericAITest                    Condition;                                         // 0x0008(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionAIGenerigWorldQuerying_Evaluate) == 0x000008, "Wrong alignment on OrionAIGenerigWorldQuerying_Evaluate");
static_assert(sizeof(OrionAIGenerigWorldQuerying_Evaluate) == 0x000020, "Wrong size on OrionAIGenerigWorldQuerying_Evaluate");
static_assert(offsetof(OrionAIGenerigWorldQuerying_Evaluate, WorldContextObject) == 0x000000, "Member 'OrionAIGenerigWorldQuerying_Evaluate::WorldContextObject' has a wrong offset!");
static_assert(offsetof(OrionAIGenerigWorldQuerying_Evaluate, Condition) == 0x000008, "Member 'OrionAIGenerigWorldQuerying_Evaluate::Condition' has a wrong offset!");
static_assert(offsetof(OrionAIGenerigWorldQuerying_Evaluate, ReturnValue) == 0x000018, "Member 'OrionAIGenerigWorldQuerying_Evaluate::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIGenerigWorldQuerying.FactCheck
// 0x0018 (0x0018 - 0x0000)
struct OrionAIGenerigWorldQuerying_FactCheck final
{
public:
	EOrionAISymbolicItem                          LHS;                                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTrue;                                           // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionGenericAITest                    ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIGenerigWorldQuerying_FactCheck) == 0x000008, "Wrong alignment on OrionAIGenerigWorldQuerying_FactCheck");
static_assert(sizeof(OrionAIGenerigWorldQuerying_FactCheck) == 0x000018, "Wrong size on OrionAIGenerigWorldQuerying_FactCheck");
static_assert(offsetof(OrionAIGenerigWorldQuerying_FactCheck, LHS) == 0x000000, "Member 'OrionAIGenerigWorldQuerying_FactCheck::LHS' has a wrong offset!");
static_assert(offsetof(OrionAIGenerigWorldQuerying_FactCheck, bIsTrue) == 0x000001, "Member 'OrionAIGenerigWorldQuerying_FactCheck::bIsTrue' has a wrong offset!");
static_assert(offsetof(OrionAIGenerigWorldQuerying_FactCheck, ReturnValue) == 0x000008, "Member 'OrionAIGenerigWorldQuerying_FactCheck::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIGenerigWorldQuerying.IsDead
// 0x0018 (0x0018 - 0x0000)
struct OrionAIGenerigWorldQuerying_IsDead final
{
public:
	EOrionAISymbolicItem                          LHS;                                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTrue;                                           // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionGenericAITest                    ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIGenerigWorldQuerying_IsDead) == 0x000008, "Wrong alignment on OrionAIGenerigWorldQuerying_IsDead");
static_assert(sizeof(OrionAIGenerigWorldQuerying_IsDead) == 0x000018, "Wrong size on OrionAIGenerigWorldQuerying_IsDead");
static_assert(offsetof(OrionAIGenerigWorldQuerying_IsDead, LHS) == 0x000000, "Member 'OrionAIGenerigWorldQuerying_IsDead::LHS' has a wrong offset!");
static_assert(offsetof(OrionAIGenerigWorldQuerying_IsDead, bIsTrue) == 0x000001, "Member 'OrionAIGenerigWorldQuerying_IsDead::bIsTrue' has a wrong offset!");
static_assert(offsetof(OrionAIGenerigWorldQuerying_IsDead, ReturnValue) == 0x000008, "Member 'OrionAIGenerigWorldQuerying_IsDead::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIGenerigWorldQuerying.IsTowerDead
// 0x0018 (0x0018 - 0x0000)
struct OrionAIGenerigWorldQuerying_IsTowerDead final
{
public:
	EAITowerClassification                        Tower;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIOwnership                                  Ownership;                                         // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIGenericLocation                            Location;                                          // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTrue;                                           // 0x0003(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionGenericAITest                    ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIGenerigWorldQuerying_IsTowerDead) == 0x000008, "Wrong alignment on OrionAIGenerigWorldQuerying_IsTowerDead");
static_assert(sizeof(OrionAIGenerigWorldQuerying_IsTowerDead) == 0x000018, "Wrong size on OrionAIGenerigWorldQuerying_IsTowerDead");
static_assert(offsetof(OrionAIGenerigWorldQuerying_IsTowerDead, Tower) == 0x000000, "Member 'OrionAIGenerigWorldQuerying_IsTowerDead::Tower' has a wrong offset!");
static_assert(offsetof(OrionAIGenerigWorldQuerying_IsTowerDead, Ownership) == 0x000001, "Member 'OrionAIGenerigWorldQuerying_IsTowerDead::Ownership' has a wrong offset!");
static_assert(offsetof(OrionAIGenerigWorldQuerying_IsTowerDead, Location) == 0x000002, "Member 'OrionAIGenerigWorldQuerying_IsTowerDead::Location' has a wrong offset!");
static_assert(offsetof(OrionAIGenerigWorldQuerying_IsTowerDead, bIsTrue) == 0x000003, "Member 'OrionAIGenerigWorldQuerying_IsTowerDead::bIsTrue' has a wrong offset!");
static_assert(offsetof(OrionAIGenerigWorldQuerying_IsTowerDead, ReturnValue) == 0x000008, "Member 'OrionAIGenerigWorldQuerying_IsTowerDead::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIGenerigWorldQuerying.LongestDistanceTo
// 0x0018 (0x0018 - 0x0000)
struct OrionAIGenerigWorldQuerying_LongestDistanceTo final
{
public:
	EOrionAISymbolicItem                          From;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionAISymbolicItem                          To;                                                // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGenericAICheck                               Op;                                                // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Distance;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionGenericAITest                    ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIGenerigWorldQuerying_LongestDistanceTo) == 0x000008, "Wrong alignment on OrionAIGenerigWorldQuerying_LongestDistanceTo");
static_assert(sizeof(OrionAIGenerigWorldQuerying_LongestDistanceTo) == 0x000018, "Wrong size on OrionAIGenerigWorldQuerying_LongestDistanceTo");
static_assert(offsetof(OrionAIGenerigWorldQuerying_LongestDistanceTo, From) == 0x000000, "Member 'OrionAIGenerigWorldQuerying_LongestDistanceTo::From' has a wrong offset!");
static_assert(offsetof(OrionAIGenerigWorldQuerying_LongestDistanceTo, To) == 0x000001, "Member 'OrionAIGenerigWorldQuerying_LongestDistanceTo::To' has a wrong offset!");
static_assert(offsetof(OrionAIGenerigWorldQuerying_LongestDistanceTo, Op) == 0x000002, "Member 'OrionAIGenerigWorldQuerying_LongestDistanceTo::Op' has a wrong offset!");
static_assert(offsetof(OrionAIGenerigWorldQuerying_LongestDistanceTo, Distance) == 0x000004, "Member 'OrionAIGenerigWorldQuerying_LongestDistanceTo::Distance' has a wrong offset!");
static_assert(offsetof(OrionAIGenerigWorldQuerying_LongestDistanceTo, ReturnValue) == 0x000008, "Member 'OrionAIGenerigWorldQuerying_LongestDistanceTo::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIGenerigWorldQuerying.ShortestDistanceTo
// 0x0018 (0x0018 - 0x0000)
struct OrionAIGenerigWorldQuerying_ShortestDistanceTo final
{
public:
	EOrionAISymbolicItem                          From;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionAISymbolicItem                          To;                                                // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGenericAICheck                               Op;                                                // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Distance;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionGenericAITest                    ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIGenerigWorldQuerying_ShortestDistanceTo) == 0x000008, "Wrong alignment on OrionAIGenerigWorldQuerying_ShortestDistanceTo");
static_assert(sizeof(OrionAIGenerigWorldQuerying_ShortestDistanceTo) == 0x000018, "Wrong size on OrionAIGenerigWorldQuerying_ShortestDistanceTo");
static_assert(offsetof(OrionAIGenerigWorldQuerying_ShortestDistanceTo, From) == 0x000000, "Member 'OrionAIGenerigWorldQuerying_ShortestDistanceTo::From' has a wrong offset!");
static_assert(offsetof(OrionAIGenerigWorldQuerying_ShortestDistanceTo, To) == 0x000001, "Member 'OrionAIGenerigWorldQuerying_ShortestDistanceTo::To' has a wrong offset!");
static_assert(offsetof(OrionAIGenerigWorldQuerying_ShortestDistanceTo, Op) == 0x000002, "Member 'OrionAIGenerigWorldQuerying_ShortestDistanceTo::Op' has a wrong offset!");
static_assert(offsetof(OrionAIGenerigWorldQuerying_ShortestDistanceTo, Distance) == 0x000004, "Member 'OrionAIGenerigWorldQuerying_ShortestDistanceTo::Distance' has a wrong offset!");
static_assert(offsetof(OrionAIGenerigWorldQuerying_ShortestDistanceTo, ReturnValue) == 0x000008, "Member 'OrionAIGenerigWorldQuerying_ShortestDistanceTo::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIInfluenceMapManager.OnNavDataGenerationFinished
// 0x0008 (0x0008 - 0x0000)
struct OrionAIInfluenceMapManager_OnNavDataGenerationFinished final
{
public:
	class ANavigationData*                        NavData;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIInfluenceMapManager_OnNavDataGenerationFinished) == 0x000008, "Wrong alignment on OrionAIInfluenceMapManager_OnNavDataGenerationFinished");
static_assert(sizeof(OrionAIInfluenceMapManager_OnNavDataGenerationFinished) == 0x000008, "Wrong size on OrionAIInfluenceMapManager_OnNavDataGenerationFinished");
static_assert(offsetof(OrionAIInfluenceMapManager_OnNavDataGenerationFinished, NavData) == 0x000000, "Member 'OrionAIInfluenceMapManager_OnNavDataGenerationFinished::NavData' has a wrong offset!");

// Function OrionGame.OrionAIKismetLibrary.GetBlackboardValueAsAbilitySpecHandle
// 0x0038 (0x0038 - 0x0000)
struct OrionAIKismetLibrary_GetBlackboardValueAsAbilitySpecHandle final
{
public:
	class UBTNode*                                NodeOwner;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 Key;                                               // 0x0008(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAbilitySpecHandle             ReturnValue;                                       // 0x0030(0x0004)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionAIKismetLibrary_GetBlackboardValueAsAbilitySpecHandle) == 0x000008, "Wrong alignment on OrionAIKismetLibrary_GetBlackboardValueAsAbilitySpecHandle");
static_assert(sizeof(OrionAIKismetLibrary_GetBlackboardValueAsAbilitySpecHandle) == 0x000038, "Wrong size on OrionAIKismetLibrary_GetBlackboardValueAsAbilitySpecHandle");
static_assert(offsetof(OrionAIKismetLibrary_GetBlackboardValueAsAbilitySpecHandle, NodeOwner) == 0x000000, "Member 'OrionAIKismetLibrary_GetBlackboardValueAsAbilitySpecHandle::NodeOwner' has a wrong offset!");
static_assert(offsetof(OrionAIKismetLibrary_GetBlackboardValueAsAbilitySpecHandle, Key) == 0x000008, "Member 'OrionAIKismetLibrary_GetBlackboardValueAsAbilitySpecHandle::Key' has a wrong offset!");
static_assert(offsetof(OrionAIKismetLibrary_GetBlackboardValueAsAbilitySpecHandle, ReturnValue) == 0x000030, "Member 'OrionAIKismetLibrary_GetBlackboardValueAsAbilitySpecHandle::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIKismetLibrary.GetClosestJungleCamp
// 0x0018 (0x0018 - 0x0000)
struct OrionAIKismetLibrary_GetClosestJungleCamp final
{
public:
	class AOrionAIBot*                            Bot;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAICampType                                   Camp;                                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinCreepsAlive;                                    // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionCharAISpawner_Jungle*             ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIKismetLibrary_GetClosestJungleCamp) == 0x000008, "Wrong alignment on OrionAIKismetLibrary_GetClosestJungleCamp");
static_assert(sizeof(OrionAIKismetLibrary_GetClosestJungleCamp) == 0x000018, "Wrong size on OrionAIKismetLibrary_GetClosestJungleCamp");
static_assert(offsetof(OrionAIKismetLibrary_GetClosestJungleCamp, Bot) == 0x000000, "Member 'OrionAIKismetLibrary_GetClosestJungleCamp::Bot' has a wrong offset!");
static_assert(offsetof(OrionAIKismetLibrary_GetClosestJungleCamp, Camp) == 0x000008, "Member 'OrionAIKismetLibrary_GetClosestJungleCamp::Camp' has a wrong offset!");
static_assert(offsetof(OrionAIKismetLibrary_GetClosestJungleCamp, MinCreepsAlive) == 0x00000C, "Member 'OrionAIKismetLibrary_GetClosestJungleCamp::MinCreepsAlive' has a wrong offset!");
static_assert(offsetof(OrionAIKismetLibrary_GetClosestJungleCamp, ReturnValue) == 0x000010, "Member 'OrionAIKismetLibrary_GetClosestJungleCamp::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIKismetLibrary.GetInfluenceValueAt
// 0x0020 (0x0020 - 0x0000)
struct OrionAIKismetLibrary_GetInfluenceValueAt final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldLocation;                                     // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    QuerierTeam;                                       // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionAIKismetLibrary_GetInfluenceValueAt) == 0x000008, "Wrong alignment on OrionAIKismetLibrary_GetInfluenceValueAt");
static_assert(sizeof(OrionAIKismetLibrary_GetInfluenceValueAt) == 0x000020, "Wrong size on OrionAIKismetLibrary_GetInfluenceValueAt");
static_assert(offsetof(OrionAIKismetLibrary_GetInfluenceValueAt, WorldContextObject) == 0x000000, "Member 'OrionAIKismetLibrary_GetInfluenceValueAt::WorldContextObject' has a wrong offset!");
static_assert(offsetof(OrionAIKismetLibrary_GetInfluenceValueAt, WorldLocation) == 0x000008, "Member 'OrionAIKismetLibrary_GetInfluenceValueAt::WorldLocation' has a wrong offset!");
static_assert(offsetof(OrionAIKismetLibrary_GetInfluenceValueAt, QuerierTeam) == 0x000014, "Member 'OrionAIKismetLibrary_GetInfluenceValueAt::QuerierTeam' has a wrong offset!");
static_assert(offsetof(OrionAIKismetLibrary_GetInfluenceValueAt, ReturnValue) == 0x000018, "Member 'OrionAIKismetLibrary_GetInfluenceValueAt::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIKismetLibrary.GetOwnTower
// 0x0020 (0x0020 - 0x0000)
struct OrionAIKismetLibrary_GetOwnTower final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LaneID;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    TeamNum;                                           // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TowerIndex;                                        // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrionDamageableObjective_Base*         ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIKismetLibrary_GetOwnTower) == 0x000008, "Wrong alignment on OrionAIKismetLibrary_GetOwnTower");
static_assert(sizeof(OrionAIKismetLibrary_GetOwnTower) == 0x000020, "Wrong size on OrionAIKismetLibrary_GetOwnTower");
static_assert(offsetof(OrionAIKismetLibrary_GetOwnTower, WorldContextObject) == 0x000000, "Member 'OrionAIKismetLibrary_GetOwnTower::WorldContextObject' has a wrong offset!");
static_assert(offsetof(OrionAIKismetLibrary_GetOwnTower, LaneID) == 0x000008, "Member 'OrionAIKismetLibrary_GetOwnTower::LaneID' has a wrong offset!");
static_assert(offsetof(OrionAIKismetLibrary_GetOwnTower, TeamNum) == 0x00000C, "Member 'OrionAIKismetLibrary_GetOwnTower::TeamNum' has a wrong offset!");
static_assert(offsetof(OrionAIKismetLibrary_GetOwnTower, TowerIndex) == 0x000010, "Member 'OrionAIKismetLibrary_GetOwnTower::TowerIndex' has a wrong offset!");
static_assert(offsetof(OrionAIKismetLibrary_GetOwnTower, ReturnValue) == 0x000018, "Member 'OrionAIKismetLibrary_GetOwnTower::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIKismetLibrary.K2_ClearTimerByHandle
// 0x0010 (0x0010 - 0x0000)
struct OrionAIKismetLibrary_K2_ClearTimerByHandle final
{
public:
	struct FTimerHandle                           TimerHandle;                                       // 0x0000(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	class UObject*                                WorldContext;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIKismetLibrary_K2_ClearTimerByHandle) == 0x000008, "Wrong alignment on OrionAIKismetLibrary_K2_ClearTimerByHandle");
static_assert(sizeof(OrionAIKismetLibrary_K2_ClearTimerByHandle) == 0x000010, "Wrong size on OrionAIKismetLibrary_K2_ClearTimerByHandle");
static_assert(offsetof(OrionAIKismetLibrary_K2_ClearTimerByHandle, TimerHandle) == 0x000000, "Member 'OrionAIKismetLibrary_K2_ClearTimerByHandle::TimerHandle' has a wrong offset!");
static_assert(offsetof(OrionAIKismetLibrary_K2_ClearTimerByHandle, WorldContext) == 0x000008, "Member 'OrionAIKismetLibrary_K2_ClearTimerByHandle::WorldContext' has a wrong offset!");

// Function OrionGame.OrionAIKismetLibrary.K2_FillWithBots
// 0x0020 (0x0020 - 0x0000)
struct OrionAIKismetLibrary_K2_FillWithBots final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BotsToAddToEachTeam;                               // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 HeroListName;                                      // 0x0010(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIKismetLibrary_K2_FillWithBots) == 0x000008, "Wrong alignment on OrionAIKismetLibrary_K2_FillWithBots");
static_assert(sizeof(OrionAIKismetLibrary_K2_FillWithBots) == 0x000020, "Wrong size on OrionAIKismetLibrary_K2_FillWithBots");
static_assert(offsetof(OrionAIKismetLibrary_K2_FillWithBots, WorldContextObject) == 0x000000, "Member 'OrionAIKismetLibrary_K2_FillWithBots::WorldContextObject' has a wrong offset!");
static_assert(offsetof(OrionAIKismetLibrary_K2_FillWithBots, BotsToAddToEachTeam) == 0x000008, "Member 'OrionAIKismetLibrary_K2_FillWithBots::BotsToAddToEachTeam' has a wrong offset!");
static_assert(offsetof(OrionAIKismetLibrary_K2_FillWithBots, HeroListName) == 0x000010, "Member 'OrionAIKismetLibrary_K2_FillWithBots::HeroListName' has a wrong offset!");

// Function OrionGame.OrionAIKismetLibrary.K2_GetAIMarkup
// 0x0010 (0x0010 - 0x0000)
struct OrionAIKismetLibrary_K2_GetAIMarkup final
{
public:
	class AActor*                                 WorldContext;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionAILevelMarkup*                    ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIKismetLibrary_K2_GetAIMarkup) == 0x000008, "Wrong alignment on OrionAIKismetLibrary_K2_GetAIMarkup");
static_assert(sizeof(OrionAIKismetLibrary_K2_GetAIMarkup) == 0x000010, "Wrong size on OrionAIKismetLibrary_K2_GetAIMarkup");
static_assert(offsetof(OrionAIKismetLibrary_K2_GetAIMarkup, WorldContext) == 0x000000, "Member 'OrionAIKismetLibrary_K2_GetAIMarkup::WorldContext' has a wrong offset!");
static_assert(offsetof(OrionAIKismetLibrary_K2_GetAIMarkup, ReturnValue) == 0x000008, "Member 'OrionAIKismetLibrary_K2_GetAIMarkup::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIKismetLibrary.K2_GetTeamBots
// 0x0020 (0x0020 - 0x0000)
struct OrionAIKismetLibrary_K2_GetTeamBots final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    TeamNum;                                           // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AOrionAIBot*>                    OutBots;                                           // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIKismetLibrary_K2_GetTeamBots) == 0x000008, "Wrong alignment on OrionAIKismetLibrary_K2_GetTeamBots");
static_assert(sizeof(OrionAIKismetLibrary_K2_GetTeamBots) == 0x000020, "Wrong size on OrionAIKismetLibrary_K2_GetTeamBots");
static_assert(offsetof(OrionAIKismetLibrary_K2_GetTeamBots, WorldContextObject) == 0x000000, "Member 'OrionAIKismetLibrary_K2_GetTeamBots::WorldContextObject' has a wrong offset!");
static_assert(offsetof(OrionAIKismetLibrary_K2_GetTeamBots, TeamNum) == 0x000008, "Member 'OrionAIKismetLibrary_K2_GetTeamBots::TeamNum' has a wrong offset!");
static_assert(offsetof(OrionAIKismetLibrary_K2_GetTeamBots, OutBots) == 0x000010, "Member 'OrionAIKismetLibrary_K2_GetTeamBots::OutBots' has a wrong offset!");

// Function OrionGame.OrionAIKismetLibrary.K2_SetTimerDelegate
// 0x0028 (0x0028 - 0x0000)
struct OrionAIKismetLibrary_K2_SetTimerDelegate final
{
public:
	TDelegate<void()>                             Delegate;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLooping;                                          // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                WorldContext;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIKismetLibrary_K2_SetTimerDelegate) == 0x000008, "Wrong alignment on OrionAIKismetLibrary_K2_SetTimerDelegate");
static_assert(sizeof(OrionAIKismetLibrary_K2_SetTimerDelegate) == 0x000028, "Wrong size on OrionAIKismetLibrary_K2_SetTimerDelegate");
static_assert(offsetof(OrionAIKismetLibrary_K2_SetTimerDelegate, Delegate) == 0x000000, "Member 'OrionAIKismetLibrary_K2_SetTimerDelegate::Delegate' has a wrong offset!");
static_assert(offsetof(OrionAIKismetLibrary_K2_SetTimerDelegate, Time) == 0x000010, "Member 'OrionAIKismetLibrary_K2_SetTimerDelegate::Time' has a wrong offset!");
static_assert(offsetof(OrionAIKismetLibrary_K2_SetTimerDelegate, bLooping) == 0x000014, "Member 'OrionAIKismetLibrary_K2_SetTimerDelegate::bLooping' has a wrong offset!");
static_assert(offsetof(OrionAIKismetLibrary_K2_SetTimerDelegate, WorldContext) == 0x000018, "Member 'OrionAIKismetLibrary_K2_SetTimerDelegate::WorldContext' has a wrong offset!");
static_assert(offsetof(OrionAIKismetLibrary_K2_SetTimerDelegate, ReturnValue) == 0x000020, "Member 'OrionAIKismetLibrary_K2_SetTimerDelegate::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIKismetLibrary.RemoveInfluenceSource
// 0x0020 (0x0020 - 0x0000)
struct OrionAIKismetLibrary_RemoveInfluenceSource final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TScriptInterface<class IOrionTeamActorInterface> InfluenceSource;                                   // 0x0008(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bForceUpdate;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionAIKismetLibrary_RemoveInfluenceSource) == 0x000008, "Wrong alignment on OrionAIKismetLibrary_RemoveInfluenceSource");
static_assert(sizeof(OrionAIKismetLibrary_RemoveInfluenceSource) == 0x000020, "Wrong size on OrionAIKismetLibrary_RemoveInfluenceSource");
static_assert(offsetof(OrionAIKismetLibrary_RemoveInfluenceSource, WorldContextObject) == 0x000000, "Member 'OrionAIKismetLibrary_RemoveInfluenceSource::WorldContextObject' has a wrong offset!");
static_assert(offsetof(OrionAIKismetLibrary_RemoveInfluenceSource, InfluenceSource) == 0x000008, "Member 'OrionAIKismetLibrary_RemoveInfluenceSource::InfluenceSource' has a wrong offset!");
static_assert(offsetof(OrionAIKismetLibrary_RemoveInfluenceSource, bForceUpdate) == 0x000018, "Member 'OrionAIKismetLibrary_RemoveInfluenceSource::bForceUpdate' has a wrong offset!");

// Function OrionGame.OrionAIKismetLibrary.UpdateInfluenceSurce
// 0x0028 (0x0028 - 0x0000)
struct OrionAIKismetLibrary_UpdateInfluenceSurce final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TScriptInterface<class IOrionTeamActorInterface> InfluenceSource;                                   // 0x0008(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	EAIActorClassification                        SourceType;                                        // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Radius;                                            // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceUpdate;                                      // 0x0024(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionAIKismetLibrary_UpdateInfluenceSurce) == 0x000008, "Wrong alignment on OrionAIKismetLibrary_UpdateInfluenceSurce");
static_assert(sizeof(OrionAIKismetLibrary_UpdateInfluenceSurce) == 0x000028, "Wrong size on OrionAIKismetLibrary_UpdateInfluenceSurce");
static_assert(offsetof(OrionAIKismetLibrary_UpdateInfluenceSurce, WorldContextObject) == 0x000000, "Member 'OrionAIKismetLibrary_UpdateInfluenceSurce::WorldContextObject' has a wrong offset!");
static_assert(offsetof(OrionAIKismetLibrary_UpdateInfluenceSurce, InfluenceSource) == 0x000008, "Member 'OrionAIKismetLibrary_UpdateInfluenceSurce::InfluenceSource' has a wrong offset!");
static_assert(offsetof(OrionAIKismetLibrary_UpdateInfluenceSurce, SourceType) == 0x000018, "Member 'OrionAIKismetLibrary_UpdateInfluenceSurce::SourceType' has a wrong offset!");
static_assert(offsetof(OrionAIKismetLibrary_UpdateInfluenceSurce, Radius) == 0x00001C, "Member 'OrionAIKismetLibrary_UpdateInfluenceSurce::Radius' has a wrong offset!");
static_assert(offsetof(OrionAIKismetLibrary_UpdateInfluenceSurce, Strength) == 0x000020, "Member 'OrionAIKismetLibrary_UpdateInfluenceSurce::Strength' has a wrong offset!");
static_assert(offsetof(OrionAIKismetLibrary_UpdateInfluenceSurce, bForceUpdate) == 0x000024, "Member 'OrionAIKismetLibrary_UpdateInfluenceSurce::bForceUpdate' has a wrong offset!");

// Function OrionGame.OrionTutorialPath.PlayPoof
// 0x000C (0x000C - 0x0000)
struct OrionTutorialPath_PlayPoof final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTutorialPath_PlayPoof) == 0x000004, "Wrong alignment on OrionTutorialPath_PlayPoof");
static_assert(sizeof(OrionTutorialPath_PlayPoof) == 0x00000C, "Wrong size on OrionTutorialPath_PlayPoof");
static_assert(offsetof(OrionTutorialPath_PlayPoof, Location) == 0x000000, "Member 'OrionTutorialPath_PlayPoof::Location' has a wrong offset!");

// Function OrionGame.OrionTutorialPath.UpdateLineDecalComponent
// 0x0028 (0x0028 - 0x0000)
struct OrionTutorialPath_UpdateLineDecalComponent final
{
public:
	class UDecalComponent*                        Decal;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               Mid;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SourceVec;                                         // 0x0010(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetVec;                                         // 0x001C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTutorialPath_UpdateLineDecalComponent) == 0x000008, "Wrong alignment on OrionTutorialPath_UpdateLineDecalComponent");
static_assert(sizeof(OrionTutorialPath_UpdateLineDecalComponent) == 0x000028, "Wrong size on OrionTutorialPath_UpdateLineDecalComponent");
static_assert(offsetof(OrionTutorialPath_UpdateLineDecalComponent, Decal) == 0x000000, "Member 'OrionTutorialPath_UpdateLineDecalComponent::Decal' has a wrong offset!");
static_assert(offsetof(OrionTutorialPath_UpdateLineDecalComponent, Mid) == 0x000008, "Member 'OrionTutorialPath_UpdateLineDecalComponent::Mid' has a wrong offset!");
static_assert(offsetof(OrionTutorialPath_UpdateLineDecalComponent, SourceVec) == 0x000010, "Member 'OrionTutorialPath_UpdateLineDecalComponent::SourceVec' has a wrong offset!");
static_assert(offsetof(OrionTutorialPath_UpdateLineDecalComponent, TargetVec) == 0x00001C, "Member 'OrionTutorialPath_UpdateLineDecalComponent::TargetVec' has a wrong offset!");

// Function OrionGame.OrionTutorialPath.UpdateNodeDecalComponent
// 0x0020 (0x0020 - 0x0000)
struct OrionTutorialPath_UpdateNodeDecalComponent final
{
public:
	class UDecalComponent*                        Decal;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               Mid;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index_0;                                           // 0x001C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTutorialPath_UpdateNodeDecalComponent) == 0x000008, "Wrong alignment on OrionTutorialPath_UpdateNodeDecalComponent");
static_assert(sizeof(OrionTutorialPath_UpdateNodeDecalComponent) == 0x000020, "Wrong size on OrionTutorialPath_UpdateNodeDecalComponent");
static_assert(offsetof(OrionTutorialPath_UpdateNodeDecalComponent, Decal) == 0x000000, "Member 'OrionTutorialPath_UpdateNodeDecalComponent::Decal' has a wrong offset!");
static_assert(offsetof(OrionTutorialPath_UpdateNodeDecalComponent, Mid) == 0x000008, "Member 'OrionTutorialPath_UpdateNodeDecalComponent::Mid' has a wrong offset!");
static_assert(offsetof(OrionTutorialPath_UpdateNodeDecalComponent, Location) == 0x000010, "Member 'OrionTutorialPath_UpdateNodeDecalComponent::Location' has a wrong offset!");
static_assert(offsetof(OrionTutorialPath_UpdateNodeDecalComponent, Index_0) == 0x00001C, "Member 'OrionTutorialPath_UpdateNodeDecalComponent::Index_0' has a wrong offset!");

// Function OrionGame.OrionTutorialPath.GetNumOfPoints
// 0x0004 (0x0004 - 0x0000)
struct OrionTutorialPath_GetNumOfPoints final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTutorialPath_GetNumOfPoints) == 0x000004, "Wrong alignment on OrionTutorialPath_GetNumOfPoints");
static_assert(sizeof(OrionTutorialPath_GetNumOfPoints) == 0x000004, "Wrong size on OrionTutorialPath_GetNumOfPoints");
static_assert(offsetof(OrionTutorialPath_GetNumOfPoints, ReturnValue) == 0x000000, "Member 'OrionTutorialPath_GetNumOfPoints::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCarriedObjective.HandleCurrentHoldersDeath
// 0x0008 (0x0008 - 0x0000)
struct OrionCarriedObjective_HandleCurrentHoldersDeath final
{
public:
	class AOrionChar*                             DeadChar;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCarriedObjective_HandleCurrentHoldersDeath) == 0x000008, "Wrong alignment on OrionCarriedObjective_HandleCurrentHoldersDeath");
static_assert(sizeof(OrionCarriedObjective_HandleCurrentHoldersDeath) == 0x000008, "Wrong size on OrionCarriedObjective_HandleCurrentHoldersDeath");
static_assert(offsetof(OrionCarriedObjective_HandleCurrentHoldersDeath, DeadChar) == 0x000000, "Member 'OrionCarriedObjective_HandleCurrentHoldersDeath::DeadChar' has a wrong offset!");

// Function OrionGame.OrionCarriedObjective.HandleCurrentHoldersDestroyed
// 0x0008 (0x0008 - 0x0000)
struct OrionCarriedObjective_HandleCurrentHoldersDestroyed final
{
public:
	class AActor*                                 DestroyedActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCarriedObjective_HandleCurrentHoldersDestroyed) == 0x000008, "Wrong alignment on OrionCarriedObjective_HandleCurrentHoldersDestroyed");
static_assert(sizeof(OrionCarriedObjective_HandleCurrentHoldersDestroyed) == 0x000008, "Wrong size on OrionCarriedObjective_HandleCurrentHoldersDestroyed");
static_assert(offsetof(OrionCarriedObjective_HandleCurrentHoldersDestroyed, DestroyedActor) == 0x000000, "Member 'OrionCarriedObjective_HandleCurrentHoldersDestroyed::DestroyedActor' has a wrong offset!");

// Function OrionGame.OrionCarriedObjective.HandleHomingDeath
// 0x0008 (0x0008 - 0x0000)
struct OrionCarriedObjective_HandleHomingDeath final
{
public:
	class AOrionChar*                             DeadChar;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCarriedObjective_HandleHomingDeath) == 0x000008, "Wrong alignment on OrionCarriedObjective_HandleHomingDeath");
static_assert(sizeof(OrionCarriedObjective_HandleHomingDeath) == 0x000008, "Wrong size on OrionCarriedObjective_HandleHomingDeath");
static_assert(offsetof(OrionCarriedObjective_HandleHomingDeath, DeadChar) == 0x000000, "Member 'OrionCarriedObjective_HandleHomingDeath::DeadChar' has a wrong offset!");

// Function OrionGame.OrionCarriedObjective.HandleHomingEnterPhaseShift
// 0x0008 (0x0008 - 0x0000)
struct OrionCarriedObjective_HandleHomingEnterPhaseShift final
{
public:
	class AOrionChar*                             PhaseShifedChar;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCarriedObjective_HandleHomingEnterPhaseShift) == 0x000008, "Wrong alignment on OrionCarriedObjective_HandleHomingEnterPhaseShift");
static_assert(sizeof(OrionCarriedObjective_HandleHomingEnterPhaseShift) == 0x000008, "Wrong size on OrionCarriedObjective_HandleHomingEnterPhaseShift");
static_assert(offsetof(OrionCarriedObjective_HandleHomingEnterPhaseShift, PhaseShifedChar) == 0x000000, "Member 'OrionCarriedObjective_HandleHomingEnterPhaseShift::PhaseShifedChar' has a wrong offset!");

// Function OrionGame.OrionCarriedObjective.IsHeld
// 0x0001 (0x0001 - 0x0000)
struct OrionCarriedObjective_IsHeld final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCarriedObjective_IsHeld) == 0x000001, "Wrong alignment on OrionCarriedObjective_IsHeld");
static_assert(sizeof(OrionCarriedObjective_IsHeld) == 0x000001, "Wrong size on OrionCarriedObjective_IsHeld");
static_assert(offsetof(OrionCarriedObjective_IsHeld, ReturnValue) == 0x000000, "Member 'OrionCarriedObjective_IsHeld::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCarriedObjective.SetCurrentHolder
// 0x0008 (0x0008 - 0x0000)
struct OrionCarriedObjective_SetCurrentHolder final
{
public:
	class AOrionPlayerState_Game*                 InHolder;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCarriedObjective_SetCurrentHolder) == 0x000008, "Wrong alignment on OrionCarriedObjective_SetCurrentHolder");
static_assert(sizeof(OrionCarriedObjective_SetCurrentHolder) == 0x000008, "Wrong size on OrionCarriedObjective_SetCurrentHolder");
static_assert(offsetof(OrionCarriedObjective_SetCurrentHolder, InHolder) == 0x000000, "Member 'OrionCarriedObjective_SetCurrentHolder::InHolder' has a wrong offset!");

// Function OrionGame.OrionAimTargetInterface.GetAimTargetExtent
// 0x0014 (0x0014 - 0x0000)
struct OrionAimTargetInterface_GetAimTargetExtent final
{
public:
	struct FVector                                Center;                                            // 0x0000(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Width;                                             // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAimTargetInterface_GetAimTargetExtent) == 0x000004, "Wrong alignment on OrionAimTargetInterface_GetAimTargetExtent");
static_assert(sizeof(OrionAimTargetInterface_GetAimTargetExtent) == 0x000014, "Wrong size on OrionAimTargetInterface_GetAimTargetExtent");
static_assert(offsetof(OrionAimTargetInterface_GetAimTargetExtent, Center) == 0x000000, "Member 'OrionAimTargetInterface_GetAimTargetExtent::Center' has a wrong offset!");
static_assert(offsetof(OrionAimTargetInterface_GetAimTargetExtent, Width) == 0x00000C, "Member 'OrionAimTargetInterface_GetAimTargetExtent::Width' has a wrong offset!");
static_assert(offsetof(OrionAimTargetInterface_GetAimTargetExtent, Height) == 0x000010, "Member 'OrionAimTargetInterface_GetAimTargetExtent::Height' has a wrong offset!");

// Function OrionGame.OrionAimTargetInterface.GetAimTargetSensingLocation
// 0x000C (0x000C - 0x0000)
struct OrionAimTargetInterface_GetAimTargetSensingLocation final
{
public:
	struct FVector                                AimPosition;                                       // 0x0000(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAimTargetInterface_GetAimTargetSensingLocation) == 0x000004, "Wrong alignment on OrionAimTargetInterface_GetAimTargetSensingLocation");
static_assert(sizeof(OrionAimTargetInterface_GetAimTargetSensingLocation) == 0x00000C, "Wrong size on OrionAimTargetInterface_GetAimTargetSensingLocation");
static_assert(offsetof(OrionAimTargetInterface_GetAimTargetSensingLocation, AimPosition) == 0x000000, "Member 'OrionAimTargetInterface_GetAimTargetSensingLocation::AimPosition' has a wrong offset!");

// Function OrionGame.OrionAimTargetInterface.GetMyTargetType
// 0x0001 (0x0001 - 0x0000)
struct OrionAimTargetInterface_GetMyTargetType final
{
public:
	EOrionTargetType                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAimTargetInterface_GetMyTargetType) == 0x000001, "Wrong alignment on OrionAimTargetInterface_GetMyTargetType");
static_assert(sizeof(OrionAimTargetInterface_GetMyTargetType) == 0x000001, "Wrong size on OrionAimTargetInterface_GetMyTargetType");
static_assert(offsetof(OrionAimTargetInterface_GetMyTargetType, ReturnValue) == 0x000000, "Member 'OrionAimTargetInterface_GetMyTargetType::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAimTargetInterface.GetNumberPopLocation
// 0x0018 (0x0018 - 0x0000)
struct OrionAimTargetInterface_GetNumberPopLocation final
{
public:
	struct FVector                                HitLocation;                                       // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAimTargetInterface_GetNumberPopLocation) == 0x000004, "Wrong alignment on OrionAimTargetInterface_GetNumberPopLocation");
static_assert(sizeof(OrionAimTargetInterface_GetNumberPopLocation) == 0x000018, "Wrong size on OrionAimTargetInterface_GetNumberPopLocation");
static_assert(offsetof(OrionAimTargetInterface_GetNumberPopLocation, HitLocation) == 0x000000, "Member 'OrionAimTargetInterface_GetNumberPopLocation::HitLocation' has a wrong offset!");
static_assert(offsetof(OrionAimTargetInterface_GetNumberPopLocation, ReturnValue) == 0x00000C, "Member 'OrionAimTargetInterface_GetNumberPopLocation::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAimTargetInterface.GetTargetingLocation
// 0x000C (0x000C - 0x0000)
struct OrionAimTargetInterface_GetTargetingLocation final
{
public:
	struct FVector                                OutPosition;                                       // 0x0000(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAimTargetInterface_GetTargetingLocation) == 0x000004, "Wrong alignment on OrionAimTargetInterface_GetTargetingLocation");
static_assert(sizeof(OrionAimTargetInterface_GetTargetingLocation) == 0x00000C, "Wrong size on OrionAimTargetInterface_GetTargetingLocation");
static_assert(offsetof(OrionAimTargetInterface_GetTargetingLocation, OutPosition) == 0x000000, "Member 'OrionAimTargetInterface_GetTargetingLocation::OutPosition' has a wrong offset!");

// Function OrionGame.OrionAimTargetInterface.IsValidDirectHit
// 0x0090 (0x0090 - 0x0000)
struct OrionAimTargetInterface_IsValidDirectHit final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0088(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionAimTargetInterface_IsValidDirectHit) == 0x000008, "Wrong alignment on OrionAimTargetInterface_IsValidDirectHit");
static_assert(sizeof(OrionAimTargetInterface_IsValidDirectHit) == 0x000090, "Wrong size on OrionAimTargetInterface_IsValidDirectHit");
static_assert(offsetof(OrionAimTargetInterface_IsValidDirectHit, HitResult) == 0x000000, "Member 'OrionAimTargetInterface_IsValidDirectHit::HitResult' has a wrong offset!");
static_assert(offsetof(OrionAimTargetInterface_IsValidDirectHit, ReturnValue) == 0x000088, "Member 'OrionAimTargetInterface_IsValidDirectHit::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAimTargetInterface.ShouldIgnoreCollisionWithTeam
// 0x0003 (0x0003 - 0x0000)
struct OrionAimTargetInterface_ShouldIgnoreCollisionWithTeam final
{
public:
	EOrionTeam                                    Team;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPassedFilter;                                     // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAimTargetInterface_ShouldIgnoreCollisionWithTeam) == 0x000001, "Wrong alignment on OrionAimTargetInterface_ShouldIgnoreCollisionWithTeam");
static_assert(sizeof(OrionAimTargetInterface_ShouldIgnoreCollisionWithTeam) == 0x000003, "Wrong size on OrionAimTargetInterface_ShouldIgnoreCollisionWithTeam");
static_assert(offsetof(OrionAimTargetInterface_ShouldIgnoreCollisionWithTeam, Team) == 0x000000, "Member 'OrionAimTargetInterface_ShouldIgnoreCollisionWithTeam::Team' has a wrong offset!");
static_assert(offsetof(OrionAimTargetInterface_ShouldIgnoreCollisionWithTeam, bPassedFilter) == 0x000001, "Member 'OrionAimTargetInterface_ShouldIgnoreCollisionWithTeam::bPassedFilter' has a wrong offset!");
static_assert(offsetof(OrionAimTargetInterface_ShouldIgnoreCollisionWithTeam, ReturnValue) == 0x000002, "Member 'OrionAimTargetInterface_ShouldIgnoreCollisionWithTeam::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAimTargetInterface.UpdateOccludedVision
// 0x0001 (0x0001 - 0x0000)
struct OrionAimTargetInterface_UpdateOccludedVision final
{
public:
	bool                                          bShouldShowWhenOccluded;                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAimTargetInterface_UpdateOccludedVision) == 0x000001, "Wrong alignment on OrionAimTargetInterface_UpdateOccludedVision");
static_assert(sizeof(OrionAimTargetInterface_UpdateOccludedVision) == 0x000001, "Wrong size on OrionAimTargetInterface_UpdateOccludedVision");
static_assert(offsetof(OrionAimTargetInterface_UpdateOccludedVision, bShouldShowWhenOccluded) == 0x000000, "Member 'OrionAimTargetInterface_UpdateOccludedVision::bShouldShowWhenOccluded' has a wrong offset!");

// Function OrionGame.OrionAimTargetInterface.CanBeHitWhileInShadowPlane
// 0x0001 (0x0001 - 0x0000)
struct OrionAimTargetInterface_CanBeHitWhileInShadowPlane final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAimTargetInterface_CanBeHitWhileInShadowPlane) == 0x000001, "Wrong alignment on OrionAimTargetInterface_CanBeHitWhileInShadowPlane");
static_assert(sizeof(OrionAimTargetInterface_CanBeHitWhileInShadowPlane) == 0x000001, "Wrong size on OrionAimTargetInterface_CanBeHitWhileInShadowPlane");
static_assert(offsetof(OrionAimTargetInterface_CanBeHitWhileInShadowPlane, ReturnValue) == 0x000000, "Member 'OrionAimTargetInterface_CanBeHitWhileInShadowPlane::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAimTargetInterface.CanSee
// 0x0010 (0x0010 - 0x0000)
struct OrionAimTargetInterface_CanSee final
{
public:
	const class AActor*                           TargetActor;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionVisionType                              ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionAimTargetInterface_CanSee) == 0x000008, "Wrong alignment on OrionAimTargetInterface_CanSee");
static_assert(sizeof(OrionAimTargetInterface_CanSee) == 0x000010, "Wrong size on OrionAimTargetInterface_CanSee");
static_assert(offsetof(OrionAimTargetInterface_CanSee, TargetActor) == 0x000000, "Member 'OrionAimTargetInterface_CanSee::TargetActor' has a wrong offset!");
static_assert(offsetof(OrionAimTargetInterface_CanSee, ReturnValue) == 0x000008, "Member 'OrionAimTargetInterface_CanSee::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAimTargetInterface.IsTargetable
// 0x0001 (0x0001 - 0x0000)
struct OrionAimTargetInterface_IsTargetable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAimTargetInterface_IsTargetable) == 0x000001, "Wrong alignment on OrionAimTargetInterface_IsTargetable");
static_assert(sizeof(OrionAimTargetInterface_IsTargetable) == 0x000001, "Wrong size on OrionAimTargetInterface_IsTargetable");
static_assert(offsetof(OrionAimTargetInterface_IsTargetable, ReturnValue) == 0x000000, "Member 'OrionAimTargetInterface_IsTargetable::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharAISpawner.AddAIToNextWave
// 0x0008 (0x0008 - 0x0000)
struct OrionCharAISpawner_AddAIToNextWave final
{
public:
	class UOrionAIData*                           InAIData;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAISpawner_AddAIToNextWave) == 0x000008, "Wrong alignment on OrionCharAISpawner_AddAIToNextWave");
static_assert(sizeof(OrionCharAISpawner_AddAIToNextWave) == 0x000008, "Wrong size on OrionCharAISpawner_AddAIToNextWave");
static_assert(offsetof(OrionCharAISpawner_AddAIToNextWave, InAIData) == 0x000000, "Member 'OrionCharAISpawner_AddAIToNextWave::InAIData' has a wrong offset!");

// Function OrionGame.OrionCharAISpawner.ApplyAggroEffectForHero
// 0x0010 (0x0010 - 0x0000)
struct OrionCharAISpawner_ApplyAggroEffectForHero final
{
public:
	class AActor*                                 Hero;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            AggroEffect;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAISpawner_ApplyAggroEffectForHero) == 0x000008, "Wrong alignment on OrionCharAISpawner_ApplyAggroEffectForHero");
static_assert(sizeof(OrionCharAISpawner_ApplyAggroEffectForHero) == 0x000010, "Wrong size on OrionCharAISpawner_ApplyAggroEffectForHero");
static_assert(offsetof(OrionCharAISpawner_ApplyAggroEffectForHero, Hero) == 0x000000, "Member 'OrionCharAISpawner_ApplyAggroEffectForHero::Hero' has a wrong offset!");
static_assert(offsetof(OrionCharAISpawner_ApplyAggroEffectForHero, AggroEffect) == 0x000008, "Member 'OrionCharAISpawner_ApplyAggroEffectForHero::AggroEffect' has a wrong offset!");

// Function OrionGame.OrionCharAISpawner.ChangeTeamOldVisionManagerOnly
// 0x0001 (0x0001 - 0x0000)
struct OrionCharAISpawner_ChangeTeamOldVisionManagerOnly final
{
public:
	EOrionTeam                                    NewTeam;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAISpawner_ChangeTeamOldVisionManagerOnly) == 0x000001, "Wrong alignment on OrionCharAISpawner_ChangeTeamOldVisionManagerOnly");
static_assert(sizeof(OrionCharAISpawner_ChangeTeamOldVisionManagerOnly) == 0x000001, "Wrong size on OrionCharAISpawner_ChangeTeamOldVisionManagerOnly");
static_assert(offsetof(OrionCharAISpawner_ChangeTeamOldVisionManagerOnly, NewTeam) == 0x000000, "Member 'OrionCharAISpawner_ChangeTeamOldVisionManagerOnly::NewTeam' has a wrong offset!");

// Function OrionGame.OrionCharAISpawner.ForceRestartSpawner
// 0x0001 (0x0001 - 0x0000)
struct OrionCharAISpawner_ForceRestartSpawner final
{
public:
	EOrionCharAISpawnerType                       InType;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAISpawner_ForceRestartSpawner) == 0x000001, "Wrong alignment on OrionCharAISpawner_ForceRestartSpawner");
static_assert(sizeof(OrionCharAISpawner_ForceRestartSpawner) == 0x000001, "Wrong size on OrionCharAISpawner_ForceRestartSpawner");
static_assert(offsetof(OrionCharAISpawner_ForceRestartSpawner, InType) == 0x000000, "Member 'OrionCharAISpawner_ForceRestartSpawner::InType' has a wrong offset!");

// Function OrionGame.OrionCharAISpawner.GetSpawnerAICount
// 0x0004 (0x0004 - 0x0000)
struct OrionCharAISpawner_GetSpawnerAICount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAISpawner_GetSpawnerAICount) == 0x000004, "Wrong alignment on OrionCharAISpawner_GetSpawnerAICount");
static_assert(sizeof(OrionCharAISpawner_GetSpawnerAICount) == 0x000004, "Wrong size on OrionCharAISpawner_GetSpawnerAICount");
static_assert(offsetof(OrionCharAISpawner_GetSpawnerAICount, ReturnValue) == 0x000000, "Member 'OrionCharAISpawner_GetSpawnerAICount::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharAISpawner.HandleSpawnedAIDeath
// 0x0018 (0x0018 - 0x0000)
struct OrionCharAISpawner_HandleSpawnedAIDeath final
{
public:
	class AOrionChar*                             DeadChar;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            Killer;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAISpawner_HandleSpawnedAIDeath) == 0x000008, "Wrong alignment on OrionCharAISpawner_HandleSpawnedAIDeath");
static_assert(sizeof(OrionCharAISpawner_HandleSpawnedAIDeath) == 0x000018, "Wrong size on OrionCharAISpawner_HandleSpawnedAIDeath");
static_assert(offsetof(OrionCharAISpawner_HandleSpawnedAIDeath, DeadChar) == 0x000000, "Member 'OrionCharAISpawner_HandleSpawnedAIDeath::DeadChar' has a wrong offset!");
static_assert(offsetof(OrionCharAISpawner_HandleSpawnedAIDeath, Killer) == 0x000008, "Member 'OrionCharAISpawner_HandleSpawnedAIDeath::Killer' has a wrong offset!");
static_assert(offsetof(OrionCharAISpawner_HandleSpawnedAIDeath, DamageCauser) == 0x000010, "Member 'OrionCharAISpawner_HandleSpawnedAIDeath::DamageCauser' has a wrong offset!");

// Function OrionGame.OrionCharAISpawner.HandleSpawnedAIDestroyed
// 0x0008 (0x0008 - 0x0000)
struct OrionCharAISpawner_HandleSpawnedAIDestroyed final
{
public:
	class AActor*                                 DestroyedActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAISpawner_HandleSpawnedAIDestroyed) == 0x000008, "Wrong alignment on OrionCharAISpawner_HandleSpawnedAIDestroyed");
static_assert(sizeof(OrionCharAISpawner_HandleSpawnedAIDestroyed) == 0x000008, "Wrong size on OrionCharAISpawner_HandleSpawnedAIDestroyed");
static_assert(offsetof(OrionCharAISpawner_HandleSpawnedAIDestroyed, DestroyedActor) == 0x000000, "Member 'OrionCharAISpawner_HandleSpawnedAIDestroyed::DestroyedActor' has a wrong offset!");

// Function OrionGame.OrionCharAISpawner.IsSpawningAnAIFormation
// 0x0001 (0x0001 - 0x0000)
struct OrionCharAISpawner_IsSpawningAnAIFormation final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAISpawner_IsSpawningAnAIFormation) == 0x000001, "Wrong alignment on OrionCharAISpawner_IsSpawningAnAIFormation");
static_assert(sizeof(OrionCharAISpawner_IsSpawningAnAIFormation) == 0x000001, "Wrong size on OrionCharAISpawner_IsSpawningAnAIFormation");
static_assert(offsetof(OrionCharAISpawner_IsSpawningAnAIFormation, ReturnValue) == 0x000000, "Member 'OrionCharAISpawner_IsSpawningAnAIFormation::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharAISpawner.NotifyPendingAIFormation
// 0x0008 (0x0008 - 0x0000)
struct OrionCharAISpawner_NotifyPendingAIFormation final
{
public:
	const class UOrionAIFormationData*            InFormationData;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAISpawner_NotifyPendingAIFormation) == 0x000008, "Wrong alignment on OrionCharAISpawner_NotifyPendingAIFormation");
static_assert(sizeof(OrionCharAISpawner_NotifyPendingAIFormation) == 0x000008, "Wrong size on OrionCharAISpawner_NotifyPendingAIFormation");
static_assert(offsetof(OrionCharAISpawner_NotifyPendingAIFormation, InFormationData) == 0x000000, "Member 'OrionCharAISpawner_NotifyPendingAIFormation::InFormationData' has a wrong offset!");

// Function OrionGame.OrionCharAISpawner.OnAIFormationSpawned
// 0x0008 (0x0008 - 0x0000)
struct OrionCharAISpawner_OnAIFormationSpawned final
{
public:
	class UOrionAIFormation*                      NewFormation;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAISpawner_OnAIFormationSpawned) == 0x000008, "Wrong alignment on OrionCharAISpawner_OnAIFormationSpawned");
static_assert(sizeof(OrionCharAISpawner_OnAIFormationSpawned) == 0x000008, "Wrong size on OrionCharAISpawner_OnAIFormationSpawned");
static_assert(offsetof(OrionCharAISpawner_OnAIFormationSpawned, NewFormation) == 0x000000, "Member 'OrionCharAISpawner_OnAIFormationSpawned::NewFormation' has a wrong offset!");

// Function OrionGame.OrionCharAISpawner.OnIntroSpawnForAI
// 0x0008 (0x0008 - 0x0000)
struct OrionCharAISpawner_OnIntroSpawnForAI final
{
public:
	class AOrionCharAI*                           SpawnedAI;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAISpawner_OnIntroSpawnForAI) == 0x000008, "Wrong alignment on OrionCharAISpawner_OnIntroSpawnForAI");
static_assert(sizeof(OrionCharAISpawner_OnIntroSpawnForAI) == 0x000008, "Wrong size on OrionCharAISpawner_OnIntroSpawnForAI");
static_assert(offsetof(OrionCharAISpawner_OnIntroSpawnForAI, SpawnedAI) == 0x000000, "Member 'OrionCharAISpawner_OnIntroSpawnForAI::SpawnedAI' has a wrong offset!");

// Function OrionGame.OrionCharAISpawner.OnPostRemovedAI
// 0x0008 (0x0008 - 0x0000)
struct OrionCharAISpawner_OnPostRemovedAI final
{
public:
	class AOrionCharAI*                           RemovedAI;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAISpawner_OnPostRemovedAI) == 0x000008, "Wrong alignment on OrionCharAISpawner_OnPostRemovedAI");
static_assert(sizeof(OrionCharAISpawner_OnPostRemovedAI) == 0x000008, "Wrong size on OrionCharAISpawner_OnPostRemovedAI");
static_assert(offsetof(OrionCharAISpawner_OnPostRemovedAI, RemovedAI) == 0x000000, "Member 'OrionCharAISpawner_OnPostRemovedAI::RemovedAI' has a wrong offset!");

// Function OrionGame.OrionCharAISpawner.OnPostSpawnedAI
// 0x0008 (0x0008 - 0x0000)
struct OrionCharAISpawner_OnPostSpawnedAI final
{
public:
	class AOrionCharAI*                           SpawnedAI;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAISpawner_OnPostSpawnedAI) == 0x000008, "Wrong alignment on OrionCharAISpawner_OnPostSpawnedAI");
static_assert(sizeof(OrionCharAISpawner_OnPostSpawnedAI) == 0x000008, "Wrong size on OrionCharAISpawner_OnPostSpawnedAI");
static_assert(offsetof(OrionCharAISpawner_OnPostSpawnedAI, SpawnedAI) == 0x000000, "Member 'OrionCharAISpawner_OnPostSpawnedAI::SpawnedAI' has a wrong offset!");

// Function OrionGame.OrionCharAISpawner.OnPreSpawnAI
// 0x0008 (0x0008 - 0x0000)
struct OrionCharAISpawner_OnPreSpawnAI final
{
public:
	class UOrionAIData*                           InAIData;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAISpawner_OnPreSpawnAI) == 0x000008, "Wrong alignment on OrionCharAISpawner_OnPreSpawnAI");
static_assert(sizeof(OrionCharAISpawner_OnPreSpawnAI) == 0x000008, "Wrong size on OrionCharAISpawner_OnPreSpawnAI");
static_assert(offsetof(OrionCharAISpawner_OnPreSpawnAI, InAIData) == 0x000000, "Member 'OrionCharAISpawner_OnPreSpawnAI::InAIData' has a wrong offset!");

// Function OrionGame.OrionCharAISpawner.OnRep_CurrentBuffTypeTag
// 0x0008 (0x0008 - 0x0000)
struct OrionCharAISpawner_OnRep_CurrentBuffTypeTag final
{
public:
	struct FGameplayTag                           OldColor;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAISpawner_OnRep_CurrentBuffTypeTag) == 0x000008, "Wrong alignment on OrionCharAISpawner_OnRep_CurrentBuffTypeTag");
static_assert(sizeof(OrionCharAISpawner_OnRep_CurrentBuffTypeTag) == 0x000008, "Wrong size on OrionCharAISpawner_OnRep_CurrentBuffTypeTag");
static_assert(offsetof(OrionCharAISpawner_OnRep_CurrentBuffTypeTag, OldColor) == 0x000000, "Member 'OrionCharAISpawner_OnRep_CurrentBuffTypeTag::OldColor' has a wrong offset!");

// Function OrionGame.OrionCharAISpawner.OnReplenishWaveTimerStart
// 0x0018 (0x0018 - 0x0000)
struct OrionCharAISpawner_OnReplenishWaveTimerStart final
{
public:
	float                                         InReplenishDelayTimer;                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AController*                            Killer;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAISpawner_OnReplenishWaveTimerStart) == 0x000008, "Wrong alignment on OrionCharAISpawner_OnReplenishWaveTimerStart");
static_assert(sizeof(OrionCharAISpawner_OnReplenishWaveTimerStart) == 0x000018, "Wrong size on OrionCharAISpawner_OnReplenishWaveTimerStart");
static_assert(offsetof(OrionCharAISpawner_OnReplenishWaveTimerStart, InReplenishDelayTimer) == 0x000000, "Member 'OrionCharAISpawner_OnReplenishWaveTimerStart::InReplenishDelayTimer' has a wrong offset!");
static_assert(offsetof(OrionCharAISpawner_OnReplenishWaveTimerStart, Killer) == 0x000008, "Member 'OrionCharAISpawner_OnReplenishWaveTimerStart::Killer' has a wrong offset!");
static_assert(offsetof(OrionCharAISpawner_OnReplenishWaveTimerStart, DamageCauser) == 0x000010, "Member 'OrionCharAISpawner_OnReplenishWaveTimerStart::DamageCauser' has a wrong offset!");

// Function OrionGame.OrionCharAISpawner.OnSpawnerBuffTypeChanged
// 0x0010 (0x0010 - 0x0000)
struct OrionCharAISpawner_OnSpawnerBuffTypeChanged final
{
public:
	struct FGameplayTag                           NewColorTag;                                       // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    TeamChanged;                                       // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionCharAISpawner_OnSpawnerBuffTypeChanged) == 0x000008, "Wrong alignment on OrionCharAISpawner_OnSpawnerBuffTypeChanged");
static_assert(sizeof(OrionCharAISpawner_OnSpawnerBuffTypeChanged) == 0x000010, "Wrong size on OrionCharAISpawner_OnSpawnerBuffTypeChanged");
static_assert(offsetof(OrionCharAISpawner_OnSpawnerBuffTypeChanged, NewColorTag) == 0x000000, "Member 'OrionCharAISpawner_OnSpawnerBuffTypeChanged::NewColorTag' has a wrong offset!");
static_assert(offsetof(OrionCharAISpawner_OnSpawnerBuffTypeChanged, TeamChanged) == 0x000008, "Member 'OrionCharAISpawner_OnSpawnerBuffTypeChanged::TeamChanged' has a wrong offset!");

// Function OrionGame.OrionCharAISpawner.RemoveAggroEffectForHero
// 0x0008 (0x0008 - 0x0000)
struct OrionCharAISpawner_RemoveAggroEffectForHero final
{
public:
	class AActor*                                 Hero;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAISpawner_RemoveAggroEffectForHero) == 0x000008, "Wrong alignment on OrionCharAISpawner_RemoveAggroEffectForHero");
static_assert(sizeof(OrionCharAISpawner_RemoveAggroEffectForHero) == 0x000008, "Wrong size on OrionCharAISpawner_RemoveAggroEffectForHero");
static_assert(offsetof(OrionCharAISpawner_RemoveAggroEffectForHero, Hero) == 0x000000, "Member 'OrionCharAISpawner_RemoveAggroEffectForHero::Hero' has a wrong offset!");

// Function OrionGame.OrionCharAISpawner.SelectSpawnLocation
// 0x0018 (0x0018 - 0x0000)
struct OrionCharAISpawner_SelectSpawnLocation final
{
public:
	struct FVector                                OutLocation;                                       // 0x0000(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               OutRotation;                                       // 0x000C(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAISpawner_SelectSpawnLocation) == 0x000004, "Wrong alignment on OrionCharAISpawner_SelectSpawnLocation");
static_assert(sizeof(OrionCharAISpawner_SelectSpawnLocation) == 0x000018, "Wrong size on OrionCharAISpawner_SelectSpawnLocation");
static_assert(offsetof(OrionCharAISpawner_SelectSpawnLocation, OutLocation) == 0x000000, "Member 'OrionCharAISpawner_SelectSpawnLocation::OutLocation' has a wrong offset!");
static_assert(offsetof(OrionCharAISpawner_SelectSpawnLocation, OutRotation) == 0x00000C, "Member 'OrionCharAISpawner_SelectSpawnLocation::OutRotation' has a wrong offset!");

// Function OrionGame.OrionCharAISpawner.SendAggroManagerMessage
// 0x0010 (0x0010 - 0x0000)
struct OrionCharAISpawner_SendAggroManagerMessage final
{
public:
	EAIMessageFromSpawner                         MESSAGE;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 MessageInstigator;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAISpawner_SendAggroManagerMessage) == 0x000008, "Wrong alignment on OrionCharAISpawner_SendAggroManagerMessage");
static_assert(sizeof(OrionCharAISpawner_SendAggroManagerMessage) == 0x000010, "Wrong size on OrionCharAISpawner_SendAggroManagerMessage");
static_assert(offsetof(OrionCharAISpawner_SendAggroManagerMessage, MESSAGE) == 0x000000, "Member 'OrionCharAISpawner_SendAggroManagerMessage::MESSAGE' has a wrong offset!");
static_assert(offsetof(OrionCharAISpawner_SendAggroManagerMessage, MessageInstigator) == 0x000008, "Member 'OrionCharAISpawner_SendAggroManagerMessage::MessageInstigator' has a wrong offset!");

// Function OrionGame.OrionCharAISpawner.SetSpawnerType
// 0x0001 (0x0001 - 0x0000)
struct OrionCharAISpawner_SetSpawnerType final
{
public:
	EOrionCharAISpawnerType                       InType;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAISpawner_SetSpawnerType) == 0x000001, "Wrong alignment on OrionCharAISpawner_SetSpawnerType");
static_assert(sizeof(OrionCharAISpawner_SetSpawnerType) == 0x000001, "Wrong size on OrionCharAISpawner_SetSpawnerType");
static_assert(offsetof(OrionCharAISpawner_SetSpawnerType, InType) == 0x000000, "Member 'OrionCharAISpawner_SetSpawnerType::InType' has a wrong offset!");

// Function OrionGame.OrionCharAISpawner.SpawnAI
// 0x0010 (0x0010 - 0x0000)
struct OrionCharAISpawner_SpawnAI final
{
public:
	class UOrionAIData*                           InAIData;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionCharAI*                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAISpawner_SpawnAI) == 0x000008, "Wrong alignment on OrionCharAISpawner_SpawnAI");
static_assert(sizeof(OrionCharAISpawner_SpawnAI) == 0x000010, "Wrong size on OrionCharAISpawner_SpawnAI");
static_assert(offsetof(OrionCharAISpawner_SpawnAI, InAIData) == 0x000000, "Member 'OrionCharAISpawner_SpawnAI::InAIData' has a wrong offset!");
static_assert(offsetof(OrionCharAISpawner_SpawnAI, ReturnValue) == 0x000008, "Member 'OrionCharAISpawner_SpawnAI::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharAISpawner.StartSpawningNextAIFormation
// 0x0008 (0x0008 - 0x0000)
struct OrionCharAISpawner_StartSpawningNextAIFormation final
{
public:
	const class UOrionAIFormationData*            InFormationData;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAISpawner_StartSpawningNextAIFormation) == 0x000008, "Wrong alignment on OrionCharAISpawner_StartSpawningNextAIFormation");
static_assert(sizeof(OrionCharAISpawner_StartSpawningNextAIFormation) == 0x000008, "Wrong size on OrionCharAISpawner_StartSpawningNextAIFormation");
static_assert(offsetof(OrionCharAISpawner_StartSpawningNextAIFormation, InFormationData) == 0x000000, "Member 'OrionCharAISpawner_StartSpawningNextAIFormation::InFormationData' has a wrong offset!");

// Function OrionGame.OrionCharAISpawner.GetAggroManagerHeroesInRange
// 0x0010 (0x0010 - 0x0000)
struct OrionCharAISpawner_GetAggroManagerHeroesInRange final
{
public:
	TArray<class AOrionChar*>                     HeroesInRange;                                     // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAISpawner_GetAggroManagerHeroesInRange) == 0x000008, "Wrong alignment on OrionCharAISpawner_GetAggroManagerHeroesInRange");
static_assert(sizeof(OrionCharAISpawner_GetAggroManagerHeroesInRange) == 0x000010, "Wrong size on OrionCharAISpawner_GetAggroManagerHeroesInRange");
static_assert(offsetof(OrionCharAISpawner_GetAggroManagerHeroesInRange, HeroesInRange) == 0x000000, "Member 'OrionCharAISpawner_GetAggroManagerHeroesInRange::HeroesInRange' has a wrong offset!");

// Function OrionGame.OrionCharAISpawner.GetAggroManagerHeroesWithAggro
// 0x0010 (0x0010 - 0x0000)
struct OrionCharAISpawner_GetAggroManagerHeroesWithAggro final
{
public:
	TArray<class AOrionChar*>                     HeroesWithAggro;                                   // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAISpawner_GetAggroManagerHeroesWithAggro) == 0x000008, "Wrong alignment on OrionCharAISpawner_GetAggroManagerHeroesWithAggro");
static_assert(sizeof(OrionCharAISpawner_GetAggroManagerHeroesWithAggro) == 0x000010, "Wrong size on OrionCharAISpawner_GetAggroManagerHeroesWithAggro");
static_assert(offsetof(OrionCharAISpawner_GetAggroManagerHeroesWithAggro, HeroesWithAggro) == 0x000000, "Member 'OrionCharAISpawner_GetAggroManagerHeroesWithAggro::HeroesWithAggro' has a wrong offset!");

// Function OrionGame.OrionCharAISpawner.GetAggroManagerSpawnedList
// 0x0010 (0x0010 - 0x0000)
struct OrionCharAISpawner_GetAggroManagerSpawnedList final
{
public:
	TArray<class AOrionCharAI*>                   SpawnedPawns;                                      // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAISpawner_GetAggroManagerSpawnedList) == 0x000008, "Wrong alignment on OrionCharAISpawner_GetAggroManagerSpawnedList");
static_assert(sizeof(OrionCharAISpawner_GetAggroManagerSpawnedList) == 0x000010, "Wrong size on OrionCharAISpawner_GetAggroManagerSpawnedList");
static_assert(offsetof(OrionCharAISpawner_GetAggroManagerSpawnedList, SpawnedPawns) == 0x000000, "Member 'OrionCharAISpawner_GetAggroManagerSpawnedList::SpawnedPawns' has a wrong offset!");

// Function OrionGame.OrionCharAISpawner.IsAggroManagerStateInCombat
// 0x0001 (0x0001 - 0x0000)
struct OrionCharAISpawner_IsAggroManagerStateInCombat final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAISpawner_IsAggroManagerStateInCombat) == 0x000001, "Wrong alignment on OrionCharAISpawner_IsAggroManagerStateInCombat");
static_assert(sizeof(OrionCharAISpawner_IsAggroManagerStateInCombat) == 0x000001, "Wrong size on OrionCharAISpawner_IsAggroManagerStateInCombat");
static_assert(offsetof(OrionCharAISpawner_IsAggroManagerStateInCombat, ReturnValue) == 0x000000, "Member 'OrionCharAISpawner_IsAggroManagerStateInCombat::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharAISpawner.IsAggroManagerStateResetting
// 0x0001 (0x0001 - 0x0000)
struct OrionCharAISpawner_IsAggroManagerStateResetting final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAISpawner_IsAggroManagerStateResetting) == 0x000001, "Wrong alignment on OrionCharAISpawner_IsAggroManagerStateResetting");
static_assert(sizeof(OrionCharAISpawner_IsAggroManagerStateResetting) == 0x000001, "Wrong size on OrionCharAISpawner_IsAggroManagerStateResetting");
static_assert(offsetof(OrionCharAISpawner_IsAggroManagerStateResetting, ReturnValue) == 0x000000, "Member 'OrionCharAISpawner_IsAggroManagerStateResetting::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharAISpawner.IsAggroManagerStateRespawning
// 0x0001 (0x0001 - 0x0000)
struct OrionCharAISpawner_IsAggroManagerStateRespawning final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAISpawner_IsAggroManagerStateRespawning) == 0x000001, "Wrong alignment on OrionCharAISpawner_IsAggroManagerStateRespawning");
static_assert(sizeof(OrionCharAISpawner_IsAggroManagerStateRespawning) == 0x000001, "Wrong size on OrionCharAISpawner_IsAggroManagerStateRespawning");
static_assert(offsetof(OrionCharAISpawner_IsAggroManagerStateRespawning, ReturnValue) == 0x000000, "Member 'OrionCharAISpawner_IsAggroManagerStateRespawning::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionAIPerceptionSystem.HandleCallForHelp
// 0x02A8 (0x02A8 - 0x0000)
struct OrionAIPerceptionSystem_HandleCallForHelp final
{
public:
	class AActor*                                 DamagedActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 AttackingActor;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpec                    EffectSpec;                                        // 0x0010(0x0298)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAIPerceptionSystem_HandleCallForHelp) == 0x000008, "Wrong alignment on OrionAIPerceptionSystem_HandleCallForHelp");
static_assert(sizeof(OrionAIPerceptionSystem_HandleCallForHelp) == 0x0002A8, "Wrong size on OrionAIPerceptionSystem_HandleCallForHelp");
static_assert(offsetof(OrionAIPerceptionSystem_HandleCallForHelp, DamagedActor) == 0x000000, "Member 'OrionAIPerceptionSystem_HandleCallForHelp::DamagedActor' has a wrong offset!");
static_assert(offsetof(OrionAIPerceptionSystem_HandleCallForHelp, AttackingActor) == 0x000008, "Member 'OrionAIPerceptionSystem_HandleCallForHelp::AttackingActor' has a wrong offset!");
static_assert(offsetof(OrionAIPerceptionSystem_HandleCallForHelp, EffectSpec) == 0x000010, "Member 'OrionAIPerceptionSystem_HandleCallForHelp::EffectSpec' has a wrong offset!");

// Function OrionGame.OrionChar.ApplyAlternateAppearance
// 0x0010 (0x0010 - 0x0000)
struct OrionChar_ApplyAlternateAppearance final
{
public:
	class UMaterialInterface*                     Material;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableShadowCasting;                             // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionChar_ApplyAlternateAppearance) == 0x000008, "Wrong alignment on OrionChar_ApplyAlternateAppearance");
static_assert(sizeof(OrionChar_ApplyAlternateAppearance) == 0x000010, "Wrong size on OrionChar_ApplyAlternateAppearance");
static_assert(offsetof(OrionChar_ApplyAlternateAppearance, Material) == 0x000000, "Member 'OrionChar_ApplyAlternateAppearance::Material' has a wrong offset!");
static_assert(offsetof(OrionChar_ApplyAlternateAppearance, bDisableShadowCasting) == 0x000008, "Member 'OrionChar_ApplyAlternateAppearance::bDisableShadowCasting' has a wrong offset!");

// Function OrionGame.OrionChar.ChangeLocalStatus
// 0x0002 (0x0002 - 0x0000)
struct OrionChar_ChangeLocalStatus final
{
public:
	EOrionCharLocalStatusTypes                    OrionCharLocalStatusType;                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetTo;                                            // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionChar_ChangeLocalStatus) == 0x000001, "Wrong alignment on OrionChar_ChangeLocalStatus");
static_assert(sizeof(OrionChar_ChangeLocalStatus) == 0x000002, "Wrong size on OrionChar_ChangeLocalStatus");
static_assert(offsetof(OrionChar_ChangeLocalStatus, OrionCharLocalStatusType) == 0x000000, "Member 'OrionChar_ChangeLocalStatus::OrionCharLocalStatusType' has a wrong offset!");
static_assert(offsetof(OrionChar_ChangeLocalStatus, bSetTo) == 0x000001, "Member 'OrionChar_ChangeLocalStatus::bSetTo' has a wrong offset!");

// Function OrionGame.OrionChar.CustomMatch_RemoveOnDeath
// 0x0540 (0x0540 - 0x0000)
struct OrionChar_CustomMatch_RemoveOnDeath final
{
public:
	struct FActiveGameplayEffect                  Effect;                                            // 0x0000(0x0530)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0530(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_531[0xF];                                      // 0x0531(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionChar_CustomMatch_RemoveOnDeath) == 0x000010, "Wrong alignment on OrionChar_CustomMatch_RemoveOnDeath");
static_assert(sizeof(OrionChar_CustomMatch_RemoveOnDeath) == 0x000540, "Wrong size on OrionChar_CustomMatch_RemoveOnDeath");
static_assert(offsetof(OrionChar_CustomMatch_RemoveOnDeath, Effect) == 0x000000, "Member 'OrionChar_CustomMatch_RemoveOnDeath::Effect' has a wrong offset!");
static_assert(offsetof(OrionChar_CustomMatch_RemoveOnDeath, ReturnValue) == 0x000530, "Member 'OrionChar_CustomMatch_RemoveOnDeath::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionChar.GetCurrentTargetIsLocalHero
// 0x0001 (0x0001 - 0x0000)
struct OrionChar_GetCurrentTargetIsLocalHero final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionChar_GetCurrentTargetIsLocalHero) == 0x000001, "Wrong alignment on OrionChar_GetCurrentTargetIsLocalHero");
static_assert(sizeof(OrionChar_GetCurrentTargetIsLocalHero) == 0x000001, "Wrong size on OrionChar_GetCurrentTargetIsLocalHero");
static_assert(offsetof(OrionChar_GetCurrentTargetIsLocalHero, ReturnValue) == 0x000000, "Member 'OrionChar_GetCurrentTargetIsLocalHero::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionChar.GetEstimatedCXPBounty
// 0x0004 (0x0004 - 0x0000)
struct OrionChar_GetEstimatedCXPBounty final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionChar_GetEstimatedCXPBounty) == 0x000004, "Wrong alignment on OrionChar_GetEstimatedCXPBounty");
static_assert(sizeof(OrionChar_GetEstimatedCXPBounty) == 0x000004, "Wrong size on OrionChar_GetEstimatedCXPBounty");
static_assert(offsetof(OrionChar_GetEstimatedCXPBounty, ReturnValue) == 0x000000, "Member 'OrionChar_GetEstimatedCXPBounty::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionChar.GetLocalStatus
// 0x0002 (0x0002 - 0x0000)
struct OrionChar_GetLocalStatus final
{
public:
	EOrionCharLocalStatusTypes                    OrionCharLocalStatusType;                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionChar_GetLocalStatus) == 0x000001, "Wrong alignment on OrionChar_GetLocalStatus");
static_assert(sizeof(OrionChar_GetLocalStatus) == 0x000002, "Wrong size on OrionChar_GetLocalStatus");
static_assert(offsetof(OrionChar_GetLocalStatus, OrionCharLocalStatusType) == 0x000000, "Member 'OrionChar_GetLocalStatus::OrionCharLocalStatusType' has a wrong offset!");
static_assert(offsetof(OrionChar_GetLocalStatus, ReturnValue) == 0x000001, "Member 'OrionChar_GetLocalStatus::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionChar.IsInShadowPlane
// 0x0001 (0x0001 - 0x0000)
struct OrionChar_IsInShadowPlane final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionChar_IsInShadowPlane) == 0x000001, "Wrong alignment on OrionChar_IsInShadowPlane");
static_assert(sizeof(OrionChar_IsInShadowPlane) == 0x000001, "Wrong size on OrionChar_IsInShadowPlane");
static_assert(offsetof(OrionChar_IsInShadowPlane, ReturnValue) == 0x000000, "Member 'OrionChar_IsInShadowPlane::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionChar.IsSuspended
// 0x0001 (0x0001 - 0x0000)
struct OrionChar_IsSuspended final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionChar_IsSuspended) == 0x000001, "Wrong alignment on OrionChar_IsSuspended");
static_assert(sizeof(OrionChar_IsSuspended) == 0x000001, "Wrong size on OrionChar_IsSuspended");
static_assert(offsetof(OrionChar_IsSuspended, ReturnValue) == 0x000000, "Member 'OrionChar_IsSuspended::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionChar.IsWorldDirectionABackPedalAnimation
// 0x0010 (0x0010 - 0x0000)
struct OrionChar_IsWorldDirectionABackPedalAnimation final
{
public:
	struct FVector                                InWorldDirectionVector;                            // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionChar_IsWorldDirectionABackPedalAnimation) == 0x000004, "Wrong alignment on OrionChar_IsWorldDirectionABackPedalAnimation");
static_assert(sizeof(OrionChar_IsWorldDirectionABackPedalAnimation) == 0x000010, "Wrong size on OrionChar_IsWorldDirectionABackPedalAnimation");
static_assert(offsetof(OrionChar_IsWorldDirectionABackPedalAnimation, InWorldDirectionVector) == 0x000000, "Member 'OrionChar_IsWorldDirectionABackPedalAnimation::InWorldDirectionVector' has a wrong offset!");
static_assert(offsetof(OrionChar_IsWorldDirectionABackPedalAnimation, ReturnValue) == 0x00000C, "Member 'OrionChar_IsWorldDirectionABackPedalAnimation::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionChar.OnCustomHit
// 0x0090 (0x0090 - 0x0000)
struct OrionChar_OnCustomHit final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x0088)(Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EProjectileCustomHitResponseType              ProjectileCustomHitResponseType_0;                 // 0x0088(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Magnitude;                                         // 0x008C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionChar_OnCustomHit) == 0x000008, "Wrong alignment on OrionChar_OnCustomHit");
static_assert(sizeof(OrionChar_OnCustomHit) == 0x000090, "Wrong size on OrionChar_OnCustomHit");
static_assert(offsetof(OrionChar_OnCustomHit, Hit) == 0x000000, "Member 'OrionChar_OnCustomHit::Hit' has a wrong offset!");
static_assert(offsetof(OrionChar_OnCustomHit, ProjectileCustomHitResponseType_0) == 0x000088, "Member 'OrionChar_OnCustomHit::ProjectileCustomHitResponseType_0' has a wrong offset!");
static_assert(offsetof(OrionChar_OnCustomHit, Magnitude) == 0x00008C, "Member 'OrionChar_OnCustomHit::Magnitude' has a wrong offset!");

// Function OrionGame.OrionChar.OnMontageStarted
// 0x0008 (0x0008 - 0x0000)
struct OrionChar_OnMontageStarted final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionChar_OnMontageStarted) == 0x000008, "Wrong alignment on OrionChar_OnMontageStarted");
static_assert(sizeof(OrionChar_OnMontageStarted) == 0x000008, "Wrong size on OrionChar_OnMontageStarted");
static_assert(offsetof(OrionChar_OnMontageStarted, Montage) == 0x000000, "Member 'OrionChar_OnMontageStarted::Montage' has a wrong offset!");

// Function OrionGame.OrionChar.OnRep_ReplicatedVisionData
// 0x0004 (0x0004 - 0x0000)
struct OrionChar_OnRep_ReplicatedVisionData final
{
public:
	struct FOrionReplicatedVisionData             OldData;                                           // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionChar_OnRep_ReplicatedVisionData) == 0x000002, "Wrong alignment on OrionChar_OnRep_ReplicatedVisionData");
static_assert(sizeof(OrionChar_OnRep_ReplicatedVisionData) == 0x000004, "Wrong size on OrionChar_OnRep_ReplicatedVisionData");
static_assert(offsetof(OrionChar_OnRep_ReplicatedVisionData, OldData) == 0x000000, "Member 'OrionChar_OnRep_ReplicatedVisionData::OldData' has a wrong offset!");

// Function OrionGame.OrionChar.OnRep_VisibleToEnemy
// 0x0004 (0x0004 - 0x0000)
struct OrionChar_OnRep_VisibleToEnemy final
{
public:
	struct FOrionReplicatedVisibleToEnemy         OldValue;                                          // 0x0000(0x0004)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionChar_OnRep_VisibleToEnemy) == 0x000001, "Wrong alignment on OrionChar_OnRep_VisibleToEnemy");
static_assert(sizeof(OrionChar_OnRep_VisibleToEnemy) == 0x000004, "Wrong size on OrionChar_OnRep_VisibleToEnemy");
static_assert(offsetof(OrionChar_OnRep_VisibleToEnemy, OldValue) == 0x000000, "Member 'OrionChar_OnRep_VisibleToEnemy::OldValue' has a wrong offset!");

// Function OrionGame.OrionChar.PlaySoundOnActor
// 0x0018 (0x0018 - 0x0000)
struct OrionChar_PlaySoundOnActor final
{
public:
	class USoundBase*                             SoundToPlay;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttached;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopWhenAttachedToDestroyed;                      // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionChar_PlaySoundOnActor) == 0x000008, "Wrong alignment on OrionChar_PlaySoundOnActor");
static_assert(sizeof(OrionChar_PlaySoundOnActor) == 0x000018, "Wrong size on OrionChar_PlaySoundOnActor");
static_assert(offsetof(OrionChar_PlaySoundOnActor, SoundToPlay) == 0x000000, "Member 'OrionChar_PlaySoundOnActor::SoundToPlay' has a wrong offset!");
static_assert(offsetof(OrionChar_PlaySoundOnActor, bAttached) == 0x000008, "Member 'OrionChar_PlaySoundOnActor::bAttached' has a wrong offset!");
static_assert(offsetof(OrionChar_PlaySoundOnActor, bStopWhenAttachedToDestroyed) == 0x000009, "Member 'OrionChar_PlaySoundOnActor::bStopWhenAttachedToDestroyed' has a wrong offset!");
static_assert(offsetof(OrionChar_PlaySoundOnActor, ReturnValue) == 0x000010, "Member 'OrionChar_PlaySoundOnActor::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionChar.PlaySoundTeamAdjustedForSelf
// 0x0018 (0x0018 - 0x0000)
struct OrionChar_PlaySoundTeamAdjustedForSelf final
{
public:
	class USoundBase*                             SoundToPlay;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Attached;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopWhenAttachedToDestroyed;                      // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionChar_PlaySoundTeamAdjustedForSelf) == 0x000008, "Wrong alignment on OrionChar_PlaySoundTeamAdjustedForSelf");
static_assert(sizeof(OrionChar_PlaySoundTeamAdjustedForSelf) == 0x000018, "Wrong size on OrionChar_PlaySoundTeamAdjustedForSelf");
static_assert(offsetof(OrionChar_PlaySoundTeamAdjustedForSelf, SoundToPlay) == 0x000000, "Member 'OrionChar_PlaySoundTeamAdjustedForSelf::SoundToPlay' has a wrong offset!");
static_assert(offsetof(OrionChar_PlaySoundTeamAdjustedForSelf, Attached) == 0x000008, "Member 'OrionChar_PlaySoundTeamAdjustedForSelf::Attached' has a wrong offset!");
static_assert(offsetof(OrionChar_PlaySoundTeamAdjustedForSelf, bStopWhenAttachedToDestroyed) == 0x000009, "Member 'OrionChar_PlaySoundTeamAdjustedForSelf::bStopWhenAttachedToDestroyed' has a wrong offset!");
static_assert(offsetof(OrionChar_PlaySoundTeamAdjustedForSelf, ReturnValue) == 0x000010, "Member 'OrionChar_PlaySoundTeamAdjustedForSelf::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionChar.SetTargetingTagRequirements
// 0x0040 (0x0040 - 0x0000)
struct OrionChar_SetTargetingTagRequirements final
{
public:
	struct FGameplayTagRequirements               InTargetingTagRequirements;                        // 0x0000(0x0040)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionChar_SetTargetingTagRequirements) == 0x000008, "Wrong alignment on OrionChar_SetTargetingTagRequirements");
static_assert(sizeof(OrionChar_SetTargetingTagRequirements) == 0x000040, "Wrong size on OrionChar_SetTargetingTagRequirements");
static_assert(offsetof(OrionChar_SetTargetingTagRequirements, InTargetingTagRequirements) == 0x000000, "Member 'OrionChar_SetTargetingTagRequirements::InTargetingTagRequirements' has a wrong offset!");

// Function OrionGame.OrionChar.UpdateMultipleScalarParametersOnMaterials
// 0x0020 (0x0020 - 0x0000)
struct OrionChar_UpdateMultipleScalarParametersOnMaterials final
{
public:
	class USkeletalMeshComponent*                 Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParameterValue;                                    // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ParameterNames;                                    // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionChar_UpdateMultipleScalarParametersOnMaterials) == 0x000008, "Wrong alignment on OrionChar_UpdateMultipleScalarParametersOnMaterials");
static_assert(sizeof(OrionChar_UpdateMultipleScalarParametersOnMaterials) == 0x000020, "Wrong size on OrionChar_UpdateMultipleScalarParametersOnMaterials");
static_assert(offsetof(OrionChar_UpdateMultipleScalarParametersOnMaterials, Component) == 0x000000, "Member 'OrionChar_UpdateMultipleScalarParametersOnMaterials::Component' has a wrong offset!");
static_assert(offsetof(OrionChar_UpdateMultipleScalarParametersOnMaterials, ParameterValue) == 0x000008, "Member 'OrionChar_UpdateMultipleScalarParametersOnMaterials::ParameterValue' has a wrong offset!");
static_assert(offsetof(OrionChar_UpdateMultipleScalarParametersOnMaterials, ParameterNames) == 0x000010, "Member 'OrionChar_UpdateMultipleScalarParametersOnMaterials::ParameterNames' has a wrong offset!");

// Function OrionGame.OrionChar.UpdateMultipleVectorParametersOnMaterials
// 0x0028 (0x0028 - 0x0000)
struct OrionChar_UpdateMultipleVectorParametersOnMaterials final
{
public:
	class USkeletalMeshComponent*                 Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ParameterValue;                                    // 0x0008(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           ParameterNames;                                    // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionChar_UpdateMultipleVectorParametersOnMaterials) == 0x000008, "Wrong alignment on OrionChar_UpdateMultipleVectorParametersOnMaterials");
static_assert(sizeof(OrionChar_UpdateMultipleVectorParametersOnMaterials) == 0x000028, "Wrong size on OrionChar_UpdateMultipleVectorParametersOnMaterials");
static_assert(offsetof(OrionChar_UpdateMultipleVectorParametersOnMaterials, Component) == 0x000000, "Member 'OrionChar_UpdateMultipleVectorParametersOnMaterials::Component' has a wrong offset!");
static_assert(offsetof(OrionChar_UpdateMultipleVectorParametersOnMaterials, ParameterValue) == 0x000008, "Member 'OrionChar_UpdateMultipleVectorParametersOnMaterials::ParameterValue' has a wrong offset!");
static_assert(offsetof(OrionChar_UpdateMultipleVectorParametersOnMaterials, ParameterNames) == 0x000018, "Member 'OrionChar_UpdateMultipleVectorParametersOnMaterials::ParameterNames' has a wrong offset!");

// Function OrionGame.OrionChar.UpdateScalarParameterValueOnMaterials
// 0x0018 (0x0018 - 0x0000)
struct OrionChar_UpdateScalarParameterValueOnMaterials final
{
public:
	class USkeletalMeshComponent*                 Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParameterValue;                                    // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionChar_UpdateScalarParameterValueOnMaterials) == 0x000008, "Wrong alignment on OrionChar_UpdateScalarParameterValueOnMaterials");
static_assert(sizeof(OrionChar_UpdateScalarParameterValueOnMaterials) == 0x000018, "Wrong size on OrionChar_UpdateScalarParameterValueOnMaterials");
static_assert(offsetof(OrionChar_UpdateScalarParameterValueOnMaterials, Component) == 0x000000, "Member 'OrionChar_UpdateScalarParameterValueOnMaterials::Component' has a wrong offset!");
static_assert(offsetof(OrionChar_UpdateScalarParameterValueOnMaterials, ParameterName) == 0x000008, "Member 'OrionChar_UpdateScalarParameterValueOnMaterials::ParameterName' has a wrong offset!");
static_assert(offsetof(OrionChar_UpdateScalarParameterValueOnMaterials, ParameterValue) == 0x000010, "Member 'OrionChar_UpdateScalarParameterValueOnMaterials::ParameterValue' has a wrong offset!");

// Function OrionGame.OrionChar.UpdateVectorParameterValueOnMaterials
// 0x0020 (0x0020 - 0x0000)
struct OrionChar_UpdateVectorParameterValueOnMaterials final
{
public:
	class USkeletalMeshComponent*                 Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ParameterValue;                                    // 0x0010(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionChar_UpdateVectorParameterValueOnMaterials) == 0x000008, "Wrong alignment on OrionChar_UpdateVectorParameterValueOnMaterials");
static_assert(sizeof(OrionChar_UpdateVectorParameterValueOnMaterials) == 0x000020, "Wrong size on OrionChar_UpdateVectorParameterValueOnMaterials");
static_assert(offsetof(OrionChar_UpdateVectorParameterValueOnMaterials, Component) == 0x000000, "Member 'OrionChar_UpdateVectorParameterValueOnMaterials::Component' has a wrong offset!");
static_assert(offsetof(OrionChar_UpdateVectorParameterValueOnMaterials, ParameterName) == 0x000008, "Member 'OrionChar_UpdateVectorParameterValueOnMaterials::ParameterName' has a wrong offset!");
static_assert(offsetof(OrionChar_UpdateVectorParameterValueOnMaterials, ParameterValue) == 0x000010, "Member 'OrionChar_UpdateVectorParameterValueOnMaterials::ParameterValue' has a wrong offset!");

// Function OrionGame.OrionChar.GetHealth
// 0x0004 (0x0004 - 0x0000)
struct OrionChar_GetHealth final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionChar_GetHealth) == 0x000004, "Wrong alignment on OrionChar_GetHealth");
static_assert(sizeof(OrionChar_GetHealth) == 0x000004, "Wrong size on OrionChar_GetHealth");
static_assert(offsetof(OrionChar_GetHealth, ReturnValue) == 0x000000, "Member 'OrionChar_GetHealth::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionChar.GetHealthPercent
// 0x0004 (0x0004 - 0x0000)
struct OrionChar_GetHealthPercent final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionChar_GetHealthPercent) == 0x000004, "Wrong alignment on OrionChar_GetHealthPercent");
static_assert(sizeof(OrionChar_GetHealthPercent) == 0x000004, "Wrong size on OrionChar_GetHealthPercent");
static_assert(offsetof(OrionChar_GetHealthPercent, ReturnValue) == 0x000000, "Member 'OrionChar_GetHealthPercent::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionChar.GetHealthRegen
// 0x0004 (0x0004 - 0x0000)
struct OrionChar_GetHealthRegen final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionChar_GetHealthRegen) == 0x000004, "Wrong alignment on OrionChar_GetHealthRegen");
static_assert(sizeof(OrionChar_GetHealthRegen) == 0x000004, "Wrong size on OrionChar_GetHealthRegen");
static_assert(offsetof(OrionChar_GetHealthRegen, ReturnValue) == 0x000000, "Member 'OrionChar_GetHealthRegen::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionChar.GetMaxHealth
// 0x0004 (0x0004 - 0x0000)
struct OrionChar_GetMaxHealth final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionChar_GetMaxHealth) == 0x000004, "Wrong alignment on OrionChar_GetMaxHealth");
static_assert(sizeof(OrionChar_GetMaxHealth) == 0x000004, "Wrong size on OrionChar_GetMaxHealth");
static_assert(offsetof(OrionChar_GetMaxHealth, ReturnValue) == 0x000000, "Member 'OrionChar_GetMaxHealth::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionChar.GetTeamNum
// 0x0001 (0x0001 - 0x0000)
struct OrionChar_GetTeamNum final
{
public:
	EOrionTeam                                    ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionChar_GetTeamNum) == 0x000001, "Wrong alignment on OrionChar_GetTeamNum");
static_assert(sizeof(OrionChar_GetTeamNum) == 0x000001, "Wrong size on OrionChar_GetTeamNum");
static_assert(offsetof(OrionChar_GetTeamNum, ReturnValue) == 0x000000, "Member 'OrionChar_GetTeamNum::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionChar.GetTotalTimeToAttack
// 0x0004 (0x0004 - 0x0000)
struct OrionChar_GetTotalTimeToAttack final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionChar_GetTotalTimeToAttack) == 0x000004, "Wrong alignment on OrionChar_GetTotalTimeToAttack");
static_assert(sizeof(OrionChar_GetTotalTimeToAttack) == 0x000004, "Wrong size on OrionChar_GetTotalTimeToAttack");
static_assert(offsetof(OrionChar_GetTotalTimeToAttack, ReturnValue) == 0x000000, "Member 'OrionChar_GetTotalTimeToAttack::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionChar.IsAbilityUseDisabled
// 0x0001 (0x0001 - 0x0000)
struct OrionChar_IsAbilityUseDisabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionChar_IsAbilityUseDisabled) == 0x000001, "Wrong alignment on OrionChar_IsAbilityUseDisabled");
static_assert(sizeof(OrionChar_IsAbilityUseDisabled) == 0x000001, "Wrong size on OrionChar_IsAbilityUseDisabled");
static_assert(offsetof(OrionChar_IsAbilityUseDisabled, ReturnValue) == 0x000000, "Member 'OrionChar_IsAbilityUseDisabled::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionChar.IsBasicAttackDisabled
// 0x0001 (0x0001 - 0x0000)
struct OrionChar_IsBasicAttackDisabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionChar_IsBasicAttackDisabled) == 0x000001, "Wrong alignment on OrionChar_IsBasicAttackDisabled");
static_assert(sizeof(OrionChar_IsBasicAttackDisabled) == 0x000001, "Wrong size on OrionChar_IsBasicAttackDisabled");
static_assert(offsetof(OrionChar_IsBasicAttackDisabled, ReturnValue) == 0x000000, "Member 'OrionChar_IsBasicAttackDisabled::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionChar.IsJumpProvidingForce
// 0x0001 (0x0001 - 0x0000)
struct OrionChar_IsJumpProvidingForce final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionChar_IsJumpProvidingForce) == 0x000001, "Wrong alignment on OrionChar_IsJumpProvidingForce");
static_assert(sizeof(OrionChar_IsJumpProvidingForce) == 0x000001, "Wrong size on OrionChar_IsJumpProvidingForce");
static_assert(offsetof(OrionChar_IsJumpProvidingForce, ReturnValue) == 0x000000, "Member 'OrionChar_IsJumpProvidingForce::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionChar.IsMovementDisabled
// 0x0001 (0x0001 - 0x0000)
struct OrionChar_IsMovementDisabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionChar_IsMovementDisabled) == 0x000001, "Wrong alignment on OrionChar_IsMovementDisabled");
static_assert(sizeof(OrionChar_IsMovementDisabled) == 0x000001, "Wrong size on OrionChar_IsMovementDisabled");
static_assert(offsetof(OrionChar_IsMovementDisabled, ReturnValue) == 0x000000, "Member 'OrionChar_IsMovementDisabled::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionChar.IsSilenced
// 0x0001 (0x0001 - 0x0000)
struct OrionChar_IsSilenced final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionChar_IsSilenced) == 0x000001, "Wrong alignment on OrionChar_IsSilenced");
static_assert(sizeof(OrionChar_IsSilenced) == 0x000001, "Wrong size on OrionChar_IsSilenced");
static_assert(offsetof(OrionChar_IsSilenced, ReturnValue) == 0x000000, "Member 'OrionChar_IsSilenced::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharAI.ApplyGameplayEffectToSelf
// 0x0018 (0x0018 - 0x0000)
struct OrionCharAI_ApplyGameplayEffectToSelf final
{
public:
	class UGameplayEffect*                        GameplayEffect;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GameplayEffectLevel;                               // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            ReturnValue;                                       // 0x000C(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionCharAI_ApplyGameplayEffectToSelf) == 0x000008, "Wrong alignment on OrionCharAI_ApplyGameplayEffectToSelf");
static_assert(sizeof(OrionCharAI_ApplyGameplayEffectToSelf) == 0x000018, "Wrong size on OrionCharAI_ApplyGameplayEffectToSelf");
static_assert(offsetof(OrionCharAI_ApplyGameplayEffectToSelf, GameplayEffect) == 0x000000, "Member 'OrionCharAI_ApplyGameplayEffectToSelf::GameplayEffect' has a wrong offset!");
static_assert(offsetof(OrionCharAI_ApplyGameplayEffectToSelf, GameplayEffectLevel) == 0x000008, "Member 'OrionCharAI_ApplyGameplayEffectToSelf::GameplayEffectLevel' has a wrong offset!");
static_assert(offsetof(OrionCharAI_ApplyGameplayEffectToSelf, ReturnValue) == 0x00000C, "Member 'OrionCharAI_ApplyGameplayEffectToSelf::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharAI.CancelAnimation
// 0x0001 (0x0001 - 0x0000)
struct OrionCharAI_CancelAnimation final
{
public:
	EOrionMinionPrioritizedBehavior               Behavior;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAI_CancelAnimation) == 0x000001, "Wrong alignment on OrionCharAI_CancelAnimation");
static_assert(sizeof(OrionCharAI_CancelAnimation) == 0x000001, "Wrong size on OrionCharAI_CancelAnimation");
static_assert(offsetof(OrionCharAI_CancelAnimation, Behavior) == 0x000000, "Member 'OrionCharAI_CancelAnimation::Behavior' has a wrong offset!");

// Function OrionGame.OrionCharAI.GameplayCue_Damage
// 0x00C0 (0x00C0 - 0x0000)
struct OrionCharAI_GameplayCue_Damage final
{
public:
	EGameplayCueEvent                             EventType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayCueParameters                 Parameters;                                        // 0x0008(0x00B8)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAI_GameplayCue_Damage) == 0x000008, "Wrong alignment on OrionCharAI_GameplayCue_Damage");
static_assert(sizeof(OrionCharAI_GameplayCue_Damage) == 0x0000C0, "Wrong size on OrionCharAI_GameplayCue_Damage");
static_assert(offsetof(OrionCharAI_GameplayCue_Damage, EventType) == 0x000000, "Member 'OrionCharAI_GameplayCue_Damage::EventType' has a wrong offset!");
static_assert(offsetof(OrionCharAI_GameplayCue_Damage, Parameters) == 0x000008, "Member 'OrionCharAI_GameplayCue_Damage::Parameters' has a wrong offset!");

// Function OrionGame.OrionCharAI.GetCurrentTargetIsLocalHero
// 0x0001 (0x0001 - 0x0000)
struct OrionCharAI_GetCurrentTargetIsLocalHero final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAI_GetCurrentTargetIsLocalHero) == 0x000001, "Wrong alignment on OrionCharAI_GetCurrentTargetIsLocalHero");
static_assert(sizeof(OrionCharAI_GetCurrentTargetIsLocalHero) == 0x000001, "Wrong size on OrionCharAI_GetCurrentTargetIsLocalHero");
static_assert(offsetof(OrionCharAI_GetCurrentTargetIsLocalHero, ReturnValue) == 0x000000, "Member 'OrionCharAI_GetCurrentTargetIsLocalHero::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharAI.OnNewTargetAcquired
// 0x0008 (0x0008 - 0x0000)
struct OrionCharAI_OnNewTargetAcquired final
{
public:
	class AActor*                                 NewTarget;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAI_OnNewTargetAcquired) == 0x000008, "Wrong alignment on OrionCharAI_OnNewTargetAcquired");
static_assert(sizeof(OrionCharAI_OnNewTargetAcquired) == 0x000008, "Wrong size on OrionCharAI_OnNewTargetAcquired");
static_assert(offsetof(OrionCharAI_OnNewTargetAcquired, NewTarget) == 0x000000, "Member 'OrionCharAI_OnNewTargetAcquired::NewTarget' has a wrong offset!");

// Function OrionGame.OrionCharAI.OnRep_AIData
// 0x0008 (0x0008 - 0x0000)
struct OrionCharAI_OnRep_AIData final
{
public:
	const class UOrionAIData*                     OldAIData;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAI_OnRep_AIData) == 0x000008, "Wrong alignment on OrionCharAI_OnRep_AIData");
static_assert(sizeof(OrionCharAI_OnRep_AIData) == 0x000008, "Wrong size on OrionCharAI_OnRep_AIData");
static_assert(offsetof(OrionCharAI_OnRep_AIData, OldAIData) == 0x000000, "Member 'OrionCharAI_OnRep_AIData::OldAIData' has a wrong offset!");

// Function OrionGame.OrionCharAI.PlayHeroAggroAlert
// 0x0008 (0x0008 - 0x0000)
struct OrionCharAI_PlayHeroAggroAlert final
{
public:
	class AOrionCharHero*                         HeroTarget;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAI_PlayHeroAggroAlert) == 0x000008, "Wrong alignment on OrionCharAI_PlayHeroAggroAlert");
static_assert(sizeof(OrionCharAI_PlayHeroAggroAlert) == 0x000008, "Wrong size on OrionCharAI_PlayHeroAggroAlert");
static_assert(offsetof(OrionCharAI_PlayHeroAggroAlert, HeroTarget) == 0x000000, "Member 'OrionCharAI_PlayHeroAggroAlert::HeroTarget' has a wrong offset!");

// Function OrionGame.OrionCharAI.RequestAnimation
// 0x000C (0x000C - 0x0000)
struct OrionCharAI_RequestAnimation final
{
public:
	EOrionMinionPrioritizedBehavior               Behavior;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayIndex;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLooping;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionCharAI_RequestAnimation) == 0x000004, "Wrong alignment on OrionCharAI_RequestAnimation");
static_assert(sizeof(OrionCharAI_RequestAnimation) == 0x00000C, "Wrong size on OrionCharAI_RequestAnimation");
static_assert(offsetof(OrionCharAI_RequestAnimation, Behavior) == 0x000000, "Member 'OrionCharAI_RequestAnimation::Behavior' has a wrong offset!");
static_assert(offsetof(OrionCharAI_RequestAnimation, PlayIndex) == 0x000004, "Member 'OrionCharAI_RequestAnimation::PlayIndex' has a wrong offset!");
static_assert(offsetof(OrionCharAI_RequestAnimation, bLooping) == 0x000008, "Member 'OrionCharAI_RequestAnimation::bLooping' has a wrong offset!");

// Function OrionGame.OrionCharAI.SetUpMeshShadows
// 0x0008 (0x0008 - 0x0000)
struct OrionCharAI_SetUpMeshShadows final
{
public:
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAI_SetUpMeshShadows) == 0x000008, "Wrong alignment on OrionCharAI_SetUpMeshShadows");
static_assert(sizeof(OrionCharAI_SetUpMeshShadows) == 0x000008, "Wrong size on OrionCharAI_SetUpMeshShadows");
static_assert(offsetof(OrionCharAI_SetUpMeshShadows, SkeletalMeshComponent) == 0x000000, "Member 'OrionCharAI_SetUpMeshShadows::SkeletalMeshComponent' has a wrong offset!");

// Function OrionGame.OrionCharAI.GetExecuteHealthThreshold
// 0x0010 (0x0010 - 0x0000)
struct OrionCharAI_GetExecuteHealthThreshold final
{
public:
	class UOrionAbilitySystemComponent*           DamagerASC;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionCharAI_GetExecuteHealthThreshold) == 0x000008, "Wrong alignment on OrionCharAI_GetExecuteHealthThreshold");
static_assert(sizeof(OrionCharAI_GetExecuteHealthThreshold) == 0x000010, "Wrong size on OrionCharAI_GetExecuteHealthThreshold");
static_assert(offsetof(OrionCharAI_GetExecuteHealthThreshold, DamagerASC) == 0x000000, "Member 'OrionCharAI_GetExecuteHealthThreshold::DamagerASC' has a wrong offset!");
static_assert(offsetof(OrionCharAI_GetExecuteHealthThreshold, ReturnValue) == 0x000008, "Member 'OrionCharAI_GetExecuteHealthThreshold::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharAI_Minion.Debug_OverrideTeamVisuals
// 0x0001 (0x0001 - 0x0000)
struct OrionCharAI_Minion_Debug_OverrideTeamVisuals final
{
public:
	EOrionTeam                                    NewTeamVisuals;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAI_Minion_Debug_OverrideTeamVisuals) == 0x000001, "Wrong alignment on OrionCharAI_Minion_Debug_OverrideTeamVisuals");
static_assert(sizeof(OrionCharAI_Minion_Debug_OverrideTeamVisuals) == 0x000001, "Wrong size on OrionCharAI_Minion_Debug_OverrideTeamVisuals");
static_assert(offsetof(OrionCharAI_Minion_Debug_OverrideTeamVisuals, NewTeamVisuals) == 0x000000, "Member 'OrionCharAI_Minion_Debug_OverrideTeamVisuals::NewTeamVisuals' has a wrong offset!");

// Function OrionGame.OrionCharAI_Minion.MinionBeginOverlap
// 0x0010 (0x0010 - 0x0000)
struct OrionCharAI_Minion_MinionBeginOverlap final
{
public:
	class AActor*                                 SelfActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAI_Minion_MinionBeginOverlap) == 0x000008, "Wrong alignment on OrionCharAI_Minion_MinionBeginOverlap");
static_assert(sizeof(OrionCharAI_Minion_MinionBeginOverlap) == 0x000010, "Wrong size on OrionCharAI_Minion_MinionBeginOverlap");
static_assert(offsetof(OrionCharAI_Minion_MinionBeginOverlap, SelfActor) == 0x000000, "Member 'OrionCharAI_Minion_MinionBeginOverlap::SelfActor' has a wrong offset!");
static_assert(offsetof(OrionCharAI_Minion_MinionBeginOverlap, OtherActor) == 0x000008, "Member 'OrionCharAI_Minion_MinionBeginOverlap::OtherActor' has a wrong offset!");

// Function OrionGame.OrionCharAI_Minion.Native_DoMeleeAttack
// 0x0008 (0x0008 - 0x0000)
struct OrionCharAI_Minion_Native_DoMeleeAttack final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAI_Minion_Native_DoMeleeAttack) == 0x000008, "Wrong alignment on OrionCharAI_Minion_Native_DoMeleeAttack");
static_assert(sizeof(OrionCharAI_Minion_Native_DoMeleeAttack) == 0x000008, "Wrong size on OrionCharAI_Minion_Native_DoMeleeAttack");
static_assert(offsetof(OrionCharAI_Minion_Native_DoMeleeAttack, TargetActor) == 0x000000, "Member 'OrionCharAI_Minion_Native_DoMeleeAttack::TargetActor' has a wrong offset!");

// Function OrionGame.OrionCharAI_Minion.Native_DoRangedAttack
// 0x0008 (0x0008 - 0x0000)
struct OrionCharAI_Minion_Native_DoRangedAttack final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAI_Minion_Native_DoRangedAttack) == 0x000008, "Wrong alignment on OrionCharAI_Minion_Native_DoRangedAttack");
static_assert(sizeof(OrionCharAI_Minion_Native_DoRangedAttack) == 0x000008, "Wrong size on OrionCharAI_Minion_Native_DoRangedAttack");
static_assert(offsetof(OrionCharAI_Minion_Native_DoRangedAttack, TargetActor) == 0x000000, "Member 'OrionCharAI_Minion_Native_DoRangedAttack::TargetActor' has a wrong offset!");

// Function OrionGame.OrionCharAI_Minion.Native_MulticastDoRangedAttack
// 0x0010 (0x0010 - 0x0000)
struct OrionCharAI_Minion_Native_MulticastDoRangedAttack final
{
public:
	struct FOrionMinionAttackInfo                 RangedAttackInfo;                                  // 0x0000(0x0010)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAI_Minion_Native_MulticastDoRangedAttack) == 0x000008, "Wrong alignment on OrionCharAI_Minion_Native_MulticastDoRangedAttack");
static_assert(sizeof(OrionCharAI_Minion_Native_MulticastDoRangedAttack) == 0x000010, "Wrong size on OrionCharAI_Minion_Native_MulticastDoRangedAttack");
static_assert(offsetof(OrionCharAI_Minion_Native_MulticastDoRangedAttack, RangedAttackInfo) == 0x000000, "Member 'OrionCharAI_Minion_Native_MulticastDoRangedAttack::RangedAttackInfo' has a wrong offset!");

// Function OrionGame.OrionCharAI_Minion.OnPlayDeathAnim
// 0x0008 (0x0008 - 0x0000)
struct OrionCharAI_Minion_OnPlayDeathAnim final
{
public:
	float                                         PlaybackTime;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowedToRagdoll;                                 // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionCharAI_Minion_OnPlayDeathAnim) == 0x000004, "Wrong alignment on OrionCharAI_Minion_OnPlayDeathAnim");
static_assert(sizeof(OrionCharAI_Minion_OnPlayDeathAnim) == 0x000008, "Wrong size on OrionCharAI_Minion_OnPlayDeathAnim");
static_assert(offsetof(OrionCharAI_Minion_OnPlayDeathAnim, PlaybackTime) == 0x000000, "Member 'OrionCharAI_Minion_OnPlayDeathAnim::PlaybackTime' has a wrong offset!");
static_assert(offsetof(OrionCharAI_Minion_OnPlayDeathAnim, bAllowedToRagdoll) == 0x000004, "Member 'OrionCharAI_Minion_OnPlayDeathAnim::bAllowedToRagdoll' has a wrong offset!");

// Function OrionGame.OrionCharAI_Minion.RequestSelfDestruct
// 0x0004 (0x0004 - 0x0000)
struct OrionCharAI_Minion_RequestSelfDestruct final
{
public:
	float                                         Delay;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAI_Minion_RequestSelfDestruct) == 0x000004, "Wrong alignment on OrionCharAI_Minion_RequestSelfDestruct");
static_assert(sizeof(OrionCharAI_Minion_RequestSelfDestruct) == 0x000004, "Wrong size on OrionCharAI_Minion_RequestSelfDestruct");
static_assert(offsetof(OrionCharAI_Minion_RequestSelfDestruct, Delay) == 0x000000, "Member 'OrionCharAI_Minion_RequestSelfDestruct::Delay' has a wrong offset!");

// Function OrionGame.OrionAISystem.ConfigureAsBotOnlyGame
// 0x0008 (0x0008 - 0x0000)
struct OrionAISystem_ConfigureAsBotOnlyGame final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAISystem_ConfigureAsBotOnlyGame) == 0x000008, "Wrong alignment on OrionAISystem_ConfigureAsBotOnlyGame");
static_assert(sizeof(OrionAISystem_ConfigureAsBotOnlyGame) == 0x000008, "Wrong size on OrionAISystem_ConfigureAsBotOnlyGame");
static_assert(offsetof(OrionAISystem_ConfigureAsBotOnlyGame, WorldContextObject) == 0x000000, "Member 'OrionAISystem_ConfigureAsBotOnlyGame::WorldContextObject' has a wrong offset!");

// Function OrionGame.OrionAITask_FlowFieldMove.FlowFieldMove
// 0x0018 (0x0018 - 0x0000)
struct OrionAITask_FlowFieldMove_FlowFieldMove final
{
public:
	class AOrionAIController*                     Controller;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockAILogic;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAITask_FlowFieldMove*             ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAITask_FlowFieldMove_FlowFieldMove) == 0x000008, "Wrong alignment on OrionAITask_FlowFieldMove_FlowFieldMove");
static_assert(sizeof(OrionAITask_FlowFieldMove_FlowFieldMove) == 0x000018, "Wrong size on OrionAITask_FlowFieldMove_FlowFieldMove");
static_assert(offsetof(OrionAITask_FlowFieldMove_FlowFieldMove, Controller) == 0x000000, "Member 'OrionAITask_FlowFieldMove_FlowFieldMove::Controller' has a wrong offset!");
static_assert(offsetof(OrionAITask_FlowFieldMove_FlowFieldMove, bLockAILogic) == 0x000008, "Member 'OrionAITask_FlowFieldMove_FlowFieldMove::bLockAILogic' has a wrong offset!");
static_assert(offsetof(OrionAITask_FlowFieldMove_FlowFieldMove, ReturnValue) == 0x000010, "Member 'OrionAITask_FlowFieldMove_FlowFieldMove::ReturnValue' has a wrong offset!");

// DelegateFunction OrionGame.OrionAITask_FlowFieldMove.MoveTaskCompletedSignature__DelegateSignature
// 0x0001 (0x0001 - 0x0000)
struct OrionAITask_FlowFieldMove_MoveTaskCompletedSignature__DelegateSignature final
{
public:
	EPathFollowingResult                          Result;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAITask_FlowFieldMove_MoveTaskCompletedSignature__DelegateSignature) == 0x000001, "Wrong alignment on OrionAITask_FlowFieldMove_MoveTaskCompletedSignature__DelegateSignature");
static_assert(sizeof(OrionAITask_FlowFieldMove_MoveTaskCompletedSignature__DelegateSignature) == 0x000001, "Wrong size on OrionAITask_FlowFieldMove_MoveTaskCompletedSignature__DelegateSignature");
static_assert(offsetof(OrionAITask_FlowFieldMove_MoveTaskCompletedSignature__DelegateSignature, Result) == 0x000000, "Member 'OrionAITask_FlowFieldMove_MoveTaskCompletedSignature__DelegateSignature::Result' has a wrong offset!");

// Function OrionGame.OrionAITask_MoveTo.OrionGraphAIMoveTo
// 0x0030 (0x0030 - 0x0000)
struct OrionAITask_MoveTo_OrionGraphAIMoveTo final
{
public:
	class AAIController*                          Controller;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GoalLocation;                                      // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 GoalActor;                                         // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AcceptanceRadius;                                  // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIOptionFlag                                 StopOnOverlap;                                     // 0x0024(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIOptionFlag                                 AcceptPartialPath;                                 // 0x0025(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UAITask_MoveTo*                         ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAITask_MoveTo_OrionGraphAIMoveTo) == 0x000008, "Wrong alignment on OrionAITask_MoveTo_OrionGraphAIMoveTo");
static_assert(sizeof(OrionAITask_MoveTo_OrionGraphAIMoveTo) == 0x000030, "Wrong size on OrionAITask_MoveTo_OrionGraphAIMoveTo");
static_assert(offsetof(OrionAITask_MoveTo_OrionGraphAIMoveTo, Controller) == 0x000000, "Member 'OrionAITask_MoveTo_OrionGraphAIMoveTo::Controller' has a wrong offset!");
static_assert(offsetof(OrionAITask_MoveTo_OrionGraphAIMoveTo, GoalLocation) == 0x000008, "Member 'OrionAITask_MoveTo_OrionGraphAIMoveTo::GoalLocation' has a wrong offset!");
static_assert(offsetof(OrionAITask_MoveTo_OrionGraphAIMoveTo, GoalActor) == 0x000018, "Member 'OrionAITask_MoveTo_OrionGraphAIMoveTo::GoalActor' has a wrong offset!");
static_assert(offsetof(OrionAITask_MoveTo_OrionGraphAIMoveTo, AcceptanceRadius) == 0x000020, "Member 'OrionAITask_MoveTo_OrionGraphAIMoveTo::AcceptanceRadius' has a wrong offset!");
static_assert(offsetof(OrionAITask_MoveTo_OrionGraphAIMoveTo, StopOnOverlap) == 0x000024, "Member 'OrionAITask_MoveTo_OrionGraphAIMoveTo::StopOnOverlap' has a wrong offset!");
static_assert(offsetof(OrionAITask_MoveTo_OrionGraphAIMoveTo, AcceptPartialPath) == 0x000025, "Member 'OrionAITask_MoveTo_OrionGraphAIMoveTo::AcceptPartialPath' has a wrong offset!");
static_assert(offsetof(OrionAITask_MoveTo_OrionGraphAIMoveTo, ReturnValue) == 0x000028, "Member 'OrionAITask_MoveTo_OrionGraphAIMoveTo::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionStoreDisplayLibrary.GetStorefrontDisplayInfo
// 0x0040 (0x0040 - 0x0000)
struct OrionStoreDisplayLibrary_GetStorefrontDisplayInfo final
{
public:
	EOrionStoreFront                              Storefront;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionStorefrontInfo                   StorefrontInfo;                                    // 0x0008(0x0038)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionStoreDisplayLibrary_GetStorefrontDisplayInfo) == 0x000008, "Wrong alignment on OrionStoreDisplayLibrary_GetStorefrontDisplayInfo");
static_assert(sizeof(OrionStoreDisplayLibrary_GetStorefrontDisplayInfo) == 0x000040, "Wrong size on OrionStoreDisplayLibrary_GetStorefrontDisplayInfo");
static_assert(offsetof(OrionStoreDisplayLibrary_GetStorefrontDisplayInfo, Storefront) == 0x000000, "Member 'OrionStoreDisplayLibrary_GetStorefrontDisplayInfo::Storefront' has a wrong offset!");
static_assert(offsetof(OrionStoreDisplayLibrary_GetStorefrontDisplayInfo, StorefrontInfo) == 0x000008, "Member 'OrionStoreDisplayLibrary_GetStorefrontDisplayInfo::StorefrontInfo' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.AddAfkPeriod
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerGame_AddAfkPeriod final
{
public:
	int32                                         NewAfkPeriod;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_AddAfkPeriod) == 0x000004, "Wrong alignment on OrionCheatManagerGame_AddAfkPeriod");
static_assert(sizeof(OrionCheatManagerGame_AddAfkPeriod) == 0x000004, "Wrong size on OrionCheatManagerGame_AddAfkPeriod");
static_assert(offsetof(OrionCheatManagerGame_AddAfkPeriod, NewAfkPeriod) == 0x000000, "Member 'OrionCheatManagerGame_AddAfkPeriod::NewAfkPeriod' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.AddBotEnemy
// 0x0010 (0x0010 - 0x0000)
struct OrionCheatManagerGame_AddBotEnemy final
{
public:
	class FString                                 DataAssetName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_AddBotEnemy) == 0x000008, "Wrong alignment on OrionCheatManagerGame_AddBotEnemy");
static_assert(sizeof(OrionCheatManagerGame_AddBotEnemy) == 0x000010, "Wrong size on OrionCheatManagerGame_AddBotEnemy");
static_assert(offsetof(OrionCheatManagerGame_AddBotEnemy, DataAssetName) == 0x000000, "Member 'OrionCheatManagerGame_AddBotEnemy::DataAssetName' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.AddBotFriend
// 0x0010 (0x0010 - 0x0000)
struct OrionCheatManagerGame_AddBotFriend final
{
public:
	class FString                                 DataAssetName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_AddBotFriend) == 0x000008, "Wrong alignment on OrionCheatManagerGame_AddBotFriend");
static_assert(sizeof(OrionCheatManagerGame_AddBotFriend) == 0x000010, "Wrong size on OrionCheatManagerGame_AddBotFriend");
static_assert(offsetof(OrionCheatManagerGame_AddBotFriend, DataAssetName) == 0x000000, "Member 'OrionCheatManagerGame_AddBotFriend::DataAssetName' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.AddTag
// 0x0010 (0x0010 - 0x0000)
struct OrionCheatManagerGame_AddTag final
{
public:
	class FString                                 TagName;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_AddTag) == 0x000008, "Wrong alignment on OrionCheatManagerGame_AddTag");
static_assert(sizeof(OrionCheatManagerGame_AddTag) == 0x000010, "Wrong size on OrionCheatManagerGame_AddTag");
static_assert(offsetof(OrionCheatManagerGame_AddTag, TagName) == 0x000000, "Member 'OrionCheatManagerGame_AddTag::TagName' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.AllowCardMenuAnywhere
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerGame_AllowCardMenuAnywhere final
{
public:
	int32                                         Enable;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_AllowCardMenuAnywhere) == 0x000004, "Wrong alignment on OrionCheatManagerGame_AllowCardMenuAnywhere");
static_assert(sizeof(OrionCheatManagerGame_AllowCardMenuAnywhere) == 0x000004, "Wrong size on OrionCheatManagerGame_AllowCardMenuAnywhere");
static_assert(offsetof(OrionCheatManagerGame_AllowCardMenuAnywhere, Enable) == 0x000000, "Member 'OrionCheatManagerGame_AllowCardMenuAnywhere::Enable' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.ApplyGameplayEffectToCharacter
// 0x0028 (0x0028 - 0x0000)
struct OrionCheatManagerGame_ApplyGameplayEffectToCharacter final
{
public:
	class FString                                 CharacterObjectName;                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameplayEffectName;                                // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Level;                                             // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionCheatManagerGame_ApplyGameplayEffectToCharacter) == 0x000008, "Wrong alignment on OrionCheatManagerGame_ApplyGameplayEffectToCharacter");
static_assert(sizeof(OrionCheatManagerGame_ApplyGameplayEffectToCharacter) == 0x000028, "Wrong size on OrionCheatManagerGame_ApplyGameplayEffectToCharacter");
static_assert(offsetof(OrionCheatManagerGame_ApplyGameplayEffectToCharacter, CharacterObjectName) == 0x000000, "Member 'OrionCheatManagerGame_ApplyGameplayEffectToCharacter::CharacterObjectName' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_ApplyGameplayEffectToCharacter, GameplayEffectName) == 0x000010, "Member 'OrionCheatManagerGame_ApplyGameplayEffectToCharacter::GameplayEffectName' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_ApplyGameplayEffectToCharacter, Level) == 0x000020, "Member 'OrionCheatManagerGame_ApplyGameplayEffectToCharacter::Level' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.ApplyGameplayEffectToSelf
// 0x0018 (0x0018 - 0x0000)
struct OrionCheatManagerGame_ApplyGameplayEffectToSelf final
{
public:
	class FString                                 GameplayEffectName;                                // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Level;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionCheatManagerGame_ApplyGameplayEffectToSelf) == 0x000008, "Wrong alignment on OrionCheatManagerGame_ApplyGameplayEffectToSelf");
static_assert(sizeof(OrionCheatManagerGame_ApplyGameplayEffectToSelf) == 0x000018, "Wrong size on OrionCheatManagerGame_ApplyGameplayEffectToSelf");
static_assert(offsetof(OrionCheatManagerGame_ApplyGameplayEffectToSelf, GameplayEffectName) == 0x000000, "Member 'OrionCheatManagerGame_ApplyGameplayEffectToSelf::GameplayEffectName' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_ApplyGameplayEffectToSelf, Level) == 0x000010, "Member 'OrionCheatManagerGame_ApplyGameplayEffectToSelf::Level' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.BadAss
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerGame_BadAss final
{
public:
	int32                                         State;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_BadAss) == 0x000004, "Wrong alignment on OrionCheatManagerGame_BadAss");
static_assert(sizeof(OrionCheatManagerGame_BadAss) == 0x000004, "Wrong size on OrionCheatManagerGame_BadAss");
static_assert(offsetof(OrionCheatManagerGame_BadAss, State) == 0x000000, "Member 'OrionCheatManagerGame_BadAss::State' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.CoreUnlimitedHealth
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerGame_CoreUnlimitedHealth final
{
public:
	int32                                         State;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_CoreUnlimitedHealth) == 0x000004, "Wrong alignment on OrionCheatManagerGame_CoreUnlimitedHealth");
static_assert(sizeof(OrionCheatManagerGame_CoreUnlimitedHealth) == 0x000004, "Wrong size on OrionCheatManagerGame_CoreUnlimitedHealth");
static_assert(offsetof(OrionCheatManagerGame_CoreUnlimitedHealth, State) == 0x000000, "Member 'OrionCheatManagerGame_CoreUnlimitedHealth::State' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.DamageSelf
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerGame_DamageSelf final
{
public:
	float                                         DamageAmount;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_DamageSelf) == 0x000004, "Wrong alignment on OrionCheatManagerGame_DamageSelf");
static_assert(sizeof(OrionCheatManagerGame_DamageSelf) == 0x000004, "Wrong size on OrionCheatManagerGame_DamageSelf");
static_assert(offsetof(OrionCheatManagerGame_DamageSelf, DamageAmount) == 0x000000, "Member 'OrionCheatManagerGame_DamageSelf::DamageAmount' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.DisableRework
// 0x0010 (0x0010 - 0x0000)
struct OrionCheatManagerGame_DisableRework final
{
public:
	class FString                                 HeroName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_DisableRework) == 0x000008, "Wrong alignment on OrionCheatManagerGame_DisableRework");
static_assert(sizeof(OrionCheatManagerGame_DisableRework) == 0x000010, "Wrong size on OrionCheatManagerGame_DisableRework");
static_assert(offsetof(OrionCheatManagerGame_DisableRework, HeroName) == 0x000000, "Member 'OrionCheatManagerGame_DisableRework::HeroName' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.DrawDamageNumbers
// 0x0001 (0x0001 - 0x0000)
struct OrionCheatManagerGame_DrawDamageNumbers final
{
public:
	bool                                          bDrawNumbers;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_DrawDamageNumbers) == 0x000001, "Wrong alignment on OrionCheatManagerGame_DrawDamageNumbers");
static_assert(sizeof(OrionCheatManagerGame_DrawDamageNumbers) == 0x000001, "Wrong size on OrionCheatManagerGame_DrawDamageNumbers");
static_assert(offsetof(OrionCheatManagerGame_DrawDamageNumbers, bDrawNumbers) == 0x000000, "Member 'OrionCheatManagerGame_DrawDamageNumbers::bDrawNumbers' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.DumpGameStats
// 0x0010 (0x0010 - 0x0000)
struct OrionCheatManagerGame_DumpGameStats final
{
public:
	class FString                                 FilterName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_DumpGameStats) == 0x000008, "Wrong alignment on OrionCheatManagerGame_DumpGameStats");
static_assert(sizeof(OrionCheatManagerGame_DumpGameStats) == 0x000010, "Wrong size on OrionCheatManagerGame_DumpGameStats");
static_assert(offsetof(OrionCheatManagerGame_DumpGameStats, FilterName) == 0x000000, "Member 'OrionCheatManagerGame_DumpGameStats::FilterName' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.EnableFixedTimeStep
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerGame_EnableFixedTimeStep final
{
public:
	int32                                         AsIfItWasFPS;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_EnableFixedTimeStep) == 0x000004, "Wrong alignment on OrionCheatManagerGame_EnableFixedTimeStep");
static_assert(sizeof(OrionCheatManagerGame_EnableFixedTimeStep) == 0x000004, "Wrong size on OrionCheatManagerGame_EnableFixedTimeStep");
static_assert(offsetof(OrionCheatManagerGame_EnableFixedTimeStep, AsIfItWasFPS) == 0x000000, "Member 'OrionCheatManagerGame_EnableFixedTimeStep::AsIfItWasFPS' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.EnableRework
// 0x0010 (0x0010 - 0x0000)
struct OrionCheatManagerGame_EnableRework final
{
public:
	class FString                                 HeroName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_EnableRework) == 0x000008, "Wrong alignment on OrionCheatManagerGame_EnableRework");
static_assert(sizeof(OrionCheatManagerGame_EnableRework) == 0x000010, "Wrong size on OrionCheatManagerGame_EnableRework");
static_assert(offsetof(OrionCheatManagerGame_EnableRework, HeroName) == 0x000000, "Member 'OrionCheatManagerGame_EnableRework::HeroName' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.EndSurrenderVoteTimer
// 0x0001 (0x0001 - 0x0000)
struct OrionCheatManagerGame_EndSurrenderVoteTimer final
{
public:
	uint8                                         TeamNum;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_EndSurrenderVoteTimer) == 0x000001, "Wrong alignment on OrionCheatManagerGame_EndSurrenderVoteTimer");
static_assert(sizeof(OrionCheatManagerGame_EndSurrenderVoteTimer) == 0x000001, "Wrong size on OrionCheatManagerGame_EndSurrenderVoteTimer");
static_assert(offsetof(OrionCheatManagerGame_EndSurrenderVoteTimer, TeamNum) == 0x000000, "Member 'OrionCheatManagerGame_EndSurrenderVoteTimer::TeamNum' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.ExecuteOrionDevMenuHistory
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerGame_ExecuteOrionDevMenuHistory final
{
public:
	int32                                         Idx;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_ExecuteOrionDevMenuHistory) == 0x000004, "Wrong alignment on OrionCheatManagerGame_ExecuteOrionDevMenuHistory");
static_assert(sizeof(OrionCheatManagerGame_ExecuteOrionDevMenuHistory) == 0x000004, "Wrong size on OrionCheatManagerGame_ExecuteOrionDevMenuHistory");
static_assert(offsetof(OrionCheatManagerGame_ExecuteOrionDevMenuHistory, Idx) == 0x000000, "Member 'OrionCheatManagerGame_ExecuteOrionDevMenuHistory::Idx' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.FillWithBots
// 0x0018 (0x0018 - 0x0000)
struct OrionCheatManagerGame_FillWithBots final
{
public:
	int32                                         BotsToAddToEachTeam;                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 HeroList;                                          // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_FillWithBots) == 0x000008, "Wrong alignment on OrionCheatManagerGame_FillWithBots");
static_assert(sizeof(OrionCheatManagerGame_FillWithBots) == 0x000018, "Wrong size on OrionCheatManagerGame_FillWithBots");
static_assert(offsetof(OrionCheatManagerGame_FillWithBots, BotsToAddToEachTeam) == 0x000000, "Member 'OrionCheatManagerGame_FillWithBots::BotsToAddToEachTeam' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_FillWithBots, HeroList) == 0x000008, "Member 'OrionCheatManagerGame_FillWithBots::HeroList' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.ForceAISpawnerStartingLevelTo
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerGame_ForceAISpawnerStartingLevelTo final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_ForceAISpawnerStartingLevelTo) == 0x000004, "Wrong alignment on OrionCheatManagerGame_ForceAISpawnerStartingLevelTo");
static_assert(sizeof(OrionCheatManagerGame_ForceAISpawnerStartingLevelTo) == 0x000004, "Wrong size on OrionCheatManagerGame_ForceAISpawnerStartingLevelTo");
static_assert(offsetof(OrionCheatManagerGame_ForceAISpawnerStartingLevelTo, Level) == 0x000000, "Member 'OrionCheatManagerGame_ForceAISpawnerStartingLevelTo::Level' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.ForceAllPlayersToLevel
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerGame_ForceAllPlayersToLevel final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_ForceAllPlayersToLevel) == 0x000004, "Wrong alignment on OrionCheatManagerGame_ForceAllPlayersToLevel");
static_assert(sizeof(OrionCheatManagerGame_ForceAllPlayersToLevel) == 0x000004, "Wrong size on OrionCheatManagerGame_ForceAllPlayersToLevel");
static_assert(offsetof(OrionCheatManagerGame_ForceAllPlayersToLevel, Level) == 0x000000, "Member 'OrionCheatManagerGame_ForceAllPlayersToLevel::Level' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.ForceBotDifficulty
// 0x0010 (0x0010 - 0x0000)
struct OrionCheatManagerGame_ForceBotDifficulty final
{
public:
	class FString                                 DifficultyName;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_ForceBotDifficulty) == 0x000008, "Wrong alignment on OrionCheatManagerGame_ForceBotDifficulty");
static_assert(sizeof(OrionCheatManagerGame_ForceBotDifficulty) == 0x000010, "Wrong size on OrionCheatManagerGame_ForceBotDifficulty");
static_assert(offsetof(OrionCheatManagerGame_ForceBotDifficulty, DifficultyName) == 0x000000, "Member 'OrionCheatManagerGame_ForceBotDifficulty::DifficultyName' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.ForceBotLane
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerGame_ForceBotLane final
{
public:
	int32                                         LaneIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_ForceBotLane) == 0x000004, "Wrong alignment on OrionCheatManagerGame_ForceBotLane");
static_assert(sizeof(OrionCheatManagerGame_ForceBotLane) == 0x000004, "Wrong size on OrionCheatManagerGame_ForceBotLane");
static_assert(offsetof(OrionCheatManagerGame_ForceBotLane, LaneIndex) == 0x000000, "Member 'OrionCheatManagerGame_ForceBotLane::LaneIndex' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.ForceEndgame
// 0x0008 (0x0008 - 0x0000)
struct OrionCheatManagerGame_ForceEndgame final
{
public:
	int32                                         TeamNumber;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MoveDoomedTeamSpawnPoints;                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_ForceEndgame) == 0x000004, "Wrong alignment on OrionCheatManagerGame_ForceEndgame");
static_assert(sizeof(OrionCheatManagerGame_ForceEndgame) == 0x000008, "Wrong size on OrionCheatManagerGame_ForceEndgame");
static_assert(offsetof(OrionCheatManagerGame_ForceEndgame, TeamNumber) == 0x000000, "Member 'OrionCheatManagerGame_ForceEndgame::TeamNumber' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_ForceEndgame, MoveDoomedTeamSpawnPoints) == 0x000004, "Member 'OrionCheatManagerGame_ForceEndgame::MoveDoomedTeamSpawnPoints' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.ForceEquipCard
// 0x0020 (0x0020 - 0x0000)
struct OrionCheatManagerGame_ForceEquipCard final
{
public:
	int32                                         Slot;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CardName;                                          // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CardLevel;                                         // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionCheatManagerGame_ForceEquipCard) == 0x000008, "Wrong alignment on OrionCheatManagerGame_ForceEquipCard");
static_assert(sizeof(OrionCheatManagerGame_ForceEquipCard) == 0x000020, "Wrong size on OrionCheatManagerGame_ForceEquipCard");
static_assert(offsetof(OrionCheatManagerGame_ForceEquipCard, Slot) == 0x000000, "Member 'OrionCheatManagerGame_ForceEquipCard::Slot' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_ForceEquipCard, CardName) == 0x000008, "Member 'OrionCheatManagerGame_ForceEquipCard::CardName' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_ForceEquipCard, CardLevel) == 0x000018, "Member 'OrionCheatManagerGame_ForceEquipCard::CardLevel' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.ForceEquipCardForAll
// 0x0020 (0x0020 - 0x0000)
struct OrionCheatManagerGame_ForceEquipCardForAll final
{
public:
	int32                                         Slot;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CardName;                                          // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CardLevel;                                         // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionCheatManagerGame_ForceEquipCardForAll) == 0x000008, "Wrong alignment on OrionCheatManagerGame_ForceEquipCardForAll");
static_assert(sizeof(OrionCheatManagerGame_ForceEquipCardForAll) == 0x000020, "Wrong size on OrionCheatManagerGame_ForceEquipCardForAll");
static_assert(offsetof(OrionCheatManagerGame_ForceEquipCardForAll, Slot) == 0x000000, "Member 'OrionCheatManagerGame_ForceEquipCardForAll::Slot' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_ForceEquipCardForAll, CardName) == 0x000008, "Member 'OrionCheatManagerGame_ForceEquipCardForAll::CardName' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_ForceEquipCardForAll, CardLevel) == 0x000018, "Member 'OrionCheatManagerGame_ForceEquipCardForAll::CardLevel' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.ForceRefineryFill
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerGame_ForceRefineryFill final
{
public:
	int32                                         Amount;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_ForceRefineryFill) == 0x000004, "Wrong alignment on OrionCheatManagerGame_ForceRefineryFill");
static_assert(sizeof(OrionCheatManagerGame_ForceRefineryFill) == 0x000004, "Wrong size on OrionCheatManagerGame_ForceRefineryFill");
static_assert(offsetof(OrionCheatManagerGame_ForceRefineryFill, Amount) == 0x000000, "Member 'OrionCheatManagerGame_ForceRefineryFill::Amount' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.ForceRefineryFillForTeam
// 0x0008 (0x0008 - 0x0000)
struct OrionCheatManagerGame_ForceRefineryFillForTeam final
{
public:
	int32                                         TeamNumber;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_ForceRefineryFillForTeam) == 0x000004, "Wrong alignment on OrionCheatManagerGame_ForceRefineryFillForTeam");
static_assert(sizeof(OrionCheatManagerGame_ForceRefineryFillForTeam) == 0x000008, "Wrong size on OrionCheatManagerGame_ForceRefineryFillForTeam");
static_assert(offsetof(OrionCheatManagerGame_ForceRefineryFillForTeam, TeamNumber) == 0x000000, "Member 'OrionCheatManagerGame_ForceRefineryFillForTeam::TeamNumber' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_ForceRefineryFillForTeam, Amount) == 0x000004, "Member 'OrionCheatManagerGame_ForceRefineryFillForTeam::Amount' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.ForceWinMatch
// 0x0008 (0x0008 - 0x0000)
struct OrionCheatManagerGame_ForceWinMatch final
{
public:
	uint8                                         WinningTeamNum;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumSeconds;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_ForceWinMatch) == 0x000004, "Wrong alignment on OrionCheatManagerGame_ForceWinMatch");
static_assert(sizeof(OrionCheatManagerGame_ForceWinMatch) == 0x000008, "Wrong size on OrionCheatManagerGame_ForceWinMatch");
static_assert(offsetof(OrionCheatManagerGame_ForceWinMatch, WinningTeamNum) == 0x000000, "Member 'OrionCheatManagerGame_ForceWinMatch::WinningTeamNum' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_ForceWinMatch, NumSeconds) == 0x000004, "Member 'OrionCheatManagerGame_ForceWinMatch::NumSeconds' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.GiveGold
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerGame_GiveGold final
{
public:
	int32                                         Gold;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_GiveGold) == 0x000004, "Wrong alignment on OrionCheatManagerGame_GiveGold");
static_assert(sizeof(OrionCheatManagerGame_GiveGold) == 0x000004, "Wrong size on OrionCheatManagerGame_GiveGold");
static_assert(offsetof(OrionCheatManagerGame_GiveGold, Gold) == 0x000000, "Member 'OrionCheatManagerGame_GiveGold::Gold' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.GiveTeamXP
// 0x0008 (0x0008 - 0x0000)
struct OrionCheatManagerGame_GiveTeamXP final
{
public:
	int32                                         TeamIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XP;                                                // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_GiveTeamXP) == 0x000004, "Wrong alignment on OrionCheatManagerGame_GiveTeamXP");
static_assert(sizeof(OrionCheatManagerGame_GiveTeamXP) == 0x000008, "Wrong size on OrionCheatManagerGame_GiveTeamXP");
static_assert(offsetof(OrionCheatManagerGame_GiveTeamXP, TeamIndex) == 0x000000, "Member 'OrionCheatManagerGame_GiveTeamXP::TeamIndex' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_GiveTeamXP, XP) == 0x000004, "Member 'OrionCheatManagerGame_GiveTeamXP::XP' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.GiveXP
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerGame_GiveXP final
{
public:
	int32                                         XP;                                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_GiveXP) == 0x000004, "Wrong alignment on OrionCheatManagerGame_GiveXP");
static_assert(sizeof(OrionCheatManagerGame_GiveXP) == 0x000004, "Wrong size on OrionCheatManagerGame_GiveXP");
static_assert(offsetof(OrionCheatManagerGame_GiveXP, XP) == 0x000000, "Member 'OrionCheatManagerGame_GiveXP::XP' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.HealSelf
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerGame_HealSelf final
{
public:
	float                                         HealAmount;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_HealSelf) == 0x000004, "Wrong alignment on OrionCheatManagerGame_HealSelf");
static_assert(sizeof(OrionCheatManagerGame_HealSelf) == 0x000004, "Wrong size on OrionCheatManagerGame_HealSelf");
static_assert(offsetof(OrionCheatManagerGame_HealSelf, HealAmount) == 0x000000, "Member 'OrionCheatManagerGame_HealSelf::HealAmount' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.KillAI
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerGame_KillAI final
{
public:
	int32                                         DisableAISpawning;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_KillAI) == 0x000004, "Wrong alignment on OrionCheatManagerGame_KillAI");
static_assert(sizeof(OrionCheatManagerGame_KillAI) == 0x000004, "Wrong size on OrionCheatManagerGame_KillAI");
static_assert(offsetof(OrionCheatManagerGame_KillAI, DisableAISpawning) == 0x000000, "Member 'OrionCheatManagerGame_KillAI::DisableAISpawning' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.KillTeamBots
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerGame_KillTeamBots final
{
public:
	int32                                         TeamIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_KillTeamBots) == 0x000004, "Wrong alignment on OrionCheatManagerGame_KillTeamBots");
static_assert(sizeof(OrionCheatManagerGame_KillTeamBots) == 0x000004, "Wrong size on OrionCheatManagerGame_KillTeamBots");
static_assert(offsetof(OrionCheatManagerGame_KillTeamBots, TeamIndex) == 0x000000, "Member 'OrionCheatManagerGame_KillTeamBots::TeamIndex' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.KnockbackSelf
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerGame_KnockbackSelf final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_KnockbackSelf) == 0x000004, "Wrong alignment on OrionCheatManagerGame_KnockbackSelf");
static_assert(sizeof(OrionCheatManagerGame_KnockbackSelf) == 0x000004, "Wrong size on OrionCheatManagerGame_KnockbackSelf");
static_assert(offsetof(OrionCheatManagerGame_KnockbackSelf, Distance) == 0x000000, "Member 'OrionCheatManagerGame_KnockbackSelf::Distance' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.KnockupSelf
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerGame_KnockupSelf final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_KnockupSelf) == 0x000004, "Wrong alignment on OrionCheatManagerGame_KnockupSelf");
static_assert(sizeof(OrionCheatManagerGame_KnockupSelf) == 0x000004, "Wrong size on OrionCheatManagerGame_KnockupSelf");
static_assert(offsetof(OrionCheatManagerGame_KnockupSelf, Distance) == 0x000000, "Member 'OrionCheatManagerGame_KnockupSelf::Distance' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.ModifyMaxMoveSpeed
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerGame_ModifyMaxMoveSpeed final
{
public:
	float                                         MoveAmount;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_ModifyMaxMoveSpeed) == 0x000004, "Wrong alignment on OrionCheatManagerGame_ModifyMaxMoveSpeed");
static_assert(sizeof(OrionCheatManagerGame_ModifyMaxMoveSpeed) == 0x000004, "Wrong size on OrionCheatManagerGame_ModifyMaxMoveSpeed");
static_assert(offsetof(OrionCheatManagerGame_ModifyMaxMoveSpeed, MoveAmount) == 0x000000, "Member 'OrionCheatManagerGame_ModifyMaxMoveSpeed::MoveAmount' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.PlayAmbientEventWithId
// 0x0010 (0x0010 - 0x0000)
struct OrionCheatManagerGame_PlayAmbientEventWithId final
{
public:
	class FString                                 EventID;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_PlayAmbientEventWithId) == 0x000008, "Wrong alignment on OrionCheatManagerGame_PlayAmbientEventWithId");
static_assert(sizeof(OrionCheatManagerGame_PlayAmbientEventWithId) == 0x000010, "Wrong size on OrionCheatManagerGame_PlayAmbientEventWithId");
static_assert(offsetof(OrionCheatManagerGame_PlayAmbientEventWithId, EventID) == 0x000000, "Member 'OrionCheatManagerGame_PlayAmbientEventWithId::EventID' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.RemoveCooldowns
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerGame_RemoveCooldowns final
{
public:
	int32                                         State;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_RemoveCooldowns) == 0x000004, "Wrong alignment on OrionCheatManagerGame_RemoveCooldowns");
static_assert(sizeof(OrionCheatManagerGame_RemoveCooldowns) == 0x000004, "Wrong size on OrionCheatManagerGame_RemoveCooldowns");
static_assert(offsetof(OrionCheatManagerGame_RemoveCooldowns, State) == 0x000000, "Member 'OrionCheatManagerGame_RemoveCooldowns::State' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.RemoveCosts
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerGame_RemoveCosts final
{
public:
	int32                                         State;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_RemoveCosts) == 0x000004, "Wrong alignment on OrionCheatManagerGame_RemoveCosts");
static_assert(sizeof(OrionCheatManagerGame_RemoveCosts) == 0x000004, "Wrong size on OrionCheatManagerGame_RemoveCosts");
static_assert(offsetof(OrionCheatManagerGame_RemoveCosts, State) == 0x000000, "Member 'OrionCheatManagerGame_RemoveCosts::State' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.RemoveGameplayEffectFromCharacter
// 0x0020 (0x0020 - 0x0000)
struct OrionCheatManagerGame_RemoveGameplayEffectFromCharacter final
{
public:
	class FString                                 CharacterObjectName;                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameplayEffectName;                                // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_RemoveGameplayEffectFromCharacter) == 0x000008, "Wrong alignment on OrionCheatManagerGame_RemoveGameplayEffectFromCharacter");
static_assert(sizeof(OrionCheatManagerGame_RemoveGameplayEffectFromCharacter) == 0x000020, "Wrong size on OrionCheatManagerGame_RemoveGameplayEffectFromCharacter");
static_assert(offsetof(OrionCheatManagerGame_RemoveGameplayEffectFromCharacter, CharacterObjectName) == 0x000000, "Member 'OrionCheatManagerGame_RemoveGameplayEffectFromCharacter::CharacterObjectName' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_RemoveGameplayEffectFromCharacter, GameplayEffectName) == 0x000010, "Member 'OrionCheatManagerGame_RemoveGameplayEffectFromCharacter::GameplayEffectName' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.RemoveGameplayEffectFromSelf
// 0x0010 (0x0010 - 0x0000)
struct OrionCheatManagerGame_RemoveGameplayEffectFromSelf final
{
public:
	class FString                                 GameplayEffectName;                                // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_RemoveGameplayEffectFromSelf) == 0x000008, "Wrong alignment on OrionCheatManagerGame_RemoveGameplayEffectFromSelf");
static_assert(sizeof(OrionCheatManagerGame_RemoveGameplayEffectFromSelf) == 0x000010, "Wrong size on OrionCheatManagerGame_RemoveGameplayEffectFromSelf");
static_assert(offsetof(OrionCheatManagerGame_RemoveGameplayEffectFromSelf, GameplayEffectName) == 0x000000, "Member 'OrionCheatManagerGame_RemoveGameplayEffectFromSelf::GameplayEffectName' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.RemoveRespawnTime
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerGame_RemoveRespawnTime final
{
public:
	int32                                         State;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_RemoveRespawnTime) == 0x000004, "Wrong alignment on OrionCheatManagerGame_RemoveRespawnTime");
static_assert(sizeof(OrionCheatManagerGame_RemoveRespawnTime) == 0x000004, "Wrong size on OrionCheatManagerGame_RemoveRespawnTime");
static_assert(offsetof(OrionCheatManagerGame_RemoveRespawnTime, State) == 0x000000, "Member 'OrionCheatManagerGame_RemoveRespawnTime::State' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.RemoveRespawnTimeAll
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerGame_RemoveRespawnTimeAll final
{
public:
	int32                                         State;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_RemoveRespawnTimeAll) == 0x000004, "Wrong alignment on OrionCheatManagerGame_RemoveRespawnTimeAll");
static_assert(sizeof(OrionCheatManagerGame_RemoveRespawnTimeAll) == 0x000004, "Wrong size on OrionCheatManagerGame_RemoveRespawnTimeAll");
static_assert(offsetof(OrionCheatManagerGame_RemoveRespawnTimeAll, State) == 0x000000, "Member 'OrionCheatManagerGame_RemoveRespawnTimeAll::State' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.RemoveTag
// 0x0010 (0x0010 - 0x0000)
struct OrionCheatManagerGame_RemoveTag final
{
public:
	class FString                                 TagName;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_RemoveTag) == 0x000008, "Wrong alignment on OrionCheatManagerGame_RemoveTag");
static_assert(sizeof(OrionCheatManagerGame_RemoveTag) == 0x000010, "Wrong size on OrionCheatManagerGame_RemoveTag");
static_assert(offsetof(OrionCheatManagerGame_RemoveTag, TagName) == 0x000000, "Member 'OrionCheatManagerGame_RemoveTag::TagName' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.ResetSurrenderVoteCooldown
// 0x0001 (0x0001 - 0x0000)
struct OrionCheatManagerGame_ResetSurrenderVoteCooldown final
{
public:
	uint8                                         TeamNum;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_ResetSurrenderVoteCooldown) == 0x000001, "Wrong alignment on OrionCheatManagerGame_ResetSurrenderVoteCooldown");
static_assert(sizeof(OrionCheatManagerGame_ResetSurrenderVoteCooldown) == 0x000001, "Wrong size on OrionCheatManagerGame_ResetSurrenderVoteCooldown");
static_assert(offsetof(OrionCheatManagerGame_ResetSurrenderVoteCooldown, TeamNum) == 0x000000, "Member 'OrionCheatManagerGame_ResetSurrenderVoteCooldown::TeamNum' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SetAllAbilityLevels
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerGame_SetAllAbilityLevels final
{
public:
	int32                                         NewLevel;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_SetAllAbilityLevels) == 0x000004, "Wrong alignment on OrionCheatManagerGame_SetAllAbilityLevels");
static_assert(sizeof(OrionCheatManagerGame_SetAllAbilityLevels) == 0x000004, "Wrong size on OrionCheatManagerGame_SetAllAbilityLevels");
static_assert(offsetof(OrionCheatManagerGame_SetAllAbilityLevels, NewLevel) == 0x000000, "Member 'OrionCheatManagerGame_SetAllAbilityLevels::NewLevel' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SetAllMinionWaveData
// 0x0010 (0x0010 - 0x0000)
struct OrionCheatManagerGame_SetAllMinionWaveData final
{
public:
	class FString                                 DataAssetName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_SetAllMinionWaveData) == 0x000008, "Wrong alignment on OrionCheatManagerGame_SetAllMinionWaveData");
static_assert(sizeof(OrionCheatManagerGame_SetAllMinionWaveData) == 0x000010, "Wrong size on OrionCheatManagerGame_SetAllMinionWaveData");
static_assert(offsetof(OrionCheatManagerGame_SetAllMinionWaveData, DataAssetName) == 0x000000, "Member 'OrionCheatManagerGame_SetAllMinionWaveData::DataAssetName' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SetEnemyMinionWaveData
// 0x0010 (0x0010 - 0x0000)
struct OrionCheatManagerGame_SetEnemyMinionWaveData final
{
public:
	class FString                                 DataAssetName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_SetEnemyMinionWaveData) == 0x000008, "Wrong alignment on OrionCheatManagerGame_SetEnemyMinionWaveData");
static_assert(sizeof(OrionCheatManagerGame_SetEnemyMinionWaveData) == 0x000010, "Wrong size on OrionCheatManagerGame_SetEnemyMinionWaveData");
static_assert(offsetof(OrionCheatManagerGame_SetEnemyMinionWaveData, DataAssetName) == 0x000000, "Member 'OrionCheatManagerGame_SetEnemyMinionWaveData::DataAssetName' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SetEnergyPercent
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerGame_SetEnergyPercent final
{
public:
	float                                         NewPercent;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_SetEnergyPercent) == 0x000004, "Wrong alignment on OrionCheatManagerGame_SetEnergyPercent");
static_assert(sizeof(OrionCheatManagerGame_SetEnergyPercent) == 0x000004, "Wrong size on OrionCheatManagerGame_SetEnergyPercent");
static_assert(offsetof(OrionCheatManagerGame_SetEnergyPercent, NewPercent) == 0x000000, "Member 'OrionCheatManagerGame_SetEnergyPercent::NewPercent' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SetFriendlyMinionWaveData
// 0x0010 (0x0010 - 0x0000)
struct OrionCheatManagerGame_SetFriendlyMinionWaveData final
{
public:
	class FString                                 DataAssetName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_SetFriendlyMinionWaveData) == 0x000008, "Wrong alignment on OrionCheatManagerGame_SetFriendlyMinionWaveData");
static_assert(sizeof(OrionCheatManagerGame_SetFriendlyMinionWaveData) == 0x000010, "Wrong size on OrionCheatManagerGame_SetFriendlyMinionWaveData");
static_assert(offsetof(OrionCheatManagerGame_SetFriendlyMinionWaveData, DataAssetName) == 0x000000, "Member 'OrionCheatManagerGame_SetFriendlyMinionWaveData::DataAssetName' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SetHealthPercent
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerGame_SetHealthPercent final
{
public:
	float                                         NewPercent;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_SetHealthPercent) == 0x000004, "Wrong alignment on OrionCheatManagerGame_SetHealthPercent");
static_assert(sizeof(OrionCheatManagerGame_SetHealthPercent) == 0x000004, "Wrong size on OrionCheatManagerGame_SetHealthPercent");
static_assert(offsetof(OrionCheatManagerGame_SetHealthPercent, NewPercent) == 0x000000, "Member 'OrionCheatManagerGame_SetHealthPercent::NewPercent' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SetHero
// 0x0010 (0x0010 - 0x0000)
struct OrionCheatManagerGame_SetHero final
{
public:
	class FString                                 HeroName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_SetHero) == 0x000008, "Wrong alignment on OrionCheatManagerGame_SetHero");
static_assert(sizeof(OrionCheatManagerGame_SetHero) == 0x000010, "Wrong size on OrionCheatManagerGame_SetHero");
static_assert(offsetof(OrionCheatManagerGame_SetHero, HeroName) == 0x000000, "Member 'OrionCheatManagerGame_SetHero::HeroName' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SetHeroStat
// 0x0028 (0x0028 - 0x0000)
struct OrionCheatManagerGame_SetHeroStat final
{
public:
	class FString                                 HeroName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StatName;                                          // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionCheatManagerGame_SetHeroStat) == 0x000008, "Wrong alignment on OrionCheatManagerGame_SetHeroStat");
static_assert(sizeof(OrionCheatManagerGame_SetHeroStat) == 0x000028, "Wrong size on OrionCheatManagerGame_SetHeroStat");
static_assert(offsetof(OrionCheatManagerGame_SetHeroStat, HeroName) == 0x000000, "Member 'OrionCheatManagerGame_SetHeroStat::HeroName' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SetHeroStat, StatName) == 0x000010, "Member 'OrionCheatManagerGame_SetHeroStat::StatName' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SetHeroStat, Amount) == 0x000020, "Member 'OrionCheatManagerGame_SetHeroStat::Amount' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SetMinionTeamDifficulty
// 0x0018 (0x0018 - 0x0000)
struct OrionCheatManagerGame_SetMinionTeamDifficulty final
{
public:
	int32                                         TeamIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DifficultyName;                                    // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_SetMinionTeamDifficulty) == 0x000008, "Wrong alignment on OrionCheatManagerGame_SetMinionTeamDifficulty");
static_assert(sizeof(OrionCheatManagerGame_SetMinionTeamDifficulty) == 0x000018, "Wrong size on OrionCheatManagerGame_SetMinionTeamDifficulty");
static_assert(offsetof(OrionCheatManagerGame_SetMinionTeamDifficulty, TeamIndex) == 0x000000, "Member 'OrionCheatManagerGame_SetMinionTeamDifficulty::TeamIndex' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SetMinionTeamDifficulty, DifficultyName) == 0x000008, "Member 'OrionCheatManagerGame_SetMinionTeamDifficulty::DifficultyName' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SetMyAbilityLevels
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerGame_SetMyAbilityLevels final
{
public:
	int32                                         NewLevel;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_SetMyAbilityLevels) == 0x000004, "Wrong alignment on OrionCheatManagerGame_SetMyAbilityLevels");
static_assert(sizeof(OrionCheatManagerGame_SetMyAbilityLevels) == 0x000004, "Wrong size on OrionCheatManagerGame_SetMyAbilityLevels");
static_assert(offsetof(OrionCheatManagerGame_SetMyAbilityLevels, NewLevel) == 0x000000, "Member 'OrionCheatManagerGame_SetMyAbilityLevels::NewLevel' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SetPlayerDeckInstance
// 0x0010 (0x0010 - 0x0000)
struct OrionCheatManagerGame_SetPlayerDeckInstance final
{
public:
	class FString                                 DeckName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_SetPlayerDeckInstance) == 0x000008, "Wrong alignment on OrionCheatManagerGame_SetPlayerDeckInstance");
static_assert(sizeof(OrionCheatManagerGame_SetPlayerDeckInstance) == 0x000010, "Wrong size on OrionCheatManagerGame_SetPlayerDeckInstance");
static_assert(offsetof(OrionCheatManagerGame_SetPlayerDeckInstance, DeckName) == 0x000000, "Member 'OrionCheatManagerGame_SetPlayerDeckInstance::DeckName' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SetPlayerPosition
// 0x0001 (0x0001 - 0x0000)
struct OrionCheatManagerGame_SetPlayerPosition final
{
public:
	EOrionPosition                                Position;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_SetPlayerPosition) == 0x000001, "Wrong alignment on OrionCheatManagerGame_SetPlayerPosition");
static_assert(sizeof(OrionCheatManagerGame_SetPlayerPosition) == 0x000001, "Wrong size on OrionCheatManagerGame_SetPlayerPosition");
static_assert(offsetof(OrionCheatManagerGame_SetPlayerPosition, Position) == 0x000000, "Member 'OrionCheatManagerGame_SetPlayerPosition::Position' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SetPlayerStat
// 0x0018 (0x0018 - 0x0000)
struct OrionCheatManagerGame_SetPlayerStat final
{
public:
	class FString                                 StatName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionCheatManagerGame_SetPlayerStat) == 0x000008, "Wrong alignment on OrionCheatManagerGame_SetPlayerStat");
static_assert(sizeof(OrionCheatManagerGame_SetPlayerStat) == 0x000018, "Wrong size on OrionCheatManagerGame_SetPlayerStat");
static_assert(offsetof(OrionCheatManagerGame_SetPlayerStat, StatName) == 0x000000, "Member 'OrionCheatManagerGame_SetPlayerStat::StatName' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SetPlayerStat, Amount) == 0x000010, "Member 'OrionCheatManagerGame_SetPlayerStat::Amount' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SetShouldAbortMatchStartWhenPlayersMissing
// 0x0002 (0x0002 - 0x0000)
struct OrionCheatManagerGame_SetShouldAbortMatchStartWhenPlayersMissing final
{
public:
	bool                                          bShouldAbort;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldPenalize;                                   // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_SetShouldAbortMatchStartWhenPlayersMissing) == 0x000001, "Wrong alignment on OrionCheatManagerGame_SetShouldAbortMatchStartWhenPlayersMissing");
static_assert(sizeof(OrionCheatManagerGame_SetShouldAbortMatchStartWhenPlayersMissing) == 0x000002, "Wrong size on OrionCheatManagerGame_SetShouldAbortMatchStartWhenPlayersMissing");
static_assert(offsetof(OrionCheatManagerGame_SetShouldAbortMatchStartWhenPlayersMissing, bShouldAbort) == 0x000000, "Member 'OrionCheatManagerGame_SetShouldAbortMatchStartWhenPlayersMissing::bShouldAbort' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SetShouldAbortMatchStartWhenPlayersMissing, bShouldPenalize) == 0x000001, "Member 'OrionCheatManagerGame_SetShouldAbortMatchStartWhenPlayersMissing::bShouldPenalize' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SetTeamNum
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerGame_SetTeamNum final
{
public:
	int32                                         TeamIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_SetTeamNum) == 0x000004, "Wrong alignment on OrionCheatManagerGame_SetTeamNum");
static_assert(sizeof(OrionCheatManagerGame_SetTeamNum) == 0x000004, "Wrong size on OrionCheatManagerGame_SetTeamNum");
static_assert(offsetof(OrionCheatManagerGame_SetTeamNum, TeamIndex) == 0x000000, "Member 'OrionCheatManagerGame_SetTeamNum::TeamIndex' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SetVisionManagerDebug
// 0x000C (0x000C - 0x0000)
struct OrionCheatManagerGame_SetVisionManagerDebug final
{
public:
	uint8                                         DebugMode;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Filter;                                            // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FilterIndex;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SingleFilterType;                                  // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_SetVisionManagerDebug) == 0x000004, "Wrong alignment on OrionCheatManagerGame_SetVisionManagerDebug");
static_assert(sizeof(OrionCheatManagerGame_SetVisionManagerDebug) == 0x00000C, "Wrong size on OrionCheatManagerGame_SetVisionManagerDebug");
static_assert(offsetof(OrionCheatManagerGame_SetVisionManagerDebug, DebugMode) == 0x000000, "Member 'OrionCheatManagerGame_SetVisionManagerDebug::DebugMode' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SetVisionManagerDebug, Filter) == 0x000001, "Member 'OrionCheatManagerGame_SetVisionManagerDebug::Filter' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SetVisionManagerDebug, FilterIndex) == 0x000004, "Member 'OrionCheatManagerGame_SetVisionManagerDebug::FilterIndex' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SetVisionManagerDebug, SingleFilterType) == 0x000008, "Member 'OrionCheatManagerGame_SetVisionManagerDebug::SingleFilterType' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.ShieldSelf
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerGame_ShieldSelf final
{
public:
	float                                         ShieldAmount;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_ShieldSelf) == 0x000004, "Wrong alignment on OrionCheatManagerGame_ShieldSelf");
static_assert(sizeof(OrionCheatManagerGame_ShieldSelf) == 0x000004, "Wrong size on OrionCheatManagerGame_ShieldSelf");
static_assert(offsetof(OrionCheatManagerGame_ShieldSelf, ShieldAmount) == 0x000000, "Member 'OrionCheatManagerGame_ShieldSelf::ShieldAmount' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.ShowMatchInfoText
// 0x0010 (0x0010 - 0x0000)
struct OrionCheatManagerGame_ShowMatchInfoText final
{
public:
	class FString                                 Text;                                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_ShowMatchInfoText) == 0x000008, "Wrong alignment on OrionCheatManagerGame_ShowMatchInfoText");
static_assert(sizeof(OrionCheatManagerGame_ShowMatchInfoText) == 0x000010, "Wrong size on OrionCheatManagerGame_ShowMatchInfoText");
static_assert(offsetof(OrionCheatManagerGame_ShowMatchInfoText, Text) == 0x000000, "Member 'OrionCheatManagerGame_ShowMatchInfoText::Text' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SimulateCheatDetected
// 0x0018 (0x0018 - 0x0000)
struct OrionCheatManagerGame_SimulateCheatDetected final
{
public:
	bool                                          bRevokeAuthToken;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKickFromMatch;                                    // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReasonStr;                                         // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_SimulateCheatDetected) == 0x000008, "Wrong alignment on OrionCheatManagerGame_SimulateCheatDetected");
static_assert(sizeof(OrionCheatManagerGame_SimulateCheatDetected) == 0x000018, "Wrong size on OrionCheatManagerGame_SimulateCheatDetected");
static_assert(offsetof(OrionCheatManagerGame_SimulateCheatDetected, bRevokeAuthToken) == 0x000000, "Member 'OrionCheatManagerGame_SimulateCheatDetected::bRevokeAuthToken' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SimulateCheatDetected, bKickFromMatch) == 0x000001, "Member 'OrionCheatManagerGame_SimulateCheatDetected::bKickFromMatch' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SimulateCheatDetected, ReasonStr) == 0x000008, "Member 'OrionCheatManagerGame_SimulateCheatDetected::ReasonStr' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SpawnCreepMinion
// 0x0010 (0x0010 - 0x0000)
struct OrionCheatManagerGame_SpawnCreepMinion final
{
public:
	class FString                                 DataAssetName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_SpawnCreepMinion) == 0x000008, "Wrong alignment on OrionCheatManagerGame_SpawnCreepMinion");
static_assert(sizeof(OrionCheatManagerGame_SpawnCreepMinion) == 0x000010, "Wrong size on OrionCheatManagerGame_SpawnCreepMinion");
static_assert(offsetof(OrionCheatManagerGame_SpawnCreepMinion, DataAssetName) == 0x000000, "Member 'OrionCheatManagerGame_SpawnCreepMinion::DataAssetName' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SpawnCreepMinionAtPos
// 0x0020 (0x0020 - 0x0000)
struct OrionCheatManagerGame_SpawnCreepMinionAtPos final
{
public:
	class FString                                 DataAssetName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X;                                                 // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionCheatManagerGame_SpawnCreepMinionAtPos) == 0x000008, "Wrong alignment on OrionCheatManagerGame_SpawnCreepMinionAtPos");
static_assert(sizeof(OrionCheatManagerGame_SpawnCreepMinionAtPos) == 0x000020, "Wrong size on OrionCheatManagerGame_SpawnCreepMinionAtPos");
static_assert(offsetof(OrionCheatManagerGame_SpawnCreepMinionAtPos, DataAssetName) == 0x000000, "Member 'OrionCheatManagerGame_SpawnCreepMinionAtPos::DataAssetName' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnCreepMinionAtPos, X) == 0x000010, "Member 'OrionCheatManagerGame_SpawnCreepMinionAtPos::X' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnCreepMinionAtPos, Y) == 0x000014, "Member 'OrionCheatManagerGame_SpawnCreepMinionAtPos::Y' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnCreepMinionAtPos, Z) == 0x000018, "Member 'OrionCheatManagerGame_SpawnCreepMinionAtPos::Z' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SpawnCreepMinionAtPosAndRotation
// 0x0020 (0x0020 - 0x0000)
struct OrionCheatManagerGame_SpawnCreepMinionAtPosAndRotation final
{
public:
	class FString                                 DataAssetName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X;                                                 // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InVerticalRotation;                                // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_SpawnCreepMinionAtPosAndRotation) == 0x000008, "Wrong alignment on OrionCheatManagerGame_SpawnCreepMinionAtPosAndRotation");
static_assert(sizeof(OrionCheatManagerGame_SpawnCreepMinionAtPosAndRotation) == 0x000020, "Wrong size on OrionCheatManagerGame_SpawnCreepMinionAtPosAndRotation");
static_assert(offsetof(OrionCheatManagerGame_SpawnCreepMinionAtPosAndRotation, DataAssetName) == 0x000000, "Member 'OrionCheatManagerGame_SpawnCreepMinionAtPosAndRotation::DataAssetName' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnCreepMinionAtPosAndRotation, X) == 0x000010, "Member 'OrionCheatManagerGame_SpawnCreepMinionAtPosAndRotation::X' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnCreepMinionAtPosAndRotation, Y) == 0x000014, "Member 'OrionCheatManagerGame_SpawnCreepMinionAtPosAndRotation::Y' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnCreepMinionAtPosAndRotation, Z) == 0x000018, "Member 'OrionCheatManagerGame_SpawnCreepMinionAtPosAndRotation::Z' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnCreepMinionAtPosAndRotation, InVerticalRotation) == 0x00001C, "Member 'OrionCheatManagerGame_SpawnCreepMinionAtPosAndRotation::InVerticalRotation' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SpawnEnemyHero
// 0x0010 (0x0010 - 0x0000)
struct OrionCheatManagerGame_SpawnEnemyHero final
{
public:
	class FString                                 DataAssetName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_SpawnEnemyHero) == 0x000008, "Wrong alignment on OrionCheatManagerGame_SpawnEnemyHero");
static_assert(sizeof(OrionCheatManagerGame_SpawnEnemyHero) == 0x000010, "Wrong size on OrionCheatManagerGame_SpawnEnemyHero");
static_assert(offsetof(OrionCheatManagerGame_SpawnEnemyHero, DataAssetName) == 0x000000, "Member 'OrionCheatManagerGame_SpawnEnemyHero::DataAssetName' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SpawnEnemyHeroAtPos
// 0x0020 (0x0020 - 0x0000)
struct OrionCheatManagerGame_SpawnEnemyHeroAtPos final
{
public:
	class FString                                 DataAssetName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X;                                                 // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionCheatManagerGame_SpawnEnemyHeroAtPos) == 0x000008, "Wrong alignment on OrionCheatManagerGame_SpawnEnemyHeroAtPos");
static_assert(sizeof(OrionCheatManagerGame_SpawnEnemyHeroAtPos) == 0x000020, "Wrong size on OrionCheatManagerGame_SpawnEnemyHeroAtPos");
static_assert(offsetof(OrionCheatManagerGame_SpawnEnemyHeroAtPos, DataAssetName) == 0x000000, "Member 'OrionCheatManagerGame_SpawnEnemyHeroAtPos::DataAssetName' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnEnemyHeroAtPos, X) == 0x000010, "Member 'OrionCheatManagerGame_SpawnEnemyHeroAtPos::X' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnEnemyHeroAtPos, Y) == 0x000014, "Member 'OrionCheatManagerGame_SpawnEnemyHeroAtPos::Y' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnEnemyHeroAtPos, Z) == 0x000018, "Member 'OrionCheatManagerGame_SpawnEnemyHeroAtPos::Z' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SpawnEnemyHeroAtPosAndRotation
// 0x0028 (0x0028 - 0x0000)
struct OrionCheatManagerGame_SpawnEnemyHeroAtPosAndRotation final
{
public:
	class FString                                 DataAssetName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X;                                                 // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InVerticalRotation;                                // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWithBotController;                                // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionCheatManagerGame_SpawnEnemyHeroAtPosAndRotation) == 0x000008, "Wrong alignment on OrionCheatManagerGame_SpawnEnemyHeroAtPosAndRotation");
static_assert(sizeof(OrionCheatManagerGame_SpawnEnemyHeroAtPosAndRotation) == 0x000028, "Wrong size on OrionCheatManagerGame_SpawnEnemyHeroAtPosAndRotation");
static_assert(offsetof(OrionCheatManagerGame_SpawnEnemyHeroAtPosAndRotation, DataAssetName) == 0x000000, "Member 'OrionCheatManagerGame_SpawnEnemyHeroAtPosAndRotation::DataAssetName' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnEnemyHeroAtPosAndRotation, X) == 0x000010, "Member 'OrionCheatManagerGame_SpawnEnemyHeroAtPosAndRotation::X' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnEnemyHeroAtPosAndRotation, Y) == 0x000014, "Member 'OrionCheatManagerGame_SpawnEnemyHeroAtPosAndRotation::Y' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnEnemyHeroAtPosAndRotation, Z) == 0x000018, "Member 'OrionCheatManagerGame_SpawnEnemyHeroAtPosAndRotation::Z' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnEnemyHeroAtPosAndRotation, InVerticalRotation) == 0x00001C, "Member 'OrionCheatManagerGame_SpawnEnemyHeroAtPosAndRotation::InVerticalRotation' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnEnemyHeroAtPosAndRotation, bWithBotController) == 0x000020, "Member 'OrionCheatManagerGame_SpawnEnemyHeroAtPosAndRotation::bWithBotController' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SpawnEnemyHeroWithSkinAtPosAndRotation
// 0x0038 (0x0038 - 0x0000)
struct OrionCheatManagerGame_SpawnEnemyHeroWithSkinAtPosAndRotation final
{
public:
	class FString                                 DataAssetName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SkinName;                                          // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X;                                                 // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InVerticalRotation;                                // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWithBotController;                                // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionCheatManagerGame_SpawnEnemyHeroWithSkinAtPosAndRotation) == 0x000008, "Wrong alignment on OrionCheatManagerGame_SpawnEnemyHeroWithSkinAtPosAndRotation");
static_assert(sizeof(OrionCheatManagerGame_SpawnEnemyHeroWithSkinAtPosAndRotation) == 0x000038, "Wrong size on OrionCheatManagerGame_SpawnEnemyHeroWithSkinAtPosAndRotation");
static_assert(offsetof(OrionCheatManagerGame_SpawnEnemyHeroWithSkinAtPosAndRotation, DataAssetName) == 0x000000, "Member 'OrionCheatManagerGame_SpawnEnemyHeroWithSkinAtPosAndRotation::DataAssetName' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnEnemyHeroWithSkinAtPosAndRotation, SkinName) == 0x000010, "Member 'OrionCheatManagerGame_SpawnEnemyHeroWithSkinAtPosAndRotation::SkinName' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnEnemyHeroWithSkinAtPosAndRotation, X) == 0x000020, "Member 'OrionCheatManagerGame_SpawnEnemyHeroWithSkinAtPosAndRotation::X' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnEnemyHeroWithSkinAtPosAndRotation, Y) == 0x000024, "Member 'OrionCheatManagerGame_SpawnEnemyHeroWithSkinAtPosAndRotation::Y' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnEnemyHeroWithSkinAtPosAndRotation, Z) == 0x000028, "Member 'OrionCheatManagerGame_SpawnEnemyHeroWithSkinAtPosAndRotation::Z' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnEnemyHeroWithSkinAtPosAndRotation, InVerticalRotation) == 0x00002C, "Member 'OrionCheatManagerGame_SpawnEnemyHeroWithSkinAtPosAndRotation::InVerticalRotation' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnEnemyHeroWithSkinAtPosAndRotation, bWithBotController) == 0x000030, "Member 'OrionCheatManagerGame_SpawnEnemyHeroWithSkinAtPosAndRotation::bWithBotController' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SpawnEnemyMinion
// 0x0010 (0x0010 - 0x0000)
struct OrionCheatManagerGame_SpawnEnemyMinion final
{
public:
	class FString                                 DataAssetName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_SpawnEnemyMinion) == 0x000008, "Wrong alignment on OrionCheatManagerGame_SpawnEnemyMinion");
static_assert(sizeof(OrionCheatManagerGame_SpawnEnemyMinion) == 0x000010, "Wrong size on OrionCheatManagerGame_SpawnEnemyMinion");
static_assert(offsetof(OrionCheatManagerGame_SpawnEnemyMinion, DataAssetName) == 0x000000, "Member 'OrionCheatManagerGame_SpawnEnemyMinion::DataAssetName' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SpawnEnemyMinionAtPos
// 0x0020 (0x0020 - 0x0000)
struct OrionCheatManagerGame_SpawnEnemyMinionAtPos final
{
public:
	class FString                                 DataAssetName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X;                                                 // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionCheatManagerGame_SpawnEnemyMinionAtPos) == 0x000008, "Wrong alignment on OrionCheatManagerGame_SpawnEnemyMinionAtPos");
static_assert(sizeof(OrionCheatManagerGame_SpawnEnemyMinionAtPos) == 0x000020, "Wrong size on OrionCheatManagerGame_SpawnEnemyMinionAtPos");
static_assert(offsetof(OrionCheatManagerGame_SpawnEnemyMinionAtPos, DataAssetName) == 0x000000, "Member 'OrionCheatManagerGame_SpawnEnemyMinionAtPos::DataAssetName' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnEnemyMinionAtPos, X) == 0x000010, "Member 'OrionCheatManagerGame_SpawnEnemyMinionAtPos::X' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnEnemyMinionAtPos, Y) == 0x000014, "Member 'OrionCheatManagerGame_SpawnEnemyMinionAtPos::Y' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnEnemyMinionAtPos, Z) == 0x000018, "Member 'OrionCheatManagerGame_SpawnEnemyMinionAtPos::Z' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SpawnEnemyMinionAtPosAndRotation
// 0x0020 (0x0020 - 0x0000)
struct OrionCheatManagerGame_SpawnEnemyMinionAtPosAndRotation final
{
public:
	class FString                                 DataAssetName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X;                                                 // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InVerticalRotation;                                // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_SpawnEnemyMinionAtPosAndRotation) == 0x000008, "Wrong alignment on OrionCheatManagerGame_SpawnEnemyMinionAtPosAndRotation");
static_assert(sizeof(OrionCheatManagerGame_SpawnEnemyMinionAtPosAndRotation) == 0x000020, "Wrong size on OrionCheatManagerGame_SpawnEnemyMinionAtPosAndRotation");
static_assert(offsetof(OrionCheatManagerGame_SpawnEnemyMinionAtPosAndRotation, DataAssetName) == 0x000000, "Member 'OrionCheatManagerGame_SpawnEnemyMinionAtPosAndRotation::DataAssetName' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnEnemyMinionAtPosAndRotation, X) == 0x000010, "Member 'OrionCheatManagerGame_SpawnEnemyMinionAtPosAndRotation::X' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnEnemyMinionAtPosAndRotation, Y) == 0x000014, "Member 'OrionCheatManagerGame_SpawnEnemyMinionAtPosAndRotation::Y' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnEnemyMinionAtPosAndRotation, Z) == 0x000018, "Member 'OrionCheatManagerGame_SpawnEnemyMinionAtPosAndRotation::Z' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnEnemyMinionAtPosAndRotation, InVerticalRotation) == 0x00001C, "Member 'OrionCheatManagerGame_SpawnEnemyMinionAtPosAndRotation::InVerticalRotation' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SpawnFriendlyHero
// 0x0010 (0x0010 - 0x0000)
struct OrionCheatManagerGame_SpawnFriendlyHero final
{
public:
	class FString                                 DataAssetName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_SpawnFriendlyHero) == 0x000008, "Wrong alignment on OrionCheatManagerGame_SpawnFriendlyHero");
static_assert(sizeof(OrionCheatManagerGame_SpawnFriendlyHero) == 0x000010, "Wrong size on OrionCheatManagerGame_SpawnFriendlyHero");
static_assert(offsetof(OrionCheatManagerGame_SpawnFriendlyHero, DataAssetName) == 0x000000, "Member 'OrionCheatManagerGame_SpawnFriendlyHero::DataAssetName' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SpawnFriendlyHeroAtPos
// 0x0020 (0x0020 - 0x0000)
struct OrionCheatManagerGame_SpawnFriendlyHeroAtPos final
{
public:
	class FString                                 DataAssetName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X;                                                 // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionCheatManagerGame_SpawnFriendlyHeroAtPos) == 0x000008, "Wrong alignment on OrionCheatManagerGame_SpawnFriendlyHeroAtPos");
static_assert(sizeof(OrionCheatManagerGame_SpawnFriendlyHeroAtPos) == 0x000020, "Wrong size on OrionCheatManagerGame_SpawnFriendlyHeroAtPos");
static_assert(offsetof(OrionCheatManagerGame_SpawnFriendlyHeroAtPos, DataAssetName) == 0x000000, "Member 'OrionCheatManagerGame_SpawnFriendlyHeroAtPos::DataAssetName' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnFriendlyHeroAtPos, X) == 0x000010, "Member 'OrionCheatManagerGame_SpawnFriendlyHeroAtPos::X' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnFriendlyHeroAtPos, Y) == 0x000014, "Member 'OrionCheatManagerGame_SpawnFriendlyHeroAtPos::Y' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnFriendlyHeroAtPos, Z) == 0x000018, "Member 'OrionCheatManagerGame_SpawnFriendlyHeroAtPos::Z' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SpawnFriendlyHeroAtPosAndRotation
// 0x0020 (0x0020 - 0x0000)
struct OrionCheatManagerGame_SpawnFriendlyHeroAtPosAndRotation final
{
public:
	class FString                                 DataAssetName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X;                                                 // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InVerticalRotation;                                // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_SpawnFriendlyHeroAtPosAndRotation) == 0x000008, "Wrong alignment on OrionCheatManagerGame_SpawnFriendlyHeroAtPosAndRotation");
static_assert(sizeof(OrionCheatManagerGame_SpawnFriendlyHeroAtPosAndRotation) == 0x000020, "Wrong size on OrionCheatManagerGame_SpawnFriendlyHeroAtPosAndRotation");
static_assert(offsetof(OrionCheatManagerGame_SpawnFriendlyHeroAtPosAndRotation, DataAssetName) == 0x000000, "Member 'OrionCheatManagerGame_SpawnFriendlyHeroAtPosAndRotation::DataAssetName' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnFriendlyHeroAtPosAndRotation, X) == 0x000010, "Member 'OrionCheatManagerGame_SpawnFriendlyHeroAtPosAndRotation::X' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnFriendlyHeroAtPosAndRotation, Y) == 0x000014, "Member 'OrionCheatManagerGame_SpawnFriendlyHeroAtPosAndRotation::Y' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnFriendlyHeroAtPosAndRotation, Z) == 0x000018, "Member 'OrionCheatManagerGame_SpawnFriendlyHeroAtPosAndRotation::Z' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnFriendlyHeroAtPosAndRotation, InVerticalRotation) == 0x00001C, "Member 'OrionCheatManagerGame_SpawnFriendlyHeroAtPosAndRotation::InVerticalRotation' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SpawnFriendlyHeroWithSkinAtPosAndRotation
// 0x0030 (0x0030 - 0x0000)
struct OrionCheatManagerGame_SpawnFriendlyHeroWithSkinAtPosAndRotation final
{
public:
	class FString                                 DataAssetName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SkinName;                                          // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X;                                                 // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InVerticalRotation;                                // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_SpawnFriendlyHeroWithSkinAtPosAndRotation) == 0x000008, "Wrong alignment on OrionCheatManagerGame_SpawnFriendlyHeroWithSkinAtPosAndRotation");
static_assert(sizeof(OrionCheatManagerGame_SpawnFriendlyHeroWithSkinAtPosAndRotation) == 0x000030, "Wrong size on OrionCheatManagerGame_SpawnFriendlyHeroWithSkinAtPosAndRotation");
static_assert(offsetof(OrionCheatManagerGame_SpawnFriendlyHeroWithSkinAtPosAndRotation, DataAssetName) == 0x000000, "Member 'OrionCheatManagerGame_SpawnFriendlyHeroWithSkinAtPosAndRotation::DataAssetName' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnFriendlyHeroWithSkinAtPosAndRotation, SkinName) == 0x000010, "Member 'OrionCheatManagerGame_SpawnFriendlyHeroWithSkinAtPosAndRotation::SkinName' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnFriendlyHeroWithSkinAtPosAndRotation, X) == 0x000020, "Member 'OrionCheatManagerGame_SpawnFriendlyHeroWithSkinAtPosAndRotation::X' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnFriendlyHeroWithSkinAtPosAndRotation, Y) == 0x000024, "Member 'OrionCheatManagerGame_SpawnFriendlyHeroWithSkinAtPosAndRotation::Y' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnFriendlyHeroWithSkinAtPosAndRotation, Z) == 0x000028, "Member 'OrionCheatManagerGame_SpawnFriendlyHeroWithSkinAtPosAndRotation::Z' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnFriendlyHeroWithSkinAtPosAndRotation, InVerticalRotation) == 0x00002C, "Member 'OrionCheatManagerGame_SpawnFriendlyHeroWithSkinAtPosAndRotation::InVerticalRotation' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SpawnFriendlyMinion
// 0x0010 (0x0010 - 0x0000)
struct OrionCheatManagerGame_SpawnFriendlyMinion final
{
public:
	class FString                                 DataAssetName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_SpawnFriendlyMinion) == 0x000008, "Wrong alignment on OrionCheatManagerGame_SpawnFriendlyMinion");
static_assert(sizeof(OrionCheatManagerGame_SpawnFriendlyMinion) == 0x000010, "Wrong size on OrionCheatManagerGame_SpawnFriendlyMinion");
static_assert(offsetof(OrionCheatManagerGame_SpawnFriendlyMinion, DataAssetName) == 0x000000, "Member 'OrionCheatManagerGame_SpawnFriendlyMinion::DataAssetName' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SpawnFriendlyMinionAtPos
// 0x0020 (0x0020 - 0x0000)
struct OrionCheatManagerGame_SpawnFriendlyMinionAtPos final
{
public:
	class FString                                 DataAssetName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X;                                                 // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionCheatManagerGame_SpawnFriendlyMinionAtPos) == 0x000008, "Wrong alignment on OrionCheatManagerGame_SpawnFriendlyMinionAtPos");
static_assert(sizeof(OrionCheatManagerGame_SpawnFriendlyMinionAtPos) == 0x000020, "Wrong size on OrionCheatManagerGame_SpawnFriendlyMinionAtPos");
static_assert(offsetof(OrionCheatManagerGame_SpawnFriendlyMinionAtPos, DataAssetName) == 0x000000, "Member 'OrionCheatManagerGame_SpawnFriendlyMinionAtPos::DataAssetName' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnFriendlyMinionAtPos, X) == 0x000010, "Member 'OrionCheatManagerGame_SpawnFriendlyMinionAtPos::X' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnFriendlyMinionAtPos, Y) == 0x000014, "Member 'OrionCheatManagerGame_SpawnFriendlyMinionAtPos::Y' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnFriendlyMinionAtPos, Z) == 0x000018, "Member 'OrionCheatManagerGame_SpawnFriendlyMinionAtPos::Z' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SpawnFriendlyMinionAtPosAndRotation
// 0x0020 (0x0020 - 0x0000)
struct OrionCheatManagerGame_SpawnFriendlyMinionAtPosAndRotation final
{
public:
	class FString                                 DataAssetName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X;                                                 // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InVerticalRotation;                                // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_SpawnFriendlyMinionAtPosAndRotation) == 0x000008, "Wrong alignment on OrionCheatManagerGame_SpawnFriendlyMinionAtPosAndRotation");
static_assert(sizeof(OrionCheatManagerGame_SpawnFriendlyMinionAtPosAndRotation) == 0x000020, "Wrong size on OrionCheatManagerGame_SpawnFriendlyMinionAtPosAndRotation");
static_assert(offsetof(OrionCheatManagerGame_SpawnFriendlyMinionAtPosAndRotation, DataAssetName) == 0x000000, "Member 'OrionCheatManagerGame_SpawnFriendlyMinionAtPosAndRotation::DataAssetName' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnFriendlyMinionAtPosAndRotation, X) == 0x000010, "Member 'OrionCheatManagerGame_SpawnFriendlyMinionAtPosAndRotation::X' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnFriendlyMinionAtPosAndRotation, Y) == 0x000014, "Member 'OrionCheatManagerGame_SpawnFriendlyMinionAtPosAndRotation::Y' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnFriendlyMinionAtPosAndRotation, Z) == 0x000018, "Member 'OrionCheatManagerGame_SpawnFriendlyMinionAtPosAndRotation::Z' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnFriendlyMinionAtPosAndRotation, InVerticalRotation) == 0x00001C, "Member 'OrionCheatManagerGame_SpawnFriendlyMinionAtPosAndRotation::InVerticalRotation' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SpawnTargetDummyHero
// 0x0010 (0x0010 - 0x0000)
struct OrionCheatManagerGame_SpawnTargetDummyHero final
{
public:
	class FString                                 DataAssetName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_SpawnTargetDummyHero) == 0x000008, "Wrong alignment on OrionCheatManagerGame_SpawnTargetDummyHero");
static_assert(sizeof(OrionCheatManagerGame_SpawnTargetDummyHero) == 0x000010, "Wrong size on OrionCheatManagerGame_SpawnTargetDummyHero");
static_assert(offsetof(OrionCheatManagerGame_SpawnTargetDummyHero, DataAssetName) == 0x000000, "Member 'OrionCheatManagerGame_SpawnTargetDummyHero::DataAssetName' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SpawnTargetDummyHeroAtPos
// 0x0020 (0x0020 - 0x0000)
struct OrionCheatManagerGame_SpawnTargetDummyHeroAtPos final
{
public:
	class FString                                 DataAssetName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X;                                                 // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionCheatManagerGame_SpawnTargetDummyHeroAtPos) == 0x000008, "Wrong alignment on OrionCheatManagerGame_SpawnTargetDummyHeroAtPos");
static_assert(sizeof(OrionCheatManagerGame_SpawnTargetDummyHeroAtPos) == 0x000020, "Wrong size on OrionCheatManagerGame_SpawnTargetDummyHeroAtPos");
static_assert(offsetof(OrionCheatManagerGame_SpawnTargetDummyHeroAtPos, DataAssetName) == 0x000000, "Member 'OrionCheatManagerGame_SpawnTargetDummyHeroAtPos::DataAssetName' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnTargetDummyHeroAtPos, X) == 0x000010, "Member 'OrionCheatManagerGame_SpawnTargetDummyHeroAtPos::X' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnTargetDummyHeroAtPos, Y) == 0x000014, "Member 'OrionCheatManagerGame_SpawnTargetDummyHeroAtPos::Y' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnTargetDummyHeroAtPos, Z) == 0x000018, "Member 'OrionCheatManagerGame_SpawnTargetDummyHeroAtPos::Z' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SpawnTargetDummyHeroAtPosAndRotation
// 0x0020 (0x0020 - 0x0000)
struct OrionCheatManagerGame_SpawnTargetDummyHeroAtPosAndRotation final
{
public:
	class FString                                 DataAssetName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X;                                                 // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InVerticalRotation;                                // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_SpawnTargetDummyHeroAtPosAndRotation) == 0x000008, "Wrong alignment on OrionCheatManagerGame_SpawnTargetDummyHeroAtPosAndRotation");
static_assert(sizeof(OrionCheatManagerGame_SpawnTargetDummyHeroAtPosAndRotation) == 0x000020, "Wrong size on OrionCheatManagerGame_SpawnTargetDummyHeroAtPosAndRotation");
static_assert(offsetof(OrionCheatManagerGame_SpawnTargetDummyHeroAtPosAndRotation, DataAssetName) == 0x000000, "Member 'OrionCheatManagerGame_SpawnTargetDummyHeroAtPosAndRotation::DataAssetName' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnTargetDummyHeroAtPosAndRotation, X) == 0x000010, "Member 'OrionCheatManagerGame_SpawnTargetDummyHeroAtPosAndRotation::X' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnTargetDummyHeroAtPosAndRotation, Y) == 0x000014, "Member 'OrionCheatManagerGame_SpawnTargetDummyHeroAtPosAndRotation::Y' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnTargetDummyHeroAtPosAndRotation, Z) == 0x000018, "Member 'OrionCheatManagerGame_SpawnTargetDummyHeroAtPosAndRotation::Z' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SpawnTargetDummyHeroAtPosAndRotation, InVerticalRotation) == 0x00001C, "Member 'OrionCheatManagerGame_SpawnTargetDummyHeroAtPosAndRotation::InVerticalRotation' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.StopCoinSpawning
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerGame_StopCoinSpawning final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_StopCoinSpawning) == 0x000004, "Wrong alignment on OrionCheatManagerGame_StopCoinSpawning");
static_assert(sizeof(OrionCheatManagerGame_StopCoinSpawning) == 0x000004, "Wrong size on OrionCheatManagerGame_StopCoinSpawning");
static_assert(offsetof(OrionCheatManagerGame_StopCoinSpawning, Value) == 0x000000, "Member 'OrionCheatManagerGame_StopCoinSpawning::Value' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.SurrenderVote
// 0x0008 (0x0008 - 0x0000)
struct OrionCheatManagerGame_SurrenderVote final
{
public:
	bool                                          bVoteYes;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Reason;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_SurrenderVote) == 0x000004, "Wrong alignment on OrionCheatManagerGame_SurrenderVote");
static_assert(sizeof(OrionCheatManagerGame_SurrenderVote) == 0x000008, "Wrong size on OrionCheatManagerGame_SurrenderVote");
static_assert(offsetof(OrionCheatManagerGame_SurrenderVote, bVoteYes) == 0x000000, "Member 'OrionCheatManagerGame_SurrenderVote::bVoteYes' has a wrong offset!");
static_assert(offsetof(OrionCheatManagerGame_SurrenderVote, Reason) == 0x000004, "Member 'OrionCheatManagerGame_SurrenderVote::Reason' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.ToggleStunStressTest
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerGame_ToggleStunStressTest final
{
public:
	float                                         Duration;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_ToggleStunStressTest) == 0x000004, "Wrong alignment on OrionCheatManagerGame_ToggleStunStressTest");
static_assert(sizeof(OrionCheatManagerGame_ToggleStunStressTest) == 0x000004, "Wrong size on OrionCheatManagerGame_ToggleStunStressTest");
static_assert(offsetof(OrionCheatManagerGame_ToggleStunStressTest, Duration) == 0x000000, "Member 'OrionCheatManagerGame_ToggleStunStressTest::Duration' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.TowerGod
// 0x0001 (0x0001 - 0x0000)
struct OrionCheatManagerGame_TowerGod final
{
public:
	bool                                          bTowerGod;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_TowerGod) == 0x000001, "Wrong alignment on OrionCheatManagerGame_TowerGod");
static_assert(sizeof(OrionCheatManagerGame_TowerGod) == 0x000001, "Wrong size on OrionCheatManagerGame_TowerGod");
static_assert(offsetof(OrionCheatManagerGame_TowerGod, bTowerGod) == 0x000000, "Member 'OrionCheatManagerGame_TowerGod::bTowerGod' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.TravelModeMode
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerGame_TravelModeMode final
{
public:
	int32                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_TravelModeMode) == 0x000004, "Wrong alignment on OrionCheatManagerGame_TravelModeMode");
static_assert(sizeof(OrionCheatManagerGame_TravelModeMode) == 0x000004, "Wrong size on OrionCheatManagerGame_TravelModeMode");
static_assert(offsetof(OrionCheatManagerGame_TravelModeMode, NewValue) == 0x000000, "Member 'OrionCheatManagerGame_TravelModeMode::NewValue' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.UnlimitedHealth
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerGame_UnlimitedHealth final
{
public:
	int32                                         State;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_UnlimitedHealth) == 0x000004, "Wrong alignment on OrionCheatManagerGame_UnlimitedHealth");
static_assert(sizeof(OrionCheatManagerGame_UnlimitedHealth) == 0x000004, "Wrong size on OrionCheatManagerGame_UnlimitedHealth");
static_assert(offsetof(OrionCheatManagerGame_UnlimitedHealth, State) == 0x000000, "Member 'OrionCheatManagerGame_UnlimitedHealth::State' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.VLogAIEvent
// 0x0010 (0x0010 - 0x0000)
struct OrionCheatManagerGame_VLogAIEvent final
{
public:
	class FString                                 EventLabel;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_VLogAIEvent) == 0x000008, "Wrong alignment on OrionCheatManagerGame_VLogAIEvent");
static_assert(sizeof(OrionCheatManagerGame_VLogAIEvent) == 0x000010, "Wrong size on OrionCheatManagerGame_VLogAIEvent");
static_assert(offsetof(OrionCheatManagerGame_VLogAIEvent, EventLabel) == 0x000000, "Member 'OrionCheatManagerGame_VLogAIEvent::EventLabel' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.WhyTargetingBroken
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerGame_WhyTargetingBroken final
{
public:
	float                                         DebugDuration;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_WhyTargetingBroken) == 0x000004, "Wrong alignment on OrionCheatManagerGame_WhyTargetingBroken");
static_assert(sizeof(OrionCheatManagerGame_WhyTargetingBroken) == 0x000004, "Wrong size on OrionCheatManagerGame_WhyTargetingBroken");
static_assert(offsetof(OrionCheatManagerGame_WhyTargetingBroken, DebugDuration) == 0x000000, "Member 'OrionCheatManagerGame_WhyTargetingBroken::DebugDuration' has a wrong offset!");

// Function OrionGame.OrionCheatManagerGame.WTF
// 0x0004 (0x0004 - 0x0000)
struct OrionCheatManagerGame_WTF final
{
public:
	int32                                         Enable;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCheatManagerGame_WTF) == 0x000004, "Wrong alignment on OrionCheatManagerGame_WTF");
static_assert(sizeof(OrionCheatManagerGame_WTF) == 0x000004, "Wrong size on OrionCheatManagerGame_WTF");
static_assert(offsetof(OrionCheatManagerGame_WTF, Enable) == 0x000000, "Member 'OrionCheatManagerGame_WTF::Enable' has a wrong offset!");

// Function OrionGame.OrionAmbientEventScheduler_MOBA.FireIntroEventCues
// 0x0008 (0x0008 - 0x0000)
struct OrionAmbientEventScheduler_MOBA_FireIntroEventCues final
{
public:
	class AOrionCharHero*                         LocalHero;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAmbientEventScheduler_MOBA_FireIntroEventCues) == 0x000008, "Wrong alignment on OrionAmbientEventScheduler_MOBA_FireIntroEventCues");
static_assert(sizeof(OrionAmbientEventScheduler_MOBA_FireIntroEventCues) == 0x000008, "Wrong size on OrionAmbientEventScheduler_MOBA_FireIntroEventCues");
static_assert(offsetof(OrionAmbientEventScheduler_MOBA_FireIntroEventCues, LocalHero) == 0x000000, "Member 'OrionAmbientEventScheduler_MOBA_FireIntroEventCues::LocalHero' has a wrong offset!");

// Function OrionGame.OrionAnalytics.FireEvent_InitialLoadComplete
// 0x0008 (0x0008 - 0x0000)
struct OrionAnalytics_FireEvent_InitialLoadComplete final
{
public:
	class UUserWidget*                            UserContext;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAnalytics_FireEvent_InitialLoadComplete) == 0x000008, "Wrong alignment on OrionAnalytics_FireEvent_InitialLoadComplete");
static_assert(sizeof(OrionAnalytics_FireEvent_InitialLoadComplete) == 0x000008, "Wrong size on OrionAnalytics_FireEvent_InitialLoadComplete");
static_assert(offsetof(OrionAnalytics_FireEvent_InitialLoadComplete, UserContext) == 0x000000, "Member 'OrionAnalytics_FireEvent_InitialLoadComplete::UserContext' has a wrong offset!");

// Function OrionGame.OrionAnalytics.FireEvent_ModifiedSettings
// 0x0010 (0x0010 - 0x0000)
struct OrionAnalytics_FireEvent_ModifiedSettings final
{
public:
	class UUserWidget*                            UserContext;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UOrionGameUserSettings*           UserSettings;                                      // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionAnalytics_FireEvent_ModifiedSettings) == 0x000008, "Wrong alignment on OrionAnalytics_FireEvent_ModifiedSettings");
static_assert(sizeof(OrionAnalytics_FireEvent_ModifiedSettings) == 0x000010, "Wrong size on OrionAnalytics_FireEvent_ModifiedSettings");
static_assert(offsetof(OrionAnalytics_FireEvent_ModifiedSettings, UserContext) == 0x000000, "Member 'OrionAnalytics_FireEvent_ModifiedSettings::UserContext' has a wrong offset!");
static_assert(offsetof(OrionAnalytics_FireEvent_ModifiedSettings, UserSettings) == 0x000008, "Member 'OrionAnalytics_FireEvent_ModifiedSettings::UserSettings' has a wrong offset!");

// Function OrionGame.OrionCharHero.ApplySkinToMesh
// 0x0010 (0x0010 - 0x0000)
struct OrionCharHero_ApplySkinToMesh final
{
public:
	class USkeletalMeshComponent*                 MeshToApplySkinTo;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UOrionSkinVariationItemDefinition* SkinVariation;                                     // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharHero_ApplySkinToMesh) == 0x000008, "Wrong alignment on OrionCharHero_ApplySkinToMesh");
static_assert(sizeof(OrionCharHero_ApplySkinToMesh) == 0x000010, "Wrong size on OrionCharHero_ApplySkinToMesh");
static_assert(offsetof(OrionCharHero_ApplySkinToMesh, MeshToApplySkinTo) == 0x000000, "Member 'OrionCharHero_ApplySkinToMesh::MeshToApplySkinTo' has a wrong offset!");
static_assert(offsetof(OrionCharHero_ApplySkinToMesh, SkinVariation) == 0x000008, "Member 'OrionCharHero_ApplySkinToMesh::SkinVariation' has a wrong offset!");

// Function OrionGame.OrionCharHero.DrawReticle
// 0x0018 (0x0018 - 0x0000)
struct OrionCharHero_DrawReticle final
{
public:
	struct FOrion2DReticle                        ReticleMaterial;                                   // 0x0000(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharHero_DrawReticle) == 0x000008, "Wrong alignment on OrionCharHero_DrawReticle");
static_assert(sizeof(OrionCharHero_DrawReticle) == 0x000018, "Wrong size on OrionCharHero_DrawReticle");
static_assert(offsetof(OrionCharHero_DrawReticle, ReticleMaterial) == 0x000000, "Member 'OrionCharHero_DrawReticle::ReticleMaterial' has a wrong offset!");

// Function OrionGame.OrionCharHero.DrawReticle_Setup
// 0x0010 (0x0010 - 0x0000)
struct OrionCharHero_DrawReticle_Setup final
{
public:
	class UCanvas*                                Canvas;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionUI_Base*                          CallingUI;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharHero_DrawReticle_Setup) == 0x000008, "Wrong alignment on OrionCharHero_DrawReticle_Setup");
static_assert(sizeof(OrionCharHero_DrawReticle_Setup) == 0x000010, "Wrong size on OrionCharHero_DrawReticle_Setup");
static_assert(offsetof(OrionCharHero_DrawReticle_Setup, Canvas) == 0x000000, "Member 'OrionCharHero_DrawReticle_Setup::Canvas' has a wrong offset!");
static_assert(offsetof(OrionCharHero_DrawReticle_Setup, CallingUI) == 0x000008, "Member 'OrionCharHero_DrawReticle_Setup::CallingUI' has a wrong offset!");

// Function OrionGame.OrionCharHero.DrawReticleByIndex
// 0x0004 (0x0004 - 0x0000)
struct OrionCharHero_DrawReticleByIndex final
{
public:
	int32                                         ReticleIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharHero_DrawReticleByIndex) == 0x000004, "Wrong alignment on OrionCharHero_DrawReticleByIndex");
static_assert(sizeof(OrionCharHero_DrawReticleByIndex) == 0x000004, "Wrong size on OrionCharHero_DrawReticleByIndex");
static_assert(offsetof(OrionCharHero_DrawReticleByIndex, ReticleIndex) == 0x000000, "Member 'OrionCharHero_DrawReticleByIndex::ReticleIndex' has a wrong offset!");

// Function OrionGame.OrionCharHero.GameplayCue_Damage
// 0x00C0 (0x00C0 - 0x0000)
struct OrionCharHero_GameplayCue_Damage final
{
public:
	EGameplayCueEvent                             EventType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayCueParameters                 Parameters;                                        // 0x0008(0x00B8)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharHero_GameplayCue_Damage) == 0x000008, "Wrong alignment on OrionCharHero_GameplayCue_Damage");
static_assert(sizeof(OrionCharHero_GameplayCue_Damage) == 0x0000C0, "Wrong size on OrionCharHero_GameplayCue_Damage");
static_assert(offsetof(OrionCharHero_GameplayCue_Damage, EventType) == 0x000000, "Member 'OrionCharHero_GameplayCue_Damage::EventType' has a wrong offset!");
static_assert(offsetof(OrionCharHero_GameplayCue_Damage, Parameters) == 0x000008, "Member 'OrionCharHero_GameplayCue_Damage::Parameters' has a wrong offset!");

// Function OrionGame.OrionCharHero.GetCurrentCrown
// 0x0008 (0x0008 - 0x0000)
struct OrionCharHero_GetCurrentCrown final
{
public:
	class UOrionMcpCrownItemDefinition*           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharHero_GetCurrentCrown) == 0x000008, "Wrong alignment on OrionCharHero_GetCurrentCrown");
static_assert(sizeof(OrionCharHero_GetCurrentCrown) == 0x000008, "Wrong size on OrionCharHero_GetCurrentCrown");
static_assert(offsetof(OrionCharHero_GetCurrentCrown, ReturnValue) == 0x000000, "Member 'OrionCharHero_GetCurrentCrown::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharHero.GetCurrentSkin
// 0x0008 (0x0008 - 0x0000)
struct OrionCharHero_GetCurrentSkin final
{
public:
	class UOrionSkinItemDefinition*               ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharHero_GetCurrentSkin) == 0x000008, "Wrong alignment on OrionCharHero_GetCurrentSkin");
static_assert(sizeof(OrionCharHero_GetCurrentSkin) == 0x000008, "Wrong size on OrionCharHero_GetCurrentSkin");
static_assert(offsetof(OrionCharHero_GetCurrentSkin, ReturnValue) == 0x000000, "Member 'OrionCharHero_GetCurrentSkin::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharHero.GetCurrentSkinVariation
// 0x0008 (0x0008 - 0x0000)
struct OrionCharHero_GetCurrentSkinVariation final
{
public:
	class UOrionSkinVariationItemDefinition*      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharHero_GetCurrentSkinVariation) == 0x000008, "Wrong alignment on OrionCharHero_GetCurrentSkinVariation");
static_assert(sizeof(OrionCharHero_GetCurrentSkinVariation) == 0x000008, "Wrong size on OrionCharHero_GetCurrentSkinVariation");
static_assert(offsetof(OrionCharHero_GetCurrentSkinVariation, ReturnValue) == 0x000000, "Member 'OrionCharHero_GetCurrentSkinVariation::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharHero.GetDecalAttachmentBone
// 0x0010 (0x0010 - 0x0000)
struct OrionCharHero_GetDecalAttachmentBone final
{
public:
	class FName                                   DecalName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Out_AttachmentBoneName;                            // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharHero_GetDecalAttachmentBone) == 0x000004, "Wrong alignment on OrionCharHero_GetDecalAttachmentBone");
static_assert(sizeof(OrionCharHero_GetDecalAttachmentBone) == 0x000010, "Wrong size on OrionCharHero_GetDecalAttachmentBone");
static_assert(offsetof(OrionCharHero_GetDecalAttachmentBone, DecalName) == 0x000000, "Member 'OrionCharHero_GetDecalAttachmentBone::DecalName' has a wrong offset!");
static_assert(offsetof(OrionCharHero_GetDecalAttachmentBone, Out_AttachmentBoneName) == 0x000008, "Member 'OrionCharHero_GetDecalAttachmentBone::Out_AttachmentBoneName' has a wrong offset!");

// Function OrionGame.OrionCharHero.GetDecalFudgeFactor
// 0x0018 (0x0018 - 0x0000)
struct OrionCharHero_GetDecalFudgeFactor final
{
public:
	class FName                                   DecalName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Out_FudgeFactorScaleVec;                           // 0x0008(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionCharHero_GetDecalFudgeFactor) == 0x000004, "Wrong alignment on OrionCharHero_GetDecalFudgeFactor");
static_assert(sizeof(OrionCharHero_GetDecalFudgeFactor) == 0x000018, "Wrong size on OrionCharHero_GetDecalFudgeFactor");
static_assert(offsetof(OrionCharHero_GetDecalFudgeFactor, DecalName) == 0x000000, "Member 'OrionCharHero_GetDecalFudgeFactor::DecalName' has a wrong offset!");
static_assert(offsetof(OrionCharHero_GetDecalFudgeFactor, Out_FudgeFactorScaleVec) == 0x000008, "Member 'OrionCharHero_GetDecalFudgeFactor::Out_FudgeFactorScaleVec' has a wrong offset!");

// Function OrionGame.OrionCharHero.GetLerpedRewindData
// 0x0034 (0x0034 - 0x0000)
struct OrionCharHero_GetLerpedRewindData final
{
public:
	float                                         AlphaFactor;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalSeconds;                                      // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGetTweenedValueOnInitialTime;                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OutTotalAmountMoved;                               // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRecordedIntervalsData                 ReturnValue;                                       // 0x0010(0x0024)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharHero_GetLerpedRewindData) == 0x000004, "Wrong alignment on OrionCharHero_GetLerpedRewindData");
static_assert(sizeof(OrionCharHero_GetLerpedRewindData) == 0x000034, "Wrong size on OrionCharHero_GetLerpedRewindData");
static_assert(offsetof(OrionCharHero_GetLerpedRewindData, AlphaFactor) == 0x000000, "Member 'OrionCharHero_GetLerpedRewindData::AlphaFactor' has a wrong offset!");
static_assert(offsetof(OrionCharHero_GetLerpedRewindData, TotalSeconds) == 0x000004, "Member 'OrionCharHero_GetLerpedRewindData::TotalSeconds' has a wrong offset!");
static_assert(offsetof(OrionCharHero_GetLerpedRewindData, bGetTweenedValueOnInitialTime) == 0x000008, "Member 'OrionCharHero_GetLerpedRewindData::bGetTweenedValueOnInitialTime' has a wrong offset!");
static_assert(offsetof(OrionCharHero_GetLerpedRewindData, OutTotalAmountMoved) == 0x00000C, "Member 'OrionCharHero_GetLerpedRewindData::OutTotalAmountMoved' has a wrong offset!");
static_assert(offsetof(OrionCharHero_GetLerpedRewindData, ReturnValue) == 0x000010, "Member 'OrionCharHero_GetLerpedRewindData::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharHero.GetRewindData
// 0x002C (0x002C - 0x0000)
struct OrionCharHero_GetRewindData final
{
public:
	float                                         NumSeconds;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGetTweenedValues;                                 // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRecordedIntervalsData                 ReturnValue;                                       // 0x0008(0x0024)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharHero_GetRewindData) == 0x000004, "Wrong alignment on OrionCharHero_GetRewindData");
static_assert(sizeof(OrionCharHero_GetRewindData) == 0x00002C, "Wrong size on OrionCharHero_GetRewindData");
static_assert(offsetof(OrionCharHero_GetRewindData, NumSeconds) == 0x000000, "Member 'OrionCharHero_GetRewindData::NumSeconds' has a wrong offset!");
static_assert(offsetof(OrionCharHero_GetRewindData, bGetTweenedValues) == 0x000004, "Member 'OrionCharHero_GetRewindData::bGetTweenedValues' has a wrong offset!");
static_assert(offsetof(OrionCharHero_GetRewindData, ReturnValue) == 0x000008, "Member 'OrionCharHero_GetRewindData::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharHero.GetRewindPosition
// 0x0014 (0x0014 - 0x0000)
struct OrionCharHero_GetRewindPosition final
{
public:
	float                                         NumSeconds;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGetTweenedValues;                                 // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharHero_GetRewindPosition) == 0x000004, "Wrong alignment on OrionCharHero_GetRewindPosition");
static_assert(sizeof(OrionCharHero_GetRewindPosition) == 0x000014, "Wrong size on OrionCharHero_GetRewindPosition");
static_assert(offsetof(OrionCharHero_GetRewindPosition, NumSeconds) == 0x000000, "Member 'OrionCharHero_GetRewindPosition::NumSeconds' has a wrong offset!");
static_assert(offsetof(OrionCharHero_GetRewindPosition, bGetTweenedValues) == 0x000004, "Member 'OrionCharHero_GetRewindPosition::bGetTweenedValues' has a wrong offset!");
static_assert(offsetof(OrionCharHero_GetRewindPosition, ReturnValue) == 0x000008, "Member 'OrionCharHero_GetRewindPosition::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharHero.HeroMovementUpdated
// 0x001C (0x001C - 0x0000)
struct OrionCharHero_HeroMovementUpdated final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OldLocation;                                       // 0x0004(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OldVelocity;                                       // 0x0010(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharHero_HeroMovementUpdated) == 0x000004, "Wrong alignment on OrionCharHero_HeroMovementUpdated");
static_assert(sizeof(OrionCharHero_HeroMovementUpdated) == 0x00001C, "Wrong size on OrionCharHero_HeroMovementUpdated");
static_assert(offsetof(OrionCharHero_HeroMovementUpdated, DeltaSeconds) == 0x000000, "Member 'OrionCharHero_HeroMovementUpdated::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(OrionCharHero_HeroMovementUpdated, OldLocation) == 0x000004, "Member 'OrionCharHero_HeroMovementUpdated::OldLocation' has a wrong offset!");
static_assert(offsetof(OrionCharHero_HeroMovementUpdated, OldVelocity) == 0x000010, "Member 'OrionCharHero_HeroMovementUpdated::OldVelocity' has a wrong offset!");

// Function OrionGame.OrionCharHero.RequestServerRewind
// 0x0004 (0x0004 - 0x0000)
struct OrionCharHero_RequestServerRewind final
{
public:
	float                                         NumSeconds;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharHero_RequestServerRewind) == 0x000004, "Wrong alignment on OrionCharHero_RequestServerRewind");
static_assert(sizeof(OrionCharHero_RequestServerRewind) == 0x000004, "Wrong size on OrionCharHero_RequestServerRewind");
static_assert(offsetof(OrionCharHero_RequestServerRewind, NumSeconds) == 0x000000, "Member 'OrionCharHero_RequestServerRewind::NumSeconds' has a wrong offset!");

// Function OrionGame.OrionCharHero.ReticleMaterialTick
// 0x0010 (0x0010 - 0x0000)
struct OrionCharHero_ReticleMaterialTick final
{
public:
	class UCanvas*                                Canvas;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionUI_Base*                          CallingUI;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharHero_ReticleMaterialTick) == 0x000008, "Wrong alignment on OrionCharHero_ReticleMaterialTick");
static_assert(sizeof(OrionCharHero_ReticleMaterialTick) == 0x000010, "Wrong size on OrionCharHero_ReticleMaterialTick");
static_assert(offsetof(OrionCharHero_ReticleMaterialTick, Canvas) == 0x000000, "Member 'OrionCharHero_ReticleMaterialTick::Canvas' has a wrong offset!");
static_assert(offsetof(OrionCharHero_ReticleMaterialTick, CallingUI) == 0x000008, "Member 'OrionCharHero_ReticleMaterialTick::CallingUI' has a wrong offset!");

// Function OrionGame.OrionCharHero.SetSkipNextLandingGC
// 0x0001 (0x0001 - 0x0000)
struct OrionCharHero_SetSkipNextLandingGC final
{
public:
	bool                                          bSkip;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharHero_SetSkipNextLandingGC) == 0x000001, "Wrong alignment on OrionCharHero_SetSkipNextLandingGC");
static_assert(sizeof(OrionCharHero_SetSkipNextLandingGC) == 0x000001, "Wrong size on OrionCharHero_SetSkipNextLandingGC");
static_assert(offsetof(OrionCharHero_SetSkipNextLandingGC, bSkip) == 0x000000, "Member 'OrionCharHero_SetSkipNextLandingGC::bSkip' has a wrong offset!");

// Function OrionGame.OrionCharHero.SpawnDefaultTargetActor
// 0x0008 (0x0008 - 0x0000)
struct OrionCharHero_SpawnDefaultTargetActor final
{
public:
	class AGameplayAbilityTargetActor*            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharHero_SpawnDefaultTargetActor) == 0x000008, "Wrong alignment on OrionCharHero_SpawnDefaultTargetActor");
static_assert(sizeof(OrionCharHero_SpawnDefaultTargetActor) == 0x000008, "Wrong size on OrionCharHero_SpawnDefaultTargetActor");
static_assert(offsetof(OrionCharHero_SpawnDefaultTargetActor, ReturnValue) == 0x000000, "Member 'OrionCharHero_SpawnDefaultTargetActor::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharHero.TestActivateBanner
// 0x0003 (0x0003 - 0x0000)
struct OrionCharHero_TestActivateBanner final
{
public:
	bool                                          bUseRandomProto;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDefaultProto;                                  // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharHero_TestActivateBanner) == 0x000001, "Wrong alignment on OrionCharHero_TestActivateBanner");
static_assert(sizeof(OrionCharHero_TestActivateBanner) == 0x000003, "Wrong size on OrionCharHero_TestActivateBanner");
static_assert(offsetof(OrionCharHero_TestActivateBanner, bUseRandomProto) == 0x000000, "Member 'OrionCharHero_TestActivateBanner::bUseRandomProto' has a wrong offset!");
static_assert(offsetof(OrionCharHero_TestActivateBanner, bUseDefaultProto) == 0x000001, "Member 'OrionCharHero_TestActivateBanner::bUseDefaultProto' has a wrong offset!");
static_assert(offsetof(OrionCharHero_TestActivateBanner, ReturnValue) == 0x000002, "Member 'OrionCharHero_TestActivateBanner::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharHero.TestActivateGraveMarker
// 0x0002 (0x0002 - 0x0000)
struct OrionCharHero_TestActivateGraveMarker final
{
public:
	bool                                          bForEnemy;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharHero_TestActivateGraveMarker) == 0x000001, "Wrong alignment on OrionCharHero_TestActivateGraveMarker");
static_assert(sizeof(OrionCharHero_TestActivateGraveMarker) == 0x000002, "Wrong size on OrionCharHero_TestActivateGraveMarker");
static_assert(offsetof(OrionCharHero_TestActivateGraveMarker, bForEnemy) == 0x000000, "Member 'OrionCharHero_TestActivateGraveMarker::bForEnemy' has a wrong offset!");
static_assert(offsetof(OrionCharHero_TestActivateGraveMarker, ReturnValue) == 0x000001, "Member 'OrionCharHero_TestActivateGraveMarker::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharHero.GetBaseAimLocation
// 0x000C (0x000C - 0x0000)
struct OrionCharHero_GetBaseAimLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharHero_GetBaseAimLocation) == 0x000004, "Wrong alignment on OrionCharHero_GetBaseAimLocation");
static_assert(sizeof(OrionCharHero_GetBaseAimLocation) == 0x00000C, "Wrong size on OrionCharHero_GetBaseAimLocation");
static_assert(offsetof(OrionCharHero_GetBaseAimLocation, ReturnValue) == 0x000000, "Member 'OrionCharHero_GetBaseAimLocation::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharHero.GetEnergy
// 0x0004 (0x0004 - 0x0000)
struct OrionCharHero_GetEnergy final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharHero_GetEnergy) == 0x000004, "Wrong alignment on OrionCharHero_GetEnergy");
static_assert(sizeof(OrionCharHero_GetEnergy) == 0x000004, "Wrong size on OrionCharHero_GetEnergy");
static_assert(offsetof(OrionCharHero_GetEnergy, ReturnValue) == 0x000000, "Member 'OrionCharHero_GetEnergy::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharHero.GetEnergyPercent
// 0x0004 (0x0004 - 0x0000)
struct OrionCharHero_GetEnergyPercent final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharHero_GetEnergyPercent) == 0x000004, "Wrong alignment on OrionCharHero_GetEnergyPercent");
static_assert(sizeof(OrionCharHero_GetEnergyPercent) == 0x000004, "Wrong size on OrionCharHero_GetEnergyPercent");
static_assert(offsetof(OrionCharHero_GetEnergyPercent, ReturnValue) == 0x000000, "Member 'OrionCharHero_GetEnergyPercent::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharHero.GetEnergyRegen
// 0x0004 (0x0004 - 0x0000)
struct OrionCharHero_GetEnergyRegen final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharHero_GetEnergyRegen) == 0x000004, "Wrong alignment on OrionCharHero_GetEnergyRegen");
static_assert(sizeof(OrionCharHero_GetEnergyRegen) == 0x000004, "Wrong size on OrionCharHero_GetEnergyRegen");
static_assert(offsetof(OrionCharHero_GetEnergyRegen, ReturnValue) == 0x000000, "Member 'OrionCharHero_GetEnergyRegen::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharHero.GetMaxEnergy
// 0x0004 (0x0004 - 0x0000)
struct OrionCharHero_GetMaxEnergy final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharHero_GetMaxEnergy) == 0x000004, "Wrong alignment on OrionCharHero_GetMaxEnergy");
static_assert(sizeof(OrionCharHero_GetMaxEnergy) == 0x000004, "Wrong size on OrionCharHero_GetMaxEnergy");
static_assert(offsetof(OrionCharHero_GetMaxEnergy, ReturnValue) == 0x000000, "Member 'OrionCharHero_GetMaxEnergy::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharHero.IsDecoy
// 0x0001 (0x0001 - 0x0000)
struct OrionCharHero_IsDecoy final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharHero_IsDecoy) == 0x000001, "Wrong alignment on OrionCharHero_IsDecoy");
static_assert(sizeof(OrionCharHero_IsDecoy) == 0x000001, "Wrong size on OrionCharHero_IsDecoy");
static_assert(offsetof(OrionCharHero_IsDecoy, ReturnValue) == 0x000000, "Member 'OrionCharHero_IsDecoy::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharHero_Decoy.GetHighlightableMeshes
// 0x0010 (0x0010 - 0x0000)
struct OrionCharHero_Decoy_GetHighlightableMeshes final
{
public:
	TArray<class UMeshComponent*>                 ReturnValue;                                       // 0x0000(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharHero_Decoy_GetHighlightableMeshes) == 0x000008, "Wrong alignment on OrionCharHero_Decoy_GetHighlightableMeshes");
static_assert(sizeof(OrionCharHero_Decoy_GetHighlightableMeshes) == 0x000010, "Wrong size on OrionCharHero_Decoy_GetHighlightableMeshes");
static_assert(offsetof(OrionCharHero_Decoy_GetHighlightableMeshes, ReturnValue) == 0x000000, "Member 'OrionCharHero_Decoy_GetHighlightableMeshes::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharHero_Decoy.IsDecoy
// 0x0001 (0x0001 - 0x0000)
struct OrionCharHero_Decoy_IsDecoy final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharHero_Decoy_IsDecoy) == 0x000001, "Wrong alignment on OrionCharHero_Decoy_IsDecoy");
static_assert(sizeof(OrionCharHero_Decoy_IsDecoy) == 0x000001, "Wrong size on OrionCharHero_Decoy_IsDecoy");
static_assert(offsetof(OrionCharHero_Decoy_IsDecoy, ReturnValue) == 0x000000, "Member 'OrionCharHero_Decoy_IsDecoy::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionObjectiveCapturePoint.OnCaptureHandle
// 0x0030 (0x0030 - 0x0000)
struct OrionObjectiveCapturePoint_OnCaptureHandle final
{
public:
	struct FOrionObjectivesToCapture              CapturedObjectiveData;                             // 0x0000(0x0030)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionObjectiveCapturePoint_OnCaptureHandle) == 0x000008, "Wrong alignment on OrionObjectiveCapturePoint_OnCaptureHandle");
static_assert(sizeof(OrionObjectiveCapturePoint_OnCaptureHandle) == 0x000030, "Wrong size on OrionObjectiveCapturePoint_OnCaptureHandle");
static_assert(offsetof(OrionObjectiveCapturePoint_OnCaptureHandle, CapturedObjectiveData) == 0x000000, "Member 'OrionObjectiveCapturePoint_OnCaptureHandle::CapturedObjectiveData' has a wrong offset!");

// Function OrionGame.OrionObjectiveCapturePoint.OnManuallyHandleCapture
// 0x0040 (0x0040 - 0x0000)
struct OrionObjectiveCapturePoint_OnManuallyHandleCapture final
{
public:
	class AActor*                                 OtherActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    OtherActorTeamNum;                                 // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionObjectivesToCapture              CapturedObjectiveData;                             // 0x0010(0x0030)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionObjectiveCapturePoint_OnManuallyHandleCapture) == 0x000008, "Wrong alignment on OrionObjectiveCapturePoint_OnManuallyHandleCapture");
static_assert(sizeof(OrionObjectiveCapturePoint_OnManuallyHandleCapture) == 0x000040, "Wrong size on OrionObjectiveCapturePoint_OnManuallyHandleCapture");
static_assert(offsetof(OrionObjectiveCapturePoint_OnManuallyHandleCapture, OtherActor) == 0x000000, "Member 'OrionObjectiveCapturePoint_OnManuallyHandleCapture::OtherActor' has a wrong offset!");
static_assert(offsetof(OrionObjectiveCapturePoint_OnManuallyHandleCapture, OtherActorTeamNum) == 0x000008, "Member 'OrionObjectiveCapturePoint_OnManuallyHandleCapture::OtherActorTeamNum' has a wrong offset!");
static_assert(offsetof(OrionObjectiveCapturePoint_OnManuallyHandleCapture, CapturedObjectiveData) == 0x000010, "Member 'OrionObjectiveCapturePoint_OnManuallyHandleCapture::CapturedObjectiveData' has a wrong offset!");

// Function OrionGame.OrionObjectiveCapturePoint.OnOverlapBegin
// 0x00A8 (0x00A8 - 0x0000)
struct OrionObjectiveCapturePoint_OnOverlapBegin final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionObjectiveCapturePoint_OnOverlapBegin) == 0x000008, "Wrong alignment on OrionObjectiveCapturePoint_OnOverlapBegin");
static_assert(sizeof(OrionObjectiveCapturePoint_OnOverlapBegin) == 0x0000A8, "Wrong size on OrionObjectiveCapturePoint_OnOverlapBegin");
static_assert(offsetof(OrionObjectiveCapturePoint_OnOverlapBegin, OverlappedComp) == 0x000000, "Member 'OrionObjectiveCapturePoint_OnOverlapBegin::OverlappedComp' has a wrong offset!");
static_assert(offsetof(OrionObjectiveCapturePoint_OnOverlapBegin, OtherActor) == 0x000008, "Member 'OrionObjectiveCapturePoint_OnOverlapBegin::OtherActor' has a wrong offset!");
static_assert(offsetof(OrionObjectiveCapturePoint_OnOverlapBegin, OtherComp) == 0x000010, "Member 'OrionObjectiveCapturePoint_OnOverlapBegin::OtherComp' has a wrong offset!");
static_assert(offsetof(OrionObjectiveCapturePoint_OnOverlapBegin, OtherBodyIndex) == 0x000018, "Member 'OrionObjectiveCapturePoint_OnOverlapBegin::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(OrionObjectiveCapturePoint_OnOverlapBegin, bFromSweep) == 0x00001C, "Member 'OrionObjectiveCapturePoint_OnOverlapBegin::bFromSweep' has a wrong offset!");
static_assert(offsetof(OrionObjectiveCapturePoint_OnOverlapBegin, SweepResult) == 0x000020, "Member 'OrionObjectiveCapturePoint_OnOverlapBegin::SweepResult' has a wrong offset!");

// Function OrionGame.OrionMcpItem.GetDescription
// 0x0018 (0x0018 - 0x0000)
struct OrionMcpItem_GetDescription final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpItem_GetDescription) == 0x000008, "Wrong alignment on OrionMcpItem_GetDescription");
static_assert(sizeof(OrionMcpItem_GetDescription) == 0x000018, "Wrong size on OrionMcpItem_GetDescription");
static_assert(offsetof(OrionMcpItem_GetDescription, ReturnValue) == 0x000000, "Member 'OrionMcpItem_GetDescription::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionMcpItem.GetDisplayName
// 0x0018 (0x0018 - 0x0000)
struct OrionMcpItem_GetDisplayName final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpItem_GetDisplayName) == 0x000008, "Wrong alignment on OrionMcpItem_GetDisplayName");
static_assert(sizeof(OrionMcpItem_GetDisplayName) == 0x000018, "Wrong size on OrionMcpItem_GetDisplayName");
static_assert(offsetof(OrionMcpItem_GetDisplayName, ReturnValue) == 0x000000, "Member 'OrionMcpItem_GetDisplayName::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionMcpItem.GetNumInStack
// 0x0004 (0x0004 - 0x0000)
struct OrionMcpItem_GetNumInStack final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpItem_GetNumInStack) == 0x000004, "Wrong alignment on OrionMcpItem_GetNumInStack");
static_assert(sizeof(OrionMcpItem_GetNumInStack) == 0x000004, "Wrong size on OrionMcpItem_GetNumInStack");
static_assert(offsetof(OrionMcpItem_GetNumInStack, ReturnValue) == 0x000000, "Member 'OrionMcpItem_GetNumInStack::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionMcpItem.GetType
// 0x0001 (0x0001 - 0x0000)
struct OrionMcpItem_GetType final
{
public:
	EOrionItemType                                ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpItem_GetType) == 0x000001, "Wrong alignment on OrionMcpItem_GetType");
static_assert(sizeof(OrionMcpItem_GetType) == 0x000001, "Wrong size on OrionMcpItem_GetType");
static_assert(offsetof(OrionMcpItem_GetType, ReturnValue) == 0x000000, "Member 'OrionMcpItem_GetType::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionMcpSkinVariationItem.GetInternalData
// 0x0008 (0x0008 - 0x0000)
struct OrionMcpSkinVariationItem_GetInternalData final
{
public:
	class UOrionSkinVariationItemDefinition*      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpSkinVariationItem_GetInternalData) == 0x000008, "Wrong alignment on OrionMcpSkinVariationItem_GetInternalData");
static_assert(sizeof(OrionMcpSkinVariationItem_GetInternalData) == 0x000008, "Wrong size on OrionMcpSkinVariationItem_GetInternalData");
static_assert(offsetof(OrionMcpSkinVariationItem_GetInternalData, ReturnValue) == 0x000000, "Member 'OrionMcpSkinVariationItem_GetInternalData::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionArcadeLadderSetupData.GetHeroIcon
// 0x0008 (0x0008 - 0x0000)
struct OrionArcadeLadderSetupData_GetHeroIcon final
{
public:
	class UTexture2D*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionArcadeLadderSetupData_GetHeroIcon) == 0x000008, "Wrong alignment on OrionArcadeLadderSetupData_GetHeroIcon");
static_assert(sizeof(OrionArcadeLadderSetupData_GetHeroIcon) == 0x000008, "Wrong size on OrionArcadeLadderSetupData_GetHeroIcon");
static_assert(offsetof(OrionArcadeLadderSetupData_GetHeroIcon, ReturnValue) == 0x000000, "Member 'OrionArcadeLadderSetupData_GetHeroIcon::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionArcadeLadderSetupData.GetHeroName
// 0x0018 (0x0018 - 0x0000)
struct OrionArcadeLadderSetupData_GetHeroName final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionArcadeLadderSetupData_GetHeroName) == 0x000008, "Wrong alignment on OrionArcadeLadderSetupData_GetHeroName");
static_assert(sizeof(OrionArcadeLadderSetupData_GetHeroName) == 0x000018, "Wrong size on OrionArcadeLadderSetupData_GetHeroName");
static_assert(offsetof(OrionArcadeLadderSetupData_GetHeroName, ReturnValue) == 0x000000, "Member 'OrionArcadeLadderSetupData_GetHeroName::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionBanner.ActivateBanner
// 0x0020 (0x0020 - 0x0000)
struct OrionBanner_ActivateBanner final
{
public:
	struct FVector                                EndPos;                                            // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               TargetRot;                                         // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0018(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBannerEntrance                               BannerEntranceType;                                // 0x001C(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001D(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionBanner_ActivateBanner) == 0x000004, "Wrong alignment on OrionBanner_ActivateBanner");
static_assert(sizeof(OrionBanner_ActivateBanner) == 0x000020, "Wrong size on OrionBanner_ActivateBanner");
static_assert(offsetof(OrionBanner_ActivateBanner, EndPos) == 0x000000, "Member 'OrionBanner_ActivateBanner::EndPos' has a wrong offset!");
static_assert(offsetof(OrionBanner_ActivateBanner, TargetRot) == 0x00000C, "Member 'OrionBanner_ActivateBanner::TargetRot' has a wrong offset!");
static_assert(offsetof(OrionBanner_ActivateBanner, Scale) == 0x000018, "Member 'OrionBanner_ActivateBanner::Scale' has a wrong offset!");
static_assert(offsetof(OrionBanner_ActivateBanner, BannerEntranceType) == 0x00001C, "Member 'OrionBanner_ActivateBanner::BannerEntranceType' has a wrong offset!");
static_assert(offsetof(OrionBanner_ActivateBanner, ReturnValue) == 0x00001D, "Member 'OrionBanner_ActivateBanner::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionBanner.ActivateTestBanner
// 0x0020 (0x0020 - 0x0000)
struct OrionBanner_ActivateTestBanner final
{
public:
	struct FVector                                InSpawnLocation;                                   // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               InSpawnRotation;                                   // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         InSpawnScale;                                      // 0x0018(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionBanner_ActivateTestBanner) == 0x000004, "Wrong alignment on OrionBanner_ActivateTestBanner");
static_assert(sizeof(OrionBanner_ActivateTestBanner) == 0x000020, "Wrong size on OrionBanner_ActivateTestBanner");
static_assert(offsetof(OrionBanner_ActivateTestBanner, InSpawnLocation) == 0x000000, "Member 'OrionBanner_ActivateTestBanner::InSpawnLocation' has a wrong offset!");
static_assert(offsetof(OrionBanner_ActivateTestBanner, InSpawnRotation) == 0x00000C, "Member 'OrionBanner_ActivateTestBanner::InSpawnRotation' has a wrong offset!");
static_assert(offsetof(OrionBanner_ActivateTestBanner, InSpawnScale) == 0x000018, "Member 'OrionBanner_ActivateTestBanner::InSpawnScale' has a wrong offset!");
static_assert(offsetof(OrionBanner_ActivateTestBanner, ReturnValue) == 0x00001C, "Member 'OrionBanner_ActivateTestBanner::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionBanner.AddGameplayCueLocal
// 0x00C0 (0x00C0 - 0x0000)
struct OrionBanner_AddGameplayCueLocal final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 Parameters;                                        // 0x0008(0x00B8)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBanner_AddGameplayCueLocal) == 0x000008, "Wrong alignment on OrionBanner_AddGameplayCueLocal");
static_assert(sizeof(OrionBanner_AddGameplayCueLocal) == 0x0000C0, "Wrong size on OrionBanner_AddGameplayCueLocal");
static_assert(offsetof(OrionBanner_AddGameplayCueLocal, GameplayCueTag) == 0x000000, "Member 'OrionBanner_AddGameplayCueLocal::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(OrionBanner_AddGameplayCueLocal, Parameters) == 0x000008, "Member 'OrionBanner_AddGameplayCueLocal::Parameters' has a wrong offset!");

// Function OrionGame.OrionBanner.ExecuteGameplayCueLocal
// 0x00C0 (0x00C0 - 0x0000)
struct OrionBanner_ExecuteGameplayCueLocal final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 Parameters;                                        // 0x0008(0x00B8)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBanner_ExecuteGameplayCueLocal) == 0x000008, "Wrong alignment on OrionBanner_ExecuteGameplayCueLocal");
static_assert(sizeof(OrionBanner_ExecuteGameplayCueLocal) == 0x0000C0, "Wrong size on OrionBanner_ExecuteGameplayCueLocal");
static_assert(offsetof(OrionBanner_ExecuteGameplayCueLocal, GameplayCueTag) == 0x000000, "Member 'OrionBanner_ExecuteGameplayCueLocal::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(OrionBanner_ExecuteGameplayCueLocal, Parameters) == 0x000008, "Member 'OrionBanner_ExecuteGameplayCueLocal::Parameters' has a wrong offset!");

// Function OrionGame.OrionBanner.RemoveAndFadeBannerNow
// 0x0004 (0x0004 - 0x0000)
struct OrionBanner_RemoveAndFadeBannerNow final
{
public:
	float                                         InFadeTime;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBanner_RemoveAndFadeBannerNow) == 0x000004, "Wrong alignment on OrionBanner_RemoveAndFadeBannerNow");
static_assert(sizeof(OrionBanner_RemoveAndFadeBannerNow) == 0x000004, "Wrong size on OrionBanner_RemoveAndFadeBannerNow");
static_assert(offsetof(OrionBanner_RemoveAndFadeBannerNow, InFadeTime) == 0x000000, "Member 'OrionBanner_RemoveAndFadeBannerNow::InFadeTime' has a wrong offset!");

// Function OrionGame.OrionBanner.RemoveGameplayCueLocal
// 0x00C0 (0x00C0 - 0x0000)
struct OrionBanner_RemoveGameplayCueLocal final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 Parameters;                                        // 0x0008(0x00B8)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBanner_RemoveGameplayCueLocal) == 0x000008, "Wrong alignment on OrionBanner_RemoveGameplayCueLocal");
static_assert(sizeof(OrionBanner_RemoveGameplayCueLocal) == 0x0000C0, "Wrong size on OrionBanner_RemoveGameplayCueLocal");
static_assert(offsetof(OrionBanner_RemoveGameplayCueLocal, GameplayCueTag) == 0x000000, "Member 'OrionBanner_RemoveGameplayCueLocal::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(OrionBanner_RemoveGameplayCueLocal, Parameters) == 0x000008, "Member 'OrionBanner_RemoveGameplayCueLocal::Parameters' has a wrong offset!");

// Function OrionGame.OrionBaseButton.DisableButtonWithReason
// 0x0018 (0x0018 - 0x0000)
struct OrionBaseButton_DisableButtonWithReason final
{
public:
	class FText                                   DisabledReason;                                    // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseButton_DisableButtonWithReason) == 0x000008, "Wrong alignment on OrionBaseButton_DisableButtonWithReason");
static_assert(sizeof(OrionBaseButton_DisableButtonWithReason) == 0x000018, "Wrong size on OrionBaseButton_DisableButtonWithReason");
static_assert(offsetof(OrionBaseButton_DisableButtonWithReason, DisabledReason) == 0x000000, "Member 'OrionBaseButton_DisableButtonWithReason::DisabledReason' has a wrong offset!");

// Function OrionGame.OrionBaseButton.SetIsSelectable
// 0x0001 (0x0001 - 0x0000)
struct OrionBaseButton_SetIsSelectable final
{
public:
	bool                                          bInIsSelectable;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseButton_SetIsSelectable) == 0x000001, "Wrong alignment on OrionBaseButton_SetIsSelectable");
static_assert(sizeof(OrionBaseButton_SetIsSelectable) == 0x000001, "Wrong size on OrionBaseButton_SetIsSelectable");
static_assert(offsetof(OrionBaseButton_SetIsSelectable, bInIsSelectable) == 0x000000, "Member 'OrionBaseButton_SetIsSelectable::bInIsSelectable' has a wrong offset!");

// Function OrionGame.OrionBaseButton.SetIsSelected
// 0x0002 (0x0002 - 0x0000)
struct OrionBaseButton_SetIsSelected final
{
public:
	bool                                          InSelected;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromClick;                                        // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseButton_SetIsSelected) == 0x000001, "Wrong alignment on OrionBaseButton_SetIsSelected");
static_assert(sizeof(OrionBaseButton_SetIsSelected) == 0x000002, "Wrong size on OrionBaseButton_SetIsSelected");
static_assert(offsetof(OrionBaseButton_SetIsSelected, InSelected) == 0x000000, "Member 'OrionBaseButton_SetIsSelected::InSelected' has a wrong offset!");
static_assert(offsetof(OrionBaseButton_SetIsSelected, bFromClick) == 0x000001, "Member 'OrionBaseButton_SetIsSelected::bFromClick' has a wrong offset!");

// Function OrionGame.OrionBaseButton.SetMinDimensions
// 0x0008 (0x0008 - 0x0000)
struct OrionBaseButton_SetMinDimensions final
{
public:
	int32                                         InMinWidth;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InMinHeight;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseButton_SetMinDimensions) == 0x000004, "Wrong alignment on OrionBaseButton_SetMinDimensions");
static_assert(sizeof(OrionBaseButton_SetMinDimensions) == 0x000008, "Wrong size on OrionBaseButton_SetMinDimensions");
static_assert(offsetof(OrionBaseButton_SetMinDimensions, InMinWidth) == 0x000000, "Member 'OrionBaseButton_SetMinDimensions::InMinWidth' has a wrong offset!");
static_assert(offsetof(OrionBaseButton_SetMinDimensions, InMinHeight) == 0x000004, "Member 'OrionBaseButton_SetMinDimensions::InMinHeight' has a wrong offset!");

// Function OrionGame.OrionBaseButton.SetSelectedInternal
// 0x0003 (0x0003 - 0x0000)
struct OrionBaseButton_SetSelectedInternal final
{
public:
	bool                                          bInSelected;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowSound;                                       // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBroadcast;                                        // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseButton_SetSelectedInternal) == 0x000001, "Wrong alignment on OrionBaseButton_SetSelectedInternal");
static_assert(sizeof(OrionBaseButton_SetSelectedInternal) == 0x000003, "Wrong size on OrionBaseButton_SetSelectedInternal");
static_assert(offsetof(OrionBaseButton_SetSelectedInternal, bInSelected) == 0x000000, "Member 'OrionBaseButton_SetSelectedInternal::bInSelected' has a wrong offset!");
static_assert(offsetof(OrionBaseButton_SetSelectedInternal, bAllowSound) == 0x000001, "Member 'OrionBaseButton_SetSelectedInternal::bAllowSound' has a wrong offset!");
static_assert(offsetof(OrionBaseButton_SetSelectedInternal, bBroadcast) == 0x000002, "Member 'OrionBaseButton_SetSelectedInternal::bBroadcast' has a wrong offset!");

// Function OrionGame.OrionBaseButton.SetStyle
// 0x0008 (0x0008 - 0x0000)
struct OrionBaseButton_SetStyle final
{
public:
	TSubclassOf<class UOrionButtonStyle>          InStyle;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseButton_SetStyle) == 0x000008, "Wrong alignment on OrionBaseButton_SetStyle");
static_assert(sizeof(OrionBaseButton_SetStyle) == 0x000008, "Wrong size on OrionBaseButton_SetStyle");
static_assert(offsetof(OrionBaseButton_SetStyle, InStyle) == 0x000000, "Member 'OrionBaseButton_SetStyle::InStyle' has a wrong offset!");

// Function OrionGame.OrionBaseButton.SetStyleSize
// 0x0001 (0x0001 - 0x0000)
struct OrionBaseButton_SetStyleSize final
{
public:
	EOrionWidgetStyleSize                         InSize;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseButton_SetStyleSize) == 0x000001, "Wrong alignment on OrionBaseButton_SetStyleSize");
static_assert(sizeof(OrionBaseButton_SetStyleSize) == 0x000001, "Wrong size on OrionBaseButton_SetStyleSize");
static_assert(offsetof(OrionBaseButton_SetStyleSize, InSize) == 0x000000, "Member 'OrionBaseButton_SetStyleSize::InSize' has a wrong offset!");

// Function OrionGame.OrionBaseButton.GetCurrentButtonPadding
// 0x0010 (0x0010 - 0x0000)
struct OrionBaseButton_GetCurrentButtonPadding final
{
public:
	struct FMargin                                OutButtonPadding;                                  // 0x0000(0x0010)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseButton_GetCurrentButtonPadding) == 0x000004, "Wrong alignment on OrionBaseButton_GetCurrentButtonPadding");
static_assert(sizeof(OrionBaseButton_GetCurrentButtonPadding) == 0x000010, "Wrong size on OrionBaseButton_GetCurrentButtonPadding");
static_assert(offsetof(OrionBaseButton_GetCurrentButtonPadding, OutButtonPadding) == 0x000000, "Member 'OrionBaseButton_GetCurrentButtonPadding::OutButtonPadding' has a wrong offset!");

// Function OrionGame.OrionBaseButton.GetCurrentCustomPadding
// 0x0010 (0x0010 - 0x0000)
struct OrionBaseButton_GetCurrentCustomPadding final
{
public:
	struct FMargin                                OutCustomPadding;                                  // 0x0000(0x0010)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseButton_GetCurrentCustomPadding) == 0x000004, "Wrong alignment on OrionBaseButton_GetCurrentCustomPadding");
static_assert(sizeof(OrionBaseButton_GetCurrentCustomPadding) == 0x000010, "Wrong size on OrionBaseButton_GetCurrentCustomPadding");
static_assert(offsetof(OrionBaseButton_GetCurrentCustomPadding, OutCustomPadding) == 0x000000, "Member 'OrionBaseButton_GetCurrentCustomPadding::OutCustomPadding' has a wrong offset!");

// Function OrionGame.OrionBaseButton.GetCurrentTextStyle
// 0x0008 (0x0008 - 0x0000)
struct OrionBaseButton_GetCurrentTextStyle final
{
public:
	class UOrionTextStyle*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseButton_GetCurrentTextStyle) == 0x000008, "Wrong alignment on OrionBaseButton_GetCurrentTextStyle");
static_assert(sizeof(OrionBaseButton_GetCurrentTextStyle) == 0x000008, "Wrong size on OrionBaseButton_GetCurrentTextStyle");
static_assert(offsetof(OrionBaseButton_GetCurrentTextStyle, ReturnValue) == 0x000000, "Member 'OrionBaseButton_GetCurrentTextStyle::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionBaseButton.GetCurrentTextStyleClass
// 0x0008 (0x0008 - 0x0000)
struct OrionBaseButton_GetCurrentTextStyleClass final
{
public:
	TSubclassOf<class UOrionTextStyle>            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseButton_GetCurrentTextStyleClass) == 0x000008, "Wrong alignment on OrionBaseButton_GetCurrentTextStyleClass");
static_assert(sizeof(OrionBaseButton_GetCurrentTextStyleClass) == 0x000008, "Wrong size on OrionBaseButton_GetCurrentTextStyleClass");
static_assert(offsetof(OrionBaseButton_GetCurrentTextStyleClass, ReturnValue) == 0x000000, "Member 'OrionBaseButton_GetCurrentTextStyleClass::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionBaseButton.GetSelected
// 0x0001 (0x0001 - 0x0000)
struct OrionBaseButton_GetSelected final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseButton_GetSelected) == 0x000001, "Wrong alignment on OrionBaseButton_GetSelected");
static_assert(sizeof(OrionBaseButton_GetSelected) == 0x000001, "Wrong size on OrionBaseButton_GetSelected");
static_assert(offsetof(OrionBaseButton_GetSelected, ReturnValue) == 0x000000, "Member 'OrionBaseButton_GetSelected::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionBaseButton.GetStyle
// 0x0008 (0x0008 - 0x0000)
struct OrionBaseButton_GetStyle final
{
public:
	class UOrionButtonStyle*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseButton_GetStyle) == 0x000008, "Wrong alignment on OrionBaseButton_GetStyle");
static_assert(sizeof(OrionBaseButton_GetStyle) == 0x000008, "Wrong size on OrionBaseButton_GetStyle");
static_assert(offsetof(OrionBaseButton_GetStyle, ReturnValue) == 0x000000, "Member 'OrionBaseButton_GetStyle::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionBaseButton.IsHovered
// 0x0001 (0x0001 - 0x0000)
struct OrionBaseButton_IsHovered final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseButton_IsHovered) == 0x000001, "Wrong alignment on OrionBaseButton_IsHovered");
static_assert(sizeof(OrionBaseButton_IsHovered) == 0x000001, "Wrong size on OrionBaseButton_IsHovered");
static_assert(offsetof(OrionBaseButton_IsHovered, ReturnValue) == 0x000000, "Member 'OrionBaseButton_IsHovered::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionBaseButton.IsInteractionEnabled
// 0x0001 (0x0001 - 0x0000)
struct OrionBaseButton_IsInteractionEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseButton_IsInteractionEnabled) == 0x000001, "Wrong alignment on OrionBaseButton_IsInteractionEnabled");
static_assert(sizeof(OrionBaseButton_IsInteractionEnabled) == 0x000001, "Wrong size on OrionBaseButton_IsInteractionEnabled");
static_assert(offsetof(OrionBaseButton_IsInteractionEnabled, ReturnValue) == 0x000000, "Member 'OrionBaseButton_IsInteractionEnabled::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionBaseButton.IsPressed
// 0x0001 (0x0001 - 0x0000)
struct OrionBaseButton_IsPressed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBaseButton_IsPressed) == 0x000001, "Wrong alignment on OrionBaseButton_IsPressed");
static_assert(sizeof(OrionBaseButton_IsPressed) == 0x000001, "Wrong size on OrionBaseButton_IsPressed");
static_assert(offsetof(OrionBaseButton_IsPressed, ReturnValue) == 0x000000, "Member 'OrionBaseButton_IsPressed::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionBotAbilityPicker.PickAbilityAgainstActor
// 0x00E0 (0x00E0 - 0x0000)
struct OrionBotAbilityPicker_PickAbilityAgainstActor final
{
public:
	class AOrionAIBot*                            BotAI;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilitySpec                   AbilitySpec;                                       // 0x0010(0x00C8)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00D8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionBotAbilityPicker_PickAbilityAgainstActor) == 0x000008, "Wrong alignment on OrionBotAbilityPicker_PickAbilityAgainstActor");
static_assert(sizeof(OrionBotAbilityPicker_PickAbilityAgainstActor) == 0x0000E0, "Wrong size on OrionBotAbilityPicker_PickAbilityAgainstActor");
static_assert(offsetof(OrionBotAbilityPicker_PickAbilityAgainstActor, BotAI) == 0x000000, "Member 'OrionBotAbilityPicker_PickAbilityAgainstActor::BotAI' has a wrong offset!");
static_assert(offsetof(OrionBotAbilityPicker_PickAbilityAgainstActor, TargetActor) == 0x000008, "Member 'OrionBotAbilityPicker_PickAbilityAgainstActor::TargetActor' has a wrong offset!");
static_assert(offsetof(OrionBotAbilityPicker_PickAbilityAgainstActor, AbilitySpec) == 0x000010, "Member 'OrionBotAbilityPicker_PickAbilityAgainstActor::AbilitySpec' has a wrong offset!");
static_assert(offsetof(OrionBotAbilityPicker_PickAbilityAgainstActor, ReturnValue) == 0x0000D8, "Member 'OrionBotAbilityPicker_PickAbilityAgainstActor::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionBotAISpawner.HandleSpawnedAIDeath
// 0x0018 (0x0018 - 0x0000)
struct OrionBotAISpawner_HandleSpawnedAIDeath final
{
public:
	class AOrionChar*                             DeadChar;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            Killer;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionBotAISpawner_HandleSpawnedAIDeath) == 0x000008, "Wrong alignment on OrionBotAISpawner_HandleSpawnedAIDeath");
static_assert(sizeof(OrionBotAISpawner_HandleSpawnedAIDeath) == 0x000018, "Wrong size on OrionBotAISpawner_HandleSpawnedAIDeath");
static_assert(offsetof(OrionBotAISpawner_HandleSpawnedAIDeath, DeadChar) == 0x000000, "Member 'OrionBotAISpawner_HandleSpawnedAIDeath::DeadChar' has a wrong offset!");
static_assert(offsetof(OrionBotAISpawner_HandleSpawnedAIDeath, Killer) == 0x000008, "Member 'OrionBotAISpawner_HandleSpawnedAIDeath::Killer' has a wrong offset!");
static_assert(offsetof(OrionBotAISpawner_HandleSpawnedAIDeath, DamageCauser) == 0x000010, "Member 'OrionBotAISpawner_HandleSpawnedAIDeath::DamageCauser' has a wrong offset!");

// Function OrionGame.OrionPlayerState_Game.CreatePlayerPathway
// 0x0030 (0x0030 - 0x0000)
struct OrionPlayerState_Game_CreatePlayerPathway final
{
public:
	TSubclassOf<class AOrionTraversablePathway>   OrionTraversablePathwayClass;                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartingLocation;                                  // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndingLocation;                                    // 0x0014(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionCharHero*                         OptBreadCrumbActor;                                // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionTraversablePathway*               ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerState_Game_CreatePlayerPathway) == 0x000008, "Wrong alignment on OrionPlayerState_Game_CreatePlayerPathway");
static_assert(sizeof(OrionPlayerState_Game_CreatePlayerPathway) == 0x000030, "Wrong size on OrionPlayerState_Game_CreatePlayerPathway");
static_assert(offsetof(OrionPlayerState_Game_CreatePlayerPathway, OrionTraversablePathwayClass) == 0x000000, "Member 'OrionPlayerState_Game_CreatePlayerPathway::OrionTraversablePathwayClass' has a wrong offset!");
static_assert(offsetof(OrionPlayerState_Game_CreatePlayerPathway, StartingLocation) == 0x000008, "Member 'OrionPlayerState_Game_CreatePlayerPathway::StartingLocation' has a wrong offset!");
static_assert(offsetof(OrionPlayerState_Game_CreatePlayerPathway, EndingLocation) == 0x000014, "Member 'OrionPlayerState_Game_CreatePlayerPathway::EndingLocation' has a wrong offset!");
static_assert(offsetof(OrionPlayerState_Game_CreatePlayerPathway, OptBreadCrumbActor) == 0x000020, "Member 'OrionPlayerState_Game_CreatePlayerPathway::OptBreadCrumbActor' has a wrong offset!");
static_assert(offsetof(OrionPlayerState_Game_CreatePlayerPathway, ReturnValue) == 0x000028, "Member 'OrionPlayerState_Game_CreatePlayerPathway::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlayerState_Game.GetAttachedBuffs
// 0x0010 (0x0010 - 0x0000)
struct OrionPlayerState_Game_GetAttachedBuffs final
{
public:
	TArray<class AOrionCarriedObjective*>         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerState_Game_GetAttachedBuffs) == 0x000008, "Wrong alignment on OrionPlayerState_Game_GetAttachedBuffs");
static_assert(sizeof(OrionPlayerState_Game_GetAttachedBuffs) == 0x000010, "Wrong size on OrionPlayerState_Game_GetAttachedBuffs");
static_assert(offsetof(OrionPlayerState_Game_GetAttachedBuffs, ReturnValue) == 0x000000, "Member 'OrionPlayerState_Game_GetAttachedBuffs::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlayerState_Game.GivePlayerCardActivationPoints
// 0x0004 (0x0004 - 0x0000)
struct OrionPlayerState_Game_GivePlayerCardActivationPoints final
{
public:
	int32                                         PointsEarned;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerState_Game_GivePlayerCardActivationPoints) == 0x000004, "Wrong alignment on OrionPlayerState_Game_GivePlayerCardActivationPoints");
static_assert(sizeof(OrionPlayerState_Game_GivePlayerCardActivationPoints) == 0x000004, "Wrong size on OrionPlayerState_Game_GivePlayerCardActivationPoints");
static_assert(offsetof(OrionPlayerState_Game_GivePlayerCardActivationPoints, PointsEarned) == 0x000000, "Member 'OrionPlayerState_Game_GivePlayerCardActivationPoints::PointsEarned' has a wrong offset!");

// Function OrionGame.OrionPlayerState_Game.OnRep_SurrenderVote
// 0x0001 (0x0001 - 0x0000)
struct OrionPlayerState_Game_OnRep_SurrenderVote final
{
public:
	ESurrenderVote                                OldVote;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerState_Game_OnRep_SurrenderVote) == 0x000001, "Wrong alignment on OrionPlayerState_Game_OnRep_SurrenderVote");
static_assert(sizeof(OrionPlayerState_Game_OnRep_SurrenderVote) == 0x000001, "Wrong size on OrionPlayerState_Game_OnRep_SurrenderVote");
static_assert(offsetof(OrionPlayerState_Game_OnRep_SurrenderVote, OldVote) == 0x000000, "Member 'OrionPlayerState_Game_OnRep_SurrenderVote::OldVote' has a wrong offset!");

// Function OrionGame.OrionPlayerState_Game.RequestServerPathWay
// 0x0018 (0x0018 - 0x0000)
struct OrionPlayerState_Game_RequestServerPathWay final
{
public:
	struct FVector                                SpawnLocation;                                     // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               SpawnRotation;                                     // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerState_Game_RequestServerPathWay) == 0x000004, "Wrong alignment on OrionPlayerState_Game_RequestServerPathWay");
static_assert(sizeof(OrionPlayerState_Game_RequestServerPathWay) == 0x000018, "Wrong size on OrionPlayerState_Game_RequestServerPathWay");
static_assert(offsetof(OrionPlayerState_Game_RequestServerPathWay, SpawnLocation) == 0x000000, "Member 'OrionPlayerState_Game_RequestServerPathWay::SpawnLocation' has a wrong offset!");
static_assert(offsetof(OrionPlayerState_Game_RequestServerPathWay, SpawnRotation) == 0x00000C, "Member 'OrionPlayerState_Game_RequestServerPathWay::SpawnRotation' has a wrong offset!");

// Function OrionGame.OrionPlayerState_Game.ServerAbilityLevelUp
// 0x0004 (0x0004 - 0x0000)
struct OrionPlayerState_Game_ServerAbilityLevelUp final
{
public:
	int32                                         InputID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerState_Game_ServerAbilityLevelUp) == 0x000004, "Wrong alignment on OrionPlayerState_Game_ServerAbilityLevelUp");
static_assert(sizeof(OrionPlayerState_Game_ServerAbilityLevelUp) == 0x000004, "Wrong size on OrionPlayerState_Game_ServerAbilityLevelUp");
static_assert(offsetof(OrionPlayerState_Game_ServerAbilityLevelUp, InputID) == 0x000000, "Member 'OrionPlayerState_Game_ServerAbilityLevelUp::InputID' has a wrong offset!");

// Function OrionGame.OrionPlayerState_Game.ServerTryToSetPlayerHeroDataSpecFromTeamSelection
// 0x00A8 (0x00A8 - 0x0000)
struct OrionPlayerState_Game_ServerTryToSetPlayerHeroDataSpecFromTeamSelection final
{
public:
	struct FOrionHeroDataSpec                     InHeroDataSpec;                                    // 0x0000(0x00A8)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerState_Game_ServerTryToSetPlayerHeroDataSpecFromTeamSelection) == 0x000008, "Wrong alignment on OrionPlayerState_Game_ServerTryToSetPlayerHeroDataSpecFromTeamSelection");
static_assert(sizeof(OrionPlayerState_Game_ServerTryToSetPlayerHeroDataSpecFromTeamSelection) == 0x0000A8, "Wrong size on OrionPlayerState_Game_ServerTryToSetPlayerHeroDataSpecFromTeamSelection");
static_assert(offsetof(OrionPlayerState_Game_ServerTryToSetPlayerHeroDataSpecFromTeamSelection, InHeroDataSpec) == 0x000000, "Member 'OrionPlayerState_Game_ServerTryToSetPlayerHeroDataSpecFromTeamSelection::InHeroDataSpec' has a wrong offset!");

// Function OrionGame.OrionPlayerState_Game.SetCardActivationPointsMax
// 0x0004 (0x0004 - 0x0000)
struct OrionPlayerState_Game_SetCardActivationPointsMax final
{
public:
	int32                                         NewMaxTotal;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerState_Game_SetCardActivationPointsMax) == 0x000004, "Wrong alignment on OrionPlayerState_Game_SetCardActivationPointsMax");
static_assert(sizeof(OrionPlayerState_Game_SetCardActivationPointsMax) == 0x000004, "Wrong size on OrionPlayerState_Game_SetCardActivationPointsMax");
static_assert(offsetof(OrionPlayerState_Game_SetCardActivationPointsMax, NewMaxTotal) == 0x000000, "Member 'OrionPlayerState_Game_SetCardActivationPointsMax::NewMaxTotal' has a wrong offset!");

// Function OrionGame.OrionPlayerState_Game.GetBotDifficultyLevelIndication
// 0x0001 (0x0001 - 0x0000)
struct OrionPlayerState_Game_GetBotDifficultyLevelIndication final
{
public:
	EAIBotDifficulty                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerState_Game_GetBotDifficultyLevelIndication) == 0x000001, "Wrong alignment on OrionPlayerState_Game_GetBotDifficultyLevelIndication");
static_assert(sizeof(OrionPlayerState_Game_GetBotDifficultyLevelIndication) == 0x000001, "Wrong size on OrionPlayerState_Game_GetBotDifficultyLevelIndication");
static_assert(offsetof(OrionPlayerState_Game_GetBotDifficultyLevelIndication, ReturnValue) == 0x000000, "Member 'OrionPlayerState_Game_GetBotDifficultyLevelIndication::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlayerState_Game.GetCardActivationPointsLeft
// 0x0004 (0x0004 - 0x0000)
struct OrionPlayerState_Game_GetCardActivationPointsLeft final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerState_Game_GetCardActivationPointsLeft) == 0x000004, "Wrong alignment on OrionPlayerState_Game_GetCardActivationPointsLeft");
static_assert(sizeof(OrionPlayerState_Game_GetCardActivationPointsLeft) == 0x000004, "Wrong size on OrionPlayerState_Game_GetCardActivationPointsLeft");
static_assert(offsetof(OrionPlayerState_Game_GetCardActivationPointsLeft, ReturnValue) == 0x000000, "Member 'OrionPlayerState_Game_GetCardActivationPointsLeft::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlayerState_Game.GetCardActivationPointsMax
// 0x0004 (0x0004 - 0x0000)
struct OrionPlayerState_Game_GetCardActivationPointsMax final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerState_Game_GetCardActivationPointsMax) == 0x000004, "Wrong alignment on OrionPlayerState_Game_GetCardActivationPointsMax");
static_assert(sizeof(OrionPlayerState_Game_GetCardActivationPointsMax) == 0x000004, "Wrong size on OrionPlayerState_Game_GetCardActivationPointsMax");
static_assert(offsetof(OrionPlayerState_Game_GetCardActivationPointsMax, ReturnValue) == 0x000000, "Member 'OrionPlayerState_Game_GetCardActivationPointsMax::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlayerState_Game.GetCardActivationPointsSpent
// 0x0004 (0x0004 - 0x0000)
struct OrionPlayerState_Game_GetCardActivationPointsSpent final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerState_Game_GetCardActivationPointsSpent) == 0x000004, "Wrong alignment on OrionPlayerState_Game_GetCardActivationPointsSpent");
static_assert(sizeof(OrionPlayerState_Game_GetCardActivationPointsSpent) == 0x000004, "Wrong size on OrionPlayerState_Game_GetCardActivationPointsSpent");
static_assert(offsetof(OrionPlayerState_Game_GetCardActivationPointsSpent, ReturnValue) == 0x000000, "Member 'OrionPlayerState_Game_GetCardActivationPointsSpent::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlayerState_Game.GetCurrentPawn
// 0x0008 (0x0008 - 0x0000)
struct OrionPlayerState_Game_GetCurrentPawn final
{
public:
	class AOrionChar*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerState_Game_GetCurrentPawn) == 0x000008, "Wrong alignment on OrionPlayerState_Game_GetCurrentPawn");
static_assert(sizeof(OrionPlayerState_Game_GetCurrentPawn) == 0x000008, "Wrong size on OrionPlayerState_Game_GetCurrentPawn");
static_assert(offsetof(OrionPlayerState_Game_GetCurrentPawn, ReturnValue) == 0x000000, "Member 'OrionPlayerState_Game_GetCurrentPawn::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlayerState_Game.GetSurrenderVote
// 0x0001 (0x0001 - 0x0000)
struct OrionPlayerState_Game_GetSurrenderVote final
{
public:
	ESurrenderVote                                ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerState_Game_GetSurrenderVote) == 0x000001, "Wrong alignment on OrionPlayerState_Game_GetSurrenderVote");
static_assert(sizeof(OrionPlayerState_Game_GetSurrenderVote) == 0x000001, "Wrong size on OrionPlayerState_Game_GetSurrenderVote");
static_assert(offsetof(OrionPlayerState_Game_GetSurrenderVote, ReturnValue) == 0x000000, "Member 'OrionPlayerState_Game_GetSurrenderVote::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlayerState_Game.GetTimeLeftToRespawn
// 0x0004 (0x0004 - 0x0000)
struct OrionPlayerState_Game_GetTimeLeftToRespawn final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerState_Game_GetTimeLeftToRespawn) == 0x000004, "Wrong alignment on OrionPlayerState_Game_GetTimeLeftToRespawn");
static_assert(sizeof(OrionPlayerState_Game_GetTimeLeftToRespawn) == 0x000004, "Wrong size on OrionPlayerState_Game_GetTimeLeftToRespawn");
static_assert(offsetof(OrionPlayerState_Game_GetTimeLeftToRespawn, ReturnValue) == 0x000000, "Member 'OrionPlayerState_Game_GetTimeLeftToRespawn::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionBTService_GetEnemy.ReceiveTick
// 0x0010 (0x0010 - 0x0000)
struct OrionBTService_GetEnemy_ReceiveTick final
{
public:
	class AActor*                                 OwnerActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaSeconds;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionBTService_GetEnemy_ReceiveTick) == 0x000008, "Wrong alignment on OrionBTService_GetEnemy_ReceiveTick");
static_assert(sizeof(OrionBTService_GetEnemy_ReceiveTick) == 0x000010, "Wrong size on OrionBTService_GetEnemy_ReceiveTick");
static_assert(offsetof(OrionBTService_GetEnemy_ReceiveTick, OwnerActor) == 0x000000, "Member 'OrionBTService_GetEnemy_ReceiveTick::OwnerActor' has a wrong offset!");
static_assert(offsetof(OrionBTService_GetEnemy_ReceiveTick, DeltaSeconds) == 0x000008, "Member 'OrionBTService_GetEnemy_ReceiveTick::DeltaSeconds' has a wrong offset!");

// Function OrionGame.OrionBTService_GetEnemy.ScoreTargetEnemy
// 0x0018 (0x0018 - 0x0000)
struct OrionBTService_GetEnemy_ScoreTargetEnemy final
{
public:
	class AOrionAIController*                     OwnerAIController;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Enemy;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionBTService_GetEnemy_ScoreTargetEnemy) == 0x000008, "Wrong alignment on OrionBTService_GetEnemy_ScoreTargetEnemy");
static_assert(sizeof(OrionBTService_GetEnemy_ScoreTargetEnemy) == 0x000018, "Wrong size on OrionBTService_GetEnemy_ScoreTargetEnemy");
static_assert(offsetof(OrionBTService_GetEnemy_ScoreTargetEnemy, OwnerAIController) == 0x000000, "Member 'OrionBTService_GetEnemy_ScoreTargetEnemy::OwnerAIController' has a wrong offset!");
static_assert(offsetof(OrionBTService_GetEnemy_ScoreTargetEnemy, Enemy) == 0x000008, "Member 'OrionBTService_GetEnemy_ScoreTargetEnemy::Enemy' has a wrong offset!");
static_assert(offsetof(OrionBTService_GetEnemy_ScoreTargetEnemy, ReturnValue) == 0x000010, "Member 'OrionBTService_GetEnemy_ScoreTargetEnemy::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCameraComponent_DeathCam.SetAutoFollow
// 0x0001 (0x0001 - 0x0000)
struct OrionCameraComponent_DeathCam_SetAutoFollow final
{
public:
	bool                                          bNewAutoFollow;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCameraComponent_DeathCam_SetAutoFollow) == 0x000001, "Wrong alignment on OrionCameraComponent_DeathCam_SetAutoFollow");
static_assert(sizeof(OrionCameraComponent_DeathCam_SetAutoFollow) == 0x000001, "Wrong size on OrionCameraComponent_DeathCam_SetAutoFollow");
static_assert(offsetof(OrionCameraComponent_DeathCam_SetAutoFollow, bNewAutoFollow) == 0x000000, "Member 'OrionCameraComponent_DeathCam_SetAutoFollow::bNewAutoFollow' has a wrong offset!");

// Function OrionGame.OrionCameraComponent_DeathCam.SetLazyAutoFollow
// 0x0001 (0x0001 - 0x0000)
struct OrionCameraComponent_DeathCam_SetLazyAutoFollow final
{
public:
	bool                                          bNewLazyAutoFollow;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCameraComponent_DeathCam_SetLazyAutoFollow) == 0x000001, "Wrong alignment on OrionCameraComponent_DeathCam_SetLazyAutoFollow");
static_assert(sizeof(OrionCameraComponent_DeathCam_SetLazyAutoFollow) == 0x000001, "Wrong size on OrionCameraComponent_DeathCam_SetLazyAutoFollow");
static_assert(offsetof(OrionCameraComponent_DeathCam_SetLazyAutoFollow, bNewLazyAutoFollow) == 0x000000, "Member 'OrionCameraComponent_DeathCam_SetLazyAutoFollow::bNewLazyAutoFollow' has a wrong offset!");

// Function OrionGame.OrionCardAbility.GetCardTargets
// 0x0020 (0x0020 - 0x0000)
struct OrionCardAbility_GetCardTargets final
{
public:
	struct FGameplayAbilityTargetDataHandle       ReturnValue;                                       // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCardAbility_GetCardTargets) == 0x000008, "Wrong alignment on OrionCardAbility_GetCardTargets");
static_assert(sizeof(OrionCardAbility_GetCardTargets) == 0x000020, "Wrong size on OrionCardAbility_GetCardTargets");
static_assert(offsetof(OrionCardAbility_GetCardTargets, ReturnValue) == 0x000000, "Member 'OrionCardAbility_GetCardTargets::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCardAbility.WasTriggeredFromEvent
// 0x0001 (0x0001 - 0x0000)
struct OrionCardAbility_WasTriggeredFromEvent final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCardAbility_WasTriggeredFromEvent) == 0x000001, "Wrong alignment on OrionCardAbility_WasTriggeredFromEvent");
static_assert(sizeof(OrionCardAbility_WasTriggeredFromEvent) == 0x000001, "Wrong size on OrionCardAbility_WasTriggeredFromEvent");
static_assert(offsetof(OrionCardAbility_WasTriggeredFromEvent, ReturnValue) == 0x000000, "Member 'OrionCardAbility_WasTriggeredFromEvent::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCarriedObjectiveInterface.ObjectiveScored
// 0x0008 (0x0008 - 0x0000)
struct OrionCarriedObjectiveInterface_ObjectiveScored final
{
public:
	class AActor*                                 ScoringActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCarriedObjectiveInterface_ObjectiveScored) == 0x000008, "Wrong alignment on OrionCarriedObjectiveInterface_ObjectiveScored");
static_assert(sizeof(OrionCarriedObjectiveInterface_ObjectiveScored) == 0x000008, "Wrong size on OrionCarriedObjectiveInterface_ObjectiveScored");
static_assert(offsetof(OrionCarriedObjectiveInterface_ObjectiveScored, ScoringActor) == 0x000000, "Member 'OrionCarriedObjectiveInterface_ObjectiveScored::ScoringActor' has a wrong offset!");

// Function OrionGame.OrionMinionAnimInstance.CancelBehavior
// 0x0001 (0x0001 - 0x0000)
struct OrionMinionAnimInstance_CancelBehavior final
{
public:
	EOrionMinionPrioritizedBehavior               Behavior;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMinionAnimInstance_CancelBehavior) == 0x000001, "Wrong alignment on OrionMinionAnimInstance_CancelBehavior");
static_assert(sizeof(OrionMinionAnimInstance_CancelBehavior) == 0x000001, "Wrong size on OrionMinionAnimInstance_CancelBehavior");
static_assert(offsetof(OrionMinionAnimInstance_CancelBehavior, Behavior) == 0x000000, "Member 'OrionMinionAnimInstance_CancelBehavior::Behavior' has a wrong offset!");

// Function OrionGame.OrionMinionAnimInstance.RequestBehavior
// 0x000C (0x000C - 0x0000)
struct OrionMinionAnimInstance_RequestBehavior final
{
public:
	EOrionMinionPrioritizedBehavior               Behavior;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayIndex;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLooping;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionMinionAnimInstance_RequestBehavior) == 0x000004, "Wrong alignment on OrionMinionAnimInstance_RequestBehavior");
static_assert(sizeof(OrionMinionAnimInstance_RequestBehavior) == 0x00000C, "Wrong size on OrionMinionAnimInstance_RequestBehavior");
static_assert(offsetof(OrionMinionAnimInstance_RequestBehavior, Behavior) == 0x000000, "Member 'OrionMinionAnimInstance_RequestBehavior::Behavior' has a wrong offset!");
static_assert(offsetof(OrionMinionAnimInstance_RequestBehavior, PlayIndex) == 0x000004, "Member 'OrionMinionAnimInstance_RequestBehavior::PlayIndex' has a wrong offset!");
static_assert(offsetof(OrionMinionAnimInstance_RequestBehavior, bLooping) == 0x000008, "Member 'OrionMinionAnimInstance_RequestBehavior::bLooping' has a wrong offset!");

// Function OrionGame.OrionCharAI_JungleBoss.HandleCallForHelp
// 0x02A8 (0x02A8 - 0x0000)
struct OrionCharAI_JungleBoss_HandleCallForHelp final
{
public:
	class AActor*                                 DamagedActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 AttackingActor;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpec                    EffectSpec;                                        // 0x0010(0x0298)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAI_JungleBoss_HandleCallForHelp) == 0x000008, "Wrong alignment on OrionCharAI_JungleBoss_HandleCallForHelp");
static_assert(sizeof(OrionCharAI_JungleBoss_HandleCallForHelp) == 0x0002A8, "Wrong size on OrionCharAI_JungleBoss_HandleCallForHelp");
static_assert(offsetof(OrionCharAI_JungleBoss_HandleCallForHelp, DamagedActor) == 0x000000, "Member 'OrionCharAI_JungleBoss_HandleCallForHelp::DamagedActor' has a wrong offset!");
static_assert(offsetof(OrionCharAI_JungleBoss_HandleCallForHelp, AttackingActor) == 0x000008, "Member 'OrionCharAI_JungleBoss_HandleCallForHelp::AttackingActor' has a wrong offset!");
static_assert(offsetof(OrionCharAI_JungleBoss_HandleCallForHelp, EffectSpec) == 0x000010, "Member 'OrionCharAI_JungleBoss_HandleCallForHelp::EffectSpec' has a wrong offset!");

// Function OrionGame.OrionCharAI_JungleBoss.PlayExpandingKnockback
// 0x0018 (0x0018 - 0x0000)
struct OrionCharAI_JungleBoss_PlayExpandingKnockback final
{
public:
	TSubclassOf<class UGameplayEffect>            AppliedEffect;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiusStart;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiusEnd;                                         // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExpansionTime;                                     // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionCharAI_JungleBoss_PlayExpandingKnockback) == 0x000008, "Wrong alignment on OrionCharAI_JungleBoss_PlayExpandingKnockback");
static_assert(sizeof(OrionCharAI_JungleBoss_PlayExpandingKnockback) == 0x000018, "Wrong size on OrionCharAI_JungleBoss_PlayExpandingKnockback");
static_assert(offsetof(OrionCharAI_JungleBoss_PlayExpandingKnockback, AppliedEffect) == 0x000000, "Member 'OrionCharAI_JungleBoss_PlayExpandingKnockback::AppliedEffect' has a wrong offset!");
static_assert(offsetof(OrionCharAI_JungleBoss_PlayExpandingKnockback, RadiusStart) == 0x000008, "Member 'OrionCharAI_JungleBoss_PlayExpandingKnockback::RadiusStart' has a wrong offset!");
static_assert(offsetof(OrionCharAI_JungleBoss_PlayExpandingKnockback, RadiusEnd) == 0x00000C, "Member 'OrionCharAI_JungleBoss_PlayExpandingKnockback::RadiusEnd' has a wrong offset!");
static_assert(offsetof(OrionCharAI_JungleBoss_PlayExpandingKnockback, ExpansionTime) == 0x000010, "Member 'OrionCharAI_JungleBoss_PlayExpandingKnockback::ExpansionTime' has a wrong offset!");

// Function OrionGame.OrionCharAI_JungleBoss.RequestReplicatedAnimation
// 0x0008 (0x0008 - 0x0000)
struct OrionCharAI_JungleBoss_RequestReplicatedAnimation final
{
public:
	EOrionMinionPrioritizedBehavior               Animation;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AttackId;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAI_JungleBoss_RequestReplicatedAnimation) == 0x000004, "Wrong alignment on OrionCharAI_JungleBoss_RequestReplicatedAnimation");
static_assert(sizeof(OrionCharAI_JungleBoss_RequestReplicatedAnimation) == 0x000008, "Wrong size on OrionCharAI_JungleBoss_RequestReplicatedAnimation");
static_assert(offsetof(OrionCharAI_JungleBoss_RequestReplicatedAnimation, Animation) == 0x000000, "Member 'OrionCharAI_JungleBoss_RequestReplicatedAnimation::Animation' has a wrong offset!");
static_assert(offsetof(OrionCharAI_JungleBoss_RequestReplicatedAnimation, AttackId) == 0x000004, "Member 'OrionCharAI_JungleBoss_RequestReplicatedAnimation::AttackId' has a wrong offset!");

// Function OrionGame.OrionCharAI_JungleBoss.SetDependency
// 0x0030 (0x0030 - 0x0000)
struct OrionCharAI_JungleBoss_SetDependency final
{
public:
	struct FObjectiveDependency                   Dependecy;                                         // 0x0000(0x0030)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAI_JungleBoss_SetDependency) == 0x000008, "Wrong alignment on OrionCharAI_JungleBoss_SetDependency");
static_assert(sizeof(OrionCharAI_JungleBoss_SetDependency) == 0x000030, "Wrong size on OrionCharAI_JungleBoss_SetDependency");
static_assert(offsetof(OrionCharAI_JungleBoss_SetDependency, Dependecy) == 0x000000, "Member 'OrionCharAI_JungleBoss_SetDependency::Dependecy' has a wrong offset!");

// Function OrionGame.OrionCharAI_JungleBoss.GetBestTarget
// 0x0010 (0x0010 - 0x0000)
struct OrionCharAI_JungleBoss_GetBestTarget final
{
public:
	EOrionJungleTarget                            Mode;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrionChar*                             ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAI_JungleBoss_GetBestTarget) == 0x000008, "Wrong alignment on OrionCharAI_JungleBoss_GetBestTarget");
static_assert(sizeof(OrionCharAI_JungleBoss_GetBestTarget) == 0x000010, "Wrong size on OrionCharAI_JungleBoss_GetBestTarget");
static_assert(offsetof(OrionCharAI_JungleBoss_GetBestTarget, Mode) == 0x000000, "Member 'OrionCharAI_JungleBoss_GetBestTarget::Mode' has a wrong offset!");
static_assert(offsetof(OrionCharAI_JungleBoss_GetBestTarget, ReturnValue) == 0x000008, "Member 'OrionCharAI_JungleBoss_GetBestTarget::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharAI_JungleBoss.GetCurrentTarget
// 0x0008 (0x0008 - 0x0000)
struct OrionCharAI_JungleBoss_GetCurrentTarget final
{
public:
	class AOrionChar*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAI_JungleBoss_GetCurrentTarget) == 0x000008, "Wrong alignment on OrionCharAI_JungleBoss_GetCurrentTarget");
static_assert(sizeof(OrionCharAI_JungleBoss_GetCurrentTarget) == 0x000008, "Wrong size on OrionCharAI_JungleBoss_GetCurrentTarget");
static_assert(offsetof(OrionCharAI_JungleBoss_GetCurrentTarget, ReturnValue) == 0x000000, "Member 'OrionCharAI_JungleBoss_GetCurrentTarget::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharAI_JungleBoss.HasFinishedSpawning
// 0x0001 (0x0001 - 0x0000)
struct OrionCharAI_JungleBoss_HasFinishedSpawning final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAI_JungleBoss_HasFinishedSpawning) == 0x000001, "Wrong alignment on OrionCharAI_JungleBoss_HasFinishedSpawning");
static_assert(sizeof(OrionCharAI_JungleBoss_HasFinishedSpawning) == 0x000001, "Wrong size on OrionCharAI_JungleBoss_HasFinishedSpawning");
static_assert(offsetof(OrionCharAI_JungleBoss_HasFinishedSpawning, ReturnValue) == 0x000000, "Member 'OrionCharAI_JungleBoss_HasFinishedSpawning::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharAI_PrimeHelixOld.RequestReplicatedAttackAnimation
// 0x0004 (0x0004 - 0x0000)
struct OrionCharAI_PrimeHelixOld_RequestReplicatedAttackAnimation final
{
public:
	int32                                         SpecialAttackId;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAI_PrimeHelixOld_RequestReplicatedAttackAnimation) == 0x000004, "Wrong alignment on OrionCharAI_PrimeHelixOld_RequestReplicatedAttackAnimation");
static_assert(sizeof(OrionCharAI_PrimeHelixOld_RequestReplicatedAttackAnimation) == 0x000004, "Wrong size on OrionCharAI_PrimeHelixOld_RequestReplicatedAttackAnimation");
static_assert(offsetof(OrionCharAI_PrimeHelixOld_RequestReplicatedAttackAnimation, SpecialAttackId) == 0x000000, "Member 'OrionCharAI_PrimeHelixOld_RequestReplicatedAttackAnimation::SpecialAttackId' has a wrong offset!");

// Function OrionGame.OrionCharAI_PrimeHelixOld.GetConeAttackLocations
// 0x0010 (0x0010 - 0x0000)
struct OrionCharAI_PrimeHelixOld_GetConeAttackLocations final
{
public:
	TArray<struct FVector>                        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharAI_PrimeHelixOld_GetConeAttackLocations) == 0x000008, "Wrong alignment on OrionCharAI_PrimeHelixOld_GetConeAttackLocations");
static_assert(sizeof(OrionCharAI_PrimeHelixOld_GetConeAttackLocations) == 0x000010, "Wrong size on OrionCharAI_PrimeHelixOld_GetConeAttackLocations");
static_assert(offsetof(OrionCharAI_PrimeHelixOld_GetConeAttackLocations, ReturnValue) == 0x000000, "Member 'OrionCharAI_PrimeHelixOld_GetConeAttackLocations::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharMovementComponent.ApplyKnockback
// 0x0010 (0x0010 - 0x0000)
struct OrionCharMovementComponent_ApplyKnockback final
{
public:
	struct FVector                                Direction;                                         // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceXY;                                        // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharMovementComponent_ApplyKnockback) == 0x000004, "Wrong alignment on OrionCharMovementComponent_ApplyKnockback");
static_assert(sizeof(OrionCharMovementComponent_ApplyKnockback) == 0x000010, "Wrong size on OrionCharMovementComponent_ApplyKnockback");
static_assert(offsetof(OrionCharMovementComponent_ApplyKnockback, Direction) == 0x000000, "Member 'OrionCharMovementComponent_ApplyKnockback::Direction' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_ApplyKnockback, DistanceXY) == 0x00000C, "Member 'OrionCharMovementComponent_ApplyKnockback::DistanceXY' has a wrong offset!");

// Function OrionGame.OrionCharMovementComponent.ApplyKnockup
// 0x0004 (0x0004 - 0x0000)
struct OrionCharMovementComponent_ApplyKnockup final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharMovementComponent_ApplyKnockup) == 0x000004, "Wrong alignment on OrionCharMovementComponent_ApplyKnockup");
static_assert(sizeof(OrionCharMovementComponent_ApplyKnockup) == 0x000004, "Wrong size on OrionCharMovementComponent_ApplyKnockup");
static_assert(offsetof(OrionCharMovementComponent_ApplyKnockup, Distance) == 0x000000, "Member 'OrionCharMovementComponent_ApplyKnockup::Distance' has a wrong offset!");

// Function OrionGame.OrionCharMovementComponent.BeginHover
// 0x0028 (0x0028 - 0x0000)
struct OrionCharMovementComponent_BeginHover final
{
public:
	ECharHoverMovement                            InHoverMovementType;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InDesiredHeightOffFloor;                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InInitialZOffsetMinimum;                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InUpwardStrength;                                  // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InUpwardMaxSpeed;                                  // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InDownwardStrength;                                // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InDownwardMaxSpeed;                                // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InHoverTraceDistance;                              // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InTraceResultNormalZThreshold;                     // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInDisplayDebug;                                   // 0x0024(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionCharMovementComponent_BeginHover) == 0x000004, "Wrong alignment on OrionCharMovementComponent_BeginHover");
static_assert(sizeof(OrionCharMovementComponent_BeginHover) == 0x000028, "Wrong size on OrionCharMovementComponent_BeginHover");
static_assert(offsetof(OrionCharMovementComponent_BeginHover, InHoverMovementType) == 0x000000, "Member 'OrionCharMovementComponent_BeginHover::InHoverMovementType' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_BeginHover, InDesiredHeightOffFloor) == 0x000004, "Member 'OrionCharMovementComponent_BeginHover::InDesiredHeightOffFloor' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_BeginHover, InInitialZOffsetMinimum) == 0x000008, "Member 'OrionCharMovementComponent_BeginHover::InInitialZOffsetMinimum' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_BeginHover, InUpwardStrength) == 0x00000C, "Member 'OrionCharMovementComponent_BeginHover::InUpwardStrength' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_BeginHover, InUpwardMaxSpeed) == 0x000010, "Member 'OrionCharMovementComponent_BeginHover::InUpwardMaxSpeed' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_BeginHover, InDownwardStrength) == 0x000014, "Member 'OrionCharMovementComponent_BeginHover::InDownwardStrength' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_BeginHover, InDownwardMaxSpeed) == 0x000018, "Member 'OrionCharMovementComponent_BeginHover::InDownwardMaxSpeed' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_BeginHover, InHoverTraceDistance) == 0x00001C, "Member 'OrionCharMovementComponent_BeginHover::InHoverTraceDistance' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_BeginHover, InTraceResultNormalZThreshold) == 0x000020, "Member 'OrionCharMovementComponent_BeginHover::InTraceResultNormalZThreshold' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_BeginHover, bInDisplayDebug) == 0x000024, "Member 'OrionCharMovementComponent_BeginHover::bInDisplayDebug' has a wrong offset!");

// Function OrionGame.OrionCharMovementComponent.GetHover_bDisplayDebug
// 0x0001 (0x0001 - 0x0000)
struct OrionCharMovementComponent_GetHover_bDisplayDebug final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharMovementComponent_GetHover_bDisplayDebug) == 0x000001, "Wrong alignment on OrionCharMovementComponent_GetHover_bDisplayDebug");
static_assert(sizeof(OrionCharMovementComponent_GetHover_bDisplayDebug) == 0x000001, "Wrong size on OrionCharMovementComponent_GetHover_bDisplayDebug");
static_assert(offsetof(OrionCharMovementComponent_GetHover_bDisplayDebug, ReturnValue) == 0x000000, "Member 'OrionCharMovementComponent_GetHover_bDisplayDebug::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharMovementComponent.GetHover_DesiredHeightOffFloor
// 0x0004 (0x0004 - 0x0000)
struct OrionCharMovementComponent_GetHover_DesiredHeightOffFloor final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharMovementComponent_GetHover_DesiredHeightOffFloor) == 0x000004, "Wrong alignment on OrionCharMovementComponent_GetHover_DesiredHeightOffFloor");
static_assert(sizeof(OrionCharMovementComponent_GetHover_DesiredHeightOffFloor) == 0x000004, "Wrong size on OrionCharMovementComponent_GetHover_DesiredHeightOffFloor");
static_assert(offsetof(OrionCharMovementComponent_GetHover_DesiredHeightOffFloor, ReturnValue) == 0x000000, "Member 'OrionCharMovementComponent_GetHover_DesiredHeightOffFloor::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharMovementComponent.GetHover_DownwardMaxSpeed
// 0x0004 (0x0004 - 0x0000)
struct OrionCharMovementComponent_GetHover_DownwardMaxSpeed final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharMovementComponent_GetHover_DownwardMaxSpeed) == 0x000004, "Wrong alignment on OrionCharMovementComponent_GetHover_DownwardMaxSpeed");
static_assert(sizeof(OrionCharMovementComponent_GetHover_DownwardMaxSpeed) == 0x000004, "Wrong size on OrionCharMovementComponent_GetHover_DownwardMaxSpeed");
static_assert(offsetof(OrionCharMovementComponent_GetHover_DownwardMaxSpeed, ReturnValue) == 0x000000, "Member 'OrionCharMovementComponent_GetHover_DownwardMaxSpeed::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharMovementComponent.GetHover_DownwardStrength
// 0x0004 (0x0004 - 0x0000)
struct OrionCharMovementComponent_GetHover_DownwardStrength final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharMovementComponent_GetHover_DownwardStrength) == 0x000004, "Wrong alignment on OrionCharMovementComponent_GetHover_DownwardStrength");
static_assert(sizeof(OrionCharMovementComponent_GetHover_DownwardStrength) == 0x000004, "Wrong size on OrionCharMovementComponent_GetHover_DownwardStrength");
static_assert(offsetof(OrionCharMovementComponent_GetHover_DownwardStrength, ReturnValue) == 0x000000, "Member 'OrionCharMovementComponent_GetHover_DownwardStrength::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharMovementComponent.GetHover_HoverTraceDistance
// 0x0004 (0x0004 - 0x0000)
struct OrionCharMovementComponent_GetHover_HoverTraceDistance final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharMovementComponent_GetHover_HoverTraceDistance) == 0x000004, "Wrong alignment on OrionCharMovementComponent_GetHover_HoverTraceDistance");
static_assert(sizeof(OrionCharMovementComponent_GetHover_HoverTraceDistance) == 0x000004, "Wrong size on OrionCharMovementComponent_GetHover_HoverTraceDistance");
static_assert(offsetof(OrionCharMovementComponent_GetHover_HoverTraceDistance, ReturnValue) == 0x000000, "Member 'OrionCharMovementComponent_GetHover_HoverTraceDistance::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharMovementComponent.GetHover_MovementType
// 0x0001 (0x0001 - 0x0000)
struct OrionCharMovementComponent_GetHover_MovementType final
{
public:
	ECharHoverMovement                            ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharMovementComponent_GetHover_MovementType) == 0x000001, "Wrong alignment on OrionCharMovementComponent_GetHover_MovementType");
static_assert(sizeof(OrionCharMovementComponent_GetHover_MovementType) == 0x000001, "Wrong size on OrionCharMovementComponent_GetHover_MovementType");
static_assert(offsetof(OrionCharMovementComponent_GetHover_MovementType, ReturnValue) == 0x000000, "Member 'OrionCharMovementComponent_GetHover_MovementType::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharMovementComponent.GetHover_TraceResultNormalZThreshold
// 0x0004 (0x0004 - 0x0000)
struct OrionCharMovementComponent_GetHover_TraceResultNormalZThreshold final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharMovementComponent_GetHover_TraceResultNormalZThreshold) == 0x000004, "Wrong alignment on OrionCharMovementComponent_GetHover_TraceResultNormalZThreshold");
static_assert(sizeof(OrionCharMovementComponent_GetHover_TraceResultNormalZThreshold) == 0x000004, "Wrong size on OrionCharMovementComponent_GetHover_TraceResultNormalZThreshold");
static_assert(offsetof(OrionCharMovementComponent_GetHover_TraceResultNormalZThreshold, ReturnValue) == 0x000000, "Member 'OrionCharMovementComponent_GetHover_TraceResultNormalZThreshold::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharMovementComponent.GetHover_UpwardMaxSpeed
// 0x0004 (0x0004 - 0x0000)
struct OrionCharMovementComponent_GetHover_UpwardMaxSpeed final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharMovementComponent_GetHover_UpwardMaxSpeed) == 0x000004, "Wrong alignment on OrionCharMovementComponent_GetHover_UpwardMaxSpeed");
static_assert(sizeof(OrionCharMovementComponent_GetHover_UpwardMaxSpeed) == 0x000004, "Wrong size on OrionCharMovementComponent_GetHover_UpwardMaxSpeed");
static_assert(offsetof(OrionCharMovementComponent_GetHover_UpwardMaxSpeed, ReturnValue) == 0x000000, "Member 'OrionCharMovementComponent_GetHover_UpwardMaxSpeed::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharMovementComponent.GetHover_UpwardStrength
// 0x0004 (0x0004 - 0x0000)
struct OrionCharMovementComponent_GetHover_UpwardStrength final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharMovementComponent_GetHover_UpwardStrength) == 0x000004, "Wrong alignment on OrionCharMovementComponent_GetHover_UpwardStrength");
static_assert(sizeof(OrionCharMovementComponent_GetHover_UpwardStrength) == 0x000004, "Wrong size on OrionCharMovementComponent_GetHover_UpwardStrength");
static_assert(offsetof(OrionCharMovementComponent_GetHover_UpwardStrength, ReturnValue) == 0x000000, "Member 'OrionCharMovementComponent_GetHover_UpwardStrength::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharMovementComponent.GetHover_VelocityLeadTimeStepMult
// 0x0004 (0x0004 - 0x0000)
struct OrionCharMovementComponent_GetHover_VelocityLeadTimeStepMult final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharMovementComponent_GetHover_VelocityLeadTimeStepMult) == 0x000004, "Wrong alignment on OrionCharMovementComponent_GetHover_VelocityLeadTimeStepMult");
static_assert(sizeof(OrionCharMovementComponent_GetHover_VelocityLeadTimeStepMult) == 0x000004, "Wrong size on OrionCharMovementComponent_GetHover_VelocityLeadTimeStepMult");
static_assert(offsetof(OrionCharMovementComponent_GetHover_VelocityLeadTimeStepMult, ReturnValue) == 0x000000, "Member 'OrionCharMovementComponent_GetHover_VelocityLeadTimeStepMult::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCharMovementComponent.LaunchInDirection
// 0x0014 (0x0014 - 0x0000)
struct OrionCharMovementComponent_LaunchInDirection final
{
public:
	struct FVector                                Direction;                                         // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchVelocity;                                    // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockAirControl;                                   // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionCharMovementComponent_LaunchInDirection) == 0x000004, "Wrong alignment on OrionCharMovementComponent_LaunchInDirection");
static_assert(sizeof(OrionCharMovementComponent_LaunchInDirection) == 0x000014, "Wrong size on OrionCharMovementComponent_LaunchInDirection");
static_assert(offsetof(OrionCharMovementComponent_LaunchInDirection, Direction) == 0x000000, "Member 'OrionCharMovementComponent_LaunchInDirection::Direction' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_LaunchInDirection, LaunchVelocity) == 0x00000C, "Member 'OrionCharMovementComponent_LaunchInDirection::LaunchVelocity' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_LaunchInDirection, bLockAirControl) == 0x000010, "Member 'OrionCharMovementComponent_LaunchInDirection::bLockAirControl' has a wrong offset!");

// Function OrionGame.OrionCharMovementComponent.LaunchInDirectionFromTargetData
// 0x0028 (0x0028 - 0x0000)
struct OrionCharMovementComponent_LaunchInDirectionFromTargetData final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetDataHandle;                                  // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         LaunchVelocity;                                    // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockAirControl;                                   // 0x0024(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionCharMovementComponent_LaunchInDirectionFromTargetData) == 0x000008, "Wrong alignment on OrionCharMovementComponent_LaunchInDirectionFromTargetData");
static_assert(sizeof(OrionCharMovementComponent_LaunchInDirectionFromTargetData) == 0x000028, "Wrong size on OrionCharMovementComponent_LaunchInDirectionFromTargetData");
static_assert(offsetof(OrionCharMovementComponent_LaunchInDirectionFromTargetData, TargetDataHandle) == 0x000000, "Member 'OrionCharMovementComponent_LaunchInDirectionFromTargetData::TargetDataHandle' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_LaunchInDirectionFromTargetData, LaunchVelocity) == 0x000020, "Member 'OrionCharMovementComponent_LaunchInDirectionFromTargetData::LaunchVelocity' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_LaunchInDirectionFromTargetData, bLockAirControl) == 0x000024, "Member 'OrionCharMovementComponent_LaunchInDirectionFromTargetData::bLockAirControl' has a wrong offset!");

// Function OrionGame.OrionCharMovementComponent.LaunchToPoint
// 0x0014 (0x0014 - 0x0000)
struct OrionCharMovementComponent_LaunchToPoint final
{
public:
	struct FVector                                EndPoint;                                          // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchVelocityXY;                                  // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockAirControl;                                   // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionCharMovementComponent_LaunchToPoint) == 0x000004, "Wrong alignment on OrionCharMovementComponent_LaunchToPoint");
static_assert(sizeof(OrionCharMovementComponent_LaunchToPoint) == 0x000014, "Wrong size on OrionCharMovementComponent_LaunchToPoint");
static_assert(offsetof(OrionCharMovementComponent_LaunchToPoint, EndPoint) == 0x000000, "Member 'OrionCharMovementComponent_LaunchToPoint::EndPoint' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_LaunchToPoint, LaunchVelocityXY) == 0x00000C, "Member 'OrionCharMovementComponent_LaunchToPoint::LaunchVelocityXY' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_LaunchToPoint, bLockAirControl) == 0x000010, "Member 'OrionCharMovementComponent_LaunchToPoint::bLockAirControl' has a wrong offset!");

// Function OrionGame.OrionCharMovementComponent.LaunchToPointFromTargetData
// 0x0028 (0x0028 - 0x0000)
struct OrionCharMovementComponent_LaunchToPointFromTargetData final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetDataHandle;                                  // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         LaunchVelocityXY;                                  // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockAirControl;                                   // 0x0024(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionCharMovementComponent_LaunchToPointFromTargetData) == 0x000008, "Wrong alignment on OrionCharMovementComponent_LaunchToPointFromTargetData");
static_assert(sizeof(OrionCharMovementComponent_LaunchToPointFromTargetData) == 0x000028, "Wrong size on OrionCharMovementComponent_LaunchToPointFromTargetData");
static_assert(offsetof(OrionCharMovementComponent_LaunchToPointFromTargetData, TargetDataHandle) == 0x000000, "Member 'OrionCharMovementComponent_LaunchToPointFromTargetData::TargetDataHandle' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_LaunchToPointFromTargetData, LaunchVelocityXY) == 0x000020, "Member 'OrionCharMovementComponent_LaunchToPointFromTargetData::LaunchVelocityXY' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_LaunchToPointFromTargetData, bLockAirControl) == 0x000024, "Member 'OrionCharMovementComponent_LaunchToPointFromTargetData::bLockAirControl' has a wrong offset!");

// Function OrionGame.OrionCharMovementComponent.NudgeMovement
// 0x000C (0x000C - 0x0000)
struct OrionCharMovementComponent_NudgeMovement final
{
public:
	struct FVector                                ImpulseToAdd;                                      // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharMovementComponent_NudgeMovement) == 0x000004, "Wrong alignment on OrionCharMovementComponent_NudgeMovement");
static_assert(sizeof(OrionCharMovementComponent_NudgeMovement) == 0x00000C, "Wrong size on OrionCharMovementComponent_NudgeMovement");
static_assert(offsetof(OrionCharMovementComponent_NudgeMovement, ImpulseToAdd) == 0x000000, "Member 'OrionCharMovementComponent_NudgeMovement::ImpulseToAdd' has a wrong offset!");

// Function OrionGame.OrionCharMovementComponent.OrionServerMove
// 0x0048 (0x0048 - 0x0000)
struct OrionCharMovementComponent_OrionServerMove final
{
public:
	float                                         Timestamp;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize10                  InAccel;                                           // 0x0004(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 ClientLoc;                                         // 0x0010(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         CompressedMoveFlags;                               // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ClientRoll;                                        // 0x001D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        View;                                              // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    ClientMovementBase;                                // 0x0028(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ClientBaseBoneName;                                // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ClientMovementMode;                                // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMovementAbilitySyncKey                MovementAbilitySyncKey;                            // 0x003C(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharMovementComponent_OrionServerMove) == 0x000008, "Wrong alignment on OrionCharMovementComponent_OrionServerMove");
static_assert(sizeof(OrionCharMovementComponent_OrionServerMove) == 0x000048, "Wrong size on OrionCharMovementComponent_OrionServerMove");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMove, Timestamp) == 0x000000, "Member 'OrionCharMovementComponent_OrionServerMove::Timestamp' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMove, InAccel) == 0x000004, "Member 'OrionCharMovementComponent_OrionServerMove::InAccel' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMove, ClientLoc) == 0x000010, "Member 'OrionCharMovementComponent_OrionServerMove::ClientLoc' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMove, CompressedMoveFlags) == 0x00001C, "Member 'OrionCharMovementComponent_OrionServerMove::CompressedMoveFlags' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMove, ClientRoll) == 0x00001D, "Member 'OrionCharMovementComponent_OrionServerMove::ClientRoll' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMove, View) == 0x000020, "Member 'OrionCharMovementComponent_OrionServerMove::View' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMove, ClientMovementBase) == 0x000028, "Member 'OrionCharMovementComponent_OrionServerMove::ClientMovementBase' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMove, ClientBaseBoneName) == 0x000030, "Member 'OrionCharMovementComponent_OrionServerMove::ClientBaseBoneName' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMove, ClientMovementMode) == 0x000038, "Member 'OrionCharMovementComponent_OrionServerMove::ClientMovementMode' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMove, MovementAbilitySyncKey) == 0x00003C, "Member 'OrionCharMovementComponent_OrionServerMove::MovementAbilitySyncKey' has a wrong offset!");

// Function OrionGame.OrionCharMovementComponent.OrionServerMoveDual
// 0x0060 (0x0060 - 0x0000)
struct OrionCharMovementComponent_OrionServerMoveDual final
{
public:
	float                                         TimeStamp0;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize10                  InAccel0;                                          // 0x0004(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         PendingFlags;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        View0;                                             // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timestamp;                                         // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize10                  InAccel;                                           // 0x001C(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 ClientLoc;                                         // 0x0028(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         NewFlags;                                          // 0x0034(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ClientRoll;                                        // 0x0035(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        View;                                              // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    ClientMovementBase;                                // 0x0040(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ClientBaseBoneName;                                // 0x0048(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ClientMovementMode;                                // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMovementAbilitySyncKey                MovementAbilitySyncKey;                            // 0x0054(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharMovementComponent_OrionServerMoveDual) == 0x000008, "Wrong alignment on OrionCharMovementComponent_OrionServerMoveDual");
static_assert(sizeof(OrionCharMovementComponent_OrionServerMoveDual) == 0x000060, "Wrong size on OrionCharMovementComponent_OrionServerMoveDual");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMoveDual, TimeStamp0) == 0x000000, "Member 'OrionCharMovementComponent_OrionServerMoveDual::TimeStamp0' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMoveDual, InAccel0) == 0x000004, "Member 'OrionCharMovementComponent_OrionServerMoveDual::InAccel0' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMoveDual, PendingFlags) == 0x000010, "Member 'OrionCharMovementComponent_OrionServerMoveDual::PendingFlags' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMoveDual, View0) == 0x000014, "Member 'OrionCharMovementComponent_OrionServerMoveDual::View0' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMoveDual, Timestamp) == 0x000018, "Member 'OrionCharMovementComponent_OrionServerMoveDual::Timestamp' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMoveDual, InAccel) == 0x00001C, "Member 'OrionCharMovementComponent_OrionServerMoveDual::InAccel' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMoveDual, ClientLoc) == 0x000028, "Member 'OrionCharMovementComponent_OrionServerMoveDual::ClientLoc' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMoveDual, NewFlags) == 0x000034, "Member 'OrionCharMovementComponent_OrionServerMoveDual::NewFlags' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMoveDual, ClientRoll) == 0x000035, "Member 'OrionCharMovementComponent_OrionServerMoveDual::ClientRoll' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMoveDual, View) == 0x000038, "Member 'OrionCharMovementComponent_OrionServerMoveDual::View' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMoveDual, ClientMovementBase) == 0x000040, "Member 'OrionCharMovementComponent_OrionServerMoveDual::ClientMovementBase' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMoveDual, ClientBaseBoneName) == 0x000048, "Member 'OrionCharMovementComponent_OrionServerMoveDual::ClientBaseBoneName' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMoveDual, ClientMovementMode) == 0x000050, "Member 'OrionCharMovementComponent_OrionServerMoveDual::ClientMovementMode' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMoveDual, MovementAbilitySyncKey) == 0x000054, "Member 'OrionCharMovementComponent_OrionServerMoveDual::MovementAbilitySyncKey' has a wrong offset!");

// Function OrionGame.OrionCharMovementComponent.OrionServerMoveDualHybridRootMotion
// 0x0060 (0x0060 - 0x0000)
struct OrionCharMovementComponent_OrionServerMoveDualHybridRootMotion final
{
public:
	float                                         TimeStamp0;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize10                  InAccel0;                                          // 0x0004(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         PendingFlags;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        View0;                                             // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timestamp;                                         // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize10                  InAccel;                                           // 0x001C(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 ClientLoc;                                         // 0x0028(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         NewFlags;                                          // 0x0034(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ClientRoll;                                        // 0x0035(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        View;                                              // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    ClientMovementBase;                                // 0x0040(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ClientBaseBoneName;                                // 0x0048(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ClientMovementMode;                                // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMovementAbilitySyncKey                MovementAbilitySyncKey;                            // 0x0054(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharMovementComponent_OrionServerMoveDualHybridRootMotion) == 0x000008, "Wrong alignment on OrionCharMovementComponent_OrionServerMoveDualHybridRootMotion");
static_assert(sizeof(OrionCharMovementComponent_OrionServerMoveDualHybridRootMotion) == 0x000060, "Wrong size on OrionCharMovementComponent_OrionServerMoveDualHybridRootMotion");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMoveDualHybridRootMotion, TimeStamp0) == 0x000000, "Member 'OrionCharMovementComponent_OrionServerMoveDualHybridRootMotion::TimeStamp0' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMoveDualHybridRootMotion, InAccel0) == 0x000004, "Member 'OrionCharMovementComponent_OrionServerMoveDualHybridRootMotion::InAccel0' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMoveDualHybridRootMotion, PendingFlags) == 0x000010, "Member 'OrionCharMovementComponent_OrionServerMoveDualHybridRootMotion::PendingFlags' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMoveDualHybridRootMotion, View0) == 0x000014, "Member 'OrionCharMovementComponent_OrionServerMoveDualHybridRootMotion::View0' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMoveDualHybridRootMotion, Timestamp) == 0x000018, "Member 'OrionCharMovementComponent_OrionServerMoveDualHybridRootMotion::Timestamp' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMoveDualHybridRootMotion, InAccel) == 0x00001C, "Member 'OrionCharMovementComponent_OrionServerMoveDualHybridRootMotion::InAccel' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMoveDualHybridRootMotion, ClientLoc) == 0x000028, "Member 'OrionCharMovementComponent_OrionServerMoveDualHybridRootMotion::ClientLoc' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMoveDualHybridRootMotion, NewFlags) == 0x000034, "Member 'OrionCharMovementComponent_OrionServerMoveDualHybridRootMotion::NewFlags' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMoveDualHybridRootMotion, ClientRoll) == 0x000035, "Member 'OrionCharMovementComponent_OrionServerMoveDualHybridRootMotion::ClientRoll' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMoveDualHybridRootMotion, View) == 0x000038, "Member 'OrionCharMovementComponent_OrionServerMoveDualHybridRootMotion::View' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMoveDualHybridRootMotion, ClientMovementBase) == 0x000040, "Member 'OrionCharMovementComponent_OrionServerMoveDualHybridRootMotion::ClientMovementBase' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMoveDualHybridRootMotion, ClientBaseBoneName) == 0x000048, "Member 'OrionCharMovementComponent_OrionServerMoveDualHybridRootMotion::ClientBaseBoneName' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMoveDualHybridRootMotion, ClientMovementMode) == 0x000050, "Member 'OrionCharMovementComponent_OrionServerMoveDualHybridRootMotion::ClientMovementMode' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMoveDualHybridRootMotion, MovementAbilitySyncKey) == 0x000054, "Member 'OrionCharMovementComponent_OrionServerMoveDualHybridRootMotion::MovementAbilitySyncKey' has a wrong offset!");

// Function OrionGame.OrionCharMovementComponent.OrionServerMoveOld
// 0x0020 (0x0020 - 0x0000)
struct OrionCharMovementComponent_OrionServerMoveOld final
{
public:
	float                                         OldTimeStamp;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize10                  OldAccel;                                          // 0x0004(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         OldMoveFlags;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMovementAbilitySyncKey                MovementAbilitySyncKey;                            // 0x0014(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharMovementComponent_OrionServerMoveOld) == 0x000004, "Wrong alignment on OrionCharMovementComponent_OrionServerMoveOld");
static_assert(sizeof(OrionCharMovementComponent_OrionServerMoveOld) == 0x000020, "Wrong size on OrionCharMovementComponent_OrionServerMoveOld");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMoveOld, OldTimeStamp) == 0x000000, "Member 'OrionCharMovementComponent_OrionServerMoveOld::OldTimeStamp' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMoveOld, OldAccel) == 0x000004, "Member 'OrionCharMovementComponent_OrionServerMoveOld::OldAccel' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMoveOld, OldMoveFlags) == 0x000010, "Member 'OrionCharMovementComponent_OrionServerMoveOld::OldMoveFlags' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_OrionServerMoveOld, MovementAbilitySyncKey) == 0x000014, "Member 'OrionCharMovementComponent_OrionServerMoveOld::MovementAbilitySyncKey' has a wrong offset!");

// Function OrionGame.OrionCharMovementComponent.SetHover_bDisplayDebug
// 0x0001 (0x0001 - 0x0000)
struct OrionCharMovementComponent_SetHover_bDisplayDebug final
{
public:
	bool                                          bValue;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharMovementComponent_SetHover_bDisplayDebug) == 0x000001, "Wrong alignment on OrionCharMovementComponent_SetHover_bDisplayDebug");
static_assert(sizeof(OrionCharMovementComponent_SetHover_bDisplayDebug) == 0x000001, "Wrong size on OrionCharMovementComponent_SetHover_bDisplayDebug");
static_assert(offsetof(OrionCharMovementComponent_SetHover_bDisplayDebug, bValue) == 0x000000, "Member 'OrionCharMovementComponent_SetHover_bDisplayDebug::bValue' has a wrong offset!");

// Function OrionGame.OrionCharMovementComponent.SetHover_DesiredHeightOffFloor
// 0x0004 (0x0004 - 0x0000)
struct OrionCharMovementComponent_SetHover_DesiredHeightOffFloor final
{
public:
	float                                         FValue;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharMovementComponent_SetHover_DesiredHeightOffFloor) == 0x000004, "Wrong alignment on OrionCharMovementComponent_SetHover_DesiredHeightOffFloor");
static_assert(sizeof(OrionCharMovementComponent_SetHover_DesiredHeightOffFloor) == 0x000004, "Wrong size on OrionCharMovementComponent_SetHover_DesiredHeightOffFloor");
static_assert(offsetof(OrionCharMovementComponent_SetHover_DesiredHeightOffFloor, FValue) == 0x000000, "Member 'OrionCharMovementComponent_SetHover_DesiredHeightOffFloor::FValue' has a wrong offset!");

// Function OrionGame.OrionCharMovementComponent.SetHover_DownwardMaxSpeed
// 0x0004 (0x0004 - 0x0000)
struct OrionCharMovementComponent_SetHover_DownwardMaxSpeed final
{
public:
	float                                         FValue;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharMovementComponent_SetHover_DownwardMaxSpeed) == 0x000004, "Wrong alignment on OrionCharMovementComponent_SetHover_DownwardMaxSpeed");
static_assert(sizeof(OrionCharMovementComponent_SetHover_DownwardMaxSpeed) == 0x000004, "Wrong size on OrionCharMovementComponent_SetHover_DownwardMaxSpeed");
static_assert(offsetof(OrionCharMovementComponent_SetHover_DownwardMaxSpeed, FValue) == 0x000000, "Member 'OrionCharMovementComponent_SetHover_DownwardMaxSpeed::FValue' has a wrong offset!");

// Function OrionGame.OrionCharMovementComponent.SetHover_DownwardStrength
// 0x0004 (0x0004 - 0x0000)
struct OrionCharMovementComponent_SetHover_DownwardStrength final
{
public:
	float                                         FValue;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharMovementComponent_SetHover_DownwardStrength) == 0x000004, "Wrong alignment on OrionCharMovementComponent_SetHover_DownwardStrength");
static_assert(sizeof(OrionCharMovementComponent_SetHover_DownwardStrength) == 0x000004, "Wrong size on OrionCharMovementComponent_SetHover_DownwardStrength");
static_assert(offsetof(OrionCharMovementComponent_SetHover_DownwardStrength, FValue) == 0x000000, "Member 'OrionCharMovementComponent_SetHover_DownwardStrength::FValue' has a wrong offset!");

// Function OrionGame.OrionCharMovementComponent.SetHover_HoverTraceDistance
// 0x0004 (0x0004 - 0x0000)
struct OrionCharMovementComponent_SetHover_HoverTraceDistance final
{
public:
	float                                         FValue;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharMovementComponent_SetHover_HoverTraceDistance) == 0x000004, "Wrong alignment on OrionCharMovementComponent_SetHover_HoverTraceDistance");
static_assert(sizeof(OrionCharMovementComponent_SetHover_HoverTraceDistance) == 0x000004, "Wrong size on OrionCharMovementComponent_SetHover_HoverTraceDistance");
static_assert(offsetof(OrionCharMovementComponent_SetHover_HoverTraceDistance, FValue) == 0x000000, "Member 'OrionCharMovementComponent_SetHover_HoverTraceDistance::FValue' has a wrong offset!");

// Function OrionGame.OrionCharMovementComponent.SetHover_MovementType
// 0x0001 (0x0001 - 0x0000)
struct OrionCharMovementComponent_SetHover_MovementType final
{
public:
	ECharHoverMovement                            Value;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharMovementComponent_SetHover_MovementType) == 0x000001, "Wrong alignment on OrionCharMovementComponent_SetHover_MovementType");
static_assert(sizeof(OrionCharMovementComponent_SetHover_MovementType) == 0x000001, "Wrong size on OrionCharMovementComponent_SetHover_MovementType");
static_assert(offsetof(OrionCharMovementComponent_SetHover_MovementType, Value) == 0x000000, "Member 'OrionCharMovementComponent_SetHover_MovementType::Value' has a wrong offset!");

// Function OrionGame.OrionCharMovementComponent.SetHover_TraceResultNormalZThreshold
// 0x0004 (0x0004 - 0x0000)
struct OrionCharMovementComponent_SetHover_TraceResultNormalZThreshold final
{
public:
	float                                         FValue;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharMovementComponent_SetHover_TraceResultNormalZThreshold) == 0x000004, "Wrong alignment on OrionCharMovementComponent_SetHover_TraceResultNormalZThreshold");
static_assert(sizeof(OrionCharMovementComponent_SetHover_TraceResultNormalZThreshold) == 0x000004, "Wrong size on OrionCharMovementComponent_SetHover_TraceResultNormalZThreshold");
static_assert(offsetof(OrionCharMovementComponent_SetHover_TraceResultNormalZThreshold, FValue) == 0x000000, "Member 'OrionCharMovementComponent_SetHover_TraceResultNormalZThreshold::FValue' has a wrong offset!");

// Function OrionGame.OrionCharMovementComponent.SetHover_UpwardMaxSpeed
// 0x0004 (0x0004 - 0x0000)
struct OrionCharMovementComponent_SetHover_UpwardMaxSpeed final
{
public:
	float                                         FValue;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharMovementComponent_SetHover_UpwardMaxSpeed) == 0x000004, "Wrong alignment on OrionCharMovementComponent_SetHover_UpwardMaxSpeed");
static_assert(sizeof(OrionCharMovementComponent_SetHover_UpwardMaxSpeed) == 0x000004, "Wrong size on OrionCharMovementComponent_SetHover_UpwardMaxSpeed");
static_assert(offsetof(OrionCharMovementComponent_SetHover_UpwardMaxSpeed, FValue) == 0x000000, "Member 'OrionCharMovementComponent_SetHover_UpwardMaxSpeed::FValue' has a wrong offset!");

// Function OrionGame.OrionCharMovementComponent.SetHover_UpwardStrength
// 0x0004 (0x0004 - 0x0000)
struct OrionCharMovementComponent_SetHover_UpwardStrength final
{
public:
	float                                         FValue;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharMovementComponent_SetHover_UpwardStrength) == 0x000004, "Wrong alignment on OrionCharMovementComponent_SetHover_UpwardStrength");
static_assert(sizeof(OrionCharMovementComponent_SetHover_UpwardStrength) == 0x000004, "Wrong size on OrionCharMovementComponent_SetHover_UpwardStrength");
static_assert(offsetof(OrionCharMovementComponent_SetHover_UpwardStrength, FValue) == 0x000000, "Member 'OrionCharMovementComponent_SetHover_UpwardStrength::FValue' has a wrong offset!");

// Function OrionGame.OrionCharMovementComponent.SetHover_VelocityLeadTimeStepMult
// 0x0004 (0x0004 - 0x0000)
struct OrionCharMovementComponent_SetHover_VelocityLeadTimeStepMult final
{
public:
	float                                         FValue;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharMovementComponent_SetHover_VelocityLeadTimeStepMult) == 0x000004, "Wrong alignment on OrionCharMovementComponent_SetHover_VelocityLeadTimeStepMult");
static_assert(sizeof(OrionCharMovementComponent_SetHover_VelocityLeadTimeStepMult) == 0x000004, "Wrong size on OrionCharMovementComponent_SetHover_VelocityLeadTimeStepMult");
static_assert(offsetof(OrionCharMovementComponent_SetHover_VelocityLeadTimeStepMult, FValue) == 0x000000, "Member 'OrionCharMovementComponent_SetHover_VelocityLeadTimeStepMult::FValue' has a wrong offset!");

// Function OrionGame.OrionCharMovementComponent.SimulateBasicFlight
// 0x002C (0x002C - 0x0000)
struct OrionCharMovementComponent_SimulateBasicFlight final
{
public:
	struct FVector                                StartPoint;                                        // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Distance;                                          // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistancePerIncrement;                           // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxIncrements;                                     // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0020(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCharMovementComponent_SimulateBasicFlight) == 0x000004, "Wrong alignment on OrionCharMovementComponent_SimulateBasicFlight");
static_assert(sizeof(OrionCharMovementComponent_SimulateBasicFlight) == 0x00002C, "Wrong size on OrionCharMovementComponent_SimulateBasicFlight");
static_assert(offsetof(OrionCharMovementComponent_SimulateBasicFlight, StartPoint) == 0x000000, "Member 'OrionCharMovementComponent_SimulateBasicFlight::StartPoint' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_SimulateBasicFlight, Distance) == 0x00000C, "Member 'OrionCharMovementComponent_SimulateBasicFlight::Distance' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_SimulateBasicFlight, MaxDistancePerIncrement) == 0x000018, "Member 'OrionCharMovementComponent_SimulateBasicFlight::MaxDistancePerIncrement' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_SimulateBasicFlight, MaxIncrements) == 0x00001C, "Member 'OrionCharMovementComponent_SimulateBasicFlight::MaxIncrements' has a wrong offset!");
static_assert(offsetof(OrionCharMovementComponent_SimulateBasicFlight, ReturnValue) == 0x000020, "Member 'OrionCharMovementComponent_SimulateBasicFlight::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.GetLocationRotationForSpawnActor
// 0x0020 (0x0020 - 0x0000)
struct OrionPlayerController_Game_GetLocationRotationForSpawnActor final
{
public:
	class AOrionPlayerController_Game*            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutLocation;                                       // 0x0008(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               OutRotation;                                       // 0x0014(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Game_GetLocationRotationForSpawnActor) == 0x000008, "Wrong alignment on OrionPlayerController_Game_GetLocationRotationForSpawnActor");
static_assert(sizeof(OrionPlayerController_Game_GetLocationRotationForSpawnActor) == 0x000020, "Wrong size on OrionPlayerController_Game_GetLocationRotationForSpawnActor");
static_assert(offsetof(OrionPlayerController_Game_GetLocationRotationForSpawnActor, PlayerController) == 0x000000, "Member 'OrionPlayerController_Game_GetLocationRotationForSpawnActor::PlayerController' has a wrong offset!");
static_assert(offsetof(OrionPlayerController_Game_GetLocationRotationForSpawnActor, OutLocation) == 0x000008, "Member 'OrionPlayerController_Game_GetLocationRotationForSpawnActor::OutLocation' has a wrong offset!");
static_assert(offsetof(OrionPlayerController_Game_GetLocationRotationForSpawnActor, OutRotation) == 0x000014, "Member 'OrionPlayerController_Game_GetLocationRotationForSpawnActor::OutRotation' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.ActivateAbilityForPawnCheat
// 0x0010 (0x0010 - 0x0000)
struct OrionPlayerController_Game_ActivateAbilityForPawnCheat final
{
public:
	class AOrionChar*                             InChar;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionAbilityBinding                          InputID;                                           // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPressed;                                          // 0x0009(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionPlayerController_Game_ActivateAbilityForPawnCheat) == 0x000008, "Wrong alignment on OrionPlayerController_Game_ActivateAbilityForPawnCheat");
static_assert(sizeof(OrionPlayerController_Game_ActivateAbilityForPawnCheat) == 0x000010, "Wrong size on OrionPlayerController_Game_ActivateAbilityForPawnCheat");
static_assert(offsetof(OrionPlayerController_Game_ActivateAbilityForPawnCheat, InChar) == 0x000000, "Member 'OrionPlayerController_Game_ActivateAbilityForPawnCheat::InChar' has a wrong offset!");
static_assert(offsetof(OrionPlayerController_Game_ActivateAbilityForPawnCheat, InputID) == 0x000008, "Member 'OrionPlayerController_Game_ActivateAbilityForPawnCheat::InputID' has a wrong offset!");
static_assert(offsetof(OrionPlayerController_Game_ActivateAbilityForPawnCheat, bPressed) == 0x000009, "Member 'OrionPlayerController_Game_ActivateAbilityForPawnCheat::bPressed' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.ActivateAIAbility
// 0x0010 (0x0010 - 0x0000)
struct OrionPlayerController_Game_ActivateAIAbility final
{
public:
	class AOrionChar*                             InChar;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionAbilityBinding                          InputID;                                           // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionPlayerController_Game_ActivateAIAbility) == 0x000008, "Wrong alignment on OrionPlayerController_Game_ActivateAIAbility");
static_assert(sizeof(OrionPlayerController_Game_ActivateAIAbility) == 0x000010, "Wrong size on OrionPlayerController_Game_ActivateAIAbility");
static_assert(offsetof(OrionPlayerController_Game_ActivateAIAbility, InChar) == 0x000000, "Member 'OrionPlayerController_Game_ActivateAIAbility::InChar' has a wrong offset!");
static_assert(offsetof(OrionPlayerController_Game_ActivateAIAbility, InputID) == 0x000008, "Member 'OrionPlayerController_Game_ActivateAIAbility::InputID' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.AddPawnMovementInput
// 0x0020 (0x0020 - 0x0000)
struct OrionPlayerController_Game_AddPawnMovementInput final
{
public:
	class AOrionChar*                             InChar;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldDirection;                                    // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleValue;                                        // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForce;                                            // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionPlayerController_Game_AddPawnMovementInput) == 0x000008, "Wrong alignment on OrionPlayerController_Game_AddPawnMovementInput");
static_assert(sizeof(OrionPlayerController_Game_AddPawnMovementInput) == 0x000020, "Wrong size on OrionPlayerController_Game_AddPawnMovementInput");
static_assert(offsetof(OrionPlayerController_Game_AddPawnMovementInput, InChar) == 0x000000, "Member 'OrionPlayerController_Game_AddPawnMovementInput::InChar' has a wrong offset!");
static_assert(offsetof(OrionPlayerController_Game_AddPawnMovementInput, WorldDirection) == 0x000008, "Member 'OrionPlayerController_Game_AddPawnMovementInput::WorldDirection' has a wrong offset!");
static_assert(offsetof(OrionPlayerController_Game_AddPawnMovementInput, ScaleValue) == 0x000014, "Member 'OrionPlayerController_Game_AddPawnMovementInput::ScaleValue' has a wrong offset!");
static_assert(offsetof(OrionPlayerController_Game_AddPawnMovementInput, bForce) == 0x000018, "Member 'OrionPlayerController_Game_AddPawnMovementInput::bForce' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.CancelAbilityForPawnCheat
// 0x0008 (0x0008 - 0x0000)
struct OrionPlayerController_Game_CancelAbilityForPawnCheat final
{
public:
	class AOrionChar*                             InChar;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Game_CancelAbilityForPawnCheat) == 0x000008, "Wrong alignment on OrionPlayerController_Game_CancelAbilityForPawnCheat");
static_assert(sizeof(OrionPlayerController_Game_CancelAbilityForPawnCheat) == 0x000008, "Wrong size on OrionPlayerController_Game_CancelAbilityForPawnCheat");
static_assert(offsetof(OrionPlayerController_Game_CancelAbilityForPawnCheat, InChar) == 0x000000, "Member 'OrionPlayerController_Game_CancelAbilityForPawnCheat::InChar' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.CancelAllAbilitiesCheat
// 0x0008 (0x0008 - 0x0000)
struct OrionPlayerController_Game_CancelAllAbilitiesCheat final
{
public:
	class AOrionChar*                             InChar;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Game_CancelAllAbilitiesCheat) == 0x000008, "Wrong alignment on OrionPlayerController_Game_CancelAllAbilitiesCheat");
static_assert(sizeof(OrionPlayerController_Game_CancelAllAbilitiesCheat) == 0x000008, "Wrong size on OrionPlayerController_Game_CancelAllAbilitiesCheat");
static_assert(offsetof(OrionPlayerController_Game_CancelAllAbilitiesCheat, InChar) == 0x000000, "Member 'OrionPlayerController_Game_CancelAllAbilitiesCheat::InChar' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.ClientAddMinimapPing
// 0x000C (0x000C - 0x0000)
struct OrionPlayerController_Game_ClientAddMinimapPing final
{
public:
	struct FVector                                PingWorldPosition;                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Game_ClientAddMinimapPing) == 0x000004, "Wrong alignment on OrionPlayerController_Game_ClientAddMinimapPing");
static_assert(sizeof(OrionPlayerController_Game_ClientAddMinimapPing) == 0x00000C, "Wrong size on OrionPlayerController_Game_ClientAddMinimapPing");
static_assert(offsetof(OrionPlayerController_Game_ClientAddMinimapPing, PingWorldPosition) == 0x000000, "Member 'OrionPlayerController_Game_ClientAddMinimapPing::PingWorldPosition' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.ClientKilledBy
// 0x0018 (0x0018 - 0x0000)
struct OrionPlayerController_Game_ClientKilledBy final
{
public:
	class AOrionPlayerState_Game*                 Killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 KilledActor;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Game_ClientKilledBy) == 0x000008, "Wrong alignment on OrionPlayerController_Game_ClientKilledBy");
static_assert(sizeof(OrionPlayerController_Game_ClientKilledBy) == 0x000018, "Wrong size on OrionPlayerController_Game_ClientKilledBy");
static_assert(offsetof(OrionPlayerController_Game_ClientKilledBy, Killer) == 0x000000, "Member 'OrionPlayerController_Game_ClientKilledBy::Killer' has a wrong offset!");
static_assert(offsetof(OrionPlayerController_Game_ClientKilledBy, DamageCauser) == 0x000008, "Member 'OrionPlayerController_Game_ClientKilledBy::DamageCauser' has a wrong offset!");
static_assert(offsetof(OrionPlayerController_Game_ClientKilledBy, KilledActor) == 0x000010, "Member 'OrionPlayerController_Game_ClientKilledBy::KilledActor' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.ClientMatchComplete
// 0x00D0 (0x00D0 - 0x0000)
struct OrionPlayerController_Game_ClientMatchComplete final
{
public:
	struct FMatchCompleteNotification             MatchCompleteNotification;                         // 0x0000(0x00C8)(Parm, NativeAccessSpecifierPublic)
	class FName                                   SurveyQuestionGroupName;                           // 0x00C8(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Game_ClientMatchComplete) == 0x000008, "Wrong alignment on OrionPlayerController_Game_ClientMatchComplete");
static_assert(sizeof(OrionPlayerController_Game_ClientMatchComplete) == 0x0000D0, "Wrong size on OrionPlayerController_Game_ClientMatchComplete");
static_assert(offsetof(OrionPlayerController_Game_ClientMatchComplete, MatchCompleteNotification) == 0x000000, "Member 'OrionPlayerController_Game_ClientMatchComplete::MatchCompleteNotification' has a wrong offset!");
static_assert(offsetof(OrionPlayerController_Game_ClientMatchComplete, SurveyQuestionGroupName) == 0x0000C8, "Member 'OrionPlayerController_Game_ClientMatchComplete::SurveyQuestionGroupName' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.ClientPlayKillcam
// 0x0008 (0x0008 - 0x0000)
struct OrionPlayerController_Game_ClientPlayKillcam final
{
public:
	class APawn*                                  PawnToFocus;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Game_ClientPlayKillcam) == 0x000008, "Wrong alignment on OrionPlayerController_Game_ClientPlayKillcam");
static_assert(sizeof(OrionPlayerController_Game_ClientPlayKillcam) == 0x000008, "Wrong size on OrionPlayerController_Game_ClientPlayKillcam");
static_assert(offsetof(OrionPlayerController_Game_ClientPlayKillcam, PawnToFocus) == 0x000000, "Member 'OrionPlayerController_Game_ClientPlayKillcam::PawnToFocus' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.ClientReceiveTeamCommMessage
// 0x0020 (0x0020 - 0x0000)
struct OrionPlayerController_Game_ClientReceiveTeamCommMessage final
{
public:
	struct FOrionTeamCommMessage                  MESSAGE;                                           // 0x0000(0x0020)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Game_ClientReceiveTeamCommMessage) == 0x000008, "Wrong alignment on OrionPlayerController_Game_ClientReceiveTeamCommMessage");
static_assert(sizeof(OrionPlayerController_Game_ClientReceiveTeamCommMessage) == 0x000020, "Wrong size on OrionPlayerController_Game_ClientReceiveTeamCommMessage");
static_assert(offsetof(OrionPlayerController_Game_ClientReceiveTeamCommMessage, MESSAGE) == 0x000000, "Member 'OrionPlayerController_Game_ClientReceiveTeamCommMessage::MESSAGE' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.ClientSetGravesiteCameraState
// 0x0030 (0x0030 - 0x0000)
struct OrionPlayerController_Game_ClientSetGravesiteCameraState final
{
public:
	EGravesiteCameraState                         GravesiteCameraState;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PositionOfKiller;                                  // 0x0004(0x000C)(ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PositionOfDeath;                                   // 0x0010(0x000C)(ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FacingDir;                                         // 0x001C(0x000C)(ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OptKillerActor;                                    // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Game_ClientSetGravesiteCameraState) == 0x000008, "Wrong alignment on OrionPlayerController_Game_ClientSetGravesiteCameraState");
static_assert(sizeof(OrionPlayerController_Game_ClientSetGravesiteCameraState) == 0x000030, "Wrong size on OrionPlayerController_Game_ClientSetGravesiteCameraState");
static_assert(offsetof(OrionPlayerController_Game_ClientSetGravesiteCameraState, GravesiteCameraState) == 0x000000, "Member 'OrionPlayerController_Game_ClientSetGravesiteCameraState::GravesiteCameraState' has a wrong offset!");
static_assert(offsetof(OrionPlayerController_Game_ClientSetGravesiteCameraState, PositionOfKiller) == 0x000004, "Member 'OrionPlayerController_Game_ClientSetGravesiteCameraState::PositionOfKiller' has a wrong offset!");
static_assert(offsetof(OrionPlayerController_Game_ClientSetGravesiteCameraState, PositionOfDeath) == 0x000010, "Member 'OrionPlayerController_Game_ClientSetGravesiteCameraState::PositionOfDeath' has a wrong offset!");
static_assert(offsetof(OrionPlayerController_Game_ClientSetGravesiteCameraState, FacingDir) == 0x00001C, "Member 'OrionPlayerController_Game_ClientSetGravesiteCameraState::FacingDir' has a wrong offset!");
static_assert(offsetof(OrionPlayerController_Game_ClientSetGravesiteCameraState, OptKillerActor) == 0x000028, "Member 'OrionPlayerController_Game_ClientSetGravesiteCameraState::OptKillerActor' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.ClientSurrender
// 0x0002 (0x0002 - 0x0000)
struct OrionPlayerController_Game_ClientSurrender final
{
public:
	bool                                          bSurrender;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuccess;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Game_ClientSurrender) == 0x000001, "Wrong alignment on OrionPlayerController_Game_ClientSurrender");
static_assert(sizeof(OrionPlayerController_Game_ClientSurrender) == 0x000002, "Wrong size on OrionPlayerController_Game_ClientSurrender");
static_assert(offsetof(OrionPlayerController_Game_ClientSurrender, bSurrender) == 0x000000, "Member 'OrionPlayerController_Game_ClientSurrender::bSurrender' has a wrong offset!");
static_assert(offsetof(OrionPlayerController_Game_ClientSurrender, bSuccess) == 0x000001, "Member 'OrionPlayerController_Game_ClientSurrender::bSuccess' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.ClientTransitionToSpectating
// 0x0030 (0x0030 - 0x0000)
struct OrionPlayerController_Game_ClientTransitionToSpectating final
{
public:
	struct FVector                                PositionOfKiller;                                  // 0x0000(0x000C)(ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PositionOfDeath;                                   // 0x000C(0x000C)(ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ViewerDir;                                         // 0x0018(0x000C)(ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 OptKillerActor;                                    // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Game_ClientTransitionToSpectating) == 0x000008, "Wrong alignment on OrionPlayerController_Game_ClientTransitionToSpectating");
static_assert(sizeof(OrionPlayerController_Game_ClientTransitionToSpectating) == 0x000030, "Wrong size on OrionPlayerController_Game_ClientTransitionToSpectating");
static_assert(offsetof(OrionPlayerController_Game_ClientTransitionToSpectating, PositionOfKiller) == 0x000000, "Member 'OrionPlayerController_Game_ClientTransitionToSpectating::PositionOfKiller' has a wrong offset!");
static_assert(offsetof(OrionPlayerController_Game_ClientTransitionToSpectating, PositionOfDeath) == 0x00000C, "Member 'OrionPlayerController_Game_ClientTransitionToSpectating::PositionOfDeath' has a wrong offset!");
static_assert(offsetof(OrionPlayerController_Game_ClientTransitionToSpectating, ViewerDir) == 0x000018, "Member 'OrionPlayerController_Game_ClientTransitionToSpectating::ViewerDir' has a wrong offset!");
static_assert(offsetof(OrionPlayerController_Game_ClientTransitionToSpectating, OptKillerActor) == 0x000028, "Member 'OrionPlayerController_Game_ClientTransitionToSpectating::OptKillerActor' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.ClientTriggerHighlight
// 0x0008 (0x0008 - 0x0000)
struct OrionPlayerController_Game_ClientTriggerHighlight final
{
public:
	class FName                                   HighlightEvent;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Game_ClientTriggerHighlight) == 0x000004, "Wrong alignment on OrionPlayerController_Game_ClientTriggerHighlight");
static_assert(sizeof(OrionPlayerController_Game_ClientTriggerHighlight) == 0x000008, "Wrong size on OrionPlayerController_Game_ClientTriggerHighlight");
static_assert(offsetof(OrionPlayerController_Game_ClientTriggerHighlight, HighlightEvent) == 0x000000, "Member 'OrionPlayerController_Game_ClientTriggerHighlight::HighlightEvent' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.ClientWardPing
// 0x000C (0x000C - 0x0000)
struct OrionPlayerController_Game_ClientWardPing final
{
public:
	struct FVector                                PingLocation;                                      // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Game_ClientWardPing) == 0x000004, "Wrong alignment on OrionPlayerController_Game_ClientWardPing");
static_assert(sizeof(OrionPlayerController_Game_ClientWardPing) == 0x00000C, "Wrong size on OrionPlayerController_Game_ClientWardPing");
static_assert(offsetof(OrionPlayerController_Game_ClientWardPing, PingLocation) == 0x000000, "Member 'OrionPlayerController_Game_ClientWardPing::PingLocation' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.ConfirmAbilityForPawnCheat
// 0x0008 (0x0008 - 0x0000)
struct OrionPlayerController_Game_ConfirmAbilityForPawnCheat final
{
public:
	class AOrionChar*                             InChar;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Game_ConfirmAbilityForPawnCheat) == 0x000008, "Wrong alignment on OrionPlayerController_Game_ConfirmAbilityForPawnCheat");
static_assert(sizeof(OrionPlayerController_Game_ConfirmAbilityForPawnCheat) == 0x000008, "Wrong size on OrionPlayerController_Game_ConfirmAbilityForPawnCheat");
static_assert(offsetof(OrionPlayerController_Game_ConfirmAbilityForPawnCheat, InChar) == 0x000000, "Member 'OrionPlayerController_Game_ConfirmAbilityForPawnCheat::InChar' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.DestroyTeamCommsActor
// 0x0008 (0x0008 - 0x0000)
struct OrionPlayerController_Game_DestroyTeamCommsActor final
{
public:
	class ATeamCommunicationsActor*               TeamCommsActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Game_DestroyTeamCommsActor) == 0x000008, "Wrong alignment on OrionPlayerController_Game_DestroyTeamCommsActor");
static_assert(sizeof(OrionPlayerController_Game_DestroyTeamCommsActor) == 0x000008, "Wrong size on OrionPlayerController_Game_DestroyTeamCommsActor");
static_assert(offsetof(OrionPlayerController_Game_DestroyTeamCommsActor, TeamCommsActor) == 0x000000, "Member 'OrionPlayerController_Game_DestroyTeamCommsActor::TeamCommsActor' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.ReportClientHitch
// 0x0030 (0x0030 - 0x0000)
struct OrionPlayerController_Game_ReportClientHitch final
{
public:
	struct FVector                                CameraLocation;                                    // 0x0000(0x000C)(ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  CameraRotation;                                    // 0x0010(0x0010)(ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0xC];                                       // 0x0024(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionPlayerController_Game_ReportClientHitch) == 0x000010, "Wrong alignment on OrionPlayerController_Game_ReportClientHitch");
static_assert(sizeof(OrionPlayerController_Game_ReportClientHitch) == 0x000030, "Wrong size on OrionPlayerController_Game_ReportClientHitch");
static_assert(offsetof(OrionPlayerController_Game_ReportClientHitch, CameraLocation) == 0x000000, "Member 'OrionPlayerController_Game_ReportClientHitch::CameraLocation' has a wrong offset!");
static_assert(offsetof(OrionPlayerController_Game_ReportClientHitch, CameraRotation) == 0x000010, "Member 'OrionPlayerController_Game_ReportClientHitch::CameraRotation' has a wrong offset!");
static_assert(offsetof(OrionPlayerController_Game_ReportClientHitch, Duration) == 0x000020, "Member 'OrionPlayerController_Game_ReportClientHitch::Duration' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.ScriptAIBehaviorCheat
// 0x0010 (0x0010 - 0x0000)
struct OrionPlayerController_Game_ScriptAIBehaviorCheat final
{
public:
	class AOrionChar*                             InChar;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ScriptedBehaviorName;                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Game_ScriptAIBehaviorCheat) == 0x000008, "Wrong alignment on OrionPlayerController_Game_ScriptAIBehaviorCheat");
static_assert(sizeof(OrionPlayerController_Game_ScriptAIBehaviorCheat) == 0x000010, "Wrong size on OrionPlayerController_Game_ScriptAIBehaviorCheat");
static_assert(offsetof(OrionPlayerController_Game_ScriptAIBehaviorCheat, InChar) == 0x000000, "Member 'OrionPlayerController_Game_ScriptAIBehaviorCheat::InChar' has a wrong offset!");
static_assert(offsetof(OrionPlayerController_Game_ScriptAIBehaviorCheat, ScriptedBehaviorName) == 0x000008, "Member 'OrionPlayerController_Game_ScriptAIBehaviorCheat::ScriptedBehaviorName' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.ServerActivateCardInSlot
// 0x0004 (0x0004 - 0x0000)
struct OrionPlayerController_Game_ServerActivateCardInSlot final
{
public:
	int32                                         EquipSlotIdx;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Game_ServerActivateCardInSlot) == 0x000004, "Wrong alignment on OrionPlayerController_Game_ServerActivateCardInSlot");
static_assert(sizeof(OrionPlayerController_Game_ServerActivateCardInSlot) == 0x000004, "Wrong size on OrionPlayerController_Game_ServerActivateCardInSlot");
static_assert(offsetof(OrionPlayerController_Game_ServerActivateCardInSlot, EquipSlotIdx) == 0x000000, "Member 'OrionPlayerController_Game_ServerActivateCardInSlot::EquipSlotIdx' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.ServerApplyGameplayEffect
// 0x0018 (0x0018 - 0x0000)
struct OrionPlayerController_Game_ServerApplyGameplayEffect final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayEffect*                        GameplayEffect;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectsLevel;                                      // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionPlayerController_Game_ServerApplyGameplayEffect) == 0x000008, "Wrong alignment on OrionPlayerController_Game_ServerApplyGameplayEffect");
static_assert(sizeof(OrionPlayerController_Game_ServerApplyGameplayEffect) == 0x000018, "Wrong size on OrionPlayerController_Game_ServerApplyGameplayEffect");
static_assert(offsetof(OrionPlayerController_Game_ServerApplyGameplayEffect, Target) == 0x000000, "Member 'OrionPlayerController_Game_ServerApplyGameplayEffect::Target' has a wrong offset!");
static_assert(offsetof(OrionPlayerController_Game_ServerApplyGameplayEffect, GameplayEffect) == 0x000008, "Member 'OrionPlayerController_Game_ServerApplyGameplayEffect::GameplayEffect' has a wrong offset!");
static_assert(offsetof(OrionPlayerController_Game_ServerApplyGameplayEffect, EffectsLevel) == 0x000010, "Member 'OrionPlayerController_Game_ServerApplyGameplayEffect::EffectsLevel' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.ServerBroadcastTeamComm
// 0x0008 (0x0008 - 0x0000)
struct OrionPlayerController_Game_ServerBroadcastTeamComm final
{
public:
	const class UPCTeamCommunicationsData*        TeamCommData;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Game_ServerBroadcastTeamComm) == 0x000008, "Wrong alignment on OrionPlayerController_Game_ServerBroadcastTeamComm");
static_assert(sizeof(OrionPlayerController_Game_ServerBroadcastTeamComm) == 0x000008, "Wrong size on OrionPlayerController_Game_ServerBroadcastTeamComm");
static_assert(offsetof(OrionPlayerController_Game_ServerBroadcastTeamComm, TeamCommData) == 0x000000, "Member 'OrionPlayerController_Game_ServerBroadcastTeamComm::TeamCommData' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.ServerEquipCard
// 0x0008 (0x0008 - 0x0000)
struct OrionPlayerController_Game_ServerEquipCard final
{
public:
	int32                                         HandIdx;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EquipSlotIdx;                                      // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Game_ServerEquipCard) == 0x000004, "Wrong alignment on OrionPlayerController_Game_ServerEquipCard");
static_assert(sizeof(OrionPlayerController_Game_ServerEquipCard) == 0x000008, "Wrong size on OrionPlayerController_Game_ServerEquipCard");
static_assert(offsetof(OrionPlayerController_Game_ServerEquipCard, HandIdx) == 0x000000, "Member 'OrionPlayerController_Game_ServerEquipCard::HandIdx' has a wrong offset!");
static_assert(offsetof(OrionPlayerController_Game_ServerEquipCard, EquipSlotIdx) == 0x000004, "Member 'OrionPlayerController_Game_ServerEquipCard::EquipSlotIdx' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.ServerSendMinimapPing
// 0x000C (0x000C - 0x0000)
struct OrionPlayerController_Game_ServerSendMinimapPing final
{
public:
	struct FVector                                WorldPosition;                                     // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Game_ServerSendMinimapPing) == 0x000004, "Wrong alignment on OrionPlayerController_Game_ServerSendMinimapPing");
static_assert(sizeof(OrionPlayerController_Game_ServerSendMinimapPing) == 0x00000C, "Wrong size on OrionPlayerController_Game_ServerSendMinimapPing");
static_assert(offsetof(OrionPlayerController_Game_ServerSendMinimapPing, WorldPosition) == 0x000000, "Member 'OrionPlayerController_Game_ServerSendMinimapPing::WorldPosition' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.ServerSetIsUsingGamepad
// 0x0001 (0x0001 - 0x0000)
struct OrionPlayerController_Game_ServerSetIsUsingGamepad final
{
public:
	bool                                          bNewIsUsingGamepad;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Game_ServerSetIsUsingGamepad) == 0x000001, "Wrong alignment on OrionPlayerController_Game_ServerSetIsUsingGamepad");
static_assert(sizeof(OrionPlayerController_Game_ServerSetIsUsingGamepad) == 0x000001, "Wrong size on OrionPlayerController_Game_ServerSetIsUsingGamepad");
static_assert(offsetof(OrionPlayerController_Game_ServerSetIsUsingGamepad, bNewIsUsingGamepad) == 0x000000, "Member 'OrionPlayerController_Game_ServerSetIsUsingGamepad::bNewIsUsingGamepad' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.ServerSetSelectedDeckItem
// 0x0010 (0x0010 - 0x0000)
struct OrionPlayerController_Game_ServerSetSelectedDeckItem final
{
public:
	class FString                                 DeckInstanceId;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Game_ServerSetSelectedDeckItem) == 0x000008, "Wrong alignment on OrionPlayerController_Game_ServerSetSelectedDeckItem");
static_assert(sizeof(OrionPlayerController_Game_ServerSetSelectedDeckItem) == 0x000010, "Wrong size on OrionPlayerController_Game_ServerSetSelectedDeckItem");
static_assert(offsetof(OrionPlayerController_Game_ServerSetSelectedDeckItem, DeckInstanceId) == 0x000000, "Member 'OrionPlayerController_Game_ServerSetSelectedDeckItem::DeckInstanceId' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.ServerSurrender
// 0x0008 (0x0008 - 0x0000)
struct OrionPlayerController_Game_ServerSurrender final
{
public:
	bool                                          bSurrender;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Reason;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Game_ServerSurrender) == 0x000004, "Wrong alignment on OrionPlayerController_Game_ServerSurrender");
static_assert(sizeof(OrionPlayerController_Game_ServerSurrender) == 0x000008, "Wrong size on OrionPlayerController_Game_ServerSurrender");
static_assert(offsetof(OrionPlayerController_Game_ServerSurrender, bSurrender) == 0x000000, "Member 'OrionPlayerController_Game_ServerSurrender::bSurrender' has a wrong offset!");
static_assert(offsetof(OrionPlayerController_Game_ServerSurrender, Reason) == 0x000004, "Member 'OrionPlayerController_Game_ServerSurrender::Reason' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.ServerSwapCards
// 0x0008 (0x0008 - 0x0000)
struct OrionPlayerController_Game_ServerSwapCards final
{
public:
	int32                                         EquipSlotIdxOne;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EquipSlotIdxTwo;                                   // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Game_ServerSwapCards) == 0x000004, "Wrong alignment on OrionPlayerController_Game_ServerSwapCards");
static_assert(sizeof(OrionPlayerController_Game_ServerSwapCards) == 0x000008, "Wrong size on OrionPlayerController_Game_ServerSwapCards");
static_assert(offsetof(OrionPlayerController_Game_ServerSwapCards, EquipSlotIdxOne) == 0x000000, "Member 'OrionPlayerController_Game_ServerSwapCards::EquipSlotIdxOne' has a wrong offset!");
static_assert(offsetof(OrionPlayerController_Game_ServerSwapCards, EquipSlotIdxTwo) == 0x000004, "Member 'OrionPlayerController_Game_ServerSwapCards::EquipSlotIdxTwo' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.ServerUnequipCard
// 0x0004 (0x0004 - 0x0000)
struct OrionPlayerController_Game_ServerUnequipCard final
{
public:
	int32                                         EquipSlotIdx;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Game_ServerUnequipCard) == 0x000004, "Wrong alignment on OrionPlayerController_Game_ServerUnequipCard");
static_assert(sizeof(OrionPlayerController_Game_ServerUnequipCard) == 0x000004, "Wrong size on OrionPlayerController_Game_ServerUnequipCard");
static_assert(offsetof(OrionPlayerController_Game_ServerUnequipCard, EquipSlotIdx) == 0x000000, "Member 'OrionPlayerController_Game_ServerUnequipCard::EquipSlotIdx' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.ServerUnlockGemTreePip
// 0x0001 (0x0001 - 0x0000)
struct OrionPlayerController_Game_ServerUnlockGemTreePip final
{
public:
	EOrionGemBranchType                           Branch;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Game_ServerUnlockGemTreePip) == 0x000001, "Wrong alignment on OrionPlayerController_Game_ServerUnlockGemTreePip");
static_assert(sizeof(OrionPlayerController_Game_ServerUnlockGemTreePip) == 0x000001, "Wrong size on OrionPlayerController_Game_ServerUnlockGemTreePip");
static_assert(offsetof(OrionPlayerController_Game_ServerUnlockGemTreePip, Branch) == 0x000000, "Member 'OrionPlayerController_Game_ServerUnlockGemTreePip::Branch' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.ServerUpdateCameraFreeLook
// 0x0001 (0x0001 - 0x0000)
struct OrionPlayerController_Game_ServerUpdateCameraFreeLook final
{
public:
	bool                                          bStartFreeLook;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Game_ServerUpdateCameraFreeLook) == 0x000001, "Wrong alignment on OrionPlayerController_Game_ServerUpdateCameraFreeLook");
static_assert(sizeof(OrionPlayerController_Game_ServerUpdateCameraFreeLook) == 0x000001, "Wrong size on OrionPlayerController_Game_ServerUpdateCameraFreeLook");
static_assert(offsetof(OrionPlayerController_Game_ServerUpdateCameraFreeLook, bStartFreeLook) == 0x000000, "Member 'OrionPlayerController_Game_ServerUpdateCameraFreeLook::bStartFreeLook' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.SetHealthCheat
// 0x0010 (0x0010 - 0x0000)
struct OrionPlayerController_Game_SetHealthCheat final
{
public:
	class AOrionChar*                             InChar;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InPercent;                                         // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionPlayerController_Game_SetHealthCheat) == 0x000008, "Wrong alignment on OrionPlayerController_Game_SetHealthCheat");
static_assert(sizeof(OrionPlayerController_Game_SetHealthCheat) == 0x000010, "Wrong size on OrionPlayerController_Game_SetHealthCheat");
static_assert(offsetof(OrionPlayerController_Game_SetHealthCheat, InChar) == 0x000000, "Member 'OrionPlayerController_Game_SetHealthCheat::InChar' has a wrong offset!");
static_assert(offsetof(OrionPlayerController_Game_SetHealthCheat, InPercent) == 0x000008, "Member 'OrionPlayerController_Game_SetHealthCheat::InPercent' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.SetLastZoneVisionMask
// 0x0002 (0x0002 - 0x0000)
struct OrionPlayerController_Game_SetLastZoneVisionMask final
{
public:
	uint8                                         In_InMask;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         In_CanSeeMask;                                     // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Game_SetLastZoneVisionMask) == 0x000001, "Wrong alignment on OrionPlayerController_Game_SetLastZoneVisionMask");
static_assert(sizeof(OrionPlayerController_Game_SetLastZoneVisionMask) == 0x000002, "Wrong size on OrionPlayerController_Game_SetLastZoneVisionMask");
static_assert(offsetof(OrionPlayerController_Game_SetLastZoneVisionMask, In_InMask) == 0x000000, "Member 'OrionPlayerController_Game_SetLastZoneVisionMask::In_InMask' has a wrong offset!");
static_assert(offsetof(OrionPlayerController_Game_SetLastZoneVisionMask, In_CanSeeMask) == 0x000001, "Member 'OrionPlayerController_Game_SetLastZoneVisionMask::In_CanSeeMask' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.ShouldDisplayCardOverLocalPlayer
// 0x0001 (0x0001 - 0x0000)
struct OrionPlayerController_Game_ShouldDisplayCardOverLocalPlayer final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Game_ShouldDisplayCardOverLocalPlayer) == 0x000001, "Wrong alignment on OrionPlayerController_Game_ShouldDisplayCardOverLocalPlayer");
static_assert(sizeof(OrionPlayerController_Game_ShouldDisplayCardOverLocalPlayer) == 0x000001, "Wrong size on OrionPlayerController_Game_ShouldDisplayCardOverLocalPlayer");
static_assert(offsetof(OrionPlayerController_Game_ShouldDisplayCardOverLocalPlayer, ReturnValue) == 0x000000, "Member 'OrionPlayerController_Game_ShouldDisplayCardOverLocalPlayer::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.TeleportCharTo
// 0x0020 (0x0020 - 0x0000)
struct OrionPlayerController_Game_TeleportCharTo final
{
public:
	class AOrionChar*                             InChar;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldDirection;                                    // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               DestRotation;                                      // 0x0014(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Game_TeleportCharTo) == 0x000008, "Wrong alignment on OrionPlayerController_Game_TeleportCharTo");
static_assert(sizeof(OrionPlayerController_Game_TeleportCharTo) == 0x000020, "Wrong size on OrionPlayerController_Game_TeleportCharTo");
static_assert(offsetof(OrionPlayerController_Game_TeleportCharTo, InChar) == 0x000000, "Member 'OrionPlayerController_Game_TeleportCharTo::InChar' has a wrong offset!");
static_assert(offsetof(OrionPlayerController_Game_TeleportCharTo, WorldDirection) == 0x000008, "Member 'OrionPlayerController_Game_TeleportCharTo::WorldDirection' has a wrong offset!");
static_assert(offsetof(OrionPlayerController_Game_TeleportCharTo, DestRotation) == 0x000014, "Member 'OrionPlayerController_Game_TeleportCharTo::DestRotation' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.IsUpgradePanelOpen
// 0x0001 (0x0001 - 0x0000)
struct OrionPlayerController_Game_IsUpgradePanelOpen final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Game_IsUpgradePanelOpen) == 0x000001, "Wrong alignment on OrionPlayerController_Game_IsUpgradePanelOpen");
static_assert(sizeof(OrionPlayerController_Game_IsUpgradePanelOpen) == 0x000001, "Wrong size on OrionPlayerController_Game_IsUpgradePanelOpen");
static_assert(offsetof(OrionPlayerController_Game_IsUpgradePanelOpen, ReturnValue) == 0x000000, "Member 'OrionPlayerController_Game_IsUpgradePanelOpen::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Game.OrionIsPaused
// 0x0001 (0x0001 - 0x0000)
struct OrionPlayerController_Game_OrionIsPaused final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Game_OrionIsPaused) == 0x000001, "Wrong alignment on OrionPlayerController_Game_OrionIsPaused");
static_assert(sizeof(OrionPlayerController_Game_OrionIsPaused) == 0x000001, "Wrong size on OrionPlayerController_Game_OrionIsPaused");
static_assert(offsetof(OrionPlayerController_Game_OrionIsPaused, ReturnValue) == 0x000000, "Member 'OrionPlayerController_Game_OrionIsPaused::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Arcade.ServerRestartRounds
// 0x0001 (0x0001 - 0x0000)
struct OrionPlayerController_Arcade_ServerRestartRounds final
{
public:
	bool                                          bWithBuff;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Arcade_ServerRestartRounds) == 0x000001, "Wrong alignment on OrionPlayerController_Arcade_ServerRestartRounds");
static_assert(sizeof(OrionPlayerController_Arcade_ServerRestartRounds) == 0x000001, "Wrong size on OrionPlayerController_Arcade_ServerRestartRounds");
static_assert(offsetof(OrionPlayerController_Arcade_ServerRestartRounds, bWithBuff) == 0x000000, "Member 'OrionPlayerController_Arcade_ServerRestartRounds::bWithBuff' has a wrong offset!");

// Function OrionGame.OrionClientBotManager_Smoke.OnBuffGained
// 0x01C0 (0x01C0 - 0x0000)
struct OrionClientBotManager_Smoke_OnBuffGained final
{
public:
	struct FOrionJungleBuffInfo                   BuffInfo;                                          // 0x0000(0x01C0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientBotManager_Smoke_OnBuffGained) == 0x000010, "Wrong alignment on OrionClientBotManager_Smoke_OnBuffGained");
static_assert(sizeof(OrionClientBotManager_Smoke_OnBuffGained) == 0x0001C0, "Wrong size on OrionClientBotManager_Smoke_OnBuffGained");
static_assert(offsetof(OrionClientBotManager_Smoke_OnBuffGained, BuffInfo) == 0x000000, "Member 'OrionClientBotManager_Smoke_OnBuffGained::BuffInfo' has a wrong offset!");

// Function OrionGame.OrionPlayerController_DraftLobby.ClientCreateTeamChatRoom
// 0x0010 (0x0010 - 0x0000)
struct OrionPlayerController_DraftLobby_ClientCreateTeamChatRoom final
{
public:
	class FString                                 ChatRoomId;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_DraftLobby_ClientCreateTeamChatRoom) == 0x000008, "Wrong alignment on OrionPlayerController_DraftLobby_ClientCreateTeamChatRoom");
static_assert(sizeof(OrionPlayerController_DraftLobby_ClientCreateTeamChatRoom) == 0x000010, "Wrong size on OrionPlayerController_DraftLobby_ClientCreateTeamChatRoom");
static_assert(offsetof(OrionPlayerController_DraftLobby_ClientCreateTeamChatRoom, ChatRoomId) == 0x000000, "Member 'OrionPlayerController_DraftLobby_ClientCreateTeamChatRoom::ChatRoomId' has a wrong offset!");

// Function OrionGame.OrionPlayerController_DraftLobby.ClientHeroSelectionStatus
// 0x0001 (0x0001 - 0x0000)
struct OrionPlayerController_DraftLobby_ClientHeroSelectionStatus final
{
public:
	bool                                          bWasSuccessful;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_DraftLobby_ClientHeroSelectionStatus) == 0x000001, "Wrong alignment on OrionPlayerController_DraftLobby_ClientHeroSelectionStatus");
static_assert(sizeof(OrionPlayerController_DraftLobby_ClientHeroSelectionStatus) == 0x000001, "Wrong size on OrionPlayerController_DraftLobby_ClientHeroSelectionStatus");
static_assert(offsetof(OrionPlayerController_DraftLobby_ClientHeroSelectionStatus, bWasSuccessful) == 0x000000, "Member 'OrionPlayerController_DraftLobby_ClientHeroSelectionStatus::bWasSuccessful' has a wrong offset!");

// Function OrionGame.OrionPlayerController_DraftLobby.ClientJoinTeamChatRoom
// 0x0010 (0x0010 - 0x0000)
struct OrionPlayerController_DraftLobby_ClientJoinTeamChatRoom final
{
public:
	class FString                                 ChatRoomId;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_DraftLobby_ClientJoinTeamChatRoom) == 0x000008, "Wrong alignment on OrionPlayerController_DraftLobby_ClientJoinTeamChatRoom");
static_assert(sizeof(OrionPlayerController_DraftLobby_ClientJoinTeamChatRoom) == 0x000010, "Wrong size on OrionPlayerController_DraftLobby_ClientJoinTeamChatRoom");
static_assert(offsetof(OrionPlayerController_DraftLobby_ClientJoinTeamChatRoom, ChatRoomId) == 0x000000, "Member 'OrionPlayerController_DraftLobby_ClientJoinTeamChatRoom::ChatRoomId' has a wrong offset!");

// Function OrionGame.OrionPlayerController_DraftLobby.ClientReceiveQuickChatMessage
// 0x0030 (0x0030 - 0x0000)
struct OrionPlayerController_DraftLobby_ClientReceiveQuickChatMessage final
{
public:
	struct FUniqueNetIdRepl                       SenderId;                                          // 0x0000(0x0018)(ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionQuickChatPayload                 MessagePayload;                                    // 0x0018(0x0018)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_DraftLobby_ClientReceiveQuickChatMessage) == 0x000008, "Wrong alignment on OrionPlayerController_DraftLobby_ClientReceiveQuickChatMessage");
static_assert(sizeof(OrionPlayerController_DraftLobby_ClientReceiveQuickChatMessage) == 0x000030, "Wrong size on OrionPlayerController_DraftLobby_ClientReceiveQuickChatMessage");
static_assert(offsetof(OrionPlayerController_DraftLobby_ClientReceiveQuickChatMessage, SenderId) == 0x000000, "Member 'OrionPlayerController_DraftLobby_ClientReceiveQuickChatMessage::SenderId' has a wrong offset!");
static_assert(offsetof(OrionPlayerController_DraftLobby_ClientReceiveQuickChatMessage, MessagePayload) == 0x000018, "Member 'OrionPlayerController_DraftLobby_ClientReceiveQuickChatMessage::MessagePayload' has a wrong offset!");

// Function OrionGame.OrionPlayerController_DraftLobby.ServerAttemptLockInHeroChoice
// 0x0010 (0x0010 - 0x0000)
struct OrionPlayerController_DraftLobby_ServerAttemptLockInHeroChoice final
{
public:
	class FString                                 HeroName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_DraftLobby_ServerAttemptLockInHeroChoice) == 0x000008, "Wrong alignment on OrionPlayerController_DraftLobby_ServerAttemptLockInHeroChoice");
static_assert(sizeof(OrionPlayerController_DraftLobby_ServerAttemptLockInHeroChoice) == 0x000010, "Wrong size on OrionPlayerController_DraftLobby_ServerAttemptLockInHeroChoice");
static_assert(offsetof(OrionPlayerController_DraftLobby_ServerAttemptLockInHeroChoice, HeroName) == 0x000000, "Member 'OrionPlayerController_DraftLobby_ServerAttemptLockInHeroChoice::HeroName' has a wrong offset!");

// Function OrionGame.OrionPlayerController_DraftLobby.ServerSendQuickChatMessage
// 0x0018 (0x0018 - 0x0000)
struct OrionPlayerController_DraftLobby_ServerSendQuickChatMessage final
{
public:
	struct FOrionQuickChatPayload                 QuickChatPayload;                                  // 0x0000(0x0018)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_DraftLobby_ServerSendQuickChatMessage) == 0x000008, "Wrong alignment on OrionPlayerController_DraftLobby_ServerSendQuickChatMessage");
static_assert(sizeof(OrionPlayerController_DraftLobby_ServerSendQuickChatMessage) == 0x000018, "Wrong size on OrionPlayerController_DraftLobby_ServerSendQuickChatMessage");
static_assert(offsetof(OrionPlayerController_DraftLobby_ServerSendQuickChatMessage, QuickChatPayload) == 0x000000, "Member 'OrionPlayerController_DraftLobby_ServerSendQuickChatMessage::QuickChatPayload' has a wrong offset!");

// Function OrionGame.OrionPlayerController_DraftLobby.ServerSetDesiredPosition
// 0x0001 (0x0001 - 0x0000)
struct OrionPlayerController_DraftLobby_ServerSetDesiredPosition final
{
public:
	EOrionPosition                                Position;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_DraftLobby_ServerSetDesiredPosition) == 0x000001, "Wrong alignment on OrionPlayerController_DraftLobby_ServerSetDesiredPosition");
static_assert(sizeof(OrionPlayerController_DraftLobby_ServerSetDesiredPosition) == 0x000001, "Wrong size on OrionPlayerController_DraftLobby_ServerSetDesiredPosition");
static_assert(offsetof(OrionPlayerController_DraftLobby_ServerSetDesiredPosition, Position) == 0x000000, "Member 'OrionPlayerController_DraftLobby_ServerSetDesiredPosition::Position' has a wrong offset!");

// Function OrionGame.OrionPlayerController_DraftLobby.ServerSetDesiredRole
// 0x0001 (0x0001 - 0x0000)
struct OrionPlayerController_DraftLobby_ServerSetDesiredRole final
{
public:
	EOrionRole                                    DesiredRole;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_DraftLobby_ServerSetDesiredRole) == 0x000001, "Wrong alignment on OrionPlayerController_DraftLobby_ServerSetDesiredRole");
static_assert(sizeof(OrionPlayerController_DraftLobby_ServerSetDesiredRole) == 0x000001, "Wrong size on OrionPlayerController_DraftLobby_ServerSetDesiredRole");
static_assert(offsetof(OrionPlayerController_DraftLobby_ServerSetDesiredRole, DesiredRole) == 0x000000, "Member 'OrionPlayerController_DraftLobby_ServerSetDesiredRole::DesiredRole' has a wrong offset!");

// Function OrionGame.OrionPlayerController_DraftLobby.ServerSetMapOverride
// 0x0010 (0x0010 - 0x0000)
struct OrionPlayerController_DraftLobby_ServerSetMapOverride final
{
public:
	class FString                                 InMapURL;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_DraftLobby_ServerSetMapOverride) == 0x000008, "Wrong alignment on OrionPlayerController_DraftLobby_ServerSetMapOverride");
static_assert(sizeof(OrionPlayerController_DraftLobby_ServerSetMapOverride) == 0x000010, "Wrong size on OrionPlayerController_DraftLobby_ServerSetMapOverride");
static_assert(offsetof(OrionPlayerController_DraftLobby_ServerSetMapOverride, InMapURL) == 0x000000, "Member 'OrionPlayerController_DraftLobby_ServerSetMapOverride::InMapURL' has a wrong offset!");

// Function OrionGame.OrionPlayerController_DraftLobby.ServerSetSelectedHero
// 0x0008 (0x0008 - 0x0000)
struct OrionPlayerController_DraftLobby_ServerSetSelectedHero final
{
public:
	const class UOrionHeroData*                   HeroData;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_DraftLobby_ServerSetSelectedHero) == 0x000008, "Wrong alignment on OrionPlayerController_DraftLobby_ServerSetSelectedHero");
static_assert(sizeof(OrionPlayerController_DraftLobby_ServerSetSelectedHero) == 0x000008, "Wrong size on OrionPlayerController_DraftLobby_ServerSetSelectedHero");
static_assert(offsetof(OrionPlayerController_DraftLobby_ServerSetSelectedHero, HeroData) == 0x000000, "Member 'OrionPlayerController_DraftLobby_ServerSetSelectedHero::HeroData' has a wrong offset!");

// Function OrionGame.OrionGameUserSettings.GetOrionGameUserSettings
// 0x0008 (0x0008 - 0x0000)
struct OrionGameUserSettings_GetOrionGameUserSettings final
{
public:
	class UOrionGameUserSettings*                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameUserSettings_GetOrionGameUserSettings) == 0x000008, "Wrong alignment on OrionGameUserSettings_GetOrionGameUserSettings");
static_assert(sizeof(OrionGameUserSettings_GetOrionGameUserSettings) == 0x000008, "Wrong size on OrionGameUserSettings_GetOrionGameUserSettings");
static_assert(offsetof(OrionGameUserSettings_GetOrionGameUserSettings, ReturnValue) == 0x000000, "Member 'OrionGameUserSettings_GetOrionGameUserSettings::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameUserSettings.IsRunningOnUnsupportedGraphicsCard
// 0x0001 (0x0001 - 0x0000)
struct OrionGameUserSettings_IsRunningOnUnsupportedGraphicsCard final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameUserSettings_IsRunningOnUnsupportedGraphicsCard) == 0x000001, "Wrong alignment on OrionGameUserSettings_IsRunningOnUnsupportedGraphicsCard");
static_assert(sizeof(OrionGameUserSettings_IsRunningOnUnsupportedGraphicsCard) == 0x000001, "Wrong size on OrionGameUserSettings_IsRunningOnUnsupportedGraphicsCard");
static_assert(offsetof(OrionGameUserSettings_IsRunningOnUnsupportedGraphicsCard, ReturnValue) == 0x000000, "Member 'OrionGameUserSettings_IsRunningOnUnsupportedGraphicsCard::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameUserSettings.GetForceAutomaticSettingsAtStartup
// 0x0001 (0x0001 - 0x0000)
struct OrionGameUserSettings_GetForceAutomaticSettingsAtStartup final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameUserSettings_GetForceAutomaticSettingsAtStartup) == 0x000001, "Wrong alignment on OrionGameUserSettings_GetForceAutomaticSettingsAtStartup");
static_assert(sizeof(OrionGameUserSettings_GetForceAutomaticSettingsAtStartup) == 0x000001, "Wrong size on OrionGameUserSettings_GetForceAutomaticSettingsAtStartup");
static_assert(offsetof(OrionGameUserSettings_GetForceAutomaticSettingsAtStartup, ReturnValue) == 0x000000, "Member 'OrionGameUserSettings_GetForceAutomaticSettingsAtStartup::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameUserSettings.SetCompetitiveMode
// 0x0001 (0x0001 - 0x0000)
struct OrionGameUserSettings_SetCompetitiveMode final
{
public:
	bool                                          bInCompMode;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameUserSettings_SetCompetitiveMode) == 0x000001, "Wrong alignment on OrionGameUserSettings_SetCompetitiveMode");
static_assert(sizeof(OrionGameUserSettings_SetCompetitiveMode) == 0x000001, "Wrong size on OrionGameUserSettings_SetCompetitiveMode");
static_assert(offsetof(OrionGameUserSettings_SetCompetitiveMode, bInCompMode) == 0x000000, "Member 'OrionGameUserSettings_SetCompetitiveMode::bInCompMode' has a wrong offset!");

// Function OrionGame.OrionGameUserSettings.SetForceAutomaticSettingsAtStartup
// 0x0001 (0x0001 - 0x0000)
struct OrionGameUserSettings_SetForceAutomaticSettingsAtStartup final
{
public:
	bool                                          bShouldForceSettings;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameUserSettings_SetForceAutomaticSettingsAtStartup) == 0x000001, "Wrong alignment on OrionGameUserSettings_SetForceAutomaticSettingsAtStartup");
static_assert(sizeof(OrionGameUserSettings_SetForceAutomaticSettingsAtStartup) == 0x000001, "Wrong size on OrionGameUserSettings_SetForceAutomaticSettingsAtStartup");
static_assert(offsetof(OrionGameUserSettings_SetForceAutomaticSettingsAtStartup, bShouldForceSettings) == 0x000000, "Member 'OrionGameUserSettings_SetForceAutomaticSettingsAtStartup::bShouldForceSettings' has a wrong offset!");

// Function OrionGame.OrionGameUserSettings.SetMenuFrameRateLimit
// 0x0004 (0x0004 - 0x0000)
struct OrionGameUserSettings_SetMenuFrameRateLimit final
{
public:
	float                                         NewLimit;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameUserSettings_SetMenuFrameRateLimit) == 0x000004, "Wrong alignment on OrionGameUserSettings_SetMenuFrameRateLimit");
static_assert(sizeof(OrionGameUserSettings_SetMenuFrameRateLimit) == 0x000004, "Wrong size on OrionGameUserSettings_SetMenuFrameRateLimit");
static_assert(offsetof(OrionGameUserSettings_SetMenuFrameRateLimit, NewLimit) == 0x000000, "Member 'OrionGameUserSettings_SetMenuFrameRateLimit::NewLimit' has a wrong offset!");

// Function OrionGame.OrionGameUserSettings.SetOrionGameplayQuality
// 0x0004 (0x0004 - 0x0000)
struct OrionGameUserSettings_SetOrionGameplayQuality final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameUserSettings_SetOrionGameplayQuality) == 0x000004, "Wrong alignment on OrionGameUserSettings_SetOrionGameplayQuality");
static_assert(sizeof(OrionGameUserSettings_SetOrionGameplayQuality) == 0x000004, "Wrong size on OrionGameUserSettings_SetOrionGameplayQuality");
static_assert(offsetof(OrionGameUserSettings_SetOrionGameplayQuality, Value) == 0x000000, "Member 'OrionGameUserSettings_SetOrionGameplayQuality::Value' has a wrong offset!");

// Function OrionGame.OrionGameUserSettings.TriggerRenderingBenchmark
// 0x0008 (0x0008 - 0x0000)
struct OrionGameUserSettings_TriggerRenderingBenchmark final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameUserSettings_TriggerRenderingBenchmark) == 0x000008, "Wrong alignment on OrionGameUserSettings_TriggerRenderingBenchmark");
static_assert(sizeof(OrionGameUserSettings_TriggerRenderingBenchmark) == 0x000008, "Wrong size on OrionGameUserSettings_TriggerRenderingBenchmark");
static_assert(offsetof(OrionGameUserSettings_TriggerRenderingBenchmark, WorldContextObject) == 0x000000, "Member 'OrionGameUserSettings_TriggerRenderingBenchmark::WorldContextObject' has a wrong offset!");

// Function OrionGame.OrionGameUserSettings.GetCompetitiveMode
// 0x0001 (0x0001 - 0x0000)
struct OrionGameUserSettings_GetCompetitiveMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameUserSettings_GetCompetitiveMode) == 0x000001, "Wrong alignment on OrionGameUserSettings_GetCompetitiveMode");
static_assert(sizeof(OrionGameUserSettings_GetCompetitiveMode) == 0x000001, "Wrong size on OrionGameUserSettings_GetCompetitiveMode");
static_assert(offsetof(OrionGameUserSettings_GetCompetitiveMode, ReturnValue) == 0x000000, "Member 'OrionGameUserSettings_GetCompetitiveMode::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameUserSettings.GetGPUDisplayString
// 0x0018 (0x0018 - 0x0000)
struct OrionGameUserSettings_GetGPUDisplayString final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameUserSettings_GetGPUDisplayString) == 0x000008, "Wrong alignment on OrionGameUserSettings_GetGPUDisplayString");
static_assert(sizeof(OrionGameUserSettings_GetGPUDisplayString) == 0x000018, "Wrong size on OrionGameUserSettings_GetGPUDisplayString");
static_assert(offsetof(OrionGameUserSettings_GetGPUDisplayString, ReturnValue) == 0x000000, "Member 'OrionGameUserSettings_GetGPUDisplayString::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameUserSettings.GetInitialBenchmarkState
// 0x0004 (0x0004 - 0x0000)
struct OrionGameUserSettings_GetInitialBenchmarkState final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameUserSettings_GetInitialBenchmarkState) == 0x000004, "Wrong alignment on OrionGameUserSettings_GetInitialBenchmarkState");
static_assert(sizeof(OrionGameUserSettings_GetInitialBenchmarkState) == 0x000004, "Wrong size on OrionGameUserSettings_GetInitialBenchmarkState");
static_assert(offsetof(OrionGameUserSettings_GetInitialBenchmarkState, ReturnValue) == 0x000000, "Member 'OrionGameUserSettings_GetInitialBenchmarkState::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameUserSettings.GetMenuFrameRateLimit
// 0x0004 (0x0004 - 0x0000)
struct OrionGameUserSettings_GetMenuFrameRateLimit final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameUserSettings_GetMenuFrameRateLimit) == 0x000004, "Wrong alignment on OrionGameUserSettings_GetMenuFrameRateLimit");
static_assert(sizeof(OrionGameUserSettings_GetMenuFrameRateLimit) == 0x000004, "Wrong size on OrionGameUserSettings_GetMenuFrameRateLimit");
static_assert(offsetof(OrionGameUserSettings_GetMenuFrameRateLimit, ReturnValue) == 0x000000, "Member 'OrionGameUserSettings_GetMenuFrameRateLimit::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameUserSettings.GetOrionGameplayQuality
// 0x0004 (0x0004 - 0x0000)
struct OrionGameUserSettings_GetOrionGameplayQuality final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameUserSettings_GetOrionGameplayQuality) == 0x000004, "Wrong alignment on OrionGameUserSettings_GetOrionGameplayQuality");
static_assert(sizeof(OrionGameUserSettings_GetOrionGameplayQuality) == 0x000004, "Wrong size on OrionGameUserSettings_GetOrionGameplayQuality");
static_assert(offsetof(OrionGameUserSettings_GetOrionGameplayQuality, ReturnValue) == 0x000000, "Member 'OrionGameUserSettings_GetOrionGameplayQuality::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameUserSettings.GetSupportedHDRNitLevels
// 0x0010 (0x0010 - 0x0000)
struct OrionGameUserSettings_GetSupportedHDRNitLevels final
{
public:
	TArray<int32>                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameUserSettings_GetSupportedHDRNitLevels) == 0x000008, "Wrong alignment on OrionGameUserSettings_GetSupportedHDRNitLevels");
static_assert(sizeof(OrionGameUserSettings_GetSupportedHDRNitLevels) == 0x000010, "Wrong size on OrionGameUserSettings_GetSupportedHDRNitLevels");
static_assert(offsetof(OrionGameUserSettings_GetSupportedHDRNitLevels, ReturnValue) == 0x000000, "Member 'OrionGameUserSettings_GetSupportedHDRNitLevels::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientPilotComponent_GameSmoke.OnBuffGained
// 0x01C0 (0x01C0 - 0x0000)
struct OrionClientPilotComponent_GameSmoke_OnBuffGained final
{
public:
	struct FOrionJungleBuffInfo                   BuffInfo;                                          // 0x0000(0x01C0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientPilotComponent_GameSmoke_OnBuffGained) == 0x000010, "Wrong alignment on OrionClientPilotComponent_GameSmoke_OnBuffGained");
static_assert(sizeof(OrionClientPilotComponent_GameSmoke_OnBuffGained) == 0x0001C0, "Wrong size on OrionClientPilotComponent_GameSmoke_OnBuffGained");
static_assert(offsetof(OrionClientPilotComponent_GameSmoke_OnBuffGained, BuffInfo) == 0x000000, "Member 'OrionClientPilotComponent_GameSmoke_OnBuffGained::BuffInfo' has a wrong offset!");

// Function OrionGame.OrionMcpBannerAlterationItemDefinition.GetBannerMaterialDesc
// 0x00D8 (0x00D8 - 0x0000)
struct OrionMcpBannerAlterationItemDefinition_GetBannerMaterialDesc final
{
public:
	struct FBannerMaterialDesc                    ReturnValue;                                       // 0x0000(0x00D8)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpBannerAlterationItemDefinition_GetBannerMaterialDesc) == 0x000008, "Wrong alignment on OrionMcpBannerAlterationItemDefinition_GetBannerMaterialDesc");
static_assert(sizeof(OrionMcpBannerAlterationItemDefinition_GetBannerMaterialDesc) == 0x0000D8, "Wrong size on OrionMcpBannerAlterationItemDefinition_GetBannerMaterialDesc");
static_assert(offsetof(OrionMcpBannerAlterationItemDefinition_GetBannerMaterialDesc, ReturnValue) == 0x000000, "Member 'OrionMcpBannerAlterationItemDefinition_GetBannerMaterialDesc::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionMcpBannerAlterationItemDefinition.GetDiffuse
// 0x0008 (0x0008 - 0x0000)
struct OrionMcpBannerAlterationItemDefinition_GetDiffuse final
{
public:
	class UTexture*                               ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpBannerAlterationItemDefinition_GetDiffuse) == 0x000008, "Wrong alignment on OrionMcpBannerAlterationItemDefinition_GetDiffuse");
static_assert(sizeof(OrionMcpBannerAlterationItemDefinition_GetDiffuse) == 0x000008, "Wrong size on OrionMcpBannerAlterationItemDefinition_GetDiffuse");
static_assert(offsetof(OrionMcpBannerAlterationItemDefinition_GetDiffuse, ReturnValue) == 0x000000, "Member 'OrionMcpBannerAlterationItemDefinition_GetDiffuse::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionMcpBannerAlterationItemDefinition.GetNormal
// 0x0008 (0x0008 - 0x0000)
struct OrionMcpBannerAlterationItemDefinition_GetNormal final
{
public:
	class UTexture*                               ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpBannerAlterationItemDefinition_GetNormal) == 0x000008, "Wrong alignment on OrionMcpBannerAlterationItemDefinition_GetNormal");
static_assert(sizeof(OrionMcpBannerAlterationItemDefinition_GetNormal) == 0x000008, "Wrong size on OrionMcpBannerAlterationItemDefinition_GetNormal");
static_assert(offsetof(OrionMcpBannerAlterationItemDefinition_GetNormal, ReturnValue) == 0x000000, "Member 'OrionMcpBannerAlterationItemDefinition_GetNormal::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionMcpBannerAlterationItemDefinition.GetTexture
// 0x0008 (0x0008 - 0x0000)
struct OrionMcpBannerAlterationItemDefinition_GetTexture final
{
public:
	class UTexture*                               ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpBannerAlterationItemDefinition_GetTexture) == 0x000008, "Wrong alignment on OrionMcpBannerAlterationItemDefinition_GetTexture");
static_assert(sizeof(OrionMcpBannerAlterationItemDefinition_GetTexture) == 0x000008, "Wrong size on OrionMcpBannerAlterationItemDefinition_GetTexture");
static_assert(offsetof(OrionMcpBannerAlterationItemDefinition_GetTexture, ReturnValue) == 0x000000, "Member 'OrionMcpBannerAlterationItemDefinition_GetTexture::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetAbilities
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetAbilities final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetAbilities) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetAbilities");
static_assert(sizeof(OrionClientSettingsRecord_SetAbilities) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetAbilities");
static_assert(offsetof(OrionClientSettingsRecord_SetAbilities, bNewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetAbilities::bNewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetAbilityHotkeys
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetAbilityHotkeys final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetAbilityHotkeys) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetAbilityHotkeys");
static_assert(sizeof(OrionClientSettingsRecord_SetAbilityHotkeys) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetAbilityHotkeys");
static_assert(offsetof(OrionClientSettingsRecord_SetAbilityHotkeys, bNewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetAbilityHotkeys::bNewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetAnnouncements
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetAnnouncements final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetAnnouncements) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetAnnouncements");
static_assert(sizeof(OrionClientSettingsRecord_SetAnnouncements) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetAnnouncements");
static_assert(offsetof(OrionClientSettingsRecord_SetAnnouncements, bNewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetAnnouncements::bNewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetAutoOpenCardShop
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetAutoOpenCardShop final
{
public:
	bool                                          NewValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetAutoOpenCardShop) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetAutoOpenCardShop");
static_assert(sizeof(OrionClientSettingsRecord_SetAutoOpenCardShop) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetAutoOpenCardShop");
static_assert(offsetof(OrionClientSettingsRecord_SetAutoOpenCardShop, NewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetAutoOpenCardShop::NewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetAutoPlayInstantReplay
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetAutoPlayInstantReplay final
{
public:
	bool                                          NewValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetAutoPlayInstantReplay) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetAutoPlayInstantReplay");
static_assert(sizeof(OrionClientSettingsRecord_SetAutoPlayInstantReplay) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetAutoPlayInstantReplay");
static_assert(offsetof(OrionClientSettingsRecord_SetAutoPlayInstantReplay, NewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetAutoPlayInstantReplay::NewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetBuffs
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetBuffs final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetBuffs) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetBuffs");
static_assert(sizeof(OrionClientSettingsRecord_SetBuffs) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetBuffs");
static_assert(offsetof(OrionClientSettingsRecord_SetBuffs, bNewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetBuffs::bNewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetCardHotKeys
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetCardHotKeys final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetCardHotKeys) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetCardHotKeys");
static_assert(sizeof(OrionClientSettingsRecord_SetCardHotKeys) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetCardHotKeys");
static_assert(offsetof(OrionClientSettingsRecord_SetCardHotKeys, bNewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetCardHotKeys::bNewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetCardOnboardShown
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetCardOnboardShown final
{
public:
	bool                                          InCardOnboardLastShownGame;                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetCardOnboardShown) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetCardOnboardShown");
static_assert(sizeof(OrionClientSettingsRecord_SetCardOnboardShown) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetCardOnboardShown");
static_assert(offsetof(OrionClientSettingsRecord_SetCardOnboardShown, InCardOnboardLastShownGame) == 0x000000, "Member 'OrionClientSettingsRecord_SetCardOnboardShown::InCardOnboardLastShownGame' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetCardsAndGems
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetCardsAndGems final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetCardsAndGems) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetCardsAndGems");
static_assert(sizeof(OrionClientSettingsRecord_SetCardsAndGems) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetCardsAndGems");
static_assert(offsetof(OrionClientSettingsRecord_SetCardsAndGems, bNewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetCardsAndGems::bNewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetChat
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetChat final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetChat) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetChat");
static_assert(sizeof(OrionClientSettingsRecord_SetChat) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetChat");
static_assert(offsetof(OrionClientSettingsRecord_SetChat, bNewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetChat::bNewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetDeckBuilderDialogShown
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetDeckBuilderDialogShown final
{
public:
	bool                                          bInDeckBuilderDialogShow;                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetDeckBuilderDialogShown) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetDeckBuilderDialogShown");
static_assert(sizeof(OrionClientSettingsRecord_SetDeckBuilderDialogShown) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetDeckBuilderDialogShown");
static_assert(offsetof(OrionClientSettingsRecord_SetDeckBuilderDialogShown, bInDeckBuilderDialogShow) == 0x000000, "Member 'OrionClientSettingsRecord_SetDeckBuilderDialogShown::bInDeckBuilderDialogShow' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetDetailedStatsPanelPortrait
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetDetailedStatsPanelPortrait final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetDetailedStatsPanelPortrait) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetDetailedStatsPanelPortrait");
static_assert(sizeof(OrionClientSettingsRecord_SetDetailedStatsPanelPortrait) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetDetailedStatsPanelPortrait");
static_assert(offsetof(OrionClientSettingsRecord_SetDetailedStatsPanelPortrait, bNewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetDetailedStatsPanelPortrait::bNewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetDisplayDetailedStatsPanel
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetDisplayDetailedStatsPanel final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetDisplayDetailedStatsPanel) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetDisplayDetailedStatsPanel");
static_assert(sizeof(OrionClientSettingsRecord_SetDisplayDetailedStatsPanel) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetDisplayDetailedStatsPanel");
static_assert(offsetof(OrionClientSettingsRecord_SetDisplayDetailedStatsPanel, bNewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetDisplayDetailedStatsPanel::bNewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetDisplayMeleeHeroReticle
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetDisplayMeleeHeroReticle final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetDisplayMeleeHeroReticle) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetDisplayMeleeHeroReticle");
static_assert(sizeof(OrionClientSettingsRecord_SetDisplayMeleeHeroReticle) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetDisplayMeleeHeroReticle");
static_assert(offsetof(OrionClientSettingsRecord_SetDisplayMeleeHeroReticle, bNewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetDisplayMeleeHeroReticle::bNewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetDisplayNumericalValues
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetDisplayNumericalValues final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetDisplayNumericalValues) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetDisplayNumericalValues");
static_assert(sizeof(OrionClientSettingsRecord_SetDisplayNumericalValues) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetDisplayNumericalValues");
static_assert(offsetof(OrionClientSettingsRecord_SetDisplayNumericalValues, bNewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetDisplayNumericalValues::bNewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetEnableCardOverLocalPlayer
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetEnableCardOverLocalPlayer final
{
public:
	bool                                          NewValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetEnableCardOverLocalPlayer) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetEnableCardOverLocalPlayer");
static_assert(sizeof(OrionClientSettingsRecord_SetEnableCardOverLocalPlayer) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetEnableCardOverLocalPlayer");
static_assert(offsetof(OrionClientSettingsRecord_SetEnableCardOverLocalPlayer, NewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetEnableCardOverLocalPlayer::NewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetEnableDeathcam
// 0x0004 (0x0004 - 0x0000)
struct OrionClientSettingsRecord_SetEnableDeathcam final
{
public:
	int32                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetEnableDeathcam) == 0x000004, "Wrong alignment on OrionClientSettingsRecord_SetEnableDeathcam");
static_assert(sizeof(OrionClientSettingsRecord_SetEnableDeathcam) == 0x000004, "Wrong size on OrionClientSettingsRecord_SetEnableDeathcam");
static_assert(offsetof(OrionClientSettingsRecord_SetEnableDeathcam, NewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetEnableDeathcam::NewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetEnemyHeroIndicatorRule
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetEnemyHeroIndicatorRule final
{
public:
	EHealthIndicatorVisibility                    NewValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetEnemyHeroIndicatorRule) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetEnemyHeroIndicatorRule");
static_assert(sizeof(OrionClientSettingsRecord_SetEnemyHeroIndicatorRule) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetEnemyHeroIndicatorRule");
static_assert(offsetof(OrionClientSettingsRecord_SetEnemyHeroIndicatorRule, NewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetEnemyHeroIndicatorRule::NewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetEnemyMinionIndicatorRule
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetEnemyMinionIndicatorRule final
{
public:
	EHealthIndicatorVisibility                    NewValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetEnemyMinionIndicatorRule) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetEnemyMinionIndicatorRule");
static_assert(sizeof(OrionClientSettingsRecord_SetEnemyMinionIndicatorRule) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetEnemyMinionIndicatorRule");
static_assert(offsetof(OrionClientSettingsRecord_SetEnemyMinionIndicatorRule, NewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetEnemyMinionIndicatorRule::NewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetFadeHealthBarWhenOutOfCombat
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetFadeHealthBarWhenOutOfCombat final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetFadeHealthBarWhenOutOfCombat) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetFadeHealthBarWhenOutOfCombat");
static_assert(sizeof(OrionClientSettingsRecord_SetFadeHealthBarWhenOutOfCombat) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetFadeHealthBarWhenOutOfCombat");
static_assert(offsetof(OrionClientSettingsRecord_SetFadeHealthBarWhenOutOfCombat, bNewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetFadeHealthBarWhenOutOfCombat::bNewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetFloatingCombatText
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetFloatingCombatText final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetFloatingCombatText) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetFloatingCombatText");
static_assert(sizeof(OrionClientSettingsRecord_SetFloatingCombatText) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetFloatingCombatText");
static_assert(offsetof(OrionClientSettingsRecord_SetFloatingCombatText, bNewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetFloatingCombatText::bNewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetFriendlyHeroIndicatorRule
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetFriendlyHeroIndicatorRule final
{
public:
	EHealthIndicatorVisibility                    NewValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetFriendlyHeroIndicatorRule) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetFriendlyHeroIndicatorRule");
static_assert(sizeof(OrionClientSettingsRecord_SetFriendlyHeroIndicatorRule) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetFriendlyHeroIndicatorRule");
static_assert(offsetof(OrionClientSettingsRecord_SetFriendlyHeroIndicatorRule, NewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetFriendlyHeroIndicatorRule::NewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetFriendlyMinionIndicatorRule
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetFriendlyMinionIndicatorRule final
{
public:
	EHealthIndicatorVisibility                    NewValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetFriendlyMinionIndicatorRule) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetFriendlyMinionIndicatorRule");
static_assert(sizeof(OrionClientSettingsRecord_SetFriendlyMinionIndicatorRule) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetFriendlyMinionIndicatorRule");
static_assert(offsetof(OrionClientSettingsRecord_SetFriendlyMinionIndicatorRule, NewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetFriendlyMinionIndicatorRule::NewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetFrontEndPvpMode
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetFrontEndPvpMode final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetFrontEndPvpMode) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetFrontEndPvpMode");
static_assert(sizeof(OrionClientSettingsRecord_SetFrontEndPvpMode) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetFrontEndPvpMode");
static_assert(offsetof(OrionClientSettingsRecord_SetFrontEndPvpMode, bNewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetFrontEndPvpMode::bNewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetHotkeys
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetHotkeys final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetHotkeys) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetHotkeys");
static_assert(sizeof(OrionClientSettingsRecord_SetHotkeys) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetHotkeys");
static_assert(offsetof(OrionClientSettingsRecord_SetHotkeys, bNewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetHotkeys::bNewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetHUDUIScale
// 0x0004 (0x0004 - 0x0000)
struct OrionClientSettingsRecord_SetHUDUIScale final
{
public:
	float                                         InHUDUIScale;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetHUDUIScale) == 0x000004, "Wrong alignment on OrionClientSettingsRecord_SetHUDUIScale");
static_assert(sizeof(OrionClientSettingsRecord_SetHUDUIScale) == 0x000004, "Wrong size on OrionClientSettingsRecord_SetHUDUIScale");
static_assert(offsetof(OrionClientSettingsRecord_SetHUDUIScale, InHUDUIScale) == 0x000000, "Member 'OrionClientSettingsRecord_SetHUDUIScale::InHUDUIScale' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetKillFeed
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetKillFeed final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetKillFeed) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetKillFeed");
static_assert(sizeof(OrionClientSettingsRecord_SetKillFeed) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetKillFeed");
static_assert(offsetof(OrionClientSettingsRecord_SetKillFeed, bNewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetKillFeed::bNewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetLowHPRecallWarning
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetLowHPRecallWarning final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetLowHPRecallWarning) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetLowHPRecallWarning");
static_assert(sizeof(OrionClientSettingsRecord_SetLowHPRecallWarning) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetLowHPRecallWarning");
static_assert(offsetof(OrionClientSettingsRecord_SetLowHPRecallWarning, bNewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetLowHPRecallWarning::bNewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetMeleeHeroHealthBarPosition
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetMeleeHeroHealthBarPosition final
{
public:
	EPlayerOverheadHealthBarPosition              NewValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetMeleeHeroHealthBarPosition) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetMeleeHeroHealthBarPosition");
static_assert(sizeof(OrionClientSettingsRecord_SetMeleeHeroHealthBarPosition) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetMeleeHeroHealthBarPosition");
static_assert(offsetof(OrionClientSettingsRecord_SetMeleeHeroHealthBarPosition, NewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetMeleeHeroHealthBarPosition::NewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetMiniMap
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetMiniMap final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetMiniMap) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetMiniMap");
static_assert(sizeof(OrionClientSettingsRecord_SetMiniMap) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetMiniMap");
static_assert(offsetof(OrionClientSettingsRecord_SetMiniMap, bNewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetMiniMap::bNewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetOffScreenIndicatorHealthBars
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetOffScreenIndicatorHealthBars final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetOffScreenIndicatorHealthBars) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetOffScreenIndicatorHealthBars");
static_assert(sizeof(OrionClientSettingsRecord_SetOffScreenIndicatorHealthBars) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetOffScreenIndicatorHealthBars");
static_assert(offsetof(OrionClientSettingsRecord_SetOffScreenIndicatorHealthBars, bNewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetOffScreenIndicatorHealthBars::bNewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetOffScreenIndicatorPortraits
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetOffScreenIndicatorPortraits final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetOffScreenIndicatorPortraits) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetOffScreenIndicatorPortraits");
static_assert(sizeof(OrionClientSettingsRecord_SetOffScreenIndicatorPortraits) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetOffScreenIndicatorPortraits");
static_assert(offsetof(OrionClientSettingsRecord_SetOffScreenIndicatorPortraits, bNewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetOffScreenIndicatorPortraits::bNewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetOffScreenIndicatorVisibility
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetOffScreenIndicatorVisibility final
{
public:
	EOffScreenIndicatorVisibility                 NewValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetOffScreenIndicatorVisibility) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetOffScreenIndicatorVisibility");
static_assert(sizeof(OrionClientSettingsRecord_SetOffScreenIndicatorVisibility) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetOffScreenIndicatorVisibility");
static_assert(offsetof(OrionClientSettingsRecord_SetOffScreenIndicatorVisibility, NewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetOffScreenIndicatorVisibility::NewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetRangeHeroHealthBarPosition
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetRangeHeroHealthBarPosition final
{
public:
	EPlayerOverheadHealthBarPosition              NewValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetRangeHeroHealthBarPosition) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetRangeHeroHealthBarPosition");
static_assert(sizeof(OrionClientSettingsRecord_SetRangeHeroHealthBarPosition) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetRangeHeroHealthBarPosition");
static_assert(offsetof(OrionClientSettingsRecord_SetRangeHeroHealthBarPosition, NewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetRangeHeroHealthBarPosition::NewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetReticle
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetReticle final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetReticle) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetReticle");
static_assert(sizeof(OrionClientSettingsRecord_SetReticle) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetReticle");
static_assert(offsetof(OrionClientSettingsRecord_SetReticle, bNewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetReticle::bNewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetReverseEnemyHealthBarDirection
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetReverseEnemyHealthBarDirection final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetReverseEnemyHealthBarDirection) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetReverseEnemyHealthBarDirection");
static_assert(sizeof(OrionClientSettingsRecord_SetReverseEnemyHealthBarDirection) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetReverseEnemyHealthBarDirection");
static_assert(offsetof(OrionClientSettingsRecord_SetReverseEnemyHealthBarDirection, bNewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetReverseEnemyHealthBarDirection::bNewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetShowAbilityConfirmWidget
// 0x0004 (0x0004 - 0x0000)
struct OrionClientSettingsRecord_SetShowAbilityConfirmWidget final
{
public:
	int32                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetShowAbilityConfirmWidget) == 0x000004, "Wrong alignment on OrionClientSettingsRecord_SetShowAbilityConfirmWidget");
static_assert(sizeof(OrionClientSettingsRecord_SetShowAbilityConfirmWidget) == 0x000004, "Wrong size on OrionClientSettingsRecord_SetShowAbilityConfirmWidget");
static_assert(offsetof(OrionClientSettingsRecord_SetShowAbilityConfirmWidget, NewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetShowAbilityConfirmWidget::NewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetShowAddedItemsInChat
// 0x0004 (0x0004 - 0x0000)
struct OrionClientSettingsRecord_SetShowAddedItemsInChat final
{
public:
	int32                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetShowAddedItemsInChat) == 0x000004, "Wrong alignment on OrionClientSettingsRecord_SetShowAddedItemsInChat");
static_assert(sizeof(OrionClientSettingsRecord_SetShowAddedItemsInChat) == 0x000004, "Wrong size on OrionClientSettingsRecord_SetShowAddedItemsInChat");
static_assert(offsetof(OrionClientSettingsRecord_SetShowAddedItemsInChat, NewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetShowAddedItemsInChat::NewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetShowBasicAttackRangeIndicator
// 0x0004 (0x0004 - 0x0000)
struct OrionClientSettingsRecord_SetShowBasicAttackRangeIndicator final
{
public:
	int32                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetShowBasicAttackRangeIndicator) == 0x000004, "Wrong alignment on OrionClientSettingsRecord_SetShowBasicAttackRangeIndicator");
static_assert(sizeof(OrionClientSettingsRecord_SetShowBasicAttackRangeIndicator) == 0x000004, "Wrong size on OrionClientSettingsRecord_SetShowBasicAttackRangeIndicator");
static_assert(offsetof(OrionClientSettingsRecord_SetShowBasicAttackRangeIndicator, NewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetShowBasicAttackRangeIndicator::NewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetShowCompletedItemsInChat
// 0x0004 (0x0004 - 0x0000)
struct OrionClientSettingsRecord_SetShowCompletedItemsInChat final
{
public:
	int32                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetShowCompletedItemsInChat) == 0x000004, "Wrong alignment on OrionClientSettingsRecord_SetShowCompletedItemsInChat");
static_assert(sizeof(OrionClientSettingsRecord_SetShowCompletedItemsInChat) == 0x000004, "Wrong size on OrionClientSettingsRecord_SetShowCompletedItemsInChat");
static_assert(offsetof(OrionClientSettingsRecord_SetShowCompletedItemsInChat, NewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetShowCompletedItemsInChat::NewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetShowDiscardedItemsInChat
// 0x0004 (0x0004 - 0x0000)
struct OrionClientSettingsRecord_SetShowDiscardedItemsInChat final
{
public:
	int32                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetShowDiscardedItemsInChat) == 0x000004, "Wrong alignment on OrionClientSettingsRecord_SetShowDiscardedItemsInChat");
static_assert(sizeof(OrionClientSettingsRecord_SetShowDiscardedItemsInChat) == 0x000004, "Wrong size on OrionClientSettingsRecord_SetShowDiscardedItemsInChat");
static_assert(offsetof(OrionClientSettingsRecord_SetShowDiscardedItemsInChat, NewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetShowDiscardedItemsInChat::NewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetShowHUDHotkeys
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetShowHUDHotkeys final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetShowHUDHotkeys) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetShowHUDHotkeys");
static_assert(sizeof(OrionClientSettingsRecord_SetShowHUDHotkeys) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetShowHUDHotkeys");
static_assert(offsetof(OrionClientSettingsRecord_SetShowHUDHotkeys, bNewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetShowHUDHotkeys::bNewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetShowLaneGuides
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetShowLaneGuides final
{
public:
	bool                                          NewValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetShowLaneGuides) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetShowLaneGuides");
static_assert(sizeof(OrionClientSettingsRecord_SetShowLaneGuides) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetShowLaneGuides");
static_assert(offsetof(OrionClientSettingsRecord_SetShowLaneGuides, NewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetShowLaneGuides::NewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetStaticHealthBarPosition
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetStaticHealthBarPosition final
{
public:
	EStaticHealthBarPosition                      NewValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetStaticHealthBarPosition) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetStaticHealthBarPosition");
static_assert(sizeof(OrionClientSettingsRecord_SetStaticHealthBarPosition) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetStaticHealthBarPosition");
static_assert(offsetof(OrionClientSettingsRecord_SetStaticHealthBarPosition, NewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetStaticHealthBarPosition::NewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetStatsPanel
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetStatsPanel final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetStatsPanel) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetStatsPanel");
static_assert(sizeof(OrionClientSettingsRecord_SetStatsPanel) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetStatsPanel");
static_assert(offsetof(OrionClientSettingsRecord_SetStatsPanel, bNewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetStatsPanel::bNewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetStatusAreaDisplayType
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetStatusAreaDisplayType final
{
public:
	EStatusAreaDisplayType                        NewValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetStatusAreaDisplayType) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetStatusAreaDisplayType");
static_assert(sizeof(OrionClientSettingsRecord_SetStatusAreaDisplayType) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetStatusAreaDisplayType");
static_assert(offsetof(OrionClientSettingsRecord_SetStatusAreaDisplayType, NewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetStatusAreaDisplayType::NewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetTeamComms
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetTeamComms final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetTeamComms) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetTeamComms");
static_assert(sizeof(OrionClientSettingsRecord_SetTeamComms) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetTeamComms");
static_assert(offsetof(OrionClientSettingsRecord_SetTeamComms, bNewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetTeamComms::bNewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetTeamCoreHP
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetTeamCoreHP final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetTeamCoreHP) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetTeamCoreHP");
static_assert(sizeof(OrionClientSettingsRecord_SetTeamCoreHP) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetTeamCoreHP");
static_assert(offsetof(OrionClientSettingsRecord_SetTeamCoreHP, bNewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetTeamCoreHP::bNewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.SetTeamFrames
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_SetTeamFrames final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_SetTeamFrames) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_SetTeamFrames");
static_assert(sizeof(OrionClientSettingsRecord_SetTeamFrames) == 0x000001, "Wrong size on OrionClientSettingsRecord_SetTeamFrames");
static_assert(offsetof(OrionClientSettingsRecord_SetTeamFrames, bNewValue) == 0x000000, "Member 'OrionClientSettingsRecord_SetTeamFrames::bNewValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetAbilities
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetAbilities final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetAbilities) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetAbilities");
static_assert(sizeof(OrionClientSettingsRecord_GetAbilities) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetAbilities");
static_assert(offsetof(OrionClientSettingsRecord_GetAbilities, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetAbilities::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetAbilityHotkeys
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetAbilityHotkeys final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetAbilityHotkeys) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetAbilityHotkeys");
static_assert(sizeof(OrionClientSettingsRecord_GetAbilityHotkeys) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetAbilityHotkeys");
static_assert(offsetof(OrionClientSettingsRecord_GetAbilityHotkeys, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetAbilityHotkeys::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetAnnouncements
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetAnnouncements final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetAnnouncements) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetAnnouncements");
static_assert(sizeof(OrionClientSettingsRecord_GetAnnouncements) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetAnnouncements");
static_assert(offsetof(OrionClientSettingsRecord_GetAnnouncements, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetAnnouncements::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetAutoOpenCardShop
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetAutoOpenCardShop final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetAutoOpenCardShop) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetAutoOpenCardShop");
static_assert(sizeof(OrionClientSettingsRecord_GetAutoOpenCardShop) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetAutoOpenCardShop");
static_assert(offsetof(OrionClientSettingsRecord_GetAutoOpenCardShop, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetAutoOpenCardShop::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetAutoPlayInstantReplay
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetAutoPlayInstantReplay final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetAutoPlayInstantReplay) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetAutoPlayInstantReplay");
static_assert(sizeof(OrionClientSettingsRecord_GetAutoPlayInstantReplay) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetAutoPlayInstantReplay");
static_assert(offsetof(OrionClientSettingsRecord_GetAutoPlayInstantReplay, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetAutoPlayInstantReplay::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetBuffs
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetBuffs final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetBuffs) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetBuffs");
static_assert(sizeof(OrionClientSettingsRecord_GetBuffs) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetBuffs");
static_assert(offsetof(OrionClientSettingsRecord_GetBuffs, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetBuffs::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetCardHotkeys
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetCardHotkeys final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetCardHotkeys) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetCardHotkeys");
static_assert(sizeof(OrionClientSettingsRecord_GetCardHotkeys) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetCardHotkeys");
static_assert(offsetof(OrionClientSettingsRecord_GetCardHotkeys, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetCardHotkeys::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetCardsAndGems
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetCardsAndGems final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetCardsAndGems) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetCardsAndGems");
static_assert(sizeof(OrionClientSettingsRecord_GetCardsAndGems) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetCardsAndGems");
static_assert(offsetof(OrionClientSettingsRecord_GetCardsAndGems, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetCardsAndGems::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetChat
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetChat final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetChat) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetChat");
static_assert(sizeof(OrionClientSettingsRecord_GetChat) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetChat");
static_assert(offsetof(OrionClientSettingsRecord_GetChat, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetChat::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetDetailedStatsPanelPortrait
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetDetailedStatsPanelPortrait final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetDetailedStatsPanelPortrait) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetDetailedStatsPanelPortrait");
static_assert(sizeof(OrionClientSettingsRecord_GetDetailedStatsPanelPortrait) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetDetailedStatsPanelPortrait");
static_assert(offsetof(OrionClientSettingsRecord_GetDetailedStatsPanelPortrait, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetDetailedStatsPanelPortrait::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetDisplayDetailedStatsPanel
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetDisplayDetailedStatsPanel final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetDisplayDetailedStatsPanel) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetDisplayDetailedStatsPanel");
static_assert(sizeof(OrionClientSettingsRecord_GetDisplayDetailedStatsPanel) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetDisplayDetailedStatsPanel");
static_assert(offsetof(OrionClientSettingsRecord_GetDisplayDetailedStatsPanel, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetDisplayDetailedStatsPanel::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetDisplayMeleeHeroReticle
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetDisplayMeleeHeroReticle final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetDisplayMeleeHeroReticle) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetDisplayMeleeHeroReticle");
static_assert(sizeof(OrionClientSettingsRecord_GetDisplayMeleeHeroReticle) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetDisplayMeleeHeroReticle");
static_assert(offsetof(OrionClientSettingsRecord_GetDisplayMeleeHeroReticle, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetDisplayMeleeHeroReticle::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetDisplayNumericalValues
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetDisplayNumericalValues final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetDisplayNumericalValues) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetDisplayNumericalValues");
static_assert(sizeof(OrionClientSettingsRecord_GetDisplayNumericalValues) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetDisplayNumericalValues");
static_assert(offsetof(OrionClientSettingsRecord_GetDisplayNumericalValues, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetDisplayNumericalValues::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetEnableCardOverLocalPlayer
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetEnableCardOverLocalPlayer final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetEnableCardOverLocalPlayer) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetEnableCardOverLocalPlayer");
static_assert(sizeof(OrionClientSettingsRecord_GetEnableCardOverLocalPlayer) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetEnableCardOverLocalPlayer");
static_assert(offsetof(OrionClientSettingsRecord_GetEnableCardOverLocalPlayer, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetEnableCardOverLocalPlayer::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetEnableDeathcam
// 0x0004 (0x0004 - 0x0000)
struct OrionClientSettingsRecord_GetEnableDeathcam final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetEnableDeathcam) == 0x000004, "Wrong alignment on OrionClientSettingsRecord_GetEnableDeathcam");
static_assert(sizeof(OrionClientSettingsRecord_GetEnableDeathcam) == 0x000004, "Wrong size on OrionClientSettingsRecord_GetEnableDeathcam");
static_assert(offsetof(OrionClientSettingsRecord_GetEnableDeathcam, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetEnableDeathcam::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetEnemyHeroIndicatorRule
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetEnemyHeroIndicatorRule final
{
public:
	EHealthIndicatorVisibility                    ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetEnemyHeroIndicatorRule) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetEnemyHeroIndicatorRule");
static_assert(sizeof(OrionClientSettingsRecord_GetEnemyHeroIndicatorRule) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetEnemyHeroIndicatorRule");
static_assert(offsetof(OrionClientSettingsRecord_GetEnemyHeroIndicatorRule, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetEnemyHeroIndicatorRule::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetEnemyMinionIndicatorRule
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetEnemyMinionIndicatorRule final
{
public:
	EHealthIndicatorVisibility                    ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetEnemyMinionIndicatorRule) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetEnemyMinionIndicatorRule");
static_assert(sizeof(OrionClientSettingsRecord_GetEnemyMinionIndicatorRule) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetEnemyMinionIndicatorRule");
static_assert(offsetof(OrionClientSettingsRecord_GetEnemyMinionIndicatorRule, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetEnemyMinionIndicatorRule::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetFadeHealthBarWhenOutOfCombat
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetFadeHealthBarWhenOutOfCombat final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetFadeHealthBarWhenOutOfCombat) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetFadeHealthBarWhenOutOfCombat");
static_assert(sizeof(OrionClientSettingsRecord_GetFadeHealthBarWhenOutOfCombat) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetFadeHealthBarWhenOutOfCombat");
static_assert(offsetof(OrionClientSettingsRecord_GetFadeHealthBarWhenOutOfCombat, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetFadeHealthBarWhenOutOfCombat::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetFloatingCombatText
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetFloatingCombatText final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetFloatingCombatText) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetFloatingCombatText");
static_assert(sizeof(OrionClientSettingsRecord_GetFloatingCombatText) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetFloatingCombatText");
static_assert(offsetof(OrionClientSettingsRecord_GetFloatingCombatText, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetFloatingCombatText::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetFriendlyHeroIndicatorRule
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetFriendlyHeroIndicatorRule final
{
public:
	EHealthIndicatorVisibility                    ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetFriendlyHeroIndicatorRule) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetFriendlyHeroIndicatorRule");
static_assert(sizeof(OrionClientSettingsRecord_GetFriendlyHeroIndicatorRule) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetFriendlyHeroIndicatorRule");
static_assert(offsetof(OrionClientSettingsRecord_GetFriendlyHeroIndicatorRule, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetFriendlyHeroIndicatorRule::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetFriendlyMinionIndicatorRule
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetFriendlyMinionIndicatorRule final
{
public:
	EHealthIndicatorVisibility                    ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetFriendlyMinionIndicatorRule) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetFriendlyMinionIndicatorRule");
static_assert(sizeof(OrionClientSettingsRecord_GetFriendlyMinionIndicatorRule) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetFriendlyMinionIndicatorRule");
static_assert(offsetof(OrionClientSettingsRecord_GetFriendlyMinionIndicatorRule, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetFriendlyMinionIndicatorRule::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetFrontEndPvpMode
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetFrontEndPvpMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetFrontEndPvpMode) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetFrontEndPvpMode");
static_assert(sizeof(OrionClientSettingsRecord_GetFrontEndPvpMode) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetFrontEndPvpMode");
static_assert(offsetof(OrionClientSettingsRecord_GetFrontEndPvpMode, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetFrontEndPvpMode::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetHotkeys
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetHotkeys final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetHotkeys) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetHotkeys");
static_assert(sizeof(OrionClientSettingsRecord_GetHotkeys) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetHotkeys");
static_assert(offsetof(OrionClientSettingsRecord_GetHotkeys, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetHotkeys::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetHUDUIScale
// 0x0004 (0x0004 - 0x0000)
struct OrionClientSettingsRecord_GetHUDUIScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetHUDUIScale) == 0x000004, "Wrong alignment on OrionClientSettingsRecord_GetHUDUIScale");
static_assert(sizeof(OrionClientSettingsRecord_GetHUDUIScale) == 0x000004, "Wrong size on OrionClientSettingsRecord_GetHUDUIScale");
static_assert(offsetof(OrionClientSettingsRecord_GetHUDUIScale, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetHUDUIScale::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetKillFeed
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetKillFeed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetKillFeed) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetKillFeed");
static_assert(sizeof(OrionClientSettingsRecord_GetKillFeed) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetKillFeed");
static_assert(offsetof(OrionClientSettingsRecord_GetKillFeed, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetKillFeed::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetLowHPRecallWarning
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetLowHPRecallWarning final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetLowHPRecallWarning) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetLowHPRecallWarning");
static_assert(sizeof(OrionClientSettingsRecord_GetLowHPRecallWarning) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetLowHPRecallWarning");
static_assert(offsetof(OrionClientSettingsRecord_GetLowHPRecallWarning, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetLowHPRecallWarning::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetMeleeHeroHealthBarPosition
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetMeleeHeroHealthBarPosition final
{
public:
	EPlayerOverheadHealthBarPosition              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetMeleeHeroHealthBarPosition) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetMeleeHeroHealthBarPosition");
static_assert(sizeof(OrionClientSettingsRecord_GetMeleeHeroHealthBarPosition) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetMeleeHeroHealthBarPosition");
static_assert(offsetof(OrionClientSettingsRecord_GetMeleeHeroHealthBarPosition, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetMeleeHeroHealthBarPosition::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetMiniMap
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetMiniMap final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetMiniMap) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetMiniMap");
static_assert(sizeof(OrionClientSettingsRecord_GetMiniMap) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetMiniMap");
static_assert(offsetof(OrionClientSettingsRecord_GetMiniMap, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetMiniMap::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetOffScreenIndicatorHealthBars
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetOffScreenIndicatorHealthBars final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetOffScreenIndicatorHealthBars) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetOffScreenIndicatorHealthBars");
static_assert(sizeof(OrionClientSettingsRecord_GetOffScreenIndicatorHealthBars) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetOffScreenIndicatorHealthBars");
static_assert(offsetof(OrionClientSettingsRecord_GetOffScreenIndicatorHealthBars, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetOffScreenIndicatorHealthBars::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetOffScreenIndicatorPortraits
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetOffScreenIndicatorPortraits final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetOffScreenIndicatorPortraits) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetOffScreenIndicatorPortraits");
static_assert(sizeof(OrionClientSettingsRecord_GetOffScreenIndicatorPortraits) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetOffScreenIndicatorPortraits");
static_assert(offsetof(OrionClientSettingsRecord_GetOffScreenIndicatorPortraits, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetOffScreenIndicatorPortraits::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetOffScreenIndicatorVisibility
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetOffScreenIndicatorVisibility final
{
public:
	EOffScreenIndicatorVisibility                 ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetOffScreenIndicatorVisibility) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetOffScreenIndicatorVisibility");
static_assert(sizeof(OrionClientSettingsRecord_GetOffScreenIndicatorVisibility) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetOffScreenIndicatorVisibility");
static_assert(offsetof(OrionClientSettingsRecord_GetOffScreenIndicatorVisibility, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetOffScreenIndicatorVisibility::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetRangeHeroHealthBarPosition
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetRangeHeroHealthBarPosition final
{
public:
	EPlayerOverheadHealthBarPosition              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetRangeHeroHealthBarPosition) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetRangeHeroHealthBarPosition");
static_assert(sizeof(OrionClientSettingsRecord_GetRangeHeroHealthBarPosition) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetRangeHeroHealthBarPosition");
static_assert(offsetof(OrionClientSettingsRecord_GetRangeHeroHealthBarPosition, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetRangeHeroHealthBarPosition::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetReticle
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetReticle final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetReticle) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetReticle");
static_assert(sizeof(OrionClientSettingsRecord_GetReticle) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetReticle");
static_assert(offsetof(OrionClientSettingsRecord_GetReticle, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetReticle::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetReverseEnemyHealthBarDirection
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetReverseEnemyHealthBarDirection final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetReverseEnemyHealthBarDirection) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetReverseEnemyHealthBarDirection");
static_assert(sizeof(OrionClientSettingsRecord_GetReverseEnemyHealthBarDirection) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetReverseEnemyHealthBarDirection");
static_assert(offsetof(OrionClientSettingsRecord_GetReverseEnemyHealthBarDirection, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetReverseEnemyHealthBarDirection::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetShowAbilityConfirmWidget
// 0x0004 (0x0004 - 0x0000)
struct OrionClientSettingsRecord_GetShowAbilityConfirmWidget final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetShowAbilityConfirmWidget) == 0x000004, "Wrong alignment on OrionClientSettingsRecord_GetShowAbilityConfirmWidget");
static_assert(sizeof(OrionClientSettingsRecord_GetShowAbilityConfirmWidget) == 0x000004, "Wrong size on OrionClientSettingsRecord_GetShowAbilityConfirmWidget");
static_assert(offsetof(OrionClientSettingsRecord_GetShowAbilityConfirmWidget, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetShowAbilityConfirmWidget::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetShowAddedItemsInChat
// 0x0004 (0x0004 - 0x0000)
struct OrionClientSettingsRecord_GetShowAddedItemsInChat final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetShowAddedItemsInChat) == 0x000004, "Wrong alignment on OrionClientSettingsRecord_GetShowAddedItemsInChat");
static_assert(sizeof(OrionClientSettingsRecord_GetShowAddedItemsInChat) == 0x000004, "Wrong size on OrionClientSettingsRecord_GetShowAddedItemsInChat");
static_assert(offsetof(OrionClientSettingsRecord_GetShowAddedItemsInChat, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetShowAddedItemsInChat::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetShowBasicAttackRangeIndicator
// 0x0004 (0x0004 - 0x0000)
struct OrionClientSettingsRecord_GetShowBasicAttackRangeIndicator final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetShowBasicAttackRangeIndicator) == 0x000004, "Wrong alignment on OrionClientSettingsRecord_GetShowBasicAttackRangeIndicator");
static_assert(sizeof(OrionClientSettingsRecord_GetShowBasicAttackRangeIndicator) == 0x000004, "Wrong size on OrionClientSettingsRecord_GetShowBasicAttackRangeIndicator");
static_assert(offsetof(OrionClientSettingsRecord_GetShowBasicAttackRangeIndicator, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetShowBasicAttackRangeIndicator::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetShowCompletedItemsInChat
// 0x0004 (0x0004 - 0x0000)
struct OrionClientSettingsRecord_GetShowCompletedItemsInChat final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetShowCompletedItemsInChat) == 0x000004, "Wrong alignment on OrionClientSettingsRecord_GetShowCompletedItemsInChat");
static_assert(sizeof(OrionClientSettingsRecord_GetShowCompletedItemsInChat) == 0x000004, "Wrong size on OrionClientSettingsRecord_GetShowCompletedItemsInChat");
static_assert(offsetof(OrionClientSettingsRecord_GetShowCompletedItemsInChat, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetShowCompletedItemsInChat::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetShowDiscardedItemsInChat
// 0x0004 (0x0004 - 0x0000)
struct OrionClientSettingsRecord_GetShowDiscardedItemsInChat final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetShowDiscardedItemsInChat) == 0x000004, "Wrong alignment on OrionClientSettingsRecord_GetShowDiscardedItemsInChat");
static_assert(sizeof(OrionClientSettingsRecord_GetShowDiscardedItemsInChat) == 0x000004, "Wrong size on OrionClientSettingsRecord_GetShowDiscardedItemsInChat");
static_assert(offsetof(OrionClientSettingsRecord_GetShowDiscardedItemsInChat, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetShowDiscardedItemsInChat::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetShowHUDHotkeys
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetShowHUDHotkeys final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetShowHUDHotkeys) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetShowHUDHotkeys");
static_assert(sizeof(OrionClientSettingsRecord_GetShowHUDHotkeys) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetShowHUDHotkeys");
static_assert(offsetof(OrionClientSettingsRecord_GetShowHUDHotkeys, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetShowHUDHotkeys::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetShowLaneGuides
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetShowLaneGuides final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetShowLaneGuides) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetShowLaneGuides");
static_assert(sizeof(OrionClientSettingsRecord_GetShowLaneGuides) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetShowLaneGuides");
static_assert(offsetof(OrionClientSettingsRecord_GetShowLaneGuides, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetShowLaneGuides::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetStaticHealthBarPosition
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetStaticHealthBarPosition final
{
public:
	EStaticHealthBarPosition                      ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetStaticHealthBarPosition) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetStaticHealthBarPosition");
static_assert(sizeof(OrionClientSettingsRecord_GetStaticHealthBarPosition) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetStaticHealthBarPosition");
static_assert(offsetof(OrionClientSettingsRecord_GetStaticHealthBarPosition, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetStaticHealthBarPosition::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetStatsPanel
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetStatsPanel final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetStatsPanel) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetStatsPanel");
static_assert(sizeof(OrionClientSettingsRecord_GetStatsPanel) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetStatsPanel");
static_assert(offsetof(OrionClientSettingsRecord_GetStatsPanel, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetStatsPanel::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetStatusAreaDisplayType
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetStatusAreaDisplayType final
{
public:
	EStatusAreaDisplayType                        ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetStatusAreaDisplayType) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetStatusAreaDisplayType");
static_assert(sizeof(OrionClientSettingsRecord_GetStatusAreaDisplayType) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetStatusAreaDisplayType");
static_assert(offsetof(OrionClientSettingsRecord_GetStatusAreaDisplayType, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetStatusAreaDisplayType::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetTeamComms
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetTeamComms final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetTeamComms) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetTeamComms");
static_assert(sizeof(OrionClientSettingsRecord_GetTeamComms) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetTeamComms");
static_assert(offsetof(OrionClientSettingsRecord_GetTeamComms, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetTeamComms::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetTeamCoreHP
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetTeamCoreHP final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetTeamCoreHP) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetTeamCoreHP");
static_assert(sizeof(OrionClientSettingsRecord_GetTeamCoreHP) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetTeamCoreHP");
static_assert(offsetof(OrionClientSettingsRecord_GetTeamCoreHP, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetTeamCoreHP::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.GetTeamFrames
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_GetTeamFrames final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_GetTeamFrames) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_GetTeamFrames");
static_assert(sizeof(OrionClientSettingsRecord_GetTeamFrames) == 0x000001, "Wrong size on OrionClientSettingsRecord_GetTeamFrames");
static_assert(offsetof(OrionClientSettingsRecord_GetTeamFrames, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_GetTeamFrames::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.HasShownCardOnboard
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_HasShownCardOnboard final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_HasShownCardOnboard) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_HasShownCardOnboard");
static_assert(sizeof(OrionClientSettingsRecord_HasShownCardOnboard) == 0x000001, "Wrong size on OrionClientSettingsRecord_HasShownCardOnboard");
static_assert(offsetof(OrionClientSettingsRecord_HasShownCardOnboard, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_HasShownCardOnboard::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionClientSettingsRecord.HasShownDeckBuilderDialog
// 0x0001 (0x0001 - 0x0000)
struct OrionClientSettingsRecord_HasShownDeckBuilderDialog final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionClientSettingsRecord_HasShownDeckBuilderDialog) == 0x000001, "Wrong alignment on OrionClientSettingsRecord_HasShownDeckBuilderDialog");
static_assert(sizeof(OrionClientSettingsRecord_HasShownDeckBuilderDialog) == 0x000001, "Wrong size on OrionClientSettingsRecord_HasShownDeckBuilderDialog");
static_assert(offsetof(OrionClientSettingsRecord_HasShownDeckBuilderDialog, ReturnValue) == 0x000000, "Member 'OrionClientSettingsRecord_HasShownDeckBuilderDialog::ReturnValue' has a wrong offset!");

// DelegateFunction OrionGame.OrionHeroData.OnSimpleActorLoaded__DelegateSignature
// 0x0008 (0x0008 - 0x0000)
struct OrionHeroData_OnSimpleActorLoaded__DelegateSignature final
{
public:
	class UClass*                                 Result;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionHeroData_OnSimpleActorLoaded__DelegateSignature) == 0x000008, "Wrong alignment on OrionHeroData_OnSimpleActorLoaded__DelegateSignature");
static_assert(sizeof(OrionHeroData_OnSimpleActorLoaded__DelegateSignature) == 0x000008, "Wrong size on OrionHeroData_OnSimpleActorLoaded__DelegateSignature");
static_assert(offsetof(OrionHeroData_OnSimpleActorLoaded__DelegateSignature, Result) == 0x000000, "Member 'OrionHeroData_OnSimpleActorLoaded__DelegateSignature::Result' has a wrong offset!");

// DelegateFunction OrionGame.OrionHeroData.OnSimpleActorLoadedMulti__DelegateSignature
// 0x0008 (0x0008 - 0x0000)
struct OrionHeroData_OnSimpleActorLoadedMulti__DelegateSignature final
{
public:
	class UClass*                                 Result;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionHeroData_OnSimpleActorLoadedMulti__DelegateSignature) == 0x000008, "Wrong alignment on OrionHeroData_OnSimpleActorLoadedMulti__DelegateSignature");
static_assert(sizeof(OrionHeroData_OnSimpleActorLoadedMulti__DelegateSignature) == 0x000008, "Wrong size on OrionHeroData_OnSimpleActorLoadedMulti__DelegateSignature");
static_assert(offsetof(OrionHeroData_OnSimpleActorLoadedMulti__DelegateSignature, Result) == 0x000000, "Member 'OrionHeroData_OnSimpleActorLoadedMulti__DelegateSignature::Result' has a wrong offset!");

// Function OrionGame.OrionHeroData.IsHeroRecommended
// 0x0001 (0x0001 - 0x0000)
struct OrionHeroData_IsHeroRecommended final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionHeroData_IsHeroRecommended) == 0x000001, "Wrong alignment on OrionHeroData_IsHeroRecommended");
static_assert(sizeof(OrionHeroData_IsHeroRecommended) == 0x000001, "Wrong size on OrionHeroData_IsHeroRecommended");
static_assert(offsetof(OrionHeroData_IsHeroRecommended, ReturnValue) == 0x000000, "Member 'OrionHeroData_IsHeroRecommended::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionMcpCardPackItemDefinition.GetExplicitCards
// 0x0018 (0x0018 - 0x0000)
struct OrionMcpCardPackItemDefinition_GetExplicitCards final
{
public:
	TArray<class UOrionLegacyCardItemDefinition*> Cards;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionMcpCardPackItemDefinition_GetExplicitCards) == 0x000008, "Wrong alignment on OrionMcpCardPackItemDefinition_GetExplicitCards");
static_assert(sizeof(OrionMcpCardPackItemDefinition_GetExplicitCards) == 0x000018, "Wrong size on OrionMcpCardPackItemDefinition_GetExplicitCards");
static_assert(offsetof(OrionMcpCardPackItemDefinition_GetExplicitCards, Cards) == 0x000000, "Member 'OrionMcpCardPackItemDefinition_GetExplicitCards::Cards' has a wrong offset!");
static_assert(offsetof(OrionMcpCardPackItemDefinition_GetExplicitCards, ReturnValue) == 0x000010, "Member 'OrionMcpCardPackItemDefinition_GetExplicitCards::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCraftingDeviceGlyph.OnActivationChanged
// 0x0001 (0x0001 - 0x0000)
struct OrionCraftingDeviceGlyph_OnActivationChanged final
{
public:
	bool                                          bActivated;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCraftingDeviceGlyph_OnActivationChanged) == 0x000001, "Wrong alignment on OrionCraftingDeviceGlyph_OnActivationChanged");
static_assert(sizeof(OrionCraftingDeviceGlyph_OnActivationChanged) == 0x000001, "Wrong size on OrionCraftingDeviceGlyph_OnActivationChanged");
static_assert(offsetof(OrionCraftingDeviceGlyph_OnActivationChanged, bActivated) == 0x000000, "Member 'OrionCraftingDeviceGlyph_OnActivationChanged::bActivated' has a wrong offset!");

// Function OrionGame.OrionCraftingDeviceNode.GetSlotComponentTimelineDirectly
// 0x0008 (0x0008 - 0x0000)
struct OrionCraftingDeviceNode_GetSlotComponentTimelineDirectly final
{
public:
	class UTimelineComponent*                     ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCraftingDeviceNode_GetSlotComponentTimelineDirectly) == 0x000008, "Wrong alignment on OrionCraftingDeviceNode_GetSlotComponentTimelineDirectly");
static_assert(sizeof(OrionCraftingDeviceNode_GetSlotComponentTimelineDirectly) == 0x000008, "Wrong size on OrionCraftingDeviceNode_GetSlotComponentTimelineDirectly");
static_assert(offsetof(OrionCraftingDeviceNode_GetSlotComponentTimelineDirectly, ReturnValue) == 0x000000, "Member 'OrionCraftingDeviceNode_GetSlotComponentTimelineDirectly::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCraftingDeviceNode.OnActivationChanged
// 0x0001 (0x0001 - 0x0000)
struct OrionCraftingDeviceNode_OnActivationChanged final
{
public:
	bool                                          bActivated;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCraftingDeviceNode_OnActivationChanged) == 0x000001, "Wrong alignment on OrionCraftingDeviceNode_OnActivationChanged");
static_assert(sizeof(OrionCraftingDeviceNode_OnActivationChanged) == 0x000001, "Wrong size on OrionCraftingDeviceNode_OnActivationChanged");
static_assert(offsetof(OrionCraftingDeviceNode_OnActivationChanged, bActivated) == 0x000000, "Member 'OrionCraftingDeviceNode_OnActivationChanged::bActivated' has a wrong offset!");

// Function OrionGame.OrionCraftingDeviceNode.OnComponentSlotted
// 0x0018 (0x0018 - 0x0000)
struct OrionCraftingDeviceNode_OnComponentSlotted final
{
public:
	class UOrionComponentItemDefinition*          SlottedComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     ComponentIconMaterial;                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weight;                                            // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionCraftingDeviceNode_OnComponentSlotted) == 0x000008, "Wrong alignment on OrionCraftingDeviceNode_OnComponentSlotted");
static_assert(sizeof(OrionCraftingDeviceNode_OnComponentSlotted) == 0x000018, "Wrong size on OrionCraftingDeviceNode_OnComponentSlotted");
static_assert(offsetof(OrionCraftingDeviceNode_OnComponentSlotted, SlottedComponent) == 0x000000, "Member 'OrionCraftingDeviceNode_OnComponentSlotted::SlottedComponent' has a wrong offset!");
static_assert(offsetof(OrionCraftingDeviceNode_OnComponentSlotted, ComponentIconMaterial) == 0x000008, "Member 'OrionCraftingDeviceNode_OnComponentSlotted::ComponentIconMaterial' has a wrong offset!");
static_assert(offsetof(OrionCraftingDeviceNode_OnComponentSlotted, Weight) == 0x000010, "Member 'OrionCraftingDeviceNode_OnComponentSlotted::Weight' has a wrong offset!");

// Function OrionGame.OrionMcpComponentItem.GetInternalData
// 0x0008 (0x0008 - 0x0000)
struct OrionMcpComponentItem_GetInternalData final
{
public:
	class UOrionComponentItemDefinition*          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpComponentItem_GetInternalData) == 0x000008, "Wrong alignment on OrionMcpComponentItem_GetInternalData");
static_assert(sizeof(OrionMcpComponentItem_GetInternalData) == 0x000008, "Wrong size on OrionMcpComponentItem_GetInternalData");
static_assert(offsetof(OrionMcpComponentItem_GetInternalData, ReturnValue) == 0x000000, "Member 'OrionMcpComponentItem_GetInternalData::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionCustomStoreContentWidget.OnOfferSet
// 0x0130 (0x0130 - 0x0000)
struct OrionCustomStoreContentWidget_OnOfferSet final
{
public:
	struct FStoreOfferBP                          InOffer;                                           // 0x0000(0x0130)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCustomStoreContentWidget_OnOfferSet) == 0x000008, "Wrong alignment on OrionCustomStoreContentWidget_OnOfferSet");
static_assert(sizeof(OrionCustomStoreContentWidget_OnOfferSet) == 0x000130, "Wrong size on OrionCustomStoreContentWidget_OnOfferSet");
static_assert(offsetof(OrionCustomStoreContentWidget_OnOfferSet, InOffer) == 0x000000, "Member 'OrionCustomStoreContentWidget_OnOfferSet::InOffer' has a wrong offset!");

// Function OrionGame.OrionCustomStoreContentWidget.SetOffer
// 0x0130 (0x0130 - 0x0000)
struct OrionCustomStoreContentWidget_SetOffer final
{
public:
	struct FStoreOfferBP                          InOffer;                                           // 0x0000(0x0130)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionCustomStoreContentWidget_SetOffer) == 0x000008, "Wrong alignment on OrionCustomStoreContentWidget_SetOffer");
static_assert(sizeof(OrionCustomStoreContentWidget_SetOffer) == 0x000130, "Wrong size on OrionCustomStoreContentWidget_SetOffer");
static_assert(offsetof(OrionCustomStoreContentWidget_SetOffer, InOffer) == 0x000000, "Member 'OrionCustomStoreContentWidget_SetOffer::InOffer' has a wrong offset!");

// Function OrionGame.OrionHeroTwinblastAnimInstance.OpenArmVent
// 0x0004 (0x0004 - 0x0000)
struct OrionHeroTwinblastAnimInstance_OpenArmVent final
{
public:
	float                                         OpenTime;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionHeroTwinblastAnimInstance_OpenArmVent) == 0x000004, "Wrong alignment on OrionHeroTwinblastAnimInstance_OpenArmVent");
static_assert(sizeof(OrionHeroTwinblastAnimInstance_OpenArmVent) == 0x000004, "Wrong size on OrionHeroTwinblastAnimInstance_OpenArmVent");
static_assert(offsetof(OrionHeroTwinblastAnimInstance_OpenArmVent, OpenTime) == 0x000000, "Member 'OrionHeroTwinblastAnimInstance_OpenArmVent::OpenTime' has a wrong offset!");

// Function OrionGame.OrionPedestalHero.OnPedestalActorTypeSet
// 0x0001 (0x0001 - 0x0000)
struct OrionPedestalHero_OnPedestalActorTypeSet final
{
public:
	EPedestalActorType                            PedestalActorType;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPedestalHero_OnPedestalActorTypeSet) == 0x000001, "Wrong alignment on OrionPedestalHero_OnPedestalActorTypeSet");
static_assert(sizeof(OrionPedestalHero_OnPedestalActorTypeSet) == 0x000001, "Wrong size on OrionPedestalHero_OnPedestalActorTypeSet");
static_assert(offsetof(OrionPedestalHero_OnPedestalActorTypeSet, PedestalActorType) == 0x000000, "Member 'OrionPedestalHero_OnPedestalActorTypeSet::PedestalActorType' has a wrong offset!");

// Function OrionGame.OrionDecorBanner.CreateDecorBanner
// 0x0078 (0x0078 - 0x0000)
struct OrionDecorBanner_CreateDecorBanner final
{
public:
	class AOrionPlayerState_Game*                 InPlayerState;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBannerSpec                            BannerSpec;                                        // 0x0008(0x0068)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          bShowPortrait;                                     // 0x0070(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecreateIfExists;                                 // 0x0071(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveAtOnce;                                     // 0x0072(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0073(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionDecorBanner_CreateDecorBanner) == 0x000008, "Wrong alignment on OrionDecorBanner_CreateDecorBanner");
static_assert(sizeof(OrionDecorBanner_CreateDecorBanner) == 0x000078, "Wrong size on OrionDecorBanner_CreateDecorBanner");
static_assert(offsetof(OrionDecorBanner_CreateDecorBanner, InPlayerState) == 0x000000, "Member 'OrionDecorBanner_CreateDecorBanner::InPlayerState' has a wrong offset!");
static_assert(offsetof(OrionDecorBanner_CreateDecorBanner, BannerSpec) == 0x000008, "Member 'OrionDecorBanner_CreateDecorBanner::BannerSpec' has a wrong offset!");
static_assert(offsetof(OrionDecorBanner_CreateDecorBanner, bShowPortrait) == 0x000070, "Member 'OrionDecorBanner_CreateDecorBanner::bShowPortrait' has a wrong offset!");
static_assert(offsetof(OrionDecorBanner_CreateDecorBanner, bRecreateIfExists) == 0x000071, "Member 'OrionDecorBanner_CreateDecorBanner::bRecreateIfExists' has a wrong offset!");
static_assert(offsetof(OrionDecorBanner_CreateDecorBanner, bRemoveAtOnce) == 0x000072, "Member 'OrionDecorBanner_CreateDecorBanner::bRemoveAtOnce' has a wrong offset!");
static_assert(offsetof(OrionDecorBanner_CreateDecorBanner, ReturnValue) == 0x000073, "Member 'OrionDecorBanner_CreateDecorBanner::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionDecorBanner.RemoveDecorBanner
// 0x0001 (0x0001 - 0x0000)
struct OrionDecorBanner_RemoveDecorBanner final
{
public:
	bool                                          bRemoveAtOnce;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDecorBanner_RemoveDecorBanner) == 0x000001, "Wrong alignment on OrionDecorBanner_RemoveDecorBanner");
static_assert(sizeof(OrionDecorBanner_RemoveDecorBanner) == 0x000001, "Wrong size on OrionDecorBanner_RemoveDecorBanner");
static_assert(offsetof(OrionDecorBanner_RemoveDecorBanner, bRemoveAtOnce) == 0x000000, "Member 'OrionDecorBanner_RemoveDecorBanner::bRemoveAtOnce' has a wrong offset!");

// Function OrionGame.OrionDecorBanner.SetBannerVisibility
// 0x0001 (0x0001 - 0x0000)
struct OrionDecorBanner_SetBannerVisibility final
{
public:
	bool                                          bIsVisible;                                        // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDecorBanner_SetBannerVisibility) == 0x000001, "Wrong alignment on OrionDecorBanner_SetBannerVisibility");
static_assert(sizeof(OrionDecorBanner_SetBannerVisibility) == 0x000001, "Wrong size on OrionDecorBanner_SetBannerVisibility");
static_assert(offsetof(OrionDecorBanner_SetBannerVisibility, bIsVisible) == 0x000000, "Member 'OrionDecorBanner_SetBannerVisibility::bIsVisible' has a wrong offset!");

// Function OrionGame.OrionDecorBanner.GetSlot
// 0x0004 (0x0004 - 0x0000)
struct OrionDecorBanner_GetSlot final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDecorBanner_GetSlot) == 0x000004, "Wrong alignment on OrionDecorBanner_GetSlot");
static_assert(sizeof(OrionDecorBanner_GetSlot) == 0x000004, "Wrong size on OrionDecorBanner_GetSlot");
static_assert(offsetof(OrionDecorBanner_GetSlot, ReturnValue) == 0x000000, "Member 'OrionDecorBanner_GetSlot::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionDecorBanner.GetTeamNum
// 0x0001 (0x0001 - 0x0000)
struct OrionDecorBanner_GetTeamNum final
{
public:
	EOrionTeam                                    ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDecorBanner_GetTeamNum) == 0x000001, "Wrong alignment on OrionDecorBanner_GetTeamNum");
static_assert(sizeof(OrionDecorBanner_GetTeamNum) == 0x000001, "Wrong size on OrionDecorBanner_GetTeamNum");
static_assert(offsetof(OrionDecorBanner_GetTeamNum, ReturnValue) == 0x000000, "Member 'OrionDecorBanner_GetTeamNum::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionDecorBanner.IsEnabled
// 0x0001 (0x0001 - 0x0000)
struct OrionDecorBanner_IsEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDecorBanner_IsEnabled) == 0x000001, "Wrong alignment on OrionDecorBanner_IsEnabled");
static_assert(sizeof(OrionDecorBanner_IsEnabled) == 0x000001, "Wrong size on OrionDecorBanner_IsEnabled");
static_assert(offsetof(OrionDecorBanner_IsEnabled, ReturnValue) == 0x000000, "Member 'OrionDecorBanner_IsEnabled::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionDialogWidget.ProcessResult
// 0x0001 (0x0001 - 0x0000)
struct OrionDialogWidget_ProcessResult final
{
public:
	EOrionDialogResult                            DialogResult;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDialogWidget_ProcessResult) == 0x000001, "Wrong alignment on OrionDialogWidget_ProcessResult");
static_assert(sizeof(OrionDialogWidget_ProcessResult) == 0x000001, "Wrong size on OrionDialogWidget_ProcessResult");
static_assert(offsetof(OrionDialogWidget_ProcessResult, DialogResult) == 0x000000, "Member 'OrionDialogWidget_ProcessResult::DialogResult' has a wrong offset!");

// Function OrionGame.OrionDialogWidget.ShowDialog
// 0x00B0 (0x00B0 - 0x0000)
struct OrionDialogWidget_ShowDialog final
{
public:
	struct FOrionDialogDescription                Description;                                       // 0x0000(0x00B0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDialogWidget_ShowDialog) == 0x000010, "Wrong alignment on OrionDialogWidget_ShowDialog");
static_assert(sizeof(OrionDialogWidget_ShowDialog) == 0x0000B0, "Wrong size on OrionDialogWidget_ShowDialog");
static_assert(offsetof(OrionDialogWidget_ShowDialog, Description) == 0x000000, "Member 'OrionDialogWidget_ShowDialog::Description' has a wrong offset!");

// Function OrionGame.OrionDynamicWall_Segment.EndOverlapCallback
// 0x0020 (0x0020 - 0x0000)
struct OrionDynamicWall_Segment_EndOverlapCallback final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionDynamicWall_Segment_EndOverlapCallback) == 0x000008, "Wrong alignment on OrionDynamicWall_Segment_EndOverlapCallback");
static_assert(sizeof(OrionDynamicWall_Segment_EndOverlapCallback) == 0x000020, "Wrong size on OrionDynamicWall_Segment_EndOverlapCallback");
static_assert(offsetof(OrionDynamicWall_Segment_EndOverlapCallback, OverlappedComp) == 0x000000, "Member 'OrionDynamicWall_Segment_EndOverlapCallback::OverlappedComp' has a wrong offset!");
static_assert(offsetof(OrionDynamicWall_Segment_EndOverlapCallback, OtherActor) == 0x000008, "Member 'OrionDynamicWall_Segment_EndOverlapCallback::OtherActor' has a wrong offset!");
static_assert(offsetof(OrionDynamicWall_Segment_EndOverlapCallback, OtherComp) == 0x000010, "Member 'OrionDynamicWall_Segment_EndOverlapCallback::OtherComp' has a wrong offset!");
static_assert(offsetof(OrionDynamicWall_Segment_EndOverlapCallback, OtherBodyIndex) == 0x000018, "Member 'OrionDynamicWall_Segment_EndOverlapCallback::OtherBodyIndex' has a wrong offset!");

// Function OrionGame.OrionDynamicWall_Segment.OnSegmentConstruction
// 0x000C (0x000C - 0x0000)
struct OrionDynamicWall_Segment_OnSegmentConstruction final
{
public:
	float                                         ConstructionTime;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseMinHeight;                                     // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseMaxHeight;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDynamicWall_Segment_OnSegmentConstruction) == 0x000004, "Wrong alignment on OrionDynamicWall_Segment_OnSegmentConstruction");
static_assert(sizeof(OrionDynamicWall_Segment_OnSegmentConstruction) == 0x00000C, "Wrong size on OrionDynamicWall_Segment_OnSegmentConstruction");
static_assert(offsetof(OrionDynamicWall_Segment_OnSegmentConstruction, ConstructionTime) == 0x000000, "Member 'OrionDynamicWall_Segment_OnSegmentConstruction::ConstructionTime' has a wrong offset!");
static_assert(offsetof(OrionDynamicWall_Segment_OnSegmentConstruction, BaseMinHeight) == 0x000004, "Member 'OrionDynamicWall_Segment_OnSegmentConstruction::BaseMinHeight' has a wrong offset!");
static_assert(offsetof(OrionDynamicWall_Segment_OnSegmentConstruction, BaseMaxHeight) == 0x000008, "Member 'OrionDynamicWall_Segment_OnSegmentConstruction::BaseMaxHeight' has a wrong offset!");

// Function OrionGame.OrionDynamicWall_Segment.OnSegmentDeconstruction
// 0x0004 (0x0004 - 0x0000)
struct OrionDynamicWall_Segment_OnSegmentDeconstruction final
{
public:
	float                                         DeconstructionTime;                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDynamicWall_Segment_OnSegmentDeconstruction) == 0x000004, "Wrong alignment on OrionDynamicWall_Segment_OnSegmentDeconstruction");
static_assert(sizeof(OrionDynamicWall_Segment_OnSegmentDeconstruction) == 0x000004, "Wrong size on OrionDynamicWall_Segment_OnSegmentDeconstruction");
static_assert(offsetof(OrionDynamicWall_Segment_OnSegmentDeconstruction, DeconstructionTime) == 0x000000, "Member 'OrionDynamicWall_Segment_OnSegmentDeconstruction::DeconstructionTime' has a wrong offset!");

// Function OrionGame.OrionDynamicWall_Segment.OnSegmentOverlapCharacter
// 0x0018 (0x0018 - 0x0000)
struct OrionDynamicWall_Segment_OnSegmentOverlapCharacter final
{
public:
	const class AOrionChar*                       Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PushDirection;                                     // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PushDistance;                                      // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionDynamicWall_Segment_OnSegmentOverlapCharacter) == 0x000008, "Wrong alignment on OrionDynamicWall_Segment_OnSegmentOverlapCharacter");
static_assert(sizeof(OrionDynamicWall_Segment_OnSegmentOverlapCharacter) == 0x000018, "Wrong size on OrionDynamicWall_Segment_OnSegmentOverlapCharacter");
static_assert(offsetof(OrionDynamicWall_Segment_OnSegmentOverlapCharacter, Character) == 0x000000, "Member 'OrionDynamicWall_Segment_OnSegmentOverlapCharacter::Character' has a wrong offset!");
static_assert(offsetof(OrionDynamicWall_Segment_OnSegmentOverlapCharacter, PushDirection) == 0x000008, "Member 'OrionDynamicWall_Segment_OnSegmentOverlapCharacter::PushDirection' has a wrong offset!");
static_assert(offsetof(OrionDynamicWall_Segment_OnSegmentOverlapCharacter, PushDistance) == 0x000014, "Member 'OrionDynamicWall_Segment_OnSegmentOverlapCharacter::PushDistance' has a wrong offset!");

// Function OrionGame.OrionGlobals.ReclaimWorldNiagaraSystem
// 0x0008 (0x0008 - 0x0000)
struct OrionGlobals_ReclaimWorldNiagaraSystem final
{
public:
	class UNiagaraComponent*                      PSC;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGlobals_ReclaimWorldNiagaraSystem) == 0x000008, "Wrong alignment on OrionGlobals_ReclaimWorldNiagaraSystem");
static_assert(sizeof(OrionGlobals_ReclaimWorldNiagaraSystem) == 0x000008, "Wrong size on OrionGlobals_ReclaimWorldNiagaraSystem");
static_assert(offsetof(OrionGlobals_ReclaimWorldNiagaraSystem, PSC) == 0x000000, "Member 'OrionGlobals_ReclaimWorldNiagaraSystem::PSC' has a wrong offset!");

// Function OrionGame.OrionGlobals.ReclaimWorldParticleSystem
// 0x0008 (0x0008 - 0x0000)
struct OrionGlobals_ReclaimWorldParticleSystem final
{
public:
	class UParticleSystemComponent*               PSC;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGlobals_ReclaimWorldParticleSystem) == 0x000008, "Wrong alignment on OrionGlobals_ReclaimWorldParticleSystem");
static_assert(sizeof(OrionGlobals_ReclaimWorldParticleSystem) == 0x000008, "Wrong size on OrionGlobals_ReclaimWorldParticleSystem");
static_assert(offsetof(OrionGlobals_ReclaimWorldParticleSystem, PSC) == 0x000000, "Member 'OrionGlobals_ReclaimWorldParticleSystem::PSC' has a wrong offset!");

// Function OrionGame.OrionMcpGlyphItemDefinition.GetMaterial
// 0x0008 (0x0008 - 0x0000)
struct OrionMcpGlyphItemDefinition_GetMaterial final
{
public:
	class UMaterialInterface*                     ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpGlyphItemDefinition_GetMaterial) == 0x000008, "Wrong alignment on OrionMcpGlyphItemDefinition_GetMaterial");
static_assert(sizeof(OrionMcpGlyphItemDefinition_GetMaterial) == 0x000008, "Wrong size on OrionMcpGlyphItemDefinition_GetMaterial");
static_assert(offsetof(OrionMcpGlyphItemDefinition_GetMaterial, ReturnValue) == 0x000000, "Member 'OrionMcpGlyphItemDefinition_GetMaterial::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionMcpGlyphItemDefinition.GetMesh
// 0x0008 (0x0008 - 0x0000)
struct OrionMcpGlyphItemDefinition_GetMesh final
{
public:
	class UStaticMesh*                            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpGlyphItemDefinition_GetMesh) == 0x000008, "Wrong alignment on OrionMcpGlyphItemDefinition_GetMesh");
static_assert(sizeof(OrionMcpGlyphItemDefinition_GetMesh) == 0x000008, "Wrong size on OrionMcpGlyphItemDefinition_GetMesh");
static_assert(offsetof(OrionMcpGlyphItemDefinition_GetMesh, ReturnValue) == 0x000000, "Member 'OrionMcpGlyphItemDefinition_GetMesh::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionFriendItem.GetDisplayName
// 0x0018 (0x0018 - 0x0000)
struct OrionFriendItem_GetDisplayName final
{
public:
	class FText                                   FriendName;                                        // 0x0000(0x0018)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionFriendItem_GetDisplayName) == 0x000008, "Wrong alignment on OrionFriendItem_GetDisplayName");
static_assert(sizeof(OrionFriendItem_GetDisplayName) == 0x000018, "Wrong size on OrionFriendItem_GetDisplayName");
static_assert(offsetof(OrionFriendItem_GetDisplayName, FriendName) == 0x000000, "Member 'OrionFriendItem_GetDisplayName::FriendName' has a wrong offset!");

// Function OrionGame.OrionFriendItem.GetUniqueNetID
// 0x0018 (0x0018 - 0x0000)
struct OrionFriendItem_GetUniqueNetID final
{
public:
	struct FUniqueNetIdRepl                       FriendNetID;                                       // 0x0000(0x0018)(Parm, OutParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionFriendItem_GetUniqueNetID) == 0x000008, "Wrong alignment on OrionFriendItem_GetUniqueNetID");
static_assert(sizeof(OrionFriendItem_GetUniqueNetID) == 0x000018, "Wrong size on OrionFriendItem_GetUniqueNetID");
static_assert(offsetof(OrionFriendItem_GetUniqueNetID, FriendNetID) == 0x000000, "Member 'OrionFriendItem_GetUniqueNetID::FriendNetID' has a wrong offset!");

// Function OrionGame.OrionLightBox.EstablishActivatableContent
// 0x0008 (0x0008 - 0x0000)
struct OrionLightBox_EstablishActivatableContent final
{
public:
	class UOrionActivatableWidget*                NewContent;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionLightBox_EstablishActivatableContent) == 0x000008, "Wrong alignment on OrionLightBox_EstablishActivatableContent");
static_assert(sizeof(OrionLightBox_EstablishActivatableContent) == 0x000008, "Wrong size on OrionLightBox_EstablishActivatableContent");
static_assert(offsetof(OrionLightBox_EstablishActivatableContent, NewContent) == 0x000000, "Member 'OrionLightBox_EstablishActivatableContent::NewContent' has a wrong offset!");

// Function OrionGame.OrionLightBox.OnContentActivationChanged
// 0x0001 (0x0001 - 0x0000)
struct OrionLightBox_OnContentActivationChanged final
{
public:
	bool                                          bActivated;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionLightBox_OnContentActivationChanged) == 0x000001, "Wrong alignment on OrionLightBox_OnContentActivationChanged");
static_assert(sizeof(OrionLightBox_OnContentActivationChanged) == 0x000001, "Wrong size on OrionLightBox_OnContentActivationChanged");
static_assert(offsetof(OrionLightBox_OnContentActivationChanged, bActivated) == 0x000000, "Member 'OrionLightBox_OnContentActivationChanged::bActivated' has a wrong offset!");

// Function OrionGame.OrionLightBox.OverrideContentActivation
// 0x0001 (0x0001 - 0x0000)
struct OrionLightBox_OverrideContentActivation final
{
public:
	bool                                          bActivate;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionLightBox_OverrideContentActivation) == 0x000001, "Wrong alignment on OrionLightBox_OverrideContentActivation");
static_assert(sizeof(OrionLightBox_OverrideContentActivation) == 0x000001, "Wrong size on OrionLightBox_OverrideContentActivation");
static_assert(offsetof(OrionLightBox_OverrideContentActivation, bActivate) == 0x000000, "Member 'OrionLightBox_OverrideContentActivation::bActivate' has a wrong offset!");

// Function OrionGame.OrionLightBox.IsContentActive
// 0x0001 (0x0001 - 0x0000)
struct OrionLightBox_IsContentActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionLightBox_IsContentActive) == 0x000001, "Wrong alignment on OrionLightBox_IsContentActive");
static_assert(sizeof(OrionLightBox_IsContentActive) == 0x000001, "Wrong size on OrionLightBox_IsContentActive");
static_assert(offsetof(OrionLightBox_IsContentActive, ReturnValue) == 0x000000, "Member 'OrionLightBox_IsContentActive::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameMode_Arcade_Base.BP_InitArcadePlayerState
// 0x0010 (0x0010 - 0x0000)
struct OrionGameMode_Arcade_Base_BP_InitArcadePlayerState final
{
public:
	class AOrionPlayerState_Arcade*               PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBot;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFriendly;                                       // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionGameMode_Arcade_Base_BP_InitArcadePlayerState) == 0x000008, "Wrong alignment on OrionGameMode_Arcade_Base_BP_InitArcadePlayerState");
static_assert(sizeof(OrionGameMode_Arcade_Base_BP_InitArcadePlayerState) == 0x000010, "Wrong size on OrionGameMode_Arcade_Base_BP_InitArcadePlayerState");
static_assert(offsetof(OrionGameMode_Arcade_Base_BP_InitArcadePlayerState, PlayerState) == 0x000000, "Member 'OrionGameMode_Arcade_Base_BP_InitArcadePlayerState::PlayerState' has a wrong offset!");
static_assert(offsetof(OrionGameMode_Arcade_Base_BP_InitArcadePlayerState, bIsBot) == 0x000008, "Member 'OrionGameMode_Arcade_Base_BP_InitArcadePlayerState::bIsBot' has a wrong offset!");
static_assert(offsetof(OrionGameMode_Arcade_Base_BP_InitArcadePlayerState, bIsFriendly) == 0x000009, "Member 'OrionGameMode_Arcade_Base_BP_InitArcadePlayerState::bIsFriendly' has a wrong offset!");

// Function OrionGame.OrionGameMode_Arcade_Base.OnRoundStateChange
// 0x0001 (0x0001 - 0x0000)
struct OrionGameMode_Arcade_Base_OnRoundStateChange final
{
public:
	EArcadeRoundPhase                             NewRoundState;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameMode_Arcade_Base_OnRoundStateChange) == 0x000001, "Wrong alignment on OrionGameMode_Arcade_Base_OnRoundStateChange");
static_assert(sizeof(OrionGameMode_Arcade_Base_OnRoundStateChange) == 0x000001, "Wrong size on OrionGameMode_Arcade_Base_OnRoundStateChange");
static_assert(offsetof(OrionGameMode_Arcade_Base_OnRoundStateChange, NewRoundState) == 0x000000, "Member 'OrionGameMode_Arcade_Base_OnRoundStateChange::NewRoundState' has a wrong offset!");

// Function OrionGame.OrionGameMode_Arcade_Base.PausePlayer
// 0x0010 (0x0010 - 0x0000)
struct OrionGameMode_Arcade_Base_PausePlayer final
{
public:
	class AOrionPlayerState_Arcade*               PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldPause;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionGameMode_Arcade_Base_PausePlayer) == 0x000008, "Wrong alignment on OrionGameMode_Arcade_Base_PausePlayer");
static_assert(sizeof(OrionGameMode_Arcade_Base_PausePlayer) == 0x000010, "Wrong size on OrionGameMode_Arcade_Base_PausePlayer");
static_assert(offsetof(OrionGameMode_Arcade_Base_PausePlayer, PlayerState) == 0x000000, "Member 'OrionGameMode_Arcade_Base_PausePlayer::PlayerState' has a wrong offset!");
static_assert(offsetof(OrionGameMode_Arcade_Base_PausePlayer, bShouldPause) == 0x000008, "Member 'OrionGameMode_Arcade_Base_PausePlayer::bShouldPause' has a wrong offset!");

// Function OrionGame.OrionGameMode_Arcade_Base.GetGameStateArcade
// 0x0008 (0x0008 - 0x0000)
struct OrionGameMode_Arcade_Base_GetGameStateArcade final
{
public:
	class AOrionGameState_Arcade*                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameMode_Arcade_Base_GetGameStateArcade) == 0x000008, "Wrong alignment on OrionGameMode_Arcade_Base_GetGameStateArcade");
static_assert(sizeof(OrionGameMode_Arcade_Base_GetGameStateArcade) == 0x000008, "Wrong size on OrionGameMode_Arcade_Base_GetGameStateArcade");
static_assert(offsetof(OrionGameMode_Arcade_Base_GetGameStateArcade, ReturnValue) == 0x000000, "Member 'OrionGameMode_Arcade_Base_GetGameStateArcade::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameplayCue_ItemizationOverHead.GetSequencerForCardInteraction
// 0x0010 (0x0010 - 0x0000)
struct OrionGameplayCue_ItemizationOverHead_GetSequencerForCardInteraction final
{
public:
	EOrionItemState                               SequencerType;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UActorSequencePlayer*                   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameplayCue_ItemizationOverHead_GetSequencerForCardInteraction) == 0x000008, "Wrong alignment on OrionGameplayCue_ItemizationOverHead_GetSequencerForCardInteraction");
static_assert(sizeof(OrionGameplayCue_ItemizationOverHead_GetSequencerForCardInteraction) == 0x000010, "Wrong size on OrionGameplayCue_ItemizationOverHead_GetSequencerForCardInteraction");
static_assert(offsetof(OrionGameplayCue_ItemizationOverHead_GetSequencerForCardInteraction, SequencerType) == 0x000000, "Member 'OrionGameplayCue_ItemizationOverHead_GetSequencerForCardInteraction::SequencerType' has a wrong offset!");
static_assert(offsetof(OrionGameplayCue_ItemizationOverHead_GetSequencerForCardInteraction, ReturnValue) == 0x000008, "Member 'OrionGameplayCue_ItemizationOverHead_GetSequencerForCardInteraction::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameplayCueNotify_Burst.OnBurst
// 0x0100 (0x0100 - 0x0000)
struct OrionGameplayCueNotify_Burst_OnBurst final
{
public:
	class AActor*                                 MyTarget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 Parameters;                                        // 0x0008(0x00B8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               BurstParticleSystem;                               // 0x00C0(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UParticleSystemComponent*>       AdditionalParticleSystems;                         // 0x00C8(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UCameraShake*                           BurstCameraShakeInstance;                          // 0x00D8(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADecalActor*                            BurstDecalInstance;                                // 0x00E0(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      BurstNiagaraParticleSystem;                        // 0x00E8(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UNiagaraComponent*>              AdditionalNiagaraParticleSystems;                  // 0x00F0(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameplayCueNotify_Burst_OnBurst) == 0x000008, "Wrong alignment on OrionGameplayCueNotify_Burst_OnBurst");
static_assert(sizeof(OrionGameplayCueNotify_Burst_OnBurst) == 0x000100, "Wrong size on OrionGameplayCueNotify_Burst_OnBurst");
static_assert(offsetof(OrionGameplayCueNotify_Burst_OnBurst, MyTarget) == 0x000000, "Member 'OrionGameplayCueNotify_Burst_OnBurst::MyTarget' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Burst_OnBurst, Parameters) == 0x000008, "Member 'OrionGameplayCueNotify_Burst_OnBurst::Parameters' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Burst_OnBurst, BurstParticleSystem) == 0x0000C0, "Member 'OrionGameplayCueNotify_Burst_OnBurst::BurstParticleSystem' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Burst_OnBurst, AdditionalParticleSystems) == 0x0000C8, "Member 'OrionGameplayCueNotify_Burst_OnBurst::AdditionalParticleSystems' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Burst_OnBurst, BurstCameraShakeInstance) == 0x0000D8, "Member 'OrionGameplayCueNotify_Burst_OnBurst::BurstCameraShakeInstance' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Burst_OnBurst, BurstDecalInstance) == 0x0000E0, "Member 'OrionGameplayCueNotify_Burst_OnBurst::BurstDecalInstance' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Burst_OnBurst, BurstNiagaraParticleSystem) == 0x0000E8, "Member 'OrionGameplayCueNotify_Burst_OnBurst::BurstNiagaraParticleSystem' has a wrong offset!");
static_assert(offsetof(OrionGameplayCueNotify_Burst_OnBurst, AdditionalNiagaraParticleSystems) == 0x0000F0, "Member 'OrionGameplayCueNotify_Burst_OnBurst::AdditionalNiagaraParticleSystems' has a wrong offset!");

// Function OrionGame.OrionMcpBannerItemDefinition.GetAttachToParent
// 0x0001 (0x0001 - 0x0000)
struct OrionMcpBannerItemDefinition_GetAttachToParent final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpBannerItemDefinition_GetAttachToParent) == 0x000001, "Wrong alignment on OrionMcpBannerItemDefinition_GetAttachToParent");
static_assert(sizeof(OrionMcpBannerItemDefinition_GetAttachToParent) == 0x000001, "Wrong size on OrionMcpBannerItemDefinition_GetAttachToParent");
static_assert(offsetof(OrionMcpBannerItemDefinition_GetAttachToParent, ReturnValue) == 0x000000, "Member 'OrionMcpBannerItemDefinition_GetAttachToParent::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionMcpBannerItemDefinition.GetBannerType
// 0x0001 (0x0001 - 0x0000)
struct OrionMcpBannerItemDefinition_GetBannerType final
{
public:
	EOrionBannerType                              ReturnValue;                                       // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpBannerItemDefinition_GetBannerType) == 0x000001, "Wrong alignment on OrionMcpBannerItemDefinition_GetBannerType");
static_assert(sizeof(OrionMcpBannerItemDefinition_GetBannerType) == 0x000001, "Wrong size on OrionMcpBannerItemDefinition_GetBannerType");
static_assert(offsetof(OrionMcpBannerItemDefinition_GetBannerType, ReturnValue) == 0x000000, "Member 'OrionMcpBannerItemDefinition_GetBannerType::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionMcpBannerItemDefinition.GetDecalSize
// 0x000C (0x000C - 0x0000)
struct OrionMcpBannerItemDefinition_GetDecalSize final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpBannerItemDefinition_GetDecalSize) == 0x000004, "Wrong alignment on OrionMcpBannerItemDefinition_GetDecalSize");
static_assert(sizeof(OrionMcpBannerItemDefinition_GetDecalSize) == 0x00000C, "Wrong size on OrionMcpBannerItemDefinition_GetDecalSize");
static_assert(offsetof(OrionMcpBannerItemDefinition_GetDecalSize, ReturnValue) == 0x000000, "Member 'OrionMcpBannerItemDefinition_GetDecalSize::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionMcpBannerItemDefinition.GetFXMaterial
// 0x0008 (0x0008 - 0x0000)
struct OrionMcpBannerItemDefinition_GetFXMaterial final
{
public:
	class UMaterialInterface*                     ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpBannerItemDefinition_GetFXMaterial) == 0x000008, "Wrong alignment on OrionMcpBannerItemDefinition_GetFXMaterial");
static_assert(sizeof(OrionMcpBannerItemDefinition_GetFXMaterial) == 0x000008, "Wrong size on OrionMcpBannerItemDefinition_GetFXMaterial");
static_assert(offsetof(OrionMcpBannerItemDefinition_GetFXMaterial, ReturnValue) == 0x000000, "Member 'OrionMcpBannerItemDefinition_GetFXMaterial::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionMcpBannerItemDefinition.GetFXParticle
// 0x0008 (0x0008 - 0x0000)
struct OrionMcpBannerItemDefinition_GetFXParticle final
{
public:
	class UParticleSystem*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpBannerItemDefinition_GetFXParticle) == 0x000008, "Wrong alignment on OrionMcpBannerItemDefinition_GetFXParticle");
static_assert(sizeof(OrionMcpBannerItemDefinition_GetFXParticle) == 0x000008, "Wrong size on OrionMcpBannerItemDefinition_GetFXParticle");
static_assert(offsetof(OrionMcpBannerItemDefinition_GetFXParticle, ReturnValue) == 0x000000, "Member 'OrionMcpBannerItemDefinition_GetFXParticle::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionMcpBannerItemDefinition.GetFXSound
// 0x0008 (0x0008 - 0x0000)
struct OrionMcpBannerItemDefinition_GetFXSound final
{
public:
	class USoundBase*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpBannerItemDefinition_GetFXSound) == 0x000008, "Wrong alignment on OrionMcpBannerItemDefinition_GetFXSound");
static_assert(sizeof(OrionMcpBannerItemDefinition_GetFXSound) == 0x000008, "Wrong size on OrionMcpBannerItemDefinition_GetFXSound");
static_assert(offsetof(OrionMcpBannerItemDefinition_GetFXSound, ReturnValue) == 0x000000, "Member 'OrionMcpBannerItemDefinition_GetFXSound::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionMcpBannerItemDefinition.GetSockets
// 0x0010 (0x0010 - 0x0000)
struct OrionMcpBannerItemDefinition_GetSockets final
{
public:
	TArray<struct FBannerSocketEntry>             ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpBannerItemDefinition_GetSockets) == 0x000008, "Wrong alignment on OrionMcpBannerItemDefinition_GetSockets");
static_assert(sizeof(OrionMcpBannerItemDefinition_GetSockets) == 0x000010, "Wrong size on OrionMcpBannerItemDefinition_GetSockets");
static_assert(offsetof(OrionMcpBannerItemDefinition_GetSockets, ReturnValue) == 0x000000, "Member 'OrionMcpBannerItemDefinition_GetSockets::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionMcpBannerItemDefinition.GetStaticMesh
// 0x0008 (0x0008 - 0x0000)
struct OrionMcpBannerItemDefinition_GetStaticMesh final
{
public:
	class UStaticMesh*                            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpBannerItemDefinition_GetStaticMesh) == 0x000008, "Wrong alignment on OrionMcpBannerItemDefinition_GetStaticMesh");
static_assert(sizeof(OrionMcpBannerItemDefinition_GetStaticMesh) == 0x000008, "Wrong size on OrionMcpBannerItemDefinition_GetStaticMesh");
static_assert(offsetof(OrionMcpBannerItemDefinition_GetStaticMesh, ReturnValue) == 0x000000, "Member 'OrionMcpBannerItemDefinition_GetStaticMesh::ReturnValue' has a wrong offset!");

// Function OrionGame.BlueprintGameplayStatsLibrary.EqualEqual_GameplayStatTagGameplayStatTag
// 0x0028 (0x0028 - 0x0000)
struct BlueprintGameplayStatsLibrary_EqualEqual_GameplayStatTagGameplayStatTag final
{
public:
	struct FGameplayStatTag                       A;                                                 // 0x0000(0x0010)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayStatTag                       B;                                                 // 0x0010(0x0010)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BlueprintGameplayStatsLibrary_EqualEqual_GameplayStatTagGameplayStatTag) == 0x000008, "Wrong alignment on BlueprintGameplayStatsLibrary_EqualEqual_GameplayStatTagGameplayStatTag");
static_assert(sizeof(BlueprintGameplayStatsLibrary_EqualEqual_GameplayStatTagGameplayStatTag) == 0x000028, "Wrong size on BlueprintGameplayStatsLibrary_EqualEqual_GameplayStatTagGameplayStatTag");
static_assert(offsetof(BlueprintGameplayStatsLibrary_EqualEqual_GameplayStatTagGameplayStatTag, A) == 0x000000, "Member 'BlueprintGameplayStatsLibrary_EqualEqual_GameplayStatTagGameplayStatTag::A' has a wrong offset!");
static_assert(offsetof(BlueprintGameplayStatsLibrary_EqualEqual_GameplayStatTagGameplayStatTag, B) == 0x000010, "Member 'BlueprintGameplayStatsLibrary_EqualEqual_GameplayStatTagGameplayStatTag::B' has a wrong offset!");
static_assert(offsetof(BlueprintGameplayStatsLibrary_EqualEqual_GameplayStatTagGameplayStatTag, ReturnValue) == 0x000020, "Member 'BlueprintGameplayStatsLibrary_EqualEqual_GameplayStatTagGameplayStatTag::ReturnValue' has a wrong offset!");

// Function OrionGame.BlueprintGameplayStatsLibrary.NotEqual_GameplayStatTagGameplayStatTag
// 0x0028 (0x0028 - 0x0000)
struct BlueprintGameplayStatsLibrary_NotEqual_GameplayStatTagGameplayStatTag final
{
public:
	struct FGameplayStatTag                       A;                                                 // 0x0000(0x0010)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayStatTag                       B;                                                 // 0x0010(0x0010)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BlueprintGameplayStatsLibrary_NotEqual_GameplayStatTagGameplayStatTag) == 0x000008, "Wrong alignment on BlueprintGameplayStatsLibrary_NotEqual_GameplayStatTagGameplayStatTag");
static_assert(sizeof(BlueprintGameplayStatsLibrary_NotEqual_GameplayStatTagGameplayStatTag) == 0x000028, "Wrong size on BlueprintGameplayStatsLibrary_NotEqual_GameplayStatTagGameplayStatTag");
static_assert(offsetof(BlueprintGameplayStatsLibrary_NotEqual_GameplayStatTagGameplayStatTag, A) == 0x000000, "Member 'BlueprintGameplayStatsLibrary_NotEqual_GameplayStatTagGameplayStatTag::A' has a wrong offset!");
static_assert(offsetof(BlueprintGameplayStatsLibrary_NotEqual_GameplayStatTagGameplayStatTag, B) == 0x000010, "Member 'BlueprintGameplayStatsLibrary_NotEqual_GameplayStatTagGameplayStatTag::B' has a wrong offset!");
static_assert(offsetof(BlueprintGameplayStatsLibrary_NotEqual_GameplayStatTagGameplayStatTag, ReturnValue) == 0x000020, "Member 'BlueprintGameplayStatsLibrary_NotEqual_GameplayStatTagGameplayStatTag::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameplayVolume.CanStillApplyEffectsToTargets
// 0x0001 (0x0001 - 0x0000)
struct OrionGameplayVolume_CanStillApplyEffectsToTargets final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameplayVolume_CanStillApplyEffectsToTargets) == 0x000001, "Wrong alignment on OrionGameplayVolume_CanStillApplyEffectsToTargets");
static_assert(sizeof(OrionGameplayVolume_CanStillApplyEffectsToTargets) == 0x000001, "Wrong size on OrionGameplayVolume_CanStillApplyEffectsToTargets");
static_assert(offsetof(OrionGameplayVolume_CanStillApplyEffectsToTargets, ReturnValue) == 0x000000, "Member 'OrionGameplayVolume_CanStillApplyEffectsToTargets::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameplayVolume.GetNumAppliedEffectsLeftToApply
// 0x0004 (0x0004 - 0x0000)
struct OrionGameplayVolume_GetNumAppliedEffectsLeftToApply final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameplayVolume_GetNumAppliedEffectsLeftToApply) == 0x000004, "Wrong alignment on OrionGameplayVolume_GetNumAppliedEffectsLeftToApply");
static_assert(sizeof(OrionGameplayVolume_GetNumAppliedEffectsLeftToApply) == 0x000004, "Wrong size on OrionGameplayVolume_GetNumAppliedEffectsLeftToApply");
static_assert(offsetof(OrionGameplayVolume_GetNumAppliedEffectsLeftToApply, ReturnValue) == 0x000000, "Member 'OrionGameplayVolume_GetNumAppliedEffectsLeftToApply::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameplayVolume.K2_OnBeginOverlapCallback
// 0x00A0 (0x00A0 - 0x0000)
struct OrionGameplayVolume_K2_OnBeginOverlapCallback final
{
public:
	class AActor*                                 OtherActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0018(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameplayVolume_K2_OnBeginOverlapCallback) == 0x000008, "Wrong alignment on OrionGameplayVolume_K2_OnBeginOverlapCallback");
static_assert(sizeof(OrionGameplayVolume_K2_OnBeginOverlapCallback) == 0x0000A0, "Wrong size on OrionGameplayVolume_K2_OnBeginOverlapCallback");
static_assert(offsetof(OrionGameplayVolume_K2_OnBeginOverlapCallback, OtherActor) == 0x000000, "Member 'OrionGameplayVolume_K2_OnBeginOverlapCallback::OtherActor' has a wrong offset!");
static_assert(offsetof(OrionGameplayVolume_K2_OnBeginOverlapCallback, OtherComp) == 0x000008, "Member 'OrionGameplayVolume_K2_OnBeginOverlapCallback::OtherComp' has a wrong offset!");
static_assert(offsetof(OrionGameplayVolume_K2_OnBeginOverlapCallback, OtherBodyIndex) == 0x000010, "Member 'OrionGameplayVolume_K2_OnBeginOverlapCallback::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(OrionGameplayVolume_K2_OnBeginOverlapCallback, bFromSweep) == 0x000014, "Member 'OrionGameplayVolume_K2_OnBeginOverlapCallback::bFromSweep' has a wrong offset!");
static_assert(offsetof(OrionGameplayVolume_K2_OnBeginOverlapCallback, SweepResult) == 0x000018, "Member 'OrionGameplayVolume_K2_OnBeginOverlapCallback::SweepResult' has a wrong offset!");

// Function OrionGame.OrionGameplayVolume.K2_OnEndOverlapCallback
// 0x0018 (0x0018 - 0x0000)
struct OrionGameplayVolume_K2_OnEndOverlapCallback final
{
public:
	class AActor*                                 OtherActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionGameplayVolume_K2_OnEndOverlapCallback) == 0x000008, "Wrong alignment on OrionGameplayVolume_K2_OnEndOverlapCallback");
static_assert(sizeof(OrionGameplayVolume_K2_OnEndOverlapCallback) == 0x000018, "Wrong size on OrionGameplayVolume_K2_OnEndOverlapCallback");
static_assert(offsetof(OrionGameplayVolume_K2_OnEndOverlapCallback, OtherActor) == 0x000000, "Member 'OrionGameplayVolume_K2_OnEndOverlapCallback::OtherActor' has a wrong offset!");
static_assert(offsetof(OrionGameplayVolume_K2_OnEndOverlapCallback, OtherComp) == 0x000008, "Member 'OrionGameplayVolume_K2_OnEndOverlapCallback::OtherComp' has a wrong offset!");
static_assert(offsetof(OrionGameplayVolume_K2_OnEndOverlapCallback, OtherBodyIndex) == 0x000010, "Member 'OrionGameplayVolume_K2_OnEndOverlapCallback::OtherBodyIndex' has a wrong offset!");

// Function OrionGame.OrionGameplayVolume.OnBeginOverlapCallback
// 0x00A8 (0x00A8 - 0x0000)
struct OrionGameplayVolume_OnBeginOverlapCallback final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameplayVolume_OnBeginOverlapCallback) == 0x000008, "Wrong alignment on OrionGameplayVolume_OnBeginOverlapCallback");
static_assert(sizeof(OrionGameplayVolume_OnBeginOverlapCallback) == 0x0000A8, "Wrong size on OrionGameplayVolume_OnBeginOverlapCallback");
static_assert(offsetof(OrionGameplayVolume_OnBeginOverlapCallback, OverlappedComp) == 0x000000, "Member 'OrionGameplayVolume_OnBeginOverlapCallback::OverlappedComp' has a wrong offset!");
static_assert(offsetof(OrionGameplayVolume_OnBeginOverlapCallback, OtherActor) == 0x000008, "Member 'OrionGameplayVolume_OnBeginOverlapCallback::OtherActor' has a wrong offset!");
static_assert(offsetof(OrionGameplayVolume_OnBeginOverlapCallback, OtherComp) == 0x000010, "Member 'OrionGameplayVolume_OnBeginOverlapCallback::OtherComp' has a wrong offset!");
static_assert(offsetof(OrionGameplayVolume_OnBeginOverlapCallback, OtherBodyIndex) == 0x000018, "Member 'OrionGameplayVolume_OnBeginOverlapCallback::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(OrionGameplayVolume_OnBeginOverlapCallback, bFromSweep) == 0x00001C, "Member 'OrionGameplayVolume_OnBeginOverlapCallback::bFromSweep' has a wrong offset!");
static_assert(offsetof(OrionGameplayVolume_OnBeginOverlapCallback, SweepResult) == 0x000020, "Member 'OrionGameplayVolume_OnBeginOverlapCallback::SweepResult' has a wrong offset!");

// Function OrionGame.OrionGameplayVolume.OnEndOverlapCallback
// 0x0020 (0x0020 - 0x0000)
struct OrionGameplayVolume_OnEndOverlapCallback final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionGameplayVolume_OnEndOverlapCallback) == 0x000008, "Wrong alignment on OrionGameplayVolume_OnEndOverlapCallback");
static_assert(sizeof(OrionGameplayVolume_OnEndOverlapCallback) == 0x000020, "Wrong size on OrionGameplayVolume_OnEndOverlapCallback");
static_assert(offsetof(OrionGameplayVolume_OnEndOverlapCallback, OverlappedComp) == 0x000000, "Member 'OrionGameplayVolume_OnEndOverlapCallback::OverlappedComp' has a wrong offset!");
static_assert(offsetof(OrionGameplayVolume_OnEndOverlapCallback, OtherActor) == 0x000008, "Member 'OrionGameplayVolume_OnEndOverlapCallback::OtherActor' has a wrong offset!");
static_assert(offsetof(OrionGameplayVolume_OnEndOverlapCallback, OtherComp) == 0x000010, "Member 'OrionGameplayVolume_OnEndOverlapCallback::OtherComp' has a wrong offset!");
static_assert(offsetof(OrionGameplayVolume_OnEndOverlapCallback, OtherBodyIndex) == 0x000018, "Member 'OrionGameplayVolume_OnEndOverlapCallback::OtherBodyIndex' has a wrong offset!");

// Function OrionGame.OrionInputVisualizer.SetSize
// 0x0001 (0x0001 - 0x0000)
struct OrionInputVisualizer_SetSize final
{
public:
	EOrionWidgetStyleSize                         InSize;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionInputVisualizer_SetSize) == 0x000001, "Wrong alignment on OrionInputVisualizer_SetSize");
static_assert(sizeof(OrionInputVisualizer_SetSize) == 0x000001, "Wrong size on OrionInputVisualizer_SetSize");
static_assert(offsetof(OrionInputVisualizer_SetSize, InSize) == 0x000000, "Member 'OrionInputVisualizer_SetSize::InSize' has a wrong offset!");

// Function OrionGame.OrionInputVisualizer.ShowAbilityBinding
// 0x0001 (0x0001 - 0x0000)
struct OrionInputVisualizer_ShowAbilityBinding final
{
public:
	EOrionAbilityBinding                          AbilityBinding;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionInputVisualizer_ShowAbilityBinding) == 0x000001, "Wrong alignment on OrionInputVisualizer_ShowAbilityBinding");
static_assert(sizeof(OrionInputVisualizer_ShowAbilityBinding) == 0x000001, "Wrong size on OrionInputVisualizer_ShowAbilityBinding");
static_assert(offsetof(OrionInputVisualizer_ShowAbilityBinding, AbilityBinding) == 0x000000, "Member 'OrionInputVisualizer_ShowAbilityBinding::AbilityBinding' has a wrong offset!");

// Function OrionGame.OrionInputVisualizer.ShowInputAction
// 0x0008 (0x0008 - 0x0000)
struct OrionInputVisualizer_ShowInputAction final
{
public:
	class FName                                   InActionName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionInputVisualizer_ShowInputAction) == 0x000004, "Wrong alignment on OrionInputVisualizer_ShowInputAction");
static_assert(sizeof(OrionInputVisualizer_ShowInputAction) == 0x000008, "Wrong size on OrionInputVisualizer_ShowInputAction");
static_assert(offsetof(OrionInputVisualizer_ShowInputAction, InActionName) == 0x000000, "Member 'OrionInputVisualizer_ShowInputAction::InActionName' has a wrong offset!");

// Function OrionGame.OrionInputVisualizer.ShowInputAxis
// 0x0008 (0x0008 - 0x0000)
struct OrionInputVisualizer_ShowInputAxis final
{
public:
	class FName                                   InAxisName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionInputVisualizer_ShowInputAxis) == 0x000004, "Wrong alignment on OrionInputVisualizer_ShowInputAxis");
static_assert(sizeof(OrionInputVisualizer_ShowInputAxis) == 0x000008, "Wrong size on OrionInputVisualizer_ShowInputAxis");
static_assert(offsetof(OrionInputVisualizer_ShowInputAxis, InAxisName) == 0x000000, "Member 'OrionInputVisualizer_ShowInputAxis::InAxisName' has a wrong offset!");

// Function OrionGame.OrionInputVisualizer.ShowSpecificKey
// 0x0018 (0x0018 - 0x0000)
struct OrionInputVisualizer_ShowSpecificKey final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionInputVisualizer_ShowSpecificKey) == 0x000008, "Wrong alignment on OrionInputVisualizer_ShowSpecificKey");
static_assert(sizeof(OrionInputVisualizer_ShowSpecificKey) == 0x000018, "Wrong size on OrionInputVisualizer_ShowSpecificKey");
static_assert(offsetof(OrionInputVisualizer_ShowSpecificKey, Key) == 0x000000, "Member 'OrionInputVisualizer_ShowSpecificKey::Key' has a wrong offset!");

// Function OrionGame.OrionJungleRefinery.GatherResources
// 0x0004 (0x0004 - 0x0000)
struct OrionJungleRefinery_GatherResources final
{
public:
	int32                                         Amount;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionJungleRefinery_GatherResources) == 0x000004, "Wrong alignment on OrionJungleRefinery_GatherResources");
static_assert(sizeof(OrionJungleRefinery_GatherResources) == 0x000004, "Wrong size on OrionJungleRefinery_GatherResources");
static_assert(offsetof(OrionJungleRefinery_GatherResources, Amount) == 0x000000, "Member 'OrionJungleRefinery_GatherResources::Amount' has a wrong offset!");

// Function OrionGame.OrionJungleRefinery.GetCurrentCachedResources
// 0x0004 (0x0004 - 0x0000)
struct OrionJungleRefinery_GetCurrentCachedResources final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionJungleRefinery_GetCurrentCachedResources) == 0x000004, "Wrong alignment on OrionJungleRefinery_GetCurrentCachedResources");
static_assert(sizeof(OrionJungleRefinery_GetCurrentCachedResources) == 0x000004, "Wrong size on OrionJungleRefinery_GetCurrentCachedResources");
static_assert(offsetof(OrionJungleRefinery_GetCurrentCachedResources, ReturnValue) == 0x000000, "Member 'OrionJungleRefinery_GetCurrentCachedResources::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionJungleRefinery.GetCurrentResources
// 0x0004 (0x0004 - 0x0000)
struct OrionJungleRefinery_GetCurrentResources final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionJungleRefinery_GetCurrentResources) == 0x000004, "Wrong alignment on OrionJungleRefinery_GetCurrentResources");
static_assert(sizeof(OrionJungleRefinery_GetCurrentResources) == 0x000004, "Wrong size on OrionJungleRefinery_GetCurrentResources");
static_assert(offsetof(OrionJungleRefinery_GetCurrentResources, ReturnValue) == 0x000000, "Member 'OrionJungleRefinery_GetCurrentResources::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionJungleRefinery.GetNextRefinmentTimeLeft
// 0x0004 (0x0004 - 0x0000)
struct OrionJungleRefinery_GetNextRefinmentTimeLeft final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionJungleRefinery_GetNextRefinmentTimeLeft) == 0x000004, "Wrong alignment on OrionJungleRefinery_GetNextRefinmentTimeLeft");
static_assert(sizeof(OrionJungleRefinery_GetNextRefinmentTimeLeft) == 0x000004, "Wrong size on OrionJungleRefinery_GetNextRefinmentTimeLeft");
static_assert(offsetof(OrionJungleRefinery_GetNextRefinmentTimeLeft, ReturnValue) == 0x000000, "Member 'OrionJungleRefinery_GetNextRefinmentTimeLeft::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionJungleRefinery.HandleJungleCampDeath
// 0x0018 (0x0018 - 0x0000)
struct OrionJungleRefinery_HandleJungleCampDeath final
{
public:
	class AOrionChar*                             DeadChar;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            Killer;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionJungleRefinery_HandleJungleCampDeath) == 0x000008, "Wrong alignment on OrionJungleRefinery_HandleJungleCampDeath");
static_assert(sizeof(OrionJungleRefinery_HandleJungleCampDeath) == 0x000018, "Wrong size on OrionJungleRefinery_HandleJungleCampDeath");
static_assert(offsetof(OrionJungleRefinery_HandleJungleCampDeath, DeadChar) == 0x000000, "Member 'OrionJungleRefinery_HandleJungleCampDeath::DeadChar' has a wrong offset!");
static_assert(offsetof(OrionJungleRefinery_HandleJungleCampDeath, Killer) == 0x000008, "Member 'OrionJungleRefinery_HandleJungleCampDeath::Killer' has a wrong offset!");
static_assert(offsetof(OrionJungleRefinery_HandleJungleCampDeath, DamageCauser) == 0x000010, "Member 'OrionJungleRefinery_HandleJungleCampDeath::DamageCauser' has a wrong offset!");

// Function OrionGame.OrionGameState_MOBA.DebugCapsuleSendToAll
// 0x0050 (0x0050 - 0x0000)
struct OrionGameState_MOBA_DebugCapsuleSendToAll final
{
public:
	struct FVector                                Center;                                            // 0x0000(0x000C)(ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfHeight;                                        // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0xC];                                       // 0x0014(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Rotation;                                          // 0x0020(0x0010)(ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0030(0x0004)(ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x0034(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x003C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0xC];                                       // 0x0044(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionGameState_MOBA_DebugCapsuleSendToAll) == 0x000010, "Wrong alignment on OrionGameState_MOBA_DebugCapsuleSendToAll");
static_assert(sizeof(OrionGameState_MOBA_DebugCapsuleSendToAll) == 0x000050, "Wrong size on OrionGameState_MOBA_DebugCapsuleSendToAll");
static_assert(offsetof(OrionGameState_MOBA_DebugCapsuleSendToAll, Center) == 0x000000, "Member 'OrionGameState_MOBA_DebugCapsuleSendToAll::Center' has a wrong offset!");
static_assert(offsetof(OrionGameState_MOBA_DebugCapsuleSendToAll, HalfHeight) == 0x00000C, "Member 'OrionGameState_MOBA_DebugCapsuleSendToAll::HalfHeight' has a wrong offset!");
static_assert(offsetof(OrionGameState_MOBA_DebugCapsuleSendToAll, Radius) == 0x000010, "Member 'OrionGameState_MOBA_DebugCapsuleSendToAll::Radius' has a wrong offset!");
static_assert(offsetof(OrionGameState_MOBA_DebugCapsuleSendToAll, Rotation) == 0x000020, "Member 'OrionGameState_MOBA_DebugCapsuleSendToAll::Rotation' has a wrong offset!");
static_assert(offsetof(OrionGameState_MOBA_DebugCapsuleSendToAll, Color) == 0x000030, "Member 'OrionGameState_MOBA_DebugCapsuleSendToAll::Color' has a wrong offset!");
static_assert(offsetof(OrionGameState_MOBA_DebugCapsuleSendToAll, bPersistentLines) == 0x000034, "Member 'OrionGameState_MOBA_DebugCapsuleSendToAll::bPersistentLines' has a wrong offset!");
static_assert(offsetof(OrionGameState_MOBA_DebugCapsuleSendToAll, LifeTime) == 0x000038, "Member 'OrionGameState_MOBA_DebugCapsuleSendToAll::LifeTime' has a wrong offset!");
static_assert(offsetof(OrionGameState_MOBA_DebugCapsuleSendToAll, DepthPriority) == 0x00003C, "Member 'OrionGameState_MOBA_DebugCapsuleSendToAll::DepthPriority' has a wrong offset!");
static_assert(offsetof(OrionGameState_MOBA_DebugCapsuleSendToAll, Thickness) == 0x000040, "Member 'OrionGameState_MOBA_DebugCapsuleSendToAll::Thickness' has a wrong offset!");

// Function OrionGame.OrionGameState_MOBA.DebugLineSendToAll
// 0x002C (0x002C - 0x0000)
struct OrionGameState_MOBA_DebugLineSendToAll final
{
public:
	struct FVector                                LineStart;                                         // 0x0000(0x000C)(ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LineEnd;                                           // 0x000C(0x000C)(ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0018(0x0004)(ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x0024(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameState_MOBA_DebugLineSendToAll) == 0x000004, "Wrong alignment on OrionGameState_MOBA_DebugLineSendToAll");
static_assert(sizeof(OrionGameState_MOBA_DebugLineSendToAll) == 0x00002C, "Wrong size on OrionGameState_MOBA_DebugLineSendToAll");
static_assert(offsetof(OrionGameState_MOBA_DebugLineSendToAll, LineStart) == 0x000000, "Member 'OrionGameState_MOBA_DebugLineSendToAll::LineStart' has a wrong offset!");
static_assert(offsetof(OrionGameState_MOBA_DebugLineSendToAll, LineEnd) == 0x00000C, "Member 'OrionGameState_MOBA_DebugLineSendToAll::LineEnd' has a wrong offset!");
static_assert(offsetof(OrionGameState_MOBA_DebugLineSendToAll, Color) == 0x000018, "Member 'OrionGameState_MOBA_DebugLineSendToAll::Color' has a wrong offset!");
static_assert(offsetof(OrionGameState_MOBA_DebugLineSendToAll, bPersistentLines) == 0x00001C, "Member 'OrionGameState_MOBA_DebugLineSendToAll::bPersistentLines' has a wrong offset!");
static_assert(offsetof(OrionGameState_MOBA_DebugLineSendToAll, LifeTime) == 0x000020, "Member 'OrionGameState_MOBA_DebugLineSendToAll::LifeTime' has a wrong offset!");
static_assert(offsetof(OrionGameState_MOBA_DebugLineSendToAll, DepthPriority) == 0x000024, "Member 'OrionGameState_MOBA_DebugLineSendToAll::DepthPriority' has a wrong offset!");
static_assert(offsetof(OrionGameState_MOBA_DebugLineSendToAll, Thickness) == 0x000028, "Member 'OrionGameState_MOBA_DebugLineSendToAll::Thickness' has a wrong offset!");

// Function OrionGame.OrionGameState_MOBA.DebugSphereSendToAll
// 0x0028 (0x0028 - 0x0000)
struct OrionGameState_MOBA_DebugSphereSendToAll final
{
public:
	struct FVector                                Center;                                            // 0x0000(0x000C)(ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Segments;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0014(0x0004)(ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameState_MOBA_DebugSphereSendToAll) == 0x000004, "Wrong alignment on OrionGameState_MOBA_DebugSphereSendToAll");
static_assert(sizeof(OrionGameState_MOBA_DebugSphereSendToAll) == 0x000028, "Wrong size on OrionGameState_MOBA_DebugSphereSendToAll");
static_assert(offsetof(OrionGameState_MOBA_DebugSphereSendToAll, Center) == 0x000000, "Member 'OrionGameState_MOBA_DebugSphereSendToAll::Center' has a wrong offset!");
static_assert(offsetof(OrionGameState_MOBA_DebugSphereSendToAll, Radius) == 0x00000C, "Member 'OrionGameState_MOBA_DebugSphereSendToAll::Radius' has a wrong offset!");
static_assert(offsetof(OrionGameState_MOBA_DebugSphereSendToAll, Segments) == 0x000010, "Member 'OrionGameState_MOBA_DebugSphereSendToAll::Segments' has a wrong offset!");
static_assert(offsetof(OrionGameState_MOBA_DebugSphereSendToAll, Color) == 0x000014, "Member 'OrionGameState_MOBA_DebugSphereSendToAll::Color' has a wrong offset!");
static_assert(offsetof(OrionGameState_MOBA_DebugSphereSendToAll, bPersistentLines) == 0x000018, "Member 'OrionGameState_MOBA_DebugSphereSendToAll::bPersistentLines' has a wrong offset!");
static_assert(offsetof(OrionGameState_MOBA_DebugSphereSendToAll, LifeTime) == 0x00001C, "Member 'OrionGameState_MOBA_DebugSphereSendToAll::LifeTime' has a wrong offset!");
static_assert(offsetof(OrionGameState_MOBA_DebugSphereSendToAll, DepthPriority) == 0x000020, "Member 'OrionGameState_MOBA_DebugSphereSendToAll::DepthPriority' has a wrong offset!");
static_assert(offsetof(OrionGameState_MOBA_DebugSphereSendToAll, Thickness) == 0x000024, "Member 'OrionGameState_MOBA_DebugSphereSendToAll::Thickness' has a wrong offset!");

// Function OrionGame.OrionGameState_MOBA.DecrementMatchTeamScore
// 0x0008 (0x0008 - 0x0000)
struct OrionGameState_MOBA_DecrementMatchTeamScore final
{
public:
	EOrionTeam                                    TeamNum;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Value;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameState_MOBA_DecrementMatchTeamScore) == 0x000004, "Wrong alignment on OrionGameState_MOBA_DecrementMatchTeamScore");
static_assert(sizeof(OrionGameState_MOBA_DecrementMatchTeamScore) == 0x000008, "Wrong size on OrionGameState_MOBA_DecrementMatchTeamScore");
static_assert(offsetof(OrionGameState_MOBA_DecrementMatchTeamScore, TeamNum) == 0x000000, "Member 'OrionGameState_MOBA_DecrementMatchTeamScore::TeamNum' has a wrong offset!");
static_assert(offsetof(OrionGameState_MOBA_DecrementMatchTeamScore, Value) == 0x000004, "Member 'OrionGameState_MOBA_DecrementMatchTeamScore::Value' has a wrong offset!");

// Function OrionGame.OrionGameState_MOBA.DoesMatchDisplayScore
// 0x0001 (0x0001 - 0x0000)
struct OrionGameState_MOBA_DoesMatchDisplayScore final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameState_MOBA_DoesMatchDisplayScore) == 0x000001, "Wrong alignment on OrionGameState_MOBA_DoesMatchDisplayScore");
static_assert(sizeof(OrionGameState_MOBA_DoesMatchDisplayScore) == 0x000001, "Wrong size on OrionGameState_MOBA_DoesMatchDisplayScore");
static_assert(offsetof(OrionGameState_MOBA_DoesMatchDisplayScore, ReturnValue) == 0x000000, "Member 'OrionGameState_MOBA_DoesMatchDisplayScore::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameState_MOBA.DoesMatchDisplayTime
// 0x0001 (0x0001 - 0x0000)
struct OrionGameState_MOBA_DoesMatchDisplayTime final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameState_MOBA_DoesMatchDisplayTime) == 0x000001, "Wrong alignment on OrionGameState_MOBA_DoesMatchDisplayTime");
static_assert(sizeof(OrionGameState_MOBA_DoesMatchDisplayTime) == 0x000001, "Wrong size on OrionGameState_MOBA_DoesMatchDisplayTime");
static_assert(offsetof(OrionGameState_MOBA_DoesMatchDisplayTime, ReturnValue) == 0x000000, "Member 'OrionGameState_MOBA_DoesMatchDisplayTime::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameState_MOBA.GetGameModeRecallTime
// 0x0004 (0x0004 - 0x0000)
struct OrionGameState_MOBA_GetGameModeRecallTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameState_MOBA_GetGameModeRecallTime) == 0x000004, "Wrong alignment on OrionGameState_MOBA_GetGameModeRecallTime");
static_assert(sizeof(OrionGameState_MOBA_GetGameModeRecallTime) == 0x000004, "Wrong size on OrionGameState_MOBA_GetGameModeRecallTime");
static_assert(offsetof(OrionGameState_MOBA_GetGameModeRecallTime, ReturnValue) == 0x000000, "Member 'OrionGameState_MOBA_GetGameModeRecallTime::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameState_MOBA.GetGameModeType
// 0x0001 (0x0001 - 0x0000)
struct OrionGameState_MOBA_GetGameModeType final
{
public:
	EGameModeType                                 ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameState_MOBA_GetGameModeType) == 0x000001, "Wrong alignment on OrionGameState_MOBA_GetGameModeType");
static_assert(sizeof(OrionGameState_MOBA_GetGameModeType) == 0x000001, "Wrong size on OrionGameState_MOBA_GetGameModeType");
static_assert(offsetof(OrionGameState_MOBA_GetGameModeType, ReturnValue) == 0x000000, "Member 'OrionGameState_MOBA_GetGameModeType::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameState_MOBA.GetIsMatchScoreBased
// 0x0001 (0x0001 - 0x0000)
struct OrionGameState_MOBA_GetIsMatchScoreBased final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameState_MOBA_GetIsMatchScoreBased) == 0x000001, "Wrong alignment on OrionGameState_MOBA_GetIsMatchScoreBased");
static_assert(sizeof(OrionGameState_MOBA_GetIsMatchScoreBased) == 0x000001, "Wrong size on OrionGameState_MOBA_GetIsMatchScoreBased");
static_assert(offsetof(OrionGameState_MOBA_GetIsMatchScoreBased, ReturnValue) == 0x000000, "Member 'OrionGameState_MOBA_GetIsMatchScoreBased::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameState_MOBA.GetIsMatchTimeBased
// 0x0001 (0x0001 - 0x0000)
struct OrionGameState_MOBA_GetIsMatchTimeBased final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameState_MOBA_GetIsMatchTimeBased) == 0x000001, "Wrong alignment on OrionGameState_MOBA_GetIsMatchTimeBased");
static_assert(sizeof(OrionGameState_MOBA_GetIsMatchTimeBased) == 0x000001, "Wrong size on OrionGameState_MOBA_GetIsMatchTimeBased");
static_assert(offsetof(OrionGameState_MOBA_GetIsMatchTimeBased, ReturnValue) == 0x000000, "Member 'OrionGameState_MOBA_GetIsMatchTimeBased::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameState_MOBA.GetMatchScoreLimit
// 0x0004 (0x0004 - 0x0000)
struct OrionGameState_MOBA_GetMatchScoreLimit final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameState_MOBA_GetMatchScoreLimit) == 0x000004, "Wrong alignment on OrionGameState_MOBA_GetMatchScoreLimit");
static_assert(sizeof(OrionGameState_MOBA_GetMatchScoreLimit) == 0x000004, "Wrong size on OrionGameState_MOBA_GetMatchScoreLimit");
static_assert(offsetof(OrionGameState_MOBA_GetMatchScoreLimit, ReturnValue) == 0x000000, "Member 'OrionGameState_MOBA_GetMatchScoreLimit::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameState_MOBA.GetMatchScoreUpdateTick
// 0x0004 (0x0004 - 0x0000)
struct OrionGameState_MOBA_GetMatchScoreUpdateTick final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameState_MOBA_GetMatchScoreUpdateTick) == 0x000004, "Wrong alignment on OrionGameState_MOBA_GetMatchScoreUpdateTick");
static_assert(sizeof(OrionGameState_MOBA_GetMatchScoreUpdateTick) == 0x000004, "Wrong size on OrionGameState_MOBA_GetMatchScoreUpdateTick");
static_assert(offsetof(OrionGameState_MOBA_GetMatchScoreUpdateTick, ReturnValue) == 0x000000, "Member 'OrionGameState_MOBA_GetMatchScoreUpdateTick::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameState_MOBA.GetMatchStartingScore
// 0x0004 (0x0004 - 0x0000)
struct OrionGameState_MOBA_GetMatchStartingScore final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameState_MOBA_GetMatchStartingScore) == 0x000004, "Wrong alignment on OrionGameState_MOBA_GetMatchStartingScore");
static_assert(sizeof(OrionGameState_MOBA_GetMatchStartingScore) == 0x000004, "Wrong size on OrionGameState_MOBA_GetMatchStartingScore");
static_assert(offsetof(OrionGameState_MOBA_GetMatchStartingScore, ReturnValue) == 0x000000, "Member 'OrionGameState_MOBA_GetMatchStartingScore::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameState_MOBA.GetMatchTeamScore
// 0x0008 (0x0008 - 0x0000)
struct OrionGameState_MOBA_GetMatchTeamScore final
{
public:
	EOrionTeam                                    TeamNum;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameState_MOBA_GetMatchTeamScore) == 0x000004, "Wrong alignment on OrionGameState_MOBA_GetMatchTeamScore");
static_assert(sizeof(OrionGameState_MOBA_GetMatchTeamScore) == 0x000008, "Wrong size on OrionGameState_MOBA_GetMatchTeamScore");
static_assert(offsetof(OrionGameState_MOBA_GetMatchTeamScore, TeamNum) == 0x000000, "Member 'OrionGameState_MOBA_GetMatchTeamScore::TeamNum' has a wrong offset!");
static_assert(offsetof(OrionGameState_MOBA_GetMatchTeamScore, ReturnValue) == 0x000004, "Member 'OrionGameState_MOBA_GetMatchTeamScore::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameState_MOBA.GetMatchTimeLimit
// 0x0004 (0x0004 - 0x0000)
struct OrionGameState_MOBA_GetMatchTimeLimit final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameState_MOBA_GetMatchTimeLimit) == 0x000004, "Wrong alignment on OrionGameState_MOBA_GetMatchTimeLimit");
static_assert(sizeof(OrionGameState_MOBA_GetMatchTimeLimit) == 0x000004, "Wrong size on OrionGameState_MOBA_GetMatchTimeLimit");
static_assert(offsetof(OrionGameState_MOBA_GetMatchTimeLimit, ReturnValue) == 0x000000, "Member 'OrionGameState_MOBA_GetMatchTimeLimit::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameState_MOBA.GetMatchUpdateScoreOnTickValue
// 0x0004 (0x0004 - 0x0000)
struct OrionGameState_MOBA_GetMatchUpdateScoreOnTickValue final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameState_MOBA_GetMatchUpdateScoreOnTickValue) == 0x000004, "Wrong alignment on OrionGameState_MOBA_GetMatchUpdateScoreOnTickValue");
static_assert(sizeof(OrionGameState_MOBA_GetMatchUpdateScoreOnTickValue) == 0x000004, "Wrong size on OrionGameState_MOBA_GetMatchUpdateScoreOnTickValue");
static_assert(offsetof(OrionGameState_MOBA_GetMatchUpdateScoreOnTickValue, ReturnValue) == 0x000000, "Member 'OrionGameState_MOBA_GetMatchUpdateScoreOnTickValue::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameState_MOBA.GetTeamWithHighestScore
// 0x0001 (0x0001 - 0x0000)
struct OrionGameState_MOBA_GetTeamWithHighestScore final
{
public:
	EOrionTeam                                    ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameState_MOBA_GetTeamWithHighestScore) == 0x000001, "Wrong alignment on OrionGameState_MOBA_GetTeamWithHighestScore");
static_assert(sizeof(OrionGameState_MOBA_GetTeamWithHighestScore) == 0x000001, "Wrong size on OrionGameState_MOBA_GetTeamWithHighestScore");
static_assert(offsetof(OrionGameState_MOBA_GetTeamWithHighestScore, ReturnValue) == 0x000000, "Member 'OrionGameState_MOBA_GetTeamWithHighestScore::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameState_MOBA.GetVictoryAbilitySystemFor
// 0x0010 (0x0010 - 0x0000)
struct OrionGameState_MOBA_GetVictoryAbilitySystemFor final
{
public:
	EMatchEndTeamPlacement                        VictoryPlayerIndex;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameState_MOBA_GetVictoryAbilitySystemFor) == 0x000008, "Wrong alignment on OrionGameState_MOBA_GetVictoryAbilitySystemFor");
static_assert(sizeof(OrionGameState_MOBA_GetVictoryAbilitySystemFor) == 0x000010, "Wrong size on OrionGameState_MOBA_GetVictoryAbilitySystemFor");
static_assert(offsetof(OrionGameState_MOBA_GetVictoryAbilitySystemFor, VictoryPlayerIndex) == 0x000000, "Member 'OrionGameState_MOBA_GetVictoryAbilitySystemFor::VictoryPlayerIndex' has a wrong offset!");
static_assert(offsetof(OrionGameState_MOBA_GetVictoryAbilitySystemFor, ReturnValue) == 0x000008, "Member 'OrionGameState_MOBA_GetVictoryAbilitySystemFor::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameState_MOBA.GetVictoryPawnFor
// 0x0010 (0x0010 - 0x0000)
struct OrionGameState_MOBA_GetVictoryPawnFor final
{
public:
	EMatchEndTeamPlacement                        VictoryPlayerIndex;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameState_MOBA_GetVictoryPawnFor) == 0x000008, "Wrong alignment on OrionGameState_MOBA_GetVictoryPawnFor");
static_assert(sizeof(OrionGameState_MOBA_GetVictoryPawnFor) == 0x000010, "Wrong size on OrionGameState_MOBA_GetVictoryPawnFor");
static_assert(offsetof(OrionGameState_MOBA_GetVictoryPawnFor, VictoryPlayerIndex) == 0x000000, "Member 'OrionGameState_MOBA_GetVictoryPawnFor::VictoryPlayerIndex' has a wrong offset!");
static_assert(offsetof(OrionGameState_MOBA_GetVictoryPawnFor, ReturnValue) == 0x000008, "Member 'OrionGameState_MOBA_GetVictoryPawnFor::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameState_MOBA.GiveTeamCardXP
// 0x0030 (0x0030 - 0x0000)
struct OrionGameState_MOBA_GiveTeamCardXP final
{
public:
	EOrionTeam                                    InTeam;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         XP;                                                // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionPlayerState_Game*                 Earner;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  GrantedTags;                                       // 0x0010(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameState_MOBA_GiveTeamCardXP) == 0x000008, "Wrong alignment on OrionGameState_MOBA_GiveTeamCardXP");
static_assert(sizeof(OrionGameState_MOBA_GiveTeamCardXP) == 0x000030, "Wrong size on OrionGameState_MOBA_GiveTeamCardXP");
static_assert(offsetof(OrionGameState_MOBA_GiveTeamCardXP, InTeam) == 0x000000, "Member 'OrionGameState_MOBA_GiveTeamCardXP::InTeam' has a wrong offset!");
static_assert(offsetof(OrionGameState_MOBA_GiveTeamCardXP, XP) == 0x000004, "Member 'OrionGameState_MOBA_GiveTeamCardXP::XP' has a wrong offset!");
static_assert(offsetof(OrionGameState_MOBA_GiveTeamCardXP, Earner) == 0x000008, "Member 'OrionGameState_MOBA_GiveTeamCardXP::Earner' has a wrong offset!");
static_assert(offsetof(OrionGameState_MOBA_GiveTeamCardXP, GrantedTags) == 0x000010, "Member 'OrionGameState_MOBA_GiveTeamCardXP::GrantedTags' has a wrong offset!");

// Function OrionGame.OrionGameState_MOBA.HideVictoryActor
// 0x0001 (0x0001 - 0x0000)
struct OrionGameState_MOBA_HideVictoryActor final
{
public:
	EMatchEndTeamPlacement                        VictoryPlayerIndex;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameState_MOBA_HideVictoryActor) == 0x000001, "Wrong alignment on OrionGameState_MOBA_HideVictoryActor");
static_assert(sizeof(OrionGameState_MOBA_HideVictoryActor) == 0x000001, "Wrong size on OrionGameState_MOBA_HideVictoryActor");
static_assert(offsetof(OrionGameState_MOBA_HideVictoryActor, VictoryPlayerIndex) == 0x000000, "Member 'OrionGameState_MOBA_HideVictoryActor::VictoryPlayerIndex' has a wrong offset!");

// Function OrionGame.OrionGameState_MOBA.IncrementMatchTeamScore
// 0x0008 (0x0008 - 0x0000)
struct OrionGameState_MOBA_IncrementMatchTeamScore final
{
public:
	EOrionTeam                                    TeamNum;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Value;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameState_MOBA_IncrementMatchTeamScore) == 0x000004, "Wrong alignment on OrionGameState_MOBA_IncrementMatchTeamScore");
static_assert(sizeof(OrionGameState_MOBA_IncrementMatchTeamScore) == 0x000008, "Wrong size on OrionGameState_MOBA_IncrementMatchTeamScore");
static_assert(offsetof(OrionGameState_MOBA_IncrementMatchTeamScore, TeamNum) == 0x000000, "Member 'OrionGameState_MOBA_IncrementMatchTeamScore::TeamNum' has a wrong offset!");
static_assert(offsetof(OrionGameState_MOBA_IncrementMatchTeamScore, Value) == 0x000004, "Member 'OrionGameState_MOBA_IncrementMatchTeamScore::Value' has a wrong offset!");

// Function OrionGame.OrionGameState_MOBA.MatchEndSequenceStopped
// 0x0008 (0x0008 - 0x0000)
struct OrionGameState_MOBA_MatchEndSequenceStopped final
{
public:
	class AActor*                                 ViewTarget;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameState_MOBA_MatchEndSequenceStopped) == 0x000008, "Wrong alignment on OrionGameState_MOBA_MatchEndSequenceStopped");
static_assert(sizeof(OrionGameState_MOBA_MatchEndSequenceStopped) == 0x000008, "Wrong size on OrionGameState_MOBA_MatchEndSequenceStopped");
static_assert(offsetof(OrionGameState_MOBA_MatchEndSequenceStopped, ViewTarget) == 0x000000, "Member 'OrionGameState_MOBA_MatchEndSequenceStopped::ViewTarget' has a wrong offset!");

// Function OrionGame.OrionGameState_MOBA.MulticastNotifyAIKilled
// 0x0010 (0x0010 - 0x0000)
struct OrionGameState_MOBA_MulticastNotifyAIKilled final
{
public:
	class AOrionCharAI*                           KilledAI;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionPlayerState_Game*                 KillerPlayer;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameState_MOBA_MulticastNotifyAIKilled) == 0x000008, "Wrong alignment on OrionGameState_MOBA_MulticastNotifyAIKilled");
static_assert(sizeof(OrionGameState_MOBA_MulticastNotifyAIKilled) == 0x000010, "Wrong size on OrionGameState_MOBA_MulticastNotifyAIKilled");
static_assert(offsetof(OrionGameState_MOBA_MulticastNotifyAIKilled, KilledAI) == 0x000000, "Member 'OrionGameState_MOBA_MulticastNotifyAIKilled::KilledAI' has a wrong offset!");
static_assert(offsetof(OrionGameState_MOBA_MulticastNotifyAIKilled, KillerPlayer) == 0x000008, "Member 'OrionGameState_MOBA_MulticastNotifyAIKilled::KillerPlayer' has a wrong offset!");

// Function OrionGame.OrionGameState_MOBA.MulticastNotifyPlayerKilled
// 0x0010 (0x0010 - 0x0000)
struct OrionGameState_MOBA_MulticastNotifyPlayerKilled final
{
public:
	class AOrionPlayerState_Game*                 KilledPlayer;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 KillerActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameState_MOBA_MulticastNotifyPlayerKilled) == 0x000008, "Wrong alignment on OrionGameState_MOBA_MulticastNotifyPlayerKilled");
static_assert(sizeof(OrionGameState_MOBA_MulticastNotifyPlayerKilled) == 0x000010, "Wrong size on OrionGameState_MOBA_MulticastNotifyPlayerKilled");
static_assert(offsetof(OrionGameState_MOBA_MulticastNotifyPlayerKilled, KilledPlayer) == 0x000000, "Member 'OrionGameState_MOBA_MulticastNotifyPlayerKilled::KilledPlayer' has a wrong offset!");
static_assert(offsetof(OrionGameState_MOBA_MulticastNotifyPlayerKilled, KillerActor) == 0x000008, "Member 'OrionGameState_MOBA_MulticastNotifyPlayerKilled::KillerActor' has a wrong offset!");

// Function OrionGame.OrionGameState_MOBA.PlaceWinningActor
// 0x0010 (0x0010 - 0x0000)
struct OrionGameState_MOBA_PlaceWinningActor final
{
public:
	class AActor*                                 PlacementSpot;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatchEndTeamPlacement                        VictoryPlayerIndex;                                // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionGameState_MOBA_PlaceWinningActor) == 0x000008, "Wrong alignment on OrionGameState_MOBA_PlaceWinningActor");
static_assert(sizeof(OrionGameState_MOBA_PlaceWinningActor) == 0x000010, "Wrong size on OrionGameState_MOBA_PlaceWinningActor");
static_assert(offsetof(OrionGameState_MOBA_PlaceWinningActor, PlacementSpot) == 0x000000, "Member 'OrionGameState_MOBA_PlaceWinningActor::PlacementSpot' has a wrong offset!");
static_assert(offsetof(OrionGameState_MOBA_PlaceWinningActor, VictoryPlayerIndex) == 0x000008, "Member 'OrionGameState_MOBA_PlaceWinningActor::VictoryPlayerIndex' has a wrong offset!");

// Function OrionGame.OrionGameState_MOBA.PlayVictoryAnimOn
// 0x0001 (0x0001 - 0x0000)
struct OrionGameState_MOBA_PlayVictoryAnimOn final
{
public:
	EMatchEndTeamPlacement                        VictoryPlayerIndex;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameState_MOBA_PlayVictoryAnimOn) == 0x000001, "Wrong alignment on OrionGameState_MOBA_PlayVictoryAnimOn");
static_assert(sizeof(OrionGameState_MOBA_PlayVictoryAnimOn) == 0x000001, "Wrong size on OrionGameState_MOBA_PlayVictoryAnimOn");
static_assert(offsetof(OrionGameState_MOBA_PlayVictoryAnimOn, VictoryPlayerIndex) == 0x000000, "Member 'OrionGameState_MOBA_PlayVictoryAnimOn::VictoryPlayerIndex' has a wrong offset!");

// Function OrionGame.OrionGameState_MOBA.SetEndMatchSequence
// 0x0008 (0x0008 - 0x0000)
struct OrionGameState_MOBA_SetEndMatchSequence final
{
public:
	class ULevelSequencePlayer*                   InSequence;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameState_MOBA_SetEndMatchSequence) == 0x000008, "Wrong alignment on OrionGameState_MOBA_SetEndMatchSequence");
static_assert(sizeof(OrionGameState_MOBA_SetEndMatchSequence) == 0x000008, "Wrong size on OrionGameState_MOBA_SetEndMatchSequence");
static_assert(offsetof(OrionGameState_MOBA_SetEndMatchSequence, InSequence) == 0x000000, "Member 'OrionGameState_MOBA_SetEndMatchSequence::InSequence' has a wrong offset!");

// Function OrionGame.OrionGameState_MOBA.SetMatchTeamScore
// 0x0008 (0x0008 - 0x0000)
struct OrionGameState_MOBA_SetMatchTeamScore final
{
public:
	EOrionTeam                                    TeamNum;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NewScore;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameState_MOBA_SetMatchTeamScore) == 0x000004, "Wrong alignment on OrionGameState_MOBA_SetMatchTeamScore");
static_assert(sizeof(OrionGameState_MOBA_SetMatchTeamScore) == 0x000008, "Wrong size on OrionGameState_MOBA_SetMatchTeamScore");
static_assert(offsetof(OrionGameState_MOBA_SetMatchTeamScore, TeamNum) == 0x000000, "Member 'OrionGameState_MOBA_SetMatchTeamScore::TeamNum' has a wrong offset!");
static_assert(offsetof(OrionGameState_MOBA_SetMatchTeamScore, NewScore) == 0x000004, "Member 'OrionGameState_MOBA_SetMatchTeamScore::NewScore' has a wrong offset!");

// Function OrionGame.OrionGameState_MOBA.StopVictoryAnimOn
// 0x0001 (0x0001 - 0x0000)
struct OrionGameState_MOBA_StopVictoryAnimOn final
{
public:
	EMatchEndTeamPlacement                        VictoryPlayerIndex;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameState_MOBA_StopVictoryAnimOn) == 0x000001, "Wrong alignment on OrionGameState_MOBA_StopVictoryAnimOn");
static_assert(sizeof(OrionGameState_MOBA_StopVictoryAnimOn) == 0x000001, "Wrong size on OrionGameState_MOBA_StopVictoryAnimOn");
static_assert(offsetof(OrionGameState_MOBA_StopVictoryAnimOn, VictoryPlayerIndex) == 0x000000, "Member 'OrionGameState_MOBA_StopVictoryAnimOn::VictoryPlayerIndex' has a wrong offset!");

// Function OrionGame.OrionGameState_MOBA.GetWinningTeam
// 0x0001 (0x0001 - 0x0000)
struct OrionGameState_MOBA_GetWinningTeam final
{
public:
	EOrionTeam                                    ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameState_MOBA_GetWinningTeam) == 0x000001, "Wrong alignment on OrionGameState_MOBA_GetWinningTeam");
static_assert(sizeof(OrionGameState_MOBA_GetWinningTeam) == 0x000001, "Wrong size on OrionGameState_MOBA_GetWinningTeam");
static_assert(offsetof(OrionGameState_MOBA_GetWinningTeam, ReturnValue) == 0x000000, "Member 'OrionGameState_MOBA_GetWinningTeam::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameState_Arcade.OnRep_RoundState
// 0x0018 (0x0018 - 0x0000)
struct OrionGameState_Arcade_OnRep_RoundState final
{
public:
	struct FArcadeRoundState                      OldStateRoundState;                                // 0x0000(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameState_Arcade_OnRep_RoundState) == 0x000004, "Wrong alignment on OrionGameState_Arcade_OnRep_RoundState");
static_assert(sizeof(OrionGameState_Arcade_OnRep_RoundState) == 0x000018, "Wrong size on OrionGameState_Arcade_OnRep_RoundState");
static_assert(offsetof(OrionGameState_Arcade_OnRep_RoundState, OldStateRoundState) == 0x000000, "Member 'OrionGameState_Arcade_OnRep_RoundState::OldStateRoundState' has a wrong offset!");

// Function OrionGame.OrionGameState_Arcade.OnRoundStateChange
// 0x0001 (0x0001 - 0x0000)
struct OrionGameState_Arcade_OnRoundStateChange final
{
public:
	EArcadeRoundPhase                             NewRoundState;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameState_Arcade_OnRoundStateChange) == 0x000001, "Wrong alignment on OrionGameState_Arcade_OnRoundStateChange");
static_assert(sizeof(OrionGameState_Arcade_OnRoundStateChange) == 0x000001, "Wrong size on OrionGameState_Arcade_OnRoundStateChange");
static_assert(offsetof(OrionGameState_Arcade_OnRoundStateChange, NewRoundState) == 0x000000, "Member 'OrionGameState_Arcade_OnRoundStateChange::NewRoundState' has a wrong offset!");

// Function OrionGame.OrionMcpEmoteItem.GetInternalData
// 0x0008 (0x0008 - 0x0000)
struct OrionMcpEmoteItem_GetInternalData final
{
public:
	class UOrionEmoteItemDefinition*              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpEmoteItem_GetInternalData) == 0x000008, "Wrong alignment on OrionMcpEmoteItem_GetInternalData");
static_assert(sizeof(OrionMcpEmoteItem_GetInternalData) == 0x000008, "Wrong size on OrionMcpEmoteItem_GetInternalData");
static_assert(offsetof(OrionMcpEmoteItem_GetInternalData, ReturnValue) == 0x000000, "Member 'OrionMcpEmoteItem_GetInternalData::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameState_MOBA_Tutorial.BP_GetTutorialPlayerController
// 0x0008 (0x0008 - 0x0000)
struct OrionGameState_MOBA_Tutorial_BP_GetTutorialPlayerController final
{
public:
	class AOrionPlayerController_Tutorial*        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameState_MOBA_Tutorial_BP_GetTutorialPlayerController) == 0x000008, "Wrong alignment on OrionGameState_MOBA_Tutorial_BP_GetTutorialPlayerController");
static_assert(sizeof(OrionGameState_MOBA_Tutorial_BP_GetTutorialPlayerController) == 0x000008, "Wrong size on OrionGameState_MOBA_Tutorial_BP_GetTutorialPlayerController");
static_assert(offsetof(OrionGameState_MOBA_Tutorial_BP_GetTutorialPlayerController, ReturnValue) == 0x000000, "Member 'OrionGameState_MOBA_Tutorial_BP_GetTutorialPlayerController::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameState_MOBA_Tutorial.BP_GetTutorialPlayerState
// 0x0008 (0x0008 - 0x0000)
struct OrionGameState_MOBA_Tutorial_BP_GetTutorialPlayerState final
{
public:
	class AOrionPlayerState_Tutorial*             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameState_MOBA_Tutorial_BP_GetTutorialPlayerState) == 0x000008, "Wrong alignment on OrionGameState_MOBA_Tutorial_BP_GetTutorialPlayerState");
static_assert(sizeof(OrionGameState_MOBA_Tutorial_BP_GetTutorialPlayerState) == 0x000008, "Wrong size on OrionGameState_MOBA_Tutorial_BP_GetTutorialPlayerState");
static_assert(offsetof(OrionGameState_MOBA_Tutorial_BP_GetTutorialPlayerState, ReturnValue) == 0x000000, "Member 'OrionGameState_MOBA_Tutorial_BP_GetTutorialPlayerState::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameViewportClient.OnAnalogCursorEnabledToggle
// 0x0001 (0x0001 - 0x0000)
struct OrionGameViewportClient_OnAnalogCursorEnabledToggle final
{
public:
	bool                                          bIsEnabled;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameViewportClient_OnAnalogCursorEnabledToggle) == 0x000001, "Wrong alignment on OrionGameViewportClient_OnAnalogCursorEnabledToggle");
static_assert(sizeof(OrionGameViewportClient_OnAnalogCursorEnabledToggle) == 0x000001, "Wrong size on OrionGameViewportClient_OnAnalogCursorEnabledToggle");
static_assert(offsetof(OrionGameViewportClient_OnAnalogCursorEnabledToggle, bIsEnabled) == 0x000000, "Member 'OrionGameViewportClient_OnAnalogCursorEnabledToggle::bIsEnabled' has a wrong offset!");

// Function OrionGame.OrionGestureData.GetMatchingGestureEntry
// 0x0020 (0x0020 - 0x0000)
struct OrionGestureData_GetMatchingGestureEntry final
{
public:
	EOrionGestureDirection                        Direction1;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionGestureDirection                        Direction2;                                        // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionGestureEntry                     ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGestureData_GetMatchingGestureEntry) == 0x000008, "Wrong alignment on OrionGestureData_GetMatchingGestureEntry");
static_assert(sizeof(OrionGestureData_GetMatchingGestureEntry) == 0x000020, "Wrong size on OrionGestureData_GetMatchingGestureEntry");
static_assert(offsetof(OrionGestureData_GetMatchingGestureEntry, Direction1) == 0x000000, "Member 'OrionGestureData_GetMatchingGestureEntry::Direction1' has a wrong offset!");
static_assert(offsetof(OrionGestureData_GetMatchingGestureEntry, Direction2) == 0x000001, "Member 'OrionGestureData_GetMatchingGestureEntry::Direction2' has a wrong offset!");
static_assert(offsetof(OrionGestureData_GetMatchingGestureEntry, ReturnValue) == 0x000008, "Member 'OrionGestureData_GetMatchingGestureEntry::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGravesite.ActivateGravesite
// 0x001C (0x001C - 0x0000)
struct OrionGravesite_ActivateGravesite final
{
public:
	struct FVector                                Pos;                                               // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TriggerPos;                                        // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionGravesite_ActivateGravesite) == 0x000004, "Wrong alignment on OrionGravesite_ActivateGravesite");
static_assert(sizeof(OrionGravesite_ActivateGravesite) == 0x00001C, "Wrong size on OrionGravesite_ActivateGravesite");
static_assert(offsetof(OrionGravesite_ActivateGravesite, Pos) == 0x000000, "Member 'OrionGravesite_ActivateGravesite::Pos' has a wrong offset!");
static_assert(offsetof(OrionGravesite_ActivateGravesite, TriggerPos) == 0x00000C, "Member 'OrionGravesite_ActivateGravesite::TriggerPos' has a wrong offset!");
static_assert(offsetof(OrionGravesite_ActivateGravesite, ReturnValue) == 0x000018, "Member 'OrionGravesite_ActivateGravesite::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGravesite.AddGameplayCueLocal
// 0x00C0 (0x00C0 - 0x0000)
struct OrionGravesite_AddGameplayCueLocal final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 Parameters;                                        // 0x0008(0x00B8)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGravesite_AddGameplayCueLocal) == 0x000008, "Wrong alignment on OrionGravesite_AddGameplayCueLocal");
static_assert(sizeof(OrionGravesite_AddGameplayCueLocal) == 0x0000C0, "Wrong size on OrionGravesite_AddGameplayCueLocal");
static_assert(offsetof(OrionGravesite_AddGameplayCueLocal, GameplayCueTag) == 0x000000, "Member 'OrionGravesite_AddGameplayCueLocal::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(OrionGravesite_AddGameplayCueLocal, Parameters) == 0x000008, "Member 'OrionGravesite_AddGameplayCueLocal::Parameters' has a wrong offset!");

// Function OrionGame.OrionGravesite.ExecuteGameplayCueLocal
// 0x00C0 (0x00C0 - 0x0000)
struct OrionGravesite_ExecuteGameplayCueLocal final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 Parameters;                                        // 0x0008(0x00B8)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGravesite_ExecuteGameplayCueLocal) == 0x000008, "Wrong alignment on OrionGravesite_ExecuteGameplayCueLocal");
static_assert(sizeof(OrionGravesite_ExecuteGameplayCueLocal) == 0x0000C0, "Wrong size on OrionGravesite_ExecuteGameplayCueLocal");
static_assert(offsetof(OrionGravesite_ExecuteGameplayCueLocal, GameplayCueTag) == 0x000000, "Member 'OrionGravesite_ExecuteGameplayCueLocal::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(OrionGravesite_ExecuteGameplayCueLocal, Parameters) == 0x000008, "Member 'OrionGravesite_ExecuteGameplayCueLocal::Parameters' has a wrong offset!");

// Function OrionGame.OrionGravesite.FadeOut
// 0x0001 (0x0001 - 0x0000)
struct OrionGravesite_FadeOut final
{
public:
	bool                                          bBrightenFirst;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGravesite_FadeOut) == 0x000001, "Wrong alignment on OrionGravesite_FadeOut");
static_assert(sizeof(OrionGravesite_FadeOut) == 0x000001, "Wrong size on OrionGravesite_FadeOut");
static_assert(offsetof(OrionGravesite_FadeOut, bBrightenFirst) == 0x000000, "Member 'OrionGravesite_FadeOut::bBrightenFirst' has a wrong offset!");

// Function OrionGame.OrionGravesite.RemoveGameplayCueLocal
// 0x00C0 (0x00C0 - 0x0000)
struct OrionGravesite_RemoveGameplayCueLocal final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 Parameters;                                        // 0x0008(0x00B8)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGravesite_RemoveGameplayCueLocal) == 0x000008, "Wrong alignment on OrionGravesite_RemoveGameplayCueLocal");
static_assert(sizeof(OrionGravesite_RemoveGameplayCueLocal) == 0x0000C0, "Wrong size on OrionGravesite_RemoveGameplayCueLocal");
static_assert(offsetof(OrionGravesite_RemoveGameplayCueLocal, GameplayCueTag) == 0x000000, "Member 'OrionGravesite_RemoveGameplayCueLocal::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(OrionGravesite_RemoveGameplayCueLocal, Parameters) == 0x000008, "Member 'OrionGravesite_RemoveGameplayCueLocal::Parameters' has a wrong offset!");

// Function OrionGame.OrionHeroDisplayLibrary.GetHeroLockedMessage
// 0x0020 (0x0020 - 0x0000)
struct OrionHeroDisplayLibrary_GetHeroLockedMessage final
{
public:
	EOrionHeroTier                                Tier;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   MESSAGE;                                           // 0x0008(0x0018)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionHeroDisplayLibrary_GetHeroLockedMessage) == 0x000008, "Wrong alignment on OrionHeroDisplayLibrary_GetHeroLockedMessage");
static_assert(sizeof(OrionHeroDisplayLibrary_GetHeroLockedMessage) == 0x000020, "Wrong size on OrionHeroDisplayLibrary_GetHeroLockedMessage");
static_assert(offsetof(OrionHeroDisplayLibrary_GetHeroLockedMessage, Tier) == 0x000000, "Member 'OrionHeroDisplayLibrary_GetHeroLockedMessage::Tier' has a wrong offset!");
static_assert(offsetof(OrionHeroDisplayLibrary_GetHeroLockedMessage, MESSAGE) == 0x000008, "Member 'OrionHeroDisplayLibrary_GetHeroLockedMessage::MESSAGE' has a wrong offset!");

// Function OrionGame.OrionHeroPriceAnimInstance.AnimNotify_IK_HndShotGun_Off
// 0x0008 (0x0008 - 0x0000)
struct OrionHeroPriceAnimInstance_AnimNotify_IK_HndShotGun_Off final
{
public:
	const class UAnimNotify*                      AnimNotify;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionHeroPriceAnimInstance_AnimNotify_IK_HndShotGun_Off) == 0x000008, "Wrong alignment on OrionHeroPriceAnimInstance_AnimNotify_IK_HndShotGun_Off");
static_assert(sizeof(OrionHeroPriceAnimInstance_AnimNotify_IK_HndShotGun_Off) == 0x000008, "Wrong size on OrionHeroPriceAnimInstance_AnimNotify_IK_HndShotGun_Off");
static_assert(offsetof(OrionHeroPriceAnimInstance_AnimNotify_IK_HndShotGun_Off, AnimNotify) == 0x000000, "Member 'OrionHeroPriceAnimInstance_AnimNotify_IK_HndShotGun_Off::AnimNotify' has a wrong offset!");

// Function OrionGame.OrionHeroPriceAnimInstance.AnimNotify_IK_HndShotGun_On
// 0x0008 (0x0008 - 0x0000)
struct OrionHeroPriceAnimInstance_AnimNotify_IK_HndShotGun_On final
{
public:
	const class UAnimNotify*                      AnimNotify;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionHeroPriceAnimInstance_AnimNotify_IK_HndShotGun_On) == 0x000008, "Wrong alignment on OrionHeroPriceAnimInstance_AnimNotify_IK_HndShotGun_On");
static_assert(sizeof(OrionHeroPriceAnimInstance_AnimNotify_IK_HndShotGun_On) == 0x000008, "Wrong size on OrionHeroPriceAnimInstance_AnimNotify_IK_HndShotGun_On");
static_assert(offsetof(OrionHeroPriceAnimInstance_AnimNotify_IK_HndShotGun_On, AnimNotify) == 0x000000, "Member 'OrionHeroPriceAnimInstance_AnimNotify_IK_HndShotGun_On::AnimNotify' has a wrong offset!");

// Function OrionGame.OrionHighlightsLibrary.GetNumHighlights
// 0x0010 (0x0010 - 0x0000)
struct OrionHighlightsLibrary_GetNumHighlights final
{
public:
	TDelegate<void(int32 NumHighlights)>          Callback;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionHighlightsLibrary_GetNumHighlights) == 0x000004, "Wrong alignment on OrionHighlightsLibrary_GetNumHighlights");
static_assert(sizeof(OrionHighlightsLibrary_GetNumHighlights) == 0x000010, "Wrong size on OrionHighlightsLibrary_GetNumHighlights");
static_assert(offsetof(OrionHighlightsLibrary_GetNumHighlights, Callback) == 0x000000, "Member 'OrionHighlightsLibrary_GetNumHighlights::Callback' has a wrong offset!");

// Function OrionGame.OrionHighlightsLibrary.OpenHighlightSummary
// 0x0008 (0x0008 - 0x0000)
struct OrionHighlightsLibrary_OpenHighlightSummary final
{
public:
	class UObject*                                Context;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionHighlightsLibrary_OpenHighlightSummary) == 0x000008, "Wrong alignment on OrionHighlightsLibrary_OpenHighlightSummary");
static_assert(sizeof(OrionHighlightsLibrary_OpenHighlightSummary) == 0x000008, "Wrong size on OrionHighlightsLibrary_OpenHighlightSummary");
static_assert(offsetof(OrionHighlightsLibrary_OpenHighlightSummary, Context) == 0x000000, "Member 'OrionHighlightsLibrary_OpenHighlightSummary::Context' has a wrong offset!");

// Function OrionGame.OrionHighlightsLibrary.TriggerHighlight
// 0x0008 (0x0008 - 0x0000)
struct OrionHighlightsLibrary_TriggerHighlight final
{
public:
	class FName                                   HighlightTag;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionHighlightsLibrary_TriggerHighlight) == 0x000004, "Wrong alignment on OrionHighlightsLibrary_TriggerHighlight");
static_assert(sizeof(OrionHighlightsLibrary_TriggerHighlight) == 0x000008, "Wrong size on OrionHighlightsLibrary_TriggerHighlight");
static_assert(offsetof(OrionHighlightsLibrary_TriggerHighlight, HighlightTag) == 0x000000, "Member 'OrionHighlightsLibrary_TriggerHighlight::HighlightTag' has a wrong offset!");

// Function OrionGame.GetNumHighlightsUICallbackProxy.GetNumHighlights
// 0x0008 (0x0008 - 0x0000)
struct GetNumHighlightsUICallbackProxy_GetNumHighlights final
{
public:
	class UGetNumHighlightsUICallbackProxy*       ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GetNumHighlightsUICallbackProxy_GetNumHighlights) == 0x000008, "Wrong alignment on GetNumHighlightsUICallbackProxy_GetNumHighlights");
static_assert(sizeof(GetNumHighlightsUICallbackProxy_GetNumHighlights) == 0x000008, "Wrong size on GetNumHighlightsUICallbackProxy_GetNumHighlights");
static_assert(offsetof(GetNumHighlightsUICallbackProxy_GetNumHighlights, ReturnValue) == 0x000000, "Member 'GetNumHighlightsUICallbackProxy_GetNumHighlights::ReturnValue' has a wrong offset!");

// Function OrionGame.GetNumHighlightsUICallbackProxy.OnGetNumHighlightsComplete
// 0x0004 (0x0004 - 0x0000)
struct GetNumHighlightsUICallbackProxy_OnGetNumHighlightsComplete final
{
public:
	int32                                         Count;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GetNumHighlightsUICallbackProxy_OnGetNumHighlightsComplete) == 0x000004, "Wrong alignment on GetNumHighlightsUICallbackProxy_OnGetNumHighlightsComplete");
static_assert(sizeof(GetNumHighlightsUICallbackProxy_OnGetNumHighlightsComplete) == 0x000004, "Wrong size on GetNumHighlightsUICallbackProxy_OnGetNumHighlightsComplete");
static_assert(offsetof(GetNumHighlightsUICallbackProxy_OnGetNumHighlightsComplete, Count) == 0x000000, "Member 'GetNumHighlightsUICallbackProxy_OnGetNumHighlightsComplete::Count' has a wrong offset!");

// Function OrionGame.OrionInputKeySelector.SetOrionButtonStyle
// 0x0008 (0x0008 - 0x0000)
struct OrionInputKeySelector_SetOrionButtonStyle final
{
public:
	TSubclassOf<class UOrionButtonStyle>          InButtonStyleClass;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionInputKeySelector_SetOrionButtonStyle) == 0x000008, "Wrong alignment on OrionInputKeySelector_SetOrionButtonStyle");
static_assert(sizeof(OrionInputKeySelector_SetOrionButtonStyle) == 0x000008, "Wrong size on OrionInputKeySelector_SetOrionButtonStyle");
static_assert(offsetof(OrionInputKeySelector_SetOrionButtonStyle, InButtonStyleClass) == 0x000000, "Member 'OrionInputKeySelector_SetOrionButtonStyle::InButtonStyleClass' has a wrong offset!");

// Function OrionGame.OrionInputKeySelector.SetStyleSize
// 0x0001 (0x0001 - 0x0000)
struct OrionInputKeySelector_SetStyleSize final
{
public:
	EOrionWidgetStyleSize                         InStyleSize;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionInputKeySelector_SetStyleSize) == 0x000001, "Wrong alignment on OrionInputKeySelector_SetStyleSize");
static_assert(sizeof(OrionInputKeySelector_SetStyleSize) == 0x000001, "Wrong size on OrionInputKeySelector_SetStyleSize");
static_assert(offsetof(OrionInputKeySelector_SetStyleSize, InStyleSize) == 0x000000, "Member 'OrionInputKeySelector_SetStyleSize::InStyleSize' has a wrong offset!");

// Function OrionGame.OrionInputKeySelector.SetTextColorType
// 0x0001 (0x0001 - 0x0000)
struct OrionInputKeySelector_SetTextColorType final
{
public:
	EOrionTextColor                               InColor;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionInputKeySelector_SetTextColorType) == 0x000001, "Wrong alignment on OrionInputKeySelector_SetTextColorType");
static_assert(sizeof(OrionInputKeySelector_SetTextColorType) == 0x000001, "Wrong size on OrionInputKeySelector_SetTextColorType");
static_assert(offsetof(OrionInputKeySelector_SetTextColorType, InColor) == 0x000000, "Member 'OrionInputKeySelector_SetTextColorType::InColor' has a wrong offset!");

// Function OrionGame.OrionItemizationComponent.ServerPrintDebug_WithClientStrings
// 0x0010 (0x0010 - 0x0000)
struct OrionItemizationComponent_ServerPrintDebug_WithClientStrings final
{
public:
	TArray<class FString>                         Strings;                                           // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionItemizationComponent_ServerPrintDebug_WithClientStrings) == 0x000008, "Wrong alignment on OrionItemizationComponent_ServerPrintDebug_WithClientStrings");
static_assert(sizeof(OrionItemizationComponent_ServerPrintDebug_WithClientStrings) == 0x000010, "Wrong size on OrionItemizationComponent_ServerPrintDebug_WithClientStrings");
static_assert(offsetof(OrionItemizationComponent_ServerPrintDebug_WithClientStrings, Strings) == 0x000000, "Member 'OrionItemizationComponent_ServerPrintDebug_WithClientStrings::Strings' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.AbilityTeleportActor
// 0x0028 (0x0028 - 0x0000)
struct OrionKismetLibrary_AbilityTeleportActor final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DestLocation;                                      // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               DestRotation;                                      // 0x0014(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsGroundLocation;                                  // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0021(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_AbilityTeleportActor) == 0x000008, "Wrong alignment on OrionKismetLibrary_AbilityTeleportActor");
static_assert(sizeof(OrionKismetLibrary_AbilityTeleportActor) == 0x000028, "Wrong size on OrionKismetLibrary_AbilityTeleportActor");
static_assert(offsetof(OrionKismetLibrary_AbilityTeleportActor, TargetActor) == 0x000000, "Member 'OrionKismetLibrary_AbilityTeleportActor::TargetActor' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_AbilityTeleportActor, DestLocation) == 0x000008, "Member 'OrionKismetLibrary_AbilityTeleportActor::DestLocation' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_AbilityTeleportActor, DestRotation) == 0x000014, "Member 'OrionKismetLibrary_AbilityTeleportActor::DestRotation' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_AbilityTeleportActor, IsGroundLocation) == 0x000020, "Member 'OrionKismetLibrary_AbilityTeleportActor::IsGroundLocation' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_AbilityTeleportActor, ReturnValue) == 0x000021, "Member 'OrionKismetLibrary_AbilityTeleportActor::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.AngleBetweenInDegrees
// 0x001C (0x001C - 0x0000)
struct OrionKismetLibrary_AngleBetweenInDegrees final
{
public:
	struct FVector                                V0;                                                // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                V1;                                                // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_AngleBetweenInDegrees) == 0x000004, "Wrong alignment on OrionKismetLibrary_AngleBetweenInDegrees");
static_assert(sizeof(OrionKismetLibrary_AngleBetweenInDegrees) == 0x00001C, "Wrong size on OrionKismetLibrary_AngleBetweenInDegrees");
static_assert(offsetof(OrionKismetLibrary_AngleBetweenInDegrees, V0) == 0x000000, "Member 'OrionKismetLibrary_AngleBetweenInDegrees::V0' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_AngleBetweenInDegrees, V1) == 0x00000C, "Member 'OrionKismetLibrary_AngleBetweenInDegrees::V1' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_AngleBetweenInDegrees, ReturnValue) == 0x000018, "Member 'OrionKismetLibrary_AngleBetweenInDegrees::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.AngleBetweenInRadians
// 0x001C (0x001C - 0x0000)
struct OrionKismetLibrary_AngleBetweenInRadians final
{
public:
	struct FVector                                V0;                                                // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                V1;                                                // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_AngleBetweenInRadians) == 0x000004, "Wrong alignment on OrionKismetLibrary_AngleBetweenInRadians");
static_assert(sizeof(OrionKismetLibrary_AngleBetweenInRadians) == 0x00001C, "Wrong size on OrionKismetLibrary_AngleBetweenInRadians");
static_assert(offsetof(OrionKismetLibrary_AngleBetweenInRadians, V0) == 0x000000, "Member 'OrionKismetLibrary_AngleBetweenInRadians::V0' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_AngleBetweenInRadians, V1) == 0x00000C, "Member 'OrionKismetLibrary_AngleBetweenInRadians::V1' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_AngleBetweenInRadians, ReturnValue) == 0x000018, "Member 'OrionKismetLibrary_AngleBetweenInRadians::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.AnnouncerSayDialog
// 0x0020 (0x0020 - 0x0000)
struct OrionKismetLibrary_AnnouncerSayDialog final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SoundInstigator;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Ident;                                             // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_AnnouncerSayDialog) == 0x000008, "Wrong alignment on OrionKismetLibrary_AnnouncerSayDialog");
static_assert(sizeof(OrionKismetLibrary_AnnouncerSayDialog) == 0x000020, "Wrong size on OrionKismetLibrary_AnnouncerSayDialog");
static_assert(offsetof(OrionKismetLibrary_AnnouncerSayDialog, WorldContextObject) == 0x000000, "Member 'OrionKismetLibrary_AnnouncerSayDialog::WorldContextObject' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_AnnouncerSayDialog, SoundInstigator) == 0x000008, "Member 'OrionKismetLibrary_AnnouncerSayDialog::SoundInstigator' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_AnnouncerSayDialog, Ident) == 0x000010, "Member 'OrionKismetLibrary_AnnouncerSayDialog::Ident' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.ApplyAbilityTagsToSpecFilterContainer
// 0x0028 (0x0028 - 0x0000)
struct OrionKismetLibrary_ApplyAbilityTagsToSpecFilterContainer final
{
public:
	struct FOrionFilterAndEffectsContainer        FilterContainer;                                   // 0x0000(0x0020)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UGameplayAbility*                       Ability;                                           // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_ApplyAbilityTagsToSpecFilterContainer) == 0x000008, "Wrong alignment on OrionKismetLibrary_ApplyAbilityTagsToSpecFilterContainer");
static_assert(sizeof(OrionKismetLibrary_ApplyAbilityTagsToSpecFilterContainer) == 0x000028, "Wrong size on OrionKismetLibrary_ApplyAbilityTagsToSpecFilterContainer");
static_assert(offsetof(OrionKismetLibrary_ApplyAbilityTagsToSpecFilterContainer, FilterContainer) == 0x000000, "Member 'OrionKismetLibrary_ApplyAbilityTagsToSpecFilterContainer::FilterContainer' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_ApplyAbilityTagsToSpecFilterContainer, Ability) == 0x000020, "Member 'OrionKismetLibrary_ApplyAbilityTagsToSpecFilterContainer::Ability' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.ApplyGameplayEffectsToTarget
// 0x0030 (0x0030 - 0x0000)
struct OrionKismetLibrary_ApplyGameplayEffectsToTarget final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayEffectSpecHandle>      EffectSpecHandlesToApply;                          // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FActiveGameplayEffectHandle>    AppliedEffectHandles;                              // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_ApplyGameplayEffectsToTarget) == 0x000008, "Wrong alignment on OrionKismetLibrary_ApplyGameplayEffectsToTarget");
static_assert(sizeof(OrionKismetLibrary_ApplyGameplayEffectsToTarget) == 0x000030, "Wrong size on OrionKismetLibrary_ApplyGameplayEffectsToTarget");
static_assert(offsetof(OrionKismetLibrary_ApplyGameplayEffectsToTarget, TargetActor) == 0x000000, "Member 'OrionKismetLibrary_ApplyGameplayEffectsToTarget::TargetActor' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_ApplyGameplayEffectsToTarget, EffectSpecHandlesToApply) == 0x000008, "Member 'OrionKismetLibrary_ApplyGameplayEffectsToTarget::EffectSpecHandlesToApply' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_ApplyGameplayEffectsToTarget, AppliedEffectHandles) == 0x000018, "Member 'OrionKismetLibrary_ApplyGameplayEffectsToTarget::AppliedEffectHandles' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_ApplyGameplayEffectsToTarget, ReturnValue) == 0x000028, "Member 'OrionKismetLibrary_ApplyGameplayEffectsToTarget::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.ApplyGameplayEffectsToTargetData
// 0x0050 (0x0050 - 0x0000)
struct OrionKismetLibrary_ApplyGameplayEffectsToTargetData final
{
public:
	struct FOrionFilterAndEffectsContainer        FilterContainer;                                   // 0x0000(0x0020)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0020(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FActiveGameplayEffectHandle>    AppliedEffectHandles;                              // 0x0040(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_ApplyGameplayEffectsToTargetData) == 0x000008, "Wrong alignment on OrionKismetLibrary_ApplyGameplayEffectsToTargetData");
static_assert(sizeof(OrionKismetLibrary_ApplyGameplayEffectsToTargetData) == 0x000050, "Wrong size on OrionKismetLibrary_ApplyGameplayEffectsToTargetData");
static_assert(offsetof(OrionKismetLibrary_ApplyGameplayEffectsToTargetData, FilterContainer) == 0x000000, "Member 'OrionKismetLibrary_ApplyGameplayEffectsToTargetData::FilterContainer' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_ApplyGameplayEffectsToTargetData, TargetData) == 0x000020, "Member 'OrionKismetLibrary_ApplyGameplayEffectsToTargetData::TargetData' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_ApplyGameplayEffectsToTargetData, AppliedEffectHandles) == 0x000040, "Member 'OrionKismetLibrary_ApplyGameplayEffectsToTargetData::AppliedEffectHandles' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.CanActorSeeTargetInShadowPlane
// 0x0018 (0x0018 - 0x0000)
struct OrionKismetLibrary_CanActorSeeTargetInShadowPlane final
{
public:
	const class AActor*                           Source;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           Target;                                            // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_CanActorSeeTargetInShadowPlane) == 0x000008, "Wrong alignment on OrionKismetLibrary_CanActorSeeTargetInShadowPlane");
static_assert(sizeof(OrionKismetLibrary_CanActorSeeTargetInShadowPlane) == 0x000018, "Wrong size on OrionKismetLibrary_CanActorSeeTargetInShadowPlane");
static_assert(offsetof(OrionKismetLibrary_CanActorSeeTargetInShadowPlane, Source) == 0x000000, "Member 'OrionKismetLibrary_CanActorSeeTargetInShadowPlane::Source' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_CanActorSeeTargetInShadowPlane, Target) == 0x000008, "Member 'OrionKismetLibrary_CanActorSeeTargetInShadowPlane::Target' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_CanActorSeeTargetInShadowPlane, ReturnValue) == 0x000010, "Member 'OrionKismetLibrary_CanActorSeeTargetInShadowPlane::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.CanPerformRendering
// 0x0001 (0x0001 - 0x0000)
struct OrionKismetLibrary_CanPerformRendering final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_CanPerformRendering) == 0x000001, "Wrong alignment on OrionKismetLibrary_CanPerformRendering");
static_assert(sizeof(OrionKismetLibrary_CanPerformRendering) == 0x000001, "Wrong size on OrionKismetLibrary_CanPerformRendering");
static_assert(offsetof(OrionKismetLibrary_CanPerformRendering, ReturnValue) == 0x000000, "Member 'OrionKismetLibrary_CanPerformRendering::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.CanSeeInZoneVisionMask
// 0x0018 (0x0018 - 0x0000)
struct OrionKismetLibrary_CanSeeInZoneVisionMask final
{
public:
	uint8                                         CanSeeZoneVisionMask;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Target;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_CanSeeInZoneVisionMask) == 0x000008, "Wrong alignment on OrionKismetLibrary_CanSeeInZoneVisionMask");
static_assert(sizeof(OrionKismetLibrary_CanSeeInZoneVisionMask) == 0x000018, "Wrong size on OrionKismetLibrary_CanSeeInZoneVisionMask");
static_assert(offsetof(OrionKismetLibrary_CanSeeInZoneVisionMask, CanSeeZoneVisionMask) == 0x000000, "Member 'OrionKismetLibrary_CanSeeInZoneVisionMask::CanSeeZoneVisionMask' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_CanSeeInZoneVisionMask, Target) == 0x000008, "Member 'OrionKismetLibrary_CanSeeInZoneVisionMask::Target' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_CanSeeInZoneVisionMask, ReturnValue) == 0x000010, "Member 'OrionKismetLibrary_CanSeeInZoneVisionMask::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.ChangeTeamChar
// 0x0010 (0x0010 - 0x0000)
struct OrionKismetLibrary_ChangeTeamChar final
{
public:
	class AOrionChar*                             OrionChar;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    NewTeam;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_ChangeTeamChar) == 0x000008, "Wrong alignment on OrionKismetLibrary_ChangeTeamChar");
static_assert(sizeof(OrionKismetLibrary_ChangeTeamChar) == 0x000010, "Wrong size on OrionKismetLibrary_ChangeTeamChar");
static_assert(offsetof(OrionKismetLibrary_ChangeTeamChar, OrionChar) == 0x000000, "Member 'OrionKismetLibrary_ChangeTeamChar::OrionChar' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_ChangeTeamChar, NewTeam) == 0x000008, "Member 'OrionKismetLibrary_ChangeTeamChar::NewTeam' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.ChangeTeamController
// 0x0010 (0x0010 - 0x0000)
struct OrionKismetLibrary_ChangeTeamController final
{
public:
	class AController*                            Controller;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    NewTeam;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_ChangeTeamController) == 0x000008, "Wrong alignment on OrionKismetLibrary_ChangeTeamController");
static_assert(sizeof(OrionKismetLibrary_ChangeTeamController) == 0x000010, "Wrong size on OrionKismetLibrary_ChangeTeamController");
static_assert(offsetof(OrionKismetLibrary_ChangeTeamController, Controller) == 0x000000, "Member 'OrionKismetLibrary_ChangeTeamController::Controller' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_ChangeTeamController, NewTeam) == 0x000008, "Member 'OrionKismetLibrary_ChangeTeamController::NewTeam' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.CheckCVarInt
// 0x0018 (0x0018 - 0x0000)
struct OrionKismetLibrary_CheckCVarInt final
{
public:
	class FString                                 CVarString;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_CheckCVarInt) == 0x000008, "Wrong alignment on OrionKismetLibrary_CheckCVarInt");
static_assert(sizeof(OrionKismetLibrary_CheckCVarInt) == 0x000018, "Wrong size on OrionKismetLibrary_CheckCVarInt");
static_assert(offsetof(OrionKismetLibrary_CheckCVarInt, CVarString) == 0x000000, "Member 'OrionKismetLibrary_CheckCVarInt::CVarString' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_CheckCVarInt, ReturnValue) == 0x000010, "Member 'OrionKismetLibrary_CheckCVarInt::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.CloneEffectSpecsForFilters
// 0x0058 (0x0058 - 0x0000)
struct OrionKismetLibrary_CloneEffectSpecsForFilters final
{
public:
	struct FOrionFilterAndEffectsContainer        FilterContainer;                                   // 0x0000(0x0020)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 InNewInstigator;                                   // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InNewSourceActor;                                  // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionFilterAndEffectsContainer        FilterToClone;                                     // 0x0030(0x0020)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0050(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_CloneEffectSpecsForFilters) == 0x000008, "Wrong alignment on OrionKismetLibrary_CloneEffectSpecsForFilters");
static_assert(sizeof(OrionKismetLibrary_CloneEffectSpecsForFilters) == 0x000058, "Wrong size on OrionKismetLibrary_CloneEffectSpecsForFilters");
static_assert(offsetof(OrionKismetLibrary_CloneEffectSpecsForFilters, FilterContainer) == 0x000000, "Member 'OrionKismetLibrary_CloneEffectSpecsForFilters::FilterContainer' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_CloneEffectSpecsForFilters, InNewInstigator) == 0x000020, "Member 'OrionKismetLibrary_CloneEffectSpecsForFilters::InNewInstigator' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_CloneEffectSpecsForFilters, InNewSourceActor) == 0x000028, "Member 'OrionKismetLibrary_CloneEffectSpecsForFilters::InNewSourceActor' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_CloneEffectSpecsForFilters, FilterToClone) == 0x000030, "Member 'OrionKismetLibrary_CloneEffectSpecsForFilters::FilterToClone' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_CloneEffectSpecsForFilters, ReturnValue) == 0x000050, "Member 'OrionKismetLibrary_CloneEffectSpecsForFilters::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.ClosestPointOnLineToLine
// 0x003C (0x003C - 0x0000)
struct OrionKismetLibrary_ClosestPointOnLineToLine final
{
public:
	struct FVector                                A0;                                                // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                A1;                                                // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B0;                                                // 0x0018(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B1;                                                // 0x0024(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0030(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_ClosestPointOnLineToLine) == 0x000004, "Wrong alignment on OrionKismetLibrary_ClosestPointOnLineToLine");
static_assert(sizeof(OrionKismetLibrary_ClosestPointOnLineToLine) == 0x00003C, "Wrong size on OrionKismetLibrary_ClosestPointOnLineToLine");
static_assert(offsetof(OrionKismetLibrary_ClosestPointOnLineToLine, A0) == 0x000000, "Member 'OrionKismetLibrary_ClosestPointOnLineToLine::A0' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_ClosestPointOnLineToLine, A1) == 0x00000C, "Member 'OrionKismetLibrary_ClosestPointOnLineToLine::A1' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_ClosestPointOnLineToLine, B0) == 0x000018, "Member 'OrionKismetLibrary_ClosestPointOnLineToLine::B0' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_ClosestPointOnLineToLine, B1) == 0x000024, "Member 'OrionKismetLibrary_ClosestPointOnLineToLine::B1' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_ClosestPointOnLineToLine, ReturnValue) == 0x000030, "Member 'OrionKismetLibrary_ClosestPointOnLineToLine::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.ClosestPointOnSegmentToLine
// 0x003C (0x003C - 0x0000)
struct OrionKismetLibrary_ClosestPointOnSegmentToLine final
{
public:
	struct FVector                                SegmentP0;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SegmentP1;                                         // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LineP0;                                            // 0x0018(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LineP1;                                            // 0x0024(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0030(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_ClosestPointOnSegmentToLine) == 0x000004, "Wrong alignment on OrionKismetLibrary_ClosestPointOnSegmentToLine");
static_assert(sizeof(OrionKismetLibrary_ClosestPointOnSegmentToLine) == 0x00003C, "Wrong size on OrionKismetLibrary_ClosestPointOnSegmentToLine");
static_assert(offsetof(OrionKismetLibrary_ClosestPointOnSegmentToLine, SegmentP0) == 0x000000, "Member 'OrionKismetLibrary_ClosestPointOnSegmentToLine::SegmentP0' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_ClosestPointOnSegmentToLine, SegmentP1) == 0x00000C, "Member 'OrionKismetLibrary_ClosestPointOnSegmentToLine::SegmentP1' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_ClosestPointOnSegmentToLine, LineP0) == 0x000018, "Member 'OrionKismetLibrary_ClosestPointOnSegmentToLine::LineP0' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_ClosestPointOnSegmentToLine, LineP1) == 0x000024, "Member 'OrionKismetLibrary_ClosestPointOnSegmentToLine::LineP1' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_ClosestPointOnSegmentToLine, ReturnValue) == 0x000030, "Member 'OrionKismetLibrary_ClosestPointOnSegmentToLine::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.ClosestPointOnSegmentToPlane
// 0x0040 (0x0040 - 0x0000)
struct OrionKismetLibrary_ClosestPointOnSegmentToPlane final
{
public:
	struct FVector                                SegmentP0;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SegmentP1;                                         // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlane                                 Plane;                                             // 0x0020(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0030(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_ClosestPointOnSegmentToPlane) == 0x000010, "Wrong alignment on OrionKismetLibrary_ClosestPointOnSegmentToPlane");
static_assert(sizeof(OrionKismetLibrary_ClosestPointOnSegmentToPlane) == 0x000040, "Wrong size on OrionKismetLibrary_ClosestPointOnSegmentToPlane");
static_assert(offsetof(OrionKismetLibrary_ClosestPointOnSegmentToPlane, SegmentP0) == 0x000000, "Member 'OrionKismetLibrary_ClosestPointOnSegmentToPlane::SegmentP0' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_ClosestPointOnSegmentToPlane, SegmentP1) == 0x00000C, "Member 'OrionKismetLibrary_ClosestPointOnSegmentToPlane::SegmentP1' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_ClosestPointOnSegmentToPlane, Plane) == 0x000020, "Member 'OrionKismetLibrary_ClosestPointOnSegmentToPlane::Plane' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_ClosestPointOnSegmentToPlane, ReturnValue) == 0x000030, "Member 'OrionKismetLibrary_ClosestPointOnSegmentToPlane::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.ClosestPointsOnSegmentToSegment
// 0x0048 (0x0048 - 0x0000)
struct OrionKismetLibrary_ClosestPointsOnSegmentToSegment final
{
public:
	struct FVector                                A0;                                                // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                A1;                                                // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B0;                                                // 0x0018(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B1;                                                // 0x0024(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutA;                                              // 0x0030(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutB;                                              // 0x003C(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_ClosestPointsOnSegmentToSegment) == 0x000004, "Wrong alignment on OrionKismetLibrary_ClosestPointsOnSegmentToSegment");
static_assert(sizeof(OrionKismetLibrary_ClosestPointsOnSegmentToSegment) == 0x000048, "Wrong size on OrionKismetLibrary_ClosestPointsOnSegmentToSegment");
static_assert(offsetof(OrionKismetLibrary_ClosestPointsOnSegmentToSegment, A0) == 0x000000, "Member 'OrionKismetLibrary_ClosestPointsOnSegmentToSegment::A0' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_ClosestPointsOnSegmentToSegment, A1) == 0x00000C, "Member 'OrionKismetLibrary_ClosestPointsOnSegmentToSegment::A1' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_ClosestPointsOnSegmentToSegment, B0) == 0x000018, "Member 'OrionKismetLibrary_ClosestPointsOnSegmentToSegment::B0' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_ClosestPointsOnSegmentToSegment, B1) == 0x000024, "Member 'OrionKismetLibrary_ClosestPointsOnSegmentToSegment::B1' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_ClosestPointsOnSegmentToSegment, OutA) == 0x000030, "Member 'OrionKismetLibrary_ClosestPointsOnSegmentToSegment::OutA' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_ClosestPointsOnSegmentToSegment, OutB) == 0x00003C, "Member 'OrionKismetLibrary_ClosestPointsOnSegmentToSegment::OutB' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.CompareActorTeams
// 0x0018 (0x0018 - 0x0000)
struct OrionKismetLibrary_CompareActorTeams final
{
public:
	const class AActor*                           A;                                                 // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           B;                                                 // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeamCompare                             CompareType;                                       // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0011(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_CompareActorTeams) == 0x000008, "Wrong alignment on OrionKismetLibrary_CompareActorTeams");
static_assert(sizeof(OrionKismetLibrary_CompareActorTeams) == 0x000018, "Wrong size on OrionKismetLibrary_CompareActorTeams");
static_assert(offsetof(OrionKismetLibrary_CompareActorTeams, A) == 0x000000, "Member 'OrionKismetLibrary_CompareActorTeams::A' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_CompareActorTeams, B) == 0x000008, "Member 'OrionKismetLibrary_CompareActorTeams::B' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_CompareActorTeams, CompareType) == 0x000010, "Member 'OrionKismetLibrary_CompareActorTeams::CompareType' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_CompareActorTeams, ReturnValue) == 0x000011, "Member 'OrionKismetLibrary_CompareActorTeams::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.CompareTeams
// 0x0004 (0x0004 - 0x0000)
struct OrionKismetLibrary_CompareTeams final
{
public:
	EOrionTeam                                    TeamA;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    TeamB;                                             // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeamCompare                             CompareType;                                       // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0003(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_CompareTeams) == 0x000001, "Wrong alignment on OrionKismetLibrary_CompareTeams");
static_assert(sizeof(OrionKismetLibrary_CompareTeams) == 0x000004, "Wrong size on OrionKismetLibrary_CompareTeams");
static_assert(offsetof(OrionKismetLibrary_CompareTeams, TeamA) == 0x000000, "Member 'OrionKismetLibrary_CompareTeams::TeamA' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_CompareTeams, TeamB) == 0x000001, "Member 'OrionKismetLibrary_CompareTeams::TeamB' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_CompareTeams, CompareType) == 0x000002, "Member 'OrionKismetLibrary_CompareTeams::CompareType' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_CompareTeams, ReturnValue) == 0x000003, "Member 'OrionKismetLibrary_CompareTeams::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.DebugCapsuleSendToAll
// 0x0050 (0x0050 - 0x0000)
struct OrionKismetLibrary_DebugCapsuleSendToAll final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Center;                                            // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfHeight;                                        // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Rotation;                                          // 0x0020(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0030(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x0034(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x003C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0xC];                                       // 0x0044(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_DebugCapsuleSendToAll) == 0x000010, "Wrong alignment on OrionKismetLibrary_DebugCapsuleSendToAll");
static_assert(sizeof(OrionKismetLibrary_DebugCapsuleSendToAll) == 0x000050, "Wrong size on OrionKismetLibrary_DebugCapsuleSendToAll");
static_assert(offsetof(OrionKismetLibrary_DebugCapsuleSendToAll, WorldContextObject) == 0x000000, "Member 'OrionKismetLibrary_DebugCapsuleSendToAll::WorldContextObject' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_DebugCapsuleSendToAll, Center) == 0x000008, "Member 'OrionKismetLibrary_DebugCapsuleSendToAll::Center' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_DebugCapsuleSendToAll, HalfHeight) == 0x000014, "Member 'OrionKismetLibrary_DebugCapsuleSendToAll::HalfHeight' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_DebugCapsuleSendToAll, Radius) == 0x000018, "Member 'OrionKismetLibrary_DebugCapsuleSendToAll::Radius' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_DebugCapsuleSendToAll, Rotation) == 0x000020, "Member 'OrionKismetLibrary_DebugCapsuleSendToAll::Rotation' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_DebugCapsuleSendToAll, Color) == 0x000030, "Member 'OrionKismetLibrary_DebugCapsuleSendToAll::Color' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_DebugCapsuleSendToAll, bPersistentLines) == 0x000034, "Member 'OrionKismetLibrary_DebugCapsuleSendToAll::bPersistentLines' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_DebugCapsuleSendToAll, LifeTime) == 0x000038, "Member 'OrionKismetLibrary_DebugCapsuleSendToAll::LifeTime' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_DebugCapsuleSendToAll, DepthPriority) == 0x00003C, "Member 'OrionKismetLibrary_DebugCapsuleSendToAll::DepthPriority' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_DebugCapsuleSendToAll, Thickness) == 0x000040, "Member 'OrionKismetLibrary_DebugCapsuleSendToAll::Thickness' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.DebugLineSendToAll
// 0x0038 (0x0038 - 0x0000)
struct OrionKismetLibrary_DebugLineSendToAll final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LineStart;                                         // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LineEnd;                                           // 0x0014(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0020(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x0024(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x002C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_DebugLineSendToAll) == 0x000008, "Wrong alignment on OrionKismetLibrary_DebugLineSendToAll");
static_assert(sizeof(OrionKismetLibrary_DebugLineSendToAll) == 0x000038, "Wrong size on OrionKismetLibrary_DebugLineSendToAll");
static_assert(offsetof(OrionKismetLibrary_DebugLineSendToAll, WorldContextObject) == 0x000000, "Member 'OrionKismetLibrary_DebugLineSendToAll::WorldContextObject' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_DebugLineSendToAll, LineStart) == 0x000008, "Member 'OrionKismetLibrary_DebugLineSendToAll::LineStart' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_DebugLineSendToAll, LineEnd) == 0x000014, "Member 'OrionKismetLibrary_DebugLineSendToAll::LineEnd' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_DebugLineSendToAll, Color) == 0x000020, "Member 'OrionKismetLibrary_DebugLineSendToAll::Color' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_DebugLineSendToAll, bPersistentLines) == 0x000024, "Member 'OrionKismetLibrary_DebugLineSendToAll::bPersistentLines' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_DebugLineSendToAll, LifeTime) == 0x000028, "Member 'OrionKismetLibrary_DebugLineSendToAll::LifeTime' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_DebugLineSendToAll, DepthPriority) == 0x00002C, "Member 'OrionKismetLibrary_DebugLineSendToAll::DepthPriority' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_DebugLineSendToAll, Thickness) == 0x000030, "Member 'OrionKismetLibrary_DebugLineSendToAll::Thickness' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.DebugSphereSendToAll
// 0x0030 (0x0030 - 0x0000)
struct OrionKismetLibrary_DebugSphereSendToAll final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Center;                                            // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Segments;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x001C(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_DebugSphereSendToAll) == 0x000008, "Wrong alignment on OrionKismetLibrary_DebugSphereSendToAll");
static_assert(sizeof(OrionKismetLibrary_DebugSphereSendToAll) == 0x000030, "Wrong size on OrionKismetLibrary_DebugSphereSendToAll");
static_assert(offsetof(OrionKismetLibrary_DebugSphereSendToAll, WorldContextObject) == 0x000000, "Member 'OrionKismetLibrary_DebugSphereSendToAll::WorldContextObject' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_DebugSphereSendToAll, Center) == 0x000008, "Member 'OrionKismetLibrary_DebugSphereSendToAll::Center' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_DebugSphereSendToAll, Radius) == 0x000014, "Member 'OrionKismetLibrary_DebugSphereSendToAll::Radius' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_DebugSphereSendToAll, Segments) == 0x000018, "Member 'OrionKismetLibrary_DebugSphereSendToAll::Segments' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_DebugSphereSendToAll, Color) == 0x00001C, "Member 'OrionKismetLibrary_DebugSphereSendToAll::Color' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_DebugSphereSendToAll, bPersistentLines) == 0x000020, "Member 'OrionKismetLibrary_DebugSphereSendToAll::bPersistentLines' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_DebugSphereSendToAll, LifeTime) == 0x000024, "Member 'OrionKismetLibrary_DebugSphereSendToAll::LifeTime' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_DebugSphereSendToAll, DepthPriority) == 0x000028, "Member 'OrionKismetLibrary_DebugSphereSendToAll::DepthPriority' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_DebugSphereSendToAll, Thickness) == 0x00002C, "Member 'OrionKismetLibrary_DebugSphereSendToAll::Thickness' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.DistanceSquaredBetweenSegments
// 0x0034 (0x0034 - 0x0000)
struct OrionKismetLibrary_DistanceSquaredBetweenSegments final
{
public:
	struct FVector                                A0;                                                // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                A1;                                                // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B0;                                                // 0x0018(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B1;                                                // 0x0024(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0030(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_DistanceSquaredBetweenSegments) == 0x000004, "Wrong alignment on OrionKismetLibrary_DistanceSquaredBetweenSegments");
static_assert(sizeof(OrionKismetLibrary_DistanceSquaredBetweenSegments) == 0x000034, "Wrong size on OrionKismetLibrary_DistanceSquaredBetweenSegments");
static_assert(offsetof(OrionKismetLibrary_DistanceSquaredBetweenSegments, A0) == 0x000000, "Member 'OrionKismetLibrary_DistanceSquaredBetweenSegments::A0' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_DistanceSquaredBetweenSegments, A1) == 0x00000C, "Member 'OrionKismetLibrary_DistanceSquaredBetweenSegments::A1' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_DistanceSquaredBetweenSegments, B0) == 0x000018, "Member 'OrionKismetLibrary_DistanceSquaredBetweenSegments::B0' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_DistanceSquaredBetweenSegments, B1) == 0x000024, "Member 'OrionKismetLibrary_DistanceSquaredBetweenSegments::B1' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_DistanceSquaredBetweenSegments, ReturnValue) == 0x000030, "Member 'OrionKismetLibrary_DistanceSquaredBetweenSegments::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.DoesActorHaveVisionOnTarget
// 0x0018 (0x0018 - 0x0000)
struct OrionKismetLibrary_DoesActorHaveVisionOnTarget final
{
public:
	const class AActor*                           Source;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           Target;                                            // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_DoesActorHaveVisionOnTarget) == 0x000008, "Wrong alignment on OrionKismetLibrary_DoesActorHaveVisionOnTarget");
static_assert(sizeof(OrionKismetLibrary_DoesActorHaveVisionOnTarget) == 0x000018, "Wrong size on OrionKismetLibrary_DoesActorHaveVisionOnTarget");
static_assert(offsetof(OrionKismetLibrary_DoesActorHaveVisionOnTarget, Source) == 0x000000, "Member 'OrionKismetLibrary_DoesActorHaveVisionOnTarget::Source' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_DoesActorHaveVisionOnTarget, Target) == 0x000008, "Member 'OrionKismetLibrary_DoesActorHaveVisionOnTarget::Target' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_DoesActorHaveVisionOnTarget, ReturnValue) == 0x000010, "Member 'OrionKismetLibrary_DoesActorHaveVisionOnTarget::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.DoesTeamHaveVisionOnTarget
// 0x0018 (0x0018 - 0x0000)
struct OrionKismetLibrary_DoesTeamHaveVisionOnTarget final
{
public:
	EOrionTeam                                    Team;                                              // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class AActor*                           Target;                                            // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_DoesTeamHaveVisionOnTarget) == 0x000008, "Wrong alignment on OrionKismetLibrary_DoesTeamHaveVisionOnTarget");
static_assert(sizeof(OrionKismetLibrary_DoesTeamHaveVisionOnTarget) == 0x000018, "Wrong size on OrionKismetLibrary_DoesTeamHaveVisionOnTarget");
static_assert(offsetof(OrionKismetLibrary_DoesTeamHaveVisionOnTarget, Team) == 0x000000, "Member 'OrionKismetLibrary_DoesTeamHaveVisionOnTarget::Team' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_DoesTeamHaveVisionOnTarget, Target) == 0x000008, "Member 'OrionKismetLibrary_DoesTeamHaveVisionOnTarget::Target' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_DoesTeamHaveVisionOnTarget, ReturnValue) == 0x000010, "Member 'OrionKismetLibrary_DoesTeamHaveVisionOnTarget::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.DoVisionTestBetweenActors
// 0x0020 (0x0020 - 0x0000)
struct OrionKismetLibrary_DoVisionTestBetweenActors final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Viewer;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CheckMask;                                         // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timeout;                                           // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_DoVisionTestBetweenActors) == 0x000008, "Wrong alignment on OrionKismetLibrary_DoVisionTestBetweenActors");
static_assert(sizeof(OrionKismetLibrary_DoVisionTestBetweenActors) == 0x000020, "Wrong size on OrionKismetLibrary_DoVisionTestBetweenActors");
static_assert(offsetof(OrionKismetLibrary_DoVisionTestBetweenActors, Target) == 0x000000, "Member 'OrionKismetLibrary_DoVisionTestBetweenActors::Target' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_DoVisionTestBetweenActors, Viewer) == 0x000008, "Member 'OrionKismetLibrary_DoVisionTestBetweenActors::Viewer' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_DoVisionTestBetweenActors, CheckMask) == 0x000010, "Member 'OrionKismetLibrary_DoVisionTestBetweenActors::CheckMask' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_DoVisionTestBetweenActors, Timeout) == 0x000014, "Member 'OrionKismetLibrary_DoVisionTestBetweenActors::Timeout' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_DoVisionTestBetweenActors, ReturnValue) == 0x000018, "Member 'OrionKismetLibrary_DoVisionTestBetweenActors::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.EqualEqual_ActiveGameplayEffectHandle
// 0x0014 (0x0014 - 0x0000)
struct OrionKismetLibrary_EqualEqual_ActiveGameplayEffectHandle final
{
public:
	struct FActiveGameplayEffectHandle            ActiveGameplayEffectHandleA;                       // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            ActiveGameplayEffectHandleB;                       // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_EqualEqual_ActiveGameplayEffectHandle) == 0x000004, "Wrong alignment on OrionKismetLibrary_EqualEqual_ActiveGameplayEffectHandle");
static_assert(sizeof(OrionKismetLibrary_EqualEqual_ActiveGameplayEffectHandle) == 0x000014, "Wrong size on OrionKismetLibrary_EqualEqual_ActiveGameplayEffectHandle");
static_assert(offsetof(OrionKismetLibrary_EqualEqual_ActiveGameplayEffectHandle, ActiveGameplayEffectHandleA) == 0x000000, "Member 'OrionKismetLibrary_EqualEqual_ActiveGameplayEffectHandle::ActiveGameplayEffectHandleA' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_EqualEqual_ActiveGameplayEffectHandle, ActiveGameplayEffectHandleB) == 0x000008, "Member 'OrionKismetLibrary_EqualEqual_ActiveGameplayEffectHandle::ActiveGameplayEffectHandleB' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_EqualEqual_ActiveGameplayEffectHandle, ReturnValue) == 0x000010, "Member 'OrionKismetLibrary_EqualEqual_ActiveGameplayEffectHandle::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.EvaluateCurveTableRowHandle
// 0x0030 (0x0030 - 0x0000)
struct OrionKismetLibrary_EvaluateCurveTableRowHandle final
{
public:
	struct FCurveTableRowHandle                   RowHandle;                                         // 0x0000(0x0010)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InXY;                                              // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEvaluateCurveTableResult                     OutResult;                                         // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OutXY;                                             // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ContextString;                                     // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_EvaluateCurveTableRowHandle) == 0x000008, "Wrong alignment on OrionKismetLibrary_EvaluateCurveTableRowHandle");
static_assert(sizeof(OrionKismetLibrary_EvaluateCurveTableRowHandle) == 0x000030, "Wrong size on OrionKismetLibrary_EvaluateCurveTableRowHandle");
static_assert(offsetof(OrionKismetLibrary_EvaluateCurveTableRowHandle, RowHandle) == 0x000000, "Member 'OrionKismetLibrary_EvaluateCurveTableRowHandle::RowHandle' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_EvaluateCurveTableRowHandle, InXY) == 0x000010, "Member 'OrionKismetLibrary_EvaluateCurveTableRowHandle::InXY' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_EvaluateCurveTableRowHandle, OutResult) == 0x000014, "Member 'OrionKismetLibrary_EvaluateCurveTableRowHandle::OutResult' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_EvaluateCurveTableRowHandle, OutXY) == 0x000018, "Member 'OrionKismetLibrary_EvaluateCurveTableRowHandle::OutXY' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_EvaluateCurveTableRowHandle, ContextString) == 0x000020, "Member 'OrionKismetLibrary_EvaluateCurveTableRowHandle::ContextString' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.FilterActor
// 0x0078 (0x0078 - 0x0000)
struct OrionKismetLibrary_FilterActor final
{
public:
	struct FOrionActorFilter                      Filter;                                            // 0x0000(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	const class AActor*                           Source;                                            // 0x0060(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           Target;                                            // 0x0068(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0070(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_FilterActor) == 0x000008, "Wrong alignment on OrionKismetLibrary_FilterActor");
static_assert(sizeof(OrionKismetLibrary_FilterActor) == 0x000078, "Wrong size on OrionKismetLibrary_FilterActor");
static_assert(offsetof(OrionKismetLibrary_FilterActor, Filter) == 0x000000, "Member 'OrionKismetLibrary_FilterActor::Filter' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_FilterActor, Source) == 0x000060, "Member 'OrionKismetLibrary_FilterActor::Source' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_FilterActor, Target) == 0x000068, "Member 'OrionKismetLibrary_FilterActor::Target' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_FilterActor, ReturnValue) == 0x000070, "Member 'OrionKismetLibrary_FilterActor::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.FindPlayerStart
// 0x0028 (0x0028 - 0x0000)
struct OrionKismetLibrary_FindPlayerStart final
{
public:
	class AController*                            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 StartPointActor;                                   // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartPointLocation;                                // 0x0010(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               StartPointRotation;                                // 0x001C(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_FindPlayerStart) == 0x000008, "Wrong alignment on OrionKismetLibrary_FindPlayerStart");
static_assert(sizeof(OrionKismetLibrary_FindPlayerStart) == 0x000028, "Wrong size on OrionKismetLibrary_FindPlayerStart");
static_assert(offsetof(OrionKismetLibrary_FindPlayerStart, PlayerController) == 0x000000, "Member 'OrionKismetLibrary_FindPlayerStart::PlayerController' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_FindPlayerStart, StartPointActor) == 0x000008, "Member 'OrionKismetLibrary_FindPlayerStart::StartPointActor' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_FindPlayerStart, StartPointLocation) == 0x000010, "Member 'OrionKismetLibrary_FindPlayerStart::StartPointLocation' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_FindPlayerStart, StartPointRotation) == 0x00001C, "Member 'OrionKismetLibrary_FindPlayerStart::StartPointRotation' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GameplayCue_ApplyDecal
// 0x0010 (0x0010 - 0x0000)
struct OrionKismetLibrary_GameplayCue_ApplyDecal final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DecalName;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_GameplayCue_ApplyDecal) == 0x000008, "Wrong alignment on OrionKismetLibrary_GameplayCue_ApplyDecal");
static_assert(sizeof(OrionKismetLibrary_GameplayCue_ApplyDecal) == 0x000010, "Wrong size on OrionKismetLibrary_GameplayCue_ApplyDecal");
static_assert(offsetof(OrionKismetLibrary_GameplayCue_ApplyDecal, Actor) == 0x000000, "Member 'OrionKismetLibrary_GameplayCue_ApplyDecal::Actor' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GameplayCue_ApplyDecal, DecalName) == 0x000008, "Member 'OrionKismetLibrary_GameplayCue_ApplyDecal::DecalName' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GameplayCue_ApplyDecalForDuration
// 0x0018 (0x0018 - 0x0000)
struct OrionKismetLibrary_GameplayCue_ApplyDecalForDuration final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DecalName;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_GameplayCue_ApplyDecalForDuration) == 0x000008, "Wrong alignment on OrionKismetLibrary_GameplayCue_ApplyDecalForDuration");
static_assert(sizeof(OrionKismetLibrary_GameplayCue_ApplyDecalForDuration) == 0x000018, "Wrong size on OrionKismetLibrary_GameplayCue_ApplyDecalForDuration");
static_assert(offsetof(OrionKismetLibrary_GameplayCue_ApplyDecalForDuration, Actor) == 0x000000, "Member 'OrionKismetLibrary_GameplayCue_ApplyDecalForDuration::Actor' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GameplayCue_ApplyDecalForDuration, DecalName) == 0x000008, "Member 'OrionKismetLibrary_GameplayCue_ApplyDecalForDuration::DecalName' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GameplayCue_ApplyDecalForDuration, Duration) == 0x000010, "Member 'OrionKismetLibrary_GameplayCue_ApplyDecalForDuration::Duration' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GameplayCue_PlaySoundTeamAdjustedForSource
// 0x00D8 (0x00D8 - 0x0000)
struct OrionKismetLibrary_GameplayCue_PlaySoundTeamAdjustedForSource final
{
public:
	class USoundBase*                             SoundToPlay;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 MyTarget;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 Parameters;                                        // 0x0010(0x00B8)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          Attached;                                          // 0x00C8(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopWhenAttachedToDestroyed;                      // 0x00C9(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA[0x6];                                       // 0x00CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        ReturnValue;                                       // 0x00D0(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_GameplayCue_PlaySoundTeamAdjustedForSource) == 0x000008, "Wrong alignment on OrionKismetLibrary_GameplayCue_PlaySoundTeamAdjustedForSource");
static_assert(sizeof(OrionKismetLibrary_GameplayCue_PlaySoundTeamAdjustedForSource) == 0x0000D8, "Wrong size on OrionKismetLibrary_GameplayCue_PlaySoundTeamAdjustedForSource");
static_assert(offsetof(OrionKismetLibrary_GameplayCue_PlaySoundTeamAdjustedForSource, SoundToPlay) == 0x000000, "Member 'OrionKismetLibrary_GameplayCue_PlaySoundTeamAdjustedForSource::SoundToPlay' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GameplayCue_PlaySoundTeamAdjustedForSource, MyTarget) == 0x000008, "Member 'OrionKismetLibrary_GameplayCue_PlaySoundTeamAdjustedForSource::MyTarget' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GameplayCue_PlaySoundTeamAdjustedForSource, Parameters) == 0x000010, "Member 'OrionKismetLibrary_GameplayCue_PlaySoundTeamAdjustedForSource::Parameters' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GameplayCue_PlaySoundTeamAdjustedForSource, Attached) == 0x0000C8, "Member 'OrionKismetLibrary_GameplayCue_PlaySoundTeamAdjustedForSource::Attached' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GameplayCue_PlaySoundTeamAdjustedForSource, bStopWhenAttachedToDestroyed) == 0x0000C9, "Member 'OrionKismetLibrary_GameplayCue_PlaySoundTeamAdjustedForSource::bStopWhenAttachedToDestroyed' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GameplayCue_PlaySoundTeamAdjustedForSource, ReturnValue) == 0x0000D0, "Member 'OrionKismetLibrary_GameplayCue_PlaySoundTeamAdjustedForSource::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GameplayCue_PlaySoundTeamAdjustedForTarget
// 0x00D8 (0x00D8 - 0x0000)
struct OrionKismetLibrary_GameplayCue_PlaySoundTeamAdjustedForTarget final
{
public:
	class USoundBase*                             SoundToPlay;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 MyTarget;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 Parameters;                                        // 0x0010(0x00B8)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          Attached;                                          // 0x00C8(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopWhenAttachedToDestroyed;                      // 0x00C9(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA[0x6];                                       // 0x00CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        ReturnValue;                                       // 0x00D0(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_GameplayCue_PlaySoundTeamAdjustedForTarget) == 0x000008, "Wrong alignment on OrionKismetLibrary_GameplayCue_PlaySoundTeamAdjustedForTarget");
static_assert(sizeof(OrionKismetLibrary_GameplayCue_PlaySoundTeamAdjustedForTarget) == 0x0000D8, "Wrong size on OrionKismetLibrary_GameplayCue_PlaySoundTeamAdjustedForTarget");
static_assert(offsetof(OrionKismetLibrary_GameplayCue_PlaySoundTeamAdjustedForTarget, SoundToPlay) == 0x000000, "Member 'OrionKismetLibrary_GameplayCue_PlaySoundTeamAdjustedForTarget::SoundToPlay' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GameplayCue_PlaySoundTeamAdjustedForTarget, MyTarget) == 0x000008, "Member 'OrionKismetLibrary_GameplayCue_PlaySoundTeamAdjustedForTarget::MyTarget' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GameplayCue_PlaySoundTeamAdjustedForTarget, Parameters) == 0x000010, "Member 'OrionKismetLibrary_GameplayCue_PlaySoundTeamAdjustedForTarget::Parameters' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GameplayCue_PlaySoundTeamAdjustedForTarget, Attached) == 0x0000C8, "Member 'OrionKismetLibrary_GameplayCue_PlaySoundTeamAdjustedForTarget::Attached' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GameplayCue_PlaySoundTeamAdjustedForTarget, bStopWhenAttachedToDestroyed) == 0x0000C9, "Member 'OrionKismetLibrary_GameplayCue_PlaySoundTeamAdjustedForTarget::bStopWhenAttachedToDestroyed' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GameplayCue_PlaySoundTeamAdjustedForTarget, ReturnValue) == 0x0000D0, "Member 'OrionKismetLibrary_GameplayCue_PlaySoundTeamAdjustedForTarget::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GameplayCue_RemoveDecal
// 0x0010 (0x0010 - 0x0000)
struct OrionKismetLibrary_GameplayCue_RemoveDecal final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DecalName;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_GameplayCue_RemoveDecal) == 0x000008, "Wrong alignment on OrionKismetLibrary_GameplayCue_RemoveDecal");
static_assert(sizeof(OrionKismetLibrary_GameplayCue_RemoveDecal) == 0x000010, "Wrong size on OrionKismetLibrary_GameplayCue_RemoveDecal");
static_assert(offsetof(OrionKismetLibrary_GameplayCue_RemoveDecal, Actor) == 0x000000, "Member 'OrionKismetLibrary_GameplayCue_RemoveDecal::Actor' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GameplayCue_RemoveDecal, DecalName) == 0x000008, "Member 'OrionKismetLibrary_GameplayCue_RemoveDecal::DecalName' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GameplayCue_SourceLocation
// 0x00C8 (0x00C8 - 0x0000)
struct OrionKismetLibrary_GameplayCue_SourceLocation final
{
public:
	struct FGameplayCueParameters                 Parameters;                                        // 0x0000(0x00B8)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x00B8(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_GameplayCue_SourceLocation) == 0x000008, "Wrong alignment on OrionKismetLibrary_GameplayCue_SourceLocation");
static_assert(sizeof(OrionKismetLibrary_GameplayCue_SourceLocation) == 0x0000C8, "Wrong size on OrionKismetLibrary_GameplayCue_SourceLocation");
static_assert(offsetof(OrionKismetLibrary_GameplayCue_SourceLocation, Parameters) == 0x000000, "Member 'OrionKismetLibrary_GameplayCue_SourceLocation::Parameters' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GameplayCue_SourceLocation, ReturnValue) == 0x0000B8, "Member 'OrionKismetLibrary_GameplayCue_SourceLocation::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GameplayCue_SpawnEmitter
// 0x00E0 (0x00E0 - 0x0000)
struct OrionKismetLibrary_GameplayCue_SpawnEmitter final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ParticleSystem;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 MyTarget;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 Parameters;                                        // 0x0018(0x00B8)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          Attached;                                          // 0x00D0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystemComponent*               ReturnValue;                                       // 0x00D8(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_GameplayCue_SpawnEmitter) == 0x000008, "Wrong alignment on OrionKismetLibrary_GameplayCue_SpawnEmitter");
static_assert(sizeof(OrionKismetLibrary_GameplayCue_SpawnEmitter) == 0x0000E0, "Wrong size on OrionKismetLibrary_GameplayCue_SpawnEmitter");
static_assert(offsetof(OrionKismetLibrary_GameplayCue_SpawnEmitter, WorldContextObject) == 0x000000, "Member 'OrionKismetLibrary_GameplayCue_SpawnEmitter::WorldContextObject' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GameplayCue_SpawnEmitter, ParticleSystem) == 0x000008, "Member 'OrionKismetLibrary_GameplayCue_SpawnEmitter::ParticleSystem' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GameplayCue_SpawnEmitter, MyTarget) == 0x000010, "Member 'OrionKismetLibrary_GameplayCue_SpawnEmitter::MyTarget' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GameplayCue_SpawnEmitter, Parameters) == 0x000018, "Member 'OrionKismetLibrary_GameplayCue_SpawnEmitter::Parameters' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GameplayCue_SpawnEmitter, Attached) == 0x0000D0, "Member 'OrionKismetLibrary_GameplayCue_SpawnEmitter::Attached' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GameplayCue_SpawnEmitter, ReturnValue) == 0x0000D8, "Member 'OrionKismetLibrary_GameplayCue_SpawnEmitter::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GenerateGameplayEffectSpecsForFilter
// 0x0058 (0x0058 - 0x0000)
struct OrionKismetLibrary_GenerateGameplayEffectSpecsForFilter final
{
public:
	struct FOrionFilterAndEffectsContainer        FilterContainer;                                   // 0x0000(0x0020)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Source;                                            // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InLevel;                                           // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionFilterAndEffectsContainer        ReturnValue;                                       // 0x0038(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_GenerateGameplayEffectSpecsForFilter) == 0x000008, "Wrong alignment on OrionKismetLibrary_GenerateGameplayEffectSpecsForFilter");
static_assert(sizeof(OrionKismetLibrary_GenerateGameplayEffectSpecsForFilter) == 0x000058, "Wrong size on OrionKismetLibrary_GenerateGameplayEffectSpecsForFilter");
static_assert(offsetof(OrionKismetLibrary_GenerateGameplayEffectSpecsForFilter, FilterContainer) == 0x000000, "Member 'OrionKismetLibrary_GenerateGameplayEffectSpecsForFilter::FilterContainer' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GenerateGameplayEffectSpecsForFilter, Instigator) == 0x000020, "Member 'OrionKismetLibrary_GenerateGameplayEffectSpecsForFilter::Instigator' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GenerateGameplayEffectSpecsForFilter, Source) == 0x000028, "Member 'OrionKismetLibrary_GenerateGameplayEffectSpecsForFilter::Source' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GenerateGameplayEffectSpecsForFilter, InLevel) == 0x000030, "Member 'OrionKismetLibrary_GenerateGameplayEffectSpecsForFilter::InLevel' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GenerateGameplayEffectSpecsForFilter, ReturnValue) == 0x000038, "Member 'OrionKismetLibrary_GenerateGameplayEffectSpecsForFilter::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GetActiveRotationalContentTags
// 0x0028 (0x0028 - 0x0000)
struct OrionKismetLibrary_GetActiveRotationalContentTags final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ReturnValue;                                       // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_GetActiveRotationalContentTags) == 0x000008, "Wrong alignment on OrionKismetLibrary_GetActiveRotationalContentTags");
static_assert(sizeof(OrionKismetLibrary_GetActiveRotationalContentTags) == 0x000028, "Wrong size on OrionKismetLibrary_GetActiveRotationalContentTags");
static_assert(offsetof(OrionKismetLibrary_GetActiveRotationalContentTags, WorldContextObject) == 0x000000, "Member 'OrionKismetLibrary_GetActiveRotationalContentTags::WorldContextObject' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GetActiveRotationalContentTags, ReturnValue) == 0x000008, "Member 'OrionKismetLibrary_GetActiveRotationalContentTags::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GetActorAimPosition
// 0x0018 (0x0018 - 0x0000)
struct OrionKismetLibrary_GetActorAimPosition final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_GetActorAimPosition) == 0x000008, "Wrong alignment on OrionKismetLibrary_GetActorAimPosition");
static_assert(sizeof(OrionKismetLibrary_GetActorAimPosition) == 0x000018, "Wrong size on OrionKismetLibrary_GetActorAimPosition");
static_assert(offsetof(OrionKismetLibrary_GetActorAimPosition, Actor) == 0x000000, "Member 'OrionKismetLibrary_GetActorAimPosition::Actor' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GetActorAimPosition, ReturnValue) == 0x000008, "Member 'OrionKismetLibrary_GetActorAimPosition::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GetActorBottom
// 0x0018 (0x0018 - 0x0000)
struct OrionKismetLibrary_GetActorBottom final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_GetActorBottom) == 0x000008, "Wrong alignment on OrionKismetLibrary_GetActorBottom");
static_assert(sizeof(OrionKismetLibrary_GetActorBottom) == 0x000018, "Wrong size on OrionKismetLibrary_GetActorBottom");
static_assert(offsetof(OrionKismetLibrary_GetActorBottom, Actor) == 0x000000, "Member 'OrionKismetLibrary_GetActorBottom::Actor' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GetActorBottom, ReturnValue) == 0x000008, "Member 'OrionKismetLibrary_GetActorBottom::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GetActorRadius
// 0x0010 (0x0010 - 0x0000)
struct OrionKismetLibrary_GetActorRadius final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_GetActorRadius) == 0x000008, "Wrong alignment on OrionKismetLibrary_GetActorRadius");
static_assert(sizeof(OrionKismetLibrary_GetActorRadius) == 0x000010, "Wrong size on OrionKismetLibrary_GetActorRadius");
static_assert(offsetof(OrionKismetLibrary_GetActorRadius, Actor) == 0x000000, "Member 'OrionKismetLibrary_GetActorRadius::Actor' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GetActorRadius, ReturnValue) == 0x000008, "Member 'OrionKismetLibrary_GetActorRadius::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GetActorTargetPosition
// 0x0018 (0x0018 - 0x0000)
struct OrionKismetLibrary_GetActorTargetPosition final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_GetActorTargetPosition) == 0x000008, "Wrong alignment on OrionKismetLibrary_GetActorTargetPosition");
static_assert(sizeof(OrionKismetLibrary_GetActorTargetPosition) == 0x000018, "Wrong size on OrionKismetLibrary_GetActorTargetPosition");
static_assert(offsetof(OrionKismetLibrary_GetActorTargetPosition, Actor) == 0x000000, "Member 'OrionKismetLibrary_GetActorTargetPosition::Actor' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GetActorTargetPosition, ReturnValue) == 0x000008, "Member 'OrionKismetLibrary_GetActorTargetPosition::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GetActorTeam
// 0x0010 (0x0010 - 0x0000)
struct OrionKismetLibrary_GetActorTeam final
{
public:
	const class AActor*                           A;                                                 // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_GetActorTeam) == 0x000008, "Wrong alignment on OrionKismetLibrary_GetActorTeam");
static_assert(sizeof(OrionKismetLibrary_GetActorTeam) == 0x000010, "Wrong size on OrionKismetLibrary_GetActorTeam");
static_assert(offsetof(OrionKismetLibrary_GetActorTeam, A) == 0x000000, "Member 'OrionKismetLibrary_GetActorTeam::A' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GetActorTeam, ReturnValue) == 0x000008, "Member 'OrionKismetLibrary_GetActorTeam::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GetEffectsToApplyToTargetFromFilters
// 0x0040 (0x0040 - 0x0000)
struct OrionKismetLibrary_GetEffectsToApplyToTargetFromFilters final
{
public:
	struct FOrionFilterAndEffectsContainer        FilterContainer;                                   // 0x0000(0x0020)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 Target;                                            // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayEffectSpecHandle>      EffectSpecHandlesToApply;                          // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_GetEffectsToApplyToTargetFromFilters) == 0x000008, "Wrong alignment on OrionKismetLibrary_GetEffectsToApplyToTargetFromFilters");
static_assert(sizeof(OrionKismetLibrary_GetEffectsToApplyToTargetFromFilters) == 0x000040, "Wrong size on OrionKismetLibrary_GetEffectsToApplyToTargetFromFilters");
static_assert(offsetof(OrionKismetLibrary_GetEffectsToApplyToTargetFromFilters, FilterContainer) == 0x000000, "Member 'OrionKismetLibrary_GetEffectsToApplyToTargetFromFilters::FilterContainer' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GetEffectsToApplyToTargetFromFilters, Target) == 0x000020, "Member 'OrionKismetLibrary_GetEffectsToApplyToTargetFromFilters::Target' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GetEffectsToApplyToTargetFromFilters, EffectSpecHandlesToApply) == 0x000028, "Member 'OrionKismetLibrary_GetEffectsToApplyToTargetFromFilters::EffectSpecHandlesToApply' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GetEffectsToApplyToTargetFromFilters, ReturnValue) == 0x000038, "Member 'OrionKismetLibrary_GetEffectsToApplyToTargetFromFilters::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GetEnemyColorFromMPC
// 0x0010 (0x0010 - 0x0000)
struct OrionKismetLibrary_GetEnemyColorFromMPC final
{
public:
	struct FLinearColor                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_GetEnemyColorFromMPC) == 0x000004, "Wrong alignment on OrionKismetLibrary_GetEnemyColorFromMPC");
static_assert(sizeof(OrionKismetLibrary_GetEnemyColorFromMPC) == 0x000010, "Wrong size on OrionKismetLibrary_GetEnemyColorFromMPC");
static_assert(offsetof(OrionKismetLibrary_GetEnemyColorFromMPC, ReturnValue) == 0x000000, "Member 'OrionKismetLibrary_GetEnemyColorFromMPC::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GetFriendlyColorFromMPC
// 0x0010 (0x0010 - 0x0000)
struct OrionKismetLibrary_GetFriendlyColorFromMPC final
{
public:
	struct FLinearColor                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_GetFriendlyColorFromMPC) == 0x000004, "Wrong alignment on OrionKismetLibrary_GetFriendlyColorFromMPC");
static_assert(sizeof(OrionKismetLibrary_GetFriendlyColorFromMPC) == 0x000010, "Wrong size on OrionKismetLibrary_GetFriendlyColorFromMPC");
static_assert(offsetof(OrionKismetLibrary_GetFriendlyColorFromMPC, ReturnValue) == 0x000000, "Member 'OrionKismetLibrary_GetFriendlyColorFromMPC::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GetGameplayEffectSpecsFromFilter
// 0x0048 (0x0048 - 0x0000)
struct OrionKismetLibrary_GetGameplayEffectSpecsFromFilter final
{
public:
	struct FOrionFilterAndEffectsContainer        FilterContainer;                                   // 0x0000(0x0020)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Source;                                            // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InLevel;                                           // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayEffectSpecHandle>      ReturnValue;                                       // 0x0038(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_GetGameplayEffectSpecsFromFilter) == 0x000008, "Wrong alignment on OrionKismetLibrary_GetGameplayEffectSpecsFromFilter");
static_assert(sizeof(OrionKismetLibrary_GetGameplayEffectSpecsFromFilter) == 0x000048, "Wrong size on OrionKismetLibrary_GetGameplayEffectSpecsFromFilter");
static_assert(offsetof(OrionKismetLibrary_GetGameplayEffectSpecsFromFilter, FilterContainer) == 0x000000, "Member 'OrionKismetLibrary_GetGameplayEffectSpecsFromFilter::FilterContainer' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GetGameplayEffectSpecsFromFilter, Instigator) == 0x000020, "Member 'OrionKismetLibrary_GetGameplayEffectSpecsFromFilter::Instigator' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GetGameplayEffectSpecsFromFilter, Source) == 0x000028, "Member 'OrionKismetLibrary_GetGameplayEffectSpecsFromFilter::Source' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GetGameplayEffectSpecsFromFilter, InLevel) == 0x000030, "Member 'OrionKismetLibrary_GetGameplayEffectSpecsFromFilter::InLevel' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GetGameplayEffectSpecsFromFilter, ReturnValue) == 0x000038, "Member 'OrionKismetLibrary_GetGameplayEffectSpecsFromFilter::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GetGlobalExponentialHeightFog
// 0x0010 (0x0010 - 0x0000)
struct OrionKismetLibrary_GetGlobalExponentialHeightFog final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AExponentialHeightFog*                  ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_GetGlobalExponentialHeightFog) == 0x000008, "Wrong alignment on OrionKismetLibrary_GetGlobalExponentialHeightFog");
static_assert(sizeof(OrionKismetLibrary_GetGlobalExponentialHeightFog) == 0x000010, "Wrong size on OrionKismetLibrary_GetGlobalExponentialHeightFog");
static_assert(offsetof(OrionKismetLibrary_GetGlobalExponentialHeightFog, WorldContextObject) == 0x000000, "Member 'OrionKismetLibrary_GetGlobalExponentialHeightFog::WorldContextObject' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GetGlobalExponentialHeightFog, ReturnValue) == 0x000008, "Member 'OrionKismetLibrary_GetGlobalExponentialHeightFog::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GetHealth
// 0x0010 (0x0010 - 0x0000)
struct OrionKismetLibrary_GetHealth final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_GetHealth) == 0x000008, "Wrong alignment on OrionKismetLibrary_GetHealth");
static_assert(sizeof(OrionKismetLibrary_GetHealth) == 0x000010, "Wrong size on OrionKismetLibrary_GetHealth");
static_assert(offsetof(OrionKismetLibrary_GetHealth, Target) == 0x000000, "Member 'OrionKismetLibrary_GetHealth::Target' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GetHealth, ReturnValue) == 0x000008, "Member 'OrionKismetLibrary_GetHealth::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GetHealthPCT
// 0x0010 (0x0010 - 0x0000)
struct OrionKismetLibrary_GetHealthPCT final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_GetHealthPCT) == 0x000008, "Wrong alignment on OrionKismetLibrary_GetHealthPCT");
static_assert(sizeof(OrionKismetLibrary_GetHealthPCT) == 0x000010, "Wrong size on OrionKismetLibrary_GetHealthPCT");
static_assert(offsetof(OrionKismetLibrary_GetHealthPCT, Target) == 0x000000, "Member 'OrionKismetLibrary_GetHealthPCT::Target' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GetHealthPCT, ReturnValue) == 0x000008, "Member 'OrionKismetLibrary_GetHealthPCT::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GetHeroPrimaryColor
// 0x0018 (0x0018 - 0x0000)
struct OrionKismetLibrary_GetHeroPrimaryColor final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_GetHeroPrimaryColor) == 0x000008, "Wrong alignment on OrionKismetLibrary_GetHeroPrimaryColor");
static_assert(sizeof(OrionKismetLibrary_GetHeroPrimaryColor) == 0x000018, "Wrong size on OrionKismetLibrary_GetHeroPrimaryColor");
static_assert(offsetof(OrionKismetLibrary_GetHeroPrimaryColor, Actor) == 0x000000, "Member 'OrionKismetLibrary_GetHeroPrimaryColor::Actor' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GetHeroPrimaryColor, ReturnValue) == 0x000008, "Member 'OrionKismetLibrary_GetHeroPrimaryColor::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GetHeroSecondaryColor
// 0x0018 (0x0018 - 0x0000)
struct OrionKismetLibrary_GetHeroSecondaryColor final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_GetHeroSecondaryColor) == 0x000008, "Wrong alignment on OrionKismetLibrary_GetHeroSecondaryColor");
static_assert(sizeof(OrionKismetLibrary_GetHeroSecondaryColor) == 0x000018, "Wrong size on OrionKismetLibrary_GetHeroSecondaryColor");
static_assert(offsetof(OrionKismetLibrary_GetHeroSecondaryColor, Actor) == 0x000000, "Member 'OrionKismetLibrary_GetHeroSecondaryColor::Actor' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GetHeroSecondaryColor, ReturnValue) == 0x000008, "Member 'OrionKismetLibrary_GetHeroSecondaryColor::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GetLocalPlayerController_Base
// 0x0010 (0x0010 - 0x0000)
struct OrionKismetLibrary_GetLocalPlayerController_Base final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionPlayerController_Base*            ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_GetLocalPlayerController_Base) == 0x000008, "Wrong alignment on OrionKismetLibrary_GetLocalPlayerController_Base");
static_assert(sizeof(OrionKismetLibrary_GetLocalPlayerController_Base) == 0x000010, "Wrong size on OrionKismetLibrary_GetLocalPlayerController_Base");
static_assert(offsetof(OrionKismetLibrary_GetLocalPlayerController_Base, WorldContextObject) == 0x000000, "Member 'OrionKismetLibrary_GetLocalPlayerController_Base::WorldContextObject' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GetLocalPlayerController_Base, ReturnValue) == 0x000008, "Member 'OrionKismetLibrary_GetLocalPlayerController_Base::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GetLocalPlayerController_Game
// 0x0010 (0x0010 - 0x0000)
struct OrionKismetLibrary_GetLocalPlayerController_Game final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionPlayerController_Game*            ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_GetLocalPlayerController_Game) == 0x000008, "Wrong alignment on OrionKismetLibrary_GetLocalPlayerController_Game");
static_assert(sizeof(OrionKismetLibrary_GetLocalPlayerController_Game) == 0x000010, "Wrong size on OrionKismetLibrary_GetLocalPlayerController_Game");
static_assert(offsetof(OrionKismetLibrary_GetLocalPlayerController_Game, WorldContextObject) == 0x000000, "Member 'OrionKismetLibrary_GetLocalPlayerController_Game::WorldContextObject' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GetLocalPlayerController_Game, ReturnValue) == 0x000008, "Member 'OrionKismetLibrary_GetLocalPlayerController_Game::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GetOrionReplaySpectator
// 0x0010 (0x0010 - 0x0000)
struct OrionKismetLibrary_GetOrionReplaySpectator final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionReplaySpectator*                  ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_GetOrionReplaySpectator) == 0x000008, "Wrong alignment on OrionKismetLibrary_GetOrionReplaySpectator");
static_assert(sizeof(OrionKismetLibrary_GetOrionReplaySpectator) == 0x000010, "Wrong size on OrionKismetLibrary_GetOrionReplaySpectator");
static_assert(offsetof(OrionKismetLibrary_GetOrionReplaySpectator, WorldContextObject) == 0x000000, "Member 'OrionKismetLibrary_GetOrionReplaySpectator::WorldContextObject' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GetOrionReplaySpectator, ReturnValue) == 0x000008, "Member 'OrionKismetLibrary_GetOrionReplaySpectator::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GetPlayerControllerFromActor
// 0x0010 (0x0010 - 0x0000)
struct OrionKismetLibrary_GetPlayerControllerFromActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionPlayerController_Game*            ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_GetPlayerControllerFromActor) == 0x000008, "Wrong alignment on OrionKismetLibrary_GetPlayerControllerFromActor");
static_assert(sizeof(OrionKismetLibrary_GetPlayerControllerFromActor) == 0x000010, "Wrong size on OrionKismetLibrary_GetPlayerControllerFromActor");
static_assert(offsetof(OrionKismetLibrary_GetPlayerControllerFromActor, Actor) == 0x000000, "Member 'OrionKismetLibrary_GetPlayerControllerFromActor::Actor' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GetPlayerControllerFromActor, ReturnValue) == 0x000008, "Member 'OrionKismetLibrary_GetPlayerControllerFromActor::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GetPrimaryActorFromTargetData
// 0x0030 (0x0030 - 0x0000)
struct OrionKismetLibrary_GetPrimaryActorFromTargetData final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         Index_0;                                           // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_GetPrimaryActorFromTargetData) == 0x000008, "Wrong alignment on OrionKismetLibrary_GetPrimaryActorFromTargetData");
static_assert(sizeof(OrionKismetLibrary_GetPrimaryActorFromTargetData) == 0x000030, "Wrong size on OrionKismetLibrary_GetPrimaryActorFromTargetData");
static_assert(offsetof(OrionKismetLibrary_GetPrimaryActorFromTargetData, TargetData) == 0x000000, "Member 'OrionKismetLibrary_GetPrimaryActorFromTargetData::TargetData' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GetPrimaryActorFromTargetData, Index_0) == 0x000020, "Member 'OrionKismetLibrary_GetPrimaryActorFromTargetData::Index_0' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GetPrimaryActorFromTargetData, ReturnValue) == 0x000028, "Member 'OrionKismetLibrary_GetPrimaryActorFromTargetData::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GetRigPlacementRange
// 0x0010 (0x0010 - 0x0000)
struct OrionKismetLibrary_GetRigPlacementRange final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_GetRigPlacementRange) == 0x000008, "Wrong alignment on OrionKismetLibrary_GetRigPlacementRange");
static_assert(sizeof(OrionKismetLibrary_GetRigPlacementRange) == 0x000010, "Wrong size on OrionKismetLibrary_GetRigPlacementRange");
static_assert(offsetof(OrionKismetLibrary_GetRigPlacementRange, Target) == 0x000000, "Member 'OrionKismetLibrary_GetRigPlacementRange::Target' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GetRigPlacementRange, ReturnValue) == 0x000008, "Member 'OrionKismetLibrary_GetRigPlacementRange::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GetSignificanceForLocation
// 0x0018 (0x0018 - 0x0000)
struct OrionKismetLibrary_GetSignificanceForLocation final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_GetSignificanceForLocation) == 0x000008, "Wrong alignment on OrionKismetLibrary_GetSignificanceForLocation");
static_assert(sizeof(OrionKismetLibrary_GetSignificanceForLocation) == 0x000018, "Wrong size on OrionKismetLibrary_GetSignificanceForLocation");
static_assert(offsetof(OrionKismetLibrary_GetSignificanceForLocation, WorldContextObject) == 0x000000, "Member 'OrionKismetLibrary_GetSignificanceForLocation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GetSignificanceForLocation, Location) == 0x000008, "Member 'OrionKismetLibrary_GetSignificanceForLocation::Location' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GetSignificanceForLocation, ReturnValue) == 0x000014, "Member 'OrionKismetLibrary_GetSignificanceForLocation::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GetSpawnLocationForControllerAtStartPoint
// 0x0020 (0x0020 - 0x0000)
struct OrionKismetLibrary_GetSpawnLocationForControllerAtStartPoint final
{
public:
	class AController*                            PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 StartSpot;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutSpawnLocation;                                  // 0x0010(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_GetSpawnLocationForControllerAtStartPoint) == 0x000008, "Wrong alignment on OrionKismetLibrary_GetSpawnLocationForControllerAtStartPoint");
static_assert(sizeof(OrionKismetLibrary_GetSpawnLocationForControllerAtStartPoint) == 0x000020, "Wrong size on OrionKismetLibrary_GetSpawnLocationForControllerAtStartPoint");
static_assert(offsetof(OrionKismetLibrary_GetSpawnLocationForControllerAtStartPoint, PlayerController) == 0x000000, "Member 'OrionKismetLibrary_GetSpawnLocationForControllerAtStartPoint::PlayerController' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GetSpawnLocationForControllerAtStartPoint, StartSpot) == 0x000008, "Member 'OrionKismetLibrary_GetSpawnLocationForControllerAtStartPoint::StartSpot' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GetSpawnLocationForControllerAtStartPoint, OutSpawnLocation) == 0x000010, "Member 'OrionKismetLibrary_GetSpawnLocationForControllerAtStartPoint::OutSpawnLocation' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GetTagContainerString
// 0x0030 (0x0030 - 0x0000)
struct OrionKismetLibrary_GetTagContainerString final
{
public:
	struct FGameplayTagContainer                  InContainer;                                       // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_GetTagContainerString) == 0x000008, "Wrong alignment on OrionKismetLibrary_GetTagContainerString");
static_assert(sizeof(OrionKismetLibrary_GetTagContainerString) == 0x000030, "Wrong size on OrionKismetLibrary_GetTagContainerString");
static_assert(offsetof(OrionKismetLibrary_GetTagContainerString, InContainer) == 0x000000, "Member 'OrionKismetLibrary_GetTagContainerString::InContainer' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GetTagContainerString, ReturnValue) == 0x000020, "Member 'OrionKismetLibrary_GetTagContainerString::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GetTagString
// 0x0018 (0x0018 - 0x0000)
struct OrionKismetLibrary_GetTagString final
{
public:
	struct FGameplayTag                           InTag;                                             // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_GetTagString) == 0x000008, "Wrong alignment on OrionKismetLibrary_GetTagString");
static_assert(sizeof(OrionKismetLibrary_GetTagString) == 0x000018, "Wrong size on OrionKismetLibrary_GetTagString");
static_assert(offsetof(OrionKismetLibrary_GetTagString, InTag) == 0x000000, "Member 'OrionKismetLibrary_GetTagString::InTag' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GetTagString, ReturnValue) == 0x000008, "Member 'OrionKismetLibrary_GetTagString::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GetTeamColorFromMPC
// 0x0018 (0x0018 - 0x0000)
struct OrionKismetLibrary_GetTeamColorFromMPC final
{
public:
	class UObject*                                Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_GetTeamColorFromMPC) == 0x000008, "Wrong alignment on OrionKismetLibrary_GetTeamColorFromMPC");
static_assert(sizeof(OrionKismetLibrary_GetTeamColorFromMPC) == 0x000018, "Wrong size on OrionKismetLibrary_GetTeamColorFromMPC");
static_assert(offsetof(OrionKismetLibrary_GetTeamColorFromMPC, Target) == 0x000000, "Member 'OrionKismetLibrary_GetTeamColorFromMPC::Target' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GetTeamColorFromMPC, ReturnValue) == 0x000008, "Member 'OrionKismetLibrary_GetTeamColorFromMPC::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GetTeamColorFromMPCWithTeamNum
// 0x0020 (0x0020 - 0x0000)
struct OrionKismetLibrary_GetTeamColorFromMPCWithTeamNum final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    TargetTeamNum;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           ReturnValue;                                       // 0x000C(0x0010)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_GetTeamColorFromMPCWithTeamNum) == 0x000008, "Wrong alignment on OrionKismetLibrary_GetTeamColorFromMPCWithTeamNum");
static_assert(sizeof(OrionKismetLibrary_GetTeamColorFromMPCWithTeamNum) == 0x000020, "Wrong size on OrionKismetLibrary_GetTeamColorFromMPCWithTeamNum");
static_assert(offsetof(OrionKismetLibrary_GetTeamColorFromMPCWithTeamNum, WorldContextObject) == 0x000000, "Member 'OrionKismetLibrary_GetTeamColorFromMPCWithTeamNum::WorldContextObject' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GetTeamColorFromMPCWithTeamNum, TargetTeamNum) == 0x000008, "Member 'OrionKismetLibrary_GetTeamColorFromMPCWithTeamNum::TargetTeamNum' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GetTeamColorFromMPCWithTeamNum, ReturnValue) == 0x00000C, "Member 'OrionKismetLibrary_GetTeamColorFromMPCWithTeamNum::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GetTravelModeMode
// 0x0010 (0x0010 - 0x0000)
struct OrionKismetLibrary_GetTravelModeMode final
{
public:
	class AActor*                                 WorldContextActor;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETravelModeModes                              ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_GetTravelModeMode) == 0x000008, "Wrong alignment on OrionKismetLibrary_GetTravelModeMode");
static_assert(sizeof(OrionKismetLibrary_GetTravelModeMode) == 0x000010, "Wrong size on OrionKismetLibrary_GetTravelModeMode");
static_assert(offsetof(OrionKismetLibrary_GetTravelModeMode, WorldContextActor) == 0x000000, "Member 'OrionKismetLibrary_GetTravelModeMode::WorldContextActor' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GetTravelModeMode, ReturnValue) == 0x000008, "Member 'OrionKismetLibrary_GetTravelModeMode::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GetVisibilityRelativeToLocalPlayer
// 0x0010 (0x0010 - 0x0000)
struct OrionKismetLibrary_GetVisibilityRelativeToLocalPlayer final
{
public:
	const class AActor*                           Target;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocalVisiblityState                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_GetVisibilityRelativeToLocalPlayer) == 0x000008, "Wrong alignment on OrionKismetLibrary_GetVisibilityRelativeToLocalPlayer");
static_assert(sizeof(OrionKismetLibrary_GetVisibilityRelativeToLocalPlayer) == 0x000010, "Wrong size on OrionKismetLibrary_GetVisibilityRelativeToLocalPlayer");
static_assert(offsetof(OrionKismetLibrary_GetVisibilityRelativeToLocalPlayer, Target) == 0x000000, "Member 'OrionKismetLibrary_GetVisibilityRelativeToLocalPlayer::Target' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_GetVisibilityRelativeToLocalPlayer, ReturnValue) == 0x000008, "Member 'OrionKismetLibrary_GetVisibilityRelativeToLocalPlayer::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GetWorldBackwardVector
// 0x000C (0x000C - 0x0000)
struct OrionKismetLibrary_GetWorldBackwardVector final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_GetWorldBackwardVector) == 0x000004, "Wrong alignment on OrionKismetLibrary_GetWorldBackwardVector");
static_assert(sizeof(OrionKismetLibrary_GetWorldBackwardVector) == 0x00000C, "Wrong size on OrionKismetLibrary_GetWorldBackwardVector");
static_assert(offsetof(OrionKismetLibrary_GetWorldBackwardVector, ReturnValue) == 0x000000, "Member 'OrionKismetLibrary_GetWorldBackwardVector::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GetWorldDownVector
// 0x000C (0x000C - 0x0000)
struct OrionKismetLibrary_GetWorldDownVector final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_GetWorldDownVector) == 0x000004, "Wrong alignment on OrionKismetLibrary_GetWorldDownVector");
static_assert(sizeof(OrionKismetLibrary_GetWorldDownVector) == 0x00000C, "Wrong size on OrionKismetLibrary_GetWorldDownVector");
static_assert(offsetof(OrionKismetLibrary_GetWorldDownVector, ReturnValue) == 0x000000, "Member 'OrionKismetLibrary_GetWorldDownVector::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GetWorldForwardVector
// 0x000C (0x000C - 0x0000)
struct OrionKismetLibrary_GetWorldForwardVector final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_GetWorldForwardVector) == 0x000004, "Wrong alignment on OrionKismetLibrary_GetWorldForwardVector");
static_assert(sizeof(OrionKismetLibrary_GetWorldForwardVector) == 0x00000C, "Wrong size on OrionKismetLibrary_GetWorldForwardVector");
static_assert(offsetof(OrionKismetLibrary_GetWorldForwardVector, ReturnValue) == 0x000000, "Member 'OrionKismetLibrary_GetWorldForwardVector::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GetWorldLeftVector
// 0x000C (0x000C - 0x0000)
struct OrionKismetLibrary_GetWorldLeftVector final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_GetWorldLeftVector) == 0x000004, "Wrong alignment on OrionKismetLibrary_GetWorldLeftVector");
static_assert(sizeof(OrionKismetLibrary_GetWorldLeftVector) == 0x00000C, "Wrong size on OrionKismetLibrary_GetWorldLeftVector");
static_assert(offsetof(OrionKismetLibrary_GetWorldLeftVector, ReturnValue) == 0x000000, "Member 'OrionKismetLibrary_GetWorldLeftVector::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GetWorldRightVector
// 0x000C (0x000C - 0x0000)
struct OrionKismetLibrary_GetWorldRightVector final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_GetWorldRightVector) == 0x000004, "Wrong alignment on OrionKismetLibrary_GetWorldRightVector");
static_assert(sizeof(OrionKismetLibrary_GetWorldRightVector) == 0x00000C, "Wrong size on OrionKismetLibrary_GetWorldRightVector");
static_assert(offsetof(OrionKismetLibrary_GetWorldRightVector, ReturnValue) == 0x000000, "Member 'OrionKismetLibrary_GetWorldRightVector::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.GetWorldUpVector
// 0x000C (0x000C - 0x0000)
struct OrionKismetLibrary_GetWorldUpVector final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_GetWorldUpVector) == 0x000004, "Wrong alignment on OrionKismetLibrary_GetWorldUpVector");
static_assert(sizeof(OrionKismetLibrary_GetWorldUpVector) == 0x00000C, "Wrong size on OrionKismetLibrary_GetWorldUpVector");
static_assert(offsetof(OrionKismetLibrary_GetWorldUpVector, ReturnValue) == 0x000000, "Member 'OrionKismetLibrary_GetWorldUpVector::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.HasTrueSight
// 0x0010 (0x0010 - 0x0000)
struct OrionKismetLibrary_HasTrueSight final
{
public:
	const class AActor*                           A;                                                 // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_HasTrueSight) == 0x000008, "Wrong alignment on OrionKismetLibrary_HasTrueSight");
static_assert(sizeof(OrionKismetLibrary_HasTrueSight) == 0x000010, "Wrong size on OrionKismetLibrary_HasTrueSight");
static_assert(offsetof(OrionKismetLibrary_HasTrueSight, A) == 0x000000, "Member 'OrionKismetLibrary_HasTrueSight::A' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_HasTrueSight, ReturnValue) == 0x000008, "Member 'OrionKismetLibrary_HasTrueSight::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.IsDead
// 0x0010 (0x0010 - 0x0000)
struct OrionKismetLibrary_IsDead final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_IsDead) == 0x000008, "Wrong alignment on OrionKismetLibrary_IsDead");
static_assert(sizeof(OrionKismetLibrary_IsDead) == 0x000010, "Wrong size on OrionKismetLibrary_IsDead");
static_assert(offsetof(OrionKismetLibrary_IsDead, Target) == 0x000000, "Member 'OrionKismetLibrary_IsDead::Target' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_IsDead, ReturnValue) == 0x000008, "Member 'OrionKismetLibrary_IsDead::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.IsEngineDoingAsyncLoading
// 0x0001 (0x0001 - 0x0000)
struct OrionKismetLibrary_IsEngineDoingAsyncLoading final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_IsEngineDoingAsyncLoading) == 0x000001, "Wrong alignment on OrionKismetLibrary_IsEngineDoingAsyncLoading");
static_assert(sizeof(OrionKismetLibrary_IsEngineDoingAsyncLoading) == 0x000001, "Wrong size on OrionKismetLibrary_IsEngineDoingAsyncLoading");
static_assert(offsetof(OrionKismetLibrary_IsEngineDoingAsyncLoading, ReturnValue) == 0x000000, "Member 'OrionKismetLibrary_IsEngineDoingAsyncLoading::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.IsInShadowPlane
// 0x0010 (0x0010 - 0x0000)
struct OrionKismetLibrary_IsInShadowPlane final
{
public:
	const class AActor*                           A;                                                 // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_IsInShadowPlane) == 0x000008, "Wrong alignment on OrionKismetLibrary_IsInShadowPlane");
static_assert(sizeof(OrionKismetLibrary_IsInShadowPlane) == 0x000010, "Wrong size on OrionKismetLibrary_IsInShadowPlane");
static_assert(offsetof(OrionKismetLibrary_IsInShadowPlane, A) == 0x000000, "Member 'OrionKismetLibrary_IsInShadowPlane::A' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_IsInShadowPlane, ReturnValue) == 0x000008, "Member 'OrionKismetLibrary_IsInShadowPlane::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.IsLocallyControlledPlayer
// 0x0010 (0x0010 - 0x0000)
struct OrionKismetLibrary_IsLocallyControlledPlayer final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_IsLocallyControlledPlayer) == 0x000008, "Wrong alignment on OrionKismetLibrary_IsLocallyControlledPlayer");
static_assert(sizeof(OrionKismetLibrary_IsLocallyControlledPlayer) == 0x000010, "Wrong size on OrionKismetLibrary_IsLocallyControlledPlayer");
static_assert(offsetof(OrionKismetLibrary_IsLocallyControlledPlayer, Actor) == 0x000000, "Member 'OrionKismetLibrary_IsLocallyControlledPlayer::Actor' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_IsLocallyControlledPlayer, ReturnValue) == 0x000008, "Member 'OrionKismetLibrary_IsLocallyControlledPlayer::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.IsOnLocalTeam
// 0x0018 (0x0018 - 0x0000)
struct OrionKismetLibrary_IsOnLocalTeam final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           A;                                                 // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_IsOnLocalTeam) == 0x000008, "Wrong alignment on OrionKismetLibrary_IsOnLocalTeam");
static_assert(sizeof(OrionKismetLibrary_IsOnLocalTeam) == 0x000018, "Wrong size on OrionKismetLibrary_IsOnLocalTeam");
static_assert(offsetof(OrionKismetLibrary_IsOnLocalTeam, WorldContextObject) == 0x000000, "Member 'OrionKismetLibrary_IsOnLocalTeam::WorldContextObject' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_IsOnLocalTeam, A) == 0x000008, "Member 'OrionKismetLibrary_IsOnLocalTeam::A' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_IsOnLocalTeam, ReturnValue) == 0x000010, "Member 'OrionKismetLibrary_IsOnLocalTeam::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.IsPhaseShifted
// 0x0010 (0x0010 - 0x0000)
struct OrionKismetLibrary_IsPhaseShifted final
{
public:
	const class AActor*                           A;                                                 // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_IsPhaseShifted) == 0x000008, "Wrong alignment on OrionKismetLibrary_IsPhaseShifted");
static_assert(sizeof(OrionKismetLibrary_IsPhaseShifted) == 0x000010, "Wrong size on OrionKismetLibrary_IsPhaseShifted");
static_assert(offsetof(OrionKismetLibrary_IsPhaseShifted, A) == 0x000000, "Member 'OrionKismetLibrary_IsPhaseShifted::A' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_IsPhaseShifted, ReturnValue) == 0x000008, "Member 'OrionKismetLibrary_IsPhaseShifted::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.IsRunningOnLowEndClient
// 0x0001 (0x0001 - 0x0000)
struct OrionKismetLibrary_IsRunningOnLowEndClient final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_IsRunningOnLowEndClient) == 0x000001, "Wrong alignment on OrionKismetLibrary_IsRunningOnLowEndClient");
static_assert(sizeof(OrionKismetLibrary_IsRunningOnLowEndClient) == 0x000001, "Wrong size on OrionKismetLibrary_IsRunningOnLowEndClient");
static_assert(offsetof(OrionKismetLibrary_IsRunningOnLowEndClient, ReturnValue) == 0x000000, "Member 'OrionKismetLibrary_IsRunningOnLowEndClient::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.IsSprintEnabled
// 0x0010 (0x0010 - 0x0000)
struct OrionKismetLibrary_IsSprintEnabled final
{
public:
	class AActor*                                 WorldContextActor;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_IsSprintEnabled) == 0x000008, "Wrong alignment on OrionKismetLibrary_IsSprintEnabled");
static_assert(sizeof(OrionKismetLibrary_IsSprintEnabled) == 0x000010, "Wrong size on OrionKismetLibrary_IsSprintEnabled");
static_assert(offsetof(OrionKismetLibrary_IsSprintEnabled, WorldContextActor) == 0x000000, "Member 'OrionKismetLibrary_IsSprintEnabled::WorldContextActor' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_IsSprintEnabled, ReturnValue) == 0x000008, "Member 'OrionKismetLibrary_IsSprintEnabled::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.IsVisibleToEnemy
// 0x0010 (0x0010 - 0x0000)
struct OrionKismetLibrary_IsVisibleToEnemy final
{
public:
	const class AActor*                           A;                                                 // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_IsVisibleToEnemy) == 0x000008, "Wrong alignment on OrionKismetLibrary_IsVisibleToEnemy");
static_assert(sizeof(OrionKismetLibrary_IsVisibleToEnemy) == 0x000010, "Wrong size on OrionKismetLibrary_IsVisibleToEnemy");
static_assert(offsetof(OrionKismetLibrary_IsVisibleToEnemy, A) == 0x000000, "Member 'OrionKismetLibrary_IsVisibleToEnemy::A' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_IsVisibleToEnemy, ReturnValue) == 0x000008, "Member 'OrionKismetLibrary_IsVisibleToEnemy::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.IsVisibleToTeam
// 0x0010 (0x0010 - 0x0000)
struct OrionKismetLibrary_IsVisibleToTeam final
{
public:
	const class AActor*                           A;                                                 // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    TeamNum;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_IsVisibleToTeam) == 0x000008, "Wrong alignment on OrionKismetLibrary_IsVisibleToTeam");
static_assert(sizeof(OrionKismetLibrary_IsVisibleToTeam) == 0x000010, "Wrong size on OrionKismetLibrary_IsVisibleToTeam");
static_assert(offsetof(OrionKismetLibrary_IsVisibleToTeam, A) == 0x000000, "Member 'OrionKismetLibrary_IsVisibleToTeam::A' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_IsVisibleToTeam, TeamNum) == 0x000008, "Member 'OrionKismetLibrary_IsVisibleToTeam::TeamNum' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_IsVisibleToTeam, ReturnValue) == 0x000009, "Member 'OrionKismetLibrary_IsVisibleToTeam::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.LaunchCharacterInDirection
// 0x0020 (0x0020 - 0x0000)
struct OrionKismetLibrary_LaunchCharacterInDirection final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchVelocity;                                    // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockAirControl;                                   // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_LaunchCharacterInDirection) == 0x000008, "Wrong alignment on OrionKismetLibrary_LaunchCharacterInDirection");
static_assert(sizeof(OrionKismetLibrary_LaunchCharacterInDirection) == 0x000020, "Wrong size on OrionKismetLibrary_LaunchCharacterInDirection");
static_assert(offsetof(OrionKismetLibrary_LaunchCharacterInDirection, Actor) == 0x000000, "Member 'OrionKismetLibrary_LaunchCharacterInDirection::Actor' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_LaunchCharacterInDirection, Direction) == 0x000008, "Member 'OrionKismetLibrary_LaunchCharacterInDirection::Direction' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_LaunchCharacterInDirection, LaunchVelocity) == 0x000014, "Member 'OrionKismetLibrary_LaunchCharacterInDirection::LaunchVelocity' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_LaunchCharacterInDirection, bLockAirControl) == 0x000018, "Member 'OrionKismetLibrary_LaunchCharacterInDirection::bLockAirControl' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.LaunchCharacterInDirectionFromTargetData
// 0x0030 (0x0030 - 0x0000)
struct OrionKismetLibrary_LaunchCharacterInDirectionFromTargetData final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetDataHandle;                                  // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         LaunchVelocity;                                    // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockAirControl;                                   // 0x002C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_LaunchCharacterInDirectionFromTargetData) == 0x000008, "Wrong alignment on OrionKismetLibrary_LaunchCharacterInDirectionFromTargetData");
static_assert(sizeof(OrionKismetLibrary_LaunchCharacterInDirectionFromTargetData) == 0x000030, "Wrong size on OrionKismetLibrary_LaunchCharacterInDirectionFromTargetData");
static_assert(offsetof(OrionKismetLibrary_LaunchCharacterInDirectionFromTargetData, Actor) == 0x000000, "Member 'OrionKismetLibrary_LaunchCharacterInDirectionFromTargetData::Actor' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_LaunchCharacterInDirectionFromTargetData, TargetDataHandle) == 0x000008, "Member 'OrionKismetLibrary_LaunchCharacterInDirectionFromTargetData::TargetDataHandle' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_LaunchCharacterInDirectionFromTargetData, LaunchVelocity) == 0x000028, "Member 'OrionKismetLibrary_LaunchCharacterInDirectionFromTargetData::LaunchVelocity' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_LaunchCharacterInDirectionFromTargetData, bLockAirControl) == 0x00002C, "Member 'OrionKismetLibrary_LaunchCharacterInDirectionFromTargetData::bLockAirControl' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.LaunchCharacterToPoint
// 0x0020 (0x0020 - 0x0000)
struct OrionKismetLibrary_LaunchCharacterToPoint final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndPoint;                                          // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchVelocityXY;                                  // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockAirControl;                                   // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_LaunchCharacterToPoint) == 0x000008, "Wrong alignment on OrionKismetLibrary_LaunchCharacterToPoint");
static_assert(sizeof(OrionKismetLibrary_LaunchCharacterToPoint) == 0x000020, "Wrong size on OrionKismetLibrary_LaunchCharacterToPoint");
static_assert(offsetof(OrionKismetLibrary_LaunchCharacterToPoint, Actor) == 0x000000, "Member 'OrionKismetLibrary_LaunchCharacterToPoint::Actor' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_LaunchCharacterToPoint, EndPoint) == 0x000008, "Member 'OrionKismetLibrary_LaunchCharacterToPoint::EndPoint' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_LaunchCharacterToPoint, LaunchVelocityXY) == 0x000014, "Member 'OrionKismetLibrary_LaunchCharacterToPoint::LaunchVelocityXY' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_LaunchCharacterToPoint, bLockAirControl) == 0x000018, "Member 'OrionKismetLibrary_LaunchCharacterToPoint::bLockAirControl' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.LaunchCharacterToPointFromTargetData
// 0x0030 (0x0030 - 0x0000)
struct OrionKismetLibrary_LaunchCharacterToPointFromTargetData final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetDataHandle;                                  // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         LaunchVelocityXY;                                  // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockAirControl;                                   // 0x002C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_LaunchCharacterToPointFromTargetData) == 0x000008, "Wrong alignment on OrionKismetLibrary_LaunchCharacterToPointFromTargetData");
static_assert(sizeof(OrionKismetLibrary_LaunchCharacterToPointFromTargetData) == 0x000030, "Wrong size on OrionKismetLibrary_LaunchCharacterToPointFromTargetData");
static_assert(offsetof(OrionKismetLibrary_LaunchCharacterToPointFromTargetData, Actor) == 0x000000, "Member 'OrionKismetLibrary_LaunchCharacterToPointFromTargetData::Actor' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_LaunchCharacterToPointFromTargetData, TargetDataHandle) == 0x000008, "Member 'OrionKismetLibrary_LaunchCharacterToPointFromTargetData::TargetDataHandle' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_LaunchCharacterToPointFromTargetData, LaunchVelocityXY) == 0x000028, "Member 'OrionKismetLibrary_LaunchCharacterToPointFromTargetData::LaunchVelocityXY' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_LaunchCharacterToPointFromTargetData, bLockAirControl) == 0x00002C, "Member 'OrionKismetLibrary_LaunchCharacterToPointFromTargetData::bLockAirControl' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.MakeOrionFilterHandle
// 0x0050 (0x0050 - 0x0000)
struct OrionKismetLibrary_MakeOrionFilterHandle final
{
public:
	struct FOrionAbilityTargetDataFilter          Filter;                                            // 0x0000(0x0030)(Parm, NativeAccessSpecifierPublic)
	class AActor*                                 FilterActor;                                       // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    FilterTeam;                                        // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTargetDataFilterHandle        ReturnValue;                                       // 0x0040(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_MakeOrionFilterHandle) == 0x000008, "Wrong alignment on OrionKismetLibrary_MakeOrionFilterHandle");
static_assert(sizeof(OrionKismetLibrary_MakeOrionFilterHandle) == 0x000050, "Wrong size on OrionKismetLibrary_MakeOrionFilterHandle");
static_assert(offsetof(OrionKismetLibrary_MakeOrionFilterHandle, Filter) == 0x000000, "Member 'OrionKismetLibrary_MakeOrionFilterHandle::Filter' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_MakeOrionFilterHandle, FilterActor) == 0x000030, "Member 'OrionKismetLibrary_MakeOrionFilterHandle::FilterActor' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_MakeOrionFilterHandle, FilterTeam) == 0x000038, "Member 'OrionKismetLibrary_MakeOrionFilterHandle::FilterTeam' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_MakeOrionFilterHandle, ReturnValue) == 0x000040, "Member 'OrionKismetLibrary_MakeOrionFilterHandle::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.MakeOrionTargetData
// 0x0090 (0x0090 - 0x0000)
struct OrionKismetLibrary_MakeOrionTargetData final
{
public:
	struct FTransform                             SourceTransform;                                   // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             TargetTransform;                                   // 0x0030(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0060(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowExternalTargetSwaps;                         // 0x0068(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityTargetDataHandle       ReturnValue;                                       // 0x0070(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_MakeOrionTargetData) == 0x000010, "Wrong alignment on OrionKismetLibrary_MakeOrionTargetData");
static_assert(sizeof(OrionKismetLibrary_MakeOrionTargetData) == 0x000090, "Wrong size on OrionKismetLibrary_MakeOrionTargetData");
static_assert(offsetof(OrionKismetLibrary_MakeOrionTargetData, SourceTransform) == 0x000000, "Member 'OrionKismetLibrary_MakeOrionTargetData::SourceTransform' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_MakeOrionTargetData, TargetTransform) == 0x000030, "Member 'OrionKismetLibrary_MakeOrionTargetData::TargetTransform' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_MakeOrionTargetData, TargetActor) == 0x000060, "Member 'OrionKismetLibrary_MakeOrionTargetData::TargetActor' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_MakeOrionTargetData, bAllowExternalTargetSwaps) == 0x000068, "Member 'OrionKismetLibrary_MakeOrionTargetData::bAllowExternalTargetSwaps' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_MakeOrionTargetData, ReturnValue) == 0x000070, "Member 'OrionKismetLibrary_MakeOrionTargetData::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.NewVisionManagerEnabled
// 0x0010 (0x0010 - 0x0000)
struct OrionKismetLibrary_NewVisionManagerEnabled final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_NewVisionManagerEnabled) == 0x000008, "Wrong alignment on OrionKismetLibrary_NewVisionManagerEnabled");
static_assert(sizeof(OrionKismetLibrary_NewVisionManagerEnabled) == 0x000010, "Wrong size on OrionKismetLibrary_NewVisionManagerEnabled");
static_assert(offsetof(OrionKismetLibrary_NewVisionManagerEnabled, WorldContextObject) == 0x000000, "Member 'OrionKismetLibrary_NewVisionManagerEnabled::WorldContextObject' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_NewVisionManagerEnabled, ReturnValue) == 0x000008, "Member 'OrionKismetLibrary_NewVisionManagerEnabled::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.OnSameFormation
// 0x0018 (0x0018 - 0x0000)
struct OrionKismetLibrary_OnSameFormation final
{
public:
	const class AOrionAIController*               A;                                                 // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AOrionAIController*               B;                                                 // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_OnSameFormation) == 0x000008, "Wrong alignment on OrionKismetLibrary_OnSameFormation");
static_assert(sizeof(OrionKismetLibrary_OnSameFormation) == 0x000018, "Wrong size on OrionKismetLibrary_OnSameFormation");
static_assert(offsetof(OrionKismetLibrary_OnSameFormation, A) == 0x000000, "Member 'OrionKismetLibrary_OnSameFormation::A' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_OnSameFormation, B) == 0x000008, "Member 'OrionKismetLibrary_OnSameFormation::B' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_OnSameFormation, ReturnValue) == 0x000010, "Member 'OrionKismetLibrary_OnSameFormation::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.OnSameFormationChar
// 0x0018 (0x0018 - 0x0000)
struct OrionKismetLibrary_OnSameFormationChar final
{
public:
	const class AOrionChar*                       A;                                                 // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AOrionChar*                       B;                                                 // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_OnSameFormationChar) == 0x000008, "Wrong alignment on OrionKismetLibrary_OnSameFormationChar");
static_assert(sizeof(OrionKismetLibrary_OnSameFormationChar) == 0x000018, "Wrong size on OrionKismetLibrary_OnSameFormationChar");
static_assert(offsetof(OrionKismetLibrary_OnSameFormationChar, A) == 0x000000, "Member 'OrionKismetLibrary_OnSameFormationChar::A' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_OnSameFormationChar, B) == 0x000008, "Member 'OrionKismetLibrary_OnSameFormationChar::B' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_OnSameFormationChar, ReturnValue) == 0x000010, "Member 'OrionKismetLibrary_OnSameFormationChar::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.OnSameTeam
// 0x0018 (0x0018 - 0x0000)
struct OrionKismetLibrary_OnSameTeam final
{
public:
	class AActor*                                 A;                                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 B;                                                 // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_OnSameTeam) == 0x000008, "Wrong alignment on OrionKismetLibrary_OnSameTeam");
static_assert(sizeof(OrionKismetLibrary_OnSameTeam) == 0x000018, "Wrong size on OrionKismetLibrary_OnSameTeam");
static_assert(offsetof(OrionKismetLibrary_OnSameTeam, A) == 0x000000, "Member 'OrionKismetLibrary_OnSameTeam::A' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_OnSameTeam, B) == 0x000008, "Member 'OrionKismetLibrary_OnSameTeam::B' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_OnSameTeam, ReturnValue) == 0x000010, "Member 'OrionKismetLibrary_OnSameTeam::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.PingMinimap
// 0x0018 (0x0018 - 0x0000)
struct OrionKismetLibrary_PingMinimap final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    TeamToPing;                                        // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_PingMinimap) == 0x000008, "Wrong alignment on OrionKismetLibrary_PingMinimap");
static_assert(sizeof(OrionKismetLibrary_PingMinimap) == 0x000018, "Wrong size on OrionKismetLibrary_PingMinimap");
static_assert(offsetof(OrionKismetLibrary_PingMinimap, WorldContextObject) == 0x000000, "Member 'OrionKismetLibrary_PingMinimap::WorldContextObject' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_PingMinimap, Location) == 0x000008, "Member 'OrionKismetLibrary_PingMinimap::Location' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_PingMinimap, TeamToPing) == 0x000014, "Member 'OrionKismetLibrary_PingMinimap::TeamToPing' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.PlayCameraAnimOnActor
// 0x0030 (0x0030 - 0x0000)
struct OrionKismetLibrary_PlayCameraAnimOnActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraAnim*                            AnimToPlay;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rate;                                              // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomStartTime;                                  // 0x0021(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraAnimPlaySpace                          Space;                                             // 0x0022(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x1];                                       // 0x0023(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               CustomPlaySpace;                                   // 0x0024(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_PlayCameraAnimOnActor) == 0x000008, "Wrong alignment on OrionKismetLibrary_PlayCameraAnimOnActor");
static_assert(sizeof(OrionKismetLibrary_PlayCameraAnimOnActor) == 0x000030, "Wrong size on OrionKismetLibrary_PlayCameraAnimOnActor");
static_assert(offsetof(OrionKismetLibrary_PlayCameraAnimOnActor, Actor) == 0x000000, "Member 'OrionKismetLibrary_PlayCameraAnimOnActor::Actor' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_PlayCameraAnimOnActor, AnimToPlay) == 0x000008, "Member 'OrionKismetLibrary_PlayCameraAnimOnActor::AnimToPlay' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_PlayCameraAnimOnActor, Scale) == 0x000010, "Member 'OrionKismetLibrary_PlayCameraAnimOnActor::Scale' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_PlayCameraAnimOnActor, Rate) == 0x000014, "Member 'OrionKismetLibrary_PlayCameraAnimOnActor::Rate' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_PlayCameraAnimOnActor, BlendInTime) == 0x000018, "Member 'OrionKismetLibrary_PlayCameraAnimOnActor::BlendInTime' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_PlayCameraAnimOnActor, BlendOutTime) == 0x00001C, "Member 'OrionKismetLibrary_PlayCameraAnimOnActor::BlendOutTime' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_PlayCameraAnimOnActor, bLoop) == 0x000020, "Member 'OrionKismetLibrary_PlayCameraAnimOnActor::bLoop' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_PlayCameraAnimOnActor, bRandomStartTime) == 0x000021, "Member 'OrionKismetLibrary_PlayCameraAnimOnActor::bRandomStartTime' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_PlayCameraAnimOnActor, Space) == 0x000022, "Member 'OrionKismetLibrary_PlayCameraAnimOnActor::Space' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_PlayCameraAnimOnActor, CustomPlaySpace) == 0x000024, "Member 'OrionKismetLibrary_PlayCameraAnimOnActor::CustomPlaySpace' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.PlayCameraShakeOnActor
// 0x0028 (0x0028 - 0x0000)
struct OrionKismetLibrary_PlayCameraShakeOnActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraShake>               Shake;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraAnimPlaySpace                          PlaySpace;                                         // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               UserPlaySpaceRot;                                  // 0x0018(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_PlayCameraShakeOnActor) == 0x000008, "Wrong alignment on OrionKismetLibrary_PlayCameraShakeOnActor");
static_assert(sizeof(OrionKismetLibrary_PlayCameraShakeOnActor) == 0x000028, "Wrong size on OrionKismetLibrary_PlayCameraShakeOnActor");
static_assert(offsetof(OrionKismetLibrary_PlayCameraShakeOnActor, Actor) == 0x000000, "Member 'OrionKismetLibrary_PlayCameraShakeOnActor::Actor' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_PlayCameraShakeOnActor, Shake) == 0x000008, "Member 'OrionKismetLibrary_PlayCameraShakeOnActor::Shake' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_PlayCameraShakeOnActor, Scale) == 0x000010, "Member 'OrionKismetLibrary_PlayCameraShakeOnActor::Scale' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_PlayCameraShakeOnActor, PlaySpace) == 0x000014, "Member 'OrionKismetLibrary_PlayCameraShakeOnActor::PlaySpace' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_PlayCameraShakeOnActor, UserPlaySpaceRot) == 0x000018, "Member 'OrionKismetLibrary_PlayCameraShakeOnActor::UserPlaySpaceRot' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.PlayForceFeedbackOnActor
// 0x0020 (0x0020 - 0x0000)
struct OrionKismetLibrary_PlayForceFeedbackOnActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   ForceFeedbackEffect;                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLooping;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Tag;                                               // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_PlayForceFeedbackOnActor) == 0x000008, "Wrong alignment on OrionKismetLibrary_PlayForceFeedbackOnActor");
static_assert(sizeof(OrionKismetLibrary_PlayForceFeedbackOnActor) == 0x000020, "Wrong size on OrionKismetLibrary_PlayForceFeedbackOnActor");
static_assert(offsetof(OrionKismetLibrary_PlayForceFeedbackOnActor, Actor) == 0x000000, "Member 'OrionKismetLibrary_PlayForceFeedbackOnActor::Actor' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_PlayForceFeedbackOnActor, ForceFeedbackEffect) == 0x000008, "Member 'OrionKismetLibrary_PlayForceFeedbackOnActor::ForceFeedbackEffect' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_PlayForceFeedbackOnActor, bLooping) == 0x000010, "Member 'OrionKismetLibrary_PlayForceFeedbackOnActor::bLooping' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_PlayForceFeedbackOnActor, Tag) == 0x000018, "Member 'OrionKismetLibrary_PlayForceFeedbackOnActor::Tag' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.PlayViewKickOnActor
// 0x0018 (0x0018 - 0x0000)
struct OrionKismetLibrary_PlayViewKickOnActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UOrionViewKick>             ViewKickClass;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_PlayViewKickOnActor) == 0x000008, "Wrong alignment on OrionKismetLibrary_PlayViewKickOnActor");
static_assert(sizeof(OrionKismetLibrary_PlayViewKickOnActor) == 0x000018, "Wrong size on OrionKismetLibrary_PlayViewKickOnActor");
static_assert(offsetof(OrionKismetLibrary_PlayViewKickOnActor, Actor) == 0x000000, "Member 'OrionKismetLibrary_PlayViewKickOnActor::Actor' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_PlayViewKickOnActor, ViewKickClass) == 0x000008, "Member 'OrionKismetLibrary_PlayViewKickOnActor::ViewKickClass' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_PlayViewKickOnActor, Scale) == 0x000010, "Member 'OrionKismetLibrary_PlayViewKickOnActor::Scale' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.RotateVectorDegrees
// 0x0014 (0x0014 - 0x0000)
struct OrionKismetLibrary_RotateVectorDegrees final
{
public:
	struct FVector2D                              V0;                                                // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radians;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x000C(0x0008)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_RotateVectorDegrees) == 0x000004, "Wrong alignment on OrionKismetLibrary_RotateVectorDegrees");
static_assert(sizeof(OrionKismetLibrary_RotateVectorDegrees) == 0x000014, "Wrong size on OrionKismetLibrary_RotateVectorDegrees");
static_assert(offsetof(OrionKismetLibrary_RotateVectorDegrees, V0) == 0x000000, "Member 'OrionKismetLibrary_RotateVectorDegrees::V0' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_RotateVectorDegrees, Radians) == 0x000008, "Member 'OrionKismetLibrary_RotateVectorDegrees::Radians' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_RotateVectorDegrees, ReturnValue) == 0x00000C, "Member 'OrionKismetLibrary_RotateVectorDegrees::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.RotateVectorRadians
// 0x0014 (0x0014 - 0x0000)
struct OrionKismetLibrary_RotateVectorRadians final
{
public:
	struct FVector2D                              V0;                                                // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radians;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x000C(0x0008)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_RotateVectorRadians) == 0x000004, "Wrong alignment on OrionKismetLibrary_RotateVectorRadians");
static_assert(sizeof(OrionKismetLibrary_RotateVectorRadians) == 0x000014, "Wrong size on OrionKismetLibrary_RotateVectorRadians");
static_assert(offsetof(OrionKismetLibrary_RotateVectorRadians, V0) == 0x000000, "Member 'OrionKismetLibrary_RotateVectorRadians::V0' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_RotateVectorRadians, Radians) == 0x000008, "Member 'OrionKismetLibrary_RotateVectorRadians::Radians' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_RotateVectorRadians, ReturnValue) == 0x00000C, "Member 'OrionKismetLibrary_RotateVectorRadians::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.SetFilterContextAbility
// 0x0028 (0x0028 - 0x0000)
struct OrionKismetLibrary_SetFilterContextAbility final
{
public:
	struct FOrionFilterAndEffectsContainer        FilterContainer;                                   // 0x0000(0x0020)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UGameplayAbility*                       Ability;                                           // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_SetFilterContextAbility) == 0x000008, "Wrong alignment on OrionKismetLibrary_SetFilterContextAbility");
static_assert(sizeof(OrionKismetLibrary_SetFilterContextAbility) == 0x000028, "Wrong size on OrionKismetLibrary_SetFilterContextAbility");
static_assert(offsetof(OrionKismetLibrary_SetFilterContextAbility, FilterContainer) == 0x000000, "Member 'OrionKismetLibrary_SetFilterContextAbility::FilterContainer' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SetFilterContextAbility, Ability) == 0x000020, "Member 'OrionKismetLibrary_SetFilterContextAbility::Ability' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.SetFilterContextActors
// 0x0030 (0x0030 - 0x0000)
struct OrionKismetLibrary_SetFilterContextActors final
{
public:
	struct FOrionFilterAndEffectsContainer        FilterContainer;                                   // 0x0000(0x0020)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         InActors;                                          // 0x0020(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_SetFilterContextActors) == 0x000008, "Wrong alignment on OrionKismetLibrary_SetFilterContextActors");
static_assert(sizeof(OrionKismetLibrary_SetFilterContextActors) == 0x000030, "Wrong size on OrionKismetLibrary_SetFilterContextActors");
static_assert(offsetof(OrionKismetLibrary_SetFilterContextActors, FilterContainer) == 0x000000, "Member 'OrionKismetLibrary_SetFilterContextActors::FilterContainer' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SetFilterContextActors, InActors) == 0x000020, "Member 'OrionKismetLibrary_SetFilterContextActors::InActors' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.SetFilterContextHitResult
// 0x00A8 (0x00A8 - 0x0000)
struct OrionKismetLibrary_SetFilterContextHitResult final
{
public:
	struct FOrionFilterAndEffectsContainer        FilterContainer;                                   // 0x0000(0x0020)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FHitResult                             InHitResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_SetFilterContextHitResult) == 0x000008, "Wrong alignment on OrionKismetLibrary_SetFilterContextHitResult");
static_assert(sizeof(OrionKismetLibrary_SetFilterContextHitResult) == 0x0000A8, "Wrong size on OrionKismetLibrary_SetFilterContextHitResult");
static_assert(offsetof(OrionKismetLibrary_SetFilterContextHitResult, FilterContainer) == 0x000000, "Member 'OrionKismetLibrary_SetFilterContextHitResult::FilterContainer' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SetFilterContextHitResult, InHitResult) == 0x000020, "Member 'OrionKismetLibrary_SetFilterContextHitResult::InHitResult' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.SetFilterContextInstigator
// 0x0030 (0x0030 - 0x0000)
struct OrionKismetLibrary_SetFilterContextInstigator final
{
public:
	struct FOrionFilterAndEffectsContainer        FilterContainer;                                   // 0x0000(0x0020)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 InInstigator;                                      // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InEffectCauser;                                    // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_SetFilterContextInstigator) == 0x000008, "Wrong alignment on OrionKismetLibrary_SetFilterContextInstigator");
static_assert(sizeof(OrionKismetLibrary_SetFilterContextInstigator) == 0x000030, "Wrong size on OrionKismetLibrary_SetFilterContextInstigator");
static_assert(offsetof(OrionKismetLibrary_SetFilterContextInstigator, FilterContainer) == 0x000000, "Member 'OrionKismetLibrary_SetFilterContextInstigator::FilterContainer' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SetFilterContextInstigator, InInstigator) == 0x000020, "Member 'OrionKismetLibrary_SetFilterContextInstigator::InInstigator' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SetFilterContextInstigator, InEffectCauser) == 0x000028, "Member 'OrionKismetLibrary_SetFilterContextInstigator::InEffectCauser' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.SetFilterContextOrigin
// 0x0030 (0x0030 - 0x0000)
struct OrionKismetLibrary_SetFilterContextOrigin final
{
public:
	struct FOrionFilterAndEffectsContainer        FilterContainer;                                   // 0x0000(0x0020)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                InOrigin;                                          // 0x0020(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_SetFilterContextOrigin) == 0x000008, "Wrong alignment on OrionKismetLibrary_SetFilterContextOrigin");
static_assert(sizeof(OrionKismetLibrary_SetFilterContextOrigin) == 0x000030, "Wrong size on OrionKismetLibrary_SetFilterContextOrigin");
static_assert(offsetof(OrionKismetLibrary_SetFilterContextOrigin, FilterContainer) == 0x000000, "Member 'OrionKismetLibrary_SetFilterContextOrigin::FilterContainer' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SetFilterContextOrigin, InOrigin) == 0x000020, "Member 'OrionKismetLibrary_SetFilterContextOrigin::InOrigin' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.SetFilterContextSourceObject
// 0x0028 (0x0028 - 0x0000)
struct OrionKismetLibrary_SetFilterContextSourceObject final
{
public:
	struct FOrionFilterAndEffectsContainer        FilterContainer;                                   // 0x0000(0x0020)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	const class UObject*                          NewSourceObject;                                   // 0x0020(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_SetFilterContextSourceObject) == 0x000008, "Wrong alignment on OrionKismetLibrary_SetFilterContextSourceObject");
static_assert(sizeof(OrionKismetLibrary_SetFilterContextSourceObject) == 0x000028, "Wrong size on OrionKismetLibrary_SetFilterContextSourceObject");
static_assert(offsetof(OrionKismetLibrary_SetFilterContextSourceObject, FilterContainer) == 0x000000, "Member 'OrionKismetLibrary_SetFilterContextSourceObject::FilterContainer' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SetFilterContextSourceObject, NewSourceObject) == 0x000020, "Member 'OrionKismetLibrary_SetFilterContextSourceObject::NewSourceObject' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.SetFilterGameplayEffectLevel
// 0x0030 (0x0030 - 0x0000)
struct OrionKismetLibrary_SetFilterGameplayEffectLevel final
{
public:
	struct FOrionFilterAndEffectsContainer        FilterContainer;                                   // 0x0000(0x0020)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            InGE;                                              // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GameplayEffectLevel;                               // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_SetFilterGameplayEffectLevel) == 0x000008, "Wrong alignment on OrionKismetLibrary_SetFilterGameplayEffectLevel");
static_assert(sizeof(OrionKismetLibrary_SetFilterGameplayEffectLevel) == 0x000030, "Wrong size on OrionKismetLibrary_SetFilterGameplayEffectLevel");
static_assert(offsetof(OrionKismetLibrary_SetFilterGameplayEffectLevel, FilterContainer) == 0x000000, "Member 'OrionKismetLibrary_SetFilterGameplayEffectLevel::FilterContainer' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SetFilterGameplayEffectLevel, InGE) == 0x000020, "Member 'OrionKismetLibrary_SetFilterGameplayEffectLevel::InGE' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SetFilterGameplayEffectLevel, GameplayEffectLevel) == 0x000028, "Member 'OrionKismetLibrary_SetFilterGameplayEffectLevel::GameplayEffectLevel' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.SetFilterSetByCallerMagnitude
// 0x0038 (0x0038 - 0x0000)
struct OrionKismetLibrary_SetFilterSetByCallerMagnitude final
{
public:
	struct FOrionFilterAndEffectsContainer        FilterContainer;                                   // 0x0000(0x0020)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            InGE;                                              // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SetByCallerName;                                   // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Magnitude;                                         // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_SetFilterSetByCallerMagnitude) == 0x000008, "Wrong alignment on OrionKismetLibrary_SetFilterSetByCallerMagnitude");
static_assert(sizeof(OrionKismetLibrary_SetFilterSetByCallerMagnitude) == 0x000038, "Wrong size on OrionKismetLibrary_SetFilterSetByCallerMagnitude");
static_assert(offsetof(OrionKismetLibrary_SetFilterSetByCallerMagnitude, FilterContainer) == 0x000000, "Member 'OrionKismetLibrary_SetFilterSetByCallerMagnitude::FilterContainer' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SetFilterSetByCallerMagnitude, InGE) == 0x000020, "Member 'OrionKismetLibrary_SetFilterSetByCallerMagnitude::InGE' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SetFilterSetByCallerMagnitude, SetByCallerName) == 0x000028, "Member 'OrionKismetLibrary_SetFilterSetByCallerMagnitude::SetByCallerName' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SetFilterSetByCallerMagnitude, Magnitude) == 0x000030, "Member 'OrionKismetLibrary_SetFilterSetByCallerMagnitude::Magnitude' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.SetFilterStackCountForGameplayEffect
// 0x0030 (0x0030 - 0x0000)
struct OrionKismetLibrary_SetFilterStackCountForGameplayEffect final
{
public:
	struct FOrionFilterAndEffectsContainer        FilterContainer;                                   // 0x0000(0x0020)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            InGE;                                              // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InCount;                                           // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_SetFilterStackCountForGameplayEffect) == 0x000008, "Wrong alignment on OrionKismetLibrary_SetFilterStackCountForGameplayEffect");
static_assert(sizeof(OrionKismetLibrary_SetFilterStackCountForGameplayEffect) == 0x000030, "Wrong size on OrionKismetLibrary_SetFilterStackCountForGameplayEffect");
static_assert(offsetof(OrionKismetLibrary_SetFilterStackCountForGameplayEffect, FilterContainer) == 0x000000, "Member 'OrionKismetLibrary_SetFilterStackCountForGameplayEffect::FilterContainer' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SetFilterStackCountForGameplayEffect, InGE) == 0x000020, "Member 'OrionKismetLibrary_SetFilterStackCountForGameplayEffect::InGE' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SetFilterStackCountForGameplayEffect, InCount) == 0x000028, "Member 'OrionKismetLibrary_SetFilterStackCountForGameplayEffect::InCount' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.SetFilterTagSetByCallerMagnitude
// 0x0038 (0x0038 - 0x0000)
struct OrionKismetLibrary_SetFilterTagSetByCallerMagnitude final
{
public:
	struct FOrionFilterAndEffectsContainer        FilterContainer;                                   // 0x0000(0x0020)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            InGE;                                              // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SetByCallerTag;                                    // 0x0028(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Magnitude;                                         // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_SetFilterTagSetByCallerMagnitude) == 0x000008, "Wrong alignment on OrionKismetLibrary_SetFilterTagSetByCallerMagnitude");
static_assert(sizeof(OrionKismetLibrary_SetFilterTagSetByCallerMagnitude) == 0x000038, "Wrong size on OrionKismetLibrary_SetFilterTagSetByCallerMagnitude");
static_assert(offsetof(OrionKismetLibrary_SetFilterTagSetByCallerMagnitude, FilterContainer) == 0x000000, "Member 'OrionKismetLibrary_SetFilterTagSetByCallerMagnitude::FilterContainer' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SetFilterTagSetByCallerMagnitude, InGE) == 0x000020, "Member 'OrionKismetLibrary_SetFilterTagSetByCallerMagnitude::InGE' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SetFilterTagSetByCallerMagnitude, SetByCallerTag) == 0x000028, "Member 'OrionKismetLibrary_SetFilterTagSetByCallerMagnitude::SetByCallerTag' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SetFilterTagSetByCallerMagnitude, Magnitude) == 0x000030, "Member 'OrionKismetLibrary_SetFilterTagSetByCallerMagnitude::Magnitude' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.SetTeamBarrierCollision
// 0x0010 (0x0010 - 0x0000)
struct OrionKismetLibrary_SetTeamBarrierCollision final
{
public:
	class UPrimitiveComponent*                    Primitive;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    OwnerTeam;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_SetTeamBarrierCollision) == 0x000008, "Wrong alignment on OrionKismetLibrary_SetTeamBarrierCollision");
static_assert(sizeof(OrionKismetLibrary_SetTeamBarrierCollision) == 0x000010, "Wrong size on OrionKismetLibrary_SetTeamBarrierCollision");
static_assert(offsetof(OrionKismetLibrary_SetTeamBarrierCollision, Primitive) == 0x000000, "Member 'OrionKismetLibrary_SetTeamBarrierCollision::Primitive' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SetTeamBarrierCollision, OwnerTeam) == 0x000008, "Member 'OrionKismetLibrary_SetTeamBarrierCollision::OwnerTeam' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.ShouldShowRenderingAndResolutionSettings
// 0x0001 (0x0001 - 0x0000)
struct OrionKismetLibrary_ShouldShowRenderingAndResolutionSettings final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_ShouldShowRenderingAndResolutionSettings) == 0x000001, "Wrong alignment on OrionKismetLibrary_ShouldShowRenderingAndResolutionSettings");
static_assert(sizeof(OrionKismetLibrary_ShouldShowRenderingAndResolutionSettings) == 0x000001, "Wrong size on OrionKismetLibrary_ShouldShowRenderingAndResolutionSettings");
static_assert(offsetof(OrionKismetLibrary_ShouldShowRenderingAndResolutionSettings, ReturnValue) == 0x000000, "Member 'OrionKismetLibrary_ShouldShowRenderingAndResolutionSettings::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.SignedAngleBetweenInDegrees
// 0x0014 (0x0014 - 0x0000)
struct OrionKismetLibrary_SignedAngleBetweenInDegrees final
{
public:
	struct FVector2D                              V0;                                                // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              V1;                                                // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_SignedAngleBetweenInDegrees) == 0x000004, "Wrong alignment on OrionKismetLibrary_SignedAngleBetweenInDegrees");
static_assert(sizeof(OrionKismetLibrary_SignedAngleBetweenInDegrees) == 0x000014, "Wrong size on OrionKismetLibrary_SignedAngleBetweenInDegrees");
static_assert(offsetof(OrionKismetLibrary_SignedAngleBetweenInDegrees, V0) == 0x000000, "Member 'OrionKismetLibrary_SignedAngleBetweenInDegrees::V0' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SignedAngleBetweenInDegrees, V1) == 0x000008, "Member 'OrionKismetLibrary_SignedAngleBetweenInDegrees::V1' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SignedAngleBetweenInDegrees, ReturnValue) == 0x000010, "Member 'OrionKismetLibrary_SignedAngleBetweenInDegrees::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.SignedAngleBetweenInRadians
// 0x0014 (0x0014 - 0x0000)
struct OrionKismetLibrary_SignedAngleBetweenInRadians final
{
public:
	struct FVector2D                              V0;                                                // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              V1;                                                // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_SignedAngleBetweenInRadians) == 0x000004, "Wrong alignment on OrionKismetLibrary_SignedAngleBetweenInRadians");
static_assert(sizeof(OrionKismetLibrary_SignedAngleBetweenInRadians) == 0x000014, "Wrong size on OrionKismetLibrary_SignedAngleBetweenInRadians");
static_assert(offsetof(OrionKismetLibrary_SignedAngleBetweenInRadians, V0) == 0x000000, "Member 'OrionKismetLibrary_SignedAngleBetweenInRadians::V0' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SignedAngleBetweenInRadians, V1) == 0x000008, "Member 'OrionKismetLibrary_SignedAngleBetweenInRadians::V1' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SignedAngleBetweenInRadians, ReturnValue) == 0x000010, "Member 'OrionKismetLibrary_SignedAngleBetweenInRadians::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.SpawnCoins
// 0x0080 (0x0080 - 0x0000)
struct OrionKismetLibrary_SpawnCoins final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DesiredCoinsToSpawn;                               // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Owner;                                             // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            OwnerController;                                   // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 HomingActor;                                       // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    OwnerTeam;                                         // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SpawnLocation;                                     // 0x002C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  SourceTags;                                        // 0x0038(0x0020)(Parm, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  SourceAssetTags;                                   // 0x0058(0x0020)(Parm, NativeAccessSpecifierPublic)
	EOrionPickUpSpeed                             LaunchSpeed;                                       // 0x0078(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinCoinsToSpawnThreshold;                          // 0x007C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_SpawnCoins) == 0x000008, "Wrong alignment on OrionKismetLibrary_SpawnCoins");
static_assert(sizeof(OrionKismetLibrary_SpawnCoins) == 0x000080, "Wrong size on OrionKismetLibrary_SpawnCoins");
static_assert(offsetof(OrionKismetLibrary_SpawnCoins, WorldContextObject) == 0x000000, "Member 'OrionKismetLibrary_SpawnCoins::WorldContextObject' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SpawnCoins, DesiredCoinsToSpawn) == 0x000008, "Member 'OrionKismetLibrary_SpawnCoins::DesiredCoinsToSpawn' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SpawnCoins, Owner) == 0x000010, "Member 'OrionKismetLibrary_SpawnCoins::Owner' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SpawnCoins, OwnerController) == 0x000018, "Member 'OrionKismetLibrary_SpawnCoins::OwnerController' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SpawnCoins, HomingActor) == 0x000020, "Member 'OrionKismetLibrary_SpawnCoins::HomingActor' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SpawnCoins, OwnerTeam) == 0x000028, "Member 'OrionKismetLibrary_SpawnCoins::OwnerTeam' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SpawnCoins, SpawnLocation) == 0x00002C, "Member 'OrionKismetLibrary_SpawnCoins::SpawnLocation' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SpawnCoins, SourceTags) == 0x000038, "Member 'OrionKismetLibrary_SpawnCoins::SourceTags' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SpawnCoins, SourceAssetTags) == 0x000058, "Member 'OrionKismetLibrary_SpawnCoins::SourceAssetTags' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SpawnCoins, LaunchSpeed) == 0x000078, "Member 'OrionKismetLibrary_SpawnCoins::LaunchSpeed' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SpawnCoins, MinCoinsToSpawnThreshold) == 0x00007C, "Member 'OrionKismetLibrary_SpawnCoins::MinCoinsToSpawnThreshold' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.SpawnSoundOnActor
// 0x0020 (0x0020 - 0x0000)
struct OrionKismetLibrary_SpawnSoundOnActor final
{
public:
	class USoundBase*                             SoundToPlay;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SoundTarget;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Attached;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopWhenAttachedToDestroyed;                      // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        ReturnValue;                                       // 0x0018(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_SpawnSoundOnActor) == 0x000008, "Wrong alignment on OrionKismetLibrary_SpawnSoundOnActor");
static_assert(sizeof(OrionKismetLibrary_SpawnSoundOnActor) == 0x000020, "Wrong size on OrionKismetLibrary_SpawnSoundOnActor");
static_assert(offsetof(OrionKismetLibrary_SpawnSoundOnActor, SoundToPlay) == 0x000000, "Member 'OrionKismetLibrary_SpawnSoundOnActor::SoundToPlay' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SpawnSoundOnActor, SoundTarget) == 0x000008, "Member 'OrionKismetLibrary_SpawnSoundOnActor::SoundTarget' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SpawnSoundOnActor, Attached) == 0x000010, "Member 'OrionKismetLibrary_SpawnSoundOnActor::Attached' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SpawnSoundOnActor, bStopWhenAttachedToDestroyed) == 0x000011, "Member 'OrionKismetLibrary_SpawnSoundOnActor::bStopWhenAttachedToDestroyed' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SpawnSoundOnActor, ReturnValue) == 0x000018, "Member 'OrionKismetLibrary_SpawnSoundOnActor::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.SpawnSoundOnActorAtLocation
// 0x0028 (0x0028 - 0x0000)
struct OrionKismetLibrary_SpawnSoundOnActorAtLocation final
{
public:
	class USoundBase*                             SoundToPlay;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SoundTarget;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldLocation;                                     // 0x0010(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopWhenAttachedToDestroyed;                      // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        ReturnValue;                                       // 0x0020(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_SpawnSoundOnActorAtLocation) == 0x000008, "Wrong alignment on OrionKismetLibrary_SpawnSoundOnActorAtLocation");
static_assert(sizeof(OrionKismetLibrary_SpawnSoundOnActorAtLocation) == 0x000028, "Wrong size on OrionKismetLibrary_SpawnSoundOnActorAtLocation");
static_assert(offsetof(OrionKismetLibrary_SpawnSoundOnActorAtLocation, SoundToPlay) == 0x000000, "Member 'OrionKismetLibrary_SpawnSoundOnActorAtLocation::SoundToPlay' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SpawnSoundOnActorAtLocation, SoundTarget) == 0x000008, "Member 'OrionKismetLibrary_SpawnSoundOnActorAtLocation::SoundTarget' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SpawnSoundOnActorAtLocation, WorldLocation) == 0x000010, "Member 'OrionKismetLibrary_SpawnSoundOnActorAtLocation::WorldLocation' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SpawnSoundOnActorAtLocation, bStopWhenAttachedToDestroyed) == 0x00001C, "Member 'OrionKismetLibrary_SpawnSoundOnActorAtLocation::bStopWhenAttachedToDestroyed' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SpawnSoundOnActorAtLocation, ReturnValue) == 0x000020, "Member 'OrionKismetLibrary_SpawnSoundOnActorAtLocation::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.SpawnSoundTeamAdjusted
// 0x0028 (0x0028 - 0x0000)
struct OrionKismetLibrary_SpawnSoundTeamAdjusted final
{
public:
	class USoundBase*                             SoundToPlay;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SoundInstigator;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SoundTarget;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceCreateAudioComponent;                        // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopWhenDestroyed;                                // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        ReturnValue;                                       // 0x0020(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_SpawnSoundTeamAdjusted) == 0x000008, "Wrong alignment on OrionKismetLibrary_SpawnSoundTeamAdjusted");
static_assert(sizeof(OrionKismetLibrary_SpawnSoundTeamAdjusted) == 0x000028, "Wrong size on OrionKismetLibrary_SpawnSoundTeamAdjusted");
static_assert(offsetof(OrionKismetLibrary_SpawnSoundTeamAdjusted, SoundToPlay) == 0x000000, "Member 'OrionKismetLibrary_SpawnSoundTeamAdjusted::SoundToPlay' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SpawnSoundTeamAdjusted, SoundInstigator) == 0x000008, "Member 'OrionKismetLibrary_SpawnSoundTeamAdjusted::SoundInstigator' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SpawnSoundTeamAdjusted, SoundTarget) == 0x000010, "Member 'OrionKismetLibrary_SpawnSoundTeamAdjusted::SoundTarget' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SpawnSoundTeamAdjusted, bForceCreateAudioComponent) == 0x000018, "Member 'OrionKismetLibrary_SpawnSoundTeamAdjusted::bForceCreateAudioComponent' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SpawnSoundTeamAdjusted, bStopWhenDestroyed) == 0x000019, "Member 'OrionKismetLibrary_SpawnSoundTeamAdjusted::bStopWhenDestroyed' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SpawnSoundTeamAdjusted, ReturnValue) == 0x000020, "Member 'OrionKismetLibrary_SpawnSoundTeamAdjusted::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.SpawnSoundTeamAdjustedAtLocation
// 0x0030 (0x0030 - 0x0000)
struct OrionKismetLibrary_SpawnSoundTeamAdjustedAtLocation final
{
public:
	class USoundBase*                             SoundToPlay;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SoundInstigator;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SoundTarget;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldLocation;                                     // 0x0018(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopWhenAttachedToDestroyed;                      // 0x0024(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        ReturnValue;                                       // 0x0028(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_SpawnSoundTeamAdjustedAtLocation) == 0x000008, "Wrong alignment on OrionKismetLibrary_SpawnSoundTeamAdjustedAtLocation");
static_assert(sizeof(OrionKismetLibrary_SpawnSoundTeamAdjustedAtLocation) == 0x000030, "Wrong size on OrionKismetLibrary_SpawnSoundTeamAdjustedAtLocation");
static_assert(offsetof(OrionKismetLibrary_SpawnSoundTeamAdjustedAtLocation, SoundToPlay) == 0x000000, "Member 'OrionKismetLibrary_SpawnSoundTeamAdjustedAtLocation::SoundToPlay' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SpawnSoundTeamAdjustedAtLocation, SoundInstigator) == 0x000008, "Member 'OrionKismetLibrary_SpawnSoundTeamAdjustedAtLocation::SoundInstigator' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SpawnSoundTeamAdjustedAtLocation, SoundTarget) == 0x000010, "Member 'OrionKismetLibrary_SpawnSoundTeamAdjustedAtLocation::SoundTarget' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SpawnSoundTeamAdjustedAtLocation, WorldLocation) == 0x000018, "Member 'OrionKismetLibrary_SpawnSoundTeamAdjustedAtLocation::WorldLocation' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SpawnSoundTeamAdjustedAtLocation, bStopWhenAttachedToDestroyed) == 0x000024, "Member 'OrionKismetLibrary_SpawnSoundTeamAdjustedAtLocation::bStopWhenAttachedToDestroyed' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SpawnSoundTeamAdjustedAtLocation, ReturnValue) == 0x000028, "Member 'OrionKismetLibrary_SpawnSoundTeamAdjustedAtLocation::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.SplitGameplayEffectSpecBetweenActors
// 0x0048 (0x0048 - 0x0000)
struct OrionKismetLibrary_SplitGameplayEffectSpecBetweenActors final
{
public:
	struct FGameplayEffectSpecHandle              SpecHandle;                                        // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         TargetActors;                                      // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class FName>                           DataNames;                                         // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FActiveGameplayEffectHandle>    AppliedEffectHandles;                              // 0x0038(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_SplitGameplayEffectSpecBetweenActors) == 0x000008, "Wrong alignment on OrionKismetLibrary_SplitGameplayEffectSpecBetweenActors");
static_assert(sizeof(OrionKismetLibrary_SplitGameplayEffectSpecBetweenActors) == 0x000048, "Wrong size on OrionKismetLibrary_SplitGameplayEffectSpecBetweenActors");
static_assert(offsetof(OrionKismetLibrary_SplitGameplayEffectSpecBetweenActors, SpecHandle) == 0x000000, "Member 'OrionKismetLibrary_SplitGameplayEffectSpecBetweenActors::SpecHandle' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SplitGameplayEffectSpecBetweenActors, TargetActors) == 0x000018, "Member 'OrionKismetLibrary_SplitGameplayEffectSpecBetweenActors::TargetActors' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SplitGameplayEffectSpecBetweenActors, DataNames) == 0x000028, "Member 'OrionKismetLibrary_SplitGameplayEffectSpecBetweenActors::DataNames' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SplitGameplayEffectSpecBetweenActors, AppliedEffectHandles) == 0x000038, "Member 'OrionKismetLibrary_SplitGameplayEffectSpecBetweenActors::AppliedEffectHandles' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.SplitGameplayEffectSpecBetweenTargetData
// 0x0058 (0x0058 - 0x0000)
struct OrionKismetLibrary_SplitGameplayEffectSpecBetweenTargetData final
{
public:
	struct FGameplayEffectSpecHandle              SpecHandle;                                        // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetDataHandle;                                  // 0x0018(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class FName>                           DataNames;                                         // 0x0038(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FActiveGameplayEffectHandle>    AppliedEffectHandles;                              // 0x0048(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_SplitGameplayEffectSpecBetweenTargetData) == 0x000008, "Wrong alignment on OrionKismetLibrary_SplitGameplayEffectSpecBetweenTargetData");
static_assert(sizeof(OrionKismetLibrary_SplitGameplayEffectSpecBetweenTargetData) == 0x000058, "Wrong size on OrionKismetLibrary_SplitGameplayEffectSpecBetweenTargetData");
static_assert(offsetof(OrionKismetLibrary_SplitGameplayEffectSpecBetweenTargetData, SpecHandle) == 0x000000, "Member 'OrionKismetLibrary_SplitGameplayEffectSpecBetweenTargetData::SpecHandle' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SplitGameplayEffectSpecBetweenTargetData, TargetDataHandle) == 0x000018, "Member 'OrionKismetLibrary_SplitGameplayEffectSpecBetweenTargetData::TargetDataHandle' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SplitGameplayEffectSpecBetweenTargetData, DataNames) == 0x000038, "Member 'OrionKismetLibrary_SplitGameplayEffectSpecBetweenTargetData::DataNames' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SplitGameplayEffectSpecBetweenTargetData, AppliedEffectHandles) == 0x000048, "Member 'OrionKismetLibrary_SplitGameplayEffectSpecBetweenTargetData::AppliedEffectHandles' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.SplitTargetData
// 0x0030 (0x0030 - 0x0000)
struct OrionKismetLibrary_SplitTargetData final
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetData;                                        // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FGameplayAbilityTargetDataHandle> ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_SplitTargetData) == 0x000008, "Wrong alignment on OrionKismetLibrary_SplitTargetData");
static_assert(sizeof(OrionKismetLibrary_SplitTargetData) == 0x000030, "Wrong size on OrionKismetLibrary_SplitTargetData");
static_assert(offsetof(OrionKismetLibrary_SplitTargetData, TargetData) == 0x000000, "Member 'OrionKismetLibrary_SplitTargetData::TargetData' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_SplitTargetData, ReturnValue) == 0x000020, "Member 'OrionKismetLibrary_SplitTargetData::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.StopCameraAnimOnActor
// 0x0010 (0x0010 - 0x0000)
struct OrionKismetLibrary_StopCameraAnimOnActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraAnim*                            AnimToStop;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_StopCameraAnimOnActor) == 0x000008, "Wrong alignment on OrionKismetLibrary_StopCameraAnimOnActor");
static_assert(sizeof(OrionKismetLibrary_StopCameraAnimOnActor) == 0x000010, "Wrong size on OrionKismetLibrary_StopCameraAnimOnActor");
static_assert(offsetof(OrionKismetLibrary_StopCameraAnimOnActor, Actor) == 0x000000, "Member 'OrionKismetLibrary_StopCameraAnimOnActor::Actor' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_StopCameraAnimOnActor, AnimToStop) == 0x000008, "Member 'OrionKismetLibrary_StopCameraAnimOnActor::AnimToStop' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.StopCameraShakeOnActor
// 0x0018 (0x0018 - 0x0000)
struct OrionKismetLibrary_StopCameraShakeOnActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraShake>               Shake;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImmediately;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionKismetLibrary_StopCameraShakeOnActor) == 0x000008, "Wrong alignment on OrionKismetLibrary_StopCameraShakeOnActor");
static_assert(sizeof(OrionKismetLibrary_StopCameraShakeOnActor) == 0x000018, "Wrong size on OrionKismetLibrary_StopCameraShakeOnActor");
static_assert(offsetof(OrionKismetLibrary_StopCameraShakeOnActor, Actor) == 0x000000, "Member 'OrionKismetLibrary_StopCameraShakeOnActor::Actor' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_StopCameraShakeOnActor, Shake) == 0x000008, "Member 'OrionKismetLibrary_StopCameraShakeOnActor::Shake' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_StopCameraShakeOnActor, bImmediately) == 0x000010, "Member 'OrionKismetLibrary_StopCameraShakeOnActor::bImmediately' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.StopForceFeedbackOnActor
// 0x0018 (0x0018 - 0x0000)
struct OrionKismetLibrary_StopForceFeedbackOnActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   ForceFeedbackEffect;                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_StopForceFeedbackOnActor) == 0x000008, "Wrong alignment on OrionKismetLibrary_StopForceFeedbackOnActor");
static_assert(sizeof(OrionKismetLibrary_StopForceFeedbackOnActor) == 0x000018, "Wrong size on OrionKismetLibrary_StopForceFeedbackOnActor");
static_assert(offsetof(OrionKismetLibrary_StopForceFeedbackOnActor, Actor) == 0x000000, "Member 'OrionKismetLibrary_StopForceFeedbackOnActor::Actor' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_StopForceFeedbackOnActor, ForceFeedbackEffect) == 0x000008, "Member 'OrionKismetLibrary_StopForceFeedbackOnActor::ForceFeedbackEffect' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_StopForceFeedbackOnActor, Tag) == 0x000010, "Member 'OrionKismetLibrary_StopForceFeedbackOnActor::Tag' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.TagSplitGameplayEffectSpecBetweenActors
// 0x0058 (0x0058 - 0x0000)
struct OrionKismetLibrary_TagSplitGameplayEffectSpecBetweenActors final
{
public:
	struct FGameplayEffectSpecHandle              SpecHandle;                                        // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         TargetActors;                                      // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  DataTags;                                          // 0x0028(0x0020)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FActiveGameplayEffectHandle>    AppliedEffectHandles;                              // 0x0048(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_TagSplitGameplayEffectSpecBetweenActors) == 0x000008, "Wrong alignment on OrionKismetLibrary_TagSplitGameplayEffectSpecBetweenActors");
static_assert(sizeof(OrionKismetLibrary_TagSplitGameplayEffectSpecBetweenActors) == 0x000058, "Wrong size on OrionKismetLibrary_TagSplitGameplayEffectSpecBetweenActors");
static_assert(offsetof(OrionKismetLibrary_TagSplitGameplayEffectSpecBetweenActors, SpecHandle) == 0x000000, "Member 'OrionKismetLibrary_TagSplitGameplayEffectSpecBetweenActors::SpecHandle' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_TagSplitGameplayEffectSpecBetweenActors, TargetActors) == 0x000018, "Member 'OrionKismetLibrary_TagSplitGameplayEffectSpecBetweenActors::TargetActors' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_TagSplitGameplayEffectSpecBetweenActors, DataTags) == 0x000028, "Member 'OrionKismetLibrary_TagSplitGameplayEffectSpecBetweenActors::DataTags' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_TagSplitGameplayEffectSpecBetweenActors, AppliedEffectHandles) == 0x000048, "Member 'OrionKismetLibrary_TagSplitGameplayEffectSpecBetweenActors::AppliedEffectHandles' has a wrong offset!");

// Function OrionGame.OrionKismetLibrary.TagSplitGameplayEffectSpecBetweenTargetData
// 0x0068 (0x0068 - 0x0000)
struct OrionKismetLibrary_TagSplitGameplayEffectSpecBetweenTargetData final
{
public:
	struct FGameplayEffectSpecHandle              SpecHandle;                                        // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetDataHandle;                                  // 0x0018(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  DataTags;                                          // 0x0038(0x0020)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FActiveGameplayEffectHandle>    AppliedEffectHandles;                              // 0x0058(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionKismetLibrary_TagSplitGameplayEffectSpecBetweenTargetData) == 0x000008, "Wrong alignment on OrionKismetLibrary_TagSplitGameplayEffectSpecBetweenTargetData");
static_assert(sizeof(OrionKismetLibrary_TagSplitGameplayEffectSpecBetweenTargetData) == 0x000068, "Wrong size on OrionKismetLibrary_TagSplitGameplayEffectSpecBetweenTargetData");
static_assert(offsetof(OrionKismetLibrary_TagSplitGameplayEffectSpecBetweenTargetData, SpecHandle) == 0x000000, "Member 'OrionKismetLibrary_TagSplitGameplayEffectSpecBetweenTargetData::SpecHandle' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_TagSplitGameplayEffectSpecBetweenTargetData, TargetDataHandle) == 0x000018, "Member 'OrionKismetLibrary_TagSplitGameplayEffectSpecBetweenTargetData::TargetDataHandle' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_TagSplitGameplayEffectSpecBetweenTargetData, DataTags) == 0x000038, "Member 'OrionKismetLibrary_TagSplitGameplayEffectSpecBetweenTargetData::DataTags' has a wrong offset!");
static_assert(offsetof(OrionKismetLibrary_TagSplitGameplayEffectSpecBetweenTargetData, AppliedEffectHandles) == 0x000058, "Member 'OrionKismetLibrary_TagSplitGameplayEffectSpecBetweenTargetData::AppliedEffectHandles' has a wrong offset!");

// Function OrionGame.OrionListItem.RegisterOnClicked
// 0x0010 (0x0010 - 0x0000)
struct OrionListItem_RegisterOnClicked final
{
public:
	TDelegate<void(class UUserWidget* Widget)>    Callback;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionListItem_RegisterOnClicked) == 0x000004, "Wrong alignment on OrionListItem_RegisterOnClicked");
static_assert(sizeof(OrionListItem_RegisterOnClicked) == 0x000010, "Wrong size on OrionListItem_RegisterOnClicked");
static_assert(offsetof(OrionListItem_RegisterOnClicked, Callback) == 0x000000, "Member 'OrionListItem_RegisterOnClicked::Callback' has a wrong offset!");

// Function OrionGame.OrionListItem.RegisterOnHovered
// 0x0010 (0x0010 - 0x0000)
struct OrionListItem_RegisterOnHovered final
{
public:
	TDelegate<void(class UUserWidget* Widget, bool bIsHovered)> Callback;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionListItem_RegisterOnHovered) == 0x000004, "Wrong alignment on OrionListItem_RegisterOnHovered");
static_assert(sizeof(OrionListItem_RegisterOnHovered) == 0x000010, "Wrong size on OrionListItem_RegisterOnHovered");
static_assert(offsetof(OrionListItem_RegisterOnHovered, Callback) == 0x000000, "Member 'OrionListItem_RegisterOnHovered::Callback' has a wrong offset!");

// Function OrionGame.OrionListItem.SetIndexInList
// 0x0004 (0x0004 - 0x0000)
struct OrionListItem_SetIndexInList final
{
public:
	int32                                         InIndexInList;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionListItem_SetIndexInList) == 0x000004, "Wrong alignment on OrionListItem_SetIndexInList");
static_assert(sizeof(OrionListItem_SetIndexInList) == 0x000004, "Wrong size on OrionListItem_SetIndexInList");
static_assert(offsetof(OrionListItem_SetIndexInList, InIndexInList) == 0x000000, "Member 'OrionListItem_SetIndexInList::InIndexInList' has a wrong offset!");

// Function OrionGame.OrionListItem.SetSelected
// 0x0001 (0x0001 - 0x0000)
struct OrionListItem_SetSelected final
{
public:
	bool                                          bSelected;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionListItem_SetSelected) == 0x000001, "Wrong alignment on OrionListItem_SetSelected");
static_assert(sizeof(OrionListItem_SetSelected) == 0x000001, "Wrong size on OrionListItem_SetSelected");
static_assert(offsetof(OrionListItem_SetSelected, bSelected) == 0x000000, "Member 'OrionListItem_SetSelected::bSelected' has a wrong offset!");

// Function OrionGame.OrionListItem.DoesItemHaveChildren
// 0x0004 (0x0004 - 0x0000)
struct OrionListItem_DoesItemHaveChildren final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionListItem_DoesItemHaveChildren) == 0x000004, "Wrong alignment on OrionListItem_DoesItemHaveChildren");
static_assert(sizeof(OrionListItem_DoesItemHaveChildren) == 0x000004, "Wrong size on OrionListItem_DoesItemHaveChildren");
static_assert(offsetof(OrionListItem_DoesItemHaveChildren, ReturnValue) == 0x000000, "Member 'OrionListItem_DoesItemHaveChildren::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionListItem.GetIndentLevel
// 0x0004 (0x0004 - 0x0000)
struct OrionListItem_GetIndentLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionListItem_GetIndentLevel) == 0x000004, "Wrong alignment on OrionListItem_GetIndentLevel");
static_assert(sizeof(OrionListItem_GetIndentLevel) == 0x000004, "Wrong size on OrionListItem_GetIndentLevel");
static_assert(offsetof(OrionListItem_GetIndentLevel, ReturnValue) == 0x000000, "Member 'OrionListItem_GetIndentLevel::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionListItem.GetSelectionMode
// 0x0001 (0x0001 - 0x0000)
struct OrionListItem_GetSelectionMode final
{
public:
	ESelectionMode                                ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionListItem_GetSelectionMode) == 0x000001, "Wrong alignment on OrionListItem_GetSelectionMode");
static_assert(sizeof(OrionListItem_GetSelectionMode) == 0x000001, "Wrong size on OrionListItem_GetSelectionMode");
static_assert(offsetof(OrionListItem_GetSelectionMode, ReturnValue) == 0x000000, "Member 'OrionListItem_GetSelectionMode::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionListItem.IsItemExpanded
// 0x0001 (0x0001 - 0x0000)
struct OrionListItem_IsItemExpanded final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionListItem_IsItemExpanded) == 0x000001, "Wrong alignment on OrionListItem_IsItemExpanded");
static_assert(sizeof(OrionListItem_IsItemExpanded) == 0x000001, "Wrong size on OrionListItem_IsItemExpanded");
static_assert(offsetof(OrionListItem_IsItemExpanded, ReturnValue) == 0x000000, "Member 'OrionListItem_IsItemExpanded::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionLoadingActor.OnSetSlotIndex
// 0x0004 (0x0004 - 0x0000)
struct OrionLoadingActor_OnSetSlotIndex final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionLoadingActor_OnSetSlotIndex) == 0x000004, "Wrong alignment on OrionLoadingActor_OnSetSlotIndex");
static_assert(sizeof(OrionLoadingActor_OnSetSlotIndex) == 0x000004, "Wrong size on OrionLoadingActor_OnSetSlotIndex");
static_assert(offsetof(OrionLoadingActor_OnSetSlotIndex, SlotIndex) == 0x000000, "Member 'OrionLoadingActor_OnSetSlotIndex::SlotIndex' has a wrong offset!");

// Function OrionGame.OrionLoadingScreen.OnLoadingScreenShown
// 0x0001 (0x0001 - 0x0000)
struct OrionLoadingScreen_OnLoadingScreenShown final
{
public:
	bool                                          bIsUsingFallback;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionLoadingScreen_OnLoadingScreenShown) == 0x000001, "Wrong alignment on OrionLoadingScreen_OnLoadingScreenShown");
static_assert(sizeof(OrionLoadingScreen_OnLoadingScreenShown) == 0x000001, "Wrong size on OrionLoadingScreen_OnLoadingScreenShown");
static_assert(offsetof(OrionLoadingScreen_OnLoadingScreenShown, bIsUsingFallback) == 0x000000, "Member 'OrionLoadingScreen_OnLoadingScreenShown::bIsUsingFallback' has a wrong offset!");

// Function OrionGame.OrionMatchmakingDisplayLibrary.GetBanReasonText
// 0x0020 (0x0020 - 0x0000)
struct OrionMatchmakingDisplayLibrary_GetBanReasonText final
{
public:
	EOrionBanReason                               BanReason;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   OutText;                                           // 0x0008(0x0018)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMatchmakingDisplayLibrary_GetBanReasonText) == 0x000008, "Wrong alignment on OrionMatchmakingDisplayLibrary_GetBanReasonText");
static_assert(sizeof(OrionMatchmakingDisplayLibrary_GetBanReasonText) == 0x000020, "Wrong size on OrionMatchmakingDisplayLibrary_GetBanReasonText");
static_assert(offsetof(OrionMatchmakingDisplayLibrary_GetBanReasonText, BanReason) == 0x000000, "Member 'OrionMatchmakingDisplayLibrary_GetBanReasonText::BanReason' has a wrong offset!");
static_assert(offsetof(OrionMatchmakingDisplayLibrary_GetBanReasonText, OutText) == 0x000008, "Member 'OrionMatchmakingDisplayLibrary_GetBanReasonText::OutText' has a wrong offset!");

// Function OrionGame.OrionMatchmakingDisplayLibrary.GetHeroAvailabilityText
// 0x0028 (0x0028 - 0x0000)
struct OrionMatchmakingDisplayLibrary_GetHeroAvailabilityText final
{
public:
	EOrionHeroAvailability                        Availability;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UOrionHeroData*                   HeroData;                                          // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   OutText;                                           // 0x0010(0x0018)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMatchmakingDisplayLibrary_GetHeroAvailabilityText) == 0x000008, "Wrong alignment on OrionMatchmakingDisplayLibrary_GetHeroAvailabilityText");
static_assert(sizeof(OrionMatchmakingDisplayLibrary_GetHeroAvailabilityText) == 0x000028, "Wrong size on OrionMatchmakingDisplayLibrary_GetHeroAvailabilityText");
static_assert(offsetof(OrionMatchmakingDisplayLibrary_GetHeroAvailabilityText, Availability) == 0x000000, "Member 'OrionMatchmakingDisplayLibrary_GetHeroAvailabilityText::Availability' has a wrong offset!");
static_assert(offsetof(OrionMatchmakingDisplayLibrary_GetHeroAvailabilityText, HeroData) == 0x000008, "Member 'OrionMatchmakingDisplayLibrary_GetHeroAvailabilityText::HeroData' has a wrong offset!");
static_assert(offsetof(OrionMatchmakingDisplayLibrary_GetHeroAvailabilityText, OutText) == 0x000010, "Member 'OrionMatchmakingDisplayLibrary_GetHeroAvailabilityText::OutText' has a wrong offset!");

// Function OrionGame.OrionMatchmakingDisplayLibrary.GetTeamColor
// 0x0014 (0x0014 - 0x0000)
struct OrionMatchmakingDisplayLibrary_GetTeamColor final
{
public:
	EOrionTeamMemberType                          TeamMemberType;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           TeamColor;                                         // 0x0004(0x0010)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMatchmakingDisplayLibrary_GetTeamColor) == 0x000004, "Wrong alignment on OrionMatchmakingDisplayLibrary_GetTeamColor");
static_assert(sizeof(OrionMatchmakingDisplayLibrary_GetTeamColor) == 0x000014, "Wrong size on OrionMatchmakingDisplayLibrary_GetTeamColor");
static_assert(offsetof(OrionMatchmakingDisplayLibrary_GetTeamColor, TeamMemberType) == 0x000000, "Member 'OrionMatchmakingDisplayLibrary_GetTeamColor::TeamMemberType' has a wrong offset!");
static_assert(offsetof(OrionMatchmakingDisplayLibrary_GetTeamColor, TeamColor) == 0x000004, "Member 'OrionMatchmakingDisplayLibrary_GetTeamColor::TeamColor' has a wrong offset!");

// Function OrionGame.OrionMcpBannerAlterationItem.GetInternalData
// 0x0008 (0x0008 - 0x0000)
struct OrionMcpBannerAlterationItem_GetInternalData final
{
public:
	class UOrionMcpBannerAlterationItemDefinition* ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpBannerAlterationItem_GetInternalData) == 0x000008, "Wrong alignment on OrionMcpBannerAlterationItem_GetInternalData");
static_assert(sizeof(OrionMcpBannerAlterationItem_GetInternalData) == 0x000008, "Wrong size on OrionMcpBannerAlterationItem_GetInternalData");
static_assert(offsetof(OrionMcpBannerAlterationItem_GetInternalData, ReturnValue) == 0x000000, "Member 'OrionMcpBannerAlterationItem_GetInternalData::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionMcpBannerItem.GetInternalData
// 0x0008 (0x0008 - 0x0000)
struct OrionMcpBannerItem_GetInternalData final
{
public:
	class UOrionMcpBannerItemDefinition*          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpBannerItem_GetInternalData) == 0x000008, "Wrong alignment on OrionMcpBannerItem_GetInternalData");
static_assert(sizeof(OrionMcpBannerItem_GetInternalData) == 0x000008, "Wrong size on OrionMcpBannerItem_GetInternalData");
static_assert(offsetof(OrionMcpBannerItem_GetInternalData, ReturnValue) == 0x000000, "Member 'OrionMcpBannerItem_GetInternalData::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionMcpBoostItem.GetInternalData
// 0x0008 (0x0008 - 0x0000)
struct OrionMcpBoostItem_GetInternalData final
{
public:
	class UOrionBoostItemDefinition*              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpBoostItem_GetInternalData) == 0x000008, "Wrong alignment on OrionMcpBoostItem_GetInternalData");
static_assert(sizeof(OrionMcpBoostItem_GetInternalData) == 0x000008, "Wrong size on OrionMcpBoostItem_GetInternalData");
static_assert(offsetof(OrionMcpBoostItem_GetInternalData, ReturnValue) == 0x000000, "Member 'OrionMcpBoostItem_GetInternalData::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionMcpCardItem.GetInternalData
// 0x0008 (0x0008 - 0x0000)
struct OrionMcpCardItem_GetInternalData final
{
public:
	class UOrionMcpCardItemDefinition*            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpCardItem_GetInternalData) == 0x000008, "Wrong alignment on OrionMcpCardItem_GetInternalData");
static_assert(sizeof(OrionMcpCardItem_GetInternalData) == 0x000008, "Wrong size on OrionMcpCardItem_GetInternalData");
static_assert(offsetof(OrionMcpCardItem_GetInternalData, ReturnValue) == 0x000000, "Member 'OrionMcpCardItem_GetInternalData::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionMcpCardItemDefinition.GetAffinity
// 0x0001 (0x0001 - 0x0000)
struct OrionMcpCardItemDefinition_GetAffinity final
{
public:
	EAffinityType                                 ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpCardItemDefinition_GetAffinity) == 0x000001, "Wrong alignment on OrionMcpCardItemDefinition_GetAffinity");
static_assert(sizeof(OrionMcpCardItemDefinition_GetAffinity) == 0x000001, "Wrong size on OrionMcpCardItemDefinition_GetAffinity");
static_assert(offsetof(OrionMcpCardItemDefinition_GetAffinity, ReturnValue) == 0x000000, "Member 'OrionMcpCardItemDefinition_GetAffinity::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionMcpCardPackItem.GetInternalData
// 0x0008 (0x0008 - 0x0000)
struct OrionMcpCardPackItem_GetInternalData final
{
public:
	class UOrionMcpCardPackItemDefinition*        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpCardPackItem_GetInternalData) == 0x000008, "Wrong alignment on OrionMcpCardPackItem_GetInternalData");
static_assert(sizeof(OrionMcpCardPackItem_GetInternalData) == 0x000008, "Wrong size on OrionMcpCardPackItem_GetInternalData");
static_assert(offsetof(OrionMcpCardPackItem_GetInternalData, ReturnValue) == 0x000000, "Member 'OrionMcpCardPackItem_GetInternalData::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionMcpCodeTokenItem.GetInternalData
// 0x0008 (0x0008 - 0x0000)
struct OrionMcpCodeTokenItem_GetInternalData final
{
public:
	class UOrionMcpCodeTokenItemDefinition*       ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpCodeTokenItem_GetInternalData) == 0x000008, "Wrong alignment on OrionMcpCodeTokenItem_GetInternalData");
static_assert(sizeof(OrionMcpCodeTokenItem_GetInternalData) == 0x000008, "Wrong size on OrionMcpCodeTokenItem_GetInternalData");
static_assert(offsetof(OrionMcpCodeTokenItem_GetInternalData, ReturnValue) == 0x000000, "Member 'OrionMcpCodeTokenItem_GetInternalData::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionEmoteItemDefinition.GetAnimMontage
// 0x0010 (0x0010 - 0x0000)
struct OrionEmoteItemDefinition_GetAnimMontage final
{
public:
	const class UOrionSkinItemDefinition*         SkinItemDefinition;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionEmoteItemDefinition_GetAnimMontage) == 0x000008, "Wrong alignment on OrionEmoteItemDefinition_GetAnimMontage");
static_assert(sizeof(OrionEmoteItemDefinition_GetAnimMontage) == 0x000010, "Wrong size on OrionEmoteItemDefinition_GetAnimMontage");
static_assert(offsetof(OrionEmoteItemDefinition_GetAnimMontage, SkinItemDefinition) == 0x000000, "Member 'OrionEmoteItemDefinition_GetAnimMontage::SkinItemDefinition' has a wrong offset!");
static_assert(offsetof(OrionEmoteItemDefinition_GetAnimMontage, ReturnValue) == 0x000008, "Member 'OrionEmoteItemDefinition_GetAnimMontage::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionMcpGiftBoxItem.GetInternalData
// 0x0008 (0x0008 - 0x0000)
struct OrionMcpGiftBoxItem_GetInternalData final
{
public:
	class UOrionMcpGiftBoxItemDefinition*         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpGiftBoxItem_GetInternalData) == 0x000008, "Wrong alignment on OrionMcpGiftBoxItem_GetInternalData");
static_assert(sizeof(OrionMcpGiftBoxItem_GetInternalData) == 0x000008, "Wrong size on OrionMcpGiftBoxItem_GetInternalData");
static_assert(offsetof(OrionMcpGiftBoxItem_GetInternalData, ReturnValue) == 0x000000, "Member 'OrionMcpGiftBoxItem_GetInternalData::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionMcpGlyphItem.GetInternalData
// 0x0008 (0x0008 - 0x0000)
struct OrionMcpGlyphItem_GetInternalData final
{
public:
	class UOrionMcpGlyphItemDefinition*           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpGlyphItem_GetInternalData) == 0x000008, "Wrong alignment on OrionMcpGlyphItem_GetInternalData");
static_assert(sizeof(OrionMcpGlyphItem_GetInternalData) == 0x000008, "Wrong size on OrionMcpGlyphItem_GetInternalData");
static_assert(offsetof(OrionMcpGlyphItem_GetInternalData, ReturnValue) == 0x000000, "Member 'OrionMcpGlyphItem_GetInternalData::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionMcpHeroItem.GetInternalData
// 0x0008 (0x0008 - 0x0000)
struct OrionMcpHeroItem_GetInternalData final
{
public:
	class UOrionHeroData*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpHeroItem_GetInternalData) == 0x000008, "Wrong alignment on OrionMcpHeroItem_GetInternalData");
static_assert(sizeof(OrionMcpHeroItem_GetInternalData) == 0x000008, "Wrong size on OrionMcpHeroItem_GetInternalData");
static_assert(offsetof(OrionMcpHeroItem_GetInternalData, ReturnValue) == 0x000000, "Member 'OrionMcpHeroItem_GetInternalData::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionMcpProfileAccount.ActivateBoost
// 0x0070 (0x0070 - 0x0000)
struct OrionMcpProfileAccount_ActivateBoost final
{
public:
	class FString                                 BoostId;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FClientUrlContext                      Context;                                           // 0x0010(0x0060)(Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpProfileAccount_ActivateBoost) == 0x000010, "Wrong alignment on OrionMcpProfileAccount_ActivateBoost");
static_assert(sizeof(OrionMcpProfileAccount_ActivateBoost) == 0x000070, "Wrong size on OrionMcpProfileAccount_ActivateBoost");
static_assert(offsetof(OrionMcpProfileAccount_ActivateBoost, BoostId) == 0x000000, "Member 'OrionMcpProfileAccount_ActivateBoost::BoostId' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_ActivateBoost, Context) == 0x000010, "Member 'OrionMcpProfileAccount_ActivateBoost::Context' has a wrong offset!");

// Function OrionGame.OrionMcpProfileAccount.ApplyBannerAlteration
// 0x0090 (0x0090 - 0x0000)
struct OrionMcpProfileAccount_ApplyBannerAlteration final
{
public:
	class FString                                 bannerId;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AlterationId;                                      // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AlterationSlot;                                    // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0xC];                                       // 0x0024(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FClientUrlContext                      Context;                                           // 0x0030(0x0060)(Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpProfileAccount_ApplyBannerAlteration) == 0x000010, "Wrong alignment on OrionMcpProfileAccount_ApplyBannerAlteration");
static_assert(sizeof(OrionMcpProfileAccount_ApplyBannerAlteration) == 0x000090, "Wrong size on OrionMcpProfileAccount_ApplyBannerAlteration");
static_assert(offsetof(OrionMcpProfileAccount_ApplyBannerAlteration, bannerId) == 0x000000, "Member 'OrionMcpProfileAccount_ApplyBannerAlteration::bannerId' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_ApplyBannerAlteration, AlterationId) == 0x000010, "Member 'OrionMcpProfileAccount_ApplyBannerAlteration::AlterationId' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_ApplyBannerAlteration, AlterationSlot) == 0x000020, "Member 'OrionMcpProfileAccount_ApplyBannerAlteration::AlterationSlot' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_ApplyBannerAlteration, Context) == 0x000030, "Member 'OrionMcpProfileAccount_ApplyBannerAlteration::Context' has a wrong offset!");

// Function OrionGame.OrionMcpProfileAccount.AttachBanner
// 0x0090 (0x0090 - 0x0000)
struct OrionMcpProfileAccount_AttachBanner final
{
public:
	class FString                                 AttacheeId;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AttachmentId;                                      // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SocketIndex;                                       // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0xC];                                       // 0x0024(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FClientUrlContext                      Context;                                           // 0x0030(0x0060)(Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpProfileAccount_AttachBanner) == 0x000010, "Wrong alignment on OrionMcpProfileAccount_AttachBanner");
static_assert(sizeof(OrionMcpProfileAccount_AttachBanner) == 0x000090, "Wrong size on OrionMcpProfileAccount_AttachBanner");
static_assert(offsetof(OrionMcpProfileAccount_AttachBanner, AttacheeId) == 0x000000, "Member 'OrionMcpProfileAccount_AttachBanner::AttacheeId' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_AttachBanner, AttachmentId) == 0x000010, "Member 'OrionMcpProfileAccount_AttachBanner::AttachmentId' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_AttachBanner, SocketIndex) == 0x000020, "Member 'OrionMcpProfileAccount_AttachBanner::SocketIndex' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_AttachBanner, Context) == 0x000030, "Member 'OrionMcpProfileAccount_AttachBanner::Context' has a wrong offset!");

// Function OrionGame.OrionMcpProfileAccount.BannerBulkEdit
// 0x0070 (0x0070 - 0x0000)
struct OrionMcpProfileAccount_BannerBulkEdit final
{
public:
	struct FBannerBulkCommandList                 Commands;                                          // 0x0000(0x0010)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FClientUrlContext                      Context;                                           // 0x0010(0x0060)(Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpProfileAccount_BannerBulkEdit) == 0x000010, "Wrong alignment on OrionMcpProfileAccount_BannerBulkEdit");
static_assert(sizeof(OrionMcpProfileAccount_BannerBulkEdit) == 0x000070, "Wrong size on OrionMcpProfileAccount_BannerBulkEdit");
static_assert(offsetof(OrionMcpProfileAccount_BannerBulkEdit, Commands) == 0x000000, "Member 'OrionMcpProfileAccount_BannerBulkEdit::Commands' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_BannerBulkEdit, Context) == 0x000010, "Member 'OrionMcpProfileAccount_BannerBulkEdit::Context' has a wrong offset!");

// Function OrionGame.OrionMcpProfileAccount.CheckForStuff
// 0x0060 (0x0060 - 0x0000)
struct OrionMcpProfileAccount_CheckForStuff final
{
public:
	struct FClientUrlContext                      Context;                                           // 0x0000(0x0060)(Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpProfileAccount_CheckForStuff) == 0x000010, "Wrong alignment on OrionMcpProfileAccount_CheckForStuff");
static_assert(sizeof(OrionMcpProfileAccount_CheckForStuff) == 0x000060, "Wrong size on OrionMcpProfileAccount_CheckForStuff");
static_assert(offsetof(OrionMcpProfileAccount_CheckForStuff, Context) == 0x000000, "Member 'OrionMcpProfileAccount_CheckForStuff::Context' has a wrong offset!");

// Function OrionGame.OrionMcpProfileAccount.ClaimLoginReward
// 0x0060 (0x0060 - 0x0000)
struct OrionMcpProfileAccount_ClaimLoginReward final
{
public:
	struct FClientUrlContext                      Context;                                           // 0x0000(0x0060)(Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpProfileAccount_ClaimLoginReward) == 0x000010, "Wrong alignment on OrionMcpProfileAccount_ClaimLoginReward");
static_assert(sizeof(OrionMcpProfileAccount_ClaimLoginReward) == 0x000060, "Wrong size on OrionMcpProfileAccount_ClaimLoginReward");
static_assert(offsetof(OrionMcpProfileAccount_ClaimLoginReward, Context) == 0x000000, "Member 'OrionMcpProfileAccount_ClaimLoginReward::Context' has a wrong offset!");

// Function OrionGame.OrionMcpProfileAccount.CompleteMatch
// 0x0240 (0x0240 - 0x0000)
struct OrionMcpProfileAccount_CompleteMatch final
{
public:
	class FString                                 HeroTemplateName;                                  // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayStats                         NewStatsV2;                                        // 0x0010(0x0108)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FTeamOwnershipXPBonus                  TeamOwnershipXPBonus;                              // 0x0118(0x0010)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FOrionPlayerEndMatchData               EndMatchData;                                      // 0x0128(0x00B0)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D8[0x8];                                      // 0x01D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDedicatedServerUrlContext             Context;                                           // 0x01E0(0x0060)(Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpProfileAccount_CompleteMatch) == 0x000010, "Wrong alignment on OrionMcpProfileAccount_CompleteMatch");
static_assert(sizeof(OrionMcpProfileAccount_CompleteMatch) == 0x000240, "Wrong size on OrionMcpProfileAccount_CompleteMatch");
static_assert(offsetof(OrionMcpProfileAccount_CompleteMatch, HeroTemplateName) == 0x000000, "Member 'OrionMcpProfileAccount_CompleteMatch::HeroTemplateName' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_CompleteMatch, NewStatsV2) == 0x000010, "Member 'OrionMcpProfileAccount_CompleteMatch::NewStatsV2' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_CompleteMatch, TeamOwnershipXPBonus) == 0x000118, "Member 'OrionMcpProfileAccount_CompleteMatch::TeamOwnershipXPBonus' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_CompleteMatch, EndMatchData) == 0x000128, "Member 'OrionMcpProfileAccount_CompleteMatch::EndMatchData' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_CompleteMatch, Context) == 0x0001E0, "Member 'OrionMcpProfileAccount_CompleteMatch::Context' has a wrong offset!");

// Function OrionGame.OrionMcpProfileAccount.CreateNewUserDeck
// 0x0060 (0x0060 - 0x0000)
struct OrionMcpProfileAccount_CreateNewUserDeck final
{
public:
	struct FClientUrlContext                      Context;                                           // 0x0000(0x0060)(Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpProfileAccount_CreateNewUserDeck) == 0x000010, "Wrong alignment on OrionMcpProfileAccount_CreateNewUserDeck");
static_assert(sizeof(OrionMcpProfileAccount_CreateNewUserDeck) == 0x000060, "Wrong size on OrionMcpProfileAccount_CreateNewUserDeck");
static_assert(offsetof(OrionMcpProfileAccount_CreateNewUserDeck, Context) == 0x000000, "Member 'OrionMcpProfileAccount_CreateNewUserDeck::Context' has a wrong offset!");

// Function OrionGame.OrionMcpProfileAccount.CreditClientStat
// 0x0080 (0x0080 - 0x0000)
struct OrionMcpProfileAccount_CreditClientStat final
{
public:
	class FString                                 StatName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StatCount;                                         // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0xC];                                       // 0x0014(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FClientUrlContext                      Context;                                           // 0x0020(0x0060)(Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpProfileAccount_CreditClientStat) == 0x000010, "Wrong alignment on OrionMcpProfileAccount_CreditClientStat");
static_assert(sizeof(OrionMcpProfileAccount_CreditClientStat) == 0x000080, "Wrong size on OrionMcpProfileAccount_CreditClientStat");
static_assert(offsetof(OrionMcpProfileAccount_CreditClientStat, StatName) == 0x000000, "Member 'OrionMcpProfileAccount_CreditClientStat::StatName' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_CreditClientStat, StatCount) == 0x000010, "Member 'OrionMcpProfileAccount_CreditClientStat::StatCount' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_CreditClientStat, Context) == 0x000020, "Member 'OrionMcpProfileAccount_CreditClientStat::Context' has a wrong offset!");

// Function OrionGame.OrionMcpProfileAccount.DeleteDeck
// 0x0070 (0x0070 - 0x0000)
struct OrionMcpProfileAccount_DeleteDeck final
{
public:
	class FString                                 DeckId;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FClientUrlContext                      Context;                                           // 0x0010(0x0060)(Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpProfileAccount_DeleteDeck) == 0x000010, "Wrong alignment on OrionMcpProfileAccount_DeleteDeck");
static_assert(sizeof(OrionMcpProfileAccount_DeleteDeck) == 0x000070, "Wrong size on OrionMcpProfileAccount_DeleteDeck");
static_assert(offsetof(OrionMcpProfileAccount_DeleteDeck, DeckId) == 0x000000, "Member 'OrionMcpProfileAccount_DeleteDeck::DeckId' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_DeleteDeck, Context) == 0x000010, "Member 'OrionMcpProfileAccount_DeleteDeck::Context' has a wrong offset!");

// Function OrionGame.OrionMcpProfileAccount.ExtractBannerAlteration
// 0x0080 (0x0080 - 0x0000)
struct OrionMcpProfileAccount_ExtractBannerAlteration final
{
public:
	class FString                                 bannerId;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AlterationSlot;                                    // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0xC];                                       // 0x0014(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FClientUrlContext                      Context;                                           // 0x0020(0x0060)(Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpProfileAccount_ExtractBannerAlteration) == 0x000010, "Wrong alignment on OrionMcpProfileAccount_ExtractBannerAlteration");
static_assert(sizeof(OrionMcpProfileAccount_ExtractBannerAlteration) == 0x000080, "Wrong size on OrionMcpProfileAccount_ExtractBannerAlteration");
static_assert(offsetof(OrionMcpProfileAccount_ExtractBannerAlteration, bannerId) == 0x000000, "Member 'OrionMcpProfileAccount_ExtractBannerAlteration::bannerId' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_ExtractBannerAlteration, AlterationSlot) == 0x000010, "Member 'OrionMcpProfileAccount_ExtractBannerAlteration::AlterationSlot' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_ExtractBannerAlteration, Context) == 0x000020, "Member 'OrionMcpProfileAccount_ExtractBannerAlteration::Context' has a wrong offset!");

// Function OrionGame.OrionMcpProfileAccount.IssueFriendCode
// 0x0070 (0x0070 - 0x0000)
struct OrionMcpProfileAccount_IssueFriendCode final
{
public:
	class FString                                 CodeTokenType;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FClientUrlContext                      Context;                                           // 0x0010(0x0060)(Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpProfileAccount_IssueFriendCode) == 0x000010, "Wrong alignment on OrionMcpProfileAccount_IssueFriendCode");
static_assert(sizeof(OrionMcpProfileAccount_IssueFriendCode) == 0x000070, "Wrong size on OrionMcpProfileAccount_IssueFriendCode");
static_assert(offsetof(OrionMcpProfileAccount_IssueFriendCode, CodeTokenType) == 0x000000, "Member 'OrionMcpProfileAccount_IssueFriendCode::CodeTokenType' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_IssueFriendCode, Context) == 0x000010, "Member 'OrionMcpProfileAccount_IssueFriendCode::Context' has a wrong offset!");

// Function OrionGame.OrionMcpProfileAccount.NoteNewItems
// 0x0070 (0x0070 - 0x0000)
struct OrionMcpProfileAccount_NoteNewItems final
{
public:
	struct FItemIdList                            NewItemList;                                       // 0x0000(0x0010)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FClientUrlContext                      Context;                                           // 0x0010(0x0060)(Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpProfileAccount_NoteNewItems) == 0x000010, "Wrong alignment on OrionMcpProfileAccount_NoteNewItems");
static_assert(sizeof(OrionMcpProfileAccount_NoteNewItems) == 0x000070, "Wrong size on OrionMcpProfileAccount_NoteNewItems");
static_assert(offsetof(OrionMcpProfileAccount_NoteNewItems, NewItemList) == 0x000000, "Member 'OrionMcpProfileAccount_NoteNewItems::NewItemList' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_NoteNewItems, Context) == 0x000010, "Member 'OrionMcpProfileAccount_NoteNewItems::Context' has a wrong offset!");

// Function OrionGame.OrionMcpProfileAccount.OpenCardPack
// 0x0080 (0x0080 - 0x0000)
struct OrionMcpProfileAccount_OpenCardPack final
{
public:
	class FString                                 CardPackItemId;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 KeyId;                                             // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FClientUrlContext                      Context;                                           // 0x0020(0x0060)(Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpProfileAccount_OpenCardPack) == 0x000010, "Wrong alignment on OrionMcpProfileAccount_OpenCardPack");
static_assert(sizeof(OrionMcpProfileAccount_OpenCardPack) == 0x000080, "Wrong size on OrionMcpProfileAccount_OpenCardPack");
static_assert(offsetof(OrionMcpProfileAccount_OpenCardPack, CardPackItemId) == 0x000000, "Member 'OrionMcpProfileAccount_OpenCardPack::CardPackItemId' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_OpenCardPack, KeyId) == 0x000010, "Member 'OrionMcpProfileAccount_OpenCardPack::KeyId' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_OpenCardPack, Context) == 0x000020, "Member 'OrionMcpProfileAccount_OpenCardPack::Context' has a wrong offset!");

// Function OrionGame.OrionMcpProfileAccount.OpenGiftBox
// 0x0070 (0x0070 - 0x0000)
struct OrionMcpProfileAccount_OpenGiftBox final
{
public:
	class FString                                 GiftBoxItemID;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FClientUrlContext                      Context;                                           // 0x0010(0x0060)(Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpProfileAccount_OpenGiftBox) == 0x000010, "Wrong alignment on OrionMcpProfileAccount_OpenGiftBox");
static_assert(sizeof(OrionMcpProfileAccount_OpenGiftBox) == 0x000070, "Wrong size on OrionMcpProfileAccount_OpenGiftBox");
static_assert(offsetof(OrionMcpProfileAccount_OpenGiftBox, GiftBoxItemID) == 0x000000, "Member 'OrionMcpProfileAccount_OpenGiftBox::GiftBoxItemID' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_OpenGiftBox, Context) == 0x000010, "Member 'OrionMcpProfileAccount_OpenGiftBox::Context' has a wrong offset!");

// Function OrionGame.OrionMcpProfileAccount.OpenVault
// 0x0070 (0x0070 - 0x0000)
struct OrionMcpProfileAccount_OpenVault final
{
public:
	class FString                                 VaultTemplateName;                                 // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FClientUrlContext                      Context;                                           // 0x0010(0x0060)(Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpProfileAccount_OpenVault) == 0x000010, "Wrong alignment on OrionMcpProfileAccount_OpenVault");
static_assert(sizeof(OrionMcpProfileAccount_OpenVault) == 0x000070, "Wrong size on OrionMcpProfileAccount_OpenVault");
static_assert(offsetof(OrionMcpProfileAccount_OpenVault, VaultTemplateName) == 0x000000, "Member 'OrionMcpProfileAccount_OpenVault::VaultTemplateName' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_OpenVault, Context) == 0x000010, "Member 'OrionMcpProfileAccount_OpenVault::Context' has a wrong offset!");

// Function OrionGame.OrionMcpProfileAccount.PrestigeAccount
// 0x0060 (0x0060 - 0x0000)
struct OrionMcpProfileAccount_PrestigeAccount final
{
public:
	struct FClientUrlContext                      Context;                                           // 0x0000(0x0060)(Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpProfileAccount_PrestigeAccount) == 0x000010, "Wrong alignment on OrionMcpProfileAccount_PrestigeAccount");
static_assert(sizeof(OrionMcpProfileAccount_PrestigeAccount) == 0x000060, "Wrong size on OrionMcpProfileAccount_PrestigeAccount");
static_assert(offsetof(OrionMcpProfileAccount_PrestigeAccount, Context) == 0x000000, "Member 'OrionMcpProfileAccount_PrestigeAccount::Context' has a wrong offset!");

// Function OrionGame.OrionMcpProfileAccount.PurchaseDeckSlot
// 0x0070 (0x0070 - 0x0000)
struct OrionMcpProfileAccount_PurchaseDeckSlot final
{
public:
	bool                                          MtxEquivalency;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0xF];                                        // 0x0001(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FClientUrlContext                      Context;                                           // 0x0010(0x0060)(Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpProfileAccount_PurchaseDeckSlot) == 0x000010, "Wrong alignment on OrionMcpProfileAccount_PurchaseDeckSlot");
static_assert(sizeof(OrionMcpProfileAccount_PurchaseDeckSlot) == 0x000070, "Wrong size on OrionMcpProfileAccount_PurchaseDeckSlot");
static_assert(offsetof(OrionMcpProfileAccount_PurchaseDeckSlot, MtxEquivalency) == 0x000000, "Member 'OrionMcpProfileAccount_PurchaseDeckSlot::MtxEquivalency' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_PurchaseDeckSlot, Context) == 0x000010, "Member 'OrionMcpProfileAccount_PurchaseDeckSlot::Context' has a wrong offset!");

// Function OrionGame.OrionMcpProfileAccount.RankUpCard
// 0x0080 (0x0080 - 0x0000)
struct OrionMcpProfileAccount_RankUpCard final
{
public:
	class FString                                 CardTemplateId;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MtxEquivalency;                                    // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0xF];                                       // 0x0011(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FClientUrlContext                      Context;                                           // 0x0020(0x0060)(Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpProfileAccount_RankUpCard) == 0x000010, "Wrong alignment on OrionMcpProfileAccount_RankUpCard");
static_assert(sizeof(OrionMcpProfileAccount_RankUpCard) == 0x000080, "Wrong size on OrionMcpProfileAccount_RankUpCard");
static_assert(offsetof(OrionMcpProfileAccount_RankUpCard, CardTemplateId) == 0x000000, "Member 'OrionMcpProfileAccount_RankUpCard::CardTemplateId' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_RankUpCard, MtxEquivalency) == 0x000010, "Member 'OrionMcpProfileAccount_RankUpCard::MtxEquivalency' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_RankUpCard, Context) == 0x000020, "Member 'OrionMcpProfileAccount_RankUpCard::Context' has a wrong offset!");

// Function OrionGame.OrionMcpProfileAccount.RankUpMastery
// 0x0080 (0x0080 - 0x0000)
struct OrionMcpProfileAccount_RankUpMastery final
{
public:
	class FString                                 HeroItemId;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MtxEquivalency;                                    // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ApplyLastMatch;                                    // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0xE];                                       // 0x0012(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FClientUrlContext                      Context;                                           // 0x0020(0x0060)(Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpProfileAccount_RankUpMastery) == 0x000010, "Wrong alignment on OrionMcpProfileAccount_RankUpMastery");
static_assert(sizeof(OrionMcpProfileAccount_RankUpMastery) == 0x000080, "Wrong size on OrionMcpProfileAccount_RankUpMastery");
static_assert(offsetof(OrionMcpProfileAccount_RankUpMastery, HeroItemId) == 0x000000, "Member 'OrionMcpProfileAccount_RankUpMastery::HeroItemId' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_RankUpMastery, MtxEquivalency) == 0x000010, "Member 'OrionMcpProfileAccount_RankUpMastery::MtxEquivalency' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_RankUpMastery, ApplyLastMatch) == 0x000011, "Member 'OrionMcpProfileAccount_RankUpMastery::ApplyLastMatch' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_RankUpMastery, Context) == 0x000020, "Member 'OrionMcpProfileAccount_RankUpMastery::Context' has a wrong offset!");

// Function OrionGame.OrionMcpProfileAccount.ReportQueueDodge
// 0x0070 (0x0070 - 0x0000)
struct OrionMcpProfileAccount_ReportQueueDodge final
{
public:
	EOrionDodgeType                               DodgeType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0xF];                                        // 0x0001(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDedicatedServerUrlContext             Context;                                           // 0x0010(0x0060)(Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpProfileAccount_ReportQueueDodge) == 0x000010, "Wrong alignment on OrionMcpProfileAccount_ReportQueueDodge");
static_assert(sizeof(OrionMcpProfileAccount_ReportQueueDodge) == 0x000070, "Wrong size on OrionMcpProfileAccount_ReportQueueDodge");
static_assert(offsetof(OrionMcpProfileAccount_ReportQueueDodge, DodgeType) == 0x000000, "Member 'OrionMcpProfileAccount_ReportQueueDodge::DodgeType' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_ReportQueueDodge, Context) == 0x000010, "Member 'OrionMcpProfileAccount_ReportQueueDodge::Context' has a wrong offset!");

// Function OrionGame.OrionMcpProfileAccount.SelectFreeMasteryHero
// 0x0080 (0x0080 - 0x0000)
struct OrionMcpProfileAccount_SelectFreeMasteryHero final
{
public:
	class FString                                 HeroItemId;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TokenTemplateName;                                 // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FClientUrlContext                      Context;                                           // 0x0020(0x0060)(Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpProfileAccount_SelectFreeMasteryHero) == 0x000010, "Wrong alignment on OrionMcpProfileAccount_SelectFreeMasteryHero");
static_assert(sizeof(OrionMcpProfileAccount_SelectFreeMasteryHero) == 0x000080, "Wrong size on OrionMcpProfileAccount_SelectFreeMasteryHero");
static_assert(offsetof(OrionMcpProfileAccount_SelectFreeMasteryHero, HeroItemId) == 0x000000, "Member 'OrionMcpProfileAccount_SelectFreeMasteryHero::HeroItemId' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_SelectFreeMasteryHero, TokenTemplateName) == 0x000010, "Member 'OrionMcpProfileAccount_SelectFreeMasteryHero::TokenTemplateName' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_SelectFreeMasteryHero, Context) == 0x000020, "Member 'OrionMcpProfileAccount_SelectFreeMasteryHero::Context' has a wrong offset!");

// Function OrionGame.OrionMcpProfileAccount.SetBannerForAccount
// 0x0070 (0x0070 - 0x0000)
struct OrionMcpProfileAccount_SetBannerForAccount final
{
public:
	class FString                                 bannerId;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FClientUrlContext                      Context;                                           // 0x0010(0x0060)(Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpProfileAccount_SetBannerForAccount) == 0x000010, "Wrong alignment on OrionMcpProfileAccount_SetBannerForAccount");
static_assert(sizeof(OrionMcpProfileAccount_SetBannerForAccount) == 0x000070, "Wrong size on OrionMcpProfileAccount_SetBannerForAccount");
static_assert(offsetof(OrionMcpProfileAccount_SetBannerForAccount, bannerId) == 0x000000, "Member 'OrionMcpProfileAccount_SetBannerForAccount::bannerId' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_SetBannerForAccount, Context) == 0x000010, "Member 'OrionMcpProfileAccount_SetBannerForAccount::Context' has a wrong offset!");

// Function OrionGame.OrionMcpProfileAccount.SetBannerName
// 0x0080 (0x0080 - 0x0000)
struct OrionMcpProfileAccount_SetBannerName final
{
public:
	class FString                                 bannerName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 bannerId;                                          // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FClientUrlContext                      Context;                                           // 0x0020(0x0060)(Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpProfileAccount_SetBannerName) == 0x000010, "Wrong alignment on OrionMcpProfileAccount_SetBannerName");
static_assert(sizeof(OrionMcpProfileAccount_SetBannerName) == 0x000080, "Wrong size on OrionMcpProfileAccount_SetBannerName");
static_assert(offsetof(OrionMcpProfileAccount_SetBannerName, bannerName) == 0x000000, "Member 'OrionMcpProfileAccount_SetBannerName::bannerName' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_SetBannerName, bannerId) == 0x000010, "Member 'OrionMcpProfileAccount_SetBannerName::bannerId' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_SetBannerName, Context) == 0x000020, "Member 'OrionMcpProfileAccount_SetBannerName::Context' has a wrong offset!");

// Function OrionGame.OrionMcpProfileAccount.SetCosmeticChoices
// 0x0150 (0x0150 - 0x0000)
struct OrionMcpProfileAccount_SetCosmeticChoices final
{
public:
	class FString                                 HeroId;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionCosmeticPlayerChoices            CosmeticChoices;                                   // 0x0010(0x00E0)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FClientUrlContext                      Context;                                           // 0x00F0(0x0060)(Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpProfileAccount_SetCosmeticChoices) == 0x000010, "Wrong alignment on OrionMcpProfileAccount_SetCosmeticChoices");
static_assert(sizeof(OrionMcpProfileAccount_SetCosmeticChoices) == 0x000150, "Wrong size on OrionMcpProfileAccount_SetCosmeticChoices");
static_assert(offsetof(OrionMcpProfileAccount_SetCosmeticChoices, HeroId) == 0x000000, "Member 'OrionMcpProfileAccount_SetCosmeticChoices::HeroId' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_SetCosmeticChoices, CosmeticChoices) == 0x000010, "Member 'OrionMcpProfileAccount_SetCosmeticChoices::CosmeticChoices' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_SetCosmeticChoices, Context) == 0x0000F0, "Member 'OrionMcpProfileAccount_SetCosmeticChoices::Context' has a wrong offset!");

// Function OrionGame.OrionMcpProfileAccount.SetDeckName
// 0x0080 (0x0080 - 0x0000)
struct OrionMcpProfileAccount_SetDeckName final
{
public:
	class FString                                 DeckName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DeckId;                                            // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FClientUrlContext                      Context;                                           // 0x0020(0x0060)(Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpProfileAccount_SetDeckName) == 0x000010, "Wrong alignment on OrionMcpProfileAccount_SetDeckName");
static_assert(sizeof(OrionMcpProfileAccount_SetDeckName) == 0x000080, "Wrong size on OrionMcpProfileAccount_SetDeckName");
static_assert(offsetof(OrionMcpProfileAccount_SetDeckName, DeckName) == 0x000000, "Member 'OrionMcpProfileAccount_SetDeckName::DeckName' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_SetDeckName, DeckId) == 0x000010, "Member 'OrionMcpProfileAccount_SetDeckName::DeckId' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_SetDeckName, Context) == 0x000020, "Member 'OrionMcpProfileAccount_SetDeckName::Context' has a wrong offset!");

// Function OrionGame.OrionMcpProfileAccount.SetPlatform
// 0x0070 (0x0070 - 0x0000)
struct OrionMcpProfileAccount_SetPlatform final
{
public:
	EOrionPlatformType                            NewPlatform;                                       // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0xF];                                        // 0x0001(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FClientUrlContext                      Context;                                           // 0x0010(0x0060)(Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpProfileAccount_SetPlatform) == 0x000010, "Wrong alignment on OrionMcpProfileAccount_SetPlatform");
static_assert(sizeof(OrionMcpProfileAccount_SetPlatform) == 0x000070, "Wrong size on OrionMcpProfileAccount_SetPlatform");
static_assert(offsetof(OrionMcpProfileAccount_SetPlatform, NewPlatform) == 0x000000, "Member 'OrionMcpProfileAccount_SetPlatform::NewPlatform' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_SetPlatform, Context) == 0x000010, "Member 'OrionMcpProfileAccount_SetPlatform::Context' has a wrong offset!");

// Function OrionGame.OrionMcpProfileAccount.SetPlayerVeterancy
// 0x0070 (0x0070 - 0x0000)
struct OrionMcpProfileAccount_SetPlayerVeterancy final
{
public:
	EOrionVeterancy                               Veterancy;                                         // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0xF];                                        // 0x0001(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FClientUrlContext                      Context;                                           // 0x0010(0x0060)(Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpProfileAccount_SetPlayerVeterancy) == 0x000010, "Wrong alignment on OrionMcpProfileAccount_SetPlayerVeterancy");
static_assert(sizeof(OrionMcpProfileAccount_SetPlayerVeterancy) == 0x000070, "Wrong size on OrionMcpProfileAccount_SetPlayerVeterancy");
static_assert(offsetof(OrionMcpProfileAccount_SetPlayerVeterancy, Veterancy) == 0x000000, "Member 'OrionMcpProfileAccount_SetPlayerVeterancy::Veterancy' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_SetPlayerVeterancy, Context) == 0x000010, "Member 'OrionMcpProfileAccount_SetPlayerVeterancy::Context' has a wrong offset!");

// Function OrionGame.OrionMcpProfileAccount.SetSkinCosmeticChoices
// 0x0080 (0x0080 - 0x0000)
struct OrionMcpProfileAccount_SetSkinCosmeticChoices final
{
public:
	class FString                                 SkinName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ActiveSkinVariation;                               // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FClientUrlContext                      Context;                                           // 0x0020(0x0060)(Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpProfileAccount_SetSkinCosmeticChoices) == 0x000010, "Wrong alignment on OrionMcpProfileAccount_SetSkinCosmeticChoices");
static_assert(sizeof(OrionMcpProfileAccount_SetSkinCosmeticChoices) == 0x000080, "Wrong size on OrionMcpProfileAccount_SetSkinCosmeticChoices");
static_assert(offsetof(OrionMcpProfileAccount_SetSkinCosmeticChoices, SkinName) == 0x000000, "Member 'OrionMcpProfileAccount_SetSkinCosmeticChoices::SkinName' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_SetSkinCosmeticChoices, ActiveSkinVariation) == 0x000010, "Member 'OrionMcpProfileAccount_SetSkinCosmeticChoices::ActiveSkinVariation' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_SetSkinCosmeticChoices, Context) == 0x000020, "Member 'OrionMcpProfileAccount_SetSkinCosmeticChoices::Context' has a wrong offset!");

// Function OrionGame.OrionMcpProfileAccount.SetUserCreatedDeck
// 0x00C0 (0x00C0 - 0x0000)
struct OrionMcpProfileAccount_SetUserCreatedDeck final
{
public:
	struct FUserCreatedDeck                       UserCreatedDeck;                                   // 0x0000(0x0048)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	class FString                                 DeckId;                                            // 0x0048(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FClientUrlContext                      Context;                                           // 0x0060(0x0060)(Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpProfileAccount_SetUserCreatedDeck) == 0x000010, "Wrong alignment on OrionMcpProfileAccount_SetUserCreatedDeck");
static_assert(sizeof(OrionMcpProfileAccount_SetUserCreatedDeck) == 0x0000C0, "Wrong size on OrionMcpProfileAccount_SetUserCreatedDeck");
static_assert(offsetof(OrionMcpProfileAccount_SetUserCreatedDeck, UserCreatedDeck) == 0x000000, "Member 'OrionMcpProfileAccount_SetUserCreatedDeck::UserCreatedDeck' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_SetUserCreatedDeck, DeckId) == 0x000048, "Member 'OrionMcpProfileAccount_SetUserCreatedDeck::DeckId' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_SetUserCreatedDeck, Context) == 0x000060, "Member 'OrionMcpProfileAccount_SetUserCreatedDeck::Context' has a wrong offset!");

// Function OrionGame.OrionMcpProfileAccount.UpdateAccountStatus
// 0x0060 (0x0060 - 0x0000)
struct OrionMcpProfileAccount_UpdateAccountStatus final
{
public:
	struct FClientUrlContext                      Context;                                           // 0x0000(0x0060)(Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpProfileAccount_UpdateAccountStatus) == 0x000010, "Wrong alignment on OrionMcpProfileAccount_UpdateAccountStatus");
static_assert(sizeof(OrionMcpProfileAccount_UpdateAccountStatus) == 0x000060, "Wrong size on OrionMcpProfileAccount_UpdateAccountStatus");
static_assert(offsetof(OrionMcpProfileAccount_UpdateAccountStatus, Context) == 0x000000, "Member 'OrionMcpProfileAccount_UpdateAccountStatus::Context' has a wrong offset!");

// Function OrionGame.OrionMcpProfileAccount.UpdateSimpleAchievements
// 0x0080 (0x0080 - 0x0000)
struct OrionMcpProfileAccount_UpdateSimpleAchievements final
{
public:
	struct FSimpleAchievements                    NewSimpleAchievements;                             // 0x0000(0x0010)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         RelayNotifictaion;                                 // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0xC];                                       // 0x0014(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FClientUrlContext                      Context;                                           // 0x0020(0x0060)(Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpProfileAccount_UpdateSimpleAchievements) == 0x000010, "Wrong alignment on OrionMcpProfileAccount_UpdateSimpleAchievements");
static_assert(sizeof(OrionMcpProfileAccount_UpdateSimpleAchievements) == 0x000080, "Wrong size on OrionMcpProfileAccount_UpdateSimpleAchievements");
static_assert(offsetof(OrionMcpProfileAccount_UpdateSimpleAchievements, NewSimpleAchievements) == 0x000000, "Member 'OrionMcpProfileAccount_UpdateSimpleAchievements::NewSimpleAchievements' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_UpdateSimpleAchievements, RelayNotifictaion) == 0x000010, "Member 'OrionMcpProfileAccount_UpdateSimpleAchievements::RelayNotifictaion' has a wrong offset!");
static_assert(offsetof(OrionMcpProfileAccount_UpdateSimpleAchievements, Context) == 0x000020, "Member 'OrionMcpProfileAccount_UpdateSimpleAchievements::Context' has a wrong offset!");

// Function OrionGame.OrionMcpQuestItem.GetInternalData
// 0x0008 (0x0008 - 0x0000)
struct OrionMcpQuestItem_GetInternalData final
{
public:
	class UOrionMcpQuestItemDefinition*           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpQuestItem_GetInternalData) == 0x000008, "Wrong alignment on OrionMcpQuestItem_GetInternalData");
static_assert(sizeof(OrionMcpQuestItem_GetInternalData) == 0x000008, "Wrong size on OrionMcpQuestItem_GetInternalData");
static_assert(offsetof(OrionMcpQuestItem_GetInternalData, ReturnValue) == 0x000000, "Member 'OrionMcpQuestItem_GetInternalData::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionMcpSkinItem.GetInternalData
// 0x0008 (0x0008 - 0x0000)
struct OrionMcpSkinItem_GetInternalData final
{
public:
	class UOrionSkinItemDefinition*               ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpSkinItem_GetInternalData) == 0x000008, "Wrong alignment on OrionMcpSkinItem_GetInternalData");
static_assert(sizeof(OrionMcpSkinItem_GetInternalData) == 0x000008, "Wrong size on OrionMcpSkinItem_GetInternalData");
static_assert(offsetof(OrionMcpSkinItem_GetInternalData, ReturnValue) == 0x000000, "Member 'OrionMcpSkinItem_GetInternalData::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionSkinItemDefinition.BP_ApplySkinToComponent
// 0x0010 (0x0010 - 0x0000)
struct OrionSkinItemDefinition_BP_ApplySkinToComponent final
{
public:
	class USkinnedMeshComponent*                  MeshComponent;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionSkinVariationItemDefinition*      InSkinVariation;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionSkinItemDefinition_BP_ApplySkinToComponent) == 0x000008, "Wrong alignment on OrionSkinItemDefinition_BP_ApplySkinToComponent");
static_assert(sizeof(OrionSkinItemDefinition_BP_ApplySkinToComponent) == 0x000010, "Wrong size on OrionSkinItemDefinition_BP_ApplySkinToComponent");
static_assert(offsetof(OrionSkinItemDefinition_BP_ApplySkinToComponent, MeshComponent) == 0x000000, "Member 'OrionSkinItemDefinition_BP_ApplySkinToComponent::MeshComponent' has a wrong offset!");
static_assert(offsetof(OrionSkinItemDefinition_BP_ApplySkinToComponent, InSkinVariation) == 0x000008, "Member 'OrionSkinItemDefinition_BP_ApplySkinToComponent::InSkinVariation' has a wrong offset!");

// Function OrionGame.OrionSkinItemDefinition.GetAnimInstanceClass
// 0x0008 (0x0008 - 0x0000)
struct OrionSkinItemDefinition_GetAnimInstanceClass final
{
public:
	TSubclassOf<class UAnimInstance>              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionSkinItemDefinition_GetAnimInstanceClass) == 0x000008, "Wrong alignment on OrionSkinItemDefinition_GetAnimInstanceClass");
static_assert(sizeof(OrionSkinItemDefinition_GetAnimInstanceClass) == 0x000008, "Wrong size on OrionSkinItemDefinition_GetAnimInstanceClass");
static_assert(offsetof(OrionSkinItemDefinition_GetAnimInstanceClass, ReturnValue) == 0x000000, "Member 'OrionSkinItemDefinition_GetAnimInstanceClass::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionSkinItemDefinition.GetPawnClassOverride
// 0x0008 (0x0008 - 0x0000)
struct OrionSkinItemDefinition_GetPawnClassOverride final
{
public:
	TSubclassOf<class AOrionChar>                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionSkinItemDefinition_GetPawnClassOverride) == 0x000008, "Wrong alignment on OrionSkinItemDefinition_GetPawnClassOverride");
static_assert(sizeof(OrionSkinItemDefinition_GetPawnClassOverride) == 0x000008, "Wrong size on OrionSkinItemDefinition_GetPawnClassOverride");
static_assert(offsetof(OrionSkinItemDefinition_GetPawnClassOverride, ReturnValue) == 0x000000, "Member 'OrionSkinItemDefinition_GetPawnClassOverride::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionSkinItemDefinition.GetSkelMesh
// 0x0008 (0x0008 - 0x0000)
struct OrionSkinItemDefinition_GetSkelMesh final
{
public:
	class USkeletalMesh*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionSkinItemDefinition_GetSkelMesh) == 0x000008, "Wrong alignment on OrionSkinItemDefinition_GetSkelMesh");
static_assert(sizeof(OrionSkinItemDefinition_GetSkelMesh) == 0x000008, "Wrong size on OrionSkinItemDefinition_GetSkelMesh");
static_assert(offsetof(OrionSkinItemDefinition_GetSkelMesh, ReturnValue) == 0x000000, "Member 'OrionSkinItemDefinition_GetSkelMesh::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionSkinVariationItemDefinition.GetAllValidVariantsOfSkin
// 0x0018 (0x0018 - 0x0000)
struct OrionSkinVariationItemDefinition_GetAllValidVariantsOfSkin final
{
public:
	const class UOrionSkinItemDefinition*         Skin;                                              // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UOrionSkinVariationItemDefinition*> AllVariantsOfSkin;                                 // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionSkinVariationItemDefinition_GetAllValidVariantsOfSkin) == 0x000008, "Wrong alignment on OrionSkinVariationItemDefinition_GetAllValidVariantsOfSkin");
static_assert(sizeof(OrionSkinVariationItemDefinition_GetAllValidVariantsOfSkin) == 0x000018, "Wrong size on OrionSkinVariationItemDefinition_GetAllValidVariantsOfSkin");
static_assert(offsetof(OrionSkinVariationItemDefinition_GetAllValidVariantsOfSkin, Skin) == 0x000000, "Member 'OrionSkinVariationItemDefinition_GetAllValidVariantsOfSkin::Skin' has a wrong offset!");
static_assert(offsetof(OrionSkinVariationItemDefinition_GetAllValidVariantsOfSkin, AllVariantsOfSkin) == 0x000008, "Member 'OrionSkinVariationItemDefinition_GetAllValidVariantsOfSkin::AllVariantsOfSkin' has a wrong offset!");

// Function OrionGame.OrionMcpTokenItem.GetInternalData
// 0x0008 (0x0008 - 0x0000)
struct OrionMcpTokenItem_GetInternalData final
{
public:
	class UOrionMcpTokenItemDefinition*           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMcpTokenItem_GetInternalData) == 0x000008, "Wrong alignment on OrionMcpTokenItem_GetInternalData");
static_assert(sizeof(OrionMcpTokenItem_GetInternalData) == 0x000008, "Wrong size on OrionMcpTokenItem_GetInternalData");
static_assert(offsetof(OrionMcpTokenItem_GetInternalData, ReturnValue) == 0x000000, "Member 'OrionMcpTokenItem_GetInternalData::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionMenuManagerWidget2.OnMenuClose
// 0x0008 (0x0008 - 0x0000)
struct OrionMenuManagerWidget2_OnMenuClose final
{
public:
	class UWidget*                                NewOpenWidget;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMenuManagerWidget2_OnMenuClose) == 0x000008, "Wrong alignment on OrionMenuManagerWidget2_OnMenuClose");
static_assert(sizeof(OrionMenuManagerWidget2_OnMenuClose) == 0x000008, "Wrong size on OrionMenuManagerWidget2_OnMenuClose");
static_assert(offsetof(OrionMenuManagerWidget2_OnMenuClose, NewOpenWidget) == 0x000000, "Member 'OrionMenuManagerWidget2_OnMenuClose::NewOpenWidget' has a wrong offset!");

// Function OrionGame.OrionMenuManagerWidget2.OnMenuOpen
// 0x0008 (0x0008 - 0x0000)
struct OrionMenuManagerWidget2_OnMenuOpen final
{
public:
	class UWidget*                                NewOpenWidget;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMenuManagerWidget2_OnMenuOpen) == 0x000008, "Wrong alignment on OrionMenuManagerWidget2_OnMenuOpen");
static_assert(sizeof(OrionMenuManagerWidget2_OnMenuOpen) == 0x000008, "Wrong size on OrionMenuManagerWidget2_OnMenuOpen");
static_assert(offsetof(OrionMenuManagerWidget2_OnMenuOpen, NewOpenWidget) == 0x000000, "Member 'OrionMenuManagerWidget2_OnMenuOpen::NewOpenWidget' has a wrong offset!");

// Function OrionGame.OrionMenuManagerWidget2.OnMenuOpenStateChange
// 0x0002 (0x0002 - 0x0000)
struct OrionMenuManagerWidget2_OnMenuOpenStateChange final
{
public:
	EOrionMenuSlotTypes                           MenuSlot;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewIsOpenState;                                   // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMenuManagerWidget2_OnMenuOpenStateChange) == 0x000001, "Wrong alignment on OrionMenuManagerWidget2_OnMenuOpenStateChange");
static_assert(sizeof(OrionMenuManagerWidget2_OnMenuOpenStateChange) == 0x000002, "Wrong size on OrionMenuManagerWidget2_OnMenuOpenStateChange");
static_assert(offsetof(OrionMenuManagerWidget2_OnMenuOpenStateChange, MenuSlot) == 0x000000, "Member 'OrionMenuManagerWidget2_OnMenuOpenStateChange::MenuSlot' has a wrong offset!");
static_assert(offsetof(OrionMenuManagerWidget2_OnMenuOpenStateChange, bNewIsOpenState) == 0x000001, "Member 'OrionMenuManagerWidget2_OnMenuOpenStateChange::bNewIsOpenState' has a wrong offset!");

// Function OrionGame.OrionMenuManagerWidget2.FindWidgetFromSlot
// 0x0010 (0x0010 - 0x0000)
struct OrionMenuManagerWidget2_FindWidgetFromSlot final
{
public:
	EOrionMenuSlotTypes                           InSlotType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidget*                                ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMenuManagerWidget2_FindWidgetFromSlot) == 0x000008, "Wrong alignment on OrionMenuManagerWidget2_FindWidgetFromSlot");
static_assert(sizeof(OrionMenuManagerWidget2_FindWidgetFromSlot) == 0x000010, "Wrong size on OrionMenuManagerWidget2_FindWidgetFromSlot");
static_assert(offsetof(OrionMenuManagerWidget2_FindWidgetFromSlot, InSlotType) == 0x000000, "Member 'OrionMenuManagerWidget2_FindWidgetFromSlot::InSlotType' has a wrong offset!");
static_assert(offsetof(OrionMenuManagerWidget2_FindWidgetFromSlot, ReturnValue) == 0x000008, "Member 'OrionMenuManagerWidget2_FindWidgetFromSlot::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionMenuManagerWidget2.GetDoesMenuExist
// 0x0002 (0x0002 - 0x0000)
struct OrionMenuManagerWidget2_GetDoesMenuExist final
{
public:
	EOrionMenuSlotTypes                           InSlotType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMenuManagerWidget2_GetDoesMenuExist) == 0x000001, "Wrong alignment on OrionMenuManagerWidget2_GetDoesMenuExist");
static_assert(sizeof(OrionMenuManagerWidget2_GetDoesMenuExist) == 0x000002, "Wrong size on OrionMenuManagerWidget2_GetDoesMenuExist");
static_assert(offsetof(OrionMenuManagerWidget2_GetDoesMenuExist, InSlotType) == 0x000000, "Member 'OrionMenuManagerWidget2_GetDoesMenuExist::InSlotType' has a wrong offset!");
static_assert(offsetof(OrionMenuManagerWidget2_GetDoesMenuExist, ReturnValue) == 0x000001, "Member 'OrionMenuManagerWidget2_GetDoesMenuExist::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionMenuManagerWidget2.GetIsMenuVisible
// 0x0002 (0x0002 - 0x0000)
struct OrionMenuManagerWidget2_GetIsMenuVisible final
{
public:
	EOrionMenuSlotTypes                           InSlotType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMenuManagerWidget2_GetIsMenuVisible) == 0x000001, "Wrong alignment on OrionMenuManagerWidget2_GetIsMenuVisible");
static_assert(sizeof(OrionMenuManagerWidget2_GetIsMenuVisible) == 0x000002, "Wrong size on OrionMenuManagerWidget2_GetIsMenuVisible");
static_assert(offsetof(OrionMenuManagerWidget2_GetIsMenuVisible, InSlotType) == 0x000000, "Member 'OrionMenuManagerWidget2_GetIsMenuVisible::InSlotType' has a wrong offset!");
static_assert(offsetof(OrionMenuManagerWidget2_GetIsMenuVisible, ReturnValue) == 0x000001, "Member 'OrionMenuManagerWidget2_GetIsMenuVisible::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionMenuManagerWidget2.GetTopCursorState
// 0x0001 (0x0001 - 0x0000)
struct OrionMenuManagerWidget2_GetTopCursorState final
{
public:
	EOrionDesiredAnalogCursorState                ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMenuManagerWidget2_GetTopCursorState) == 0x000001, "Wrong alignment on OrionMenuManagerWidget2_GetTopCursorState");
static_assert(sizeof(OrionMenuManagerWidget2_GetTopCursorState) == 0x000001, "Wrong size on OrionMenuManagerWidget2_GetTopCursorState");
static_assert(offsetof(OrionMenuManagerWidget2_GetTopCursorState, ReturnValue) == 0x000000, "Member 'OrionMenuManagerWidget2_GetTopCursorState::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionMenuManagerWidget2.GetTopOpenWidget
// 0x0008 (0x0008 - 0x0000)
struct OrionMenuManagerWidget2_GetTopOpenWidget final
{
public:
	class UWidget*                                ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMenuManagerWidget2_GetTopOpenWidget) == 0x000008, "Wrong alignment on OrionMenuManagerWidget2_GetTopOpenWidget");
static_assert(sizeof(OrionMenuManagerWidget2_GetTopOpenWidget) == 0x000008, "Wrong size on OrionMenuManagerWidget2_GetTopOpenWidget");
static_assert(offsetof(OrionMenuManagerWidget2_GetTopOpenWidget, ReturnValue) == 0x000000, "Member 'OrionMenuManagerWidget2_GetTopOpenWidget::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionMurielAnimInstance.AnimNotify_Jump_Land_End
// 0x0008 (0x0008 - 0x0000)
struct OrionMurielAnimInstance_AnimNotify_Jump_Land_End final
{
public:
	const class UAnimNotify*                      AnimNotify;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionMurielAnimInstance_AnimNotify_Jump_Land_End) == 0x000008, "Wrong alignment on OrionMurielAnimInstance_AnimNotify_Jump_Land_End");
static_assert(sizeof(OrionMurielAnimInstance_AnimNotify_Jump_Land_End) == 0x000008, "Wrong size on OrionMurielAnimInstance_AnimNotify_Jump_Land_End");
static_assert(offsetof(OrionMurielAnimInstance_AnimNotify_Jump_Land_End, AnimNotify) == 0x000000, "Member 'OrionMurielAnimInstance_AnimNotify_Jump_Land_End::AnimNotify' has a wrong offset!");

// Function OrionGame.OrionNavTowerComponent.OnNavDataGenerationFinished
// 0x0008 (0x0008 - 0x0000)
struct OrionNavTowerComponent_OnNavDataGenerationFinished final
{
public:
	class ANavigationData*                        NavData;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionNavTowerComponent_OnNavDataGenerationFinished) == 0x000008, "Wrong alignment on OrionNavTowerComponent_OnNavDataGenerationFinished");
static_assert(sizeof(OrionNavTowerComponent_OnNavDataGenerationFinished) == 0x000008, "Wrong size on OrionNavTowerComponent_OnNavDataGenerationFinished");
static_assert(offsetof(OrionNavTowerComponent_OnNavDataGenerationFinished, NavData) == 0x000000, "Member 'OrionNavTowerComponent_OnNavDataGenerationFinished::NavData' has a wrong offset!");

// Function OrionGame.OrionNotificationLibrary.AddNotification
// 0x0190 (0x0190 - 0x0000)
struct OrionNotificationLibrary_AddNotification final
{
public:
	struct FOrionNotification                     InNotification;                                    // 0x0000(0x0180)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UObject*                                WorldContext;                                      // 0x0180(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_188[0x8];                                      // 0x0188(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionNotificationLibrary_AddNotification) == 0x000010, "Wrong alignment on OrionNotificationLibrary_AddNotification");
static_assert(sizeof(OrionNotificationLibrary_AddNotification) == 0x000190, "Wrong size on OrionNotificationLibrary_AddNotification");
static_assert(offsetof(OrionNotificationLibrary_AddNotification, InNotification) == 0x000000, "Member 'OrionNotificationLibrary_AddNotification::InNotification' has a wrong offset!");
static_assert(offsetof(OrionNotificationLibrary_AddNotification, WorldContext) == 0x000180, "Member 'OrionNotificationLibrary_AddNotification::WorldContext' has a wrong offset!");

// Function OrionGame.OrionNotificationLibrary.BindToNotificationResponse
// 0x0190 (0x0190 - 0x0000)
struct OrionNotificationLibrary_BindToNotificationResponse final
{
public:
	struct FOrionNotification                     InNotification;                                    // 0x0000(0x0180)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FOrionNotification& Notification, ENotificationButton Response)> InCallback;                                        // 0x0180(0x0010)(Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionNotificationLibrary_BindToNotificationResponse) == 0x000010, "Wrong alignment on OrionNotificationLibrary_BindToNotificationResponse");
static_assert(sizeof(OrionNotificationLibrary_BindToNotificationResponse) == 0x000190, "Wrong size on OrionNotificationLibrary_BindToNotificationResponse");
static_assert(offsetof(OrionNotificationLibrary_BindToNotificationResponse, InNotification) == 0x000000, "Member 'OrionNotificationLibrary_BindToNotificationResponse::InNotification' has a wrong offset!");
static_assert(offsetof(OrionNotificationLibrary_BindToNotificationResponse, InCallback) == 0x000180, "Member 'OrionNotificationLibrary_BindToNotificationResponse::InCallback' has a wrong offset!");

// Function OrionGame.OrionNotificationLibrary.ClearAllErrorNotifications
// 0x0008 (0x0008 - 0x0000)
struct OrionNotificationLibrary_ClearAllErrorNotifications final
{
public:
	class UObject*                                WorldContext;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionNotificationLibrary_ClearAllErrorNotifications) == 0x000008, "Wrong alignment on OrionNotificationLibrary_ClearAllErrorNotifications");
static_assert(sizeof(OrionNotificationLibrary_ClearAllErrorNotifications) == 0x000008, "Wrong size on OrionNotificationLibrary_ClearAllErrorNotifications");
static_assert(offsetof(OrionNotificationLibrary_ClearAllErrorNotifications, WorldContext) == 0x000000, "Member 'OrionNotificationLibrary_ClearAllErrorNotifications::WorldContext' has a wrong offset!");

// Function OrionGame.OrionNotificationLibrary.Equal
// 0x0310 (0x0310 - 0x0000)
struct OrionNotificationLibrary_Equal final
{
public:
	struct FOrionNotification                     LHS;                                               // 0x0000(0x0180)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FOrionNotification                     RHS;                                               // 0x0180(0x0180)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0300(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_301[0xF];                                      // 0x0301(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionNotificationLibrary_Equal) == 0x000010, "Wrong alignment on OrionNotificationLibrary_Equal");
static_assert(sizeof(OrionNotificationLibrary_Equal) == 0x000310, "Wrong size on OrionNotificationLibrary_Equal");
static_assert(offsetof(OrionNotificationLibrary_Equal, LHS) == 0x000000, "Member 'OrionNotificationLibrary_Equal::LHS' has a wrong offset!");
static_assert(offsetof(OrionNotificationLibrary_Equal, RHS) == 0x000180, "Member 'OrionNotificationLibrary_Equal::RHS' has a wrong offset!");
static_assert(offsetof(OrionNotificationLibrary_Equal, ReturnValue) == 0x000300, "Member 'OrionNotificationLibrary_Equal::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionNotificationLibrary.GetNotificationDisplayTimeText
// 0x01A0 (0x01A0 - 0x0000)
struct OrionNotificationLibrary_GetNotificationDisplayTimeText final
{
public:
	struct FOrionNotification                     InNotification;                                    // 0x0000(0x0180)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0180(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
	uint8                                         Pad_198[0x8];                                      // 0x0198(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionNotificationLibrary_GetNotificationDisplayTimeText) == 0x000010, "Wrong alignment on OrionNotificationLibrary_GetNotificationDisplayTimeText");
static_assert(sizeof(OrionNotificationLibrary_GetNotificationDisplayTimeText) == 0x0001A0, "Wrong size on OrionNotificationLibrary_GetNotificationDisplayTimeText");
static_assert(offsetof(OrionNotificationLibrary_GetNotificationDisplayTimeText, InNotification) == 0x000000, "Member 'OrionNotificationLibrary_GetNotificationDisplayTimeText::InNotification' has a wrong offset!");
static_assert(offsetof(OrionNotificationLibrary_GetNotificationDisplayTimeText, ReturnValue) == 0x000180, "Member 'OrionNotificationLibrary_GetNotificationDisplayTimeText::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionNotificationLibrary.IsNotificationValid
// 0x0190 (0x0190 - 0x0000)
struct OrionNotificationLibrary_IsNotificationValid final
{
public:
	struct FOrionNotification                     InNotification;                                    // 0x0000(0x0180)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0180(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181[0xF];                                      // 0x0181(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionNotificationLibrary_IsNotificationValid) == 0x000010, "Wrong alignment on OrionNotificationLibrary_IsNotificationValid");
static_assert(sizeof(OrionNotificationLibrary_IsNotificationValid) == 0x000190, "Wrong size on OrionNotificationLibrary_IsNotificationValid");
static_assert(offsetof(OrionNotificationLibrary_IsNotificationValid, InNotification) == 0x000000, "Member 'OrionNotificationLibrary_IsNotificationValid::InNotification' has a wrong offset!");
static_assert(offsetof(OrionNotificationLibrary_IsNotificationValid, ReturnValue) == 0x000180, "Member 'OrionNotificationLibrary_IsNotificationValid::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionNotificationLibrary.KillNotification
// 0x0010 (0x0010 - 0x0000)
struct OrionNotificationLibrary_KillNotification final
{
public:
	class UObject*                                Context;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Identifier;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionNotificationLibrary_KillNotification) == 0x000008, "Wrong alignment on OrionNotificationLibrary_KillNotification");
static_assert(sizeof(OrionNotificationLibrary_KillNotification) == 0x000010, "Wrong size on OrionNotificationLibrary_KillNotification");
static_assert(offsetof(OrionNotificationLibrary_KillNotification, Context) == 0x000000, "Member 'OrionNotificationLibrary_KillNotification::Context' has a wrong offset!");
static_assert(offsetof(OrionNotificationLibrary_KillNotification, Identifier) == 0x000008, "Member 'OrionNotificationLibrary_KillNotification::Identifier' has a wrong offset!");

// Function OrionGame.OrionNotificationLibrary.OnNotificationActionTaken
// 0x0190 (0x0190 - 0x0000)
struct OrionNotificationLibrary_OnNotificationActionTaken final
{
public:
	struct FOrionNotification                     InNotification;                                    // 0x0000(0x0180)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ENotificationButton                           InSelection;                                       // 0x0180(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181[0xF];                                      // 0x0181(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionNotificationLibrary_OnNotificationActionTaken) == 0x000010, "Wrong alignment on OrionNotificationLibrary_OnNotificationActionTaken");
static_assert(sizeof(OrionNotificationLibrary_OnNotificationActionTaken) == 0x000190, "Wrong size on OrionNotificationLibrary_OnNotificationActionTaken");
static_assert(offsetof(OrionNotificationLibrary_OnNotificationActionTaken, InNotification) == 0x000000, "Member 'OrionNotificationLibrary_OnNotificationActionTaken::InNotification' has a wrong offset!");
static_assert(offsetof(OrionNotificationLibrary_OnNotificationActionTaken, InSelection) == 0x000180, "Member 'OrionNotificationLibrary_OnNotificationActionTaken::InSelection' has a wrong offset!");

// Function OrionGame.OrionNotificationLibrary.RemoveNotification
// 0x0190 (0x0190 - 0x0000)
struct OrionNotificationLibrary_RemoveNotification final
{
public:
	struct FOrionNotification                     InNotification;                                    // 0x0000(0x0180)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UObject*                                WorldContext;                                      // 0x0180(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0188(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189[0x7];                                      // 0x0189(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionNotificationLibrary_RemoveNotification) == 0x000010, "Wrong alignment on OrionNotificationLibrary_RemoveNotification");
static_assert(sizeof(OrionNotificationLibrary_RemoveNotification) == 0x000190, "Wrong size on OrionNotificationLibrary_RemoveNotification");
static_assert(offsetof(OrionNotificationLibrary_RemoveNotification, InNotification) == 0x000000, "Member 'OrionNotificationLibrary_RemoveNotification::InNotification' has a wrong offset!");
static_assert(offsetof(OrionNotificationLibrary_RemoveNotification, WorldContext) == 0x000180, "Member 'OrionNotificationLibrary_RemoveNotification::WorldContext' has a wrong offset!");
static_assert(offsetof(OrionNotificationLibrary_RemoveNotification, ReturnValue) == 0x000188, "Member 'OrionNotificationLibrary_RemoveNotification::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionNotificationLibrary.SetNotificationDisplayTime
// 0x0190 (0x0190 - 0x0000)
struct OrionNotificationLibrary_SetNotificationDisplayTime final
{
public:
	struct FOrionNotification                     InNotification;                                    // 0x0000(0x0180)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FTimespan                              Time;                                              // 0x0180(0x0008)(Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                WorldContext;                                      // 0x0188(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionNotificationLibrary_SetNotificationDisplayTime) == 0x000010, "Wrong alignment on OrionNotificationLibrary_SetNotificationDisplayTime");
static_assert(sizeof(OrionNotificationLibrary_SetNotificationDisplayTime) == 0x000190, "Wrong size on OrionNotificationLibrary_SetNotificationDisplayTime");
static_assert(offsetof(OrionNotificationLibrary_SetNotificationDisplayTime, InNotification) == 0x000000, "Member 'OrionNotificationLibrary_SetNotificationDisplayTime::InNotification' has a wrong offset!");
static_assert(offsetof(OrionNotificationLibrary_SetNotificationDisplayTime, Time) == 0x000180, "Member 'OrionNotificationLibrary_SetNotificationDisplayTime::Time' has a wrong offset!");
static_assert(offsetof(OrionNotificationLibrary_SetNotificationDisplayTime, WorldContext) == 0x000188, "Member 'OrionNotificationLibrary_SetNotificationDisplayTime::WorldContext' has a wrong offset!");

// Function OrionGame.OrionNotificationLibrary.ShowNotification
// 0x01C0 (0x01C0 - 0x0000)
struct OrionNotificationLibrary_ShowNotification final
{
public:
	class UObject*                                Context;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TitleText;                                         // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   BodyText;                                          // 0x0020(0x0018)(Parm, NativeAccessSpecifierPublic)
	float                                         DisplayTime;                                       // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionNotification                     ReturnValue;                                       // 0x0040(0x0180)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionNotificationLibrary_ShowNotification) == 0x000010, "Wrong alignment on OrionNotificationLibrary_ShowNotification");
static_assert(sizeof(OrionNotificationLibrary_ShowNotification) == 0x0001C0, "Wrong size on OrionNotificationLibrary_ShowNotification");
static_assert(offsetof(OrionNotificationLibrary_ShowNotification, Context) == 0x000000, "Member 'OrionNotificationLibrary_ShowNotification::Context' has a wrong offset!");
static_assert(offsetof(OrionNotificationLibrary_ShowNotification, TitleText) == 0x000008, "Member 'OrionNotificationLibrary_ShowNotification::TitleText' has a wrong offset!");
static_assert(offsetof(OrionNotificationLibrary_ShowNotification, BodyText) == 0x000020, "Member 'OrionNotificationLibrary_ShowNotification::BodyText' has a wrong offset!");
static_assert(offsetof(OrionNotificationLibrary_ShowNotification, DisplayTime) == 0x000038, "Member 'OrionNotificationLibrary_ShowNotification::DisplayTime' has a wrong offset!");
static_assert(offsetof(OrionNotificationLibrary_ShowNotification, ReturnValue) == 0x000040, "Member 'OrionNotificationLibrary_ShowNotification::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionNotificationInterface.GetNotification
// 0x0180 (0x0180 - 0x0000)
struct OrionNotificationInterface_GetNotification final
{
public:
	struct FOrionNotification                     ReturnValue;                                       // 0x0000(0x0180)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionNotificationInterface_GetNotification) == 0x000010, "Wrong alignment on OrionNotificationInterface_GetNotification");
static_assert(sizeof(OrionNotificationInterface_GetNotification) == 0x000180, "Wrong size on OrionNotificationInterface_GetNotification");
static_assert(offsetof(OrionNotificationInterface_GetNotification, ReturnValue) == 0x000000, "Member 'OrionNotificationInterface_GetNotification::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPartyBeaconClient.ClientSendAcceptMatchPlayersUpdate
// 0x0010 (0x0010 - 0x0000)
struct OrionPartyBeaconClient_ClientSendAcceptMatchPlayersUpdate final
{
public:
	TArray<struct FOrionAcceptMatchData>          AcceptMatchPlayers;                                // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPartyBeaconClient_ClientSendAcceptMatchPlayersUpdate) == 0x000008, "Wrong alignment on OrionPartyBeaconClient_ClientSendAcceptMatchPlayersUpdate");
static_assert(sizeof(OrionPartyBeaconClient_ClientSendAcceptMatchPlayersUpdate) == 0x000010, "Wrong size on OrionPartyBeaconClient_ClientSendAcceptMatchPlayersUpdate");
static_assert(offsetof(OrionPartyBeaconClient_ClientSendAcceptMatchPlayersUpdate, AcceptMatchPlayers) == 0x000000, "Member 'OrionPartyBeaconClient_ClientSendAcceptMatchPlayersUpdate::AcceptMatchPlayers' has a wrong offset!");

// Function OrionGame.OrionPartyBeaconClient.ClientSendLobbyStateChanged
// 0x0001 (0x0001 - 0x0000)
struct OrionPartyBeaconClient_ClientSendLobbyStateChanged final
{
public:
	EOrionBeaconLobbyState                        NewState;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPartyBeaconClient_ClientSendLobbyStateChanged) == 0x000001, "Wrong alignment on OrionPartyBeaconClient_ClientSendLobbyStateChanged");
static_assert(sizeof(OrionPartyBeaconClient_ClientSendLobbyStateChanged) == 0x000001, "Wrong size on OrionPartyBeaconClient_ClientSendLobbyStateChanged");
static_assert(offsetof(OrionPartyBeaconClient_ClientSendLobbyStateChanged, NewState) == 0x000000, "Member 'OrionPartyBeaconClient_ClientSendLobbyStateChanged::NewState' has a wrong offset!");

// Function OrionGame.OrionPartyBeaconClient.ClientSetTeamInfoResponse
// 0x0001 (0x0001 - 0x0000)
struct OrionPartyBeaconClient_ClientSetTeamInfoResponse final
{
public:
	EPartySetTeamInfoResult                       Result;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPartyBeaconClient_ClientSetTeamInfoResponse) == 0x000001, "Wrong alignment on OrionPartyBeaconClient_ClientSetTeamInfoResponse");
static_assert(sizeof(OrionPartyBeaconClient_ClientSetTeamInfoResponse) == 0x000001, "Wrong size on OrionPartyBeaconClient_ClientSetTeamInfoResponse");
static_assert(offsetof(OrionPartyBeaconClient_ClientSetTeamInfoResponse, Result) == 0x000000, "Member 'OrionPartyBeaconClient_ClientSetTeamInfoResponse::Result' has a wrong offset!");

// Function OrionGame.OrionPartyBeaconClient.ServerConfigureMatchReservationRequest
// 0x0080 (0x0080 - 0x0000)
struct OrionPartyBeaconClient_ServerConfigureMatchReservationRequest final
{
public:
	class FString                                 InSessionId;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionMatchConfig                      MatchConfig;                                       // 0x0010(0x0040)(Parm, NativeAccessSpecifierPublic)
	struct FPartyReservation                      PartyReservation;                                  // 0x0050(0x0030)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPartyBeaconClient_ServerConfigureMatchReservationRequest) == 0x000008, "Wrong alignment on OrionPartyBeaconClient_ServerConfigureMatchReservationRequest");
static_assert(sizeof(OrionPartyBeaconClient_ServerConfigureMatchReservationRequest) == 0x000080, "Wrong size on OrionPartyBeaconClient_ServerConfigureMatchReservationRequest");
static_assert(offsetof(OrionPartyBeaconClient_ServerConfigureMatchReservationRequest, InSessionId) == 0x000000, "Member 'OrionPartyBeaconClient_ServerConfigureMatchReservationRequest::InSessionId' has a wrong offset!");
static_assert(offsetof(OrionPartyBeaconClient_ServerConfigureMatchReservationRequest, MatchConfig) == 0x000010, "Member 'OrionPartyBeaconClient_ServerConfigureMatchReservationRequest::MatchConfig' has a wrong offset!");
static_assert(offsetof(OrionPartyBeaconClient_ServerConfigureMatchReservationRequest, PartyReservation) == 0x000050, "Member 'OrionPartyBeaconClient_ServerConfigureMatchReservationRequest::PartyReservation' has a wrong offset!");

// Function OrionGame.OrionPartyBeaconClient.ServerSetAcceptedMatch
// 0x0038 (0x0038 - 0x0000)
struct OrionPartyBeaconClient_ServerSetAcceptedMatch final
{
public:
	struct FUniqueNetIdRepl                       PartyLeader;                                       // 0x0000(0x0018)(ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUniqueNetIdRepl                       MemberId;                                          // 0x0018(0x0018)(ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionAcceptMatchState                        AcceptState;                                       // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionPartyBeaconClient_ServerSetAcceptedMatch) == 0x000008, "Wrong alignment on OrionPartyBeaconClient_ServerSetAcceptedMatch");
static_assert(sizeof(OrionPartyBeaconClient_ServerSetAcceptedMatch) == 0x000038, "Wrong size on OrionPartyBeaconClient_ServerSetAcceptedMatch");
static_assert(offsetof(OrionPartyBeaconClient_ServerSetAcceptedMatch, PartyLeader) == 0x000000, "Member 'OrionPartyBeaconClient_ServerSetAcceptedMatch::PartyLeader' has a wrong offset!");
static_assert(offsetof(OrionPartyBeaconClient_ServerSetAcceptedMatch, MemberId) == 0x000018, "Member 'OrionPartyBeaconClient_ServerSetAcceptedMatch::MemberId' has a wrong offset!");
static_assert(offsetof(OrionPartyBeaconClient_ServerSetAcceptedMatch, AcceptState) == 0x000030, "Member 'OrionPartyBeaconClient_ServerSetAcceptedMatch::AcceptState' has a wrong offset!");

// Function OrionGame.OrionPartyBeaconClient.ServerSetTeamInfoRequest
// 0x01A8 (0x01A8 - 0x0000)
struct OrionPartyBeaconClient_ServerSetTeamInfoRequest final
{
public:
	struct FUniqueNetIdRepl                       PartyLeader;                                       // 0x0000(0x0018)(ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerTeam;                                       // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionTBTeamInfo                       TeamInfo;                                          // 0x0020(0x0188)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPartyBeaconClient_ServerSetTeamInfoRequest) == 0x000008, "Wrong alignment on OrionPartyBeaconClient_ServerSetTeamInfoRequest");
static_assert(sizeof(OrionPartyBeaconClient_ServerSetTeamInfoRequest) == 0x0001A8, "Wrong size on OrionPartyBeaconClient_ServerSetTeamInfoRequest");
static_assert(offsetof(OrionPartyBeaconClient_ServerSetTeamInfoRequest, PartyLeader) == 0x000000, "Member 'OrionPartyBeaconClient_ServerSetTeamInfoRequest::PartyLeader' has a wrong offset!");
static_assert(offsetof(OrionPartyBeaconClient_ServerSetTeamInfoRequest, bPlayerTeam) == 0x000018, "Member 'OrionPartyBeaconClient_ServerSetTeamInfoRequest::bPlayerTeam' has a wrong offset!");
static_assert(offsetof(OrionPartyBeaconClient_ServerSetTeamInfoRequest, TeamInfo) == 0x000020, "Member 'OrionPartyBeaconClient_ServerSetTeamInfoRequest::TeamInfo' has a wrong offset!");

// Function OrionGame.OrionPartyMemberState.GetAccountLevel
// 0x0004 (0x0004 - 0x0000)
struct OrionPartyMemberState_GetAccountLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPartyMemberState_GetAccountLevel) == 0x000004, "Wrong alignment on OrionPartyMemberState_GetAccountLevel");
static_assert(sizeof(OrionPartyMemberState_GetAccountLevel) == 0x000004, "Wrong size on OrionPartyMemberState_GetAccountLevel");
static_assert(offsetof(OrionPartyMemberState_GetAccountLevel, ReturnValue) == 0x000000, "Member 'OrionPartyMemberState_GetAccountLevel::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPartyMemberState.GetIsConsole
// 0x0004 (0x0004 - 0x0000)
struct OrionPartyMemberState_GetIsConsole final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPartyMemberState_GetIsConsole) == 0x000004, "Wrong alignment on OrionPartyMemberState_GetIsConsole");
static_assert(sizeof(OrionPartyMemberState_GetIsConsole) == 0x000004, "Wrong size on OrionPartyMemberState_GetIsConsole");
static_assert(offsetof(OrionPartyMemberState_GetIsConsole, ReturnValue) == 0x000000, "Member 'OrionPartyMemberState_GetIsConsole::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPartyMemberState.GetLevelProgress
// 0x0004 (0x0004 - 0x0000)
struct OrionPartyMemberState_GetLevelProgress final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPartyMemberState_GetLevelProgress) == 0x000004, "Wrong alignment on OrionPartyMemberState_GetLevelProgress");
static_assert(sizeof(OrionPartyMemberState_GetLevelProgress) == 0x000004, "Wrong size on OrionPartyMemberState_GetLevelProgress");
static_assert(offsetof(OrionPartyMemberState_GetLevelProgress, ReturnValue) == 0x000000, "Member 'OrionPartyMemberState_GetLevelProgress::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPartyMemberState.IsDirty
// 0x0002 (0x0002 - 0x0000)
struct OrionPartyMemberState_IsDirty final
{
public:
	EOrionPartyMemberStateFlags                   Flag;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPartyMemberState_IsDirty) == 0x000001, "Wrong alignment on OrionPartyMemberState_IsDirty");
static_assert(sizeof(OrionPartyMemberState_IsDirty) == 0x000002, "Wrong size on OrionPartyMemberState_IsDirty");
static_assert(offsetof(OrionPartyMemberState_IsDirty, Flag) == 0x000000, "Member 'OrionPartyMemberState_IsDirty::Flag' has a wrong offset!");
static_assert(offsetof(OrionPartyMemberState_IsDirty, ReturnValue) == 0x000001, "Member 'OrionPartyMemberState_IsDirty::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPersistentPartyMember.SetHero
// 0x0008 (0x0008 - 0x0000)
struct OrionPersistentPartyMember_SetHero final
{
public:
	class UOrionHeroData*                         InHero;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPersistentPartyMember_SetHero) == 0x000008, "Wrong alignment on OrionPersistentPartyMember_SetHero");
static_assert(sizeof(OrionPersistentPartyMember_SetHero) == 0x000008, "Wrong size on OrionPersistentPartyMember_SetHero");
static_assert(offsetof(OrionPersistentPartyMember_SetHero, InHero) == 0x000000, "Member 'OrionPersistentPartyMember_SetHero::InHero' has a wrong offset!");

// Function OrionGame.OrionPersistentPartyMember.SetLoaded
// 0x0001 (0x0001 - 0x0000)
struct OrionPersistentPartyMember_SetLoaded final
{
public:
	bool                                          InLoaded;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPersistentPartyMember_SetLoaded) == 0x000001, "Wrong alignment on OrionPersistentPartyMember_SetLoaded");
static_assert(sizeof(OrionPersistentPartyMember_SetLoaded) == 0x000001, "Wrong size on OrionPersistentPartyMember_SetLoaded");
static_assert(offsetof(OrionPersistentPartyMember_SetLoaded, InLoaded) == 0x000000, "Member 'OrionPersistentPartyMember_SetLoaded::InLoaded' has a wrong offset!");

// Function OrionGame.OrionPersistentPartyMember.SetReady
// 0x0001 (0x0001 - 0x0000)
struct OrionPersistentPartyMember_SetReady final
{
public:
	bool                                          bInReady;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPersistentPartyMember_SetReady) == 0x000001, "Wrong alignment on OrionPersistentPartyMember_SetReady");
static_assert(sizeof(OrionPersistentPartyMember_SetReady) == 0x000001, "Wrong size on OrionPersistentPartyMember_SetReady");
static_assert(offsetof(OrionPersistentPartyMember_SetReady, bInReady) == 0x000000, "Member 'OrionPersistentPartyMember_SetReady::bInReady' has a wrong offset!");

// Function OrionGame.OrionPersistentPartyMember.GetCurrentBanReason
// 0x0001 (0x0001 - 0x0000)
struct OrionPersistentPartyMember_GetCurrentBanReason final
{
public:
	EOrionBanReason                               ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPersistentPartyMember_GetCurrentBanReason) == 0x000001, "Wrong alignment on OrionPersistentPartyMember_GetCurrentBanReason");
static_assert(sizeof(OrionPersistentPartyMember_GetCurrentBanReason) == 0x000001, "Wrong size on OrionPersistentPartyMember_GetCurrentBanReason");
static_assert(offsetof(OrionPersistentPartyMember_GetCurrentBanReason, ReturnValue) == 0x000000, "Member 'OrionPersistentPartyMember_GetCurrentBanReason::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPersistentPartyMember.GetHero
// 0x0010 (0x0010 - 0x0000)
struct OrionPersistentPartyMember_GetHero final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPersistentPartyMember_GetHero) == 0x000008, "Wrong alignment on OrionPersistentPartyMember_GetHero");
static_assert(sizeof(OrionPersistentPartyMember_GetHero) == 0x000010, "Wrong size on OrionPersistentPartyMember_GetHero");
static_assert(offsetof(OrionPersistentPartyMember_GetHero, ReturnValue) == 0x000000, "Member 'OrionPersistentPartyMember_GetHero::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPersistentPartyMember.GetLocation
// 0x0001 (0x0001 - 0x0000)
struct OrionPersistentPartyMember_GetLocation final
{
public:
	EOrionPartyMemberLocation                     ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPersistentPartyMember_GetLocation) == 0x000001, "Wrong alignment on OrionPersistentPartyMember_GetLocation");
static_assert(sizeof(OrionPersistentPartyMember_GetLocation) == 0x000001, "Wrong size on OrionPersistentPartyMember_GetLocation");
static_assert(offsetof(OrionPersistentPartyMember_GetLocation, ReturnValue) == 0x000000, "Member 'OrionPersistentPartyMember_GetLocation::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPersistentPartyMember.HasLockedInHero
// 0x0010 (0x0010 - 0x0000)
struct OrionPersistentPartyMember_HasLockedInHero final
{
public:
	class UOrionHeroData*                         HeroData;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionPersistentPartyMember_HasLockedInHero) == 0x000008, "Wrong alignment on OrionPersistentPartyMember_HasLockedInHero");
static_assert(sizeof(OrionPersistentPartyMember_HasLockedInHero) == 0x000010, "Wrong size on OrionPersistentPartyMember_HasLockedInHero");
static_assert(offsetof(OrionPersistentPartyMember_HasLockedInHero, HeroData) == 0x000000, "Member 'OrionPersistentPartyMember_HasLockedInHero::HeroData' has a wrong offset!");
static_assert(offsetof(OrionPersistentPartyMember_HasLockedInHero, ReturnValue) == 0x000008, "Member 'OrionPersistentPartyMember_HasLockedInHero::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPersistentPartyMember.IsDirty
// 0x0002 (0x0002 - 0x0000)
struct OrionPersistentPartyMember_IsDirty final
{
public:
	EOrionPersistentPartyMemberStateFlags         Flag;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPersistentPartyMember_IsDirty) == 0x000001, "Wrong alignment on OrionPersistentPartyMember_IsDirty");
static_assert(sizeof(OrionPersistentPartyMember_IsDirty) == 0x000002, "Wrong size on OrionPersistentPartyMember_IsDirty");
static_assert(offsetof(OrionPersistentPartyMember_IsDirty, Flag) == 0x000000, "Member 'OrionPersistentPartyMember_IsDirty::Flag' has a wrong offset!");
static_assert(offsetof(OrionPersistentPartyMember_IsDirty, ReturnValue) == 0x000001, "Member 'OrionPersistentPartyMember_IsDirty::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPersistentPartyMember.IsLoaded
// 0x0001 (0x0001 - 0x0000)
struct OrionPersistentPartyMember_IsLoaded final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPersistentPartyMember_IsLoaded) == 0x000001, "Wrong alignment on OrionPersistentPartyMember_IsLoaded");
static_assert(sizeof(OrionPersistentPartyMember_IsLoaded) == 0x000001, "Wrong size on OrionPersistentPartyMember_IsLoaded");
static_assert(offsetof(OrionPersistentPartyMember_IsLoaded, ReturnValue) == 0x000000, "Member 'OrionPersistentPartyMember_IsLoaded::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPersistentPartyMember.IsReady
// 0x0001 (0x0001 - 0x0000)
struct OrionPersistentPartyMember_IsReady final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPersistentPartyMember_IsReady) == 0x000001, "Wrong alignment on OrionPersistentPartyMember_IsReady");
static_assert(sizeof(OrionPersistentPartyMember_IsReady) == 0x000001, "Wrong size on OrionPersistentPartyMember_IsReady");
static_assert(offsetof(OrionPersistentPartyMember_IsReady, ReturnValue) == 0x000000, "Member 'OrionPersistentPartyMember_IsReady::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPickupManager.DeactivatePickupsOfType
// 0x0008 (0x0008 - 0x0000)
struct OrionPickupManager_DeactivatePickupsOfType final
{
public:
	TSubclassOf<class AOrionPickup>               PickupClass;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPickupManager_DeactivatePickupsOfType) == 0x000008, "Wrong alignment on OrionPickupManager_DeactivatePickupsOfType");
static_assert(sizeof(OrionPickupManager_DeactivatePickupsOfType) == 0x000008, "Wrong size on OrionPickupManager_DeactivatePickupsOfType");
static_assert(offsetof(OrionPickupManager_DeactivatePickupsOfType, PickupClass) == 0x000000, "Member 'OrionPickupManager_DeactivatePickupsOfType::PickupClass' has a wrong offset!");

// Function OrionGame.OrionPickupManager.ReliableHandlePickupCollected
// 0x0010 (0x0010 - 0x0000)
struct OrionPickupManager_ReliableHandlePickupCollected final
{
public:
	uint64                                        InPickupID;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Collector;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPickupManager_ReliableHandlePickupCollected) == 0x000008, "Wrong alignment on OrionPickupManager_ReliableHandlePickupCollected");
static_assert(sizeof(OrionPickupManager_ReliableHandlePickupCollected) == 0x000010, "Wrong size on OrionPickupManager_ReliableHandlePickupCollected");
static_assert(offsetof(OrionPickupManager_ReliableHandlePickupCollected, InPickupID) == 0x000000, "Member 'OrionPickupManager_ReliableHandlePickupCollected::InPickupID' has a wrong offset!");
static_assert(offsetof(OrionPickupManager_ReliableHandlePickupCollected, Collector) == 0x000008, "Member 'OrionPickupManager_ReliableHandlePickupCollected::Collector' has a wrong offset!");

// Function OrionGame.OrionPickupManager.ReliableRelaunchPickup
// 0x0050 (0x0050 - 0x0000)
struct OrionPickupManager_ReliableRelaunchPickup final
{
public:
	struct FPickupLaunchInfo                      LaunchInfo;                                        // 0x0000(0x0050)(ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPickupManager_ReliableRelaunchPickup) == 0x000008, "Wrong alignment on OrionPickupManager_ReliableRelaunchPickup");
static_assert(sizeof(OrionPickupManager_ReliableRelaunchPickup) == 0x000050, "Wrong size on OrionPickupManager_ReliableRelaunchPickup");
static_assert(offsetof(OrionPickupManager_ReliableRelaunchPickup, LaunchInfo) == 0x000000, "Member 'OrionPickupManager_ReliableRelaunchPickup::LaunchInfo' has a wrong offset!");

// Function OrionGame.OrionPickupManager.ReliableSetExpireTimerTo
// 0x0010 (0x0010 - 0x0000)
struct OrionPickupManager_ReliableSetExpireTimerTo final
{
public:
	uint64                                        InPickupID;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewExpireTime;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionPickupManager_ReliableSetExpireTimerTo) == 0x000008, "Wrong alignment on OrionPickupManager_ReliableSetExpireTimerTo");
static_assert(sizeof(OrionPickupManager_ReliableSetExpireTimerTo) == 0x000010, "Wrong size on OrionPickupManager_ReliableSetExpireTimerTo");
static_assert(offsetof(OrionPickupManager_ReliableSetExpireTimerTo, InPickupID) == 0x000000, "Member 'OrionPickupManager_ReliableSetExpireTimerTo::InPickupID' has a wrong offset!");
static_assert(offsetof(OrionPickupManager_ReliableSetExpireTimerTo, NewExpireTime) == 0x000008, "Member 'OrionPickupManager_ReliableSetExpireTimerTo::NewExpireTime' has a wrong offset!");

// Function OrionGame.OrionPickupManager.ReliableSetPickupLocation
// 0x0018 (0x0018 - 0x0000)
struct OrionPickupManager_ReliableSetPickupLocation final
{
public:
	uint64                                        InPickupID;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NewLocation;                                       // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionPickupManager_ReliableSetPickupLocation) == 0x000008, "Wrong alignment on OrionPickupManager_ReliableSetPickupLocation");
static_assert(sizeof(OrionPickupManager_ReliableSetPickupLocation) == 0x000018, "Wrong size on OrionPickupManager_ReliableSetPickupLocation");
static_assert(offsetof(OrionPickupManager_ReliableSetPickupLocation, InPickupID) == 0x000000, "Member 'OrionPickupManager_ReliableSetPickupLocation::InPickupID' has a wrong offset!");
static_assert(offsetof(OrionPickupManager_ReliableSetPickupLocation, NewLocation) == 0x000008, "Member 'OrionPickupManager_ReliableSetPickupLocation::NewLocation' has a wrong offset!");

// Function OrionGame.OrionPickupManager.ReliableSpawnPickup
// 0x0108 (0x0108 - 0x0000)
struct OrionPickupManager_ReliableSpawnPickup final
{
public:
	struct FPickupSpawnInfo                       CoinSpawnInfo;                                     // 0x0000(0x0108)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPickupManager_ReliableSpawnPickup) == 0x000008, "Wrong alignment on OrionPickupManager_ReliableSpawnPickup");
static_assert(sizeof(OrionPickupManager_ReliableSpawnPickup) == 0x000108, "Wrong size on OrionPickupManager_ReliableSpawnPickup");
static_assert(offsetof(OrionPickupManager_ReliableSpawnPickup, CoinSpawnInfo) == 0x000000, "Member 'OrionPickupManager_ReliableSpawnPickup::CoinSpawnInfo' has a wrong offset!");

// Function OrionGame.OrionPickupManager.UnrealiableSpawnPickup
// 0x0108 (0x0108 - 0x0000)
struct OrionPickupManager_UnrealiableSpawnPickup final
{
public:
	struct FPickupSpawnInfo                       CoinSpawnInfo;                                     // 0x0000(0x0108)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPickupManager_UnrealiableSpawnPickup) == 0x000008, "Wrong alignment on OrionPickupManager_UnrealiableSpawnPickup");
static_assert(sizeof(OrionPickupManager_UnrealiableSpawnPickup) == 0x000108, "Wrong size on OrionPickupManager_UnrealiableSpawnPickup");
static_assert(offsetof(OrionPickupManager_UnrealiableSpawnPickup, CoinSpawnInfo) == 0x000000, "Member 'OrionPickupManager_UnrealiableSpawnPickup::CoinSpawnInfo' has a wrong offset!");

// Function OrionGame.OrionPickupManager.UnreliableHandlePickupCollected
// 0x0010 (0x0010 - 0x0000)
struct OrionPickupManager_UnreliableHandlePickupCollected final
{
public:
	uint64                                        InPickupID;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Collector;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPickupManager_UnreliableHandlePickupCollected) == 0x000008, "Wrong alignment on OrionPickupManager_UnreliableHandlePickupCollected");
static_assert(sizeof(OrionPickupManager_UnreliableHandlePickupCollected) == 0x000010, "Wrong size on OrionPickupManager_UnreliableHandlePickupCollected");
static_assert(offsetof(OrionPickupManager_UnreliableHandlePickupCollected, InPickupID) == 0x000000, "Member 'OrionPickupManager_UnreliableHandlePickupCollected::InPickupID' has a wrong offset!");
static_assert(offsetof(OrionPickupManager_UnreliableHandlePickupCollected, Collector) == 0x000008, "Member 'OrionPickupManager_UnreliableHandlePickupCollected::Collector' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Sandbox.SetHero
// 0x0008 (0x0008 - 0x0000)
struct OrionPlayerController_Sandbox_SetHero final
{
public:
	class UOrionHeroData*                         SelectedHeroData;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Sandbox_SetHero) == 0x000008, "Wrong alignment on OrionPlayerController_Sandbox_SetHero");
static_assert(sizeof(OrionPlayerController_Sandbox_SetHero) == 0x000008, "Wrong size on OrionPlayerController_Sandbox_SetHero");
static_assert(offsetof(OrionPlayerController_Sandbox_SetHero, SelectedHeroData) == 0x000000, "Member 'OrionPlayerController_Sandbox_SetHero::SelectedHeroData' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Tutorial.RecordTutorialAnalytics
// 0x0010 (0x0010 - 0x0000)
struct OrionPlayerController_Tutorial_RecordTutorialAnalytics final
{
public:
	struct FGameplayStatTag                       Stat;                                              // 0x0000(0x0010)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Tutorial_RecordTutorialAnalytics) == 0x000008, "Wrong alignment on OrionPlayerController_Tutorial_RecordTutorialAnalytics");
static_assert(sizeof(OrionPlayerController_Tutorial_RecordTutorialAnalytics) == 0x000010, "Wrong size on OrionPlayerController_Tutorial_RecordTutorialAnalytics");
static_assert(offsetof(OrionPlayerController_Tutorial_RecordTutorialAnalytics, Stat) == 0x000000, "Member 'OrionPlayerController_Tutorial_RecordTutorialAnalytics::Stat' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Tutorial.ServerFindPathToActor
// 0x0008 (0x0008 - 0x0000)
struct OrionPlayerController_Tutorial_ServerFindPathToActor final
{
public:
	class AActor*                                 InTargetActor;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Tutorial_ServerFindPathToActor) == 0x000008, "Wrong alignment on OrionPlayerController_Tutorial_ServerFindPathToActor");
static_assert(sizeof(OrionPlayerController_Tutorial_ServerFindPathToActor) == 0x000008, "Wrong size on OrionPlayerController_Tutorial_ServerFindPathToActor");
static_assert(offsetof(OrionPlayerController_Tutorial_ServerFindPathToActor, InTargetActor) == 0x000000, "Member 'OrionPlayerController_Tutorial_ServerFindPathToActor::InTargetActor' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Tutorial.ServerForceStartTutorialSpawner
// 0x0010 (0x0010 - 0x0000)
struct OrionPlayerController_Tutorial_ServerForceStartTutorialSpawner final
{
public:
	class AOrionCharAISpawner*                    Spawner;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionCharAISpawnerType                       InType;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionPlayerController_Tutorial_ServerForceStartTutorialSpawner) == 0x000008, "Wrong alignment on OrionPlayerController_Tutorial_ServerForceStartTutorialSpawner");
static_assert(sizeof(OrionPlayerController_Tutorial_ServerForceStartTutorialSpawner) == 0x000010, "Wrong size on OrionPlayerController_Tutorial_ServerForceStartTutorialSpawner");
static_assert(offsetof(OrionPlayerController_Tutorial_ServerForceStartTutorialSpawner, Spawner) == 0x000000, "Member 'OrionPlayerController_Tutorial_ServerForceStartTutorialSpawner::Spawner' has a wrong offset!");
static_assert(offsetof(OrionPlayerController_Tutorial_ServerForceStartTutorialSpawner, InType) == 0x000008, "Member 'OrionPlayerController_Tutorial_ServerForceStartTutorialSpawner::InType' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Tutorial.ServerForceStopTutorialSequencer
// 0x0008 (0x0008 - 0x0000)
struct OrionPlayerController_Tutorial_ServerForceStopTutorialSequencer final
{
public:
	class ALevelSequenceActor*                    SequenceActor;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Tutorial_ServerForceStopTutorialSequencer) == 0x000008, "Wrong alignment on OrionPlayerController_Tutorial_ServerForceStopTutorialSequencer");
static_assert(sizeof(OrionPlayerController_Tutorial_ServerForceStopTutorialSequencer) == 0x000008, "Wrong size on OrionPlayerController_Tutorial_ServerForceStopTutorialSequencer");
static_assert(offsetof(OrionPlayerController_Tutorial_ServerForceStopTutorialSequencer, SequenceActor) == 0x000000, "Member 'OrionPlayerController_Tutorial_ServerForceStopTutorialSequencer::SequenceActor' has a wrong offset!");

// Function OrionGame.OrionPlayerController_Tutorial.UpdateTutorialStat
// 0x0010 (0x0010 - 0x0000)
struct OrionPlayerController_Tutorial_UpdateTutorialStat final
{
public:
	struct FGameplayStatTag                       Stat;                                              // 0x0000(0x0010)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerController_Tutorial_UpdateTutorialStat) == 0x000008, "Wrong alignment on OrionPlayerController_Tutorial_UpdateTutorialStat");
static_assert(sizeof(OrionPlayerController_Tutorial_UpdateTutorialStat) == 0x000010, "Wrong size on OrionPlayerController_Tutorial_UpdateTutorialStat");
static_assert(offsetof(OrionPlayerController_Tutorial_UpdateTutorialStat, Stat) == 0x000000, "Member 'OrionPlayerController_Tutorial_UpdateTutorialStat::Stat' has a wrong offset!");

// Function OrionGame.OrionPlayerStart.GetPlayerStartType
// 0x0001 (0x0001 - 0x0000)
struct OrionPlayerStart_GetPlayerStartType final
{
public:
	EOrionPlayerStartType                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerStart_GetPlayerStartType) == 0x000001, "Wrong alignment on OrionPlayerStart_GetPlayerStartType");
static_assert(sizeof(OrionPlayerStart_GetPlayerStartType) == 0x000001, "Wrong size on OrionPlayerStart_GetPlayerStartType");
static_assert(offsetof(OrionPlayerStart_GetPlayerStartType, ReturnValue) == 0x000000, "Member 'OrionPlayerStart_GetPlayerStartType::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlayerStart.GetTeamNum
// 0x0001 (0x0001 - 0x0000)
struct OrionPlayerStart_GetTeamNum final
{
public:
	EOrionTeam                                    ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerStart_GetTeamNum) == 0x000001, "Wrong alignment on OrionPlayerStart_GetTeamNum");
static_assert(sizeof(OrionPlayerStart_GetTeamNum) == 0x000001, "Wrong size on OrionPlayerStart_GetTeamNum");
static_assert(offsetof(OrionPlayerStart_GetTeamNum, ReturnValue) == 0x000000, "Member 'OrionPlayerStart_GetTeamNum::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlayerStart.IsEnabled
// 0x0001 (0x0001 - 0x0000)
struct OrionPlayerStart_IsEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerStart_IsEnabled) == 0x000001, "Wrong alignment on OrionPlayerStart_IsEnabled");
static_assert(sizeof(OrionPlayerStart_IsEnabled) == 0x000001, "Wrong size on OrionPlayerStart_IsEnabled");
static_assert(offsetof(OrionPlayerStart_IsEnabled, ReturnValue) == 0x000000, "Member 'OrionPlayerStart_IsEnabled::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlayerState_DraftLobby.OnRep_TeamSpecificInfo
// 0x0038 (0x0038 - 0x0000)
struct OrionPlayerState_DraftLobby_OnRep_TeamSpecificInfo final
{
public:
	struct FTeamSpecificDraftPlayerInfo           OldInfo;                                           // 0x0000(0x0038)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerState_DraftLobby_OnRep_TeamSpecificInfo) == 0x000008, "Wrong alignment on OrionPlayerState_DraftLobby_OnRep_TeamSpecificInfo");
static_assert(sizeof(OrionPlayerState_DraftLobby_OnRep_TeamSpecificInfo) == 0x000038, "Wrong size on OrionPlayerState_DraftLobby_OnRep_TeamSpecificInfo");
static_assert(offsetof(OrionPlayerState_DraftLobby_OnRep_TeamSpecificInfo, OldInfo) == 0x000000, "Member 'OrionPlayerState_DraftLobby_OnRep_TeamSpecificInfo::OldInfo' has a wrong offset!");

// Function OrionGame.OrionPlayerState_Tutorial.ForceHeroToLevel
// 0x0004 (0x0004 - 0x0000)
struct OrionPlayerState_Tutorial_ForceHeroToLevel final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerState_Tutorial_ForceHeroToLevel) == 0x000004, "Wrong alignment on OrionPlayerState_Tutorial_ForceHeroToLevel");
static_assert(sizeof(OrionPlayerState_Tutorial_ForceHeroToLevel) == 0x000004, "Wrong size on OrionPlayerState_Tutorial_ForceHeroToLevel");
static_assert(offsetof(OrionPlayerState_Tutorial_ForceHeroToLevel, Level) == 0x000000, "Member 'OrionPlayerState_Tutorial_ForceHeroToLevel::Level' has a wrong offset!");

// Function OrionGame.OrionPlayerState_Tutorial.ServerUpdateStatFromTutorial
// 0x0008 (0x0008 - 0x0000)
struct OrionPlayerState_Tutorial_ServerUpdateStatFromTutorial final
{
public:
	TSubclassOf<class UOrionTutorial>             TutorialClass;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlayerState_Tutorial_ServerUpdateStatFromTutorial) == 0x000008, "Wrong alignment on OrionPlayerState_Tutorial_ServerUpdateStatFromTutorial");
static_assert(sizeof(OrionPlayerState_Tutorial_ServerUpdateStatFromTutorial) == 0x000008, "Wrong size on OrionPlayerState_Tutorial_ServerUpdateStatFromTutorial");
static_assert(offsetof(OrionPlayerState_Tutorial_ServerUpdateStatFromTutorial, TutorialClass) == 0x000000, "Member 'OrionPlayerState_Tutorial_ServerUpdateStatFromTutorial::TutorialClass' has a wrong offset!");

// Function OrionGame.OrionPlaylistManager.AllowsRejoin
// 0x0008 (0x0008 - 0x0000)
struct OrionPlaylistManager_AllowsRejoin final
{
public:
	int32                                         PlaylistId;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionPlaylistManager_AllowsRejoin) == 0x000004, "Wrong alignment on OrionPlaylistManager_AllowsRejoin");
static_assert(sizeof(OrionPlaylistManager_AllowsRejoin) == 0x000008, "Wrong size on OrionPlaylistManager_AllowsRejoin");
static_assert(offsetof(OrionPlaylistManager_AllowsRejoin, PlaylistId) == 0x000000, "Member 'OrionPlaylistManager_AllowsRejoin::PlaylistId' has a wrong offset!");
static_assert(offsetof(OrionPlaylistManager_AllowsRejoin, ReturnValue) == 0x000004, "Member 'OrionPlaylistManager_AllowsRejoin::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlaylistManager.AllowsSurrender
// 0x0008 (0x0008 - 0x0000)
struct OrionPlaylistManager_AllowsSurrender final
{
public:
	int32                                         PlaylistId;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionPlaylistManager_AllowsSurrender) == 0x000004, "Wrong alignment on OrionPlaylistManager_AllowsSurrender");
static_assert(sizeof(OrionPlaylistManager_AllowsSurrender) == 0x000008, "Wrong size on OrionPlaylistManager_AllowsSurrender");
static_assert(offsetof(OrionPlaylistManager_AllowsSurrender, PlaylistId) == 0x000000, "Member 'OrionPlaylistManager_AllowsSurrender::PlaylistId' has a wrong offset!");
static_assert(offsetof(OrionPlaylistManager_AllowsSurrender, ReturnValue) == 0x000004, "Member 'OrionPlaylistManager_AllowsSurrender::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlaylistManager.AwardsXP
// 0x0008 (0x0008 - 0x0000)
struct OrionPlaylistManager_AwardsXP final
{
public:
	int32                                         PlaylistId;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionPlaylistManager_AwardsXP) == 0x000004, "Wrong alignment on OrionPlaylistManager_AwardsXP");
static_assert(sizeof(OrionPlaylistManager_AwardsXP) == 0x000008, "Wrong size on OrionPlaylistManager_AwardsXP");
static_assert(offsetof(OrionPlaylistManager_AwardsXP, PlaylistId) == 0x000000, "Member 'OrionPlaylistManager_AwardsXP::PlaylistId' has a wrong offset!");
static_assert(offsetof(OrionPlaylistManager_AwardsXP, ReturnValue) == 0x000004, "Member 'OrionPlaylistManager_AwardsXP::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlaylistManager.DoesPlaylistAllowMirrorMatches
// 0x0008 (0x0008 - 0x0000)
struct OrionPlaylistManager_DoesPlaylistAllowMirrorMatches final
{
public:
	int32                                         PlaylistId;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionPlaylistManager_DoesPlaylistAllowMirrorMatches) == 0x000004, "Wrong alignment on OrionPlaylistManager_DoesPlaylistAllowMirrorMatches");
static_assert(sizeof(OrionPlaylistManager_DoesPlaylistAllowMirrorMatches) == 0x000008, "Wrong size on OrionPlaylistManager_DoesPlaylistAllowMirrorMatches");
static_assert(offsetof(OrionPlaylistManager_DoesPlaylistAllowMirrorMatches, PlaylistId) == 0x000000, "Member 'OrionPlaylistManager_DoesPlaylistAllowMirrorMatches::PlaylistId' has a wrong offset!");
static_assert(offsetof(OrionPlaylistManager_DoesPlaylistAllowMirrorMatches, ReturnValue) == 0x000004, "Member 'OrionPlaylistManager_DoesPlaylistAllowMirrorMatches::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlaylistManager.Exists
// 0x0008 (0x0008 - 0x0000)
struct OrionPlaylistManager_Exists final
{
public:
	int32                                         PlaylistId;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionPlaylistManager_Exists) == 0x000004, "Wrong alignment on OrionPlaylistManager_Exists");
static_assert(sizeof(OrionPlaylistManager_Exists) == 0x000008, "Wrong size on OrionPlaylistManager_Exists");
static_assert(offsetof(OrionPlaylistManager_Exists, PlaylistId) == 0x000000, "Member 'OrionPlaylistManager_Exists::PlaylistId' has a wrong offset!");
static_assert(offsetof(OrionPlaylistManager_Exists, ReturnValue) == 0x000004, "Member 'OrionPlaylistManager_Exists::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlaylistManager.FindPlaylist
// 0x00D0 (0x00D0 - 0x0000)
struct OrionPlaylistManager_FindPlaylist final
{
public:
	int32                                         PlaylistId;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionPlaylistInfo                     OutPlaylist;                                       // 0x0008(0x00C0)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00C8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionPlaylistManager_FindPlaylist) == 0x000008, "Wrong alignment on OrionPlaylistManager_FindPlaylist");
static_assert(sizeof(OrionPlaylistManager_FindPlaylist) == 0x0000D0, "Wrong size on OrionPlaylistManager_FindPlaylist");
static_assert(offsetof(OrionPlaylistManager_FindPlaylist, PlaylistId) == 0x000000, "Member 'OrionPlaylistManager_FindPlaylist::PlaylistId' has a wrong offset!");
static_assert(offsetof(OrionPlaylistManager_FindPlaylist, OutPlaylist) == 0x000008, "Member 'OrionPlaylistManager_FindPlaylist::OutPlaylist' has a wrong offset!");
static_assert(offsetof(OrionPlaylistManager_FindPlaylist, ReturnValue) == 0x0000C8, "Member 'OrionPlaylistManager_FindPlaylist::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlaylistManager.GetArcadeURL
// 0x0018 (0x0018 - 0x0000)
struct OrionPlaylistManager_GetArcadeURL final
{
public:
	int32                                         PlaylistId;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlaylistManager_GetArcadeURL) == 0x000008, "Wrong alignment on OrionPlaylistManager_GetArcadeURL");
static_assert(sizeof(OrionPlaylistManager_GetArcadeURL) == 0x000018, "Wrong size on OrionPlaylistManager_GetArcadeURL");
static_assert(offsetof(OrionPlaylistManager_GetArcadeURL, PlaylistId) == 0x000000, "Member 'OrionPlaylistManager_GetArcadeURL::PlaylistId' has a wrong offset!");
static_assert(offsetof(OrionPlaylistManager_GetArcadeURL, ReturnValue) == 0x000008, "Member 'OrionPlaylistManager_GetArcadeURL::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlaylistManager.GetGameMapURL
// 0x0020 (0x0020 - 0x0000)
struct OrionPlaylistManager_GetGameMapURL final
{
public:
	int32                                         PlaylistId;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 OutMapURL;                                         // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionPlaylistManager_GetGameMapURL) == 0x000008, "Wrong alignment on OrionPlaylistManager_GetGameMapURL");
static_assert(sizeof(OrionPlaylistManager_GetGameMapURL) == 0x000020, "Wrong size on OrionPlaylistManager_GetGameMapURL");
static_assert(offsetof(OrionPlaylistManager_GetGameMapURL, PlaylistId) == 0x000000, "Member 'OrionPlaylistManager_GetGameMapURL::PlaylistId' has a wrong offset!");
static_assert(offsetof(OrionPlaylistManager_GetGameMapURL, OutMapURL) == 0x000008, "Member 'OrionPlaylistManager_GetGameMapURL::OutMapURL' has a wrong offset!");
static_assert(offsetof(OrionPlaylistManager_GetGameMapURL, ReturnValue) == 0x000018, "Member 'OrionPlaylistManager_GetGameMapURL::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlaylistManager.GetLoadingScreen
// 0x0018 (0x0018 - 0x0000)
struct OrionPlaylistManager_GetLoadingScreen final
{
public:
	int32                                         PlaylistId;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlaylistManager_GetLoadingScreen) == 0x000008, "Wrong alignment on OrionPlaylistManager_GetLoadingScreen");
static_assert(sizeof(OrionPlaylistManager_GetLoadingScreen) == 0x000018, "Wrong size on OrionPlaylistManager_GetLoadingScreen");
static_assert(offsetof(OrionPlaylistManager_GetLoadingScreen, PlaylistId) == 0x000000, "Member 'OrionPlaylistManager_GetLoadingScreen::PlaylistId' has a wrong offset!");
static_assert(offsetof(OrionPlaylistManager_GetLoadingScreen, ReturnValue) == 0x000008, "Member 'OrionPlaylistManager_GetLoadingScreen::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlaylistManager.GetLobbyMapURL
// 0x0020 (0x0020 - 0x0000)
struct OrionPlaylistManager_GetLobbyMapURL final
{
public:
	int32                                         PlaylistId;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 OutMapURL;                                         // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionPlaylistManager_GetLobbyMapURL) == 0x000008, "Wrong alignment on OrionPlaylistManager_GetLobbyMapURL");
static_assert(sizeof(OrionPlaylistManager_GetLobbyMapURL) == 0x000020, "Wrong size on OrionPlaylistManager_GetLobbyMapURL");
static_assert(offsetof(OrionPlaylistManager_GetLobbyMapURL, PlaylistId) == 0x000000, "Member 'OrionPlaylistManager_GetLobbyMapURL::PlaylistId' has a wrong offset!");
static_assert(offsetof(OrionPlaylistManager_GetLobbyMapURL, OutMapURL) == 0x000008, "Member 'OrionPlaylistManager_GetLobbyMapURL::OutMapURL' has a wrong offset!");
static_assert(offsetof(OrionPlaylistManager_GetLobbyMapURL, ReturnValue) == 0x000018, "Member 'OrionPlaylistManager_GetLobbyMapURL::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlaylistManager.GetPlaylistName
// 0x0018 (0x0018 - 0x0000)
struct OrionPlaylistManager_GetPlaylistName final
{
public:
	int32                                         PlaylistId;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlaylistManager_GetPlaylistName) == 0x000008, "Wrong alignment on OrionPlaylistManager_GetPlaylistName");
static_assert(sizeof(OrionPlaylistManager_GetPlaylistName) == 0x000018, "Wrong size on OrionPlaylistManager_GetPlaylistName");
static_assert(offsetof(OrionPlaylistManager_GetPlaylistName, PlaylistId) == 0x000000, "Member 'OrionPlaylistManager_GetPlaylistName::PlaylistId' has a wrong offset!");
static_assert(offsetof(OrionPlaylistManager_GetPlaylistName, ReturnValue) == 0x000008, "Member 'OrionPlaylistManager_GetPlaylistName::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlaylistManager.GetRatingType
// 0x0018 (0x0018 - 0x0000)
struct OrionPlaylistManager_GetRatingType final
{
public:
	int32                                         PlaylistId;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlaylistManager_GetRatingType) == 0x000008, "Wrong alignment on OrionPlaylistManager_GetRatingType");
static_assert(sizeof(OrionPlaylistManager_GetRatingType) == 0x000018, "Wrong size on OrionPlaylistManager_GetRatingType");
static_assert(offsetof(OrionPlaylistManager_GetRatingType, PlaylistId) == 0x000000, "Member 'OrionPlaylistManager_GetRatingType::PlaylistId' has a wrong offset!");
static_assert(offsetof(OrionPlaylistManager_GetRatingType, ReturnValue) == 0x000008, "Member 'OrionPlaylistManager_GetRatingType::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlaylistManager.GetRawGameMapPath
// 0x0020 (0x0020 - 0x0000)
struct OrionPlaylistManager_GetRawGameMapPath final
{
public:
	int32                                         PlaylistId;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 OutMapPath;                                        // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionPlaylistManager_GetRawGameMapPath) == 0x000008, "Wrong alignment on OrionPlaylistManager_GetRawGameMapPath");
static_assert(sizeof(OrionPlaylistManager_GetRawGameMapPath) == 0x000020, "Wrong size on OrionPlaylistManager_GetRawGameMapPath");
static_assert(offsetof(OrionPlaylistManager_GetRawGameMapPath, PlaylistId) == 0x000000, "Member 'OrionPlaylistManager_GetRawGameMapPath::PlaylistId' has a wrong offset!");
static_assert(offsetof(OrionPlaylistManager_GetRawGameMapPath, OutMapPath) == 0x000008, "Member 'OrionPlaylistManager_GetRawGameMapPath::OutMapPath' has a wrong offset!");
static_assert(offsetof(OrionPlaylistManager_GetRawGameMapPath, ReturnValue) == 0x000018, "Member 'OrionPlaylistManager_GetRawGameMapPath::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlaylistManager.GetReplayFlag
// 0x0018 (0x0018 - 0x0000)
struct OrionPlaylistManager_GetReplayFlag final
{
public:
	int32                                         PlaylistId;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlaylistManager_GetReplayFlag) == 0x000008, "Wrong alignment on OrionPlaylistManager_GetReplayFlag");
static_assert(sizeof(OrionPlaylistManager_GetReplayFlag) == 0x000018, "Wrong size on OrionPlaylistManager_GetReplayFlag");
static_assert(offsetof(OrionPlaylistManager_GetReplayFlag, PlaylistId) == 0x000000, "Member 'OrionPlaylistManager_GetReplayFlag::PlaylistId' has a wrong offset!");
static_assert(offsetof(OrionPlaylistManager_GetReplayFlag, ReturnValue) == 0x000008, "Member 'OrionPlaylistManager_GetReplayFlag::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlaylistManager.GetTeamInfo
// 0x0014 (0x0014 - 0x0000)
struct OrionPlaylistManager_GetTeamInfo final
{
public:
	int32                                         PlaylistId;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutMaxPlayers;                                     // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutMaxTeams;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutTeamSize;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionPlaylistManager_GetTeamInfo) == 0x000004, "Wrong alignment on OrionPlaylistManager_GetTeamInfo");
static_assert(sizeof(OrionPlaylistManager_GetTeamInfo) == 0x000014, "Wrong size on OrionPlaylistManager_GetTeamInfo");
static_assert(offsetof(OrionPlaylistManager_GetTeamInfo, PlaylistId) == 0x000000, "Member 'OrionPlaylistManager_GetTeamInfo::PlaylistId' has a wrong offset!");
static_assert(offsetof(OrionPlaylistManager_GetTeamInfo, OutMaxPlayers) == 0x000004, "Member 'OrionPlaylistManager_GetTeamInfo::OutMaxPlayers' has a wrong offset!");
static_assert(offsetof(OrionPlaylistManager_GetTeamInfo, OutMaxTeams) == 0x000008, "Member 'OrionPlaylistManager_GetTeamInfo::OutMaxTeams' has a wrong offset!");
static_assert(offsetof(OrionPlaylistManager_GetTeamInfo, OutTeamSize) == 0x00000C, "Member 'OrionPlaylistManager_GetTeamInfo::OutTeamSize' has a wrong offset!");
static_assert(offsetof(OrionPlaylistManager_GetTeamInfo, ReturnValue) == 0x000010, "Member 'OrionPlaylistManager_GetTeamInfo::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlaylistManager.GetTeamSize
// 0x0008 (0x0008 - 0x0000)
struct OrionPlaylistManager_GetTeamSize final
{
public:
	int32                                         PlaylistId;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPlaylistManager_GetTeamSize) == 0x000004, "Wrong alignment on OrionPlaylistManager_GetTeamSize");
static_assert(sizeof(OrionPlaylistManager_GetTeamSize) == 0x000008, "Wrong size on OrionPlaylistManager_GetTeamSize");
static_assert(offsetof(OrionPlaylistManager_GetTeamSize, PlaylistId) == 0x000000, "Member 'OrionPlaylistManager_GetTeamSize::PlaylistId' has a wrong offset!");
static_assert(offsetof(OrionPlaylistManager_GetTeamSize, ReturnValue) == 0x000004, "Member 'OrionPlaylistManager_GetTeamSize::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlaylistManager.HasBots
// 0x0008 (0x0008 - 0x0000)
struct OrionPlaylistManager_HasBots final
{
public:
	int32                                         PlaylistId;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionPlaylistManager_HasBots) == 0x000004, "Wrong alignment on OrionPlaylistManager_HasBots");
static_assert(sizeof(OrionPlaylistManager_HasBots) == 0x000008, "Wrong size on OrionPlaylistManager_HasBots");
static_assert(offsetof(OrionPlaylistManager_HasBots, PlaylistId) == 0x000000, "Member 'OrionPlaylistManager_HasBots::PlaylistId' has a wrong offset!");
static_assert(offsetof(OrionPlaylistManager_HasBots, ReturnValue) == 0x000004, "Member 'OrionPlaylistManager_HasBots::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlaylistManager.HasEnemyBots
// 0x0008 (0x0008 - 0x0000)
struct OrionPlaylistManager_HasEnemyBots final
{
public:
	int32                                         PlaylistId;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionPlaylistManager_HasEnemyBots) == 0x000004, "Wrong alignment on OrionPlaylistManager_HasEnemyBots");
static_assert(sizeof(OrionPlaylistManager_HasEnemyBots) == 0x000008, "Wrong size on OrionPlaylistManager_HasEnemyBots");
static_assert(offsetof(OrionPlaylistManager_HasEnemyBots, PlaylistId) == 0x000000, "Member 'OrionPlaylistManager_HasEnemyBots::PlaylistId' has a wrong offset!");
static_assert(offsetof(OrionPlaylistManager_HasEnemyBots, ReturnValue) == 0x000004, "Member 'OrionPlaylistManager_HasEnemyBots::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlaylistManager.HasFriendlyBots
// 0x0008 (0x0008 - 0x0000)
struct OrionPlaylistManager_HasFriendlyBots final
{
public:
	int32                                         PlaylistId;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionPlaylistManager_HasFriendlyBots) == 0x000004, "Wrong alignment on OrionPlaylistManager_HasFriendlyBots");
static_assert(sizeof(OrionPlaylistManager_HasFriendlyBots) == 0x000008, "Wrong size on OrionPlaylistManager_HasFriendlyBots");
static_assert(offsetof(OrionPlaylistManager_HasFriendlyBots, PlaylistId) == 0x000000, "Member 'OrionPlaylistManager_HasFriendlyBots::PlaylistId' has a wrong offset!");
static_assert(offsetof(OrionPlaylistManager_HasFriendlyBots, ReturnValue) == 0x000004, "Member 'OrionPlaylistManager_HasFriendlyBots::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlaylistManager.IsCoop
// 0x0008 (0x0008 - 0x0000)
struct OrionPlaylistManager_IsCoop final
{
public:
	int32                                         PlaylistId;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionPlaylistManager_IsCoop) == 0x000004, "Wrong alignment on OrionPlaylistManager_IsCoop");
static_assert(sizeof(OrionPlaylistManager_IsCoop) == 0x000008, "Wrong size on OrionPlaylistManager_IsCoop");
static_assert(offsetof(OrionPlaylistManager_IsCoop, PlaylistId) == 0x000000, "Member 'OrionPlaylistManager_IsCoop::PlaylistId' has a wrong offset!");
static_assert(offsetof(OrionPlaylistManager_IsCoop, ReturnValue) == 0x000004, "Member 'OrionPlaylistManager_IsCoop::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlaylistManager.IsPVP
// 0x0008 (0x0008 - 0x0000)
struct OrionPlaylistManager_IsPVP final
{
public:
	int32                                         PlaylistId;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionPlaylistManager_IsPVP) == 0x000004, "Wrong alignment on OrionPlaylistManager_IsPVP");
static_assert(sizeof(OrionPlaylistManager_IsPVP) == 0x000008, "Wrong size on OrionPlaylistManager_IsPVP");
static_assert(offsetof(OrionPlaylistManager_IsPVP, PlaylistId) == 0x000000, "Member 'OrionPlaylistManager_IsPVP::PlaylistId' has a wrong offset!");
static_assert(offsetof(OrionPlaylistManager_IsPVP, ReturnValue) == 0x000004, "Member 'OrionPlaylistManager_IsPVP::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlaylistManager.IsRanked
// 0x0008 (0x0008 - 0x0000)
struct OrionPlaylistManager_IsRanked final
{
public:
	int32                                         PlaylistId;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionPlaylistManager_IsRanked) == 0x000004, "Wrong alignment on OrionPlaylistManager_IsRanked");
static_assert(sizeof(OrionPlaylistManager_IsRanked) == 0x000008, "Wrong size on OrionPlaylistManager_IsRanked");
static_assert(offsetof(OrionPlaylistManager_IsRanked, PlaylistId) == 0x000000, "Member 'OrionPlaylistManager_IsRanked::PlaylistId' has a wrong offset!");
static_assert(offsetof(OrionPlaylistManager_IsRanked, ReturnValue) == 0x000004, "Member 'OrionPlaylistManager_IsRanked::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlaylistManager.IsSolo
// 0x0008 (0x0008 - 0x0000)
struct OrionPlaylistManager_IsSolo final
{
public:
	int32                                         PlaylistId;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionPlaylistManager_IsSolo) == 0x000004, "Wrong alignment on OrionPlaylistManager_IsSolo");
static_assert(sizeof(OrionPlaylistManager_IsSolo) == 0x000008, "Wrong size on OrionPlaylistManager_IsSolo");
static_assert(offsetof(OrionPlaylistManager_IsSolo, PlaylistId) == 0x000000, "Member 'OrionPlaylistManager_IsSolo::PlaylistId' has a wrong offset!");
static_assert(offsetof(OrionPlaylistManager_IsSolo, ReturnValue) == 0x000004, "Member 'OrionPlaylistManager_IsSolo::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlaylistManager.IsSoloVsAI
// 0x0008 (0x0008 - 0x0000)
struct OrionPlaylistManager_IsSoloVsAI final
{
public:
	int32                                         PlaylistId;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionPlaylistManager_IsSoloVsAI) == 0x000004, "Wrong alignment on OrionPlaylistManager_IsSoloVsAI");
static_assert(sizeof(OrionPlaylistManager_IsSoloVsAI) == 0x000008, "Wrong size on OrionPlaylistManager_IsSoloVsAI");
static_assert(offsetof(OrionPlaylistManager_IsSoloVsAI, PlaylistId) == 0x000000, "Member 'OrionPlaylistManager_IsSoloVsAI::PlaylistId' has a wrong offset!");
static_assert(offsetof(OrionPlaylistManager_IsSoloVsAI, ReturnValue) == 0x000004, "Member 'OrionPlaylistManager_IsSoloVsAI::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlaylistManager.IsTutorial
// 0x0008 (0x0008 - 0x0000)
struct OrionPlaylistManager_IsTutorial final
{
public:
	int32                                         PlaylistId;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionPlaylistManager_IsTutorial) == 0x000004, "Wrong alignment on OrionPlaylistManager_IsTutorial");
static_assert(sizeof(OrionPlaylistManager_IsTutorial) == 0x000008, "Wrong size on OrionPlaylistManager_IsTutorial");
static_assert(offsetof(OrionPlaylistManager_IsTutorial, PlaylistId) == 0x000000, "Member 'OrionPlaylistManager_IsTutorial::PlaylistId' has a wrong offset!");
static_assert(offsetof(OrionPlaylistManager_IsTutorial, ReturnValue) == 0x000004, "Member 'OrionPlaylistManager_IsTutorial::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlaylistManager.PlaylistHasLobby
// 0x0008 (0x0008 - 0x0000)
struct OrionPlaylistManager_PlaylistHasLobby final
{
public:
	int32                                         PlaylistId;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionPlaylistManager_PlaylistHasLobby) == 0x000004, "Wrong alignment on OrionPlaylistManager_PlaylistHasLobby");
static_assert(sizeof(OrionPlaylistManager_PlaylistHasLobby) == 0x000008, "Wrong size on OrionPlaylistManager_PlaylistHasLobby");
static_assert(offsetof(OrionPlaylistManager_PlaylistHasLobby, PlaylistId) == 0x000000, "Member 'OrionPlaylistManager_PlaylistHasLobby::PlaylistId' has a wrong offset!");
static_assert(offsetof(OrionPlaylistManager_PlaylistHasLobby, ReturnValue) == 0x000004, "Member 'OrionPlaylistManager_PlaylistHasLobby::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlaylistManager.ShouldShowPostMatchSummary
// 0x0008 (0x0008 - 0x0000)
struct OrionPlaylistManager_ShouldShowPostMatchSummary final
{
public:
	int32                                         PlaylistId;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionPlaylistManager_ShouldShowPostMatchSummary) == 0x000004, "Wrong alignment on OrionPlaylistManager_ShouldShowPostMatchSummary");
static_assert(sizeof(OrionPlaylistManager_ShouldShowPostMatchSummary) == 0x000008, "Wrong size on OrionPlaylistManager_ShouldShowPostMatchSummary");
static_assert(offsetof(OrionPlaylistManager_ShouldShowPostMatchSummary, PlaylistId) == 0x000000, "Member 'OrionPlaylistManager_ShouldShowPostMatchSummary::PlaylistId' has a wrong offset!");
static_assert(offsetof(OrionPlaylistManager_ShouldShowPostMatchSummary, ReturnValue) == 0x000004, "Member 'OrionPlaylistManager_ShouldShowPostMatchSummary::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlaylistManager.SupportsCustomMMKey
// 0x0008 (0x0008 - 0x0000)
struct OrionPlaylistManager_SupportsCustomMMKey final
{
public:
	int32                                         PlaylistId;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionPlaylistManager_SupportsCustomMMKey) == 0x000004, "Wrong alignment on OrionPlaylistManager_SupportsCustomMMKey");
static_assert(sizeof(OrionPlaylistManager_SupportsCustomMMKey) == 0x000008, "Wrong size on OrionPlaylistManager_SupportsCustomMMKey");
static_assert(offsetof(OrionPlaylistManager_SupportsCustomMMKey, PlaylistId) == 0x000000, "Member 'OrionPlaylistManager_SupportsCustomMMKey::PlaylistId' has a wrong offset!");
static_assert(offsetof(OrionPlaylistManager_SupportsCustomMMKey, ReturnValue) == 0x000004, "Member 'OrionPlaylistManager_SupportsCustomMMKey::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPlaylistManager.SupportsDraftInReplays
// 0x0008 (0x0008 - 0x0000)
struct OrionPlaylistManager_SupportsDraftInReplays final
{
public:
	int32                                         PlaylistId;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionPlaylistManager_SupportsDraftInReplays) == 0x000004, "Wrong alignment on OrionPlaylistManager_SupportsDraftInReplays");
static_assert(sizeof(OrionPlaylistManager_SupportsDraftInReplays) == 0x000008, "Wrong size on OrionPlaylistManager_SupportsDraftInReplays");
static_assert(offsetof(OrionPlaylistManager_SupportsDraftInReplays, PlaylistId) == 0x000000, "Member 'OrionPlaylistManager_SupportsDraftInReplays::PlaylistId' has a wrong offset!");
static_assert(offsetof(OrionPlaylistManager_SupportsDraftInReplays, ReturnValue) == 0x000004, "Member 'OrionPlaylistManager_SupportsDraftInReplays::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionPriceAnimInstance.AnimNotify_IK_HndShotGun_Off
// 0x0008 (0x0008 - 0x0000)
struct OrionPriceAnimInstance_AnimNotify_IK_HndShotGun_Off final
{
public:
	const class UAnimNotify*                      AnimNotify;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPriceAnimInstance_AnimNotify_IK_HndShotGun_Off) == 0x000008, "Wrong alignment on OrionPriceAnimInstance_AnimNotify_IK_HndShotGun_Off");
static_assert(sizeof(OrionPriceAnimInstance_AnimNotify_IK_HndShotGun_Off) == 0x000008, "Wrong size on OrionPriceAnimInstance_AnimNotify_IK_HndShotGun_Off");
static_assert(offsetof(OrionPriceAnimInstance_AnimNotify_IK_HndShotGun_Off, AnimNotify) == 0x000000, "Member 'OrionPriceAnimInstance_AnimNotify_IK_HndShotGun_Off::AnimNotify' has a wrong offset!");

// Function OrionGame.OrionPriceAnimInstance.AnimNotify_IK_HndShotGun_On
// 0x0008 (0x0008 - 0x0000)
struct OrionPriceAnimInstance_AnimNotify_IK_HndShotGun_On final
{
public:
	const class UAnimNotify*                      AnimNotify;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionPriceAnimInstance_AnimNotify_IK_HndShotGun_On) == 0x000008, "Wrong alignment on OrionPriceAnimInstance_AnimNotify_IK_HndShotGun_On");
static_assert(sizeof(OrionPriceAnimInstance_AnimNotify_IK_HndShotGun_On) == 0x000008, "Wrong size on OrionPriceAnimInstance_AnimNotify_IK_HndShotGun_On");
static_assert(offsetof(OrionPriceAnimInstance_AnimNotify_IK_HndShotGun_On, AnimNotify) == 0x000000, "Member 'OrionPriceAnimInstance_AnimNotify_IK_HndShotGun_On::AnimNotify' has a wrong offset!");

// Function OrionGame.OrionProjectileMovementComponent.GetHomingTargetLocation
// 0x000C (0x000C - 0x0000)
struct OrionProjectileMovementComponent_GetHomingTargetLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjectileMovementComponent_GetHomingTargetLocation) == 0x000004, "Wrong alignment on OrionProjectileMovementComponent_GetHomingTargetLocation");
static_assert(sizeof(OrionProjectileMovementComponent_GetHomingTargetLocation) == 0x00000C, "Wrong size on OrionProjectileMovementComponent_GetHomingTargetLocation");
static_assert(offsetof(OrionProjectileMovementComponent_GetHomingTargetLocation, ReturnValue) == 0x000000, "Member 'OrionProjectileMovementComponent_GetHomingTargetLocation::ReturnValue' has a wrong offset!");

// DelegateFunction OrionGame.OrionProjectileMovementComponent.OnOrionProjectileBounceDelegate__DelegateSignature
// 0x0098 (0x0098 - 0x0000)
struct OrionProjectileMovementComponent_OnOrionProjectileBounceDelegate__DelegateSignature final
{
public:
	struct FHitResult                             ImpactResult;                                      // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                ImpactVelocity;                                    // 0x0088(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionProjectileMovementComponent_OnOrionProjectileBounceDelegate__DelegateSignature) == 0x000008, "Wrong alignment on OrionProjectileMovementComponent_OnOrionProjectileBounceDelegate__DelegateSignature");
static_assert(sizeof(OrionProjectileMovementComponent_OnOrionProjectileBounceDelegate__DelegateSignature) == 0x000098, "Wrong size on OrionProjectileMovementComponent_OnOrionProjectileBounceDelegate__DelegateSignature");
static_assert(offsetof(OrionProjectileMovementComponent_OnOrionProjectileBounceDelegate__DelegateSignature, ImpactResult) == 0x000000, "Member 'OrionProjectileMovementComponent_OnOrionProjectileBounceDelegate__DelegateSignature::ImpactResult' has a wrong offset!");
static_assert(offsetof(OrionProjectileMovementComponent_OnOrionProjectileBounceDelegate__DelegateSignature, ImpactVelocity) == 0x000088, "Member 'OrionProjectileMovementComponent_OnOrionProjectileBounceDelegate__DelegateSignature::ImpactVelocity' has a wrong offset!");

// DelegateFunction OrionGame.OrionProjectileMovementComponent.OnOrionProjectileStopDelegate__DelegateSignature
// 0x0088 (0x0088 - 0x0000)
struct OrionProjectileMovementComponent_OnOrionProjectileStopDelegate__DelegateSignature final
{
public:
	struct FHitResult                             ImpactResult;                                      // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjectileMovementComponent_OnOrionProjectileStopDelegate__DelegateSignature) == 0x000008, "Wrong alignment on OrionProjectileMovementComponent_OnOrionProjectileStopDelegate__DelegateSignature");
static_assert(sizeof(OrionProjectileMovementComponent_OnOrionProjectileStopDelegate__DelegateSignature) == 0x000088, "Wrong size on OrionProjectileMovementComponent_OnOrionProjectileStopDelegate__DelegateSignature");
static_assert(offsetof(OrionProjectileMovementComponent_OnOrionProjectileStopDelegate__DelegateSignature, ImpactResult) == 0x000000, "Member 'OrionProjectileMovementComponent_OnOrionProjectileStopDelegate__DelegateSignature::ImpactResult' has a wrong offset!");

// Function OrionGame.OrionProjectileMovementComponent.SetHomingTargetLocation
// 0x000C (0x000C - 0x0000)
struct OrionProjectileMovementComponent_SetHomingTargetLocation final
{
public:
	struct FVector                                NewLocation;                                       // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjectileMovementComponent_SetHomingTargetLocation) == 0x000004, "Wrong alignment on OrionProjectileMovementComponent_SetHomingTargetLocation");
static_assert(sizeof(OrionProjectileMovementComponent_SetHomingTargetLocation) == 0x00000C, "Wrong size on OrionProjectileMovementComponent_SetHomingTargetLocation");
static_assert(offsetof(OrionProjectileMovementComponent_SetHomingTargetLocation, NewLocation) == 0x000000, "Member 'OrionProjectileMovementComponent_SetHomingTargetLocation::NewLocation' has a wrong offset!");

// Function OrionGame.OrionProjectileMovementComponent.SetVelocityInLocalSpace
// 0x000C (0x000C - 0x0000)
struct OrionProjectileMovementComponent_SetVelocityInLocalSpace final
{
public:
	struct FVector                                NewVelocity;                                       // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjectileMovementComponent_SetVelocityInLocalSpace) == 0x000004, "Wrong alignment on OrionProjectileMovementComponent_SetVelocityInLocalSpace");
static_assert(sizeof(OrionProjectileMovementComponent_SetVelocityInLocalSpace) == 0x00000C, "Wrong size on OrionProjectileMovementComponent_SetVelocityInLocalSpace");
static_assert(offsetof(OrionProjectileMovementComponent_SetVelocityInLocalSpace, NewVelocity) == 0x000000, "Member 'OrionProjectileMovementComponent_SetVelocityInLocalSpace::NewVelocity' has a wrong offset!");

// Function OrionGame.OrionProjectileMovementComponent.StopSimulating
// 0x0088 (0x0088 - 0x0000)
struct OrionProjectileMovementComponent_StopSimulating final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjectileMovementComponent_StopSimulating) == 0x000008, "Wrong alignment on OrionProjectileMovementComponent_StopSimulating");
static_assert(sizeof(OrionProjectileMovementComponent_StopSimulating) == 0x000088, "Wrong size on OrionProjectileMovementComponent_StopSimulating");
static_assert(offsetof(OrionProjectileMovementComponent_StopSimulating, HitResult) == 0x000000, "Member 'OrionProjectileMovementComponent_StopSimulating::HitResult' has a wrong offset!");

// Function OrionGame.OrionProjectileMovementComponent.LimitVelocity
// 0x0030 (0x0030 - 0x0000)
struct OrionProjectileMovementComponent_LimitVelocity final
{
public:
	struct FVector                                InVelocity;                                        // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InUnlimitedVelocity;                               // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutVelocity;                                       // 0x0018(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutUnlimitedVelocity;                              // 0x0024(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjectileMovementComponent_LimitVelocity) == 0x000004, "Wrong alignment on OrionProjectileMovementComponent_LimitVelocity");
static_assert(sizeof(OrionProjectileMovementComponent_LimitVelocity) == 0x000030, "Wrong size on OrionProjectileMovementComponent_LimitVelocity");
static_assert(offsetof(OrionProjectileMovementComponent_LimitVelocity, InVelocity) == 0x000000, "Member 'OrionProjectileMovementComponent_LimitVelocity::InVelocity' has a wrong offset!");
static_assert(offsetof(OrionProjectileMovementComponent_LimitVelocity, InUnlimitedVelocity) == 0x00000C, "Member 'OrionProjectileMovementComponent_LimitVelocity::InUnlimitedVelocity' has a wrong offset!");
static_assert(offsetof(OrionProjectileMovementComponent_LimitVelocity, OutVelocity) == 0x000018, "Member 'OrionProjectileMovementComponent_LimitVelocity::OutVelocity' has a wrong offset!");
static_assert(offsetof(OrionProjectileMovementComponent_LimitVelocity, OutUnlimitedVelocity) == 0x000024, "Member 'OrionProjectileMovementComponent_LimitVelocity::OutUnlimitedVelocity' has a wrong offset!");

// Function OrionGame.OrionProjFloorMovementComponent.SetWalkableFloorAngle
// 0x0004 (0x0004 - 0x0000)
struct OrionProjFloorMovementComponent_SetWalkableFloorAngle final
{
public:
	float                                         InWalkableFloorAngle;                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjFloorMovementComponent_SetWalkableFloorAngle) == 0x000004, "Wrong alignment on OrionProjFloorMovementComponent_SetWalkableFloorAngle");
static_assert(sizeof(OrionProjFloorMovementComponent_SetWalkableFloorAngle) == 0x000004, "Wrong size on OrionProjFloorMovementComponent_SetWalkableFloorAngle");
static_assert(offsetof(OrionProjFloorMovementComponent_SetWalkableFloorAngle, InWalkableFloorAngle) == 0x000000, "Member 'OrionProjFloorMovementComponent_SetWalkableFloorAngle::InWalkableFloorAngle' has a wrong offset!");

// Function OrionGame.OrionProjFloorMovementComponent.SetWalkableFloorZ
// 0x0004 (0x0004 - 0x0000)
struct OrionProjFloorMovementComponent_SetWalkableFloorZ final
{
public:
	float                                         InWalkableFloorZ;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjFloorMovementComponent_SetWalkableFloorZ) == 0x000004, "Wrong alignment on OrionProjFloorMovementComponent_SetWalkableFloorZ");
static_assert(sizeof(OrionProjFloorMovementComponent_SetWalkableFloorZ) == 0x000004, "Wrong size on OrionProjFloorMovementComponent_SetWalkableFloorZ");
static_assert(offsetof(OrionProjFloorMovementComponent_SetWalkableFloorZ, InWalkableFloorZ) == 0x000000, "Member 'OrionProjFloorMovementComponent_SetWalkableFloorZ::InWalkableFloorZ' has a wrong offset!");

// Function OrionGame.OrionProjFloorMovementComponent.GetPerchRadiusThreshold
// 0x0004 (0x0004 - 0x0000)
struct OrionProjFloorMovementComponent_GetPerchRadiusThreshold final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjFloorMovementComponent_GetPerchRadiusThreshold) == 0x000004, "Wrong alignment on OrionProjFloorMovementComponent_GetPerchRadiusThreshold");
static_assert(sizeof(OrionProjFloorMovementComponent_GetPerchRadiusThreshold) == 0x000004, "Wrong size on OrionProjFloorMovementComponent_GetPerchRadiusThreshold");
static_assert(offsetof(OrionProjFloorMovementComponent_GetPerchRadiusThreshold, ReturnValue) == 0x000000, "Member 'OrionProjFloorMovementComponent_GetPerchRadiusThreshold::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionProjFloorMovementComponent.GetValidPerchRadius
// 0x0004 (0x0004 - 0x0000)
struct OrionProjFloorMovementComponent_GetValidPerchRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionProjFloorMovementComponent_GetValidPerchRadius) == 0x000004, "Wrong alignment on OrionProjFloorMovementComponent_GetValidPerchRadius");
static_assert(sizeof(OrionProjFloorMovementComponent_GetValidPerchRadius) == 0x000004, "Wrong size on OrionProjFloorMovementComponent_GetValidPerchRadius");
static_assert(offsetof(OrionProjFloorMovementComponent_GetValidPerchRadius, ReturnValue) == 0x000000, "Member 'OrionProjFloorMovementComponent_GetValidPerchRadius::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionProjFloorMovementComponent.IsWalkable
// 0x0090 (0x0090 - 0x0000)
struct OrionProjFloorMovementComponent_IsWalkable final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0088(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionProjFloorMovementComponent_IsWalkable) == 0x000008, "Wrong alignment on OrionProjFloorMovementComponent_IsWalkable");
static_assert(sizeof(OrionProjFloorMovementComponent_IsWalkable) == 0x000090, "Wrong size on OrionProjFloorMovementComponent_IsWalkable");
static_assert(offsetof(OrionProjFloorMovementComponent_IsWalkable, Hit) == 0x000000, "Member 'OrionProjFloorMovementComponent_IsWalkable::Hit' has a wrong offset!");
static_assert(offsetof(OrionProjFloorMovementComponent_IsWalkable, ReturnValue) == 0x000088, "Member 'OrionProjFloorMovementComponent_IsWalkable::ReturnValue' has a wrong offset!");

// Function OrionGame.GameplayQualifierKeywordFunctionLibrary.EvaluateQualifierSpec
// 0x0020 (0x0020 - 0x0000)
struct GameplayQualifierKeywordFunctionLibrary_EvaluateQualifierSpec final
{
public:
	struct FGameplayQualifierParameters           QualifierSpec;                                     // 0x0000(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	EQualifierEvaluationResult                    OutResult;                                         // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayQualifierKeywordFunctionLibrary_EvaluateQualifierSpec) == 0x000008, "Wrong alignment on GameplayQualifierKeywordFunctionLibrary_EvaluateQualifierSpec");
static_assert(sizeof(GameplayQualifierKeywordFunctionLibrary_EvaluateQualifierSpec) == 0x000020, "Wrong size on GameplayQualifierKeywordFunctionLibrary_EvaluateQualifierSpec");
static_assert(offsetof(GameplayQualifierKeywordFunctionLibrary_EvaluateQualifierSpec, QualifierSpec) == 0x000000, "Member 'GameplayQualifierKeywordFunctionLibrary_EvaluateQualifierSpec::QualifierSpec' has a wrong offset!");
static_assert(offsetof(GameplayQualifierKeywordFunctionLibrary_EvaluateQualifierSpec, OutResult) == 0x000018, "Member 'GameplayQualifierKeywordFunctionLibrary_EvaluateQualifierSpec::OutResult' has a wrong offset!");

// Function OrionGame.OrionQuickChatWrapper.OnToggleChatOptions
// 0x0001 (0x0001 - 0x0000)
struct OrionQuickChatWrapper_OnToggleChatOptions final
{
public:
	bool                                          bShowChatOptions;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionQuickChatWrapper_OnToggleChatOptions) == 0x000001, "Wrong alignment on OrionQuickChatWrapper_OnToggleChatOptions");
static_assert(sizeof(OrionQuickChatWrapper_OnToggleChatOptions) == 0x000001, "Wrong size on OrionQuickChatWrapper_OnToggleChatOptions");
static_assert(offsetof(OrionQuickChatWrapper_OnToggleChatOptions, bShowChatOptions) == 0x000000, "Member 'OrionQuickChatWrapper_OnToggleChatOptions::bShowChatOptions' has a wrong offset!");

// Function OrionGame.OrionReplaySpectator.DebugSetSpectatorCameraType
// 0x0010 (0x0010 - 0x0000)
struct OrionReplaySpectator_DebugSetSpectatorCameraType final
{
public:
	class FString                                 Type;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionReplaySpectator_DebugSetSpectatorCameraType) == 0x000008, "Wrong alignment on OrionReplaySpectator_DebugSetSpectatorCameraType");
static_assert(sizeof(OrionReplaySpectator_DebugSetSpectatorCameraType) == 0x000010, "Wrong size on OrionReplaySpectator_DebugSetSpectatorCameraType");
static_assert(offsetof(OrionReplaySpectator_DebugSetSpectatorCameraType, Type) == 0x000000, "Member 'OrionReplaySpectator_DebugSetSpectatorCameraType::Type' has a wrong offset!");

// Function OrionGame.OrionReplaySpectator.NotifyHeroPortraitClicked
// 0x0008 (0x0008 - 0x0000)
struct OrionReplaySpectator_NotifyHeroPortraitClicked final
{
public:
	EOrionTeam                                    HeroTeam;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayerIndex;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionReplaySpectator_NotifyHeroPortraitClicked) == 0x000004, "Wrong alignment on OrionReplaySpectator_NotifyHeroPortraitClicked");
static_assert(sizeof(OrionReplaySpectator_NotifyHeroPortraitClicked) == 0x000008, "Wrong size on OrionReplaySpectator_NotifyHeroPortraitClicked");
static_assert(offsetof(OrionReplaySpectator_NotifyHeroPortraitClicked, HeroTeam) == 0x000000, "Member 'OrionReplaySpectator_NotifyHeroPortraitClicked::HeroTeam' has a wrong offset!");
static_assert(offsetof(OrionReplaySpectator_NotifyHeroPortraitClicked, PlayerIndex) == 0x000004, "Member 'OrionReplaySpectator_NotifyHeroPortraitClicked::PlayerIndex' has a wrong offset!");

// Function OrionGame.OrionReplaySpectator.ReplaceSpectatorPawn
// 0x0008 (0x0008 - 0x0000)
struct OrionReplaySpectator_ReplaceSpectatorPawn final
{
public:
	class ASpectatorPawn*                         NewSpectatorPawn;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionReplaySpectator_ReplaceSpectatorPawn) == 0x000008, "Wrong alignment on OrionReplaySpectator_ReplaceSpectatorPawn");
static_assert(sizeof(OrionReplaySpectator_ReplaceSpectatorPawn) == 0x000008, "Wrong size on OrionReplaySpectator_ReplaceSpectatorPawn");
static_assert(offsetof(OrionReplaySpectator_ReplaceSpectatorPawn, NewSpectatorPawn) == 0x000000, "Member 'OrionReplaySpectator_ReplaceSpectatorPawn::NewSpectatorPawn' has a wrong offset!");

// Function OrionGame.OrionReplaySpectator.SetHUDVisibility
// 0x0001 (0x0001 - 0x0000)
struct OrionReplaySpectator_SetHUDVisibility final
{
public:
	bool                                          bShowHUD;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionReplaySpectator_SetHUDVisibility) == 0x000001, "Wrong alignment on OrionReplaySpectator_SetHUDVisibility");
static_assert(sizeof(OrionReplaySpectator_SetHUDVisibility) == 0x000001, "Wrong size on OrionReplaySpectator_SetHUDVisibility");
static_assert(offsetof(OrionReplaySpectator_SetHUDVisibility, bShowHUD) == 0x000000, "Member 'OrionReplaySpectator_SetHUDVisibility::bShowHUD' has a wrong offset!");

// Function OrionGame.OrionReplaySpectator.SetSpectatorCameraType
// 0x0001 (0x0001 - 0x0000)
struct OrionReplaySpectator_SetSpectatorCameraType final
{
public:
	ESpectatorCameraType                          NewCameraType;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionReplaySpectator_SetSpectatorCameraType) == 0x000001, "Wrong alignment on OrionReplaySpectator_SetSpectatorCameraType");
static_assert(sizeof(OrionReplaySpectator_SetSpectatorCameraType) == 0x000001, "Wrong size on OrionReplaySpectator_SetSpectatorCameraType");
static_assert(offsetof(OrionReplaySpectator_SetSpectatorCameraType, NewCameraType) == 0x000000, "Member 'OrionReplaySpectator_SetSpectatorCameraType::NewCameraType' has a wrong offset!");

// Function OrionGame.OrionReplaySpectator.WatchActor
// 0x0008 (0x0008 - 0x0000)
struct OrionReplaySpectator_WatchActor final
{
public:
	class AActor*                                 NewActorToWatch;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionReplaySpectator_WatchActor) == 0x000008, "Wrong alignment on OrionReplaySpectator_WatchActor");
static_assert(sizeof(OrionReplaySpectator_WatchActor) == 0x000008, "Wrong size on OrionReplaySpectator_WatchActor");
static_assert(offsetof(OrionReplaySpectator_WatchActor, NewActorToWatch) == 0x000000, "Member 'OrionReplaySpectator_WatchActor::NewActorToWatch' has a wrong offset!");

// Function OrionGame.OrionReplaySpectator.WatchHero
// 0x000C (0x000C - 0x0000)
struct OrionReplaySpectator_WatchHero final
{
public:
	EOrionTeam                                    Team;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HeroIndex;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionReplaySpectator_WatchHero) == 0x000004, "Wrong alignment on OrionReplaySpectator_WatchHero");
static_assert(sizeof(OrionReplaySpectator_WatchHero) == 0x00000C, "Wrong size on OrionReplaySpectator_WatchHero");
static_assert(offsetof(OrionReplaySpectator_WatchHero, Team) == 0x000000, "Member 'OrionReplaySpectator_WatchHero::Team' has a wrong offset!");
static_assert(offsetof(OrionReplaySpectator_WatchHero, HeroIndex) == 0x000004, "Member 'OrionReplaySpectator_WatchHero::HeroIndex' has a wrong offset!");
static_assert(offsetof(OrionReplaySpectator_WatchHero, ReturnValue) == 0x000008, "Member 'OrionReplaySpectator_WatchHero::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionReplaySpectator.GetCurrentCameraType
// 0x0001 (0x0001 - 0x0000)
struct OrionReplaySpectator_GetCurrentCameraType final
{
public:
	ESpectatorCameraType                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionReplaySpectator_GetCurrentCameraType) == 0x000001, "Wrong alignment on OrionReplaySpectator_GetCurrentCameraType");
static_assert(sizeof(OrionReplaySpectator_GetCurrentCameraType) == 0x000001, "Wrong size on OrionReplaySpectator_GetCurrentCameraType");
static_assert(offsetof(OrionReplaySpectator_GetCurrentCameraType, ReturnValue) == 0x000000, "Member 'OrionReplaySpectator_GetCurrentCameraType::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionReplaySpectator.GetWatchedActor
// 0x0008 (0x0008 - 0x0000)
struct OrionReplaySpectator_GetWatchedActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionReplaySpectator_GetWatchedActor) == 0x000008, "Wrong alignment on OrionReplaySpectator_GetWatchedActor");
static_assert(sizeof(OrionReplaySpectator_GetWatchedActor) == 0x000008, "Wrong size on OrionReplaySpectator_GetWatchedActor");
static_assert(offsetof(OrionReplaySpectator_GetWatchedActor, ReturnValue) == 0x000000, "Member 'OrionReplaySpectator_GetWatchedActor::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionReplaySpectator.IsForPlayback
// 0x0001 (0x0001 - 0x0000)
struct OrionReplaySpectator_IsForPlayback final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionReplaySpectator_IsForPlayback) == 0x000001, "Wrong alignment on OrionReplaySpectator_IsForPlayback");
static_assert(sizeof(OrionReplaySpectator_IsForPlayback) == 0x000001, "Wrong size on OrionReplaySpectator_IsForPlayback");
static_assert(offsetof(OrionReplaySpectator_IsForPlayback, ReturnValue) == 0x000000, "Member 'OrionReplaySpectator_IsForPlayback::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionReplaySpectator.IsShowingDebugCameraOptions
// 0x0001 (0x0001 - 0x0000)
struct OrionReplaySpectator_IsShowingDebugCameraOptions final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionReplaySpectator_IsShowingDebugCameraOptions) == 0x000001, "Wrong alignment on OrionReplaySpectator_IsShowingDebugCameraOptions");
static_assert(sizeof(OrionReplaySpectator_IsShowingDebugCameraOptions) == 0x000001, "Wrong size on OrionReplaySpectator_IsShowingDebugCameraOptions");
static_assert(offsetof(OrionReplaySpectator_IsShowingDebugCameraOptions, ReturnValue) == 0x000000, "Member 'OrionReplaySpectator_IsShowingDebugCameraOptions::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionRichText.GetColorType
// 0x0001 (0x0001 - 0x0000)
struct OrionRichText_GetColorType final
{
public:
	EOrionTextColor                               ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRichText_GetColorType) == 0x000001, "Wrong alignment on OrionRichText_GetColorType");
static_assert(sizeof(OrionRichText_GetColorType) == 0x000001, "Wrong size on OrionRichText_GetColorType");
static_assert(offsetof(OrionRichText_GetColorType, ReturnValue) == 0x000000, "Member 'OrionRichText_GetColorType::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionRichText.GetInlineIconColorType
// 0x0001 (0x0001 - 0x0000)
struct OrionRichText_GetInlineIconColorType final
{
public:
	EOrionTextColor                               ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRichText_GetInlineIconColorType) == 0x000001, "Wrong alignment on OrionRichText_GetInlineIconColorType");
static_assert(sizeof(OrionRichText_GetInlineIconColorType) == 0x000001, "Wrong size on OrionRichText_GetInlineIconColorType");
static_assert(offsetof(OrionRichText_GetInlineIconColorType, ReturnValue) == 0x000000, "Member 'OrionRichText_GetInlineIconColorType::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionRichText.GetStyleSize
// 0x0001 (0x0001 - 0x0000)
struct OrionRichText_GetStyleSize final
{
public:
	EOrionWidgetStyleSize                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRichText_GetStyleSize) == 0x000001, "Wrong alignment on OrionRichText_GetStyleSize");
static_assert(sizeof(OrionRichText_GetStyleSize) == 0x000001, "Wrong size on OrionRichText_GetStyleSize");
static_assert(offsetof(OrionRichText_GetStyleSize, ReturnValue) == 0x000000, "Member 'OrionRichText_GetStyleSize::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionRichText.SetColorType
// 0x0001 (0x0001 - 0x0000)
struct OrionRichText_SetColorType final
{
public:
	EOrionTextColor                               Color;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRichText_SetColorType) == 0x000001, "Wrong alignment on OrionRichText_SetColorType");
static_assert(sizeof(OrionRichText_SetColorType) == 0x000001, "Wrong size on OrionRichText_SetColorType");
static_assert(offsetof(OrionRichText_SetColorType, Color) == 0x000000, "Member 'OrionRichText_SetColorType::Color' has a wrong offset!");

// Function OrionGame.OrionRichText.SetInlineIconDisplayMode
// 0x0001 (0x0001 - 0x0000)
struct OrionRichText_SetInlineIconDisplayMode final
{
public:
	ERichTextInlineIconDisplayMode                DisplayMode;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRichText_SetInlineIconDisplayMode) == 0x000001, "Wrong alignment on OrionRichText_SetInlineIconDisplayMode");
static_assert(sizeof(OrionRichText_SetInlineIconDisplayMode) == 0x000001, "Wrong size on OrionRichText_SetInlineIconDisplayMode");
static_assert(offsetof(OrionRichText_SetInlineIconDisplayMode, DisplayMode) == 0x000000, "Member 'OrionRichText_SetInlineIconDisplayMode::DisplayMode' has a wrong offset!");

// Function OrionGame.OrionRichText.SetSize
// 0x0001 (0x0001 - 0x0000)
struct OrionRichText_SetSize final
{
public:
	EOrionWidgetStyleSize                         Size;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRichText_SetSize) == 0x000001, "Wrong alignment on OrionRichText_SetSize");
static_assert(sizeof(OrionRichText_SetSize) == 0x000001, "Wrong size on OrionRichText_SetSize");
static_assert(offsetof(OrionRichText_SetSize, Size) == 0x000000, "Member 'OrionRichText_SetSize::Size' has a wrong offset!");

// Function OrionGame.OrionRichText.SetText
// 0x0018 (0x0018 - 0x0000)
struct OrionRichText_SetText final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRichText_SetText) == 0x000008, "Wrong alignment on OrionRichText_SetText");
static_assert(sizeof(OrionRichText_SetText) == 0x000018, "Wrong size on OrionRichText_SetText");
static_assert(offsetof(OrionRichText_SetText, InText) == 0x000000, "Member 'OrionRichText_SetText::InText' has a wrong offset!");

// Function OrionGame.OrionRichTextHelperLibrary.ConvertToKeyword
// 0x0018 (0x0018 - 0x0000)
struct OrionRichTextHelperLibrary_ConvertToKeyword final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRichTextHelperLibrary_ConvertToKeyword) == 0x000008, "Wrong alignment on OrionRichTextHelperLibrary_ConvertToKeyword");
static_assert(sizeof(OrionRichTextHelperLibrary_ConvertToKeyword) == 0x000018, "Wrong size on OrionRichTextHelperLibrary_ConvertToKeyword");
static_assert(offsetof(OrionRichTextHelperLibrary_ConvertToKeyword, Text) == 0x000000, "Member 'OrionRichTextHelperLibrary_ConvertToKeyword::Text' has a wrong offset!");

// Function OrionGame.OrionRichTextHelperLibrary.ConvertToKeywordSpecific
// 0x0020 (0x0020 - 0x0000)
struct OrionRichTextHelperLibrary_ConvertToKeywordSpecific final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	EOrionWidgetStyleSize                         Size;                                              // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTextColor                               Color;                                             // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionRichTextHelperLibrary_ConvertToKeywordSpecific) == 0x000008, "Wrong alignment on OrionRichTextHelperLibrary_ConvertToKeywordSpecific");
static_assert(sizeof(OrionRichTextHelperLibrary_ConvertToKeywordSpecific) == 0x000020, "Wrong size on OrionRichTextHelperLibrary_ConvertToKeywordSpecific");
static_assert(offsetof(OrionRichTextHelperLibrary_ConvertToKeywordSpecific, Text) == 0x000000, "Member 'OrionRichTextHelperLibrary_ConvertToKeywordSpecific::Text' has a wrong offset!");
static_assert(offsetof(OrionRichTextHelperLibrary_ConvertToKeywordSpecific, Size) == 0x000018, "Member 'OrionRichTextHelperLibrary_ConvertToKeywordSpecific::Size' has a wrong offset!");
static_assert(offsetof(OrionRichTextHelperLibrary_ConvertToKeywordSpecific, Color) == 0x000019, "Member 'OrionRichTextHelperLibrary_ConvertToKeywordSpecific::Color' has a wrong offset!");

// Function OrionGame.OrionRichTextHelperLibrary.FormatAsAttributeValue
// 0x0028 (0x0028 - 0x0000)
struct OrionRichTextHelperLibrary_FormatAsAttributeValue final
{
public:
	class FString                                 Value;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionAttributeSummand                        SummandType;                                       // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRichTextHelperLibrary_FormatAsAttributeValue) == 0x000008, "Wrong alignment on OrionRichTextHelperLibrary_FormatAsAttributeValue");
static_assert(sizeof(OrionRichTextHelperLibrary_FormatAsAttributeValue) == 0x000028, "Wrong size on OrionRichTextHelperLibrary_FormatAsAttributeValue");
static_assert(offsetof(OrionRichTextHelperLibrary_FormatAsAttributeValue, Value) == 0x000000, "Member 'OrionRichTextHelperLibrary_FormatAsAttributeValue::Value' has a wrong offset!");
static_assert(offsetof(OrionRichTextHelperLibrary_FormatAsAttributeValue, SummandType) == 0x000010, "Member 'OrionRichTextHelperLibrary_FormatAsAttributeValue::SummandType' has a wrong offset!");
static_assert(offsetof(OrionRichTextHelperLibrary_FormatAsAttributeValue, ReturnValue) == 0x000018, "Member 'OrionRichTextHelperLibrary_FormatAsAttributeValue::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionRichTextHelperLibrary.FormatAsCurrency
// 0x0040 (0x0040 - 0x0000)
struct OrionRichTextHelperLibrary_FormatAsCurrency final
{
public:
	EOrionCurrencyType                            Currency;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayValue;                                      // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
	EOrionWidgetStyleSize                         Size;                                              // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0028(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRichTextHelperLibrary_FormatAsCurrency) == 0x000008, "Wrong alignment on OrionRichTextHelperLibrary_FormatAsCurrency");
static_assert(sizeof(OrionRichTextHelperLibrary_FormatAsCurrency) == 0x000040, "Wrong size on OrionRichTextHelperLibrary_FormatAsCurrency");
static_assert(offsetof(OrionRichTextHelperLibrary_FormatAsCurrency, Currency) == 0x000000, "Member 'OrionRichTextHelperLibrary_FormatAsCurrency::Currency' has a wrong offset!");
static_assert(offsetof(OrionRichTextHelperLibrary_FormatAsCurrency, DisplayValue) == 0x000008, "Member 'OrionRichTextHelperLibrary_FormatAsCurrency::DisplayValue' has a wrong offset!");
static_assert(offsetof(OrionRichTextHelperLibrary_FormatAsCurrency, Size) == 0x000020, "Member 'OrionRichTextHelperLibrary_FormatAsCurrency::Size' has a wrong offset!");
static_assert(offsetof(OrionRichTextHelperLibrary_FormatAsCurrency, ReturnValue) == 0x000028, "Member 'OrionRichTextHelperLibrary_FormatAsCurrency::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionRichTextHelperLibrary.FormatAsKeyword
// 0x0020 (0x0020 - 0x0000)
struct OrionRichTextHelperLibrary_FormatAsKeyword final
{
public:
	class FString                                 Text;                                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRichTextHelperLibrary_FormatAsKeyword) == 0x000008, "Wrong alignment on OrionRichTextHelperLibrary_FormatAsKeyword");
static_assert(sizeof(OrionRichTextHelperLibrary_FormatAsKeyword) == 0x000020, "Wrong size on OrionRichTextHelperLibrary_FormatAsKeyword");
static_assert(offsetof(OrionRichTextHelperLibrary_FormatAsKeyword, Text) == 0x000000, "Member 'OrionRichTextHelperLibrary_FormatAsKeyword::Text' has a wrong offset!");
static_assert(offsetof(OrionRichTextHelperLibrary_FormatAsKeyword, ReturnValue) == 0x000010, "Member 'OrionRichTextHelperLibrary_FormatAsKeyword::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionRichTextHelperLibrary.FormatAsKeywordSpecific
// 0x0028 (0x0028 - 0x0000)
struct OrionRichTextHelperLibrary_FormatAsKeywordSpecific final
{
public:
	class FString                                 Text;                                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionWidgetStyleSize                         Size;                                              // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTextColor                               Color;                                             // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRichTextHelperLibrary_FormatAsKeywordSpecific) == 0x000008, "Wrong alignment on OrionRichTextHelperLibrary_FormatAsKeywordSpecific");
static_assert(sizeof(OrionRichTextHelperLibrary_FormatAsKeywordSpecific) == 0x000028, "Wrong size on OrionRichTextHelperLibrary_FormatAsKeywordSpecific");
static_assert(offsetof(OrionRichTextHelperLibrary_FormatAsKeywordSpecific, Text) == 0x000000, "Member 'OrionRichTextHelperLibrary_FormatAsKeywordSpecific::Text' has a wrong offset!");
static_assert(offsetof(OrionRichTextHelperLibrary_FormatAsKeywordSpecific, Size) == 0x000010, "Member 'OrionRichTextHelperLibrary_FormatAsKeywordSpecific::Size' has a wrong offset!");
static_assert(offsetof(OrionRichTextHelperLibrary_FormatAsKeywordSpecific, Color) == 0x000011, "Member 'OrionRichTextHelperLibrary_FormatAsKeywordSpecific::Color' has a wrong offset!");
static_assert(offsetof(OrionRichTextHelperLibrary_FormatAsKeywordSpecific, ReturnValue) == 0x000018, "Member 'OrionRichTextHelperLibrary_FormatAsKeywordSpecific::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionRichTextHelperLibrary.GetAttributeAbbreviationMarkup
// 0x0020 (0x0020 - 0x0000)
struct OrionRichTextHelperLibrary_GetAttributeAbbreviationMarkup final
{
public:
	class FString                                 Abbreviation;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRichTextHelperLibrary_GetAttributeAbbreviationMarkup) == 0x000008, "Wrong alignment on OrionRichTextHelperLibrary_GetAttributeAbbreviationMarkup");
static_assert(sizeof(OrionRichTextHelperLibrary_GetAttributeAbbreviationMarkup) == 0x000020, "Wrong size on OrionRichTextHelperLibrary_GetAttributeAbbreviationMarkup");
static_assert(offsetof(OrionRichTextHelperLibrary_GetAttributeAbbreviationMarkup, Abbreviation) == 0x000000, "Member 'OrionRichTextHelperLibrary_GetAttributeAbbreviationMarkup::Abbreviation' has a wrong offset!");
static_assert(offsetof(OrionRichTextHelperLibrary_GetAttributeAbbreviationMarkup, ReturnValue) == 0x000010, "Member 'OrionRichTextHelperLibrary_GetAttributeAbbreviationMarkup::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionRichTextHelperLibrary.GetAttributeMarkup
// 0x0120 (0x0120 - 0x0000)
struct OrionRichTextHelperLibrary_GetAttributeMarkup final
{
public:
	struct FOrionAttributeViewItem                AttributeItem;                                     // 0x0000(0x0110)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0110(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRichTextHelperLibrary_GetAttributeMarkup) == 0x000008, "Wrong alignment on OrionRichTextHelperLibrary_GetAttributeMarkup");
static_assert(sizeof(OrionRichTextHelperLibrary_GetAttributeMarkup) == 0x000120, "Wrong size on OrionRichTextHelperLibrary_GetAttributeMarkup");
static_assert(offsetof(OrionRichTextHelperLibrary_GetAttributeMarkup, AttributeItem) == 0x000000, "Member 'OrionRichTextHelperLibrary_GetAttributeMarkup::AttributeItem' has a wrong offset!");
static_assert(offsetof(OrionRichTextHelperLibrary_GetAttributeMarkup, ReturnValue) == 0x000110, "Member 'OrionRichTextHelperLibrary_GetAttributeMarkup::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionRichTextHelperLibrary.GetAttributeValueTag
// 0x0018 (0x0018 - 0x0000)
struct OrionRichTextHelperLibrary_GetAttributeValueTag final
{
public:
	EOrionAttributeSummand                        SummandType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ValueTag;                                          // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRichTextHelperLibrary_GetAttributeValueTag) == 0x000008, "Wrong alignment on OrionRichTextHelperLibrary_GetAttributeValueTag");
static_assert(sizeof(OrionRichTextHelperLibrary_GetAttributeValueTag) == 0x000018, "Wrong size on OrionRichTextHelperLibrary_GetAttributeValueTag");
static_assert(offsetof(OrionRichTextHelperLibrary_GetAttributeValueTag, SummandType) == 0x000000, "Member 'OrionRichTextHelperLibrary_GetAttributeValueTag::SummandType' has a wrong offset!");
static_assert(offsetof(OrionRichTextHelperLibrary_GetAttributeValueTag, ValueTag) == 0x000008, "Member 'OrionRichTextHelperLibrary_GetAttributeValueTag::ValueTag' has a wrong offset!");

// Function OrionGame.OrionRichTextHelperLibrary.GetCurrencyIconTag
// 0x0018 (0x0018 - 0x0000)
struct OrionRichTextHelperLibrary_GetCurrencyIconTag final
{
public:
	EOrionCurrencyType                            Currency;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRichTextHelperLibrary_GetCurrencyIconTag) == 0x000008, "Wrong alignment on OrionRichTextHelperLibrary_GetCurrencyIconTag");
static_assert(sizeof(OrionRichTextHelperLibrary_GetCurrencyIconTag) == 0x000018, "Wrong size on OrionRichTextHelperLibrary_GetCurrencyIconTag");
static_assert(offsetof(OrionRichTextHelperLibrary_GetCurrencyIconTag, Currency) == 0x000000, "Member 'OrionRichTextHelperLibrary_GetCurrencyIconTag::Currency' has a wrong offset!");
static_assert(offsetof(OrionRichTextHelperLibrary_GetCurrencyIconTag, ReturnValue) == 0x000008, "Member 'OrionRichTextHelperLibrary_GetCurrencyIconTag::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionRichTextHelperLibrary.GetCurrencyIconTagSpecific
// 0x0018 (0x0018 - 0x0000)
struct OrionRichTextHelperLibrary_GetCurrencyIconTagSpecific final
{
public:
	EOrionCurrencyType                            Currency;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionWidgetStyleSize                         Size;                                              // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRichTextHelperLibrary_GetCurrencyIconTagSpecific) == 0x000008, "Wrong alignment on OrionRichTextHelperLibrary_GetCurrencyIconTagSpecific");
static_assert(sizeof(OrionRichTextHelperLibrary_GetCurrencyIconTagSpecific) == 0x000018, "Wrong size on OrionRichTextHelperLibrary_GetCurrencyIconTagSpecific");
static_assert(offsetof(OrionRichTextHelperLibrary_GetCurrencyIconTagSpecific, Currency) == 0x000000, "Member 'OrionRichTextHelperLibrary_GetCurrencyIconTagSpecific::Currency' has a wrong offset!");
static_assert(offsetof(OrionRichTextHelperLibrary_GetCurrencyIconTagSpecific, Size) == 0x000001, "Member 'OrionRichTextHelperLibrary_GetCurrencyIconTagSpecific::Size' has a wrong offset!");
static_assert(offsetof(OrionRichTextHelperLibrary_GetCurrencyIconTagSpecific, ReturnValue) == 0x000008, "Member 'OrionRichTextHelperLibrary_GetCurrencyIconTagSpecific::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionRigs.GetAttchedToWell
// 0x0008 (0x0008 - 0x0000)
struct OrionRigs_GetAttchedToWell final
{
public:
	class AOrionWell_Base*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRigs_GetAttchedToWell) == 0x000008, "Wrong alignment on OrionRigs_GetAttchedToWell");
static_assert(sizeof(OrionRigs_GetAttchedToWell) == 0x000008, "Wrong size on OrionRigs_GetAttchedToWell");
static_assert(offsetof(OrionRigs_GetAttchedToWell, ReturnValue) == 0x000000, "Member 'OrionRigs_GetAttchedToWell::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionRigs.GetBoostedRigScaler
// 0x0004 (0x0004 - 0x0000)
struct OrionRigs_GetBoostedRigScaler final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRigs_GetBoostedRigScaler) == 0x000004, "Wrong alignment on OrionRigs_GetBoostedRigScaler");
static_assert(sizeof(OrionRigs_GetBoostedRigScaler) == 0x000004, "Wrong size on OrionRigs_GetBoostedRigScaler");
static_assert(offsetof(OrionRigs_GetBoostedRigScaler, ReturnValue) == 0x000000, "Member 'OrionRigs_GetBoostedRigScaler::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionRigs.GetCoinSpawnLocation
// 0x000C (0x000C - 0x0000)
struct OrionRigs_GetCoinSpawnLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRigs_GetCoinSpawnLocation) == 0x000004, "Wrong alignment on OrionRigs_GetCoinSpawnLocation");
static_assert(sizeof(OrionRigs_GetCoinSpawnLocation) == 0x00000C, "Wrong size on OrionRigs_GetCoinSpawnLocation");
static_assert(offsetof(OrionRigs_GetCoinSpawnLocation, ReturnValue) == 0x000000, "Member 'OrionRigs_GetCoinSpawnLocation::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionRigs.GetMatchTimePlaced
// 0x0004 (0x0004 - 0x0000)
struct OrionRigs_GetMatchTimePlaced final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRigs_GetMatchTimePlaced) == 0x000004, "Wrong alignment on OrionRigs_GetMatchTimePlaced");
static_assert(sizeof(OrionRigs_GetMatchTimePlaced) == 0x000004, "Wrong size on OrionRigs_GetMatchTimePlaced");
static_assert(offsetof(OrionRigs_GetMatchTimePlaced, ReturnValue) == 0x000000, "Member 'OrionRigs_GetMatchTimePlaced::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionRigs.GetPlayerThatPlacedRig
// 0x0008 (0x0008 - 0x0000)
struct OrionRigs_GetPlayerThatPlacedRig final
{
public:
	class AOrionPlayerState_Game*                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRigs_GetPlayerThatPlacedRig) == 0x000008, "Wrong alignment on OrionRigs_GetPlayerThatPlacedRig");
static_assert(sizeof(OrionRigs_GetPlayerThatPlacedRig) == 0x000008, "Wrong size on OrionRigs_GetPlayerThatPlacedRig");
static_assert(offsetof(OrionRigs_GetPlayerThatPlacedRig, ReturnValue) == 0x000000, "Member 'OrionRigs_GetPlayerThatPlacedRig::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionRigs.GetWellResourcePercentLeft
// 0x0004 (0x0004 - 0x0000)
struct OrionRigs_GetWellResourcePercentLeft final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRigs_GetWellResourcePercentLeft) == 0x000004, "Wrong alignment on OrionRigs_GetWellResourcePercentLeft");
static_assert(sizeof(OrionRigs_GetWellResourcePercentLeft) == 0x000004, "Wrong size on OrionRigs_GetWellResourcePercentLeft");
static_assert(offsetof(OrionRigs_GetWellResourcePercentLeft, ReturnValue) == 0x000000, "Member 'OrionRigs_GetWellResourcePercentLeft::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionRigs.OnAttachedToWell
// 0x0008 (0x0008 - 0x0000)
struct OrionRigs_OnAttachedToWell final
{
public:
	class AOrionWell_Base*                        InWell;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRigs_OnAttachedToWell) == 0x000008, "Wrong alignment on OrionRigs_OnAttachedToWell");
static_assert(sizeof(OrionRigs_OnAttachedToWell) == 0x000008, "Wrong size on OrionRigs_OnAttachedToWell");
static_assert(offsetof(OrionRigs_OnAttachedToWell, InWell) == 0x000000, "Member 'OrionRigs_OnAttachedToWell::InWell' has a wrong offset!");

// Function OrionGame.OrionRigs.OnRep_AttachedToWell
// 0x0008 (0x0008 - 0x0000)
struct OrionRigs_OnRep_AttachedToWell final
{
public:
	const class AOrionWell_Base*                  OldAttachedToWell;                                 // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRigs_OnRep_AttachedToWell) == 0x000008, "Wrong alignment on OrionRigs_OnRep_AttachedToWell");
static_assert(sizeof(OrionRigs_OnRep_AttachedToWell) == 0x000008, "Wrong size on OrionRigs_OnRep_AttachedToWell");
static_assert(offsetof(OrionRigs_OnRep_AttachedToWell, OldAttachedToWell) == 0x000000, "Member 'OrionRigs_OnRep_AttachedToWell::OldAttachedToWell' has a wrong offset!");

// Function OrionGame.OrionRigs.OnSpawnCoins
// 0x0010 (0x0010 - 0x0000)
struct OrionRigs_OnSpawnCoins final
{
public:
	float                                         ResourceAmount;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Target;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRigs_OnSpawnCoins) == 0x000008, "Wrong alignment on OrionRigs_OnSpawnCoins");
static_assert(sizeof(OrionRigs_OnSpawnCoins) == 0x000010, "Wrong size on OrionRigs_OnSpawnCoins");
static_assert(offsetof(OrionRigs_OnSpawnCoins, ResourceAmount) == 0x000000, "Member 'OrionRigs_OnSpawnCoins::ResourceAmount' has a wrong offset!");
static_assert(offsetof(OrionRigs_OnSpawnCoins, Target) == 0x000008, "Member 'OrionRigs_OnSpawnCoins::Target' has a wrong offset!");

// Function OrionGame.OrionRigs.PlayerCollectCoins
// 0x0008 (0x0008 - 0x0000)
struct OrionRigs_PlayerCollectCoins final
{
public:
	class AOrionCharHero*                         CollectingPlayer;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRigs_PlayerCollectCoins) == 0x000008, "Wrong alignment on OrionRigs_PlayerCollectCoins");
static_assert(sizeof(OrionRigs_PlayerCollectCoins) == 0x000008, "Wrong size on OrionRigs_PlayerCollectCoins");
static_assert(offsetof(OrionRigs_PlayerCollectCoins, CollectingPlayer) == 0x000000, "Member 'OrionRigs_PlayerCollectCoins::CollectingPlayer' has a wrong offset!");

// Function OrionGame.OrionRigs.SetPlayerThatPlacedThisRig
// 0x0008 (0x0008 - 0x0000)
struct OrionRigs_SetPlayerThatPlacedThisRig final
{
public:
	class AOrionPlayerState_Game*                 InPlayer;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRigs_SetPlayerThatPlacedThisRig) == 0x000008, "Wrong alignment on OrionRigs_SetPlayerThatPlacedThisRig");
static_assert(sizeof(OrionRigs_SetPlayerThatPlacedThisRig) == 0x000008, "Wrong size on OrionRigs_SetPlayerThatPlacedThisRig");
static_assert(offsetof(OrionRigs_SetPlayerThatPlacedThisRig, InPlayer) == 0x000000, "Member 'OrionRigs_SetPlayerThatPlacedThisRig::InPlayer' has a wrong offset!");

// Function OrionGame.OrionRigs.WellTagCallback_VisibleToEnemy
// 0x0010 (0x0010 - 0x0000)
struct OrionRigs_WellTagCallback_VisibleToEnemy final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewCount;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionRigs_WellTagCallback_VisibleToEnemy) == 0x000008, "Wrong alignment on OrionRigs_WellTagCallback_VisibleToEnemy");
static_assert(sizeof(OrionRigs_WellTagCallback_VisibleToEnemy) == 0x000010, "Wrong size on OrionRigs_WellTagCallback_VisibleToEnemy");
static_assert(offsetof(OrionRigs_WellTagCallback_VisibleToEnemy, Tag) == 0x000000, "Member 'OrionRigs_WellTagCallback_VisibleToEnemy::Tag' has a wrong offset!");
static_assert(offsetof(OrionRigs_WellTagCallback_VisibleToEnemy, NewCount) == 0x000008, "Member 'OrionRigs_WellTagCallback_VisibleToEnemy::NewCount' has a wrong offset!");

// Function OrionGame.OrionRotationalContentHandlerInterface.HandleRotationalContent
// 0x0020 (0x0020 - 0x0000)
struct OrionRotationalContentHandlerInterface_HandleRotationalContent final
{
public:
	struct FGameplayTagContainer                  TagsToHandle;                                      // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRotationalContentHandlerInterface_HandleRotationalContent) == 0x000008, "Wrong alignment on OrionRotationalContentHandlerInterface_HandleRotationalContent");
static_assert(sizeof(OrionRotationalContentHandlerInterface_HandleRotationalContent) == 0x000020, "Wrong size on OrionRotationalContentHandlerInterface_HandleRotationalContent");
static_assert(offsetof(OrionRotationalContentHandlerInterface_HandleRotationalContent, TagsToHandle) == 0x000000, "Member 'OrionRotationalContentHandlerInterface_HandleRotationalContent::TagsToHandle' has a wrong offset!");

// Function OrionGame.OrionRotationalContentManager.RegisterHandler
// 0x0010 (0x0010 - 0x0000)
struct OrionRotationalContentManager_RegisterHandler final
{
public:
	class UObject*                                Handler;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionRotationalContentManager*         SpecificManager;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRotationalContentManager_RegisterHandler) == 0x000008, "Wrong alignment on OrionRotationalContentManager_RegisterHandler");
static_assert(sizeof(OrionRotationalContentManager_RegisterHandler) == 0x000010, "Wrong size on OrionRotationalContentManager_RegisterHandler");
static_assert(offsetof(OrionRotationalContentManager_RegisterHandler, Handler) == 0x000000, "Member 'OrionRotationalContentManager_RegisterHandler::Handler' has a wrong offset!");
static_assert(offsetof(OrionRotationalContentManager_RegisterHandler, SpecificManager) == 0x000008, "Member 'OrionRotationalContentManager_RegisterHandler::SpecificManager' has a wrong offset!");

// Function OrionGame.OrionRotationalContentManager.UnRegisterHandler
// 0x0010 (0x0010 - 0x0000)
struct OrionRotationalContentManager_UnRegisterHandler final
{
public:
	class UObject*                                Handler;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionRotationalContentManager*         SpecificManager;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRotationalContentManager_UnRegisterHandler) == 0x000008, "Wrong alignment on OrionRotationalContentManager_UnRegisterHandler");
static_assert(sizeof(OrionRotationalContentManager_UnRegisterHandler) == 0x000010, "Wrong size on OrionRotationalContentManager_UnRegisterHandler");
static_assert(offsetof(OrionRotationalContentManager_UnRegisterHandler, Handler) == 0x000000, "Member 'OrionRotationalContentManager_UnRegisterHandler::Handler' has a wrong offset!");
static_assert(offsetof(OrionRotationalContentManager_UnRegisterHandler, SpecificManager) == 0x000008, "Member 'OrionRotationalContentManager_UnRegisterHandler::SpecificManager' has a wrong offset!");

// Function OrionGame.OrionRuntimeOptions.GetRuntimeOptions
// 0x0008 (0x0008 - 0x0000)
struct OrionRuntimeOptions_GetRuntimeOptions final
{
public:
	class UOrionRuntimeOptions*                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRuntimeOptions_GetRuntimeOptions) == 0x000008, "Wrong alignment on OrionRuntimeOptions_GetRuntimeOptions");
static_assert(sizeof(OrionRuntimeOptions_GetRuntimeOptions) == 0x000008, "Wrong size on OrionRuntimeOptions_GetRuntimeOptions");
static_assert(offsetof(OrionRuntimeOptions_GetRuntimeOptions, ReturnValue) == 0x000000, "Member 'OrionRuntimeOptions_GetRuntimeOptions::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionRuntimeOptions.GetBuildTime
// 0x0010 (0x0010 - 0x0000)
struct OrionRuntimeOptions_GetBuildTime final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRuntimeOptions_GetBuildTime) == 0x000008, "Wrong alignment on OrionRuntimeOptions_GetBuildTime");
static_assert(sizeof(OrionRuntimeOptions_GetBuildTime) == 0x000010, "Wrong size on OrionRuntimeOptions_GetBuildTime");
static_assert(offsetof(OrionRuntimeOptions_GetBuildTime, ReturnValue) == 0x000000, "Member 'OrionRuntimeOptions_GetBuildTime::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionRuntimeOptions.GetDecoySwapsEnabled
// 0x0001 (0x0001 - 0x0000)
struct OrionRuntimeOptions_GetDecoySwapsEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRuntimeOptions_GetDecoySwapsEnabled) == 0x000001, "Wrong alignment on OrionRuntimeOptions_GetDecoySwapsEnabled");
static_assert(sizeof(OrionRuntimeOptions_GetDecoySwapsEnabled) == 0x000001, "Wrong size on OrionRuntimeOptions_GetDecoySwapsEnabled");
static_assert(offsetof(OrionRuntimeOptions_GetDecoySwapsEnabled, ReturnValue) == 0x000000, "Member 'OrionRuntimeOptions_GetDecoySwapsEnabled::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionRuntimeOptions.GetFirstGamePlaylistID
// 0x0004 (0x0004 - 0x0000)
struct OrionRuntimeOptions_GetFirstGamePlaylistID final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRuntimeOptions_GetFirstGamePlaylistID) == 0x000004, "Wrong alignment on OrionRuntimeOptions_GetFirstGamePlaylistID");
static_assert(sizeof(OrionRuntimeOptions_GetFirstGamePlaylistID) == 0x000004, "Wrong size on OrionRuntimeOptions_GetFirstGamePlaylistID");
static_assert(offsetof(OrionRuntimeOptions_GetFirstGamePlaylistID, ReturnValue) == 0x000000, "Member 'OrionRuntimeOptions_GetFirstGamePlaylistID::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionRuntimeOptions.GetGameVersion
// 0x0010 (0x0010 - 0x0000)
struct OrionRuntimeOptions_GetGameVersion final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRuntimeOptions_GetGameVersion) == 0x000008, "Wrong alignment on OrionRuntimeOptions_GetGameVersion");
static_assert(sizeof(OrionRuntimeOptions_GetGameVersion) == 0x000010, "Wrong size on OrionRuntimeOptions_GetGameVersion");
static_assert(offsetof(OrionRuntimeOptions_GetGameVersion, ReturnValue) == 0x000000, "Member 'OrionRuntimeOptions_GetGameVersion::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionRuntimeOptions.IsDeathcamEnabled
// 0x0001 (0x0001 - 0x0000)
struct OrionRuntimeOptions_IsDeathcamEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRuntimeOptions_IsDeathcamEnabled) == 0x000001, "Wrong alignment on OrionRuntimeOptions_IsDeathcamEnabled");
static_assert(sizeof(OrionRuntimeOptions_IsDeathcamEnabled) == 0x000001, "Wrong size on OrionRuntimeOptions_IsDeathcamEnabled");
static_assert(offsetof(OrionRuntimeOptions_IsDeathcamEnabled, ReturnValue) == 0x000000, "Member 'OrionRuntimeOptions_IsDeathcamEnabled::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionRuntimeOptions.IsImageViewer
// 0x0001 (0x0001 - 0x0000)
struct OrionRuntimeOptions_IsImageViewer final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRuntimeOptions_IsImageViewer) == 0x000001, "Wrong alignment on OrionRuntimeOptions_IsImageViewer");
static_assert(sizeof(OrionRuntimeOptions_IsImageViewer) == 0x000001, "Wrong size on OrionRuntimeOptions_IsImageViewer");
static_assert(offsetof(OrionRuntimeOptions_IsImageViewer, ReturnValue) == 0x000000, "Member 'OrionRuntimeOptions_IsImageViewer::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionRuntimeOptions.ProjectileCustomHitsEnabled
// 0x0001 (0x0001 - 0x0000)
struct OrionRuntimeOptions_ProjectileCustomHitsEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRuntimeOptions_ProjectileCustomHitsEnabled) == 0x000001, "Wrong alignment on OrionRuntimeOptions_ProjectileCustomHitsEnabled");
static_assert(sizeof(OrionRuntimeOptions_ProjectileCustomHitsEnabled) == 0x000001, "Wrong size on OrionRuntimeOptions_ProjectileCustomHitsEnabled");
static_assert(offsetof(OrionRuntimeOptions_ProjectileCustomHitsEnabled, ReturnValue) == 0x000000, "Member 'OrionRuntimeOptions_ProjectileCustomHitsEnabled::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionRuntimeOptions.UseLegacyDeathTimers
// 0x0001 (0x0001 - 0x0000)
struct OrionRuntimeOptions_UseLegacyDeathTimers final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionRuntimeOptions_UseLegacyDeathTimers) == 0x000001, "Wrong alignment on OrionRuntimeOptions_UseLegacyDeathTimers");
static_assert(sizeof(OrionRuntimeOptions_UseLegacyDeathTimers) == 0x000001, "Wrong size on OrionRuntimeOptions_UseLegacyDeathTimers");
static_assert(offsetof(OrionRuntimeOptions_UseLegacyDeathTimers, ReturnValue) == 0x000000, "Member 'OrionRuntimeOptions_UseLegacyDeathTimers::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionShadowPad.GameplayTagCallback_ShadowPlanePadOff
// 0x0010 (0x0010 - 0x0000)
struct OrionShadowPad_GameplayTagCallback_ShadowPlanePadOff final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewCount;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionShadowPad_GameplayTagCallback_ShadowPlanePadOff) == 0x000008, "Wrong alignment on OrionShadowPad_GameplayTagCallback_ShadowPlanePadOff");
static_assert(sizeof(OrionShadowPad_GameplayTagCallback_ShadowPlanePadOff) == 0x000010, "Wrong size on OrionShadowPad_GameplayTagCallback_ShadowPlanePadOff");
static_assert(offsetof(OrionShadowPad_GameplayTagCallback_ShadowPlanePadOff, Tag) == 0x000000, "Member 'OrionShadowPad_GameplayTagCallback_ShadowPlanePadOff::Tag' has a wrong offset!");
static_assert(offsetof(OrionShadowPad_GameplayTagCallback_ShadowPlanePadOff, NewCount) == 0x000008, "Member 'OrionShadowPad_GameplayTagCallback_ShadowPlanePadOff::NewCount' has a wrong offset!");

// Function OrionGame.OrionShadowPad.HandleOverlappingCharDeath
// 0x0018 (0x0018 - 0x0000)
struct OrionShadowPad_HandleOverlappingCharDeath final
{
public:
	class AOrionChar*                             DeadChar;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            Killer;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionShadowPad_HandleOverlappingCharDeath) == 0x000008, "Wrong alignment on OrionShadowPad_HandleOverlappingCharDeath");
static_assert(sizeof(OrionShadowPad_HandleOverlappingCharDeath) == 0x000018, "Wrong size on OrionShadowPad_HandleOverlappingCharDeath");
static_assert(offsetof(OrionShadowPad_HandleOverlappingCharDeath, DeadChar) == 0x000000, "Member 'OrionShadowPad_HandleOverlappingCharDeath::DeadChar' has a wrong offset!");
static_assert(offsetof(OrionShadowPad_HandleOverlappingCharDeath, Killer) == 0x000008, "Member 'OrionShadowPad_HandleOverlappingCharDeath::Killer' has a wrong offset!");
static_assert(offsetof(OrionShadowPad_HandleOverlappingCharDeath, DamageCauser) == 0x000010, "Member 'OrionShadowPad_HandleOverlappingCharDeath::DamageCauser' has a wrong offset!");

// Function OrionGame.OrionShadowPad.HandleOverlappingCharEnteredPhaseShift
// 0x0008 (0x0008 - 0x0000)
struct OrionShadowPad_HandleOverlappingCharEnteredPhaseShift final
{
public:
	class AOrionChar*                             PhaseShifedChar;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionShadowPad_HandleOverlappingCharEnteredPhaseShift) == 0x000008, "Wrong alignment on OrionShadowPad_HandleOverlappingCharEnteredPhaseShift");
static_assert(sizeof(OrionShadowPad_HandleOverlappingCharEnteredPhaseShift) == 0x000008, "Wrong size on OrionShadowPad_HandleOverlappingCharEnteredPhaseShift");
static_assert(offsetof(OrionShadowPad_HandleOverlappingCharEnteredPhaseShift, PhaseShifedChar) == 0x000000, "Member 'OrionShadowPad_HandleOverlappingCharEnteredPhaseShift::PhaseShifedChar' has a wrong offset!");

// Function OrionGame.OrionShadowPad.OnOverlapBegin
// 0x00A8 (0x00A8 - 0x0000)
struct OrionShadowPad_OnOverlapBegin final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionShadowPad_OnOverlapBegin) == 0x000008, "Wrong alignment on OrionShadowPad_OnOverlapBegin");
static_assert(sizeof(OrionShadowPad_OnOverlapBegin) == 0x0000A8, "Wrong size on OrionShadowPad_OnOverlapBegin");
static_assert(offsetof(OrionShadowPad_OnOverlapBegin, OverlappedComp) == 0x000000, "Member 'OrionShadowPad_OnOverlapBegin::OverlappedComp' has a wrong offset!");
static_assert(offsetof(OrionShadowPad_OnOverlapBegin, OtherActor) == 0x000008, "Member 'OrionShadowPad_OnOverlapBegin::OtherActor' has a wrong offset!");
static_assert(offsetof(OrionShadowPad_OnOverlapBegin, OtherComp) == 0x000010, "Member 'OrionShadowPad_OnOverlapBegin::OtherComp' has a wrong offset!");
static_assert(offsetof(OrionShadowPad_OnOverlapBegin, OtherBodyIndex) == 0x000018, "Member 'OrionShadowPad_OnOverlapBegin::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(OrionShadowPad_OnOverlapBegin, bFromSweep) == 0x00001C, "Member 'OrionShadowPad_OnOverlapBegin::bFromSweep' has a wrong offset!");
static_assert(offsetof(OrionShadowPad_OnOverlapBegin, SweepResult) == 0x000020, "Member 'OrionShadowPad_OnOverlapBegin::SweepResult' has a wrong offset!");

// Function OrionGame.OrionShadowPad.OnOverlapEnd
// 0x0020 (0x0020 - 0x0000)
struct OrionShadowPad_OnOverlapEnd final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionShadowPad_OnOverlapEnd) == 0x000008, "Wrong alignment on OrionShadowPad_OnOverlapEnd");
static_assert(sizeof(OrionShadowPad_OnOverlapEnd) == 0x000020, "Wrong size on OrionShadowPad_OnOverlapEnd");
static_assert(offsetof(OrionShadowPad_OnOverlapEnd, OverlappedComp) == 0x000000, "Member 'OrionShadowPad_OnOverlapEnd::OverlappedComp' has a wrong offset!");
static_assert(offsetof(OrionShadowPad_OnOverlapEnd, OtherActor) == 0x000008, "Member 'OrionShadowPad_OnOverlapEnd::OtherActor' has a wrong offset!");
static_assert(offsetof(OrionShadowPad_OnOverlapEnd, OtherComp) == 0x000010, "Member 'OrionShadowPad_OnOverlapEnd::OtherComp' has a wrong offset!");
static_assert(offsetof(OrionShadowPad_OnOverlapEnd, OtherBodyIndex) == 0x000018, "Member 'OrionShadowPad_OnOverlapEnd::OtherBodyIndex' has a wrong offset!");

// Function OrionGame.OrionShadowPad.UpdateLocalEffects
// 0x0001 (0x0001 - 0x0000)
struct OrionShadowPad_UpdateLocalEffects final
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionShadowPad_UpdateLocalEffects) == 0x000001, "Wrong alignment on OrionShadowPad_UpdateLocalEffects");
static_assert(sizeof(OrionShadowPad_UpdateLocalEffects) == 0x000001, "Wrong size on OrionShadowPad_UpdateLocalEffects");
static_assert(offsetof(OrionShadowPad_UpdateLocalEffects, Enabled) == 0x000000, "Member 'OrionShadowPad_UpdateLocalEffects::Enabled' has a wrong offset!");

// Function OrionGame.OrionSpectatorCamComp_Arena.AddMoveForwardInput
// 0x0008 (0x0008 - 0x0000)
struct OrionSpectatorCamComp_Arena_AddMoveForwardInput final
{
public:
	float                                         InputVal;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionSpectatorCamComp_Arena_AddMoveForwardInput) == 0x000004, "Wrong alignment on OrionSpectatorCamComp_Arena_AddMoveForwardInput");
static_assert(sizeof(OrionSpectatorCamComp_Arena_AddMoveForwardInput) == 0x000008, "Wrong size on OrionSpectatorCamComp_Arena_AddMoveForwardInput");
static_assert(offsetof(OrionSpectatorCamComp_Arena_AddMoveForwardInput, InputVal) == 0x000000, "Member 'OrionSpectatorCamComp_Arena_AddMoveForwardInput::InputVal' has a wrong offset!");
static_assert(offsetof(OrionSpectatorCamComp_Arena_AddMoveForwardInput, ReturnValue) == 0x000004, "Member 'OrionSpectatorCamComp_Arena_AddMoveForwardInput::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionSpectatorCamComp_Arena.AddMoveRightInput
// 0x0008 (0x0008 - 0x0000)
struct OrionSpectatorCamComp_Arena_AddMoveRightInput final
{
public:
	float                                         InputVal;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionSpectatorCamComp_Arena_AddMoveRightInput) == 0x000004, "Wrong alignment on OrionSpectatorCamComp_Arena_AddMoveRightInput");
static_assert(sizeof(OrionSpectatorCamComp_Arena_AddMoveRightInput) == 0x000008, "Wrong size on OrionSpectatorCamComp_Arena_AddMoveRightInput");
static_assert(offsetof(OrionSpectatorCamComp_Arena_AddMoveRightInput, InputVal) == 0x000000, "Member 'OrionSpectatorCamComp_Arena_AddMoveRightInput::InputVal' has a wrong offset!");
static_assert(offsetof(OrionSpectatorCamComp_Arena_AddMoveRightInput, ReturnValue) == 0x000004, "Member 'OrionSpectatorCamComp_Arena_AddMoveRightInput::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionSpectatorCamComp_Arena.SetCameraPositionOnRail
// 0x0004 (0x0004 - 0x0000)
struct OrionSpectatorCamComp_Arena_SetCameraPositionOnRail final
{
public:
	float                                         DistanceAlongRail;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionSpectatorCamComp_Arena_SetCameraPositionOnRail) == 0x000004, "Wrong alignment on OrionSpectatorCamComp_Arena_SetCameraPositionOnRail");
static_assert(sizeof(OrionSpectatorCamComp_Arena_SetCameraPositionOnRail) == 0x000004, "Wrong size on OrionSpectatorCamComp_Arena_SetCameraPositionOnRail");
static_assert(offsetof(OrionSpectatorCamComp_Arena_SetCameraPositionOnRail, DistanceAlongRail) == 0x000000, "Member 'OrionSpectatorCamComp_Arena_SetCameraPositionOnRail::DistanceAlongRail' has a wrong offset!");

// Function OrionGame.OrionSpectatorCamComp_Arena.SetEnforce180Rule
// 0x0001 (0x0001 - 0x0000)
struct OrionSpectatorCamComp_Arena_SetEnforce180Rule final
{
public:
	bool                                          bNewEnforce180;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionSpectatorCamComp_Arena_SetEnforce180Rule) == 0x000001, "Wrong alignment on OrionSpectatorCamComp_Arena_SetEnforce180Rule");
static_assert(sizeof(OrionSpectatorCamComp_Arena_SetEnforce180Rule) == 0x000001, "Wrong size on OrionSpectatorCamComp_Arena_SetEnforce180Rule");
static_assert(offsetof(OrionSpectatorCamComp_Arena_SetEnforce180Rule, bNewEnforce180) == 0x000000, "Member 'OrionSpectatorCamComp_Arena_SetEnforce180Rule::bNewEnforce180' has a wrong offset!");

// Function OrionGame.OrionSpectatorCamComp_Chase.SetAutoFollow
// 0x0001 (0x0001 - 0x0000)
struct OrionSpectatorCamComp_Chase_SetAutoFollow final
{
public:
	bool                                          bNewAutoFollow;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionSpectatorCamComp_Chase_SetAutoFollow) == 0x000001, "Wrong alignment on OrionSpectatorCamComp_Chase_SetAutoFollow");
static_assert(sizeof(OrionSpectatorCamComp_Chase_SetAutoFollow) == 0x000001, "Wrong size on OrionSpectatorCamComp_Chase_SetAutoFollow");
static_assert(offsetof(OrionSpectatorCamComp_Chase_SetAutoFollow, bNewAutoFollow) == 0x000000, "Member 'OrionSpectatorCamComp_Chase_SetAutoFollow::bNewAutoFollow' has a wrong offset!");

// Function OrionGame.OrionSpectatorCamComp_Chase.SetLazyAutoFollow
// 0x0001 (0x0001 - 0x0000)
struct OrionSpectatorCamComp_Chase_SetLazyAutoFollow final
{
public:
	bool                                          bNewLazyAutoFollow;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionSpectatorCamComp_Chase_SetLazyAutoFollow) == 0x000001, "Wrong alignment on OrionSpectatorCamComp_Chase_SetLazyAutoFollow");
static_assert(sizeof(OrionSpectatorCamComp_Chase_SetLazyAutoFollow) == 0x000001, "Wrong size on OrionSpectatorCamComp_Chase_SetLazyAutoFollow");
static_assert(offsetof(OrionSpectatorCamComp_Chase_SetLazyAutoFollow, bNewLazyAutoFollow) == 0x000000, "Member 'OrionSpectatorCamComp_Chase_SetLazyAutoFollow::bNewLazyAutoFollow' has a wrong offset!");

// Function OrionGame.OrionSpectatorCamComp_Isometric.SetCameraAngle
// 0x0001 (0x0001 - 0x0000)
struct OrionSpectatorCamComp_Isometric_SetCameraAngle final
{
public:
	EIsometricCamAngle                            NewAngle;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionSpectatorCamComp_Isometric_SetCameraAngle) == 0x000001, "Wrong alignment on OrionSpectatorCamComp_Isometric_SetCameraAngle");
static_assert(sizeof(OrionSpectatorCamComp_Isometric_SetCameraAngle) == 0x000001, "Wrong size on OrionSpectatorCamComp_Isometric_SetCameraAngle");
static_assert(offsetof(OrionSpectatorCamComp_Isometric_SetCameraAngle, NewAngle) == 0x000000, "Member 'OrionSpectatorCamComp_Isometric_SetCameraAngle::NewAngle' has a wrong offset!");

// Function OrionGame.OrionSpectatorCamComp_OTS.SetAutoFollow
// 0x0001 (0x0001 - 0x0000)
struct OrionSpectatorCamComp_OTS_SetAutoFollow final
{
public:
	bool                                          bNewAutoFollow;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionSpectatorCamComp_OTS_SetAutoFollow) == 0x000001, "Wrong alignment on OrionSpectatorCamComp_OTS_SetAutoFollow");
static_assert(sizeof(OrionSpectatorCamComp_OTS_SetAutoFollow) == 0x000001, "Wrong size on OrionSpectatorCamComp_OTS_SetAutoFollow");
static_assert(offsetof(OrionSpectatorCamComp_OTS_SetAutoFollow, bNewAutoFollow) == 0x000000, "Member 'OrionSpectatorCamComp_OTS_SetAutoFollow::bNewAutoFollow' has a wrong offset!");

// Function OrionGame.OrionTargetingFunctionLibrary.SphereAroundActor
// 0x0098 (0x0098 - 0x0000)
struct OrionTargetingFunctionLibrary_SphereAroundActor final
{
public:
	class AActor*                                 TargetingActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 AroundActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionActorFilter                      Filter;                                            // 0x0018(0x0060)(Parm, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       ReturnValue;                                       // 0x0078(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTargetingFunctionLibrary_SphereAroundActor) == 0x000008, "Wrong alignment on OrionTargetingFunctionLibrary_SphereAroundActor");
static_assert(sizeof(OrionTargetingFunctionLibrary_SphereAroundActor) == 0x000098, "Wrong size on OrionTargetingFunctionLibrary_SphereAroundActor");
static_assert(offsetof(OrionTargetingFunctionLibrary_SphereAroundActor, TargetingActor) == 0x000000, "Member 'OrionTargetingFunctionLibrary_SphereAroundActor::TargetingActor' has a wrong offset!");
static_assert(offsetof(OrionTargetingFunctionLibrary_SphereAroundActor, AroundActor) == 0x000008, "Member 'OrionTargetingFunctionLibrary_SphereAroundActor::AroundActor' has a wrong offset!");
static_assert(offsetof(OrionTargetingFunctionLibrary_SphereAroundActor, Radius) == 0x000010, "Member 'OrionTargetingFunctionLibrary_SphereAroundActor::Radius' has a wrong offset!");
static_assert(offsetof(OrionTargetingFunctionLibrary_SphereAroundActor, Filter) == 0x000018, "Member 'OrionTargetingFunctionLibrary_SphereAroundActor::Filter' has a wrong offset!");
static_assert(offsetof(OrionTargetingFunctionLibrary_SphereAroundActor, ReturnValue) == 0x000078, "Member 'OrionTargetingFunctionLibrary_SphereAroundActor::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTeamBuilderPartyMember.SetDeck
// 0x0010 (0x0010 - 0x0000)
struct OrionTeamBuilderPartyMember_SetDeck final
{
public:
	class FString                                 DeckId;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamBuilderPartyMember_SetDeck) == 0x000008, "Wrong alignment on OrionTeamBuilderPartyMember_SetDeck");
static_assert(sizeof(OrionTeamBuilderPartyMember_SetDeck) == 0x000010, "Wrong size on OrionTeamBuilderPartyMember_SetDeck");
static_assert(offsetof(OrionTeamBuilderPartyMember_SetDeck, DeckId) == 0x000000, "Member 'OrionTeamBuilderPartyMember_SetDeck::DeckId' has a wrong offset!");

// Function OrionGame.OrionTeamBuilderPartyMember.SetHeroName
// 0x0010 (0x0010 - 0x0000)
struct OrionTeamBuilderPartyMember_SetHeroName final
{
public:
	class FString                                 HeroName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamBuilderPartyMember_SetHeroName) == 0x000008, "Wrong alignment on OrionTeamBuilderPartyMember_SetHeroName");
static_assert(sizeof(OrionTeamBuilderPartyMember_SetHeroName) == 0x000010, "Wrong size on OrionTeamBuilderPartyMember_SetHeroName");
static_assert(offsetof(OrionTeamBuilderPartyMember_SetHeroName, HeroName) == 0x000000, "Member 'OrionTeamBuilderPartyMember_SetHeroName::HeroName' has a wrong offset!");

// Function OrionGame.OrionTeamBuilderPartyMember.SetPlatform
// 0x0001 (0x0001 - 0x0000)
struct OrionTeamBuilderPartyMember_SetPlatform final
{
public:
	EOrionPlayerPlatform                          InPlatform;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamBuilderPartyMember_SetPlatform) == 0x000001, "Wrong alignment on OrionTeamBuilderPartyMember_SetPlatform");
static_assert(sizeof(OrionTeamBuilderPartyMember_SetPlatform) == 0x000001, "Wrong size on OrionTeamBuilderPartyMember_SetPlatform");
static_assert(offsetof(OrionTeamBuilderPartyMember_SetPlatform, InPlatform) == 0x000000, "Member 'OrionTeamBuilderPartyMember_SetPlatform::InPlatform' has a wrong offset!");

// Function OrionGame.OrionTeamBuilderPartyMember.SetPosition
// 0x0001 (0x0001 - 0x0000)
struct OrionTeamBuilderPartyMember_SetPosition final
{
public:
	EOrionPosition                                Position;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamBuilderPartyMember_SetPosition) == 0x000001, "Wrong alignment on OrionTeamBuilderPartyMember_SetPosition");
static_assert(sizeof(OrionTeamBuilderPartyMember_SetPosition) == 0x000001, "Wrong size on OrionTeamBuilderPartyMember_SetPosition");
static_assert(offsetof(OrionTeamBuilderPartyMember_SetPosition, Position) == 0x000000, "Member 'OrionTeamBuilderPartyMember_SetPosition::Position' has a wrong offset!");

// Function OrionGame.OrionTeamBuilderPartyMember.SetReady
// 0x0001 (0x0001 - 0x0000)
struct OrionTeamBuilderPartyMember_SetReady final
{
public:
	bool                                          InReady;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamBuilderPartyMember_SetReady) == 0x000001, "Wrong alignment on OrionTeamBuilderPartyMember_SetReady");
static_assert(sizeof(OrionTeamBuilderPartyMember_SetReady) == 0x000001, "Wrong size on OrionTeamBuilderPartyMember_SetReady");
static_assert(offsetof(OrionTeamBuilderPartyMember_SetReady, InReady) == 0x000000, "Member 'OrionTeamBuilderPartyMember_SetReady::InReady' has a wrong offset!");

// Function OrionGame.OrionTeamBuilderPartyMember.SetRole
// 0x0001 (0x0001 - 0x0000)
struct OrionTeamBuilderPartyMember_SetRole final
{
public:
	EOrionRole                                    Role;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamBuilderPartyMember_SetRole) == 0x000001, "Wrong alignment on OrionTeamBuilderPartyMember_SetRole");
static_assert(sizeof(OrionTeamBuilderPartyMember_SetRole) == 0x000001, "Wrong size on OrionTeamBuilderPartyMember_SetRole");
static_assert(offsetof(OrionTeamBuilderPartyMember_SetRole, Role) == 0x000000, "Member 'OrionTeamBuilderPartyMember_SetRole::Role' has a wrong offset!");

// Function OrionGame.OrionTeamBuilderPartyMember.GetCosmeticChoices
// 0x00E0 (0x00E0 - 0x0000)
struct OrionTeamBuilderPartyMember_GetCosmeticChoices final
{
public:
	struct FOrionCosmeticPlayerChoices            ReturnValue;                                       // 0x0000(0x00E0)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamBuilderPartyMember_GetCosmeticChoices) == 0x000008, "Wrong alignment on OrionTeamBuilderPartyMember_GetCosmeticChoices");
static_assert(sizeof(OrionTeamBuilderPartyMember_GetCosmeticChoices) == 0x0000E0, "Wrong size on OrionTeamBuilderPartyMember_GetCosmeticChoices");
static_assert(offsetof(OrionTeamBuilderPartyMember_GetCosmeticChoices, ReturnValue) == 0x000000, "Member 'OrionTeamBuilderPartyMember_GetCosmeticChoices::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTeamBuilderPartyMember.GetDeck
// 0x0010 (0x0010 - 0x0000)
struct OrionTeamBuilderPartyMember_GetDeck final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamBuilderPartyMember_GetDeck) == 0x000008, "Wrong alignment on OrionTeamBuilderPartyMember_GetDeck");
static_assert(sizeof(OrionTeamBuilderPartyMember_GetDeck) == 0x000010, "Wrong size on OrionTeamBuilderPartyMember_GetDeck");
static_assert(offsetof(OrionTeamBuilderPartyMember_GetDeck, ReturnValue) == 0x000000, "Member 'OrionTeamBuilderPartyMember_GetDeck::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTeamBuilderPartyMember.GetHeroName
// 0x0010 (0x0010 - 0x0000)
struct OrionTeamBuilderPartyMember_GetHeroName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamBuilderPartyMember_GetHeroName) == 0x000008, "Wrong alignment on OrionTeamBuilderPartyMember_GetHeroName");
static_assert(sizeof(OrionTeamBuilderPartyMember_GetHeroName) == 0x000010, "Wrong size on OrionTeamBuilderPartyMember_GetHeroName");
static_assert(offsetof(OrionTeamBuilderPartyMember_GetHeroName, ReturnValue) == 0x000000, "Member 'OrionTeamBuilderPartyMember_GetHeroName::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTeamBuilderPartyMember.GetPlatform
// 0x0001 (0x0001 - 0x0000)
struct OrionTeamBuilderPartyMember_GetPlatform final
{
public:
	EOrionPlayerPlatform                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamBuilderPartyMember_GetPlatform) == 0x000001, "Wrong alignment on OrionTeamBuilderPartyMember_GetPlatform");
static_assert(sizeof(OrionTeamBuilderPartyMember_GetPlatform) == 0x000001, "Wrong size on OrionTeamBuilderPartyMember_GetPlatform");
static_assert(offsetof(OrionTeamBuilderPartyMember_GetPlatform, ReturnValue) == 0x000000, "Member 'OrionTeamBuilderPartyMember_GetPlatform::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTeamBuilderPartyMember.GetPosition
// 0x0001 (0x0001 - 0x0000)
struct OrionTeamBuilderPartyMember_GetPosition final
{
public:
	EOrionPosition                                ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamBuilderPartyMember_GetPosition) == 0x000001, "Wrong alignment on OrionTeamBuilderPartyMember_GetPosition");
static_assert(sizeof(OrionTeamBuilderPartyMember_GetPosition) == 0x000001, "Wrong size on OrionTeamBuilderPartyMember_GetPosition");
static_assert(offsetof(OrionTeamBuilderPartyMember_GetPosition, ReturnValue) == 0x000000, "Member 'OrionTeamBuilderPartyMember_GetPosition::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTeamBuilderPartyMember.GetRole
// 0x0001 (0x0001 - 0x0000)
struct OrionTeamBuilderPartyMember_GetRole final
{
public:
	EOrionRole                                    ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamBuilderPartyMember_GetRole) == 0x000001, "Wrong alignment on OrionTeamBuilderPartyMember_GetRole");
static_assert(sizeof(OrionTeamBuilderPartyMember_GetRole) == 0x000001, "Wrong size on OrionTeamBuilderPartyMember_GetRole");
static_assert(offsetof(OrionTeamBuilderPartyMember_GetRole, ReturnValue) == 0x000000, "Member 'OrionTeamBuilderPartyMember_GetRole::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTeamBuilderPartyMember.GetSlotIdx
// 0x0004 (0x0004 - 0x0000)
struct OrionTeamBuilderPartyMember_GetSlotIdx final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamBuilderPartyMember_GetSlotIdx) == 0x000004, "Wrong alignment on OrionTeamBuilderPartyMember_GetSlotIdx");
static_assert(sizeof(OrionTeamBuilderPartyMember_GetSlotIdx) == 0x000004, "Wrong size on OrionTeamBuilderPartyMember_GetSlotIdx");
static_assert(offsetof(OrionTeamBuilderPartyMember_GetSlotIdx, ReturnValue) == 0x000000, "Member 'OrionTeamBuilderPartyMember_GetSlotIdx::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTeamBuilderPartyMember.IsDirty
// 0x0002 (0x0002 - 0x0000)
struct OrionTeamBuilderPartyMember_IsDirty final
{
public:
	EOrionTeamBuilderPartyMemberStateFlags        Flag;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamBuilderPartyMember_IsDirty) == 0x000001, "Wrong alignment on OrionTeamBuilderPartyMember_IsDirty");
static_assert(sizeof(OrionTeamBuilderPartyMember_IsDirty) == 0x000002, "Wrong size on OrionTeamBuilderPartyMember_IsDirty");
static_assert(offsetof(OrionTeamBuilderPartyMember_IsDirty, Flag) == 0x000000, "Member 'OrionTeamBuilderPartyMember_IsDirty::Flag' has a wrong offset!");
static_assert(offsetof(OrionTeamBuilderPartyMember_IsDirty, ReturnValue) == 0x000001, "Member 'OrionTeamBuilderPartyMember_IsDirty::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTeamBuilderPartyMember.IsReady
// 0x0001 (0x0001 - 0x0000)
struct OrionTeamBuilderPartyMember_IsReady final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamBuilderPartyMember_IsReady) == 0x000001, "Wrong alignment on OrionTeamBuilderPartyMember_IsReady");
static_assert(sizeof(OrionTeamBuilderPartyMember_IsReady) == 0x000001, "Wrong size on OrionTeamBuilderPartyMember_IsReady");
static_assert(offsetof(OrionTeamBuilderPartyMember_IsReady, ReturnValue) == 0x000000, "Member 'OrionTeamBuilderPartyMember_IsReady::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTeamColorComponent.SetupTeamColors
// 0x0002 (0x0002 - 0x0000)
struct OrionTeamColorComponent_SetupTeamColors final
{
public:
	EOrionTeam                                    TeamNum;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDead;                                           // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamColorComponent_SetupTeamColors) == 0x000001, "Wrong alignment on OrionTeamColorComponent_SetupTeamColors");
static_assert(sizeof(OrionTeamColorComponent_SetupTeamColors) == 0x000002, "Wrong size on OrionTeamColorComponent_SetupTeamColors");
static_assert(offsetof(OrionTeamColorComponent_SetupTeamColors, TeamNum) == 0x000000, "Member 'OrionTeamColorComponent_SetupTeamColors::TeamNum' has a wrong offset!");
static_assert(offsetof(OrionTeamColorComponent_SetupTeamColors, bIsDead) == 0x000001, "Member 'OrionTeamColorComponent_SetupTeamColors::bIsDead' has a wrong offset!");

// Function OrionGame.OrionTeamInfo.GetPlayerArray
// 0x0010 (0x0010 - 0x0000)
struct OrionTeamInfo_GetPlayerArray final
{
public:
	TArray<class AController*>                    ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamInfo_GetPlayerArray) == 0x000008, "Wrong alignment on OrionTeamInfo_GetPlayerArray");
static_assert(sizeof(OrionTeamInfo_GetPlayerArray) == 0x000010, "Wrong size on OrionTeamInfo_GetPlayerArray");
static_assert(offsetof(OrionTeamInfo_GetPlayerArray, ReturnValue) == 0x000000, "Member 'OrionTeamInfo_GetPlayerArray::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTeamInfo.GetDragonKillCount
// 0x0004 (0x0004 - 0x0000)
struct OrionTeamInfo_GetDragonKillCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamInfo_GetDragonKillCount) == 0x000004, "Wrong alignment on OrionTeamInfo_GetDragonKillCount");
static_assert(sizeof(OrionTeamInfo_GetDragonKillCount) == 0x000004, "Wrong size on OrionTeamInfo_GetDragonKillCount");
static_assert(offsetof(OrionTeamInfo_GetDragonKillCount, ReturnValue) == 0x000000, "Member 'OrionTeamInfo_GetDragonKillCount::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTeamInfo.GetMaxPlayers
// 0x0004 (0x0004 - 0x0000)
struct OrionTeamInfo_GetMaxPlayers final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamInfo_GetMaxPlayers) == 0x000004, "Wrong alignment on OrionTeamInfo_GetMaxPlayers");
static_assert(sizeof(OrionTeamInfo_GetMaxPlayers) == 0x000004, "Wrong size on OrionTeamInfo_GetMaxPlayers");
static_assert(offsetof(OrionTeamInfo_GetMaxPlayers, ReturnValue) == 0x000000, "Member 'OrionTeamInfo_GetMaxPlayers::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTeamInfo.GetNumPlayersOnTeam
// 0x0004 (0x0004 - 0x0000)
struct OrionTeamInfo_GetNumPlayersOnTeam final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamInfo_GetNumPlayersOnTeam) == 0x000004, "Wrong alignment on OrionTeamInfo_GetNumPlayersOnTeam");
static_assert(sizeof(OrionTeamInfo_GetNumPlayersOnTeam) == 0x000004, "Wrong size on OrionTeamInfo_GetNumPlayersOnTeam");
static_assert(offsetof(OrionTeamInfo_GetNumPlayersOnTeam, ReturnValue) == 0x000000, "Member 'OrionTeamInfo_GetNumPlayersOnTeam::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTeamInfo.GetSurrenderButtonText
// 0x0018 (0x0018 - 0x0000)
struct OrionTeamInfo_GetSurrenderButtonText final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamInfo_GetSurrenderButtonText) == 0x000008, "Wrong alignment on OrionTeamInfo_GetSurrenderButtonText");
static_assert(sizeof(OrionTeamInfo_GetSurrenderButtonText) == 0x000018, "Wrong size on OrionTeamInfo_GetSurrenderButtonText");
static_assert(offsetof(OrionTeamInfo_GetSurrenderButtonText, ReturnValue) == 0x000000, "Member 'OrionTeamInfo_GetSurrenderButtonText::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTeamInfo.GetSurrenderVoteCooldownSecondsRemaining
// 0x0004 (0x0004 - 0x0000)
struct OrionTeamInfo_GetSurrenderVoteCooldownSecondsRemaining final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamInfo_GetSurrenderVoteCooldownSecondsRemaining) == 0x000004, "Wrong alignment on OrionTeamInfo_GetSurrenderVoteCooldownSecondsRemaining");
static_assert(sizeof(OrionTeamInfo_GetSurrenderVoteCooldownSecondsRemaining) == 0x000004, "Wrong size on OrionTeamInfo_GetSurrenderVoteCooldownSecondsRemaining");
static_assert(offsetof(OrionTeamInfo_GetSurrenderVoteCooldownSecondsRemaining, ReturnValue) == 0x000000, "Member 'OrionTeamInfo_GetSurrenderVoteCooldownSecondsRemaining::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTeamInfo.GetSurrenderVoteSecondsRemaining
// 0x0004 (0x0004 - 0x0000)
struct OrionTeamInfo_GetSurrenderVoteSecondsRemaining final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamInfo_GetSurrenderVoteSecondsRemaining) == 0x000004, "Wrong alignment on OrionTeamInfo_GetSurrenderVoteSecondsRemaining");
static_assert(sizeof(OrionTeamInfo_GetSurrenderVoteSecondsRemaining) == 0x000004, "Wrong size on OrionTeamInfo_GetSurrenderVoteSecondsRemaining");
static_assert(offsetof(OrionTeamInfo_GetSurrenderVoteSecondsRemaining, ReturnValue) == 0x000000, "Member 'OrionTeamInfo_GetSurrenderVoteSecondsRemaining::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTeamInfo.GetSurrenderVoteStatus
// 0x0001 (0x0001 - 0x0000)
struct OrionTeamInfo_GetSurrenderVoteStatus final
{
public:
	ETeamSurrenderStatus                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamInfo_GetSurrenderVoteStatus) == 0x000001, "Wrong alignment on OrionTeamInfo_GetSurrenderVoteStatus");
static_assert(sizeof(OrionTeamInfo_GetSurrenderVoteStatus) == 0x000001, "Wrong size on OrionTeamInfo_GetSurrenderVoteStatus");
static_assert(offsetof(OrionTeamInfo_GetSurrenderVoteStatus, ReturnValue) == 0x000000, "Member 'OrionTeamInfo_GetSurrenderVoteStatus::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTeamInfo.GetSurrenderVoteText
// 0x0020 (0x0020 - 0x0000)
struct OrionTeamInfo_GetSurrenderVoteText final
{
public:
	class FText                                   VoteText;                                          // 0x0000(0x0018)(Parm, OutParm, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionTeamInfo_GetSurrenderVoteText) == 0x000008, "Wrong alignment on OrionTeamInfo_GetSurrenderVoteText");
static_assert(sizeof(OrionTeamInfo_GetSurrenderVoteText) == 0x000020, "Wrong size on OrionTeamInfo_GetSurrenderVoteText");
static_assert(offsetof(OrionTeamInfo_GetSurrenderVoteText, VoteText) == 0x000000, "Member 'OrionTeamInfo_GetSurrenderVoteText::VoteText' has a wrong offset!");
static_assert(offsetof(OrionTeamInfo_GetSurrenderVoteText, ReturnValue) == 0x000018, "Member 'OrionTeamInfo_GetSurrenderVoteText::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTeamInfo.GetTeamAssists
// 0x0004 (0x0004 - 0x0000)
struct OrionTeamInfo_GetTeamAssists final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamInfo_GetTeamAssists) == 0x000004, "Wrong alignment on OrionTeamInfo_GetTeamAssists");
static_assert(sizeof(OrionTeamInfo_GetTeamAssists) == 0x000004, "Wrong size on OrionTeamInfo_GetTeamAssists");
static_assert(offsetof(OrionTeamInfo_GetTeamAssists, ReturnValue) == 0x000000, "Member 'OrionTeamInfo_GetTeamAssists::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTeamInfo.GetTeamBuilderInfo
// 0x0188 (0x0188 - 0x0000)
struct OrionTeamInfo_GetTeamBuilderInfo final
{
public:
	struct FOrionTBTeamInfo                       ReturnValue;                                       // 0x0000(0x0188)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamInfo_GetTeamBuilderInfo) == 0x000008, "Wrong alignment on OrionTeamInfo_GetTeamBuilderInfo");
static_assert(sizeof(OrionTeamInfo_GetTeamBuilderInfo) == 0x000188, "Wrong size on OrionTeamInfo_GetTeamBuilderInfo");
static_assert(offsetof(OrionTeamInfo_GetTeamBuilderInfo, ReturnValue) == 0x000000, "Member 'OrionTeamInfo_GetTeamBuilderInfo::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTeamInfo.GetTeamDeaths
// 0x0004 (0x0004 - 0x0000)
struct OrionTeamInfo_GetTeamDeaths final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamInfo_GetTeamDeaths) == 0x000004, "Wrong alignment on OrionTeamInfo_GetTeamDeaths");
static_assert(sizeof(OrionTeamInfo_GetTeamDeaths) == 0x000004, "Wrong size on OrionTeamInfo_GetTeamDeaths");
static_assert(offsetof(OrionTeamInfo_GetTeamDeaths, ReturnValue) == 0x000000, "Member 'OrionTeamInfo_GetTeamDeaths::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTeamInfo.GetTeamDestroyedRigs
// 0x0004 (0x0004 - 0x0000)
struct OrionTeamInfo_GetTeamDestroyedRigs final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamInfo_GetTeamDestroyedRigs) == 0x000004, "Wrong alignment on OrionTeamInfo_GetTeamDestroyedRigs");
static_assert(sizeof(OrionTeamInfo_GetTeamDestroyedRigs) == 0x000004, "Wrong size on OrionTeamInfo_GetTeamDestroyedRigs");
static_assert(offsetof(OrionTeamInfo_GetTeamDestroyedRigs, ReturnValue) == 0x000000, "Member 'OrionTeamInfo_GetTeamDestroyedRigs::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTeamInfo.GetTeamInhibitorKills
// 0x0004 (0x0004 - 0x0000)
struct OrionTeamInfo_GetTeamInhibitorKills final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamInfo_GetTeamInhibitorKills) == 0x000004, "Wrong alignment on OrionTeamInfo_GetTeamInhibitorKills");
static_assert(sizeof(OrionTeamInfo_GetTeamInhibitorKills) == 0x000004, "Wrong size on OrionTeamInfo_GetTeamInhibitorKills");
static_assert(offsetof(OrionTeamInfo_GetTeamInhibitorKills, ReturnValue) == 0x000000, "Member 'OrionTeamInfo_GetTeamInhibitorKills::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTeamInfo.GetTeamInhibitorTakedowns
// 0x0004 (0x0004 - 0x0000)
struct OrionTeamInfo_GetTeamInhibitorTakedowns final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamInfo_GetTeamInhibitorTakedowns) == 0x000004, "Wrong alignment on OrionTeamInfo_GetTeamInhibitorTakedowns");
static_assert(sizeof(OrionTeamInfo_GetTeamInhibitorTakedowns) == 0x000004, "Wrong size on OrionTeamInfo_GetTeamInhibitorTakedowns");
static_assert(offsetof(OrionTeamInfo_GetTeamInhibitorTakedowns, ReturnValue) == 0x000000, "Member 'OrionTeamInfo_GetTeamInhibitorTakedowns::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTeamInfo.GetTeamKills
// 0x0004 (0x0004 - 0x0000)
struct OrionTeamInfo_GetTeamKills final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamInfo_GetTeamKills) == 0x000004, "Wrong alignment on OrionTeamInfo_GetTeamKills");
static_assert(sizeof(OrionTeamInfo_GetTeamKills) == 0x000004, "Wrong size on OrionTeamInfo_GetTeamKills");
static_assert(offsetof(OrionTeamInfo_GetTeamKills, ReturnValue) == 0x000000, "Member 'OrionTeamInfo_GetTeamKills::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTeamInfo.GetTeamMinionKills
// 0x0004 (0x0004 - 0x0000)
struct OrionTeamInfo_GetTeamMinionKills final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamInfo_GetTeamMinionKills) == 0x000004, "Wrong alignment on OrionTeamInfo_GetTeamMinionKills");
static_assert(sizeof(OrionTeamInfo_GetTeamMinionKills) == 0x000004, "Wrong size on OrionTeamInfo_GetTeamMinionKills");
static_assert(offsetof(OrionTeamInfo_GetTeamMinionKills, ReturnValue) == 0x000000, "Member 'OrionTeamInfo_GetTeamMinionKills::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTeamInfo.GetTeamPlacedRigs
// 0x0004 (0x0004 - 0x0000)
struct OrionTeamInfo_GetTeamPlacedRigs final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamInfo_GetTeamPlacedRigs) == 0x000004, "Wrong alignment on OrionTeamInfo_GetTeamPlacedRigs");
static_assert(sizeof(OrionTeamInfo_GetTeamPlacedRigs) == 0x000004, "Wrong size on OrionTeamInfo_GetTeamPlacedRigs");
static_assert(offsetof(OrionTeamInfo_GetTeamPlacedRigs, ReturnValue) == 0x000000, "Member 'OrionTeamInfo_GetTeamPlacedRigs::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTeamInfo.GetTeamTowerKills
// 0x0004 (0x0004 - 0x0000)
struct OrionTeamInfo_GetTeamTowerKills final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamInfo_GetTeamTowerKills) == 0x000004, "Wrong alignment on OrionTeamInfo_GetTeamTowerKills");
static_assert(sizeof(OrionTeamInfo_GetTeamTowerKills) == 0x000004, "Wrong size on OrionTeamInfo_GetTeamTowerKills");
static_assert(offsetof(OrionTeamInfo_GetTeamTowerKills, ReturnValue) == 0x000000, "Member 'OrionTeamInfo_GetTeamTowerKills::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTeamInfo.GetTeamTowerTakedowns
// 0x0004 (0x0004 - 0x0000)
struct OrionTeamInfo_GetTeamTowerTakedowns final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamInfo_GetTeamTowerTakedowns) == 0x000004, "Wrong alignment on OrionTeamInfo_GetTeamTowerTakedowns");
static_assert(sizeof(OrionTeamInfo_GetTeamTowerTakedowns) == 0x000004, "Wrong size on OrionTeamInfo_GetTeamTowerTakedowns");
static_assert(offsetof(OrionTeamInfo_GetTeamTowerTakedowns, ReturnValue) == 0x000000, "Member 'OrionTeamInfo_GetTeamTowerTakedowns::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTeamInfo.GetXPTrickleRate
// 0x0004 (0x0004 - 0x0000)
struct OrionTeamInfo_GetXPTrickleRate final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamInfo_GetXPTrickleRate) == 0x000004, "Wrong alignment on OrionTeamInfo_GetXPTrickleRate");
static_assert(sizeof(OrionTeamInfo_GetXPTrickleRate) == 0x000004, "Wrong size on OrionTeamInfo_GetXPTrickleRate");
static_assert(offsetof(OrionTeamInfo_GetXPTrickleRate, ReturnValue) == 0x000000, "Member 'OrionTeamInfo_GetXPTrickleRate::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTeamInfo.HasRoomForAPlayer
// 0x0001 (0x0001 - 0x0000)
struct OrionTeamInfo_HasRoomForAPlayer final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamInfo_HasRoomForAPlayer) == 0x000001, "Wrong alignment on OrionTeamInfo_HasRoomForAPlayer");
static_assert(sizeof(OrionTeamInfo_HasRoomForAPlayer) == 0x000001, "Wrong size on OrionTeamInfo_HasRoomForAPlayer");
static_assert(offsetof(OrionTeamInfo_HasRoomForAPlayer, ReturnValue) == 0x000000, "Member 'OrionTeamInfo_HasRoomForAPlayer::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTeamInfo.IsPlayerTeam
// 0x0001 (0x0001 - 0x0000)
struct OrionTeamInfo_IsPlayerTeam final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTeamInfo_IsPlayerTeam) == 0x000001, "Wrong alignment on OrionTeamInfo_IsPlayerTeam");
static_assert(sizeof(OrionTeamInfo_IsPlayerTeam) == 0x000001, "Wrong size on OrionTeamInfo_IsPlayerTeam");
static_assert(offsetof(OrionTeamInfo_IsPlayerTeam, ReturnValue) == 0x000000, "Member 'OrionTeamInfo_IsPlayerTeam::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTextStyle.GetColor
// 0x0014 (0x0014 - 0x0000)
struct OrionTextStyle_GetColor final
{
public:
	EOrionTextColor                               ColorType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           OutColor;                                          // 0x0004(0x0010)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTextStyle_GetColor) == 0x000004, "Wrong alignment on OrionTextStyle_GetColor");
static_assert(sizeof(OrionTextStyle_GetColor) == 0x000014, "Wrong size on OrionTextStyle_GetColor");
static_assert(offsetof(OrionTextStyle_GetColor, ColorType) == 0x000000, "Member 'OrionTextStyle_GetColor::ColorType' has a wrong offset!");
static_assert(offsetof(OrionTextStyle_GetColor, OutColor) == 0x000004, "Member 'OrionTextStyle_GetColor::OutColor' has a wrong offset!");

// Function OrionGame.OrionTextStyle.GetFont
// 0x0060 (0x0060 - 0x0000)
struct OrionTextStyle_GetFont final
{
public:
	EOrionWidgetStyleSize                         Size;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateFontInfo                         OutFont;                                           // 0x0008(0x0058)(Parm, OutParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTextStyle_GetFont) == 0x000008, "Wrong alignment on OrionTextStyle_GetFont");
static_assert(sizeof(OrionTextStyle_GetFont) == 0x000060, "Wrong size on OrionTextStyle_GetFont");
static_assert(offsetof(OrionTextStyle_GetFont, Size) == 0x000000, "Member 'OrionTextStyle_GetFont::Size' has a wrong offset!");
static_assert(offsetof(OrionTextStyle_GetFont, OutFont) == 0x000008, "Member 'OrionTextStyle_GetFont::OutFont' has a wrong offset!");

// Function OrionGame.OrionTextStyle.GetLineHeightPercentage
// 0x0008 (0x0008 - 0x0000)
struct OrionTextStyle_GetLineHeightPercentage final
{
public:
	EOrionWidgetStyleSize                         Size;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTextStyle_GetLineHeightPercentage) == 0x000004, "Wrong alignment on OrionTextStyle_GetLineHeightPercentage");
static_assert(sizeof(OrionTextStyle_GetLineHeightPercentage) == 0x000008, "Wrong size on OrionTextStyle_GetLineHeightPercentage");
static_assert(offsetof(OrionTextStyle_GetLineHeightPercentage, Size) == 0x000000, "Member 'OrionTextStyle_GetLineHeightPercentage::Size' has a wrong offset!");
static_assert(offsetof(OrionTextStyle_GetLineHeightPercentage, ReturnValue) == 0x000004, "Member 'OrionTextStyle_GetLineHeightPercentage::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTextStyle.GetMargin
// 0x0014 (0x0014 - 0x0000)
struct OrionTextStyle_GetMargin final
{
public:
	EOrionWidgetStyleSize                         Size;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMargin                                OutMargin;                                         // 0x0004(0x0010)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTextStyle_GetMargin) == 0x000004, "Wrong alignment on OrionTextStyle_GetMargin");
static_assert(sizeof(OrionTextStyle_GetMargin) == 0x000014, "Wrong size on OrionTextStyle_GetMargin");
static_assert(offsetof(OrionTextStyle_GetMargin, Size) == 0x000000, "Member 'OrionTextStyle_GetMargin::Size' has a wrong offset!");
static_assert(offsetof(OrionTextStyle_GetMargin, OutMargin) == 0x000004, "Member 'OrionTextStyle_GetMargin::OutMargin' has a wrong offset!");

// Function OrionGame.OrionTextStyle.GetShadowColor
// 0x0014 (0x0014 - 0x0000)
struct OrionTextStyle_GetShadowColor final
{
public:
	EOrionTextColor                               ColorType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           OutColor;                                          // 0x0004(0x0010)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTextStyle_GetShadowColor) == 0x000004, "Wrong alignment on OrionTextStyle_GetShadowColor");
static_assert(sizeof(OrionTextStyle_GetShadowColor) == 0x000014, "Wrong size on OrionTextStyle_GetShadowColor");
static_assert(offsetof(OrionTextStyle_GetShadowColor, ColorType) == 0x000000, "Member 'OrionTextStyle_GetShadowColor::ColorType' has a wrong offset!");
static_assert(offsetof(OrionTextStyle_GetShadowColor, OutColor) == 0x000004, "Member 'OrionTextStyle_GetShadowColor::OutColor' has a wrong offset!");

// Function OrionGame.OrionTextStyle.GetShadowOffset
// 0x000C (0x000C - 0x0000)
struct OrionTextStyle_GetShadowOffset final
{
public:
	EOrionWidgetStyleSize                         Size;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              OutShadowOffset;                                   // 0x0004(0x0008)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTextStyle_GetShadowOffset) == 0x000004, "Wrong alignment on OrionTextStyle_GetShadowOffset");
static_assert(sizeof(OrionTextStyle_GetShadowOffset) == 0x00000C, "Wrong size on OrionTextStyle_GetShadowOffset");
static_assert(offsetof(OrionTextStyle_GetShadowOffset, Size) == 0x000000, "Member 'OrionTextStyle_GetShadowOffset::Size' has a wrong offset!");
static_assert(offsetof(OrionTextStyle_GetShadowOffset, OutShadowOffset) == 0x000004, "Member 'OrionTextStyle_GetShadowOffset::OutShadowOffset' has a wrong offset!");

// Function OrionGame.OrionTextBlock.SetColorType
// 0x0001 (0x0001 - 0x0000)
struct OrionTextBlock_SetColorType final
{
public:
	EOrionTextColor                               Color;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTextBlock_SetColorType) == 0x000001, "Wrong alignment on OrionTextBlock_SetColorType");
static_assert(sizeof(OrionTextBlock_SetColorType) == 0x000001, "Wrong size on OrionTextBlock_SetColorType");
static_assert(offsetof(OrionTextBlock_SetColorType, Color) == 0x000000, "Member 'OrionTextBlock_SetColorType::Color' has a wrong offset!");

// Function OrionGame.OrionTextBlock.SetProperties
// 0x0018 (0x0018 - 0x0000)
struct OrionTextBlock_SetProperties final
{
public:
	TSubclassOf<class UOrionTextStyle>            InStyle;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionWidgetStyleSize                         Size;                                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTextColor                               Color;                                             // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InWrapTextAt;                                      // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldUseDropShadow;                              // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionTextBlock_SetProperties) == 0x000008, "Wrong alignment on OrionTextBlock_SetProperties");
static_assert(sizeof(OrionTextBlock_SetProperties) == 0x000018, "Wrong size on OrionTextBlock_SetProperties");
static_assert(offsetof(OrionTextBlock_SetProperties, InStyle) == 0x000000, "Member 'OrionTextBlock_SetProperties::InStyle' has a wrong offset!");
static_assert(offsetof(OrionTextBlock_SetProperties, Size) == 0x000008, "Member 'OrionTextBlock_SetProperties::Size' has a wrong offset!");
static_assert(offsetof(OrionTextBlock_SetProperties, Color) == 0x000009, "Member 'OrionTextBlock_SetProperties::Color' has a wrong offset!");
static_assert(offsetof(OrionTextBlock_SetProperties, InWrapTextAt) == 0x00000C, "Member 'OrionTextBlock_SetProperties::InWrapTextAt' has a wrong offset!");
static_assert(offsetof(OrionTextBlock_SetProperties, bShouldUseDropShadow) == 0x000010, "Member 'OrionTextBlock_SetProperties::bShouldUseDropShadow' has a wrong offset!");

// Function OrionGame.OrionTextBlock.SetSize
// 0x0001 (0x0001 - 0x0000)
struct OrionTextBlock_SetSize final
{
public:
	EOrionWidgetStyleSize                         Size;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTextBlock_SetSize) == 0x000001, "Wrong alignment on OrionTextBlock_SetSize");
static_assert(sizeof(OrionTextBlock_SetSize) == 0x000001, "Wrong size on OrionTextBlock_SetSize");
static_assert(offsetof(OrionTextBlock_SetSize, Size) == 0x000000, "Member 'OrionTextBlock_SetSize::Size' has a wrong offset!");

// Function OrionGame.OrionTextBlock.SetStyle
// 0x0008 (0x0008 - 0x0000)
struct OrionTextBlock_SetStyle final
{
public:
	TSubclassOf<class UOrionTextStyle>            InStyle;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTextBlock_SetStyle) == 0x000008, "Wrong alignment on OrionTextBlock_SetStyle");
static_assert(sizeof(OrionTextBlock_SetStyle) == 0x000008, "Wrong size on OrionTextBlock_SetStyle");
static_assert(offsetof(OrionTextBlock_SetStyle, InStyle) == 0x000000, "Member 'OrionTextBlock_SetStyle::InStyle' has a wrong offset!");

// Function OrionGame.OrionTextBlock.SetUseDropShadow
// 0x0001 (0x0001 - 0x0000)
struct OrionTextBlock_SetUseDropShadow final
{
public:
	bool                                          bShouldUseDropShadow;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTextBlock_SetUseDropShadow) == 0x000001, "Wrong alignment on OrionTextBlock_SetUseDropShadow");
static_assert(sizeof(OrionTextBlock_SetUseDropShadow) == 0x000001, "Wrong size on OrionTextBlock_SetUseDropShadow");
static_assert(offsetof(OrionTextBlock_SetUseDropShadow, bShouldUseDropShadow) == 0x000000, "Member 'OrionTextBlock_SetUseDropShadow::bShouldUseDropShadow' has a wrong offset!");

// Function OrionGame.OrionTextBlock.SetWrapTextWidth
// 0x0004 (0x0004 - 0x0000)
struct OrionTextBlock_SetWrapTextWidth final
{
public:
	int32                                         InWrapTextAt;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTextBlock_SetWrapTextWidth) == 0x000004, "Wrong alignment on OrionTextBlock_SetWrapTextWidth");
static_assert(sizeof(OrionTextBlock_SetWrapTextWidth) == 0x000004, "Wrong size on OrionTextBlock_SetWrapTextWidth");
static_assert(offsetof(OrionTextBlock_SetWrapTextWidth, InWrapTextAt) == 0x000000, "Member 'OrionTextBlock_SetWrapTextWidth::InWrapTextAt' has a wrong offset!");

// Function OrionGame.OrionTooltipAnchor.BasicTooltip
// 0x0038 (0x0038 - 0x0000)
struct OrionTooltipAnchor_BasicTooltip final
{
public:
	class FText                                   Title;                                             // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   Body;                                              // 0x0018(0x0018)(Parm, NativeAccessSpecifierPublic)
	class UOrionBasicTooltipWidget*               ReturnValue;                                       // 0x0030(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTooltipAnchor_BasicTooltip) == 0x000008, "Wrong alignment on OrionTooltipAnchor_BasicTooltip");
static_assert(sizeof(OrionTooltipAnchor_BasicTooltip) == 0x000038, "Wrong size on OrionTooltipAnchor_BasicTooltip");
static_assert(offsetof(OrionTooltipAnchor_BasicTooltip, Title) == 0x000000, "Member 'OrionTooltipAnchor_BasicTooltip::Title' has a wrong offset!");
static_assert(offsetof(OrionTooltipAnchor_BasicTooltip, Body) == 0x000018, "Member 'OrionTooltipAnchor_BasicTooltip::Body' has a wrong offset!");
static_assert(offsetof(OrionTooltipAnchor_BasicTooltip, ReturnValue) == 0x000030, "Member 'OrionTooltipAnchor_BasicTooltip::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTraversablePathway.CheckPathPointsRange
// 0x0018 (0x0018 - 0x0000)
struct OrionTraversablePathway_CheckPathPointsRange final
{
public:
	class AActor*                                 SourceActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CheckLocation;                                     // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionTraversablePathway_CheckPathPointsRange) == 0x000008, "Wrong alignment on OrionTraversablePathway_CheckPathPointsRange");
static_assert(sizeof(OrionTraversablePathway_CheckPathPointsRange) == 0x000018, "Wrong size on OrionTraversablePathway_CheckPathPointsRange");
static_assert(offsetof(OrionTraversablePathway_CheckPathPointsRange, SourceActor) == 0x000000, "Member 'OrionTraversablePathway_CheckPathPointsRange::SourceActor' has a wrong offset!");
static_assert(offsetof(OrionTraversablePathway_CheckPathPointsRange, CheckLocation) == 0x000008, "Member 'OrionTraversablePathway_CheckPathPointsRange::CheckLocation' has a wrong offset!");

// Function OrionGame.OrionTraversablePathway.CreateDebugTraversablePathway
// 0x0018 (0x0018 - 0x0000)
struct OrionTraversablePathway_CreateDebugTraversablePathway final
{
public:
	struct FVector                                PathStart;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PathEnd;                                           // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTraversablePathway_CreateDebugTraversablePathway) == 0x000004, "Wrong alignment on OrionTraversablePathway_CreateDebugTraversablePathway");
static_assert(sizeof(OrionTraversablePathway_CreateDebugTraversablePathway) == 0x000018, "Wrong size on OrionTraversablePathway_CreateDebugTraversablePathway");
static_assert(offsetof(OrionTraversablePathway_CreateDebugTraversablePathway, PathStart) == 0x000000, "Member 'OrionTraversablePathway_CreateDebugTraversablePathway::PathStart' has a wrong offset!");
static_assert(offsetof(OrionTraversablePathway_CreateDebugTraversablePathway, PathEnd) == 0x00000C, "Member 'OrionTraversablePathway_CreateDebugTraversablePathway::PathEnd' has a wrong offset!");

// Function OrionGame.OrionTraversablePathway.GetBreadCrumpActor
// 0x0008 (0x0008 - 0x0000)
struct OrionTraversablePathway_GetBreadCrumpActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTraversablePathway_GetBreadCrumpActor) == 0x000008, "Wrong alignment on OrionTraversablePathway_GetBreadCrumpActor");
static_assert(sizeof(OrionTraversablePathway_GetBreadCrumpActor) == 0x000008, "Wrong size on OrionTraversablePathway_GetBreadCrumpActor");
static_assert(offsetof(OrionTraversablePathway_GetBreadCrumpActor, ReturnValue) == 0x000000, "Member 'OrionTraversablePathway_GetBreadCrumpActor::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTraversablePathway.GetEvenlySpacedPointsFromPointArray
// 0x0010 (0x0010 - 0x0000)
struct OrionTraversablePathway_GetEvenlySpacedPointsFromPointArray final
{
public:
	TArray<struct FEvenlySpacedPoint>             ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTraversablePathway_GetEvenlySpacedPointsFromPointArray) == 0x000008, "Wrong alignment on OrionTraversablePathway_GetEvenlySpacedPointsFromPointArray");
static_assert(sizeof(OrionTraversablePathway_GetEvenlySpacedPointsFromPointArray) == 0x000010, "Wrong size on OrionTraversablePathway_GetEvenlySpacedPointsFromPointArray");
static_assert(offsetof(OrionTraversablePathway_GetEvenlySpacedPointsFromPointArray, ReturnValue) == 0x000000, "Member 'OrionTraversablePathway_GetEvenlySpacedPointsFromPointArray::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionTraversablePathway.OnAddedEvenlySpacedPoint
// 0x0004 (0x0004 - 0x0000)
struct OrionTraversablePathway_OnAddedEvenlySpacedPoint final
{
public:
	int32                                         ArrayIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTraversablePathway_OnAddedEvenlySpacedPoint) == 0x000004, "Wrong alignment on OrionTraversablePathway_OnAddedEvenlySpacedPoint");
static_assert(sizeof(OrionTraversablePathway_OnAddedEvenlySpacedPoint) == 0x000004, "Wrong size on OrionTraversablePathway_OnAddedEvenlySpacedPoint");
static_assert(offsetof(OrionTraversablePathway_OnAddedEvenlySpacedPoint, ArrayIndex) == 0x000000, "Member 'OrionTraversablePathway_OnAddedEvenlySpacedPoint::ArrayIndex' has a wrong offset!");

// Function OrionGame.OrionTraversablePathway.OnFirstEvenlySpacedPointChanged
// 0x0008 (0x0008 - 0x0000)
struct OrionTraversablePathway_OnFirstEvenlySpacedPointChanged final
{
public:
	int32                                         PrevFirstEvenlySpacedPointIndex;                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewFirstEvenlySpacedPointIndex;                    // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTraversablePathway_OnFirstEvenlySpacedPointChanged) == 0x000004, "Wrong alignment on OrionTraversablePathway_OnFirstEvenlySpacedPointChanged");
static_assert(sizeof(OrionTraversablePathway_OnFirstEvenlySpacedPointChanged) == 0x000008, "Wrong size on OrionTraversablePathway_OnFirstEvenlySpacedPointChanged");
static_assert(offsetof(OrionTraversablePathway_OnFirstEvenlySpacedPointChanged, PrevFirstEvenlySpacedPointIndex) == 0x000000, "Member 'OrionTraversablePathway_OnFirstEvenlySpacedPointChanged::PrevFirstEvenlySpacedPointIndex' has a wrong offset!");
static_assert(offsetof(OrionTraversablePathway_OnFirstEvenlySpacedPointChanged, NewFirstEvenlySpacedPointIndex) == 0x000004, "Member 'OrionTraversablePathway_OnFirstEvenlySpacedPointChanged::NewFirstEvenlySpacedPointIndex' has a wrong offset!");

// Function OrionGame.OrionTraversablePathway.OnLastEvenlySpacedPointChanged
// 0x0008 (0x0008 - 0x0000)
struct OrionTraversablePathway_OnLastEvenlySpacedPointChanged final
{
public:
	int32                                         PrevLastEvenlySpacedPointIndex;                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewLastEvenlySpacedPointIndex;                     // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTraversablePathway_OnLastEvenlySpacedPointChanged) == 0x000004, "Wrong alignment on OrionTraversablePathway_OnLastEvenlySpacedPointChanged");
static_assert(sizeof(OrionTraversablePathway_OnLastEvenlySpacedPointChanged) == 0x000008, "Wrong size on OrionTraversablePathway_OnLastEvenlySpacedPointChanged");
static_assert(offsetof(OrionTraversablePathway_OnLastEvenlySpacedPointChanged, PrevLastEvenlySpacedPointIndex) == 0x000000, "Member 'OrionTraversablePathway_OnLastEvenlySpacedPointChanged::PrevLastEvenlySpacedPointIndex' has a wrong offset!");
static_assert(offsetof(OrionTraversablePathway_OnLastEvenlySpacedPointChanged, NewLastEvenlySpacedPointIndex) == 0x000004, "Member 'OrionTraversablePathway_OnLastEvenlySpacedPointChanged::NewLastEvenlySpacedPointIndex' has a wrong offset!");

// Function OrionGame.OrionTraversablePathway.OnSourceInRange
// 0x0008 (0x0008 - 0x0000)
struct OrionTraversablePathway_OnSourceInRange final
{
public:
	class AActor*                                 SourceActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTraversablePathway_OnSourceInRange) == 0x000008, "Wrong alignment on OrionTraversablePathway_OnSourceInRange");
static_assert(sizeof(OrionTraversablePathway_OnSourceInRange) == 0x000008, "Wrong size on OrionTraversablePathway_OnSourceInRange");
static_assert(offsetof(OrionTraversablePathway_OnSourceInRange, SourceActor) == 0x000000, "Member 'OrionTraversablePathway_OnSourceInRange::SourceActor' has a wrong offset!");

// Function OrionGame.OrionTraversablePathway.OnSourceOutOfRange
// 0x0008 (0x0008 - 0x0000)
struct OrionTraversablePathway_OnSourceOutOfRange final
{
public:
	class AActor*                                 SourceActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionTraversablePathway_OnSourceOutOfRange) == 0x000008, "Wrong alignment on OrionTraversablePathway_OnSourceOutOfRange");
static_assert(sizeof(OrionTraversablePathway_OnSourceOutOfRange) == 0x000008, "Wrong size on OrionTraversablePathway_OnSourceOutOfRange");
static_assert(offsetof(OrionTraversablePathway_OnSourceOutOfRange, SourceActor) == 0x000000, "Member 'OrionTraversablePathway_OnSourceOutOfRange::SourceActor' has a wrong offset!");

// Function OrionGame.OrionUIBlueprintLibrary.Contains_OrionAffinityStruct
// 0x000C (0x000C - 0x0000)
struct OrionUIBlueprintLibrary_Contains_OrionAffinityStruct final
{
public:
	struct FOrionAffinityStruct                   Authority;                                         // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FOrionAffinityStruct                   Test;                                              // 0x0004(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionUIBlueprintLibrary_Contains_OrionAffinityStruct) == 0x000004, "Wrong alignment on OrionUIBlueprintLibrary_Contains_OrionAffinityStruct");
static_assert(sizeof(OrionUIBlueprintLibrary_Contains_OrionAffinityStruct) == 0x00000C, "Wrong size on OrionUIBlueprintLibrary_Contains_OrionAffinityStruct");
static_assert(offsetof(OrionUIBlueprintLibrary_Contains_OrionAffinityStruct, Authority) == 0x000000, "Member 'OrionUIBlueprintLibrary_Contains_OrionAffinityStruct::Authority' has a wrong offset!");
static_assert(offsetof(OrionUIBlueprintLibrary_Contains_OrionAffinityStruct, Test) == 0x000004, "Member 'OrionUIBlueprintLibrary_Contains_OrionAffinityStruct::Test' has a wrong offset!");
static_assert(offsetof(OrionUIBlueprintLibrary_Contains_OrionAffinityStruct, ReturnValue) == 0x000008, "Member 'OrionUIBlueprintLibrary_Contains_OrionAffinityStruct::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUIBlueprintLibrary.CopyToClipboard
// 0x0010 (0x0010 - 0x0000)
struct OrionUIBlueprintLibrary_CopyToClipboard final
{
public:
	class FString                                 ClipboardText;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIBlueprintLibrary_CopyToClipboard) == 0x000008, "Wrong alignment on OrionUIBlueprintLibrary_CopyToClipboard");
static_assert(sizeof(OrionUIBlueprintLibrary_CopyToClipboard) == 0x000010, "Wrong size on OrionUIBlueprintLibrary_CopyToClipboard");
static_assert(offsetof(OrionUIBlueprintLibrary_CopyToClipboard, ClipboardText) == 0x000000, "Member 'OrionUIBlueprintLibrary_CopyToClipboard::ClipboardText' has a wrong offset!");

// Function OrionGame.OrionUIBlueprintLibrary.EqualEqual_OrionPlayerStateUIID
// 0x0058 (0x0058 - 0x0000)
struct OrionUIBlueprintLibrary_EqualEqual_OrionPlayerStateUIID final
{
public:
	struct FOrionPlayerStateUIID                  A;                                                 // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FOrionPlayerStateUIID                  B;                                                 // 0x0028(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0050(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionUIBlueprintLibrary_EqualEqual_OrionPlayerStateUIID) == 0x000008, "Wrong alignment on OrionUIBlueprintLibrary_EqualEqual_OrionPlayerStateUIID");
static_assert(sizeof(OrionUIBlueprintLibrary_EqualEqual_OrionPlayerStateUIID) == 0x000058, "Wrong size on OrionUIBlueprintLibrary_EqualEqual_OrionPlayerStateUIID");
static_assert(offsetof(OrionUIBlueprintLibrary_EqualEqual_OrionPlayerStateUIID, A) == 0x000000, "Member 'OrionUIBlueprintLibrary_EqualEqual_OrionPlayerStateUIID::A' has a wrong offset!");
static_assert(offsetof(OrionUIBlueprintLibrary_EqualEqual_OrionPlayerStateUIID, B) == 0x000028, "Member 'OrionUIBlueprintLibrary_EqualEqual_OrionPlayerStateUIID::B' has a wrong offset!");
static_assert(offsetof(OrionUIBlueprintLibrary_EqualEqual_OrionPlayerStateUIID, ReturnValue) == 0x000050, "Member 'OrionUIBlueprintLibrary_EqualEqual_OrionPlayerStateUIID::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUIBlueprintLibrary.GetAvailableLanguages
// 0x0010 (0x0010 - 0x0000)
struct OrionUIBlueprintLibrary_GetAvailableLanguages final
{
public:
	TArray<class FString>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIBlueprintLibrary_GetAvailableLanguages) == 0x000008, "Wrong alignment on OrionUIBlueprintLibrary_GetAvailableLanguages");
static_assert(sizeof(OrionUIBlueprintLibrary_GetAvailableLanguages) == 0x000010, "Wrong size on OrionUIBlueprintLibrary_GetAvailableLanguages");
static_assert(offsetof(OrionUIBlueprintLibrary_GetAvailableLanguages, ReturnValue) == 0x000000, "Member 'OrionUIBlueprintLibrary_GetAvailableLanguages::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUIBlueprintLibrary.GetCleanOffset
// 0x0010 (0x0010 - 0x0000)
struct OrionUIBlueprintLibrary_GetCleanOffset final
{
public:
	struct FVector2D                              InVec;                                             // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIBlueprintLibrary_GetCleanOffset) == 0x000004, "Wrong alignment on OrionUIBlueprintLibrary_GetCleanOffset");
static_assert(sizeof(OrionUIBlueprintLibrary_GetCleanOffset) == 0x000010, "Wrong size on OrionUIBlueprintLibrary_GetCleanOffset");
static_assert(offsetof(OrionUIBlueprintLibrary_GetCleanOffset, InVec) == 0x000000, "Member 'OrionUIBlueprintLibrary_GetCleanOffset::InVec' has a wrong offset!");
static_assert(offsetof(OrionUIBlueprintLibrary_GetCleanOffset, ReturnValue) == 0x000008, "Member 'OrionUIBlueprintLibrary_GetCleanOffset::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUIBlueprintLibrary.GetCurrentLanguageCode
// 0x0010 (0x0010 - 0x0000)
struct OrionUIBlueprintLibrary_GetCurrentLanguageCode final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIBlueprintLibrary_GetCurrentLanguageCode) == 0x000008, "Wrong alignment on OrionUIBlueprintLibrary_GetCurrentLanguageCode");
static_assert(sizeof(OrionUIBlueprintLibrary_GetCurrentLanguageCode) == 0x000010, "Wrong size on OrionUIBlueprintLibrary_GetCurrentLanguageCode");
static_assert(offsetof(OrionUIBlueprintLibrary_GetCurrentLanguageCode, ReturnValue) == 0x000000, "Member 'OrionUIBlueprintLibrary_GetCurrentLanguageCode::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUIBlueprintLibrary.GetCurrentMaterialTime
// 0x0004 (0x0004 - 0x0000)
struct OrionUIBlueprintLibrary_GetCurrentMaterialTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIBlueprintLibrary_GetCurrentMaterialTime) == 0x000004, "Wrong alignment on OrionUIBlueprintLibrary_GetCurrentMaterialTime");
static_assert(sizeof(OrionUIBlueprintLibrary_GetCurrentMaterialTime) == 0x000004, "Wrong size on OrionUIBlueprintLibrary_GetCurrentMaterialTime");
static_assert(offsetof(OrionUIBlueprintLibrary_GetCurrentMaterialTime, ReturnValue) == 0x000000, "Member 'OrionUIBlueprintLibrary_GetCurrentMaterialTime::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUIBlueprintLibrary.GetHealthPipValue
// 0x0004 (0x0004 - 0x0000)
struct OrionUIBlueprintLibrary_GetHealthPipValue final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIBlueprintLibrary_GetHealthPipValue) == 0x000004, "Wrong alignment on OrionUIBlueprintLibrary_GetHealthPipValue");
static_assert(sizeof(OrionUIBlueprintLibrary_GetHealthPipValue) == 0x000004, "Wrong size on OrionUIBlueprintLibrary_GetHealthPipValue");
static_assert(offsetof(OrionUIBlueprintLibrary_GetHealthPipValue, ReturnValue) == 0x000000, "Member 'OrionUIBlueprintLibrary_GetHealthPipValue::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUIBlueprintLibrary.GetHeroesForWelcomeScreen
// 0x0010 (0x0010 - 0x0000)
struct OrionUIBlueprintLibrary_GetHeroesForWelcomeScreen final
{
public:
	TArray<class UOrionHeroData*>                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIBlueprintLibrary_GetHeroesForWelcomeScreen) == 0x000008, "Wrong alignment on OrionUIBlueprintLibrary_GetHeroesForWelcomeScreen");
static_assert(sizeof(OrionUIBlueprintLibrary_GetHeroesForWelcomeScreen) == 0x000010, "Wrong size on OrionUIBlueprintLibrary_GetHeroesForWelcomeScreen");
static_assert(offsetof(OrionUIBlueprintLibrary_GetHeroesForWelcomeScreen, ReturnValue) == 0x000000, "Member 'OrionUIBlueprintLibrary_GetHeroesForWelcomeScreen::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUIBlueprintLibrary.GetLanguageDisplayName
// 0x0020 (0x0020 - 0x0000)
struct OrionUIBlueprintLibrary_GetLanguageDisplayName final
{
public:
	class FString                                 LanguageCode;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIBlueprintLibrary_GetLanguageDisplayName) == 0x000008, "Wrong alignment on OrionUIBlueprintLibrary_GetLanguageDisplayName");
static_assert(sizeof(OrionUIBlueprintLibrary_GetLanguageDisplayName) == 0x000020, "Wrong size on OrionUIBlueprintLibrary_GetLanguageDisplayName");
static_assert(offsetof(OrionUIBlueprintLibrary_GetLanguageDisplayName, LanguageCode) == 0x000000, "Member 'OrionUIBlueprintLibrary_GetLanguageDisplayName::LanguageCode' has a wrong offset!");
static_assert(offsetof(OrionUIBlueprintLibrary_GetLanguageDisplayName, ReturnValue) == 0x000010, "Member 'OrionUIBlueprintLibrary_GetLanguageDisplayName::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUIBlueprintLibrary.GetSegmentAngles
// 0x0010 (0x0010 - 0x0000)
struct OrionUIBlueprintLibrary_GetSegmentAngles final
{
public:
	float                                         Center;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WedgeSize;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Min;                                               // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIBlueprintLibrary_GetSegmentAngles) == 0x000004, "Wrong alignment on OrionUIBlueprintLibrary_GetSegmentAngles");
static_assert(sizeof(OrionUIBlueprintLibrary_GetSegmentAngles) == 0x000010, "Wrong size on OrionUIBlueprintLibrary_GetSegmentAngles");
static_assert(offsetof(OrionUIBlueprintLibrary_GetSegmentAngles, Center) == 0x000000, "Member 'OrionUIBlueprintLibrary_GetSegmentAngles::Center' has a wrong offset!");
static_assert(offsetof(OrionUIBlueprintLibrary_GetSegmentAngles, WedgeSize) == 0x000004, "Member 'OrionUIBlueprintLibrary_GetSegmentAngles::WedgeSize' has a wrong offset!");
static_assert(offsetof(OrionUIBlueprintLibrary_GetSegmentAngles, Min) == 0x000008, "Member 'OrionUIBlueprintLibrary_GetSegmentAngles::Min' has a wrong offset!");
static_assert(offsetof(OrionUIBlueprintLibrary_GetSegmentAngles, Max) == 0x00000C, "Member 'OrionUIBlueprintLibrary_GetSegmentAngles::Max' has a wrong offset!");

// Function OrionGame.OrionUIBlueprintLibrary.GetStoreOfferFrom
// 0x0138 (0x0138 - 0x0000)
struct OrionUIBlueprintLibrary_GetStoreOfferFrom final
{
public:
	class UObject*                                Source;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStoreOfferBP                          Result;                                            // 0x0008(0x0130)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIBlueprintLibrary_GetStoreOfferFrom) == 0x000008, "Wrong alignment on OrionUIBlueprintLibrary_GetStoreOfferFrom");
static_assert(sizeof(OrionUIBlueprintLibrary_GetStoreOfferFrom) == 0x000138, "Wrong size on OrionUIBlueprintLibrary_GetStoreOfferFrom");
static_assert(offsetof(OrionUIBlueprintLibrary_GetStoreOfferFrom, Source) == 0x000000, "Member 'OrionUIBlueprintLibrary_GetStoreOfferFrom::Source' has a wrong offset!");
static_assert(offsetof(OrionUIBlueprintLibrary_GetStoreOfferFrom, Result) == 0x000008, "Member 'OrionUIBlueprintLibrary_GetStoreOfferFrom::Result' has a wrong offset!");

// Function OrionGame.OrionUIBlueprintLibrary.GetTimespanAsSimpleText
// 0x0020 (0x0020 - 0x0000)
struct OrionUIBlueprintLibrary_GetTimespanAsSimpleText final
{
public:
	struct FTimespan                              Timespan;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0008(0x0018)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIBlueprintLibrary_GetTimespanAsSimpleText) == 0x000008, "Wrong alignment on OrionUIBlueprintLibrary_GetTimespanAsSimpleText");
static_assert(sizeof(OrionUIBlueprintLibrary_GetTimespanAsSimpleText) == 0x000020, "Wrong size on OrionUIBlueprintLibrary_GetTimespanAsSimpleText");
static_assert(offsetof(OrionUIBlueprintLibrary_GetTimespanAsSimpleText, Timespan) == 0x000000, "Member 'OrionUIBlueprintLibrary_GetTimespanAsSimpleText::Timespan' has a wrong offset!");
static_assert(offsetof(OrionUIBlueprintLibrary_GetTimespanAsSimpleText, Text) == 0x000008, "Member 'OrionUIBlueprintLibrary_GetTimespanAsSimpleText::Text' has a wrong offset!");

// Function OrionGame.OrionUIBlueprintLibrary.GetTwoLetterLanguageCode
// 0x0010 (0x0010 - 0x0000)
struct OrionUIBlueprintLibrary_GetTwoLetterLanguageCode final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIBlueprintLibrary_GetTwoLetterLanguageCode) == 0x000008, "Wrong alignment on OrionUIBlueprintLibrary_GetTwoLetterLanguageCode");
static_assert(sizeof(OrionUIBlueprintLibrary_GetTwoLetterLanguageCode) == 0x000010, "Wrong size on OrionUIBlueprintLibrary_GetTwoLetterLanguageCode");
static_assert(offsetof(OrionUIBlueprintLibrary_GetTwoLetterLanguageCode, ReturnValue) == 0x000000, "Member 'OrionUIBlueprintLibrary_GetTwoLetterLanguageCode::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUIBlueprintLibrary.HasCommandLineParameter
// 0x0018 (0x0018 - 0x0000)
struct OrionUIBlueprintLibrary_HasCommandLineParameter final
{
public:
	class FString                                 CommandLine;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionUIBlueprintLibrary_HasCommandLineParameter) == 0x000008, "Wrong alignment on OrionUIBlueprintLibrary_HasCommandLineParameter");
static_assert(sizeof(OrionUIBlueprintLibrary_HasCommandLineParameter) == 0x000018, "Wrong size on OrionUIBlueprintLibrary_HasCommandLineParameter");
static_assert(offsetof(OrionUIBlueprintLibrary_HasCommandLineParameter, CommandLine) == 0x000000, "Member 'OrionUIBlueprintLibrary_HasCommandLineParameter::CommandLine' has a wrong offset!");
static_assert(offsetof(OrionUIBlueprintLibrary_HasCommandLineParameter, ReturnValue) == 0x000010, "Member 'OrionUIBlueprintLibrary_HasCommandLineParameter::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUIBlueprintLibrary.IsConsoleBuild
// 0x0001 (0x0001 - 0x0000)
struct OrionUIBlueprintLibrary_IsConsoleBuild final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIBlueprintLibrary_IsConsoleBuild) == 0x000001, "Wrong alignment on OrionUIBlueprintLibrary_IsConsoleBuild");
static_assert(sizeof(OrionUIBlueprintLibrary_IsConsoleBuild) == 0x000001, "Wrong size on OrionUIBlueprintLibrary_IsConsoleBuild");
static_assert(offsetof(OrionUIBlueprintLibrary_IsConsoleBuild, ReturnValue) == 0x000000, "Member 'OrionUIBlueprintLibrary_IsConsoleBuild::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUIBlueprintLibrary.IsConsoleOpen
// 0x0001 (0x0001 - 0x0000)
struct OrionUIBlueprintLibrary_IsConsoleOpen final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIBlueprintLibrary_IsConsoleOpen) == 0x000001, "Wrong alignment on OrionUIBlueprintLibrary_IsConsoleOpen");
static_assert(sizeof(OrionUIBlueprintLibrary_IsConsoleOpen) == 0x000001, "Wrong size on OrionUIBlueprintLibrary_IsConsoleOpen");
static_assert(offsetof(OrionUIBlueprintLibrary_IsConsoleOpen, ReturnValue) == 0x000000, "Member 'OrionUIBlueprintLibrary_IsConsoleOpen::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUIBlueprintLibrary.IsDemoMode
// 0x0001 (0x0001 - 0x0000)
struct OrionUIBlueprintLibrary_IsDemoMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIBlueprintLibrary_IsDemoMode) == 0x000001, "Wrong alignment on OrionUIBlueprintLibrary_IsDemoMode");
static_assert(sizeof(OrionUIBlueprintLibrary_IsDemoMode) == 0x000001, "Wrong size on OrionUIBlueprintLibrary_IsDemoMode");
static_assert(offsetof(OrionUIBlueprintLibrary_IsDemoMode, ReturnValue) == 0x000000, "Member 'OrionUIBlueprintLibrary_IsDemoMode::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUIBlueprintLibrary.IsGeForceNowBuild
// 0x0001 (0x0001 - 0x0000)
struct OrionUIBlueprintLibrary_IsGeForceNowBuild final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIBlueprintLibrary_IsGeForceNowBuild) == 0x000001, "Wrong alignment on OrionUIBlueprintLibrary_IsGeForceNowBuild");
static_assert(sizeof(OrionUIBlueprintLibrary_IsGeForceNowBuild) == 0x000001, "Wrong size on OrionUIBlueprintLibrary_IsGeForceNowBuild");
static_assert(offsetof(OrionUIBlueprintLibrary_IsGeForceNowBuild, ReturnValue) == 0x000000, "Member 'OrionUIBlueprintLibrary_IsGeForceNowBuild::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUIBlueprintLibrary.IsInSegment
// 0x0010 (0x0010 - 0x0000)
struct OrionUIBlueprintLibrary_IsInSegment final
{
public:
	float                                         Center;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WedgeSize;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TestAngle;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionUIBlueprintLibrary_IsInSegment) == 0x000004, "Wrong alignment on OrionUIBlueprintLibrary_IsInSegment");
static_assert(sizeof(OrionUIBlueprintLibrary_IsInSegment) == 0x000010, "Wrong size on OrionUIBlueprintLibrary_IsInSegment");
static_assert(offsetof(OrionUIBlueprintLibrary_IsInSegment, Center) == 0x000000, "Member 'OrionUIBlueprintLibrary_IsInSegment::Center' has a wrong offset!");
static_assert(offsetof(OrionUIBlueprintLibrary_IsInSegment, WedgeSize) == 0x000004, "Member 'OrionUIBlueprintLibrary_IsInSegment::WedgeSize' has a wrong offset!");
static_assert(offsetof(OrionUIBlueprintLibrary_IsInSegment, TestAngle) == 0x000008, "Member 'OrionUIBlueprintLibrary_IsInSegment::TestAngle' has a wrong offset!");
static_assert(offsetof(OrionUIBlueprintLibrary_IsInSegment, ReturnValue) == 0x00000C, "Member 'OrionUIBlueprintLibrary_IsInSegment::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUIBlueprintLibrary.IsInWorld
// 0x0010 (0x0010 - 0x0000)
struct OrionUIBlueprintLibrary_IsInWorld final
{
public:
	class UObject*                                TestObject;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionUIBlueprintLibrary_IsInWorld) == 0x000008, "Wrong alignment on OrionUIBlueprintLibrary_IsInWorld");
static_assert(sizeof(OrionUIBlueprintLibrary_IsInWorld) == 0x000010, "Wrong size on OrionUIBlueprintLibrary_IsInWorld");
static_assert(offsetof(OrionUIBlueprintLibrary_IsInWorld, TestObject) == 0x000000, "Member 'OrionUIBlueprintLibrary_IsInWorld::TestObject' has a wrong offset!");
static_assert(offsetof(OrionUIBlueprintLibrary_IsInWorld, ReturnValue) == 0x000008, "Member 'OrionUIBlueprintLibrary_IsInWorld::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUIBlueprintLibrary.IsMTXPaymentAllowed
// 0x0001 (0x0001 - 0x0000)
struct OrionUIBlueprintLibrary_IsMTXPaymentAllowed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIBlueprintLibrary_IsMTXPaymentAllowed) == 0x000001, "Wrong alignment on OrionUIBlueprintLibrary_IsMTXPaymentAllowed");
static_assert(sizeof(OrionUIBlueprintLibrary_IsMTXPaymentAllowed) == 0x000001, "Wrong size on OrionUIBlueprintLibrary_IsMTXPaymentAllowed");
static_assert(offsetof(OrionUIBlueprintLibrary_IsMTXPaymentAllowed, ReturnValue) == 0x000000, "Member 'OrionUIBlueprintLibrary_IsMTXPaymentAllowed::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUIBlueprintLibrary.IsPS4Build
// 0x0001 (0x0001 - 0x0000)
struct OrionUIBlueprintLibrary_IsPS4Build final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIBlueprintLibrary_IsPS4Build) == 0x000001, "Wrong alignment on OrionUIBlueprintLibrary_IsPS4Build");
static_assert(sizeof(OrionUIBlueprintLibrary_IsPS4Build) == 0x000001, "Wrong size on OrionUIBlueprintLibrary_IsPS4Build");
static_assert(offsetof(OrionUIBlueprintLibrary_IsPS4Build, ReturnValue) == 0x000000, "Member 'OrionUIBlueprintLibrary_IsPS4Build::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUIBlueprintLibrary.IsTencentBuild
// 0x0001 (0x0001 - 0x0000)
struct OrionUIBlueprintLibrary_IsTencentBuild final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIBlueprintLibrary_IsTencentBuild) == 0x000001, "Wrong alignment on OrionUIBlueprintLibrary_IsTencentBuild");
static_assert(sizeof(OrionUIBlueprintLibrary_IsTencentBuild) == 0x000001, "Wrong size on OrionUIBlueprintLibrary_IsTencentBuild");
static_assert(offsetof(OrionUIBlueprintLibrary_IsTencentBuild, ReturnValue) == 0x000000, "Member 'OrionUIBlueprintLibrary_IsTencentBuild::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUIBlueprintLibrary.IsWIPUIEnabled
// 0x0001 (0x0001 - 0x0000)
struct OrionUIBlueprintLibrary_IsWIPUIEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIBlueprintLibrary_IsWIPUIEnabled) == 0x000001, "Wrong alignment on OrionUIBlueprintLibrary_IsWIPUIEnabled");
static_assert(sizeof(OrionUIBlueprintLibrary_IsWIPUIEnabled) == 0x000001, "Wrong size on OrionUIBlueprintLibrary_IsWIPUIEnabled");
static_assert(offsetof(OrionUIBlueprintLibrary_IsWIPUIEnabled, ReturnValue) == 0x000000, "Member 'OrionUIBlueprintLibrary_IsWIPUIEnabled::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUIBlueprintLibrary.NotEqual_OrionPlayerStateUIID
// 0x0058 (0x0058 - 0x0000)
struct OrionUIBlueprintLibrary_NotEqual_OrionPlayerStateUIID final
{
public:
	struct FOrionPlayerStateUIID                  A;                                                 // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FOrionPlayerStateUIID                  B;                                                 // 0x0028(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0050(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionUIBlueprintLibrary_NotEqual_OrionPlayerStateUIID) == 0x000008, "Wrong alignment on OrionUIBlueprintLibrary_NotEqual_OrionPlayerStateUIID");
static_assert(sizeof(OrionUIBlueprintLibrary_NotEqual_OrionPlayerStateUIID) == 0x000058, "Wrong size on OrionUIBlueprintLibrary_NotEqual_OrionPlayerStateUIID");
static_assert(offsetof(OrionUIBlueprintLibrary_NotEqual_OrionPlayerStateUIID, A) == 0x000000, "Member 'OrionUIBlueprintLibrary_NotEqual_OrionPlayerStateUIID::A' has a wrong offset!");
static_assert(offsetof(OrionUIBlueprintLibrary_NotEqual_OrionPlayerStateUIID, B) == 0x000028, "Member 'OrionUIBlueprintLibrary_NotEqual_OrionPlayerStateUIID::B' has a wrong offset!");
static_assert(offsetof(OrionUIBlueprintLibrary_NotEqual_OrionPlayerStateUIID, ReturnValue) == 0x000050, "Member 'OrionUIBlueprintLibrary_NotEqual_OrionPlayerStateUIID::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUIBlueprintLibrary.OrionAffinityStructToEnum
// 0x0008 (0x0008 - 0x0000)
struct OrionUIBlueprintLibrary_OrionAffinityStructToEnum final
{
public:
	struct FOrionAffinityStruct                   Authority;                                         // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	EAffinityType                                 First;                                             // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAffinityType                                 Second;                                            // 0x0005(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionUIBlueprintLibrary_OrionAffinityStructToEnum) == 0x000004, "Wrong alignment on OrionUIBlueprintLibrary_OrionAffinityStructToEnum");
static_assert(sizeof(OrionUIBlueprintLibrary_OrionAffinityStructToEnum) == 0x000008, "Wrong size on OrionUIBlueprintLibrary_OrionAffinityStructToEnum");
static_assert(offsetof(OrionUIBlueprintLibrary_OrionAffinityStructToEnum, Authority) == 0x000000, "Member 'OrionUIBlueprintLibrary_OrionAffinityStructToEnum::Authority' has a wrong offset!");
static_assert(offsetof(OrionUIBlueprintLibrary_OrionAffinityStructToEnum, First) == 0x000004, "Member 'OrionUIBlueprintLibrary_OrionAffinityStructToEnum::First' has a wrong offset!");
static_assert(offsetof(OrionUIBlueprintLibrary_OrionAffinityStructToEnum, Second) == 0x000005, "Member 'OrionUIBlueprintLibrary_OrionAffinityStructToEnum::Second' has a wrong offset!");

// Function OrionGame.OrionUIBlueprintLibrary.OrionLaunchURL
// 0x0018 (0x0018 - 0x0000)
struct OrionUIBlueprintLibrary_OrionLaunchURL final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 URL;                                               // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIBlueprintLibrary_OrionLaunchURL) == 0x000008, "Wrong alignment on OrionUIBlueprintLibrary_OrionLaunchURL");
static_assert(sizeof(OrionUIBlueprintLibrary_OrionLaunchURL) == 0x000018, "Wrong size on OrionUIBlueprintLibrary_OrionLaunchURL");
static_assert(offsetof(OrionUIBlueprintLibrary_OrionLaunchURL, WorldContextObject) == 0x000000, "Member 'OrionUIBlueprintLibrary_OrionLaunchURL::WorldContextObject' has a wrong offset!");
static_assert(offsetof(OrionUIBlueprintLibrary_OrionLaunchURL, URL) == 0x000008, "Member 'OrionUIBlueprintLibrary_OrionLaunchURL::URL' has a wrong offset!");

// Function OrionGame.OrionUIBlueprintLibrary.OrionTBFindMemberByIndex
// 0x0188 (0x0188 - 0x0000)
struct OrionUIBlueprintLibrary_OrionTBFindMemberByIndex final
{
public:
	struct FOrionTBState                          Members;                                           // 0x0000(0x0010)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionTBSlotState                      Result;                                            // 0x0018(0x0168)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0180(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181[0x7];                                      // 0x0181(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionUIBlueprintLibrary_OrionTBFindMemberByIndex) == 0x000008, "Wrong alignment on OrionUIBlueprintLibrary_OrionTBFindMemberByIndex");
static_assert(sizeof(OrionUIBlueprintLibrary_OrionTBFindMemberByIndex) == 0x000188, "Wrong size on OrionUIBlueprintLibrary_OrionTBFindMemberByIndex");
static_assert(offsetof(OrionUIBlueprintLibrary_OrionTBFindMemberByIndex, Members) == 0x000000, "Member 'OrionUIBlueprintLibrary_OrionTBFindMemberByIndex::Members' has a wrong offset!");
static_assert(offsetof(OrionUIBlueprintLibrary_OrionTBFindMemberByIndex, SlotIndex) == 0x000010, "Member 'OrionUIBlueprintLibrary_OrionTBFindMemberByIndex::SlotIndex' has a wrong offset!");
static_assert(offsetof(OrionUIBlueprintLibrary_OrionTBFindMemberByIndex, Result) == 0x000018, "Member 'OrionUIBlueprintLibrary_OrionTBFindMemberByIndex::Result' has a wrong offset!");
static_assert(offsetof(OrionUIBlueprintLibrary_OrionTBFindMemberByIndex, ReturnValue) == 0x000180, "Member 'OrionUIBlueprintLibrary_OrionTBFindMemberByIndex::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUIBlueprintLibrary.SafePercent
// 0x0010 (0x0010 - 0x0000)
struct OrionUIBlueprintLibrary_SafePercent final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValueMax;                                          // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIfInvalidReturnOne;                               // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIBlueprintLibrary_SafePercent) == 0x000004, "Wrong alignment on OrionUIBlueprintLibrary_SafePercent");
static_assert(sizeof(OrionUIBlueprintLibrary_SafePercent) == 0x000010, "Wrong size on OrionUIBlueprintLibrary_SafePercent");
static_assert(offsetof(OrionUIBlueprintLibrary_SafePercent, Value) == 0x000000, "Member 'OrionUIBlueprintLibrary_SafePercent::Value' has a wrong offset!");
static_assert(offsetof(OrionUIBlueprintLibrary_SafePercent, ValueMax) == 0x000004, "Member 'OrionUIBlueprintLibrary_SafePercent::ValueMax' has a wrong offset!");
static_assert(offsetof(OrionUIBlueprintLibrary_SafePercent, bIfInvalidReturnOne) == 0x000008, "Member 'OrionUIBlueprintLibrary_SafePercent::bIfInvalidReturnOne' has a wrong offset!");
static_assert(offsetof(OrionUIBlueprintLibrary_SafePercent, ReturnValue) == 0x00000C, "Member 'OrionUIBlueprintLibrary_SafePercent::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUIBlueprintLibrary.SetInputModeGameAndUI
// 0x0018 (0x0018 - 0x0000)
struct OrionUIBlueprintLibrary_SetInputModeGameAndUI final
{
public:
	class APlayerController*                      Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                WidgetToFocus;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideCursorDuringCapture;                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableParallax;                                   // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnalogCursor;                                     // 0x0012(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionUIBlueprintLibrary_SetInputModeGameAndUI) == 0x000008, "Wrong alignment on OrionUIBlueprintLibrary_SetInputModeGameAndUI");
static_assert(sizeof(OrionUIBlueprintLibrary_SetInputModeGameAndUI) == 0x000018, "Wrong size on OrionUIBlueprintLibrary_SetInputModeGameAndUI");
static_assert(offsetof(OrionUIBlueprintLibrary_SetInputModeGameAndUI, Target) == 0x000000, "Member 'OrionUIBlueprintLibrary_SetInputModeGameAndUI::Target' has a wrong offset!");
static_assert(offsetof(OrionUIBlueprintLibrary_SetInputModeGameAndUI, WidgetToFocus) == 0x000008, "Member 'OrionUIBlueprintLibrary_SetInputModeGameAndUI::WidgetToFocus' has a wrong offset!");
static_assert(offsetof(OrionUIBlueprintLibrary_SetInputModeGameAndUI, bHideCursorDuringCapture) == 0x000010, "Member 'OrionUIBlueprintLibrary_SetInputModeGameAndUI::bHideCursorDuringCapture' has a wrong offset!");
static_assert(offsetof(OrionUIBlueprintLibrary_SetInputModeGameAndUI, bEnableParallax) == 0x000011, "Member 'OrionUIBlueprintLibrary_SetInputModeGameAndUI::bEnableParallax' has a wrong offset!");
static_assert(offsetof(OrionUIBlueprintLibrary_SetInputModeGameAndUI, bAnalogCursor) == 0x000012, "Member 'OrionUIBlueprintLibrary_SetInputModeGameAndUI::bAnalogCursor' has a wrong offset!");

// Function OrionGame.OrionUIBlueprintLibrary.SetInputModeGameOnly
// 0x0008 (0x0008 - 0x0000)
struct OrionUIBlueprintLibrary_SetInputModeGameOnly final
{
public:
	class APlayerController*                      Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIBlueprintLibrary_SetInputModeGameOnly) == 0x000008, "Wrong alignment on OrionUIBlueprintLibrary_SetInputModeGameOnly");
static_assert(sizeof(OrionUIBlueprintLibrary_SetInputModeGameOnly) == 0x000008, "Wrong size on OrionUIBlueprintLibrary_SetInputModeGameOnly");
static_assert(offsetof(OrionUIBlueprintLibrary_SetInputModeGameOnly, Target) == 0x000000, "Member 'OrionUIBlueprintLibrary_SetInputModeGameOnly::Target' has a wrong offset!");

// Function OrionGame.OrionUIBlueprintLibrary.SetInputModeUIOnly
// 0x0018 (0x0018 - 0x0000)
struct OrionUIBlueprintLibrary_SetInputModeUIOnly final
{
public:
	class APlayerController*                      Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                WidgetToFocus;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableParallax;                                   // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionUIBlueprintLibrary_SetInputModeUIOnly) == 0x000008, "Wrong alignment on OrionUIBlueprintLibrary_SetInputModeUIOnly");
static_assert(sizeof(OrionUIBlueprintLibrary_SetInputModeUIOnly) == 0x000018, "Wrong size on OrionUIBlueprintLibrary_SetInputModeUIOnly");
static_assert(offsetof(OrionUIBlueprintLibrary_SetInputModeUIOnly, Target) == 0x000000, "Member 'OrionUIBlueprintLibrary_SetInputModeUIOnly::Target' has a wrong offset!");
static_assert(offsetof(OrionUIBlueprintLibrary_SetInputModeUIOnly, WidgetToFocus) == 0x000008, "Member 'OrionUIBlueprintLibrary_SetInputModeUIOnly::WidgetToFocus' has a wrong offset!");
static_assert(offsetof(OrionUIBlueprintLibrary_SetInputModeUIOnly, bEnableParallax) == 0x000010, "Member 'OrionUIBlueprintLibrary_SetInputModeUIOnly::bEnableParallax' has a wrong offset!");

// Function OrionGame.OrionUIBlueprintLibrary.SetNeedsMouse
// 0x0010 (0x0010 - 0x0000)
struct OrionUIBlueprintLibrary_SetNeedsMouse final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedsMouse;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionUIBlueprintLibrary_SetNeedsMouse) == 0x000008, "Wrong alignment on OrionUIBlueprintLibrary_SetNeedsMouse");
static_assert(sizeof(OrionUIBlueprintLibrary_SetNeedsMouse) == 0x000010, "Wrong size on OrionUIBlueprintLibrary_SetNeedsMouse");
static_assert(offsetof(OrionUIBlueprintLibrary_SetNeedsMouse, WorldContextObject) == 0x000000, "Member 'OrionUIBlueprintLibrary_SetNeedsMouse::WorldContextObject' has a wrong offset!");
static_assert(offsetof(OrionUIBlueprintLibrary_SetNeedsMouse, bNeedsMouse) == 0x000008, "Member 'OrionUIBlueprintLibrary_SetNeedsMouse::bNeedsMouse' has a wrong offset!");

// Function OrionGame.OrionUIBlueprintLibrary.StatToText
// 0x0020 (0x0020 - 0x0000)
struct OrionUIBlueprintLibrary_StatToText final
{
public:
	EOrionStatTypes                               InType;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIBlueprintLibrary_StatToText) == 0x000008, "Wrong alignment on OrionUIBlueprintLibrary_StatToText");
static_assert(sizeof(OrionUIBlueprintLibrary_StatToText) == 0x000020, "Wrong size on OrionUIBlueprintLibrary_StatToText");
static_assert(offsetof(OrionUIBlueprintLibrary_StatToText, InType) == 0x000000, "Member 'OrionUIBlueprintLibrary_StatToText::InType' has a wrong offset!");
static_assert(offsetof(OrionUIBlueprintLibrary_StatToText, ReturnValue) == 0x000008, "Member 'OrionUIBlueprintLibrary_StatToText::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUIBlueprintLibrary.SupportsHDR
// 0x0001 (0x0001 - 0x0000)
struct OrionUIBlueprintLibrary_SupportsHDR final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIBlueprintLibrary_SupportsHDR) == 0x000001, "Wrong alignment on OrionUIBlueprintLibrary_SupportsHDR");
static_assert(sizeof(OrionUIBlueprintLibrary_SupportsHDR) == 0x000001, "Wrong size on OrionUIBlueprintLibrary_SupportsHDR");
static_assert(offsetof(OrionUIBlueprintLibrary_SupportsHDR, ReturnValue) == 0x000000, "Member 'OrionUIBlueprintLibrary_SupportsHDR::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUIManagerWidget.BP_RegisterInputHandlerWidget
// 0x0030 (0x0030 - 0x0000)
struct OrionUIManagerWidget_BP_RegisterInputHandlerWidget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TScriptInterface<class IOrionInputHandlerWidget> WidgetToRegister;                                  // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FKey                                   InKey;                                             // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIManagerWidget_BP_RegisterInputHandlerWidget) == 0x000008, "Wrong alignment on OrionUIManagerWidget_BP_RegisterInputHandlerWidget");
static_assert(sizeof(OrionUIManagerWidget_BP_RegisterInputHandlerWidget) == 0x000030, "Wrong size on OrionUIManagerWidget_BP_RegisterInputHandlerWidget");
static_assert(offsetof(OrionUIManagerWidget_BP_RegisterInputHandlerWidget, WorldContextObject) == 0x000000, "Member 'OrionUIManagerWidget_BP_RegisterInputHandlerWidget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(OrionUIManagerWidget_BP_RegisterInputHandlerWidget, WidgetToRegister) == 0x000008, "Member 'OrionUIManagerWidget_BP_RegisterInputHandlerWidget::WidgetToRegister' has a wrong offset!");
static_assert(offsetof(OrionUIManagerWidget_BP_RegisterInputHandlerWidget, InKey) == 0x000018, "Member 'OrionUIManagerWidget_BP_RegisterInputHandlerWidget::InKey' has a wrong offset!");

// Function OrionGame.OrionUIManagerWidget.BP_UnregisterInputHandlerWidget
// 0x0030 (0x0030 - 0x0000)
struct OrionUIManagerWidget_BP_UnregisterInputHandlerWidget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TScriptInterface<class IOrionInputHandlerWidget> WidgetToUnregister;                                // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FKey                                   InKey;                                             // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIManagerWidget_BP_UnregisterInputHandlerWidget) == 0x000008, "Wrong alignment on OrionUIManagerWidget_BP_UnregisterInputHandlerWidget");
static_assert(sizeof(OrionUIManagerWidget_BP_UnregisterInputHandlerWidget) == 0x000030, "Wrong size on OrionUIManagerWidget_BP_UnregisterInputHandlerWidget");
static_assert(offsetof(OrionUIManagerWidget_BP_UnregisterInputHandlerWidget, WorldContextObject) == 0x000000, "Member 'OrionUIManagerWidget_BP_UnregisterInputHandlerWidget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(OrionUIManagerWidget_BP_UnregisterInputHandlerWidget, WidgetToUnregister) == 0x000008, "Member 'OrionUIManagerWidget_BP_UnregisterInputHandlerWidget::WidgetToUnregister' has a wrong offset!");
static_assert(offsetof(OrionUIManagerWidget_BP_UnregisterInputHandlerWidget, InKey) == 0x000018, "Member 'OrionUIManagerWidget_BP_UnregisterInputHandlerWidget::InKey' has a wrong offset!");

// Function OrionGame.OrionUIManagerWidget.EstablishCurrentBackHandlerStack
// 0x0010 (0x0010 - 0x0000)
struct OrionUIManagerWidget_EstablishCurrentBackHandlerStack final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StackName;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIManagerWidget_EstablishCurrentBackHandlerStack) == 0x000008, "Wrong alignment on OrionUIManagerWidget_EstablishCurrentBackHandlerStack");
static_assert(sizeof(OrionUIManagerWidget_EstablishCurrentBackHandlerStack) == 0x000010, "Wrong size on OrionUIManagerWidget_EstablishCurrentBackHandlerStack");
static_assert(offsetof(OrionUIManagerWidget_EstablishCurrentBackHandlerStack, WorldContextObject) == 0x000000, "Member 'OrionUIManagerWidget_EstablishCurrentBackHandlerStack::WorldContextObject' has a wrong offset!");
static_assert(offsetof(OrionUIManagerWidget_EstablishCurrentBackHandlerStack, StackName) == 0x000008, "Member 'OrionUIManagerWidget_EstablishCurrentBackHandlerStack::StackName' has a wrong offset!");

// Function OrionGame.OrionUIManagerWidget.GetUIManagerWidget
// 0x0010 (0x0010 - 0x0000)
struct OrionUIManagerWidget_GetUIManagerWidget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionUIManagerWidget*                  ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIManagerWidget_GetUIManagerWidget) == 0x000008, "Wrong alignment on OrionUIManagerWidget_GetUIManagerWidget");
static_assert(sizeof(OrionUIManagerWidget_GetUIManagerWidget) == 0x000010, "Wrong size on OrionUIManagerWidget_GetUIManagerWidget");
static_assert(offsetof(OrionUIManagerWidget_GetUIManagerWidget, WorldContextObject) == 0x000000, "Member 'OrionUIManagerWidget_GetUIManagerWidget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(OrionUIManagerWidget_GetUIManagerWidget, ReturnValue) == 0x000008, "Member 'OrionUIManagerWidget_GetUIManagerWidget::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUIManagerWidget.HideLoadingScreen
// 0x0008 (0x0008 - 0x0000)
struct OrionUIManagerWidget_HideLoadingScreen final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIManagerWidget_HideLoadingScreen) == 0x000008, "Wrong alignment on OrionUIManagerWidget_HideLoadingScreen");
static_assert(sizeof(OrionUIManagerWidget_HideLoadingScreen) == 0x000008, "Wrong size on OrionUIManagerWidget_HideLoadingScreen");
static_assert(offsetof(OrionUIManagerWidget_HideLoadingScreen, WorldContextObject) == 0x000000, "Member 'OrionUIManagerWidget_HideLoadingScreen::WorldContextObject' has a wrong offset!");

// Function OrionGame.OrionUIManagerWidget.HideLoadingScreenIfMode
// 0x0010 (0x0010 - 0x0000)
struct OrionUIManagerWidget_HideLoadingScreenIfMode final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionLoadingScreenMode                       Mode;                                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionUIManagerWidget_HideLoadingScreenIfMode) == 0x000008, "Wrong alignment on OrionUIManagerWidget_HideLoadingScreenIfMode");
static_assert(sizeof(OrionUIManagerWidget_HideLoadingScreenIfMode) == 0x000010, "Wrong size on OrionUIManagerWidget_HideLoadingScreenIfMode");
static_assert(offsetof(OrionUIManagerWidget_HideLoadingScreenIfMode, WorldContextObject) == 0x000000, "Member 'OrionUIManagerWidget_HideLoadingScreenIfMode::WorldContextObject' has a wrong offset!");
static_assert(offsetof(OrionUIManagerWidget_HideLoadingScreenIfMode, Mode) == 0x000008, "Member 'OrionUIManagerWidget_HideLoadingScreenIfMode::Mode' has a wrong offset!");

// Function OrionGame.OrionUIManagerWidget.IsLoadingScreenVisible
// 0x0010 (0x0010 - 0x0000)
struct OrionUIManagerWidget_IsLoadingScreenVisible final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionUIManagerWidget_IsLoadingScreenVisible) == 0x000008, "Wrong alignment on OrionUIManagerWidget_IsLoadingScreenVisible");
static_assert(sizeof(OrionUIManagerWidget_IsLoadingScreenVisible) == 0x000010, "Wrong size on OrionUIManagerWidget_IsLoadingScreenVisible");
static_assert(offsetof(OrionUIManagerWidget_IsLoadingScreenVisible, WorldContextObject) == 0x000000, "Member 'OrionUIManagerWidget_IsLoadingScreenVisible::WorldContextObject' has a wrong offset!");
static_assert(offsetof(OrionUIManagerWidget_IsLoadingScreenVisible, ReturnValue) == 0x000008, "Member 'OrionUIManagerWidget_IsLoadingScreenVisible::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUIManagerWidget.KillConfirmationDialog
// 0x0008 (0x0008 - 0x0000)
struct OrionUIManagerWidget_KillConfirmationDialog final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIManagerWidget_KillConfirmationDialog) == 0x000008, "Wrong alignment on OrionUIManagerWidget_KillConfirmationDialog");
static_assert(sizeof(OrionUIManagerWidget_KillConfirmationDialog) == 0x000008, "Wrong size on OrionUIManagerWidget_KillConfirmationDialog");
static_assert(offsetof(OrionUIManagerWidget_KillConfirmationDialog, WorldContextObject) == 0x000000, "Member 'OrionUIManagerWidget_KillConfirmationDialog::WorldContextObject' has a wrong offset!");

// Function OrionGame.OrionUIManagerWidget.PlayVideo
// 0x0018 (0x0018 - 0x0000)
struct OrionUIManagerWidget_PlayVideo final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VideoID;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionUIManagerWidget_PlayVideo) == 0x000008, "Wrong alignment on OrionUIManagerWidget_PlayVideo");
static_assert(sizeof(OrionUIManagerWidget_PlayVideo) == 0x000018, "Wrong size on OrionUIManagerWidget_PlayVideo");
static_assert(offsetof(OrionUIManagerWidget_PlayVideo, WorldContextObject) == 0x000000, "Member 'OrionUIManagerWidget_PlayVideo::WorldContextObject' has a wrong offset!");
static_assert(offsetof(OrionUIManagerWidget_PlayVideo, VideoID) == 0x000008, "Member 'OrionUIManagerWidget_PlayVideo::VideoID' has a wrong offset!");
static_assert(offsetof(OrionUIManagerWidget_PlayVideo, ReturnValue) == 0x000010, "Member 'OrionUIManagerWidget_PlayVideo::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUIManagerWidget.SetActiveTutorial
// 0x0018 (0x0018 - 0x0000)
struct OrionUIManagerWidget_SetActiveTutorial final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionTutorial*                         Tutorial;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideTutorialInProgress;                       // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionUIManagerWidget_SetActiveTutorial) == 0x000008, "Wrong alignment on OrionUIManagerWidget_SetActiveTutorial");
static_assert(sizeof(OrionUIManagerWidget_SetActiveTutorial) == 0x000018, "Wrong size on OrionUIManagerWidget_SetActiveTutorial");
static_assert(offsetof(OrionUIManagerWidget_SetActiveTutorial, WorldContextObject) == 0x000000, "Member 'OrionUIManagerWidget_SetActiveTutorial::WorldContextObject' has a wrong offset!");
static_assert(offsetof(OrionUIManagerWidget_SetActiveTutorial, Tutorial) == 0x000008, "Member 'OrionUIManagerWidget_SetActiveTutorial::Tutorial' has a wrong offset!");
static_assert(offsetof(OrionUIManagerWidget_SetActiveTutorial, bOverrideTutorialInProgress) == 0x000010, "Member 'OrionUIManagerWidget_SetActiveTutorial::bOverrideTutorialInProgress' has a wrong offset!");

// Function OrionGame.OrionUIManagerWidget.ShowErrorNotification
// 0x0028 (0x0028 - 0x0000)
struct OrionUIManagerWidget_ShowErrorNotification final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayMessage;                                    // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
	bool                                          bClearExistingErrors;                              // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionUIManagerWidget_ShowErrorNotification) == 0x000008, "Wrong alignment on OrionUIManagerWidget_ShowErrorNotification");
static_assert(sizeof(OrionUIManagerWidget_ShowErrorNotification) == 0x000028, "Wrong size on OrionUIManagerWidget_ShowErrorNotification");
static_assert(offsetof(OrionUIManagerWidget_ShowErrorNotification, WorldContextObject) == 0x000000, "Member 'OrionUIManagerWidget_ShowErrorNotification::WorldContextObject' has a wrong offset!");
static_assert(offsetof(OrionUIManagerWidget_ShowErrorNotification, DisplayMessage) == 0x000008, "Member 'OrionUIManagerWidget_ShowErrorNotification::DisplayMessage' has a wrong offset!");
static_assert(offsetof(OrionUIManagerWidget_ShowErrorNotification, bClearExistingErrors) == 0x000020, "Member 'OrionUIManagerWidget_ShowErrorNotification::bClearExistingErrors' has a wrong offset!");

// Function OrionGame.OrionUIManagerWidget.ShowLoadingScreen
// 0x0010 (0x0010 - 0x0000)
struct OrionUIManagerWidget_ShowLoadingScreen final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionLoadingScreenMode                       Mode;                                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionUIManagerWidget_ShowLoadingScreen) == 0x000008, "Wrong alignment on OrionUIManagerWidget_ShowLoadingScreen");
static_assert(sizeof(OrionUIManagerWidget_ShowLoadingScreen) == 0x000010, "Wrong size on OrionUIManagerWidget_ShowLoadingScreen");
static_assert(offsetof(OrionUIManagerWidget_ShowLoadingScreen, WorldContextObject) == 0x000000, "Member 'OrionUIManagerWidget_ShowLoadingScreen::WorldContextObject' has a wrong offset!");
static_assert(offsetof(OrionUIManagerWidget_ShowLoadingScreen, Mode) == 0x000008, "Member 'OrionUIManagerWidget_ShowLoadingScreen::Mode' has a wrong offset!");

// Function OrionGame.OrionUIManagerWidget.StopActiveTutorial
// 0x0010 (0x0010 - 0x0000)
struct OrionUIManagerWidget_StopActiveTutorial final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UOrionTutorial>             TutorialClass;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIManagerWidget_StopActiveTutorial) == 0x000008, "Wrong alignment on OrionUIManagerWidget_StopActiveTutorial");
static_assert(sizeof(OrionUIManagerWidget_StopActiveTutorial) == 0x000010, "Wrong size on OrionUIManagerWidget_StopActiveTutorial");
static_assert(offsetof(OrionUIManagerWidget_StopActiveTutorial, WorldContextObject) == 0x000000, "Member 'OrionUIManagerWidget_StopActiveTutorial::WorldContextObject' has a wrong offset!");
static_assert(offsetof(OrionUIManagerWidget_StopActiveTutorial, TutorialClass) == 0x000008, "Member 'OrionUIManagerWidget_StopActiveTutorial::TutorialClass' has a wrong offset!");

// Function OrionGame.OrionUIManagerWidget.AddMovingWidget
// 0x0060 (0x0060 - 0x0000)
struct OrionUIManagerWidget_AddMovingWidget final
{
public:
	class UWidget*                                WidgetToMove;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGeometry                              SourceGeometry;                                    // 0x0008(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   DestinationId;                                     // 0x0040(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveDuration;                                      // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumCopies;                                         // 0x004C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CopyDelay;                                         // 0x0050(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovingWidgetMotion                           MotionType;                                        // 0x0054(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SpreadAngleDegrees;                                // 0x0058(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionUIManagerWidget_AddMovingWidget) == 0x000008, "Wrong alignment on OrionUIManagerWidget_AddMovingWidget");
static_assert(sizeof(OrionUIManagerWidget_AddMovingWidget) == 0x000060, "Wrong size on OrionUIManagerWidget_AddMovingWidget");
static_assert(offsetof(OrionUIManagerWidget_AddMovingWidget, WidgetToMove) == 0x000000, "Member 'OrionUIManagerWidget_AddMovingWidget::WidgetToMove' has a wrong offset!");
static_assert(offsetof(OrionUIManagerWidget_AddMovingWidget, SourceGeometry) == 0x000008, "Member 'OrionUIManagerWidget_AddMovingWidget::SourceGeometry' has a wrong offset!");
static_assert(offsetof(OrionUIManagerWidget_AddMovingWidget, DestinationId) == 0x000040, "Member 'OrionUIManagerWidget_AddMovingWidget::DestinationId' has a wrong offset!");
static_assert(offsetof(OrionUIManagerWidget_AddMovingWidget, MoveDuration) == 0x000048, "Member 'OrionUIManagerWidget_AddMovingWidget::MoveDuration' has a wrong offset!");
static_assert(offsetof(OrionUIManagerWidget_AddMovingWidget, NumCopies) == 0x00004C, "Member 'OrionUIManagerWidget_AddMovingWidget::NumCopies' has a wrong offset!");
static_assert(offsetof(OrionUIManagerWidget_AddMovingWidget, CopyDelay) == 0x000050, "Member 'OrionUIManagerWidget_AddMovingWidget::CopyDelay' has a wrong offset!");
static_assert(offsetof(OrionUIManagerWidget_AddMovingWidget, MotionType) == 0x000054, "Member 'OrionUIManagerWidget_AddMovingWidget::MotionType' has a wrong offset!");
static_assert(offsetof(OrionUIManagerWidget_AddMovingWidget, SpreadAngleDegrees) == 0x000058, "Member 'OrionUIManagerWidget_AddMovingWidget::SpreadAngleDegrees' has a wrong offset!");

// Function OrionGame.OrionUIManagerWidget.IsModalMode
// 0x0001 (0x0001 - 0x0000)
struct OrionUIManagerWidget_IsModalMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIManagerWidget_IsModalMode) == 0x000001, "Wrong alignment on OrionUIManagerWidget_IsModalMode");
static_assert(sizeof(OrionUIManagerWidget_IsModalMode) == 0x000001, "Wrong size on OrionUIManagerWidget_IsModalMode");
static_assert(offsetof(OrionUIManagerWidget_IsModalMode, ReturnValue) == 0x000000, "Member 'OrionUIManagerWidget_IsModalMode::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUIManagerWidget.KillMovingWidget
// 0x0008 (0x0008 - 0x0000)
struct OrionUIManagerWidget_KillMovingWidget final
{
public:
	class FName                                   MovingWidgetId;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIManagerWidget_KillMovingWidget) == 0x000004, "Wrong alignment on OrionUIManagerWidget_KillMovingWidget");
static_assert(sizeof(OrionUIManagerWidget_KillMovingWidget) == 0x000008, "Wrong size on OrionUIManagerWidget_KillMovingWidget");
static_assert(offsetof(OrionUIManagerWidget_KillMovingWidget, MovingWidgetId) == 0x000000, "Member 'OrionUIManagerWidget_KillMovingWidget::MovingWidgetId' has a wrong offset!");

// DelegateFunction OrionGame.OrionUIManagerWidget.OnLoadingScreenProgressUpdated__DelegateSignature
// 0x0004 (0x0004 - 0x0000)
struct OrionUIManagerWidget_OnLoadingScreenProgressUpdated__DelegateSignature final
{
public:
	float                                         LoadingPercent;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIManagerWidget_OnLoadingScreenProgressUpdated__DelegateSignature) == 0x000004, "Wrong alignment on OrionUIManagerWidget_OnLoadingScreenProgressUpdated__DelegateSignature");
static_assert(sizeof(OrionUIManagerWidget_OnLoadingScreenProgressUpdated__DelegateSignature) == 0x000004, "Wrong size on OrionUIManagerWidget_OnLoadingScreenProgressUpdated__DelegateSignature");
static_assert(offsetof(OrionUIManagerWidget_OnLoadingScreenProgressUpdated__DelegateSignature, LoadingPercent) == 0x000000, "Member 'OrionUIManagerWidget_OnLoadingScreenProgressUpdated__DelegateSignature::LoadingPercent' has a wrong offset!");

// Function OrionGame.OrionUIManagerWidget.OnSetMatchInfoText
// 0x0018 (0x0018 - 0x0000)
struct OrionUIManagerWidget_OnSetMatchInfoText final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIManagerWidget_OnSetMatchInfoText) == 0x000008, "Wrong alignment on OrionUIManagerWidget_OnSetMatchInfoText");
static_assert(sizeof(OrionUIManagerWidget_OnSetMatchInfoText) == 0x000018, "Wrong size on OrionUIManagerWidget_OnSetMatchInfoText");
static_assert(offsetof(OrionUIManagerWidget_OnSetMatchInfoText, InText) == 0x000000, "Member 'OrionUIManagerWidget_OnSetMatchInfoText::InText' has a wrong offset!");

// Function OrionGame.OrionUIManagerWidget.OnSetMatchInfoVisibility
// 0x0001 (0x0001 - 0x0000)
struct OrionUIManagerWidget_OnSetMatchInfoVisibility final
{
public:
	bool                                          bVisible;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIManagerWidget_OnSetMatchInfoVisibility) == 0x000001, "Wrong alignment on OrionUIManagerWidget_OnSetMatchInfoVisibility");
static_assert(sizeof(OrionUIManagerWidget_OnSetMatchInfoVisibility) == 0x000001, "Wrong size on OrionUIManagerWidget_OnSetMatchInfoVisibility");
static_assert(offsetof(OrionUIManagerWidget_OnSetMatchInfoVisibility, bVisible) == 0x000000, "Member 'OrionUIManagerWidget_OnSetMatchInfoVisibility::bVisible' has a wrong offset!");

// Function OrionGame.OrionUIManagerWidget.OnShowError
// 0x00B0 (0x00B0 - 0x0000)
struct OrionUIManagerWidget_OnShowError final
{
public:
	struct FOrionDialogDescription                Description;                                       // 0x0000(0x00B0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIManagerWidget_OnShowError) == 0x000010, "Wrong alignment on OrionUIManagerWidget_OnShowError");
static_assert(sizeof(OrionUIManagerWidget_OnShowError) == 0x0000B0, "Wrong size on OrionUIManagerWidget_OnShowError");
static_assert(offsetof(OrionUIManagerWidget_OnShowError, Description) == 0x000000, "Member 'OrionUIManagerWidget_OnShowError::Description' has a wrong offset!");

// Function OrionGame.OrionUIManagerWidget.SetStateContentDisplayed
// 0x0001 (0x0001 - 0x0000)
struct OrionUIManagerWidget_SetStateContentDisplayed final
{
public:
	bool                                          bDisplay;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIManagerWidget_SetStateContentDisplayed) == 0x000001, "Wrong alignment on OrionUIManagerWidget_SetStateContentDisplayed");
static_assert(sizeof(OrionUIManagerWidget_SetStateContentDisplayed) == 0x000001, "Wrong size on OrionUIManagerWidget_SetStateContentDisplayed");
static_assert(offsetof(OrionUIManagerWidget_SetStateContentDisplayed, bDisplay) == 0x000000, "Member 'OrionUIManagerWidget_SetStateContentDisplayed::bDisplay' has a wrong offset!");

// Function OrionGame.OrionUIManagerWidget.ShowModalContent
// 0x0008 (0x0008 - 0x0000)
struct OrionUIManagerWidget_ShowModalContent final
{
public:
	class UOrionActivatableWidget*                ActivatableContent;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIManagerWidget_ShowModalContent) == 0x000008, "Wrong alignment on OrionUIManagerWidget_ShowModalContent");
static_assert(sizeof(OrionUIManagerWidget_ShowModalContent) == 0x000008, "Wrong size on OrionUIManagerWidget_ShowModalContent");
static_assert(offsetof(OrionUIManagerWidget_ShowModalContent, ActivatableContent) == 0x000000, "Member 'OrionUIManagerWidget_ShowModalContent::ActivatableContent' has a wrong offset!");

// Function OrionGame.OrionUIManagerWidget.BP_GetCurrentUIStateWidget
// 0x0008 (0x0008 - 0x0000)
struct OrionUIManagerWidget_BP_GetCurrentUIStateWidget final
{
public:
	class UOrionUIStateWidget*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIManagerWidget_BP_GetCurrentUIStateWidget) == 0x000008, "Wrong alignment on OrionUIManagerWidget_BP_GetCurrentUIStateWidget");
static_assert(sizeof(OrionUIManagerWidget_BP_GetCurrentUIStateWidget) == 0x000008, "Wrong size on OrionUIManagerWidget_BP_GetCurrentUIStateWidget");
static_assert(offsetof(OrionUIManagerWidget_BP_GetCurrentUIStateWidget, ReturnValue) == 0x000000, "Member 'OrionUIManagerWidget_BP_GetCurrentUIStateWidget::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUIManagerWidget.GetCurrentUIState
// 0x0001 (0x0001 - 0x0000)
struct OrionUIManagerWidget_GetCurrentUIState final
{
public:
	EOrionUIState                                 ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIManagerWidget_GetCurrentUIState) == 0x000001, "Wrong alignment on OrionUIManagerWidget_GetCurrentUIState");
static_assert(sizeof(OrionUIManagerWidget_GetCurrentUIState) == 0x000001, "Wrong size on OrionUIManagerWidget_GetCurrentUIState");
static_assert(offsetof(OrionUIManagerWidget_GetCurrentUIState, ReturnValue) == 0x000000, "Member 'OrionUIManagerWidget_GetCurrentUIState::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUIManagerWidget.IsStateContentDisplayed
// 0x0001 (0x0001 - 0x0000)
struct OrionUIManagerWidget_IsStateContentDisplayed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIManagerWidget_IsStateContentDisplayed) == 0x000001, "Wrong alignment on OrionUIManagerWidget_IsStateContentDisplayed");
static_assert(sizeof(OrionUIManagerWidget_IsStateContentDisplayed) == 0x000001, "Wrong size on OrionUIManagerWidget_IsStateContentDisplayed");
static_assert(offsetof(OrionUIManagerWidget_IsStateContentDisplayed, ReturnValue) == 0x000000, "Member 'OrionUIManagerWidget_IsStateContentDisplayed::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUIStateWidget.UpdateButtonLegend
// 0x0010 (0x0010 - 0x0000)
struct OrionUIStateWidget_UpdateButtonLegend final
{
public:
	TArray<struct FButtonLegendItem>              LegendSource;                                      // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIStateWidget_UpdateButtonLegend) == 0x000008, "Wrong alignment on OrionUIStateWidget_UpdateButtonLegend");
static_assert(sizeof(OrionUIStateWidget_UpdateButtonLegend) == 0x000010, "Wrong size on OrionUIStateWidget_UpdateButtonLegend");
static_assert(offsetof(OrionUIStateWidget_UpdateButtonLegend, LegendSource) == 0x000000, "Member 'OrionUIStateWidget_UpdateButtonLegend::LegendSource' has a wrong offset!");

// Function OrionGame.OrionUIStateWidget.IsReadyForNextState
// 0x0001 (0x0001 - 0x0000)
struct OrionUIStateWidget_IsReadyForNextState final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUIStateWidget_IsReadyForNextState) == 0x000001, "Wrong alignment on OrionUIStateWidget_IsReadyForNextState");
static_assert(sizeof(OrionUIStateWidget_IsReadyForNextState) == 0x000001, "Wrong size on OrionUIStateWidget_IsReadyForNextState");
static_assert(offsetof(OrionUIStateWidget_IsReadyForNextState, ReturnValue) == 0x000000, "Member 'OrionUIStateWidget_IsReadyForNextState::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUserWidget_GameEventMessage.GetEnemyTeam
// 0x0001 (0x0001 - 0x0000)
struct OrionUserWidget_GameEventMessage_GetEnemyTeam final
{
public:
	EOrionTeam                                    ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUserWidget_GameEventMessage_GetEnemyTeam) == 0x000001, "Wrong alignment on OrionUserWidget_GameEventMessage_GetEnemyTeam");
static_assert(sizeof(OrionUserWidget_GameEventMessage_GetEnemyTeam) == 0x000001, "Wrong size on OrionUserWidget_GameEventMessage_GetEnemyTeam");
static_assert(offsetof(OrionUserWidget_GameEventMessage_GetEnemyTeam, ReturnValue) == 0x000000, "Member 'OrionUserWidget_GameEventMessage_GetEnemyTeam::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionUserWidget_GameEventMessage.GetMyTeam
// 0x0001 (0x0001 - 0x0000)
struct OrionUserWidget_GameEventMessage_GetMyTeam final
{
public:
	EOrionTeam                                    ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUserWidget_GameEventMessage_GetMyTeam) == 0x000001, "Wrong alignment on OrionUserWidget_GameEventMessage_GetMyTeam");
static_assert(sizeof(OrionUserWidget_GameEventMessage_GetMyTeam) == 0x000001, "Wrong size on OrionUserWidget_GameEventMessage_GetMyTeam");
static_assert(offsetof(OrionUserWidget_GameEventMessage_GetMyTeam, ReturnValue) == 0x000000, "Member 'OrionUserWidget_GameEventMessage_GetMyTeam::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionGameEventMessageContainer.AddNewGameEventMessage
// 0x00D0 (0x00D0 - 0x0000)
struct OrionGameEventMessageContainer_AddNewGameEventMessage final
{
public:
	struct FOrionGameEventMessageData             NewMessageData;                                    // 0x0000(0x00D0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionGameEventMessageContainer_AddNewGameEventMessage) == 0x000008, "Wrong alignment on OrionGameEventMessageContainer_AddNewGameEventMessage");
static_assert(sizeof(OrionGameEventMessageContainer_AddNewGameEventMessage) == 0x0000D0, "Wrong size on OrionGameEventMessageContainer_AddNewGameEventMessage");
static_assert(offsetof(OrionGameEventMessageContainer_AddNewGameEventMessage, NewMessageData) == 0x000000, "Member 'OrionGameEventMessageContainer_AddNewGameEventMessage::NewMessageData' has a wrong offset!");

// Function OrionGame.OrionUserWidget_Reticle.OnTargetingUpdate
// 0x0001 (0x0001 - 0x0000)
struct OrionUserWidget_Reticle_OnTargetingUpdate final
{
public:
	bool                                          bIsTargeting;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionUserWidget_Reticle_OnTargetingUpdate) == 0x000001, "Wrong alignment on OrionUserWidget_Reticle_OnTargetingUpdate");
static_assert(sizeof(OrionUserWidget_Reticle_OnTargetingUpdate) == 0x000001, "Wrong size on OrionUserWidget_Reticle_OnTargetingUpdate");
static_assert(offsetof(OrionUserWidget_Reticle_OnTargetingUpdate, bIsTargeting) == 0x000000, "Member 'OrionUserWidget_Reticle_OnTargetingUpdate::bIsTargeting' has a wrong offset!");

// Function OrionGame.OrionVisionManager2.MulticastDebugLog
// 0x0010 (0x0010 - 0x0000)
struct OrionVisionManager2_MulticastDebugLog final
{
public:
	TArray<class FString>                         Strs;                                              // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionVisionManager2_MulticastDebugLog) == 0x000008, "Wrong alignment on OrionVisionManager2_MulticastDebugLog");
static_assert(sizeof(OrionVisionManager2_MulticastDebugLog) == 0x000010, "Wrong size on OrionVisionManager2_MulticastDebugLog");
static_assert(offsetof(OrionVisionManager2_MulticastDebugLog, Strs) == 0x000000, "Member 'OrionVisionManager2_MulticastDebugLog::Strs' has a wrong offset!");

// Function OrionGame.OrionVisionWard.HandleTrackedHeroDeath
// 0x0018 (0x0018 - 0x0000)
struct OrionVisionWard_HandleTrackedHeroDeath final
{
public:
	class AOrionChar*                             DeadChar;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            Killer;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionVisionWard_HandleTrackedHeroDeath) == 0x000008, "Wrong alignment on OrionVisionWard_HandleTrackedHeroDeath");
static_assert(sizeof(OrionVisionWard_HandleTrackedHeroDeath) == 0x000018, "Wrong size on OrionVisionWard_HandleTrackedHeroDeath");
static_assert(offsetof(OrionVisionWard_HandleTrackedHeroDeath, DeadChar) == 0x000000, "Member 'OrionVisionWard_HandleTrackedHeroDeath::DeadChar' has a wrong offset!");
static_assert(offsetof(OrionVisionWard_HandleTrackedHeroDeath, Killer) == 0x000008, "Member 'OrionVisionWard_HandleTrackedHeroDeath::Killer' has a wrong offset!");
static_assert(offsetof(OrionVisionWard_HandleTrackedHeroDeath, DamageCauser) == 0x000010, "Member 'OrionVisionWard_HandleTrackedHeroDeath::DamageCauser' has a wrong offset!");

// Function OrionGame.OrionVisionWard.OnPlayerSightedPing
// 0x0008 (0x0008 - 0x0000)
struct OrionVisionWard_OnPlayerSightedPing final
{
public:
	class AActor*                                 SightedPlayer;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionVisionWard_OnPlayerSightedPing) == 0x000008, "Wrong alignment on OrionVisionWard_OnPlayerSightedPing");
static_assert(sizeof(OrionVisionWard_OnPlayerSightedPing) == 0x000008, "Wrong size on OrionVisionWard_OnPlayerSightedPing");
static_assert(offsetof(OrionVisionWard_OnPlayerSightedPing, SightedPlayer) == 0x000000, "Member 'OrionVisionWard_OnPlayerSightedPing::SightedPlayer' has a wrong offset!");

// Function OrionGame.OrionVisionWard.GetLifeSpanPercentage
// 0x0004 (0x0004 - 0x0000)
struct OrionVisionWard_GetLifeSpanPercentage final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionVisionWard_GetLifeSpanPercentage) == 0x000004, "Wrong alignment on OrionVisionWard_GetLifeSpanPercentage");
static_assert(sizeof(OrionVisionWard_GetLifeSpanPercentage) == 0x000004, "Wrong size on OrionVisionWard_GetLifeSpanPercentage");
static_assert(offsetof(OrionVisionWard_GetLifeSpanPercentage, ReturnValue) == 0x000000, "Member 'OrionVisionWard_GetLifeSpanPercentage::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionWell_Base.DetachRig
// 0x0008 (0x0008 - 0x0000)
struct OrionWell_Base_DetachRig final
{
public:
	class AOrionRigs*                             RigToRemove;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionWell_Base_DetachRig) == 0x000008, "Wrong alignment on OrionWell_Base_DetachRig");
static_assert(sizeof(OrionWell_Base_DetachRig) == 0x000008, "Wrong size on OrionWell_Base_DetachRig");
static_assert(offsetof(OrionWell_Base_DetachRig, RigToRemove) == 0x000000, "Member 'OrionWell_Base_DetachRig::RigToRemove' has a wrong offset!");

// Function OrionGame.OrionWell_Base.ForceWellToState
// 0x0001 (0x0001 - 0x0000)
struct OrionWell_Base_ForceWellToState final
{
public:
	EOrionWellState                               NewState;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionWell_Base_ForceWellToState) == 0x000001, "Wrong alignment on OrionWell_Base_ForceWellToState");
static_assert(sizeof(OrionWell_Base_ForceWellToState) == 0x000001, "Wrong size on OrionWell_Base_ForceWellToState");
static_assert(offsetof(OrionWell_Base_ForceWellToState, NewState) == 0x000000, "Member 'OrionWell_Base_ForceWellToState::NewState' has a wrong offset!");

// Function OrionGame.OrionWell_Base.GetAttachedRig
// 0x0008 (0x0008 - 0x0000)
struct OrionWell_Base_GetAttachedRig final
{
public:
	class AOrionRigs*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionWell_Base_GetAttachedRig) == 0x000008, "Wrong alignment on OrionWell_Base_GetAttachedRig");
static_assert(sizeof(OrionWell_Base_GetAttachedRig) == 0x000008, "Wrong size on OrionWell_Base_GetAttachedRig");
static_assert(offsetof(OrionWell_Base_GetAttachedRig, ReturnValue) == 0x000000, "Member 'OrionWell_Base_GetAttachedRig::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionWell_Base.GetCurrentWellState
// 0x0001 (0x0001 - 0x0000)
struct OrionWell_Base_GetCurrentWellState final
{
public:
	EOrionWellState                               ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionWell_Base_GetCurrentWellState) == 0x000001, "Wrong alignment on OrionWell_Base_GetCurrentWellState");
static_assert(sizeof(OrionWell_Base_GetCurrentWellState) == 0x000001, "Wrong size on OrionWell_Base_GetCurrentWellState");
static_assert(offsetof(OrionWell_Base_GetCurrentWellState, ReturnValue) == 0x000000, "Member 'OrionWell_Base_GetCurrentWellState::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionWell_Base.GetPlayerThatPlacedRig
// 0x0008 (0x0008 - 0x0000)
struct OrionWell_Base_GetPlayerThatPlacedRig final
{
public:
	class AOrionPlayerState_Game*                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionWell_Base_GetPlayerThatPlacedRig) == 0x000008, "Wrong alignment on OrionWell_Base_GetPlayerThatPlacedRig");
static_assert(sizeof(OrionWell_Base_GetPlayerThatPlacedRig) == 0x000008, "Wrong size on OrionWell_Base_GetPlayerThatPlacedRig");
static_assert(offsetof(OrionWell_Base_GetPlayerThatPlacedRig, ReturnValue) == 0x000000, "Member 'OrionWell_Base_GetPlayerThatPlacedRig::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionWell_Base.GetResourcePercent
// 0x0004 (0x0004 - 0x0000)
struct OrionWell_Base_GetResourcePercent final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionWell_Base_GetResourcePercent) == 0x000004, "Wrong alignment on OrionWell_Base_GetResourcePercent");
static_assert(sizeof(OrionWell_Base_GetResourcePercent) == 0x000004, "Wrong size on OrionWell_Base_GetResourcePercent");
static_assert(offsetof(OrionWell_Base_GetResourcePercent, ReturnValue) == 0x000000, "Member 'OrionWell_Base_GetResourcePercent::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionWell_Base.GetRigAttachLocation
// 0x000C (0x000C - 0x0000)
struct OrionWell_Base_GetRigAttachLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionWell_Base_GetRigAttachLocation) == 0x000004, "Wrong alignment on OrionWell_Base_GetRigAttachLocation");
static_assert(sizeof(OrionWell_Base_GetRigAttachLocation) == 0x00000C, "Wrong size on OrionWell_Base_GetRigAttachLocation");
static_assert(offsetof(OrionWell_Base_GetRigAttachLocation, ReturnValue) == 0x000000, "Member 'OrionWell_Base_GetRigAttachLocation::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionWell_Base.GetRigAttachRotaion
// 0x000C (0x000C - 0x0000)
struct OrionWell_Base_GetRigAttachRotaion final
{
public:
	struct FRotator                               ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionWell_Base_GetRigAttachRotaion) == 0x000004, "Wrong alignment on OrionWell_Base_GetRigAttachRotaion");
static_assert(sizeof(OrionWell_Base_GetRigAttachRotaion) == 0x00000C, "Wrong size on OrionWell_Base_GetRigAttachRotaion");
static_assert(offsetof(OrionWell_Base_GetRigAttachRotaion, ReturnValue) == 0x000000, "Member 'OrionWell_Base_GetRigAttachRotaion::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionWell_Base.GetRigBoostedScale
// 0x0004 (0x0004 - 0x0000)
struct OrionWell_Base_GetRigBoostedScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionWell_Base_GetRigBoostedScale) == 0x000004, "Wrong alignment on OrionWell_Base_GetRigBoostedScale");
static_assert(sizeof(OrionWell_Base_GetRigBoostedScale) == 0x000004, "Wrong size on OrionWell_Base_GetRigBoostedScale");
static_assert(offsetof(OrionWell_Base_GetRigBoostedScale, ReturnValue) == 0x000000, "Member 'OrionWell_Base_GetRigBoostedScale::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionWell_Base.K2_IsRigPlaced
// 0x0001 (0x0001 - 0x0000)
struct OrionWell_Base_K2_IsRigPlaced final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionWell_Base_K2_IsRigPlaced) == 0x000001, "Wrong alignment on OrionWell_Base_K2_IsRigPlaced");
static_assert(sizeof(OrionWell_Base_K2_IsRigPlaced) == 0x000001, "Wrong size on OrionWell_Base_K2_IsRigPlaced");
static_assert(offsetof(OrionWell_Base_K2_IsRigPlaced, ReturnValue) == 0x000000, "Member 'OrionWell_Base_K2_IsRigPlaced::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionWell_Base.OnAttachRig
// 0x0008 (0x0008 - 0x0000)
struct OrionWell_Base_OnAttachRig final
{
public:
	class AOrionRigs*                             NewAttachedRig;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionWell_Base_OnAttachRig) == 0x000008, "Wrong alignment on OrionWell_Base_OnAttachRig");
static_assert(sizeof(OrionWell_Base_OnAttachRig) == 0x000008, "Wrong size on OrionWell_Base_OnAttachRig");
static_assert(offsetof(OrionWell_Base_OnAttachRig, NewAttachedRig) == 0x000000, "Member 'OrionWell_Base_OnAttachRig::NewAttachedRig' has a wrong offset!");

// Function OrionGame.OrionWell_Base.OnOverlapBegin
// 0x00A8 (0x00A8 - 0x0000)
struct OrionWell_Base_OnOverlapBegin final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionWell_Base_OnOverlapBegin) == 0x000008, "Wrong alignment on OrionWell_Base_OnOverlapBegin");
static_assert(sizeof(OrionWell_Base_OnOverlapBegin) == 0x0000A8, "Wrong size on OrionWell_Base_OnOverlapBegin");
static_assert(offsetof(OrionWell_Base_OnOverlapBegin, OverlappedComp) == 0x000000, "Member 'OrionWell_Base_OnOverlapBegin::OverlappedComp' has a wrong offset!");
static_assert(offsetof(OrionWell_Base_OnOverlapBegin, OtherActor) == 0x000008, "Member 'OrionWell_Base_OnOverlapBegin::OtherActor' has a wrong offset!");
static_assert(offsetof(OrionWell_Base_OnOverlapBegin, OtherComp) == 0x000010, "Member 'OrionWell_Base_OnOverlapBegin::OtherComp' has a wrong offset!");
static_assert(offsetof(OrionWell_Base_OnOverlapBegin, OtherBodyIndex) == 0x000018, "Member 'OrionWell_Base_OnOverlapBegin::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(OrionWell_Base_OnOverlapBegin, bFromSweep) == 0x00001C, "Member 'OrionWell_Base_OnOverlapBegin::bFromSweep' has a wrong offset!");
static_assert(offsetof(OrionWell_Base_OnOverlapBegin, SweepResult) == 0x000020, "Member 'OrionWell_Base_OnOverlapBegin::SweepResult' has a wrong offset!");

// Function OrionGame.OrionWell_Base.OnOverlapEnd
// 0x0020 (0x0020 - 0x0000)
struct OrionWell_Base_OnOverlapEnd final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(OrionWell_Base_OnOverlapEnd) == 0x000008, "Wrong alignment on OrionWell_Base_OnOverlapEnd");
static_assert(sizeof(OrionWell_Base_OnOverlapEnd) == 0x000020, "Wrong size on OrionWell_Base_OnOverlapEnd");
static_assert(offsetof(OrionWell_Base_OnOverlapEnd, OverlappedComp) == 0x000000, "Member 'OrionWell_Base_OnOverlapEnd::OverlappedComp' has a wrong offset!");
static_assert(offsetof(OrionWell_Base_OnOverlapEnd, OtherActor) == 0x000008, "Member 'OrionWell_Base_OnOverlapEnd::OtherActor' has a wrong offset!");
static_assert(offsetof(OrionWell_Base_OnOverlapEnd, OtherComp) == 0x000010, "Member 'OrionWell_Base_OnOverlapEnd::OtherComp' has a wrong offset!");
static_assert(offsetof(OrionWell_Base_OnOverlapEnd, OtherBodyIndex) == 0x000018, "Member 'OrionWell_Base_OnOverlapEnd::OtherBodyIndex' has a wrong offset!");

// Function OrionGame.OrionWell_Base.OnRep_WellStateUpdate
// 0x0001 (0x0001 - 0x0000)
struct OrionWell_Base_OnRep_WellStateUpdate final
{
public:
	EOrionWellState                               OldState;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionWell_Base_OnRep_WellStateUpdate) == 0x000001, "Wrong alignment on OrionWell_Base_OnRep_WellStateUpdate");
static_assert(sizeof(OrionWell_Base_OnRep_WellStateUpdate) == 0x000001, "Wrong size on OrionWell_Base_OnRep_WellStateUpdate");
static_assert(offsetof(OrionWell_Base_OnRep_WellStateUpdate, OldState) == 0x000000, "Member 'OrionWell_Base_OnRep_WellStateUpdate::OldState' has a wrong offset!");

// Function OrionGame.OrionWell_Base.ShowRigGatherAmount
// 0x0004 (0x0004 - 0x0000)
struct OrionWell_Base_ShowRigGatherAmount final
{
public:
	float                                         AmountGathered;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionWell_Base_ShowRigGatherAmount) == 0x000004, "Wrong alignment on OrionWell_Base_ShowRigGatherAmount");
static_assert(sizeof(OrionWell_Base_ShowRigGatherAmount) == 0x000004, "Wrong size on OrionWell_Base_ShowRigGatherAmount");
static_assert(offsetof(OrionWell_Base_ShowRigGatherAmount, AmountGathered) == 0x000000, "Member 'OrionWell_Base_ShowRigGatherAmount::AmountGathered' has a wrong offset!");

// Function OrionGame.OrionWell_Base.UpdateCollectionPadOverlaps
// 0x0008 (0x0008 - 0x0000)
struct OrionWell_Base_UpdateCollectionPadOverlaps final
{
public:
	class AActor*                                 InActorToUpdate;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionWell_Base_UpdateCollectionPadOverlaps) == 0x000008, "Wrong alignment on OrionWell_Base_UpdateCollectionPadOverlaps");
static_assert(sizeof(OrionWell_Base_UpdateCollectionPadOverlaps) == 0x000008, "Wrong size on OrionWell_Base_UpdateCollectionPadOverlaps");
static_assert(offsetof(OrionWell_Base_UpdateCollectionPadOverlaps, InActorToUpdate) == 0x000000, "Member 'OrionWell_Base_UpdateCollectionPadOverlaps::InActorToUpdate' has a wrong offset!");

// Function OrionGame.OrionWell_Base.GetMaxResource
// 0x0004 (0x0004 - 0x0000)
struct OrionWell_Base_GetMaxResource final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionWell_Base_GetMaxResource) == 0x000004, "Wrong alignment on OrionWell_Base_GetMaxResource");
static_assert(sizeof(OrionWell_Base_GetMaxResource) == 0x000004, "Wrong size on OrionWell_Base_GetMaxResource");
static_assert(offsetof(OrionWell_Base_GetMaxResource, ReturnValue) == 0x000000, "Member 'OrionWell_Base_GetMaxResource::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionWell_Base.GetRemainingDeadZoneTime
// 0x0004 (0x0004 - 0x0000)
struct OrionWell_Base_GetRemainingDeadZoneTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionWell_Base_GetRemainingDeadZoneTime) == 0x000004, "Wrong alignment on OrionWell_Base_GetRemainingDeadZoneTime");
static_assert(sizeof(OrionWell_Base_GetRemainingDeadZoneTime) == 0x000004, "Wrong size on OrionWell_Base_GetRemainingDeadZoneTime");
static_assert(offsetof(OrionWell_Base_GetRemainingDeadZoneTime, ReturnValue) == 0x000000, "Member 'OrionWell_Base_GetRemainingDeadZoneTime::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionWell_Base.GetRemainingInitalSpawnDelay
// 0x0004 (0x0004 - 0x0000)
struct OrionWell_Base_GetRemainingInitalSpawnDelay final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionWell_Base_GetRemainingInitalSpawnDelay) == 0x000004, "Wrong alignment on OrionWell_Base_GetRemainingInitalSpawnDelay");
static_assert(sizeof(OrionWell_Base_GetRemainingInitalSpawnDelay) == 0x000004, "Wrong size on OrionWell_Base_GetRemainingInitalSpawnDelay");
static_assert(offsetof(OrionWell_Base_GetRemainingInitalSpawnDelay, ReturnValue) == 0x000000, "Member 'OrionWell_Base_GetRemainingInitalSpawnDelay::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionWell_Base.GetResource
// 0x0004 (0x0004 - 0x0000)
struct OrionWell_Base_GetResource final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionWell_Base_GetResource) == 0x000004, "Wrong alignment on OrionWell_Base_GetResource");
static_assert(sizeof(OrionWell_Base_GetResource) == 0x000004, "Wrong size on OrionWell_Base_GetResource");
static_assert(offsetof(OrionWell_Base_GetResource, ReturnValue) == 0x000000, "Member 'OrionWell_Base_GetResource::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionWell_Base.GetWellActiveTime
// 0x0004 (0x0004 - 0x0000)
struct OrionWell_Base_GetWellActiveTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionWell_Base_GetWellActiveTime) == 0x000004, "Wrong alignment on OrionWell_Base_GetWellActiveTime");
static_assert(sizeof(OrionWell_Base_GetWellActiveTime) == 0x000004, "Wrong size on OrionWell_Base_GetWellActiveTime");
static_assert(offsetof(OrionWell_Base_GetWellActiveTime, ReturnValue) == 0x000000, "Member 'OrionWell_Base_GetWellActiveTime::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionWell_Base.GetWellDeadZoneTime
// 0x0004 (0x0004 - 0x0000)
struct OrionWell_Base_GetWellDeadZoneTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionWell_Base_GetWellDeadZoneTime) == 0x000004, "Wrong alignment on OrionWell_Base_GetWellDeadZoneTime");
static_assert(sizeof(OrionWell_Base_GetWellDeadZoneTime) == 0x000004, "Wrong size on OrionWell_Base_GetWellDeadZoneTime");
static_assert(offsetof(OrionWell_Base_GetWellDeadZoneTime, ReturnValue) == 0x000000, "Member 'OrionWell_Base_GetWellDeadZoneTime::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionWell_Base.GetWellGeyserTime
// 0x0004 (0x0004 - 0x0000)
struct OrionWell_Base_GetWellGeyserTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionWell_Base_GetWellGeyserTime) == 0x000004, "Wrong alignment on OrionWell_Base_GetWellGeyserTime");
static_assert(sizeof(OrionWell_Base_GetWellGeyserTime) == 0x000004, "Wrong size on OrionWell_Base_GetWellGeyserTime");
static_assert(offsetof(OrionWell_Base_GetWellGeyserTime, ReturnValue) == 0x000000, "Member 'OrionWell_Base_GetWellGeyserTime::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionWell_Base.GetWellInitalSpawnDelay
// 0x0004 (0x0004 - 0x0000)
struct OrionWell_Base_GetWellInitalSpawnDelay final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionWell_Base_GetWellInitalSpawnDelay) == 0x000004, "Wrong alignment on OrionWell_Base_GetWellInitalSpawnDelay");
static_assert(sizeof(OrionWell_Base_GetWellInitalSpawnDelay) == 0x000004, "Wrong size on OrionWell_Base_GetWellInitalSpawnDelay");
static_assert(offsetof(OrionWell_Base_GetWellInitalSpawnDelay, ReturnValue) == 0x000000, "Member 'OrionWell_Base_GetWellInitalSpawnDelay::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionWell_Base.IsActive
// 0x0001 (0x0001 - 0x0000)
struct OrionWell_Base_IsActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionWell_Base_IsActive) == 0x000001, "Wrong alignment on OrionWell_Base_IsActive");
static_assert(sizeof(OrionWell_Base_IsActive) == 0x000001, "Wrong size on OrionWell_Base_IsActive");
static_assert(offsetof(OrionWell_Base_IsActive, ReturnValue) == 0x000000, "Member 'OrionWell_Base_IsActive::ReturnValue' has a wrong offset!");

// Function OrionGame.OrionWidget_HUDIndicatorOverlay.SetLocalPlayerController
// 0x0008 (0x0008 - 0x0000)
struct OrionWidget_HUDIndicatorOverlay_SetLocalPlayerController final
{
public:
	class APlayerController*                      LocalPlayerController;                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OrionWidget_HUDIndicatorOverlay_SetLocalPlayerController) == 0x000008, "Wrong alignment on OrionWidget_HUDIndicatorOverlay_SetLocalPlayerController");
static_assert(sizeof(OrionWidget_HUDIndicatorOverlay_SetLocalPlayerController) == 0x000008, "Wrong size on OrionWidget_HUDIndicatorOverlay_SetLocalPlayerController");
static_assert(offsetof(OrionWidget_HUDIndicatorOverlay_SetLocalPlayerController, LocalPlayerController) == 0x000000, "Member 'OrionWidget_HUDIndicatorOverlay_SetLocalPlayerController::LocalPlayerController' has a wrong offset!");

// Function OrionGame.PlayerBotSpawner.SetPosition
// 0x0001 (0x0001 - 0x0000)
struct PlayerBotSpawner_SetPosition final
{
public:
	EOrionPosition                                InPosition;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerBotSpawner_SetPosition) == 0x000001, "Wrong alignment on PlayerBotSpawner_SetPosition");
static_assert(sizeof(PlayerBotSpawner_SetPosition) == 0x000001, "Wrong size on PlayerBotSpawner_SetPosition");
static_assert(offsetof(PlayerBotSpawner_SetPosition, InPosition) == 0x000000, "Member 'PlayerBotSpawner_SetPosition::InPosition' has a wrong offset!");

// Function OrionGame.PlayerBotSpawner.Spawn
// 0x0008 (0x0008 - 0x0000)
struct PlayerBotSpawner_Spawn final
{
public:
	class AOrionAIBot*                            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerBotSpawner_Spawn) == 0x000008, "Wrong alignment on PlayerBotSpawner_Spawn");
static_assert(sizeof(PlayerBotSpawner_Spawn) == 0x000008, "Wrong size on PlayerBotSpawner_Spawn");
static_assert(offsetof(PlayerBotSpawner_Spawn, ReturnValue) == 0x000000, "Member 'PlayerBotSpawner_Spawn::ReturnValue' has a wrong offset!");

// Function OrionGame.PlayerBotSpawner.GetTeamNum
// 0x0001 (0x0001 - 0x0000)
struct PlayerBotSpawner_GetTeamNum final
{
public:
	EOrionTeam                                    ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerBotSpawner_GetTeamNum) == 0x000001, "Wrong alignment on PlayerBotSpawner_GetTeamNum");
static_assert(sizeof(PlayerBotSpawner_GetTeamNum) == 0x000001, "Wrong size on PlayerBotSpawner_GetTeamNum");
static_assert(offsetof(PlayerBotSpawner_GetTeamNum, ReturnValue) == 0x000000, "Member 'PlayerBotSpawner_GetTeamNum::ReturnValue' has a wrong offset!");

// Function OrionGame.ScalableFloatUtils.GetValue
// 0x0030 (0x0030 - 0x0000)
struct ScalableFloatUtils_GetValue final
{
public:
	struct FScalableFloat                         Input;                                             // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0028(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ScalableFloatUtils_GetValue) == 0x000008, "Wrong alignment on ScalableFloatUtils_GetValue");
static_assert(sizeof(ScalableFloatUtils_GetValue) == 0x000030, "Wrong size on ScalableFloatUtils_GetValue");
static_assert(offsetof(ScalableFloatUtils_GetValue, Input) == 0x000000, "Member 'ScalableFloatUtils_GetValue::Input' has a wrong offset!");
static_assert(offsetof(ScalableFloatUtils_GetValue, ReturnValue) == 0x000028, "Member 'ScalableFloatUtils_GetValue::ReturnValue' has a wrong offset!");

// Function OrionGame.ScalableFloatUtils.GetValueAtLevel
// 0x0030 (0x0030 - 0x0000)
struct ScalableFloatUtils_GetValueAtLevel final
{
public:
	struct FScalableFloat                         Input;                                             // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         Level;                                             // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x002C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ScalableFloatUtils_GetValueAtLevel) == 0x000008, "Wrong alignment on ScalableFloatUtils_GetValueAtLevel");
static_assert(sizeof(ScalableFloatUtils_GetValueAtLevel) == 0x000030, "Wrong size on ScalableFloatUtils_GetValueAtLevel");
static_assert(offsetof(ScalableFloatUtils_GetValueAtLevel, Input) == 0x000000, "Member 'ScalableFloatUtils_GetValueAtLevel::Input' has a wrong offset!");
static_assert(offsetof(ScalableFloatUtils_GetValueAtLevel, Level) == 0x000028, "Member 'ScalableFloatUtils_GetValueAtLevel::Level' has a wrong offset!");
static_assert(offsetof(ScalableFloatUtils_GetValueAtLevel, ReturnValue) == 0x00002C, "Member 'ScalableFloatUtils_GetValueAtLevel::ReturnValue' has a wrong offset!");

// Function OrionGame.ScalableFloatUtils.IsStatic
// 0x0030 (0x0030 - 0x0000)
struct ScalableFloatUtils_IsStatic final
{
public:
	struct FScalableFloat                         Input;                                             // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ScalableFloatUtils_IsStatic) == 0x000008, "Wrong alignment on ScalableFloatUtils_IsStatic");
static_assert(sizeof(ScalableFloatUtils_IsStatic) == 0x000030, "Wrong size on ScalableFloatUtils_IsStatic");
static_assert(offsetof(ScalableFloatUtils_IsStatic, Input) == 0x000000, "Member 'ScalableFloatUtils_IsStatic::Input' has a wrong offset!");
static_assert(offsetof(ScalableFloatUtils_IsStatic, ReturnValue) == 0x000028, "Member 'ScalableFloatUtils_IsStatic::ReturnValue' has a wrong offset!");

// Function OrionGame.ScalableFloatUtils.SetScalingValue
// 0x0040 (0x0040 - 0x0000)
struct ScalableFloatUtils_SetScalingValue final
{
public:
	struct FScalableFloat                         Input;                                             // 0x0000(0x0028)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         InCoeffecient;                                     // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   InRowName;                                         // 0x0030(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveTable*                            InTable;                                           // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ScalableFloatUtils_SetScalingValue) == 0x000008, "Wrong alignment on ScalableFloatUtils_SetScalingValue");
static_assert(sizeof(ScalableFloatUtils_SetScalingValue) == 0x000040, "Wrong size on ScalableFloatUtils_SetScalingValue");
static_assert(offsetof(ScalableFloatUtils_SetScalingValue, Input) == 0x000000, "Member 'ScalableFloatUtils_SetScalingValue::Input' has a wrong offset!");
static_assert(offsetof(ScalableFloatUtils_SetScalingValue, InCoeffecient) == 0x000028, "Member 'ScalableFloatUtils_SetScalingValue::InCoeffecient' has a wrong offset!");
static_assert(offsetof(ScalableFloatUtils_SetScalingValue, InRowName) == 0x000030, "Member 'ScalableFloatUtils_SetScalingValue::InRowName' has a wrong offset!");
static_assert(offsetof(ScalableFloatUtils_SetScalingValue, InTable) == 0x000038, "Member 'ScalableFloatUtils_SetScalingValue::InTable' has a wrong offset!");

// Function OrionGame.ScalableFloatUtils.SetValue
// 0x0030 (0x0030 - 0x0000)
struct ScalableFloatUtils_SetValue final
{
public:
	struct FScalableFloat                         Input;                                             // 0x0000(0x0028)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         NewValue;                                          // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ScalableFloatUtils_SetValue) == 0x000008, "Wrong alignment on ScalableFloatUtils_SetValue");
static_assert(sizeof(ScalableFloatUtils_SetValue) == 0x000030, "Wrong size on ScalableFloatUtils_SetValue");
static_assert(offsetof(ScalableFloatUtils_SetValue, Input) == 0x000000, "Member 'ScalableFloatUtils_SetValue::Input' has a wrong offset!");
static_assert(offsetof(ScalableFloatUtils_SetValue, NewValue) == 0x000028, "Member 'ScalableFloatUtils_SetValue::NewValue' has a wrong offset!");

// Function OrionGame.ScalableFloatUtils.ToSimpleString
// 0x0038 (0x0038 - 0x0000)
struct ScalableFloatUtils_ToSimpleString final
{
public:
	struct FScalableFloat                         Input;                                             // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ScalableFloatUtils_ToSimpleString) == 0x000008, "Wrong alignment on ScalableFloatUtils_ToSimpleString");
static_assert(sizeof(ScalableFloatUtils_ToSimpleString) == 0x000038, "Wrong size on ScalableFloatUtils_ToSimpleString");
static_assert(offsetof(ScalableFloatUtils_ToSimpleString, Input) == 0x000000, "Member 'ScalableFloatUtils_ToSimpleString::Input' has a wrong offset!");
static_assert(offsetof(ScalableFloatUtils_ToSimpleString, ReturnValue) == 0x000028, "Member 'ScalableFloatUtils_ToSimpleString::ReturnValue' has a wrong offset!");

// Function OrionGame.TeamCommunicationsActor.Blueprint_StartHidingBeforeDestroy
// 0x0001 (0x0001 - 0x0000)
struct TeamCommunicationsActor_Blueprint_StartHidingBeforeDestroy final
{
public:
	bool                                          bIsOwningPlayer;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TeamCommunicationsActor_Blueprint_StartHidingBeforeDestroy) == 0x000001, "Wrong alignment on TeamCommunicationsActor_Blueprint_StartHidingBeforeDestroy");
static_assert(sizeof(TeamCommunicationsActor_Blueprint_StartHidingBeforeDestroy) == 0x000001, "Wrong size on TeamCommunicationsActor_Blueprint_StartHidingBeforeDestroy");
static_assert(offsetof(TeamCommunicationsActor_Blueprint_StartHidingBeforeDestroy, bIsOwningPlayer) == 0x000000, "Member 'TeamCommunicationsActor_Blueprint_StartHidingBeforeDestroy::bIsOwningPlayer' has a wrong offset!");

// Function OrionGame.TeamCommunicationsActor.HideVisuals
// 0x0001 (0x0001 - 0x0000)
struct TeamCommunicationsActor_HideVisuals final
{
public:
	bool                                          bIsOwningPlayer;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TeamCommunicationsActor_HideVisuals) == 0x000001, "Wrong alignment on TeamCommunicationsActor_HideVisuals");
static_assert(sizeof(TeamCommunicationsActor_HideVisuals) == 0x000001, "Wrong size on TeamCommunicationsActor_HideVisuals");
static_assert(offsetof(TeamCommunicationsActor_HideVisuals, bIsOwningPlayer) == 0x000000, "Member 'TeamCommunicationsActor_HideVisuals::bIsOwningPlayer' has a wrong offset!");

// Function OrionGame.TeamCommunicationsActor.ShowVisuals
// 0x0001 (0x0001 - 0x0000)
struct TeamCommunicationsActor_ShowVisuals final
{
public:
	bool                                          bIsOwningPlayer;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TeamCommunicationsActor_ShowVisuals) == 0x000001, "Wrong alignment on TeamCommunicationsActor_ShowVisuals");
static_assert(sizeof(TeamCommunicationsActor_ShowVisuals) == 0x000001, "Wrong size on TeamCommunicationsActor_ShowVisuals");
static_assert(offsetof(TeamCommunicationsActor_ShowVisuals, bIsOwningPlayer) == 0x000000, "Member 'TeamCommunicationsActor_ShowVisuals::bIsOwningPlayer' has a wrong offset!");

// Function OrionGame.TimeAgoLibrary.RefreshTime
// 0x0040 (0x0040 - 0x0000)
struct TimeAgoLibrary_RefreshTime final
{
public:
	struct FTimeAgo                               TimeAgo;                                           // 0x0000(0x0038)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FDateTime                              InTimepoint;                                       // 0x0038(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TimeAgoLibrary_RefreshTime) == 0x000008, "Wrong alignment on TimeAgoLibrary_RefreshTime");
static_assert(sizeof(TimeAgoLibrary_RefreshTime) == 0x000040, "Wrong size on TimeAgoLibrary_RefreshTime");
static_assert(offsetof(TimeAgoLibrary_RefreshTime, TimeAgo) == 0x000000, "Member 'TimeAgoLibrary_RefreshTime::TimeAgo' has a wrong offset!");
static_assert(offsetof(TimeAgoLibrary_RefreshTime, InTimepoint) == 0x000038, "Member 'TimeAgoLibrary_RefreshTime::InTimepoint' has a wrong offset!");

// Function OrionGame.TimeAgoLibrary.RegisterEditableText
// 0x0048 (0x0048 - 0x0000)
struct TimeAgoLibrary_RegisterEditableText final
{
public:
	struct FTimeAgo                               TimeAgo;                                           // 0x0000(0x0038)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UMultiLineEditableText*                 InEditableText;                                    // 0x0038(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              InTimepoint;                                       // 0x0040(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TimeAgoLibrary_RegisterEditableText) == 0x000008, "Wrong alignment on TimeAgoLibrary_RegisterEditableText");
static_assert(sizeof(TimeAgoLibrary_RegisterEditableText) == 0x000048, "Wrong size on TimeAgoLibrary_RegisterEditableText");
static_assert(offsetof(TimeAgoLibrary_RegisterEditableText, TimeAgo) == 0x000000, "Member 'TimeAgoLibrary_RegisterEditableText::TimeAgo' has a wrong offset!");
static_assert(offsetof(TimeAgoLibrary_RegisterEditableText, InEditableText) == 0x000038, "Member 'TimeAgoLibrary_RegisterEditableText::InEditableText' has a wrong offset!");
static_assert(offsetof(TimeAgoLibrary_RegisterEditableText, InTimepoint) == 0x000040, "Member 'TimeAgoLibrary_RegisterEditableText::InTimepoint' has a wrong offset!");

// Function OrionGame.TimeAgoLibrary.RegisterText
// 0x0048 (0x0048 - 0x0000)
struct TimeAgoLibrary_RegisterText final
{
public:
	struct FTimeAgo                               TimeAgo;                                           // 0x0000(0x0038)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UTextBlock*                             InTextBlock;                                       // 0x0038(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              InTimepoint;                                       // 0x0040(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TimeAgoLibrary_RegisterText) == 0x000008, "Wrong alignment on TimeAgoLibrary_RegisterText");
static_assert(sizeof(TimeAgoLibrary_RegisterText) == 0x000048, "Wrong size on TimeAgoLibrary_RegisterText");
static_assert(offsetof(TimeAgoLibrary_RegisterText, TimeAgo) == 0x000000, "Member 'TimeAgoLibrary_RegisterText::TimeAgo' has a wrong offset!");
static_assert(offsetof(TimeAgoLibrary_RegisterText, InTextBlock) == 0x000038, "Member 'TimeAgoLibrary_RegisterText::InTextBlock' has a wrong offset!");
static_assert(offsetof(TimeAgoLibrary_RegisterText, InTimepoint) == 0x000040, "Member 'TimeAgoLibrary_RegisterText::InTimepoint' has a wrong offset!");

// Function OrionGame.TimeAgoLibrary.RegisterTextBox
// 0x0048 (0x0048 - 0x0000)
struct TimeAgoLibrary_RegisterTextBox final
{
public:
	struct FTimeAgo                               TimeAgo;                                           // 0x0000(0x0038)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UMultiLineEditableTextBox*              InEditableTextBox;                                 // 0x0038(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              InTimepoint;                                       // 0x0040(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TimeAgoLibrary_RegisterTextBox) == 0x000008, "Wrong alignment on TimeAgoLibrary_RegisterTextBox");
static_assert(sizeof(TimeAgoLibrary_RegisterTextBox) == 0x000048, "Wrong size on TimeAgoLibrary_RegisterTextBox");
static_assert(offsetof(TimeAgoLibrary_RegisterTextBox, TimeAgo) == 0x000000, "Member 'TimeAgoLibrary_RegisterTextBox::TimeAgo' has a wrong offset!");
static_assert(offsetof(TimeAgoLibrary_RegisterTextBox, InEditableTextBox) == 0x000038, "Member 'TimeAgoLibrary_RegisterTextBox::InEditableTextBox' has a wrong offset!");
static_assert(offsetof(TimeAgoLibrary_RegisterTextBox, InTimepoint) == 0x000040, "Member 'TimeAgoLibrary_RegisterTextBox::InTimepoint' has a wrong offset!");

// Function OrionGame.WidgetStack.PushWidget
// 0x0008 (0x0008 - 0x0000)
struct WidgetStack_PushWidget final
{
public:
	class UWidget*                                InWidget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WidgetStack_PushWidget) == 0x000008, "Wrong alignment on WidgetStack_PushWidget");
static_assert(sizeof(WidgetStack_PushWidget) == 0x000008, "Wrong size on WidgetStack_PushWidget");
static_assert(offsetof(WidgetStack_PushWidget, InWidget) == 0x000000, "Member 'WidgetStack_PushWidget::InWidget' has a wrong offset!");

// Function OrionGame.WidgetStack.NumWidgets
// 0x0004 (0x0004 - 0x0000)
struct WidgetStack_NumWidgets final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WidgetStack_NumWidgets) == 0x000004, "Wrong alignment on WidgetStack_NumWidgets");
static_assert(sizeof(WidgetStack_NumWidgets) == 0x000004, "Wrong size on WidgetStack_NumWidgets");
static_assert(offsetof(WidgetStack_NumWidgets, ReturnValue) == 0x000000, "Member 'WidgetStack_NumWidgets::ReturnValue' has a wrong offset!");

}

