#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: OrionUI

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "BlueprintContext_structs.hpp"


namespace SDK
{

// Enum OrionUI.EOrionSortingTypes
// NumValues: 0x0005
enum class EOrionSortingTypes : uint8
{
	CardCollection                           = 0,
	GemCollection                            = 1,
	DeckBuilderCards                         = 2,
	DeckBuilderGems                          = 3,
	MAX                                      = 4,
};

// Enum OrionUI.EOrionButtonState
// NumValues: 0x0004
enum class EOrionButtonState : uint8
{
	Normal                                   = 0,
	Over                                     = 1,
	Down                                     = 2,
	EOrionButtonState_MAX                    = 3,
};

// Enum OrionUI.EOrionTableViewSelectionMode
// NumValues: 0x0003
enum class EOrionTableViewSelectionMode : uint8
{
	None                                     = 0,
	Single                                   = 1,
	EOrionTableViewSelectionMode_MAX         = 2,
};

// Enum OrionUI.EPlayerSlotSearchState
// NumValues: 0x0003
enum class EPlayerSlotSearchState : uint8
{
	NotFound                                 = 0,
	Found                                    = 1,
	MAX                                      = 2,
};

// Enum OrionUI.EBannerListItemType
// NumValues: 0x0003
enum class EBannerListItemType : uint8
{
	NormalBanner                             = 0,
	EmptyBanner                              = 1,
	EBannerListItemType_MAX                  = 2,
};

// Enum OrionUI.ETextPositionType
// NumValues: 0x0006
enum class ETextPositionType : uint8
{
	Default                                  = 0,
	Above                                    = 1,
	Below                                    = 2,
	Left                                     = 3,
	Right                                    = 4,
	ETextPositionType_MAX                    = 5,
};

// Enum OrionUI.EDateType
// NumValues: 0x0004
enum class EDateType : uint8
{
	None                                     = 0,
	Coming                                   = 1,
	Ending                                   = 2,
	EDateType_MAX                            = 3,
};

// Enum OrionUI.ETileType
// NumValues: 0x000B
enum class ETileType : uint8
{
	Invalid                                  = 0,
	Default                                  = 1,
	Website                                  = 2,
	Video                                    = 3,
	Replay                                   = 4,
	Marketplace                              = 5,
	Navigation                               = 6,
	Text                                     = 7,
	Custom                                   = 8,
	BoostExhausted                           = 9,
	ETileType_MAX                            = 10,
};

// Enum OrionUI.EOrionButtonSound
// NumValues: 0x0003
enum class EOrionButtonSound : uint8
{
	Hover                                    = 0,
	Pressed                                  = 1,
	EOrionButtonSound_MAX                    = 2,
};

// Enum OrionUI.ECardShopState
// NumValues: 0x0004
enum class ECardShopState : uint8
{
	DeckSelect                               = 0,
	Normal                                   = 1,
	CardFloating                             = 2,
	MAX                                      = 3,
};

// Enum OrionUI.EEquipSlotIndex
// NumValues: 0x0004
enum class EEquipSlotIndex : uint8
{
	One                                      = 0,
	Two                                      = 1,
	Three                                    = 2,
	MAX                                      = 3,
};

// Enum OrionUI.ECollectionType
// NumValues: 0x0009
enum class ECollectionType : uint8
{
	Hero                                     = 0,
	LootCrate                                = 1,
	Chest                                    = 2,
	Card                                     = 3,
	Gem                                      = 4,
	Deck                                     = 5,
	Banner                                   = 6,
	BannerThumbnail                          = 7,
	ECollectionType_MAX                      = 8,
};

// Enum OrionUI.EOrionDailyRewardPreviewTotalDays
// NumValues: 0x0005
enum class EOrionDailyRewardPreviewTotalDays : uint8
{
	Days15                                   = 0,
	Days30                                   = 1,
	Days60                                   = 2,
	Days90                                   = 3,
	EOrionDailyRewardPreviewTotalDays_MAX    = 4,
};

// Enum OrionUI.EOrionDailyRewardDayType
// NumValues: 0x0004
enum class EOrionDailyRewardDayType : uint8
{
	Past                                     = 0,
	Today                                    = 1,
	Future                                   = 2,
	EOrionDailyRewardDayType_MAX             = 3,
};

// Enum OrionUI.EDynamicBoxType
// NumValues: 0x0005
enum class EDynamicBoxType : uint8
{
	Horizontal                               = 0,
	Vertical                                 = 1,
	Wrap                                     = 2,
	Overlay                                  = 3,
	EDynamicBoxType_MAX                      = 4,
};

// Enum OrionUI.EOrionFilterHeaderButtonType
// NumValues: 0x0003
enum class EOrionFilterHeaderButtonType : uint8
{
	Cards                                    = 0,
	Gems                                     = 1,
	MAX                                      = 2,
};

// Enum OrionUI.EHandEntryVisualState
// NumValues: 0x0003
enum class EHandEntryVisualState : uint8
{
	Normal                                   = 0,
	UnequipTarget                            = 1,
	EHandEntryVisualState_MAX                = 2,
};

// Enum OrionUI.EOrionHeroTooltipStatus
// NumValues: 0x0004
enum class EOrionHeroTooltipStatus : uint8
{
	Normal                                   = 0,
	Locked                                   = 1,
	Recommended                              = 2,
	EOrionHeroTooltipStatus_MAX              = 3,
};

// Enum OrionUI.EOrionHUDWidgetType
// NumValues: 0x0023
enum class EOrionHUDWidgetType : uint8
{
	Reticle                                  = 0,
	GameEventMessages                        = 1,
	RespawnTimer                             = 2,
	AbilityNotReady                          = 3,
	MiniMap                                  = 4,
	RespawnBarTimer                          = 5,
	DamageOverlay                            = 6,
	MenuManager                              = 7,
	IndicatorOverlay                         = 8,
	WIP                                      = 9,
	AbilityWidgets                           = 10,
	PlayerStatus                             = 11,
	CardAbilities                            = 12,
	MatchTime                                = 13,
	CoreWidgets                              = 14,
	BuffWidets                               = 15,
	KDAWidget                                = 16,
	DigitalFlame                             = 17,
	CombatMessages                           = 18,
	WellProgress                             = 19,
	AlphaBuildBadge                          = 20,
	ChatWidget                               = 21,
	AbilityConfirm                           = 22,
	QuestLog                                 = 23,
	TeamFrame                                = 24,
	TowerHealthBar                           = 25,
	HotkeyPanel                              = 26,
	StatusFeed                               = 27,
	KillFeed                                 = 28,
	TeamCommFeed                             = 29,
	MapMessageFeed                           = 30,
	AbilityFailFeed                          = 31,
	ActionPrompt                             = 32,
	BuffMessageArea                          = 33,
	MAX                                      = 34,
};

// Enum OrionUI.EAbilitySource
// NumValues: 0x0003
enum class EAbilitySource : uint32
{
	EquippedCard                             = 0,
	Gem                                      = 1,
	EAbilitySource_MAX                       = 2,
};

// Enum OrionUI.EKillFeedParticipantType
// NumValues: 0x0004
enum class EKillFeedParticipantType : uint8
{
	Self                                     = 0,
	Friendly                                 = 1,
	Enemy                                    = 2,
	EKillFeedParticipantType_MAX             = 3,
};

// Enum OrionUI.EOrionLegacySlateWidgetType
// NumValues: 0x0004
enum class EOrionLegacySlateWidgetType : uint8
{
	None                                     = 0,
	Watermark                                = 1,
	DeveloperMenu                            = 2,
	MAX                                      = 3,
};

// Enum OrionUI.EOrionSpinState
// NumValues: 0x0005
enum class EOrionSpinState : uint8
{
	Inactive                                 = 0,
	Opening                                  = 1,
	Spinning                                 = 2,
	SlowingDown                              = 3,
	EOrionSpinState_MAX                      = 4,
};

// Enum OrionUI.EOrionHeroRankTier
// NumValues: 0x0005
enum class EOrionHeroRankTier : uint8
{
	None                                     = 0,
	Bronze                                   = 1,
	Silver                                   = 2,
	Gold                                     = 3,
	Max                                      = 4,
};

// Enum OrionUI.EPlayerActionPromptMessage
// NumValues: 0x0007
enum class EPlayerActionPromptMessage : uint8
{
	None                                     = 0,
	CriticallyWounded                        = 1,
	AbilityUpgradeAvailable                  = 2,
	OpenShop                                 = 3,
	SelectDeck                               = 4,
	SpendCoins                               = 5,
	EPlayerActionPromptMessage_MAX           = 6,
};

// Enum OrionUI.EOrionNetworkReplayLiveType
// NumValues: 0x0004
enum class EOrionNetworkReplayLiveType : uint8
{
	Either                                   = 0,
	LiveOnly                                 = 1,
	CompletedOnly                            = 2,
	EOrionNetworkReplayLiveType_MAX          = 3,
};

// Enum OrionUI.EOrionNetworkReplayFilter
// NumValues: 0x0009
enum class EOrionNetworkReplayFilter : uint8
{
	Invalid                                  = 0,
	Personal                                 = 1,
	Friends                                  = 2,
	LiveAll                                  = 3,
	LiveFriends                              = 4,
	Recent                                   = 5,
	Featured                                 = 6,
	Search                                   = 7,
	EOrionNetworkReplayFilter_MAX            = 8,
};

// Enum OrionUI.EReplayDetailsState
// NumValues: 0x0004
enum class EReplayDetailsState : uint8
{
	Invalid                                  = 0,
	Requested                                = 1,
	Ready                                    = 2,
	EReplayDetailsState_MAX                  = 3,
};

// Enum OrionUI.EOrionRewardWidgetState
// NumValues: 0x0005
enum class EOrionRewardWidgetState : uint8
{
	Ineligible                               = 0,
	Earned                                   = 1,
	Normal                                   = 2,
	Active                                   = 3,
	EOrionRewardWidgetState_MAX              = 4,
};

// Enum OrionUI.ERollingTextWidgetState
// NumValues: 0x0004
enum class ERollingTextWidgetState : uint8
{
	Displaying                               = 0,
	RollingOut                               = 1,
	RollingIn                                = 2,
	ERollingTextWidgetState_MAX              = 3,
};

// Enum OrionUI.EOrionDeckGemSortOptions
// NumValues: 0x0004
enum class EOrionDeckGemSortOptions : uint8
{
	Shape                                    = 0,
	Name                                     = 1,
	Rarity                                   = 2,
	MAX                                      = 3,
};

// Enum OrionUI.EOrionDeckCardSortOptions
// NumValues: 0x0006
enum class EOrionDeckCardSortOptions : uint8
{
	Cost                                     = 0,
	Affinity                                 = 1,
	Level                                    = 2,
	Rarity                                   = 3,
	Name                                     = 4,
	MAX                                      = 5,
};

// Enum OrionUI.EOrionGemSortOptions
// NumValues: 0x0005
enum class EOrionGemSortOptions : uint8
{
	Stone                                    = 0,
	Shape                                    = 1,
	Name                                     = 2,
	Rarity                                   = 3,
	MAX                                      = 4,
};

// Enum OrionUI.EOrionCardSortOptions
// NumValues: 0x0007
enum class EOrionCardSortOptions : uint8
{
	Affinity                                 = 0,
	Cost                                     = 1,
	Level                                    = 2,
	Rarity                                   = 3,
	Name                                     = 4,
	Unlocked                                 = 5,
	MAX                                      = 6,
};

// Enum OrionUI.EOrionFrontEndContentFlow
// NumValues: 0x0010
enum class EOrionFrontEndContentFlow : uint8
{
	NewUserVideo                             = 0,
	Welcome                                  = 1,
	NewDawnVideo                             = 2,
	SovereignUpdate                          = 3,
	NewCardsUpdate                           = 4,
	DraftWarning                             = 5,
	CardOnboardPopup                         = 6,
	LoginBonus                               = 7,
	GiftBoxes                                = 8,
	MasteryOnboardPopup                      = 9,
	CMSPopup                                 = 10,
	MOTD                                     = 11,
	StartBackgroundMusic                     = 12,
	DeckBuilderPVPUnlocked                   = 13,
	FlowComplete                             = 14,
	EOrionFrontEndContentFlow_MAX            = 15,
};

// Enum OrionUI.ESortPriority
// NumValues: 0x0004
enum class ESortPriority : uint8
{
	NewestFirst                              = 0,
	OldestFirst                              = 1,
	Alphabetical                             = 2,
	ESortPriority_MAX                        = 3,
};

// Enum OrionUI.EOrionTabListType
// NumValues: 0x0004
enum class EOrionTabListType : uint8
{
	None                                     = 0,
	Primary                                  = 1,
	Secondary                                = 2,
	EOrionTabListType_MAX                    = 3,
};

// Enum OrionUI.EItemAlignment
// NumValues: 0x0006
enum class EItemAlignment : uint8
{
	EvenlyDistributed                        = 0,
	LeftAligned                              = 1,
	RightAligned                             = 2,
	CenterAligned                            = 3,
	Fill                                     = 4,
	EItemAlignment_MAX                       = 5,
};

// Enum OrionUI.EUnlockType
// NumValues: 0x0007
enum class EUnlockType : uint8
{
	None                                     = 0,
	CardLevel                                = 1,
	CardCrafting                             = 2,
	MasteryRank                              = 3,
	DeckSlot                                 = 4,
	HeroMastery                              = 5,
	Max                                      = 6,
};

// Enum OrionUI.EVaultScreenState
// NumValues: 0x0006
enum class EVaultScreenState : uint8
{
	Initializing                             = 0,
	Idle                                     = 1,
	Looping                                  = 2,
	Landing                                  = 3,
	Finished                                 = 4,
	EVaultScreenState_MAX                    = 5,
};

// Enum OrionUI.ETransitionCurve
// NumValues: 0x0008
enum class ETransitionCurve : uint8
{
	Linear                                   = 0,
	QuadIn                                   = 1,
	QuadOut                                  = 2,
	QuadInOut                                = 3,
	CubicIn                                  = 4,
	CubicOut                                 = 5,
	CubicInOut                               = 6,
	ETransitionCurve_MAX                     = 7,
};

// Enum OrionUI.EOrionSwitcherTransition
// NumValues: 0x0005
enum class EOrionSwitcherTransition : uint8
{
	FadeOnly                                 = 0,
	Horizontal                               = 1,
	Vertical                                 = 2,
	Zoom                                     = 3,
	EOrionSwitcherTransition_MAX             = 4,
};

// Enum OrionUI.EXPType
// NumValues: 0x0003
enum class EXPType : uint8
{
	CardPoints                               = 0,
	XP                                       = 1,
	EXPType_MAX                              = 2,
};

// ScriptStruct OrionUI.ReadyCheckDisplayData
// 0x0020 (0x0020 - 0x0000)
struct FReadyCheckDisplayData final
{
public:
	class UImage*                                 CheckImage;                                        // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x18];                                       // 0x0008(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReadyCheckDisplayData) == 0x000008, "Wrong alignment on FReadyCheckDisplayData");
static_assert(sizeof(FReadyCheckDisplayData) == 0x000020, "Wrong size on FReadyCheckDisplayData");
static_assert(offsetof(FReadyCheckDisplayData, CheckImage) == 0x000000, "Member 'FReadyCheckDisplayData::CheckImage' has a wrong offset!");

// ScriptStruct OrionUI.CollectionTabData
// 0x0038 (0x0038 - 0x0000)
struct FCollectionTabData final
{
public:
	ECollectionType                               CollectionType;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TabId;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TabName;                                           // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FName                                   SceneCamera;                                       // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TutorialID;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTabData) == 0x000008, "Wrong alignment on FCollectionTabData");
static_assert(sizeof(FCollectionTabData) == 0x000038, "Wrong size on FCollectionTabData");
static_assert(offsetof(FCollectionTabData, CollectionType) == 0x000000, "Member 'FCollectionTabData::CollectionType' has a wrong offset!");
static_assert(offsetof(FCollectionTabData, TabId) == 0x000008, "Member 'FCollectionTabData::TabId' has a wrong offset!");
static_assert(offsetof(FCollectionTabData, TabName) == 0x000010, "Member 'FCollectionTabData::TabName' has a wrong offset!");
static_assert(offsetof(FCollectionTabData, SceneCamera) == 0x000028, "Member 'FCollectionTabData::SceneCamera' has a wrong offset!");
static_assert(offsetof(FCollectionTabData, TutorialID) == 0x000030, "Member 'FCollectionTabData::TutorialID' has a wrong offset!");

// ScriptStruct OrionUI.TileDefinition
// 0x00A8 (0x00A8 - 0x0000)
struct FTileDefinition final
{
public:
	ETileType                                     Type;                                              // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TypeString;                                        // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Title;                                             // 0x0018(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Subtitle;                                          // 0x0030(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Eyebrow;                                           // 0x0048(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 Link;                                              // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GroupID;                                           // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              Countdown;                                         // 0x0080(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDateType                                     CountdownType;                                     // 0x0088(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MediaUrl;                                          // 0x0090(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsVisible;                                         // 0x00A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextPositionType                             TextPosition;                                      // 0x00A1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A2[0x2];                                       // 0x00A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TextBlockGapSize;                                  // 0x00A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTileDefinition) == 0x000008, "Wrong alignment on FTileDefinition");
static_assert(sizeof(FTileDefinition) == 0x0000A8, "Wrong size on FTileDefinition");
static_assert(offsetof(FTileDefinition, Type) == 0x000000, "Member 'FTileDefinition::Type' has a wrong offset!");
static_assert(offsetof(FTileDefinition, TypeString) == 0x000008, "Member 'FTileDefinition::TypeString' has a wrong offset!");
static_assert(offsetof(FTileDefinition, Title) == 0x000018, "Member 'FTileDefinition::Title' has a wrong offset!");
static_assert(offsetof(FTileDefinition, Subtitle) == 0x000030, "Member 'FTileDefinition::Subtitle' has a wrong offset!");
static_assert(offsetof(FTileDefinition, Eyebrow) == 0x000048, "Member 'FTileDefinition::Eyebrow' has a wrong offset!");
static_assert(offsetof(FTileDefinition, Link) == 0x000060, "Member 'FTileDefinition::Link' has a wrong offset!");
static_assert(offsetof(FTileDefinition, GroupID) == 0x000070, "Member 'FTileDefinition::GroupID' has a wrong offset!");
static_assert(offsetof(FTileDefinition, Countdown) == 0x000080, "Member 'FTileDefinition::Countdown' has a wrong offset!");
static_assert(offsetof(FTileDefinition, CountdownType) == 0x000088, "Member 'FTileDefinition::CountdownType' has a wrong offset!");
static_assert(offsetof(FTileDefinition, MediaUrl) == 0x000090, "Member 'FTileDefinition::MediaUrl' has a wrong offset!");
static_assert(offsetof(FTileDefinition, IsVisible) == 0x0000A0, "Member 'FTileDefinition::IsVisible' has a wrong offset!");
static_assert(offsetof(FTileDefinition, TextPosition) == 0x0000A1, "Member 'FTileDefinition::TextPosition' has a wrong offset!");
static_assert(offsetof(FTileDefinition, TextBlockGapSize) == 0x0000A4, "Member 'FTileDefinition::TextBlockGapSize' has a wrong offset!");

// ScriptStruct OrionUI.AIBotDifficultyDisplayEntry
// 0x0030 (0x0030 - 0x0000)
struct FAIBotDifficultyDisplayEntry final
{
public:
	class FText                                   DifficultyName;                                    // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   SelectorText;                                      // 0x0018(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIBotDifficultyDisplayEntry) == 0x000008, "Wrong alignment on FAIBotDifficultyDisplayEntry");
static_assert(sizeof(FAIBotDifficultyDisplayEntry) == 0x000030, "Wrong size on FAIBotDifficultyDisplayEntry");
static_assert(offsetof(FAIBotDifficultyDisplayEntry, DifficultyName) == 0x000000, "Member 'FAIBotDifficultyDisplayEntry::DifficultyName' has a wrong offset!");
static_assert(offsetof(FAIBotDifficultyDisplayEntry, SelectorText) == 0x000018, "Member 'FAIBotDifficultyDisplayEntry::SelectorText' has a wrong offset!");

// ScriptStruct OrionUI.SlotDescription
// 0x0020 (0x0020 - 0x0000)
struct FSlotDescription final
{
public:
	class FName                                   SlotName;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ColumnCount;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RowCount;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseFeaturedTextStyle;                             // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAutoScroll;                                 // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UOrionTileDataBlock>        CustomTileDataBlock;                               // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSlotDescription) == 0x000008, "Wrong alignment on FSlotDescription");
static_assert(sizeof(FSlotDescription) == 0x000020, "Wrong size on FSlotDescription");
static_assert(offsetof(FSlotDescription, SlotName) == 0x000000, "Member 'FSlotDescription::SlotName' has a wrong offset!");
static_assert(offsetof(FSlotDescription, ColumnCount) == 0x000008, "Member 'FSlotDescription::ColumnCount' has a wrong offset!");
static_assert(offsetof(FSlotDescription, RowCount) == 0x00000C, "Member 'FSlotDescription::RowCount' has a wrong offset!");
static_assert(offsetof(FSlotDescription, bUseFeaturedTextStyle) == 0x000010, "Member 'FSlotDescription::bUseFeaturedTextStyle' has a wrong offset!");
static_assert(offsetof(FSlotDescription, bEnableAutoScroll) == 0x000011, "Member 'FSlotDescription::bEnableAutoScroll' has a wrong offset!");
static_assert(offsetof(FSlotDescription, CustomTileDataBlock) == 0x000018, "Member 'FSlotDescription::CustomTileDataBlock' has a wrong offset!");

// ScriptStruct OrionUI.OrionStaticBuffInfo
// 0x0020 (0x0020 - 0x0000)
struct FOrionStaticBuffInfo final
{
public:
	struct FLinearColor                           BuffColor;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             BuffIcon;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           BuffTag;                                           // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionStaticBuffInfo) == 0x000008, "Wrong alignment on FOrionStaticBuffInfo");
static_assert(sizeof(FOrionStaticBuffInfo) == 0x000020, "Wrong size on FOrionStaticBuffInfo");
static_assert(offsetof(FOrionStaticBuffInfo, BuffColor) == 0x000000, "Member 'FOrionStaticBuffInfo::BuffColor' has a wrong offset!");
static_assert(offsetof(FOrionStaticBuffInfo, BuffIcon) == 0x000010, "Member 'FOrionStaticBuffInfo::BuffIcon' has a wrong offset!");
static_assert(offsetof(FOrionStaticBuffInfo, BuffTag) == 0x000018, "Member 'FOrionStaticBuffInfo::BuffTag' has a wrong offset!");

// ScriptStruct OrionUI.TeamCommGameEventInfo
// 0x0020 (0x0020 - 0x0000)
struct FTeamCommGameEventInfo final
{
public:
	class FName                                   MessageTypeIdentifier;                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   EventText;                                         // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTeamCommGameEventInfo) == 0x000008, "Wrong alignment on FTeamCommGameEventInfo");
static_assert(sizeof(FTeamCommGameEventInfo) == 0x000020, "Wrong size on FTeamCommGameEventInfo");
static_assert(offsetof(FTeamCommGameEventInfo, MessageTypeIdentifier) == 0x000000, "Member 'FTeamCommGameEventInfo::MessageTypeIdentifier' has a wrong offset!");
static_assert(offsetof(FTeamCommGameEventInfo, EventText) == 0x000008, "Member 'FTeamCommGameEventInfo::EventText' has a wrong offset!");

// ScriptStruct OrionUI.FloatingTextGlyphInfo
// 0x0004 (0x0004 - 0x0000)
struct FFloatingTextGlyphInfo final
{
public:
	float                                         CharWidthBias;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFloatingTextGlyphInfo) == 0x000004, "Wrong alignment on FFloatingTextGlyphInfo");
static_assert(sizeof(FFloatingTextGlyphInfo) == 0x000004, "Wrong size on FFloatingTextGlyphInfo");
static_assert(offsetof(FFloatingTextGlyphInfo, CharWidthBias) == 0x000000, "Member 'FFloatingTextGlyphInfo::CharWidthBias' has a wrong offset!");

// ScriptStruct OrionUI.OrionHUDWidgetEntry
// 0x0010 (0x0010 - 0x0000)
struct FOrionHUDWidgetEntry final
{
public:
	TArray<class UWidget*>                        Widgets;                                           // 0x0000(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionHUDWidgetEntry) == 0x000008, "Wrong alignment on FOrionHUDWidgetEntry");
static_assert(sizeof(FOrionHUDWidgetEntry) == 0x000010, "Wrong size on FOrionHUDWidgetEntry");
static_assert(offsetof(FOrionHUDWidgetEntry, Widgets) == 0x000000, "Member 'FOrionHUDWidgetEntry::Widgets' has a wrong offset!");

// ScriptStruct OrionUI.PlayerOverwriteBinding
// 0x0028 (0x0028 - 0x0000)
struct FPlayerOverwriteBinding final
{
public:
	class FName                                   BindingName;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   BindingDisplayName;                                // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	EKeyBindingType                               BindingType;                                       // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowModifierKeys;                                // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowMouseKeys;                                   // 0x0022(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x5];                                       // 0x0023(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerOverwriteBinding) == 0x000008, "Wrong alignment on FPlayerOverwriteBinding");
static_assert(sizeof(FPlayerOverwriteBinding) == 0x000028, "Wrong size on FPlayerOverwriteBinding");
static_assert(offsetof(FPlayerOverwriteBinding, BindingName) == 0x000000, "Member 'FPlayerOverwriteBinding::BindingName' has a wrong offset!");
static_assert(offsetof(FPlayerOverwriteBinding, BindingDisplayName) == 0x000008, "Member 'FPlayerOverwriteBinding::BindingDisplayName' has a wrong offset!");
static_assert(offsetof(FPlayerOverwriteBinding, BindingType) == 0x000020, "Member 'FPlayerOverwriteBinding::BindingType' has a wrong offset!");
static_assert(offsetof(FPlayerOverwriteBinding, bAllowModifierKeys) == 0x000021, "Member 'FPlayerOverwriteBinding::bAllowModifierKeys' has a wrong offset!");
static_assert(offsetof(FPlayerOverwriteBinding, bAllowMouseKeys) == 0x000022, "Member 'FPlayerOverwriteBinding::bAllowMouseKeys' has a wrong offset!");

// ScriptStruct OrionUI.PlayerOverwriteBindingCategory
// 0x0030 (0x0030 - 0x0000)
struct FPlayerOverwriteBindingCategory final
{
public:
	class FName                                   CategoryName;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   CategoryDisplayName;                               // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FPlayerOverwriteBinding>        Bindings;                                          // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerOverwriteBindingCategory) == 0x000008, "Wrong alignment on FPlayerOverwriteBindingCategory");
static_assert(sizeof(FPlayerOverwriteBindingCategory) == 0x000030, "Wrong size on FPlayerOverwriteBindingCategory");
static_assert(offsetof(FPlayerOverwriteBindingCategory, CategoryName) == 0x000000, "Member 'FPlayerOverwriteBindingCategory::CategoryName' has a wrong offset!");
static_assert(offsetof(FPlayerOverwriteBindingCategory, CategoryDisplayName) == 0x000008, "Member 'FPlayerOverwriteBindingCategory::CategoryDisplayName' has a wrong offset!");
static_assert(offsetof(FPlayerOverwriteBindingCategory, Bindings) == 0x000020, "Member 'FPlayerOverwriteBindingCategory::Bindings' has a wrong offset!");

// ScriptStruct OrionUI.OrionLootCrateResultEntryRow
// 0x0020 (0x0020 - 0x0000)
struct FOrionLootCrateResultEntryRow final
{
public:
	class UOrionMcpItemDefinition*                RewardItem;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x18];                                       // 0x0008(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionLootCrateResultEntryRow) == 0x000008, "Wrong alignment on FOrionLootCrateResultEntryRow");
static_assert(sizeof(FOrionLootCrateResultEntryRow) == 0x000020, "Wrong size on FOrionLootCrateResultEntryRow");
static_assert(offsetof(FOrionLootCrateResultEntryRow, RewardItem) == 0x000000, "Member 'FOrionLootCrateResultEntryRow::RewardItem' has a wrong offset!");

// ScriptStruct OrionUI.RoleHeroPair
// 0x0080 (0x0080 - 0x0000)
struct FRoleHeroPair final
{
public:
	class FText                                   RoleName;                                          // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UOrionHeroData>          SelectedMasteryHero;                               // 0x0018(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRecommended;                                    // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   HeroDescription;                                   // 0x0048(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   RoleDescription;                                   // 0x0060(0x0018)(Edit, NativeAccessSpecifierPublic)
	class UTexture2D*                             RoleImage;                                         // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoleHeroPair) == 0x000008, "Wrong alignment on FRoleHeroPair");
static_assert(sizeof(FRoleHeroPair) == 0x000080, "Wrong size on FRoleHeroPair");
static_assert(offsetof(FRoleHeroPair, RoleName) == 0x000000, "Member 'FRoleHeroPair::RoleName' has a wrong offset!");
static_assert(offsetof(FRoleHeroPair, SelectedMasteryHero) == 0x000018, "Member 'FRoleHeroPair::SelectedMasteryHero' has a wrong offset!");
static_assert(offsetof(FRoleHeroPair, bIsRecommended) == 0x000040, "Member 'FRoleHeroPair::bIsRecommended' has a wrong offset!");
static_assert(offsetof(FRoleHeroPair, HeroDescription) == 0x000048, "Member 'FRoleHeroPair::HeroDescription' has a wrong offset!");
static_assert(offsetof(FRoleHeroPair, RoleDescription) == 0x000060, "Member 'FRoleHeroPair::RoleDescription' has a wrong offset!");
static_assert(offsetof(FRoleHeroPair, RoleImage) == 0x000078, "Member 'FRoleHeroPair::RoleImage' has a wrong offset!");

// ScriptStruct OrionUI.OrionMuteInfo
// 0x0040 (0x0040 - 0x0000)
struct FOrionMuteInfo final
{
public:
	class AOrionPlayerState_Game*                 PlayerState;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMuted;                                          // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlayerName;                                        // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   HeroName;                                          // 0x0020(0x0018)(NativeAccessSpecifierPublic)
	class UTexture2D*                             HeroIcon;                                          // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionMuteInfo) == 0x000008, "Wrong alignment on FOrionMuteInfo");
static_assert(sizeof(FOrionMuteInfo) == 0x000040, "Wrong size on FOrionMuteInfo");
static_assert(offsetof(FOrionMuteInfo, PlayerState) == 0x000000, "Member 'FOrionMuteInfo::PlayerState' has a wrong offset!");
static_assert(offsetof(FOrionMuteInfo, bIsMuted) == 0x000008, "Member 'FOrionMuteInfo::bIsMuted' has a wrong offset!");
static_assert(offsetof(FOrionMuteInfo, PlayerName) == 0x000010, "Member 'FOrionMuteInfo::PlayerName' has a wrong offset!");
static_assert(offsetof(FOrionMuteInfo, HeroName) == 0x000020, "Member 'FOrionMuteInfo::HeroName' has a wrong offset!");
static_assert(offsetof(FOrionMuteInfo, HeroIcon) == 0x000038, "Member 'FOrionMuteInfo::HeroIcon' has a wrong offset!");

// ScriptStruct OrionUI.OrionQuestAlertInfo
// 0x0030 (0x0030 - 0x0000)
struct FOrionQuestAlertInfo final
{
public:
	class FName                                   QuestName;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   QuestText;                                         // 0x0008(0x0018)(NativeAccessSpecifierPublic)
	int32                                         StartCount;                                        // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewCount;                                          // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountMax;                                          // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionQuestAlertInfo) == 0x000008, "Wrong alignment on FOrionQuestAlertInfo");
static_assert(sizeof(FOrionQuestAlertInfo) == 0x000030, "Wrong size on FOrionQuestAlertInfo");
static_assert(offsetof(FOrionQuestAlertInfo, QuestName) == 0x000000, "Member 'FOrionQuestAlertInfo::QuestName' has a wrong offset!");
static_assert(offsetof(FOrionQuestAlertInfo, QuestText) == 0x000008, "Member 'FOrionQuestAlertInfo::QuestText' has a wrong offset!");
static_assert(offsetof(FOrionQuestAlertInfo, StartCount) == 0x000020, "Member 'FOrionQuestAlertInfo::StartCount' has a wrong offset!");
static_assert(offsetof(FOrionQuestAlertInfo, NewCount) == 0x000024, "Member 'FOrionQuestAlertInfo::NewCount' has a wrong offset!");
static_assert(offsetof(FOrionQuestAlertInfo, CountMax) == 0x000028, "Member 'FOrionQuestAlertInfo::CountMax' has a wrong offset!");

// ScriptStruct OrionUI.OrionRespawnWidgetEntry
// 0x0018 (0x0018 - 0x0000)
struct FOrionRespawnWidgetEntry final
{
public:
	float                                         TimeRemaining;                                     // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             HeroPortrait;                                      // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionRespawnTimerHeroIconWidget*       HeroIconWidget;                                    // 0x0010(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionRespawnWidgetEntry) == 0x000008, "Wrong alignment on FOrionRespawnWidgetEntry");
static_assert(sizeof(FOrionRespawnWidgetEntry) == 0x000018, "Wrong size on FOrionRespawnWidgetEntry");
static_assert(offsetof(FOrionRespawnWidgetEntry, TimeRemaining) == 0x000000, "Member 'FOrionRespawnWidgetEntry::TimeRemaining' has a wrong offset!");
static_assert(offsetof(FOrionRespawnWidgetEntry, HeroPortrait) == 0x000008, "Member 'FOrionRespawnWidgetEntry::HeroPortrait' has a wrong offset!");
static_assert(offsetof(FOrionRespawnWidgetEntry, HeroIconWidget) == 0x000010, "Member 'FOrionRespawnWidgetEntry::HeroIconWidget' has a wrong offset!");

// ScriptStruct OrionUI.OrionSortingUtils
// 0x0001 (0x0001 - 0x0000)
struct FOrionSortingUtils final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionSortingUtils) == 0x000001, "Wrong alignment on FOrionSortingUtils");
static_assert(sizeof(FOrionSortingUtils) == 0x000001, "Wrong size on FOrionSortingUtils");

// ScriptStruct OrionUI.OrionMenuEntry
// 0x0060 (0x0060 - 0x0000)
struct FOrionMenuEntry final
{
public:
	class FName                                   MenuId;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   MenuName;                                          // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   WidgetClass;                                       // 0x0020(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SceneName;                                         // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TutorialID;                                        // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UOrionTabButton>            TabButtonClass;                                    // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionMenuEntry) == 0x000008, "Wrong alignment on FOrionMenuEntry");
static_assert(sizeof(FOrionMenuEntry) == 0x000060, "Wrong size on FOrionMenuEntry");
static_assert(offsetof(FOrionMenuEntry, MenuId) == 0x000000, "Member 'FOrionMenuEntry::MenuId' has a wrong offset!");
static_assert(offsetof(FOrionMenuEntry, MenuName) == 0x000008, "Member 'FOrionMenuEntry::MenuName' has a wrong offset!");
static_assert(offsetof(FOrionMenuEntry, WidgetClass) == 0x000020, "Member 'FOrionMenuEntry::WidgetClass' has a wrong offset!");
static_assert(offsetof(FOrionMenuEntry, SceneName) == 0x000048, "Member 'FOrionMenuEntry::SceneName' has a wrong offset!");
static_assert(offsetof(FOrionMenuEntry, TutorialID) == 0x000050, "Member 'FOrionMenuEntry::TutorialID' has a wrong offset!");
static_assert(offsetof(FOrionMenuEntry, TabButtonClass) == 0x000058, "Member 'FOrionMenuEntry::TabButtonClass' has a wrong offset!");

// ScriptStruct OrionUI.TabListEntry
// 0x0068 (0x0068 - 0x0000)
struct FTabListEntry final
{
public:
	int32                                         TabIndex;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0008(0x0018)(NativeAccessSpecifierPublic)
	class UOrionTabButton*                        TabButton;                                         // 0x0020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ContentAssetID;                                    // 0x0028(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                ContentInstance;                                   // 0x0050(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SceneName;                                         // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TutorialID;                                        // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTabListEntry) == 0x000008, "Wrong alignment on FTabListEntry");
static_assert(sizeof(FTabListEntry) == 0x000068, "Wrong size on FTabListEntry");
static_assert(offsetof(FTabListEntry, TabIndex) == 0x000000, "Member 'FTabListEntry::TabIndex' has a wrong offset!");
static_assert(offsetof(FTabListEntry, DisplayName) == 0x000008, "Member 'FTabListEntry::DisplayName' has a wrong offset!");
static_assert(offsetof(FTabListEntry, TabButton) == 0x000020, "Member 'FTabListEntry::TabButton' has a wrong offset!");
static_assert(offsetof(FTabListEntry, ContentAssetID) == 0x000028, "Member 'FTabListEntry::ContentAssetID' has a wrong offset!");
static_assert(offsetof(FTabListEntry, ContentInstance) == 0x000050, "Member 'FTabListEntry::ContentInstance' has a wrong offset!");
static_assert(offsetof(FTabListEntry, SceneName) == 0x000058, "Member 'FTabListEntry::SceneName' has a wrong offset!");
static_assert(offsetof(FTabListEntry, TutorialID) == 0x000060, "Member 'FTabListEntry::TutorialID' has a wrong offset!");

// ScriptStruct OrionUI.OrionUISwatch
// 0x0028 (0x0028 - 0x0000)
struct FOrionUISwatch final
{
public:
	class FString                                 SwatchId;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ColorName;                                         // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           Color;                                             // 0x0018(0x0010)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOrionUISwatch) == 0x000008, "Wrong alignment on FOrionUISwatch");
static_assert(sizeof(FOrionUISwatch) == 0x000028, "Wrong size on FOrionUISwatch");
static_assert(offsetof(FOrionUISwatch, SwatchId) == 0x000000, "Member 'FOrionUISwatch::SwatchId' has a wrong offset!");
static_assert(offsetof(FOrionUISwatch, ColorName) == 0x000010, "Member 'FOrionUISwatch::ColorName' has a wrong offset!");
static_assert(offsetof(FOrionUISwatch, Color) == 0x000018, "Member 'FOrionUISwatch::Color' has a wrong offset!");

// ScriptStruct OrionUI.OrionUIColor
// 0x0070 (0x0070 - 0x0000)
struct alignas(0x10) FOrionUIColor final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionUIPaletteDefinition*              PaletteDefinition;                                 // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 PaletteEntryId;                                    // 0x0048(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x18];                                      // 0x0058(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionUIColor) == 0x000010, "Wrong alignment on FOrionUIColor");
static_assert(sizeof(FOrionUIColor) == 0x000070, "Wrong size on FOrionUIColor");
static_assert(offsetof(FOrionUIColor, PaletteDefinition) == 0x000040, "Member 'FOrionUIColor::PaletteDefinition' has a wrong offset!");
static_assert(offsetof(FOrionUIColor, PaletteEntryId) == 0x000048, "Member 'FOrionUIColor::PaletteEntryId' has a wrong offset!");

// ScriptStruct OrionUI.OrionUISwatchOverride
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FOrionUISwatchOverride final
{
public:
	class FName                                   SwatchName;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           OverrideColor;                                     // 0x0008(0x0010)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionUISwatchOverride) == 0x000008, "Wrong alignment on FOrionUISwatchOverride");
static_assert(sizeof(FOrionUISwatchOverride) == 0x000018, "Wrong size on FOrionUISwatchOverride");
static_assert(offsetof(FOrionUISwatchOverride, SwatchName) == 0x000000, "Member 'FOrionUISwatchOverride::SwatchName' has a wrong offset!");
static_assert(offsetof(FOrionUISwatchOverride, OverrideColor) == 0x000008, "Member 'FOrionUISwatchOverride::OverrideColor' has a wrong offset!");

// ScriptStruct OrionUI.CustomerServiceURLInLanguage
// 0x0020 (0x0020 - 0x0000)
struct FCustomerServiceURLInLanguage final
{
public:
	class FString                                 LanguageCode;                                      // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 URLString;                                         // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomerServiceURLInLanguage) == 0x000008, "Wrong alignment on FCustomerServiceURLInLanguage");
static_assert(sizeof(FCustomerServiceURLInLanguage) == 0x000020, "Wrong size on FCustomerServiceURLInLanguage");
static_assert(offsetof(FCustomerServiceURLInLanguage, LanguageCode) == 0x000000, "Member 'FCustomerServiceURLInLanguage::LanguageCode' has a wrong offset!");
static_assert(offsetof(FCustomerServiceURLInLanguage, URLString) == 0x000010, "Member 'FCustomerServiceURLInLanguage::URLString' has a wrong offset!");

// ScriptStruct OrionUI.OrionVideoTitleEvent
// 0x0010 (0x0010 - 0x0000)
struct FOrionVideoTitleEvent final
{
public:
	struct FTimespan                              Time;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       Animation;                                         // 0x0008(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionVideoTitleEvent) == 0x000008, "Wrong alignment on FOrionVideoTitleEvent");
static_assert(sizeof(FOrionVideoTitleEvent) == 0x000010, "Wrong size on FOrionVideoTitleEvent");
static_assert(offsetof(FOrionVideoTitleEvent, Time) == 0x000000, "Member 'FOrionVideoTitleEvent::Time' has a wrong offset!");
static_assert(offsetof(FOrionVideoTitleEvent, Animation) == 0x000008, "Member 'FOrionVideoTitleEvent::Animation' has a wrong offset!");

// ScriptStruct OrionUI.PlatformBitset
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FPlatformBitset final
{
public:
	uint8                                         Windows : 1;                                       // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         PlayStation4 : 1;                                  // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         XboxOne : 1;                                       // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Mac : 1;                                           // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         IOS : 1;                                           // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Android : 1;                                       // 0x0000(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Linux : 1;                                         // 0x0000(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlatformBitset) == 0x000004, "Wrong alignment on FPlatformBitset");
static_assert(sizeof(FPlatformBitset) == 0x000004, "Wrong size on FPlatformBitset");

}

