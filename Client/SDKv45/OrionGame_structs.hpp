#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: OrionGame

#include "Basic.hpp"

#include "GameplayAbilities_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "Slate_structs.hpp"
#include "SlateCore_structs.hpp"
#include "InputCore_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "McpProfileSys_structs.hpp"
#include "AnimGraphRuntime_structs.hpp"
#include "UMG_structs.hpp"
#include "Party_structs.hpp"


namespace SDK
{

// Enum OrionGame.EOrionTeam
// NumValues: 0x0007
enum class EOrionTeam : uint8
{
	TeamRed                                  = 0,
	TeamBlue                                 = 1,
	TeamCreep                                = 2,
	TeamSpectator                            = 3,
	NoTeam                                   = 4,
	TeamCount                                = 5,
	EOrionTeam_MAX                           = 6,
};

// Enum OrionGame.EOrionProjectileMovementMode
// NumValues: 0x0005
enum class EOrionProjectileMovementMode : uint8
{
	Default                                  = 0,
	Homing                                   = 1,
	PROJ_Walking                             = 2,
	PROJ_Falling                             = 3,
	EOrionProjectileMovementMode_MAX         = 4,
};

// Enum OrionGame.EMovingWidgetMotion
// NumValues: 0x0003
enum class EMovingWidgetMotion : uint8
{
	Linear                                   = 0,
	Bezier                                   = 1,
	EMovingWidgetMotion_MAX                  = 2,
};

// Enum OrionGame.EOrionUIState
// NumValues: 0x000E
enum class EOrionUIState : uint8
{
	Invalid                                  = 0,
	InitialPreload                           = 1,
	Title                                    = 2,
	Login                                    = 3,
	HotfixAndLoad                            = 4,
	FrontEnd                                 = 5,
	Match                                    = 6,
	Replay                                   = 7,
	DraftLobby                               = 8,
	Debug                                    = 9,
	Development_HUD                          = 10,
	RejoinMatch                              = 11,
	Match_PVE                                = 12,
	MAX                                      = 13,
};

// Enum OrionGame.EOrionLoadingScreenMode
// NumValues: 0x0009
enum class EOrionLoadingScreenMode : uint8
{
	Default                                  = 0,
	PreGame                                  = 1,
	Sovereign                                = 2,
	Tutorial                                 = 3,
	Transition                               = 4,
	Hotfix                                   = 5,
	Replay                                   = 6,
	ReturnToMainMenu                         = 7,
	MAX                                      = 8,
};

// Enum OrionGame.EProjectileCustomHitResponseType
// NumValues: 0x0007
enum class EProjectileCustomHitResponseType : uint8
{
	None                                     = 0,
	Common_Shield                            = 1,
	Shield_Damageable                        = 2,
	Shield_Damage_Absorber                   = 3,
	Structure_Shield                         = 4,
	BackDoorProtected_Structure              = 5,
	EProjectileCustomHitResponseType_MAX     = 6,
};

// Enum OrionGame.EOrionProjectileLaunchMode
// NumValues: 0x0006
enum class EOrionProjectileLaunchMode : uint8
{
	Default                                  = 0,
	ArcToTargetHigh                          = 1,
	ArcToTargetLow                           = 2,
	ArcToMaxRange                            = 3,
	COUNT                                    = 4,
	EOrionProjectileLaunchMode_MAX           = 5,
};

// Enum OrionGame.EOrionProjectileSpeed
// NumValues: 0x0009
enum class EOrionProjectileSpeed : uint8
{
	VerySlow                                 = 0,
	Slow                                     = 1,
	Default                                  = 2,
	Fast                                     = 3,
	MaxSpeed                                 = 4,
	LMB_Slow                                 = 5,
	LMB_Default                              = 6,
	COUNT                                    = 7,
	EOrionProjectileSpeed_MAX                = 8,
};

// Enum OrionGame.EOrionMuzzleSocket
// NumValues: 0x0008
enum class EOrionMuzzleSocket : uint8
{
	None                                     = 0,
	Muzzle_01                                = 1,
	Muzzle_02                                = 2,
	Muzzle_03                                = 3,
	Muzzle_04                                = 4,
	Muzzle_05                                = 5,
	COUNT                                    = 6,
	EOrionMuzzleSocket_MAX                   = 7,
};

// Enum OrionGame.EOrionItemRarity
// NumValues: 0x0006
enum class EOrionItemRarity : uint8
{
	Common                                   = 0,
	Uncommon                                 = 1,
	Rare                                     = 2,
	Epic                                     = 3,
	Legendary                                = 4,
	MAX                                      = 5,
};

// Enum OrionGame.EOrionItemFlyLocation
// NumValues: 0x0005
enum class EOrionItemFlyLocation : uint8
{
	Default                                  = 0,
	TimeCurrency                             = 1,
	MTXCurrency                              = 2,
	Boost                                    = 3,
	EOrionItemFlyLocation_MAX                = 4,
};

// Enum OrionGame.EOrionItemType
// NumValues: 0x0020
enum class EOrionItemType : uint8
{
	Banner                                   = 0,
	BannerAlteration                         = 1,
	Boost                                    = 2,
	LegacyCard                               = 3,
	Card                                     = 4,
	CardPack                                 = 5,
	ClashMob                                 = 6,
	Component                                = 7,
	Crown                                    = 8,
	Currency                                 = 9,
	Deck                                     = 10,
	Gem                                      = 11,
	GemKeywordBucket                         = 12,
	Emote                                    = 13,
	GiftBox                                  = 14,
	Glyph                                    = 15,
	Hero                                     = 16,
	Quest                                    = 17,
	RankUpRecipe                             = 18,
	Skin                                     = 19,
	SkinVariation                            = 20,
	Vault                                    = 21,
	Token                                    = 22,
	TranslateToken                           = 23,
	CodeToken                                = 24,
	Simple                                   = 25,
	CuratedDeck                              = 26,
	Profile                                  = 27,
	Objective                                = 28,
	AIData                                   = 29,
	Max_None                                 = 30,
	EOrionItemType_MAX                       = 31,
};

// Enum OrionGame.EAIBotDifficulty
// NumValues: 0x0007
enum class EAIBotDifficulty : uint8
{
	Introductory                             = 0,
	Easy                                     = 1,
	Intermediate                             = 2,
	Experienced                              = 3,
	Veteran                                  = 4,
	Custom                                   = 5,
	MAX                                      = 6,
};

// Enum OrionGame.EOrionGemBranchType
// NumValues: 0x0004
enum class EOrionGemBranchType : uint8
{
	Intellect                                = 0,
	Vitality                                 = 1,
	Dexterity                                = 2,
	MAX                                      = 3,
};

// Enum OrionGame.EOrionAbilityBinding
// NumValues: 0x0018
enum class EOrionAbilityBinding : uint8
{
	Ability1                                 = 0,
	Ability2                                 = 1,
	Ability3                                 = 2,
	Ability4                                 = 3,
	Ability5                                 = 4,
	Travel                                   = 5,
	Jump                                     = 6,
	Recall                                   = 7,
	Passive                                  = 8,
	ActivatableCard1                         = 9,
	ActivatableCard2                         = 10,
	ActivatableCard3                         = 11,
	ActivatableCard4                         = 12,
	PrimeHelix                               = 13,
	ItemSlot1                                = 14,
	ItemSlot2                                = 15,
	ItemSlot3                                = 16,
	Emote1                                   = 17,
	Emote2                                   = 18,
	Emote3                                   = 19,
	Emote4                                   = 20,
	Sprint                                   = 21,
	ForcedRecall                             = 22,
	MAX                                      = 23,
};

// Enum OrionGame.EOrionPosition
// NumValues: 0x0008
enum class EOrionPosition : uint8
{
	Invalid                                  = 0,
	Any                                      = 1,
	TopLane                                  = 2,
	MiddleLane                               = 3,
	Jungle                                   = 4,
	Support                                  = 5,
	Carry                                    = 6,
	MAX                                      = 7,
};

// Enum OrionGame.EOrionHeroTrait
// NumValues: 0x000F
enum class EOrionHeroTrait : uint8
{
	Invalid                                  = 0,
	Assassin                                 = 1,
	Initiator                                = 2,
	Guardian                                 = 3,
	Ganker                                   = 4,
	Durable                                  = 5,
	Marauder                                 = 6,
	Controller                               = 7,
	Sieger                                   = 8,
	Elusive                                  = 9,
	Burst                                    = 10,
	Attacker                                 = 11,
	Wild                                     = 12,
	Zoner                                    = 13,
	MAX                                      = 14,
};

// Enum OrionGame.EOrionRole
// NumValues: 0x0009
enum class EOrionRole : uint8
{
	Invalid                                  = 0,
	Any                                      = 1,
	Assassin                                 = 2,
	Fighter                                  = 3,
	Caster                                   = 4,
	Ranger                                   = 5,
	Support                                  = 6,
	Tank                                     = 7,
	MAX                                      = 8,
};

// Enum OrionGame.EOrionHeroRangeType
// NumValues: 0x0004
enum class EOrionHeroRangeType : uint8
{
	None                                     = 0,
	Melee                                    = 1,
	Ranged                                   = 2,
	EOrionHeroRangeType_MAX                  = 3,
};

// Enum OrionGame.EOrionHeroTier
// NumValues: 0x0006
enum class EOrionHeroTier : uint8
{
	None                                     = 0,
	Tier0                                    = 1,
	Tier1                                    = 2,
	Tier2                                    = 3,
	Tier3                                    = 4,
	MAX                                      = 5,
};

// Enum OrionGame.EBannerCommandType
// NumValues: 0x0003
enum class EBannerCommandType : uint8
{
	AttachBanner                             = 0,
	ApplyAlteration                          = 1,
	EBannerCommandType_MAX                   = 2,
};

// Enum OrionGame.EOrionDodgeType
// NumValues: 0x0008
enum class EOrionDodgeType : uint8
{
	Unknown                                  = 0,
	DraftLockInFailure                       = 1,
	AssociatedWithDraftLockInFailure         = 2,
	DraftDisconnect                          = 3,
	AssociatedWithDraftDisconnect            = 4,
	FailedToLoadMatch                        = 5,
	DisconnectBeforeMatchStart               = 6,
	MAX                                      = 7,
};

// Enum OrionGame.EOrionBannerType
// NumValues: 0x0007
enum class EOrionBannerType : uint8
{
	Staff                                    = 0,
	Charm                                    = 1,
	VFX                                      = 2,
	ImpactVFX                                = 3,
	DeactivationFX                           = 4,
	ActivationFX                             = 5,
	EOrionBannerType_MAX                     = 6,
};

// Enum OrionGame.EOrionPlatformType
// NumValues: 0x0003
enum class EOrionPlatformType : uint8
{
	PC                                       = 0,
	PS4                                      = 1,
	EOrionPlatformType_MAX                   = 2,
};

// Enum OrionGame.EOrionVeterancy
// NumValues: 0x0006
enum class EOrionVeterancy : uint8
{
	Unassigned                               = 0,
	Novice                                   = 1,
	Beginner                                 = 2,
	Experienced                              = 3,
	Hardcore                                 = 4,
	EOrionVeterancy_MAX                      = 5,
};

// Enum OrionGame.EOrionSimpleAchievementType
// NumValues: 0x0015
enum class EOrionSimpleAchievementType : uint8
{
	Unknown                                  = 0,
	OpenCardShop                             = 1,
	LeftBaseNoCards                          = 2,
	LeftBaseWith3CP                          = 3,
	InBaseWith3CP                            = 4,
	LevelAbility                             = 5,
	PrimeGuardian                            = 6,
	PickedUpOP                               = 7,
	AllyHasOP                                = 8,
	EnemyHasOP                               = 9,
	NearEmptyWell                            = 10,
	NearAllyWell                             = 11,
	NearEnemyWell                            = 12,
	CappingWellNoKey                         = 13,
	CappingWellNoCharges                     = 14,
	LastHitting                              = 15,
	TowerCallForHelp                         = 16,
	NearJungleCampBlue                       = 17,
	NearJungleCampBlack                      = 18,
	NearJungleCampRed                        = 19,
	MAX                                      = 20,
};

// Enum OrionGame.EOrionPartyMemberStateFlags
// NumValues: 0x0005
enum class EOrionPartyMemberStateFlags : uint8
{
	AccountLevel                             = 0,
	LevelProgress                            = 1,
	MatchmakingLevel                         = 2,
	bAfk                                     = 3,
	EOrionPartyMemberStateFlags_MAX          = 4,
};

// Enum OrionGame.ENotificationButton
// NumValues: 0x0003
enum class ENotificationButton : uint8
{
	Left                                     = 0,
	Right                                    = 1,
	ENotificationButton_MAX                  = 2,
};

// Enum OrionGame.ENotificationType
// NumValues: 0x0006
enum class ENotificationType : uint8
{
	Static                                   = 0,
	Interactive                              = 1,
	Information                              = 2,
	Error                                    = 3,
	Invalid                                  = 4,
	ENotificationType_MAX                    = 5,
};

// Enum OrionGame.EOrionFirstGameMatchmakingType
// NumValues: 0x0004
enum class EOrionFirstGameMatchmakingType : uint8
{
	AlwaysSolo                               = 0,
	AlwaysCoop                               = 1,
	ByExperiment                             = 2,
	EOrionFirstGameMatchmakingType_MAX       = 3,
};

// Enum OrionGame.EMinionLastHitVisualizationMode
// NumValues: 0x0004
enum class EMinionLastHitVisualizationMode : uint8
{
	Never                                    = 0,
	ByExperiment                             = 1,
	Always                                   = 2,
	EMinionLastHitVisualizationMode_MAX      = 3,
};

// Enum OrionGame.EBotObjectiveParam
// NumValues: 0x0008
enum class EBotObjectiveParam : uint8
{
	Auto                                     = 0,
	Left                                     = 1,
	Middle                                   = 2,
	Right                                    = 3,
	Closest                                  = 4,
	MostAdvanced                             = 5,
	Weakest                                  = 6,
	MAX                                      = 7,
};

// Enum OrionGame.EBotObjectiveName
// NumValues: 0x000A
enum class EBotObjectiveName : uint8
{
	Defend                                   = 0,
	Attack                                   = 1,
	GroupUp                                  = 2,
	PlaceWard                                = 3,
	AttackWhiteCamp                          = 4,
	AttackGreenCamp                          = 5,
	AttackGoldCamp                           = 6,
	AttackRaptorCamp                         = 7,
	AttackOPCamp                             = 8,
	MAX                                      = 9,
};

// Enum OrionGame.EBotObjectiveType
// NumValues: 0x0004
enum class EBotObjectiveType : uint8
{
	Offensive                                = 0,
	Defensive                                = 1,
	Utility                                  = 2,
	EBotObjectiveType_MAX                    = 3,
};

// Enum OrionGame.EBotObjectiveState
// NumValues: 0x0004
enum class EBotObjectiveState : uint8
{
	Invalid                                  = 0,
	Dormant                                  = 1,
	Available                                = 2,
	EBotObjectiveState_MAX                   = 3,
};

// Enum OrionGame.EBotObjectiveDebugDrawingMode
// NumValues: 0x0004
enum class EBotObjectiveDebugDrawingMode : uint8
{
	Structure                                = 0,
	Team                                     = 1,
	Influence                                = 2,
	EBotObjectiveDebugDrawingMode_MAX        = 3,
};

// Enum OrionGame.EObjectiveGraphProximityMode
// NumValues: 0x0004
enum class EObjectiveGraphProximityMode : uint8
{
	Closest                                  = 0,
	Second                                   = 1,
	Lane                                     = 2,
	EObjectiveGraphProximityMode_MAX         = 3,
};

// Enum OrionGame.EObjectiveNodeTeam
// NumValues: 0x0004
enum class EObjectiveNodeTeam : uint8
{
	Red                                      = 0,
	Blue                                     = 1,
	Neutral                                  = 2,
	MAX                                      = 3,
};

// Enum OrionGame.EObjectiveNodeType
// NumValues: 0x0008
enum class EObjectiveNodeType : uint8
{
	None                                     = 0,
	Tower                                    = 1,
	Well                                     = 2,
	JungleCamp                               = 3,
	Character                                = 4,
	Refinery                                 = 5,
	Ward                                     = 6,
	MAX                                      = 7,
};

// Enum OrionGame.ERichPresenceStateChange
// NumValues: 0x0007
enum class ERichPresenceStateChange : uint8
{
	None                                     = 0,
	AutoUpdate                               = 1,
	Idle                                     = 2,
	Active                                   = 3,
	Busy                                     = 4,
	NotBusy                                  = 5,
	ERichPresenceStateChange_MAX             = 6,
};

// Enum OrionGame.EDynamicEventsForUIModuleGarbageEnum
// NumValues: 0x0002
enum class EDynamicEventsForUIModuleGarbageEnum : uint8
{
	JustHereToGetAUHTGenHeader               = 0,
	EDynamicEventsForUIModuleGarbageEnum_MAX = 1,
};

// Enum OrionGame.EFCheckType
// NumValues: 0x0003
enum class EFCheckType : uint8
{
	Instant                                  = 0,
	Continuous                               = 1,
	EFCheckType_MAX                          = 2,
};

// Enum OrionGame.EActorDistanceType
// NumValues: 0x0003
enum class EActorDistanceType : uint8
{
	DistanceFromStart                        = 0,
	TotalDistanceMoved                       = 1,
	EActorDistanceType_MAX                   = 2,
};

// Enum OrionGame.EAutomationAbilityAction
// NumValues: 0x0005
enum class EAutomationAbilityAction : uint8
{
	Press                                    = 0,
	Release                                  = 1,
	Cancel                                   = 2,
	Confirm                                  = 3,
	EAutomationAbilityAction_MAX             = 4,
};

// Enum OrionGame.EAutomationAbilityActivationType
// NumValues: 0x0009
enum class EAutomationAbilityActivationType : uint8
{
	PressReleaseAndConfirm                   = 0,
	PressReleaseAndCancel                    = 1,
	PressAndRelease                          = 2,
	PressOnly                                = 3,
	ReleaseOnly                              = 4,
	ReleaseAndConfirm                        = 5,
	ConfirmOnly                              = 6,
	Cancel                                   = 7,
	EAutomationAbilityActivationType_MAX     = 8,
};

// Enum OrionGame.ETestJungleCreatures
// NumValues: 0x000B
enum class ETestJungleCreatures : uint8
{
	MeleeCreep                               = 0,
	RangedCreep                              = 1,
	Raptor                                   = 2,
	GoldBuff                                 = 3,
	GreenBuff                                = 4,
	BlackBuff                                = 5,
	BlueBuff                                 = 6,
	PurpleBuff                               = 7,
	RedBuff                                  = 8,
	PrimeGuardian                            = 9,
	ETestJungleCreatures_MAX                 = 10,
};

// Enum OrionGame.EMinionOverride
// NumValues: 0x0005
enum class EMinionOverride : uint8
{
	Default                                  = 0,
	DawnMinion                               = 1,
	DuskMinion                               = 2,
	OldMinion                                = 3,
	EMinionOverride_MAX                      = 4,
};

// Enum OrionGame.ETestMinions
// NumValues: 0x0006
enum class ETestMinions : uint8
{
	MeleeMinion                              = 0,
	RangedMinion                             = 1,
	SiegeMinion                              = 2,
	SuperMinion                              = 3,
	TargetDummy                              = 4,
	ETestMinions_MAX                         = 5,
};

// Enum OrionGame.EGGPUserDataOpType
// NumValues: 0x0004
enum class EGGPUserDataOpType : uint8
{
	Default                                  = 0,
	Set                                      = 1,
	Transform                                = 2,
	EGGPUserDataOpType_MAX                   = 3,
};

// Enum OrionGame.EGGPSimpleMathOperator
// NumValues: 0x0005
enum class EGGPSimpleMathOperator : uint8
{
	Add                                      = 0,
	Subtract                                 = 1,
	Multiply                                 = 2,
	Divide                                   = 3,
	EGGPSimpleMathOperator_MAX               = 4,
};

// Enum OrionGame.EAbilityAutoConfirmInputMode
// NumValues: 0x0004
enum class EAbilityAutoConfirmInputMode : uint8
{
	User                                     = 0,
	Always                                   = 1,
	Never                                    = 2,
	EAbilityAutoConfirmInputMode_MAX         = 3,
};

// Enum OrionGame.EEventEvaluatorGameplayEffectListenType
// NumValues: 0x0003
enum class EEventEvaluatorGameplayEffectListenType : uint8
{
	AppliedToSelf                            = 0,
	AppliedToTarget                          = 1,
	EEventEvaluatorGameplayEffectListenType_MAX = 2,
};

// Enum OrionGame.EEventEvaluatorAbilityActivateType
// NumValues: 0x0003
enum class EEventEvaluatorAbilityActivateType : uint8
{
	Commit                                   = 0,
	Activate                                 = 1,
	EEventEvaluatorAbilityActivateType_MAX   = 2,
};

// Enum OrionGame.EOrionDirectedMovementSpace
// NumValues: 0x0005
enum class EOrionDirectedMovementSpace : uint8
{
	WorldSpace                               = 0,
	ActorLocRelative                         = 1,
	ActorLocRotRelative                      = 2,
	CameraRelative                           = 3,
	EOrionDirectedMovementSpace_MAX          = 4,
};

// Enum OrionGame.EPassiveActivation
// NumValues: 0x0003
enum class EPassiveActivation : uint8
{
	TryActivateContinuously                  = 0,
	TryActivateOnSpawnOnly                   = 1,
	EPassiveActivation_MAX                   = 2,
};

// Enum OrionGame.EReticleVisibility
// NumValues: 0x0004
enum class EReticleVisibility : uint8
{
	HideReticle                              = 0,
	ShowReticle                              = 1,
	DoNotAffectReticle                       = 2,
	EReticleVisibility_MAX                   = 3,
};

// Enum OrionGame.EOrionAbilitYToolTipLevelType
// NumValues: 0x0003
enum class EOrionAbilitYToolTipLevelType : uint8
{
	AbilityLevel                             = 0,
	HeroLevel                                = 1,
	EOrionAbilitYToolTipLevelType_MAX        = 2,
};

// Enum OrionGame.EOrionAbilityTooltipFactors
// NumValues: 0x0012
enum class EOrionAbilityTooltipFactors : uint8
{
	BP                                       = 0,
	ARC                                      = 1,
	AR                                       = 2,
	BAT                                      = 3,
	ASR                                      = 4,
	BPH                                      = 5,
	HBS                                      = 6,
	LSR                                      = 7,
	CD                                       = 8,
	EC                                       = 9,
	SHIELD                                   = 10,
	MOVESPEED                                = 11,
	DURATION                                 = 12,
	PHYS_ARMOR                               = 13,
	EN_ARMOR                                 = 14,
	MAX_HEALTH                               = 15,
	MAX_HEALTH_PERCENT                       = 16,
	EOrionAbilityTooltipFactors_MAX          = 17,
};

// Enum OrionGame.EHUDDisplayType
// NumValues: 0x0003
enum class EHUDDisplayType : uint8
{
	DisplayAsCooldown                        = 0,
	DisplayAsDuration                        = 1,
	EHUDDisplayType_MAX                      = 2,
};

// Enum OrionGame.EPassiveHUDType
// NumValues: 0x0004
enum class EPassiveHUDType : uint8
{
	None                                     = 0,
	StackCount                               = 1,
	Duration                                 = 2,
	EPassiveHUDType_MAX                      = 3,
};

// Enum OrionGame.EOrionAbilityBotFocusOverride
// NumValues: 0x0006
enum class EOrionAbilityBotFocusOverride : uint8
{
	None                                     = 0,
	MoveGoal                                 = 1,
	Enemy                                    = 2,
	CurrentHeading                           = 3,
	FriendToSupport                          = 4,
	MAX                                      = 5,
};

// Enum OrionGame.EOrionAbilityBotInputConfirmation
// NumValues: 0x0006
enum class EOrionAbilityBotInputConfirmation : uint8
{
	None                                     = 0,
	Instant                                  = 1,
	TargetClose                              = 2,
	NextTick                                 = 3,
	Delay                                    = 4,
	EOrionAbilityBotInputConfirmation_MAX    = 5,
};

// Enum OrionGame.EOrionAbilityActivationGroup
// NumValues: 0x0005
enum class EOrionAbilityActivationGroup : uint8
{
	Default                                  = 0,
	Blocking                                 = 1,
	Replaceable                              = 2,
	Custom_ReplacedByBlockingOnly            = 3,
	MAX                                      = 4,
};

// Enum OrionGame.EOrionSecondaryCooldownType
// NumValues: 0x0003
enum class EOrionSecondaryCooldownType : uint8
{
	Default                                  = 0,
	Explicit                                 = 1,
	EOrionSecondaryCooldownType_MAX          = 2,
};

// Enum OrionGame.EOrionCooldownType
// NumValues: 0x0004
enum class EOrionCooldownType : uint8
{
	Explicit                                 = 0,
	AttackSpeedBased                         = 1,
	NoCooldown                               = 2,
	EOrionCooldownType_MAX                   = 3,
};

// Enum OrionGame.EOrionCostType
// NumValues: 0x0004
enum class EOrionCostType : uint8
{
	Explicit                                 = 0,
	AttackSpeedBased                         = 1,
	NoCooldown                               = 2,
	EOrionCostType_MAX                       = 3,
};

// Enum OrionGame.EBackHandlerType
// NumValues: 0x0004
enum class EBackHandlerType : uint8
{
	None                                     = 0,
	ActiveStack                              = 1,
	Global                                   = 2,
	EBackHandlerType_MAX                     = 3,
};

// Enum OrionGame.EOrionActorPrioritizerDimensionPolicy
// NumValues: 0x0003
enum class EOrionActorPrioritizerDimensionPolicy : uint8
{
	Dimension2d                              = 0,
	Dimension3d                              = 1,
	EOrionActorPrioritizerDimensionPolicy_MAX = 2,
};

// Enum OrionGame.EOrionActorPrioritizerSortPolicy
// NumValues: 0x0003
enum class EOrionActorPrioritizerSortPolicy : uint8
{
	Angle                                    = 0,
	Distance                                 = 1,
	EOrionActorPrioritizerSortPolicy_MAX     = 2,
};

// Enum OrionGame.EOrionActorPrioritizerOriginPolicy
// NumValues: 0x0004
enum class EOrionActorPrioritizerOriginPolicy : uint8
{
	View                                     = 0,
	Owner                                    = 1,
	Shape                                    = 2,
	EOrionActorPrioritizerOriginPolicy_MAX   = 3,
};

// Enum OrionGame.EAffinityType
// NumValues: 0x0007
enum class EAffinityType : uint8
{
	Invalid                                  = 0,
	Growth                                   = 1,
	Knowledge                                = 2,
	Order                                    = 3,
	Death                                    = 4,
	Chaos                                    = 5,
	MAX                                      = 6,
};

// Enum OrionGame.EBotAbilityType
// NumValues: 0x0005
enum class EBotAbilityType : uint8
{
	Melee                                    = 0,
	Ranged                                   = 1,
	AreaOfEffect                             = 2,
	Other                                    = 3,
	MAX                                      = 4,
};

// Enum OrionGame.ECorePerceptionTypes
// NumValues: 0x0006
enum class ECorePerceptionTypes : uint8
{
	Sight                                    = 0,
	Hearing                                  = 1,
	Damage                                   = 2,
	Team                                     = 3,
	Prediction                               = 4,
	MAX                                      = 5,
};

// Enum OrionGame.EOrionStencilValueSource
// NumValues: 0x0005
enum class EOrionStencilValueSource : uint8
{
	Decals                                   = 0,
	Occlusion                                = 1,
	DeathcamHighlightedKiller                = 2,
	AbilitySystemActiveTarget                = 3,
	MAX                                      = 4,
};

// Enum OrionGame.EBotThreatAssessment
// NumValues: 0x0004
enum class EBotThreatAssessment : uint8
{
	Flee                                     = 0,
	Default                                  = 1,
	Aggressive                               = 2,
	MAX                                      = 3,
};

// Enum OrionGame.EBotGraphPathfindingMode
// NumValues: 0x0004
enum class EBotGraphPathfindingMode : uint8
{
	Default                                  = 0,
	Lane                                     = 1,
	Jungle                                   = 2,
	MAX                                      = 3,
};

// Enum OrionGame.EOrionAITestType
// NumValues: 0x0007
enum class EOrionAITestType : uint8
{
	ShortestDistance                         = 0,
	LongestDistance                          = 1,
	Compare                                  = 2,
	Fact                                     = 3,
	SymbolDead                               = 4,
	TowerDead                                = 5,
	MAX                                      = 6,
};

// Enum OrionGame.EOrionAISymbolicItem
// NumValues: 0x000F
enum class EOrionAISymbolicItem : uint8
{
	Self                                     = 0,
	CurrentEnemy                             = 1,
	ObjectiveActor                           = 2,
	EnemyJungler                             = 3,
	ITEM_SET                                 = 4,
	EnemiesAlive                             = 5,
	FriendsAlive                             = 6,
	KnownEnemyHeroes                         = 7,
	ITEM_VALUE                               = 8,
	AverageAliveFriendsCXP                   = 9,
	CardXP                                   = 10,
	FurthestPushedLaneID                     = 11,
	FurthestPushedLaneProgress               = 12,
	AssignedLaneProgress                     = 13,
	MAX                                      = 14,
};

// Enum OrionGame.EAICampType
// NumValues: 0x000E
enum class EAICampType : uint8
{
	None                                     = 0,
	White                                    = 1,
	River                                    = 2,
	Green                                    = 3,
	Gold                                     = 4,
	Raptors                                  = 5,
	OP                                       = 6,
	Black                                    = 7,
	Custom1                                  = 8,
	Custom2                                  = 9,
	Custom3                                  = 10,
	Custom4                                  = 11,
	Custom5                                  = 12,
	MAX                                      = 13,
};

// Enum OrionGame.EAIGenericLocation
// NumValues: 0x000B
enum class EAIGenericLocation : uint8
{
	Offlane                                  = 0,
	MiddleLane                               = 1,
	SafeLane                                 = 2,
	Assigned                                 = 3,
	FurthestPushedLane                       = 4,
	NextNearestLane                          = 5,
	Vulnerable                               = 6,
	Outnumbered                              = 7,
	Closest                                  = 8,
	Any                                      = 9,
	MAX                                      = 10,
};

// Enum OrionGame.EAIWardLocation
// NumValues: 0x0005
enum class EAIWardLocation : uint8
{
	River                                    = 0,
	OwnJungle                                = 1,
	EnemyJungle                              = 2,
	Any                                      = 3,
	MAX                                      = 4,
};

// Enum OrionGame.EAIMapSide
// NumValues: 0x0003
enum class EAIMapSide : uint8
{
	Left                                     = 0,
	Right                                    = 1,
	MAX                                      = 2,
};

// Enum OrionGame.EAIOwnership
// NumValues: 0x0004
enum class EAIOwnership : uint8
{
	Own                                      = 0,
	Enemy                                    = 1,
	Any                                      = 2,
	MAX                                      = 3,
};

// Enum OrionGame.EAITowerClassification
// NumValues: 0x0005
enum class EAITowerClassification : uint8
{
	Core                                     = 0,
	Inhib                                    = 1,
	Tier2                                    = 2,
	Tier1                                    = 3,
	MAX                                      = 4,
};

// Enum OrionGame.EAIMatchProgress
// NumValues: 0x0004
enum class EAIMatchProgress : uint8
{
	Early                                    = 0,
	Mid                                      = 1,
	Late                                     = 2,
	MAX                                      = 3,
};

// Enum OrionGame.EAITeamCommEvent
// NumValues: 0x0016
enum class EAITeamCommEvent : uint8
{
	None                                     = 0,
	Attack_Left                              = 1,
	Attack_Middle                            = 2,
	Attack_Right                             = 3,
	Defend_Left                              = 4,
	Defend_Middle                            = 5,
	Defend_Right                             = 6,
	OMW_Left                                 = 7,
	OMW_Middle                               = 8,
	OMW_Right                                = 9,
	OMW_Generic                              = 10,
	EnemyMissing                             = 11,
	NeedHelp                                 = 12,
	UltimateReady                            = 13,
	GoodJob                                  = 14,
	Sorry                                    = 15,
	DontChase                                = 16,
	BeRightBack                              = 17,
	Retreat                                  = 18,
	Attack_Orb                               = 19,
	GroupUp                                  = 20,
	MAX                                      = 21,
};

// Enum OrionGame.EAIBotTeamDisplay
// NumValues: 0x0003
enum class EAIBotTeamDisplay : uint8
{
	Team0                                    = 0,
	Team1                                    = 1,
	MAX                                      = 2,
};

// Enum OrionGame.EBotEnemySelectionMode
// NumValues: 0x0006
enum class EBotEnemySelectionMode : uint8
{
	Default                                  = 0,
	LastHittingMinions                       = 1,
	NotLastHittingMinions                    = 2,
	WaveClearing                             = 3,
	HeroPriority                             = 4,
	MAX                                      = 5,
};

// Enum OrionGame.EAIMoveUrgency
// NumValues: 0x0005
enum class EAIMoveUrgency : uint8
{
	Low                                      = 0,
	Regular                                  = 1,
	High                                     = 2,
	Ultimate                                 = 3,
	MAX                                      = 4,
};

// Enum OrionGame.EOrionNavAreaFlag
// NumValues: 0x0004
enum class EOrionNavAreaFlag : uint8
{
	Default                                  = 0,
	Jump                                     = 1,
	Recall                                   = 2,
	EOrionNavAreaFlag_MAX                    = 3,
};

// Enum OrionGame.EBotObjectiveBehaviorResult
// NumValues: 0x0003
enum class EBotObjectiveBehaviorResult : uint8
{
	Done                                     = 0,
	Failed                                   = 1,
	MAX                                      = 2,
};

// Enum OrionGame.EAILanePosition
// NumValues: 0x0005
enum class EAILanePosition : uint8
{
	None                                     = 0,
	Offlane                                  = 1,
	Midlane                                  = 2,
	Safelane                                 = 3,
	MAX                                      = 4,
};

// Enum OrionGame.EOrionJungleTarget
// NumValues: 0x000A
enum class EOrionJungleTarget : uint8
{
	Tank                                     = 0,
	RandomAttackerPreferNotTank              = 1,
	RandomInRangePreferNotTank               = 2,
	RandomAttackerPreferRanged               = 3,
	RandomInRangePreferRanged                = 4,
	RandomAnyAttacker                        = 5,
	RandomAnyInRange                         = 6,
	FurthestAttacker                         = 7,
	FurthestInRange                          = 8,
	EOrionJungleTarget_MAX                   = 9,
};

// Enum OrionGame.EOrionMinionPriority
// NumValues: 0x000D
enum class EOrionMinionPriority : uint8
{
	None                                     = 0,
	Taunt                                    = 1,
	Heroes                                   = 2,
	HeroAttackingHero                        = 3,
	HeroAttackingMinion                      = 4,
	MinionMelee                              = 5,
	MinionRanged                             = 6,
	MinionSiege                              = 7,
	MinionSuper                              = 8,
	Minions                                  = 9,
	Towers                                   = 10,
	Damageables                              = 11,
	MAX                                      = 12,
};

// Enum OrionGame.EOrionBotAbilityTargetType
// NumValues: 0x0007
enum class EOrionBotAbilityTargetType : uint8
{
	Anything                                 = 0,
	Enemy                                    = 1,
	HurtingFriend                            = 2,
	Tower                                    = 3,
	Self                                     = 4,
	Movement                                 = 5,
	EOrionBotAbilityTargetType_MAX           = 6,
};

// Enum OrionGame.EOrionAIBotBehaviorContext
// NumValues: 0x0006
enum class EOrionAIBotBehaviorContext : uint8
{
	None                                     = 0,
	EnemyChase                               = 1,
	Retreat                                  = 2,
	LaneGoalAttack                           = 3,
	Objective                                = 4,
	EOrionAIBotBehaviorContext_MAX           = 5,
};

// Enum OrionGame.EOrionAIFocusPriority
// NumValues: 0x0003
enum class EOrionAIFocusPriority : uint8
{
	CurrentActionContext                     = 5,
	LaneGoal                                 = 6,
	EOrionAIFocusPriority_MAX                = 7,
};

// Enum OrionGame.EOrionAvoidanceFlag
// NumValues: 0x0008
enum class EOrionAvoidanceFlag : uint8
{
	Hero                                     = 0,
	LaneMelee                                = 1,
	LaneRanged                               = 2,
	LaneSiege                                = 3,
	LaneSuper                                = 4,
	JungleMelee                              = 5,
	JungleRanged                             = 6,
	EOrionAvoidanceFlag_MAX                  = 7,
};

// Enum OrionGame.EAIMinionType
// NumValues: 0x0009
enum class EAIMinionType : uint8
{
	None                                     = 0,
	LaneMelee                                = 1,
	LaneRanged                               = 2,
	LaneSiege                                = 3,
	LaneSuper                                = 4,
	JungleWeak                               = 5,
	JungleBuff                               = 6,
	JungleBoss                               = 7,
	MAX                                      = 8,
};

// Enum OrionGame.EAIMessageFromSpawner
// NumValues: 0x0007
enum class EAIMessageFromSpawner : uint8
{
	RespawnStarted                           = 0,
	RespawnFinished                          = 1,
	HeroEnteredRange                         = 2,
	HeroLeftRange                            = 3,
	MinionSpawned                            = 4,
	MinionDied                               = 5,
	EAIMessageFromSpawner_MAX                = 6,
};

// Enum OrionGame.EAIActorClassification
// NumValues: 0x0005
enum class EAIActorClassification : uint8
{
	Other                                    = 0,
	Minion                                   = 1,
	Hero                                     = 2,
	AreaOfEffect                             = 3,
	MAX                                      = 4,
};

// Enum OrionGame.EAIBotLOD
// NumValues: 0x0004
enum class EAIBotLOD : uint8
{
	Full                                     = 0,
	Medium                                   = 1,
	Low                                      = 2,
	MAX                                      = 3,
};

// Enum OrionGame.EAIAbilityTag
// NumValues: 0x0005
enum class EAIAbilityTag : uint8
{
	Primary                                  = 0,
	Secondary                                = 1,
	Alternate                                = 2,
	Ultimate                                 = 3,
	MAX                                      = 4,
};

// Enum OrionGame.EPlayerStat
// NumValues: 0x006A
enum class EPlayerStat : uint8
{
	Gold_Minion                              = 0,
	Gold_Minion_Jungle                       = 1,
	Gold_Minion_Jungle_Green                 = 2,
	Gold_Minion_Jungle_Gold                  = 3,
	Gold_PrimeHelix                          = 4,
	Gold_Hero                                = 5,
	Gold_Tower                               = 6,
	Gold_Tower_Inner                         = 7,
	Gold_Tower_Outter                        = 8,
	Gold_Inhibitor                           = 9,
	Gold_Refinery_Payout                     = 10,
	Gold_Refinery_Leech                      = 11,
	Gold_Cheat                               = 12,
	Gold_KillingBlow                         = 13,
	Gold_Assist                              = 14,
	Gold_Drip                                = 15,
	Gold_GameStart                           = 16,
	Gold_Itemization                         = 17,
	Gold_PlayerPlaced                        = 18,
	Gold_Misc                                = 19,
	Gold_Total                               = 20,
	LMBDamageDealt                           = 21,
	RMBDamageDealt                           = 22,
	QDamageDealt                             = 23,
	EDamageDealt                             = 24,
	RDamageDealt                             = 25,
	OtherDamageDealt                         = 26,
	LMBDamageReceived                        = 27,
	RMBDamageReceived                        = 28,
	QDamageReceived                          = 29,
	EDamageReceived                          = 30,
	RDamageReceived                          = 31,
	OtherDamageReceived                      = 32,
	HeroDamageDealt                          = 33,
	HeroDamageReceived                       = 34,
	MinionDamageDealt                        = 35,
	JungleMinionDamageDealt                  = 36,
	PrimeHelixMinionDamageDealt              = 37,
	RigDamageDealt                           = 38,
	TowerDamageDealt                         = 39,
	InhibitorDamageDealt                     = 40,
	CoreDamageDealt                          = 41,
	MinionDamageReceived                     = 42,
	JungleMinionDamageReceived               = 43,
	PrimeHelixMinionDamageReceived           = 44,
	RigDamageReceived                        = 45,
	TowerDamageReceived                      = 46,
	InhibitorDamageReceived                  = 47,
	CoreDamageReceived                       = 48,
	HeroKillXP                               = 49,
	HeroAssistXP                             = 50,
	MinionKillXP                             = 51,
	MinionAssistXP                           = 52,
	JungleMinionKillXP                       = 53,
	JungleMinionAssistXP                     = 54,
	TowerKillXP                              = 55,
	TowerAssistXP                            = 56,
	RigKillXP                                = 57,
	RigAssistXP                              = 58,
	RigCollectionXP                          = 59,
	WellCaptureXP                            = 60,
	PrimeHelixMinionKillXP                   = 61,
	PrimeHelixMinionAssistXP                 = 62,
	HeroLastHits                             = 63,
	MinionLastHits                           = 64,
	JungleMinionLastHits                     = 65,
	TowerLastHits                            = 66,
	RigLastHits                              = 67,
	PrimeHelixMinionLastHits                 = 68,
	LMBRegDmg                                = 69,
	LMBCritDmg                               = 70,
	LMBHitFreq                               = 71,
	LMBCritFreq                              = 72,
	RMBRegDmg                                = 73,
	RMBCritDmg                               = 74,
	RMBHitFreq                               = 75,
	RMBCritFreq                              = 76,
	QRegDmg                                  = 77,
	QCritDmg                                 = 78,
	QHitFreq                                 = 79,
	QCritFreq                                = 80,
	ERegDmg                                  = 81,
	ECritDmg                                 = 82,
	EHitFreq                                 = 83,
	ECritFreq                                = 84,
	RRegDmg                                  = 85,
	RCritDmg                                 = 86,
	RHitFreq                                 = 87,
	RCritFreq                                = 88,
	OtherRegDmg                              = 89,
	OtherCritDmg                             = 90,
	OtherHitFreq                             = 91,
	OtherCritFreq                            = 92,
	ControllerAPM                            = 93,
	KeyboardAPM                              = 94,
	NumMovementTimeDiscrepanciesDetected     = 95,
	MovementLifetimeRawTimeDiscrepancy       = 96,
	MovementLifetime                         = 97,
	CardSelfHealing                          = 98,
	CardOtherHealing                         = 99,
	LifeStealSelfHealing                     = 100,
	LifeStealOtherHealing                    = 101,
	MiscSelfHealing                          = 102,
	MiscOtherHealing                         = 103,
	NUM_PLAYER_STATS                         = 104,
	EPlayerStat_MAX                          = 105,
};

// Enum OrionGame.EBehaviorRequestState
// NumValues: 0x0005
enum class EBehaviorRequestState : uint8
{
	Reset                                    = 0,
	Play                                     = 1,
	PlayLoop                                 = 2,
	Stop                                     = 3,
	Max                                      = 4,
};

// Enum OrionGame.EOrionMinionAnimDirection
// NumValues: 0x0005
enum class EOrionMinionAnimDirection : uint8
{
	Forward                                  = 0,
	Right                                    = 1,
	Back                                     = 2,
	Left                                     = 3,
	Max                                      = 4,
};

// Enum OrionGame.EOrionMinionPrioritizedBehavior
// NumValues: 0x0010
enum class EOrionMinionPrioritizedBehavior : uint8
{
	Spawn                                    = 0,
	Death                                    = 1,
	KnockBack_ToFront                        = 2,
	KnockBack_ToBack                         = 3,
	KnockUp                                  = 4,
	Stun                                     = 5,
	Special_Attack                           = 6,
	HitReaction_Additive_Front               = 7,
	HitReaction_Additive_Back                = 8,
	HitReaction_Additive_Right               = 9,
	HitReaction_Additive_Left                = 10,
	Ranged_Attack                            = 11,
	Melee_Attack                             = 12,
	Ranged_Attack_Additive                   = 13,
	AggroNotify                              = 14,
	Max                                      = 15,
};

// Enum OrionGame.EOrionMinionAnimSlot
// NumValues: 0x0005
enum class EOrionMinionAnimSlot : uint8
{
	BaseAnimation                            = 0,
	SplitBody                                = 1,
	AdditiveAnimation                        = 2,
	FullBodyAnimation                        = 3,
	Max                                      = 4,
};

// Enum OrionGame.EOrionAnimMotionRecordMode
// NumValues: 0x0005
enum class EOrionAnimMotionRecordMode : uint8
{
	ERT_Jump                                 = 0,
	ERT_Start                                = 1,
	ERT_Stop                                 = 2,
	ERT_Pivot                                = 3,
	ERT_MAX                                  = 4,
};

// Enum OrionGame.ESpeedWarpingAxisMode
// NumValues: 0x0007
enum class ESpeedWarpingAxisMode : uint8
{
	IKFootRootLocalX                         = 0,
	IKFootRootLocalY                         = 1,
	IKFootRootLocalZ                         = 2,
	WorldSpaceVectorInput                    = 3,
	ComponentSpaceVectorInput                = 4,
	ActorSpaceVectorInput                    = 5,
	ESpeedWarpingAxisMode_MAX                = 6,
};

// Enum OrionGame.ECardinalDirection
// NumValues: 0x0005
enum class ECardinalDirection : uint8
{
	N                                        = 0,
	E                                        = 1,
	S                                        = 2,
	W                                        = 3,
	ECardinalDirection_MAX                   = 4,
};

// Enum OrionGame.EOrionLoadingPhase
// NumValues: 0x0006
enum class EOrionLoadingPhase : uint8
{
	None                                     = 0,
	FrontEnd                                 = 1,
	FrontEnd_Selected                        = 2,
	Game_InUse                               = 4,
	Game_NotInUse                            = 6,
	EOrionLoadingPhase_MAX                   = 7,
};

// Enum OrionGame.EAbilityDisplayValueFormat
// NumValues: 0x0007
enum class EAbilityDisplayValueFormat : uint32
{
	Normal                                   = 0,
	Percent_Raw                              = 1,
	Percent_SubtractOne                      = 2,
	Percent_Final                            = 3,
	Time                                     = 4,
	Distance                                 = 5,
	EAbilityDisplayValueFormat_MAX           = 6,
};

// Enum OrionGame.EAttributeViewCategory
// NumValues: 0x0005
enum class EAttributeViewCategory : uint8
{
	None                                     = 0,
	Offensive                                = 1,
	Defensive                                = 2,
	Utility                                  = 3,
	MAX                                      = 4,
};

// Enum OrionGame.EEntranceInterpolation
// NumValues: 0x000C
enum class EEntranceInterpolation : uint8
{
	Linear                                   = 0,
	Curve                                    = 1,
	InverseCurve                             = 2,
	HardCurve                                = 3,
	InverseHardCurve                         = 4,
	SevereCurve                              = 5,
	InverseSevereCurve                       = 6,
	S_Curve                                  = 7,
	InverseS_Curve                           = 8,
	Backward_S_Curve                         = 9,
	InverseBackward_S_Curve                  = 10,
	EEntranceInterpolation_MAX               = 11,
};

// Enum OrionGame.ESpawnOrionTaskCacheBehavior
// NumValues: 0x0004
enum class ESpawnOrionTaskCacheBehavior : uint8
{
	NoCache                                  = 0,
	CacheAndResetOnAccess                    = 1,
	CacheNoReset                             = 2,
	ESpawnOrionTaskCacheBehavior_MAX         = 3,
};

// Enum OrionGame.ECameraModeBlendFunction
// NumValues: 0x0006
enum class ECameraModeBlendFunction : uint8
{
	Linear                                   = 0,
	EaseIn                                   = 1,
	EaseOut                                  = 2,
	EaseInOut                                = 3,
	COUNT                                    = 4,
	ECameraModeBlendFunction_MAX             = 5,
};

// Enum OrionGame.ECameraModeType
// NumValues: 0x0005
enum class ECameraModeType : uint8
{
	ThirdPerson                              = 0,
	FirstPerson                              = 1,
	Detached                                 = 2,
	COUNT                                    = 3,
	ECameraModeType_MAX                      = 4,
};

// Enum OrionGame.EOrionViewKickRotationalDirection
// NumValues: 0x0004
enum class EOrionViewKickRotationalDirection : uint8
{
	Random                                   = 0,
	Clockwise                                = 1,
	Counterclockwise                         = 2,
	EOrionViewKickRotationalDirection_MAX    = 3,
};

// Enum OrionGame.EOrionCardLevelTier
// NumValues: 0x0005
enum class EOrionCardLevelTier : uint8
{
	Bronze                                   = 0,
	Silver                                   = 1,
	Gold                                     = 2,
	Diamond                                  = 3,
	MAX                                      = 4,
};

// Enum OrionGame.EOrionCardTraits
// NumValues: 0x0007
enum class EOrionCardTraits : uint8
{
	Consumable                               = 0,
	DiscardOnDeath                           = 1,
	Cultivate                                = 2,
	CanNotDiscard                            = 3,
	Elevate                                  = 4,
	None                                     = 5,
	MAX                                      = 6,
};

// Enum OrionGame.EOrionCharLocalStatusTypes
// NumValues: 0x0003
enum class EOrionCharLocalStatusTypes : uint8
{
	IsShade                                  = 0,
	InRevenantUlt                            = 1,
	MAX                                      = 2,
};

// Enum OrionGame.EOrionCharAISpawnerType
// NumValues: 0x0007
enum class EOrionCharAISpawnerType : uint8
{
	OCAIST_OnDemand                          = 0,
	OCAIST_WaveSpawner                       = 1,
	OCAIST_FormationReplenish                = 2,
	OCAIST_WaveReplenish                     = 3,
	OCAIST_DelayWaveReplenish                = 4,
	OCAIST_None                              = 5,
	OCAIST_MAX                               = 6,
};

// Enum OrionGame.EOrionCharAISpawnerCategory
// NumValues: 0x0005
enum class EOrionCharAISpawnerCategory : uint8
{
	Default                                  = 0,
	Lane                                     = 1,
	Jungle                                   = 2,
	CoreBoss                                 = 3,
	EOrionCharAISpawnerCategory_MAX          = 4,
};

// Enum OrionGame.ECharHoverMovement
// NumValues: 0x0004
enum class ECharHoverMovement : uint8
{
	None                                     = 0,
	FlyWalk                                  = 1,
	StandardCharacterHover                   = 2,
	ECharHoverMovement_MAX                   = 3,
};

// Enum OrionGame.EOrionServerMoveType
// NumValues: 0x0006
enum class EOrionServerMoveType : uint8
{
	NoType                                   = 0,
	ServerMove                               = 1,
	ServerMoveDual                           = 2,
	ServerMoveDualHybridRootMotion           = 3,
	ServerMoveOld                            = 4,
	EOrionServerMoveType_MAX                 = 5,
};

// Enum OrionGame.EStatusAreaDisplayType
// NumValues: 0x0003
enum class EStatusAreaDisplayType : uint8
{
	Simple                                   = 0,
	Advanced                                 = 1,
	EStatusAreaDisplayType_MAX               = 2,
};

// Enum OrionGame.EStaticHealthBarPosition
// NumValues: 0x0005
enum class EStaticHealthBarPosition : uint8
{
	Top                                      = 0,
	Bottom                                   = 1,
	Corner                                   = 2,
	Off                                      = 3,
	EStaticHealthBarPosition_MAX             = 4,
};

// Enum OrionGame.EPlayerOverheadHealthBarPosition
// NumValues: 0x0004
enum class EPlayerOverheadHealthBarPosition : uint8
{
	OverHead                                 = 0,
	OverShoulder                             = 1,
	Off                                      = 2,
	EPlayerOverheadHealthBarPosition_MAX     = 3,
};

// Enum OrionGame.EOffScreenIndicatorVisibility
// NumValues: 0x0004
enum class EOffScreenIndicatorVisibility : uint8
{
	On                                       = 0,
	EnemyOnly                                = 1,
	Off                                      = 2,
	EOffScreenIndicatorVisibility_MAX        = 3,
};

// Enum OrionGame.EHealthIndicatorVisibility
// NumValues: 0x0004
enum class EHealthIndicatorVisibility : uint8
{
	AlwaysVisible                            = 0,
	OnlyDamaged                              = 1,
	Off                                      = 2,
	EHealthIndicatorVisibility_MAX           = 3,
};

// Enum OrionGame.EOrionCoinSize
// NumValues: 0x0004
enum class EOrionCoinSize : uint8
{
	Small                                    = 0,
	Medium                                   = 1,
	Large                                    = 2,
	MAX                                      = 3,
};

// Enum OrionGame.EOrionCraftingAction
// NumValues: 0x0003
enum class EOrionCraftingAction : uint8
{
	Create                                   = 0,
	Dismantle                                = 1,
	MAX                                      = 2,
};

// Enum OrionGame.EOrionDecalOrientation
// NumValues: 0x0004
enum class EOrionDecalOrientation : uint8
{
	CameraAligned                            = 0,
	CharacterForward                         = 1,
	CharacterVelocity                        = 2,
	EOrionDecalOrientation_MAX               = 3,
};

// Enum OrionGame.EOrionDecalTargetState
// NumValues: 0x0005
enum class EOrionDecalTargetState : uint8
{
	NewlyCreated                             = 0,
	Active                                   = 1,
	Inactive                                 = 2,
	NeedsRemoved                             = 3,
	EOrionDecalTargetState_MAX               = 4,
};

// Enum OrionGame.EOrionDecalState
// NumValues: 0x0009
enum class EOrionDecalState : uint8
{
	None                                     = 0,
	NeedsFadedIn                             = 1,
	FadingIn                                 = 2,
	Active                                   = 3,
	NeedsFadedOut                            = 4,
	FadingOut                                = 5,
	Inactive                                 = 6,
	NeedsDestroyed                           = 7,
	EOrionDecalState_MAX                     = 8,
};

// Enum OrionGame.EWitnessRelationship
// NumValues: 0x0007
enum class EWitnessRelationship : uint8
{
	Self                                     = 0,
	Allies                                   = 1,
	AlliesAndSelf                            = 2,
	Enemies                                  = 3,
	EnemiesAndSelf                           = 4,
	All                                      = 5,
	EWitnessRelationship_MAX                 = 6,
};

// Enum OrionGame.EDraftLobbyEndState
// NumValues: 0x0009
enum class EDraftLobbyEndState : uint8
{
	DraftLobbyEndState_Unknown               = 0,
	DraftLobbyEndState_Success               = 1,
	DraftLobbyEndState_Abort_WaitingForPlayers = 2,
	DraftLobbyEndState_Abort_PlayerLeft      = 3,
	DraftLobbyEndState_Abort_LockInFailure   = 4,
	DraftLobbyEndState_Abort_BannedPlayerIntrusion = 5,
	DraftLobbyEndState_Abort_TravelFailure   = 6,
	DraftLobbyEndState_Abort_ServerError     = 7,
	DraftLobbyEndState_MAX                   = 8,
};

// Enum OrionGame.EOrionHeroMovementProfile
// NumValues: 0x0008
enum class EOrionHeroMovementProfile : uint8
{
	None                                     = 0,
	Default_Light                            = 1,
	Default_Medium                           = 2,
	Default_Heavy                            = 3,
	TravelMode_Light                         = 4,
	TravelMode_Medium                        = 5,
	TravelMode_Heavy                         = 6,
	MAX                                      = 7,
};

// Enum OrionGame.EEventKeywordGrantFlag
// NumValues: 0x0004
enum class EEventKeywordGrantFlag : uint8
{
	Human                                    = 1,
	AI                                       = 2,
	Dummy                                    = 4,
	EEventKeywordGrantFlag_MAX               = 5,
};

// Enum OrionGame.EOrionFeaturedHeroAction
// NumValues: 0x0004
enum class EOrionFeaturedHeroAction : uint8
{
	Purchase                                 = 0,
	LootCrate                                = 1,
	Play                                     = 2,
	EOrionFeaturedHeroAction_MAX             = 3,
};

// Enum OrionGame.EOrionFeaturedHeroType
// NumValues: 0x0006
enum class EOrionFeaturedHeroType : uint8
{
	Mastery                                  = 0,
	Skin                                     = 1,
	SkinVariation                            = 2,
	HeroBundle                               = 3,
	Bundle                                   = 4,
	EOrionFeaturedHeroType_MAX               = 5,
};

// Enum OrionGame.EOrionSurrenderVoteReason
// NumValues: 0x000F
enum class EOrionSurrenderVoteReason : uint8
{
	No                                       = 0,
	YesSkipSurvey                            = 1,
	UnfairMatchUp                            = 2,
	ToxicTeammates                           = 3,
	TeammatesPlayingPoorly                   = 4,
	NoChanceOfWinning                        = 5,
	NotHavingFun                             = 6,
	BadTiming                                = 7,
	PeerPressure                             = 8,
	TooConfusing                             = 9,
	TeammateDisconnected                     = 10,
	TeammateJoinedLate                       = 11,
	Other                                    = 12,
	COUNT                                    = 13,
	EOrionSurrenderVoteReason_MAX            = 14,
};

// Enum OrionGame.EOrionXPAssisterTimeOut
// NumValues: 0x0007
enum class EOrionXPAssisterTimeOut : uint8
{
	VeryFast                                 = 0,
	Fast                                     = 1,
	Normal                                   = 2,
	Slow                                     = 3,
	VerySlow                                 = 4,
	COUNT                                    = 5,
	EOrionXPAssisterTimeOut_MAX              = 6,
};

// Enum OrionGame.EOrionTrickleTeamXPAmount
// NumValues: 0x0006
enum class EOrionTrickleTeamXPAmount : uint8
{
	VeryLittle                               = 0,
	Little                                   = 1,
	Normal                                   = 2,
	Large                                    = 3,
	COUNT                                    = 4,
	EOrionTrickleTeamXPAmount_MAX            = 5,
};

// Enum OrionGame.EOrionTrickleTeamXPRate
// NumValues: 0x0006
enum class EOrionTrickleTeamXPRate : uint8
{
	VerySlow                                 = 0,
	Slow                                     = 1,
	Default                                  = 2,
	Fast                                     = 3,
	COUNT                                    = 4,
	EOrionTrickleTeamXPRate_MAX              = 5,
};

// Enum OrionGame.EOrionItemEvent
// NumValues: 0x0006
enum class EOrionItemEvent : uint8
{
	Nothing                                  = 0,
	Equipped                                 = 1,
	Activation                               = 2,
	Consumed                                 = 3,
	Combusted                                = 4,
	EOrionItemEvent_MAX                      = 5,
};

// Enum OrionGame.EOrionItemState
// NumValues: 0x000C
enum class EOrionItemState : uint8
{
	Nothing                                  = 0,
	CardEquipped                             = 1,
	CardStartActivation                      = 2,
	CardLoopingActivation                    = 3,
	CardEndActivation                        = 4,
	CardConsumed                             = 5,
	CardCombusted                            = 6,
	GemEquipped                              = 7,
	GemStartActivation                       = 8,
	GemLoopingActivation                     = 9,
	GemEndActivation                         = 10,
	EOrionItemState_MAX                      = 11,
};

// Enum OrionGame.EShouldLoadDelegateType
// NumValues: 0x0003
enum class EShouldLoadDelegateType : uint8
{
	FrontEnd                                 = 0,
	ForGamePlay                              = 1,
	EShouldLoadDelegateType_MAX              = 2,
};

// Enum OrionGame.EGCNotifySubsetState
// NumValues: 0x0005
enum class EGCNotifySubsetState : uint8
{
	Default                                  = 0,
	Unloaded                                 = 1,
	Loading                                  = 2,
	Loaded                                   = 3,
	EGCNotifySubsetState_MAX                 = 4,
};

// Enum OrionGame.EOrionGameplayCueTraceOrientation
// NumValues: 0x0003
enum class EOrionGameplayCueTraceOrientation : uint8
{
	OrientToImpactNormal                     = 0,
	OrientToTraceStart                       = 1,
	EOrionGameplayCueTraceOrientation_MAX    = 2,
};

// Enum OrionGame.EGCLevelRequirement
// NumValues: 0x0003
enum class EGCLevelRequirement : uint8
{
	AbilityLevel                             = 0,
	GameplayEffectLevel                      = 1,
	EGCLevelRequirement_MAX                  = 2,
};

// Enum OrionGame.EParticleTeamColorAdjustStyle
// NumValues: 0x0004
enum class EParticleTeamColorAdjustStyle : uint8
{
	NotAdjusted                              = 0,
	AdjustedForSource                        = 1,
	AdjustedForTarget                        = 2,
	EParticleTeamColorAdjustStyle_MAX        = 3,
};

// Enum OrionGame.EParticleCondition
// NumValues: 0x0004
enum class EParticleCondition : uint8
{
	NoCondition                              = 0,
	LocalPlayerSource                        = 1,
	NonLocalPlayerSource                     = 2,
	EParticleCondition_MAX                   = 3,
};

// Enum OrionGame.ETeamAdjustStyle
// NumValues: 0x0004
enum class ETeamAdjustStyle : uint8
{
	RelativeToTarget                         = 0,
	RelativeToSource                         = 1,
	NotAdjusted                              = 2,
	ETeamAdjustStyle_MAX                     = 3,
};

// Enum OrionGame.ELocalVisiblityPolicy
// NumValues: 0x0003
enum class ELocalVisiblityPolicy : uint8
{
	Default                                  = 0,
	AlwaysPlay                               = 1,
	ELocalVisiblityPolicy_MAX                = 2,
};

// Enum OrionGame.EOrionGameplayCueParticleAttachType
// NumValues: 0x0003
enum class EOrionGameplayCueParticleAttachType : uint8
{
	AttachToTarget                           = 0,
	DoNotAttach                              = 1,
	EOrionGameplayCueParticleAttachType_MAX  = 2,
};

// Enum OrionGame.EOrionGameplayItemState
// NumValues: 0x0005
enum class EOrionGameplayItemState : uint8
{
	Unknown                                  = 0,
	Available                                = 1,
	Equipped                                 = 2,
	Destroyed                                = 3,
	EOrionGameplayItemState_MAX              = 4,
};

// Enum OrionGame.EOrionStatTrackType
// NumValues: 0x0004
enum class EOrionStatTrackType : uint8
{
	MatchStat                                = 0,
	LifeStat                                 = 1,
	Custom                                   = 2,
	MAX                                      = 3,
};

// Enum OrionGame.EOrionQuestVerbType
// NumValues: 0x0003
enum class EOrionQuestVerbType : uint8
{
	EARN                                     = 0,
	COMPLETE                                 = 1,
	EOrionQuestVerbType_MAX                  = 2,
};

// Enum OrionGame.EDraftLobbyState
// NumValues: 0x0007
enum class EDraftLobbyState : uint8
{
	Invalid                                  = 0,
	WaitingForPlayers                        = 1,
	PhaseTransition                          = 2,
	PlayerSelection                          = 3,
	DraftAborting                            = 4,
	DraftComplete                            = 5,
	EDraftLobbyState_MAX                     = 6,
};

// Enum OrionGame.ETeamChatRoomState
// NumValues: 0x0005
enum class ETeamChatRoomState : uint8
{
	NotCreated                               = 0,
	Creating                                 = 1,
	Created                                  = 2,
	Timeout                                  = 3,
	ETeamChatRoomState_MAX                   = 4,
};

// Enum OrionGame.EGameModeType
// NumValues: 0x0006
enum class EGameModeType : uint8
{
	Default_MOBA                             = 0,
	TimeLimit_MOBA                           = 1,
	TimeLimitWithScore_MOBA                  = 2,
	ScoreLimit_MOBA                          = 3,
	ScoreToZero_MOBA                         = 4,
	EGameModeType_MAX                        = 5,
};

// Enum OrionGame.EOrionGemRank
// NumValues: 0x0007
enum class EOrionGemRank : uint8
{
	Invalid                                  = 0,
	One                                      = 1,
	Two                                      = 2,
	Three                                    = 3,
	Four                                     = 4,
	Five                                     = 5,
	MAX                                      = 6,
};

// Enum OrionGame.ESimpleAbilityBaseProperty
// NumValues: 0x0005
enum class ESimpleAbilityBaseProperty : uint8
{
	ListenDuration                           = 0,
	Cooldown                                 = 1,
	ManaCost                                 = 2,
	AppliedEffect                            = 3,
	MAX                                      = 4,
};

// Enum OrionGame.EOrionGemType
// NumValues: 0x0004
enum class EOrionGemType : uint8
{
	Offense                                  = 0,
	Defense                                  = 1,
	Utility                                  = 2,
	MAX                                      = 3,
};

// Enum OrionGame.EGravesiteCameraState
// NumValues: 0x0005
enum class EGravesiteCameraState : uint8
{
	DISABLED                                 = 0,
	FOCUS_INITIAL_DIRECTION                  = 1,
	FOCUS_PLAYER_ENTERED_GRAVESITE           = 2,
	FOCUS_BANNER_RAISED                      = 3,
	EGravesiteCameraState_MAX                = 4,
};

// Enum OrionGame.EBannerEntrance
// NumValues: 0x0007
enum class EBannerEntrance : uint8
{
	Invalid                                  = 0,
	Land                                     = 1,
	Land_NoScale                             = 2,
	Rise                                     = 3,
	PostRise                                 = 4,
	InAir                                    = 5,
	EBannerEntrance_MAX                      = 6,
};

// Enum OrionGame.EOrionLoadedDataType
// NumValues: 0x0006
enum class EOrionLoadedDataType : uint8
{
	Default                                  = 0,
	CardGameplayEffects                      = 1,
	UIManagerPlus                            = 2,
	SharedGameplayCues                       = 3,
	ArcadeAssets                             = 4,
	MAX                                      = 5,
};

// Enum OrionGame.EOrionLoadedDataState
// NumValues: 0x0005
enum class EOrionLoadedDataState : uint8
{
	Default                                  = 0,
	Unloaded                                 = 1,
	Loading                                  = 2,
	Loaded                                   = 3,
	EOrionLoadedDataState_MAX                = 4,
};

// Enum OrionGame.EOrionLatencyPreset
// NumValues: 0x0007
enum class EOrionLatencyPreset : uint8
{
	None                                     = 0,
	Lan                                      = 1,
	RealWorld                                = 2,
	Poor                                     = 3,
	ExtremelyPoor                            = 4,
	Custom                                   = 5,
	MAX                                      = 6,
};

// Enum OrionGame.EOrionObjectLibrary
// NumValues: 0x001D
enum class EOrionObjectLibrary : uint8
{
	BannerData                               = 0,
	BannerAlterationData                     = 1,
	BoostData                                = 2,
	CardData                                 = 3,
	LegacyCardData                           = 4,
	CardPackData                             = 5,
	ClashMobData                             = 6,
	ComponentData                            = 7,
	CrownData                                = 8,
	DeckData                                 = 9,
	GemData                                  = 10,
	GemKeywordBucketData                     = 11,
	EmoteData                                = 12,
	GiftBoxData                              = 13,
	GlyphData                                = 14,
	HeroData                                 = 15,
	QuestData                                = 16,
	RankUpRecipeData                         = 17,
	SkinData                                 = 18,
	SkinVariationData                        = 19,
	VaultData                                = 20,
	TokenData                                = 21,
	TranslateTokenData                       = 22,
	CodeTokenData                            = 23,
	SimpleData                               = 24,
	CuratedDeckData                          = 25,
	AIData                                   = 26,
	Max_None                                 = 27,
	EOrionObjectLibrary_MAX                  = 28,
};

// Enum OrionGame.EGravesiteFade
// NumValues: 0x0007
enum class EGravesiteFade : uint8
{
	None                                     = 0,
	In                                       = 1,
	Out_FromTimeOut                          = 2,
	MaxBrighten                              = 3,
	Out_AfterBannerRaised                    = 4,
	Done                                     = 5,
	EGravesiteFade_MAX                       = 6,
};

// Enum OrionGame.EOrionHighlightSignificance
// NumValues: 0x0008
enum class EOrionHighlightSignificance : uint8
{
	ExtremelyBad                             = 1,
	VeryBad                                  = 2,
	Bad                                      = 4,
	Neutral                                  = 8,
	Good                                     = 16,
	VeryGood                                 = 32,
	ExtremelyGood                            = 64,
	MAX                                      = 128,
};

// Enum OrionGame.EOrionHighlightType
// NumValues: 0x0005
enum class EOrionHighlightType : uint8
{
	Milestone                                = 1,
	Achievement                              = 2,
	Incident                                 = 4,
	StateChange                              = 8,
	MAX                                      = 16,
};

// Enum OrionGame.EOrionHighlightCaptureType
// NumValues: 0x0003
enum class EOrionHighlightCaptureType : uint8
{
	Video                                    = 0,
	Screenshot                               = 1,
	EOrionHighlightCaptureType_MAX           = 2,
};

// Enum OrionGame.EOrionDamageNumberType
// NumValues: 0x001B
enum class EOrionDamageNumberType : uint8
{
	DebugStr                                 = 0,
	PhysicalDamage                           = 1,
	EnergyDamage                             = 2,
	ShieldedDamage                           = 3,
	Healing                                  = 4,
	XP                                       = 5,
	CardXP                                   = 6,
	TeamCardXP                               = 7,
	TeamCardXP_Outgoing                      = 8,
	PhysicalDamage_Crit                      = 9,
	EnergyDamage_Crit                        = 10,
	ShieldedDamage_Crit                      = 11,
	PhysicalCleaveDamage                     = 12,
	EnergyCleaveDamage                       = 13,
	StatusEffect                             = 14,
	IntenseStatusEffect                      = 15,
	StatusEffect_LocalParticipant            = 16,
	IntenseStatusEffect_LocalParticipant     = 17,
	AbilityApplied                           = 18,
	PhysicalDamageSelf                       = 19,
	EnergyDamageSelf                         = 20,
	ShieldedDamageSelf                       = 21,
	PhysicalDamageCritSelf                   = 22,
	EnergyDamageCritSelf                     = 23,
	ShieldedDamageCritSelf                   = 24,
	NumOfTypes                               = 25,
	EOrionDamageNumberType_MAX               = 26,
};

// Enum OrionGame.EOrionTowerTargetingType
// NumValues: 0x0005
enum class EOrionTowerTargetingType : uint8
{
	None                                     = 0,
	Minions                                  = 1,
	Teammate                                 = 2,
	LocalPlayer                              = 3,
	EOrionTowerTargetingType_MAX             = 4,
};

// Enum OrionGame.EOrionHUDShowKillCamMode
// NumValues: 0x0003
enum class EOrionHUDShowKillCamMode : uint8
{
	Cut                                      = 0,
	Fade                                     = 1,
	EOrionHUDShowKillCamMode_MAX             = 2,
};

// Enum OrionGame.EOrionHUDFadeState
// NumValues: 0x0004
enum class EOrionHUDFadeState : uint8
{
	FadedIn                                  = 0,
	FadedOut                                 = 1,
	Fading                                   = 2,
	EOrionHUDFadeState_MAX                   = 3,
};

// Enum OrionGame.EOrionHUDFadeRequest
// NumValues: 0x0006
enum class EOrionHUDFadeRequest : uint8
{
	FadeIn_Slow                              = 0,
	FadeOut_Slow                             = 1,
	FadeIn_Instant                           = 2,
	FadeOut_Instant                          = 3,
	None                                     = 4,
	EOrionHUDFadeRequest_MAX                 = 5,
};

// Enum OrionGame.EOrionCardSelectionDirections
// NumValues: 0x0005
enum class EOrionCardSelectionDirections : uint8
{
	Up                                       = 0,
	Right                                    = 1,
	Down                                     = 2,
	Left                                     = 3,
	MAX                                      = 4,
};

// Enum OrionGame.EOrionGameEventMessageType
// NumValues: 0x0007
enum class EOrionGameEventMessageType : uint8
{
	Team_Comm_Message                        = 0,
	Level_Up                                 = 1,
	Player_Killed                            = 2,
	Structure_Destroyed                      = 3,
	Prime_Helix_Killed                       = 4,
	TeamAdvantage                            = 5,
	MAX                                      = 6,
};

// Enum OrionGame.EOrionGameEventMessagePrio
// NumValues: 0x000A
enum class EOrionGameEventMessagePrio : uint8
{
	Low                                      = 0,
	Leveled_Up                               = 1,
	Team_Advantage                           = 2,
	Player_Killed                            = 3,
	Turret_Destroyed                         = 4,
	Inhibitor_Destroyed                      = 5,
	Prime_Helix_Killed                       = 6,
	Core_Destroyed                           = 7,
	High                                     = 8,
	EOrionGameEventMessagePrio_MAX           = 9,
};

// Enum OrionGame.ESafeZonePadding
// NumValues: 0x0004
enum class ESafeZonePadding : uint8
{
	X_And_Y                                  = 0,
	X_Only                                   = 1,
	Y_Only                                   = 2,
	ESafeZonePadding_MAX                     = 3,
};

// Enum OrionGame.EOrionCombatMessageState
// NumValues: 0x0005
enum class EOrionCombatMessageState : uint8
{
	None                                     = 0,
	Entering                                 = 1,
	Idle                                     = 2,
	Exiting                                  = 3,
	EOrionCombatMessageState_MAX             = 4,
};

// Enum OrionGame.EOrionCombatMessageType
// NumValues: 0x0015
enum class EOrionCombatMessageType : uint8
{
	CannotUseAbility_NotReady                = 0,
	CannotUseAbility_OnCooldown              = 1,
	CannotUseAbility_NoEnergy                = 2,
	CannotUseAbility_NoEmote                 = 3,
	PrimeHelix                               = 4,
	PrimeHelix_OpBuff                        = 5,
	BlackBuff                                = 6,
	BlueBuff                                 = 7,
	RedBuff                                  = 8,
	JungleBuff                               = 9,
	RiverAbilityDamageBuff                   = 10,
	RiverDoTDamageBuff                       = 11,
	RiverMoveSpeedDamageBuff                 = 12,
	RiverShadowPlaneDamageBuff               = 13,
	SafeLaneBuff                             = 14,
	SpendCardPoints                          = 15,
	WellIsEmpty                              = 16,
	WellIsInactive                           = 17,
	WellIsContested                          = 18,
	NeedRigCard                              = 19,
	MAX                                      = 20,
};

// Enum OrionGame.EAbilityPipDisplayType
// NumValues: 0x0006
enum class EAbilityPipDisplayType : uint8
{
	Five_Pips                                = 0,
	Three_Pips                               = 1,
	Four_Pips                                = 2,
	Two_Pips                                 = 3,
	No_Pips                                  = 4,
	EAbilityPipDisplayType_MAX               = 5,
};

// Enum OrionGame.EOrionAnalogStick
// NumValues: 0x0004
enum class EOrionAnalogStick : uint8
{
	Left                                     = 0,
	Right                                    = 1,
	None                                     = 2,
	EOrionAnalogStick_MAX                    = 3,
};

// Enum OrionGame.EOrionGestureDirection
// NumValues: 0x0006
enum class EOrionGestureDirection : uint8
{
	Right                                    = 0,
	Down                                     = 1,
	Left                                     = 2,
	Up                                       = 3,
	None                                     = 4,
	EOrionGestureDirection_MAX               = 5,
};

// Enum OrionGame.EOrionLobbyBuilderResult
// NumValues: 0x001C
enum class EOrionLobbyBuilderResult : uint8
{
	None                                     = 0,
	Success                                  = 1,
	Cancelled_Explicit                       = 2,
	Cancelled_ReadyCheckFailed               = 3,
	Cancelled_ReadyCheckTimeout              = 4,
	Cancelled_MemberPromoted                 = 5,
	Cancelled_MemberQuit                     = 6,
	AlreadyInProgress                        = 7,
	AlreadyFinished                          = 8,
	InvalidUser                              = 9,
	InvalidControllerId                      = 10,
	InvalidPlaylist                          = 11,
	NotInParty                               = 12,
	NotPartyLeader                           = 13,
	InvalidCustomKeyPlaylist                 = 14,
	InvalidCustomKeyParty                    = 15,
	TooManyPlayers                           = 16,
	InvalidCancelState                       = 17,
	MatchmakerInUse                          = 18,
	InvalidSessionInterface                  = 19,
	FindSessionsFailed                       = 20,
	FailedBeaconReconnect                    = 21,
	FailedToGetPartyMMR                      = 22,
	UnexpectedMatchmakerState                = 23,
	RemovedFromParty                         = 24,
	UnexpectedReservationResponse            = 25,
	NotInGameSession                         = 26,
	EOrionLobbyBuilderResult_MAX             = 27,
};

// Enum OrionGame.EOrionLobbyBuilderState
// NumValues: 0x000E
enum class EOrionLobbyBuilderState : uint8
{
	None                                     = 0,
	Starting                                 = 1,
	Searching                                = 2,
	CancelSearchPass                         = 3,
	PatchCheck                               = 4,
	RetrySearch                              = 5,
	ReconnectToBeacon                        = 6,
	LeavingLobby                             = 7,
	WaitingForPlayers                        = 8,
	ReadyingUp                               = 9,
	TravellingToMatch                        = 10,
	HandlingError                            = 11,
	Finished                                 = 12,
	EOrionLobbyBuilderState_MAX              = 13,
};

// Enum OrionGame.EMatchmakingFlags
// NumValues: 0x0005
enum class EMatchmakingFlags : uint8
{
	None                                     = 0,
	CreateNewOnly                            = 1,
	NoReservation                            = 2,
	Private                                  = 4,
	EMatchmakingFlags_MAX                    = 5,
};

// Enum OrionGame.EMatchmakingUpdateStatus
// NumValues: 0x000A
enum class EMatchmakingUpdateStatus : uint8
{
	NoStatus                                 = 0,
	Started                                  = 1,
	Searching                                = 2,
	CreatingReservation                      = 3,
	JoiningSession                           = 4,
	ConnectionFailure                        = 5,
	WaitingForPartyLeader                    = 6,
	Finished                                 = 7,
	Cancelling                               = 8,
	EMatchmakingUpdateStatus_MAX             = 9,
};

// Enum OrionGame.EMatchmakingCompleteResult
// NumValues: 0x0008
enum class EMatchmakingCompleteResult : uint8
{
	NotStarted                               = 0,
	NoResults                                = 1,
	NoOnlineSession                          = 2,
	NoOnlineAccount                          = 3,
	Success                                  = 4,
	Cancelled                                = 5,
	Failure                                  = 6,
	EMatchmakingCompleteResult_MAX           = 7,
};

// Enum OrionGame.EPlaylistType
// NumValues: 0x0009
enum class EPlaylistType : uint8
{
	Training                                 = 0,
	MOBAUnranked                             = 1,
	MOBARanked                               = 2,
	MOBARankedFast                           = 3,
	TeamBuilder                              = 4,
	CoopVsAI                                 = 5,
	PracticeVsAI                             = 6,
	None                                     = 7,
	EPlaylistType_MAX                        = 8,
};

// Enum OrionGame.EOrionCardPackType
// NumValues: 0x0005
enum class EOrionCardPackType : uint8
{
	CardPack                                 = 0,
	LootCrate                                = 1,
	Chest                                    = 2,
	Other                                    = 3,
	EOrionCardPackType_MAX                   = 4,
};

// Enum OrionGame.EClashMobSocialType
// NumValues: 0x0004
enum class EClashMobSocialType : uint8
{
	SOLO                                     = 0,
	CLAN                                     = 1,
	COMMUNITY                                = 2,
	EClashMobSocialType_MAX                  = 3,
};

// Enum OrionGame.EOrionBanReason
// NumValues: 0x0007
enum class EOrionBanReason : uint8
{
	Unknown                                  = 0,
	NotBanned                                = 1,
	QueueDodgeWarning                        = 2,
	QueueDodge                               = 3,
	AbandonedMatch                           = 4,
	CSInfraction                             = 5,
	MAX                                      = 6,
};

// Enum OrionGame.EOrionStatEvaluationType
// NumValues: 0x0004
enum class EOrionStatEvaluationType : uint8
{
	AccountPersistant                        = 0,
	Accumulated                              = 1,
	Match                                    = 2,
	EOrionStatEvaluationType_MAX             = 3,
};

// Enum OrionGame.EOrionQuestObjectiveStatTrackType
// NumValues: 0x0005
enum class EOrionQuestObjectiveStatTrackType : uint8
{
	Account                                  = 0,
	Quest                                    = 1,
	Match                                    = 2,
	GameLife                                 = 3,
	EOrionQuestObjectiveStatTrackType_MAX    = 4,
};

// Enum OrionGame.EOrionQuestRegistration
// NumValues: 0x0004
enum class EOrionQuestRegistration : uint8
{
	ServerAndClient                          = 0,
	ServerOnly                               = 1,
	ClientOnly                               = 2,
	EOrionQuestRegistration_MAX              = 3,
};

// Enum OrionGame.EOrionPrereqOp
// NumValues: 0x0006
enum class EOrionPrereqOp : uint8
{
	GreaterThan                              = 0,
	GreaterThanEqualTo                       = 1,
	LessThan                                 = 2,
	LessThanEqualTo                          = 3,
	Equals                                   = 4,
	Max                                      = 5,
};

// Enum OrionGame.EOrionQuestType
// NumValues: 0x0009
enum class EOrionQuestType : uint8
{
	PROGRESSION                              = 0,
	HERO                                     = 1,
	DAILY                                    = 2,
	WEEKLY                                   = 3,
	STORY                                    = 4,
	BADGE                                    = 5,
	TIPS                                     = 6,
	TUTORIAL                                 = 7,
	EOrionQuestType_MAX                      = 8,
};

// Enum OrionGame.EOrionDesiredAnalogCursorState
// NumValues: 0x0005
enum class EOrionDesiredAnalogCursorState : uint8
{
	GameOnly                                 = 0,
	GameAndUI                                = 1,
	UIOnly                                   = 2,
	None                                     = 3,
	EOrionDesiredAnalogCursorState_MAX       = 4,
};

// Enum OrionGame.EOrionMenuSlotTypes
// NumValues: 0x000E
enum class EOrionMenuSlotTypes : uint8
{
	CardMenu                                 = 0,
	TeamComms                                = 1,
	Character                                = 2,
	Scoreboard                               = 3,
	EscapeMenu                               = 4,
	DebugTeamSelect                          = 5,
	AbilityUpgradePanel                      = 6,
	AbilityUpgradePanelPullTab               = 7,
	LargeMinimap                             = 8,
	SurrenderReasonMenu                      = 9,
	Emote                                    = 10,
	QuickShopPanel                           = 11,
	MAX                                      = 12,
	None                                     = 13,
};

// Enum OrionGame.EOrionMinionAttackState
// NumValues: 0x0004
enum class EOrionMinionAttackState : uint8
{
	NotAttacking                             = 0,
	AttackingA                               = 1,
	AttackingB                               = 2,
	EOrionMinionAttackState_MAX              = 3,
};

// Enum OrionGame.EJogAdditive
// NumValues: 0x0006
enum class EJogAdditive : uint8
{
	None                                     = 0,
	PrimaryJog                               = 1,
	TravelPrepare                            = 2,
	ConsecratedGround                        = 3,
	LifeLock                                 = 4,
	EJogAdditive_MAX                         = 5,
};

// Enum OrionGame.ENavFieldDistanceClass
// NumValues: 0x0005
enum class ENavFieldDistanceClass : uint8
{
	NoSample                                 = 0,
	Lane                                     = 1,
	NearLane                                 = 2,
	Jungle                                   = 3,
	MAX                                      = 4,
};

// Enum OrionGame.EDailyRewardType
// NumValues: 0x0005
enum class EDailyRewardType : uint8
{
	Invalid                                  = 0,
	Random                                   = 1,
	Normal                                   = 2,
	Major                                    = 3,
	EDailyRewardType_MAX                     = 4,
};

// Enum OrionGame.EOrionCaptureResults
// NumValues: 0x0005
enum class EOrionCaptureResults : uint8
{
	ApplyGEToTeam_Players                    = 0,
	ApplyGEToTeam_All                        = 1,
	ApplyGEToIndividual                      = 2,
	ManuallyHandleCapture                    = 3,
	EOrionCaptureResults_MAX                 = 4,
};

// Enum OrionGame.EObjectiveDependecyRelation
// NumValues: 0x0003
enum class EObjectiveDependecyRelation : uint8
{
	MustBeDown                               = 0,
	AnyDown                                  = 1,
	EObjectiveDependecyRelation_MAX          = 2,
};

// Enum OrionGame.EOrionBeaconLobbyState
// NumValues: 0x0004
enum class EOrionBeaconLobbyState : uint8
{
	PreReadyCheck                            = 0,
	ReadyCheck                               = 1,
	PostReadyCheck                           = 2,
	EOrionBeaconLobbyState_MAX               = 3,
};

// Enum OrionGame.EPartySetTeamInfoResult
// NumValues: 0x0007
enum class EPartySetTeamInfoResult : uint8
{
	Error                                    = 0,
	InvalidTeam                              = 1,
	NoTeam                                   = 2,
	NotLeader                                = 3,
	InvalidPlaylist                          = 4,
	Success                                  = 5,
	EPartySetTeamInfoResult_MAX              = 6,
};

// Enum OrionGame.EOrionPartyGameStateFlags
// NumValues: 0x0002
enum class EOrionPartyGameStateFlags : uint8
{
	SessionId                                = 0,
	EOrionPartyGameStateFlags_MAX            = 1,
};

// Enum OrionGame.EOrionPersistentPartyGameStateFlags
// NumValues: 0x000D
enum class EOrionPersistentPartyGameStateFlags : uint8
{
	SessionId                                = 0,
	PartyProgression                         = 1,
	PlaylistID                               = 2,
	AIDifficulty                             = 3,
	MatchmakingCustomKey                     = 4,
	MatchmakingState                         = 5,
	NumPlayersNeeded                         = 6,
	MatchmakingResult                        = 7,
	AcceptMatchPlayers                       = 8,
	LockInHeroResponses                      = 9,
	MatchmakingEstWaitTime                   = 10,
	MatchmakingBucketId                      = 11,
	EOrionPersistentPartyGameStateFlags_MAX  = 12,
};

// Enum OrionGame.EOrionPartyMatchmakingState
// NumValues: 0x0009
enum class EOrionPartyMatchmakingState : uint8
{
	None                                     = 0,
	Searching                                = 1,
	ConnectingToLobby                        = 2,
	WaitingForPlayers                        = 3,
	ReadyCheck                               = 4,
	TravelToMatch                            = 5,
	ProcessCancel                            = 6,
	ProcessError                             = 7,
	EOrionPartyMatchmakingState_MAX          = 8,
};

// Enum OrionGame.EOrionPartyState
// NumValues: 0x0007
enum class EOrionPartyState : uint8
{
	Frontend                                 = 0,
	Matchmaking                              = 1,
	PostMatchmaking                          = 2,
	TeamBuilder_ConvertToTeam                = 3,
	PreGameLobby                             = 4,
	InGame                                   = 5,
	EOrionPartyState_MAX                     = 6,
};

// Enum OrionGame.EOrionPersistentPartyMemberStateFlags
// NumValues: 0x000D
enum class EOrionPersistentPartyMemberStateFlags : uint8
{
	AccountLevel                             = 0,
	LevelProgress                            = 1,
	MatchmakingLevel                         = 2,
	bAfk                                     = 3,
	Location                                 = 4,
	bReady                                   = 5,
	AcceptMatchState                         = 6,
	HeroName                                 = 7,
	bLoaded                                  = 8,
	MMR                                      = 9,
	bMMRAdjustedForNewPlayer                 = 10,
	BanReason                                = 11,
	EOrionPersistentPartyMemberStateFlags_MAX = 12,
};

// Enum OrionGame.EOrionPartyMemberLocation
// NumValues: 0x0009
enum class EOrionPartyMemberLocation : uint8
{
	PreLobby                                 = 0,
	ConnectingToLobby                        = 1,
	Lobby                                    = 2,
	PreGame                                  = 3,
	JoiningGame                              = 4,
	InGame                                   = 5,
	Replay                                   = 6,
	Rejoin                                   = 7,
	EOrionPartyMemberLocation_MAX            = 8,
};

// Enum OrionGame.EOrionLevelType
// NumValues: 0x0004
enum class EOrionLevelType : uint8
{
	Account                                  = 0,
	Hero                                     = 1,
	Skin                                     = 2,
	EOrionLevelType_MAX                      = 3,
};

// Enum OrionGame.EOrionQuestState
// NumValues: 0x0005
enum class EOrionQuestState : uint8
{
	Inactive                                 = 0,
	Active                                   = 1,
	Completed                                = 2,
	Claimed                                  = 3,
	EOrionQuestState_MAX                     = 4,
};

// Enum OrionGame.EOrionBoostType
// NumValues: 0x0009
enum class EOrionBoostType : uint8
{
	XP                                       = 0,
	TimeCurrency                             = 1,
	XPWinCount                               = 2,
	TimeCurrencyWinCount                     = 3,
	CraftingSave                             = 4,
	CraftingEnhance                          = 5,
	Subscription                             = 6,
	Founders                                 = 7,
	EOrionBoostType_MAX                      = 8,
};

// Enum OrionGame.EFTestActorKey
// NumValues: 0x002E
enum class EFTestActorKey : uint8
{
	Null                                     = 0,
	Player                                   = 1,
	AllyHero1                                = 2,
	AllyHero2                                = 3,
	AllyHero3                                = 4,
	AllyMinion1                              = 5,
	AllyMinion2                              = 6,
	AllyMinion3                              = 7,
	EnemyHero1                               = 8,
	EnemyHero2                               = 9,
	EnemyHero3                               = 10,
	EnemyMinion1                             = 11,
	EnemyMinion2                             = 12,
	EnemyMinion3                             = 13,
	JungleMinion1                            = 14,
	JungleMinion2                            = 15,
	JungleMinion3                            = 16,
	Placeable1                               = 17,
	Placeable2                               = 18,
	Placeable3                               = 19,
	Projectile1                              = 20,
	Projectile2                              = 21,
	Projectile3                              = 22,
	Volume1                                  = 23,
	Volume2                                  = 24,
	Volume3                                  = 25,
	BlueCore                                 = 26,
	BlueCoreAimTarget                        = 27,
	BlueInhibitor                            = 28,
	BlueInhibitorAimTarget                   = 29,
	BlueTower                                = 30,
	BlueTowerAimTarget                       = 31,
	BlueRefinery                             = 32,
	BlueRefineryAimTarget                    = 33,
	RedCore                                  = 34,
	RedCoreAimTarget                         = 35,
	RedInhibitor                             = 36,
	RedInhibitorAimTarget                    = 37,
	RedTower                                 = 38,
	RedTowerAimTarget                        = 39,
	RedRefinery                              = 40,
	RedRefineryAimTarget                     = 41,
	FXAimTargetNear                          = 42,
	FXAimTargetMid                           = 43,
	FXAimTargetFar                           = 44,
	EFTestActorKey_MAX                       = 45,
};

// Enum OrionGame.EReturnToMainMenuReason
// NumValues: 0x0028
enum class EReturnToMainMenuReason : uint8
{
	None                                     = 0,
	Unknown                                  = 1,
	QuittingGame                             = 2,
	LoggedOut                                = 3,
	LeftMatch                                = 4,
	LeftLobby                                = 5,
	LeftPartyFromLobby                       = 6,
	LeftPartyFromGame                        = 7,
	LeftGameToJoinParty                      = 8,
	QuittingReplay                           = 9,
	Critical                                 = 10,
	ServerError                              = 11,
	LostConnectionToHost                     = 12,
	WaitingForPlayersTimeout                 = 13,
	DraftLobbyLockInTimeout                  = 14,
	DraftLobbyPlayerLeft                     = 15,
	PlaybackError                            = 16,
	InvalidPlayerStateHero                   = 17,
	InvalidPlayerStateTeam                   = 18,
	InvalidPlayerStateDeck                   = 19,
	NotAllowedInMatch                        = 20,
	PlayerAbandoned                          = 21,
	MatchAbandoned                           = 22,
	NoEnemyTeam                              = 23,
	ServersOffline                           = 24,
	PlayAccessEnded                          = 25,
	PrivilegeWarning                         = 26,
	PlayersFailedToJoin                      = 27,
	FailedToSyncProfile                      = 28,
	InvalidPlayerData                        = 29,
	ClientNeedsPatch                         = 30,
	ClientNeedsReload                        = 31,
	ClientNeedsRelaunch                      = 32,
	ClientFailedToUpdate                     = 33,
	NetGuidMismatch                          = 34,
	NetChecksumMismatch                      = 35,
	MustBeLoggedInToUpdate                   = 36,
	CheatDetected                            = 37,
	CheatDetectedLogout                      = 38,
	EReturnToMainMenuReason_MAX              = 39,
};

// Enum OrionGame.EOrionDraftAbortPenaltyReason
// NumValues: 0x0006
enum class EOrionDraftAbortPenaltyReason : uint8
{
	None                                     = 0,
	LockInFailure                            = 1,
	AssociatedWithLockInFailure              = 2,
	Leaver                                   = 3,
	AssociatedWithLeaver                     = 4,
	EOrionDraftAbortPenaltyReason_MAX        = 5,
};

// Enum OrionGame.EOrionDraftPickStatus
// NumValues: 0x0007
enum class EOrionDraftPickStatus : uint8
{
	WaitingForPlayers                        = 0,
	Waiting                                  = 1,
	UpNext                                   = 2,
	Picking                                  = 3,
	LockedIn                                 = 4,
	Complete                                 = 5,
	EOrionDraftPickStatus_MAX                = 6,
};

// Enum OrionGame.EOrionDamageType
// NumValues: 0x0004
enum class EOrionDamageType : uint8
{
	Invalid                                  = 0,
	Physical                                 = 1,
	Energy                                   = 2,
	EOrionDamageType_MAX                     = 3,
};

// Enum OrionGame.EDeathLogState
// NumValues: 0x0003
enum class EDeathLogState : uint8
{
	Closed                                   = 0,
	SummaryOpened                            = 1,
	EDeathLogState_MAX                       = 2,
};

// Enum OrionGame.EPlaylistEntryType
// NumValues: 0x0004
enum class EPlaylistEntryType : uint8
{
	Generic                                  = 0,
	PVP                                      = 1,
	Arcade                                   = 2,
	MAX                                      = 3,
};

// Enum OrionGame.EPieceOfFlairType
// NumValues: 0x0015
enum class EPieceOfFlairType : uint8
{
	OneCardReward                            = 0,
	MultipleCardReward                       = 1,
	Coins                                    = 2,
	OneCardPack                              = 3,
	MultipleCardPacks                        = 4,
	HeroUnlocked                             = 5,
	DeckBuilderUnlocked                      = 6,
	PvPUnlocked                              = 7,
	SkinReward                               = 8,
	EmoteReward                              = 9,
	Reputation                               = 10,
	StarterDeck                              = 11,
	Boost                                    = 12,
	DeckSlot                                 = 13,
	Banner                                   = 14,
	BannerAlteration                         = 15,
	LootCrate                                = 16,
	CardCraftingUnlock                       = 17,
	LootCrateKey                             = 18,
	SkinVariationReward                      = 19,
	MAX                                      = 20,
};

// Enum OrionGame.EOrionProjectileTimeDilation
// NumValues: 0x0005
enum class EOrionProjectileTimeDilation : uint8
{
	NotActive                                = 0,
	LerpingIn                                = 1,
	ArrivedAtTarget                          = 2,
	LerpingOut                               = 3,
	EOrionProjectileTimeDilation_MAX         = 4,
};

// Enum OrionGame.ENetSyncActionRequestType
// NumValues: 0x0004
enum class ENetSyncActionRequestType : uint8
{
	All                                      = 0,
	FromServerOnly                           = 1,
	FromClientOnly                           = 2,
	ENetSyncActionRequestType_MAX            = 3,
};

// Enum OrionGame.EOrionProjectileSyncAction
// NumValues: 0x0007
enum class EOrionProjectileSyncAction : uint8
{
	None                                     = 0,
	StartTimeDilation                        = 1,
	TimeDilationArrived                      = 2,
	SetNewTarget                             = 3,
	WorldCollision                           = 4,
	HitActor                                 = 5,
	EOrionProjectileSyncAction_MAX           = 6,
};

// Enum OrionGame.EQualifierAggregationType
// NumValues: 0x0005
enum class EQualifierAggregationType : uint8
{
	Frame                                    = 0,
	Ability                                  = 1,
	Time                                     = 2,
	Indefinite                               = 3,
	EQualifierAggregationType_MAX            = 4,
};

// Enum OrionGame.EQualifierEvaluationResult
// NumValues: 0x0004
enum class EQualifierEvaluationResult : uint8
{
	Pass                                     = 0,
	Fail                                     = 1,
	InvalidContext                           = 2,
	EQualifierEvaluationResult_MAX           = 3,
};

// Enum OrionGame.EEQSAIInfluenceQuery
// NumValues: 0x0005
enum class EEQSAIInfluenceQuery : uint8
{
	ContextsTeam                             = 0,
	ContextsEnemies                          = 1,
	TotalValueForContextsTeam                = 2,
	TotalValueForEnemies                     = 3,
	EEQSAIInfluenceQuery_MAX                 = 4,
};

// Enum OrionGame.EAILaneProgressReference
// NumValues: 0x0003
enum class EAILaneProgressReference : uint8
{
	Absolute                                 = 0,
	RelativeToFrontLine                      = 1,
	EAILaneProgressReference_MAX             = 2,
};

// Enum OrionGame.EFocusMethod
// NumValues: 0x0004
enum class EFocusMethod : uint8
{
	NoFocus                                  = 0,
	AutoFocus                                = 1,
	ManualFocus                              = 2,
	EFocusMethod_MAX                         = 3,
};

// Enum OrionGame.ERichTextInlineIconDisplayMode
// NumValues: 0x0004
enum class ERichTextInlineIconDisplayMode : uint8
{
	IconOnly                                 = 0,
	TextOnly                                 = 1,
	IconAndText                              = 2,
	MAX                                      = 3,
};

// Enum OrionGame.EOrionShapeDimensionType
// NumValues: 0x0005
enum class EOrionShapeDimensionType : uint8
{
	ScalableFloat                            = 0,
	ProjectileRange                          = 1,
	ProjectileBlockRadius                    = 2,
	ProjectileOverlapRadius                  = 3,
	EOrionShapeDimensionType_MAX             = 4,
};

// Enum OrionGame.EOrionShapeFacetType
// NumValues: 0x0008
enum class EOrionShapeFacetType : uint8
{
	Beam                                     = 0,
	Box                                      = 1,
	Character                                = 2,
	Sector                                   = 3,
	Sphere                                   = 4,
	Cylinder                                 = 5,
	COUNT                                    = 6,
	EOrionShapeFacetType_MAX                 = 7,
};

// Enum OrionGame.EOrionSignificanceType
// NumValues: 0x0006
enum class EOrionSignificanceType : uint8
{
	Hero                                     = 0,
	Minion                                   = 1,
	Objective                                = 2,
	VFX                                      = 3,
	COUNT                                    = 4,
	EOrionSignificanceType_MAX               = 5,
};

// Enum OrionGame.EIsometricCamAngle
// NumValues: 0x0005
enum class EIsometricCamAngle : uint8
{
	Sideline                                 = 0,
	RedEndzone                               = 1,
	BlueEndzone                              = 2,
	Diagonal                                 = 3,
	EIsometricCamAngle_MAX                   = 4,
};

// Enum OrionGame.EStatusEffectTextDisplayRule
// NumValues: 0x0006
enum class EStatusEffectTextDisplayRule : uint8
{
	Always                                   = 0,
	OnlyMyTeam                               = 1,
	OnlyLocalParticipant                     = 2,
	OnlySelf                                 = 3,
	Never                                    = 4,
	EStatusEffectTextDisplayRule_MAX         = 5,
};

// Enum OrionGame.EOrionTargetTestResult
// NumValues: 0x0004
enum class EOrionTargetTestResult : uint8
{
	NotTested                                = 0,
	Failed                                   = 1,
	Passed                                   = 2,
	EOrionTargetTestResult_MAX               = 3,
};

// Enum OrionGame.EOrionTargetingModeValidationFailPolicy
// NumValues: 0x0003
enum class EOrionTargetingModeValidationFailPolicy : uint8
{
	UseServerDataAndConfirm                  = 0,
	CancelTargeting                          = 1,
	EOrionTargetingModeValidationFailPolicy_MAX = 2,
};

// Enum OrionGame.EOrionTargetingModePlacementPolicy
// NumValues: 0x0006
enum class EOrionTargetingModePlacementPolicy : uint8
{
	Character                                = 0,
	AimFromCamera                            = 1,
	Ground                                   = 2,
	AimFromCharacter                         = 3,
	GroundOnNavMeshOnly                      = 4,
	EOrionTargetingModePlacementPolicy_MAX   = 5,
};

// Enum OrionGame.EOrionTeamCompDebugSlotStatus
// NumValues: 0x0005
enum class EOrionTeamCompDebugSlotStatus : uint8
{
	Invalid                                  = 0,
	Searching                                = 1,
	Filled                                   = 2,
	Abandoned                                = 3,
	EOrionTeamCompDebugSlotStatus_MAX        = 4,
};

// Enum OrionGame.ETBRoboCaptainState
// NumValues: 0x000E
enum class ETBRoboCaptainState : uint8
{
	NotStarted                               = 0,
	DeterminingRole                          = 1,
	FindingTeam                              = 2,
	BecomingCaptain                          = 3,
	JoiningTeam                              = 4,
	WaitingForTeam                           = 5,
	StartingTeam                             = 6,
	WaitingForSocialMembers                  = 7,
	BuildingTeam                             = 8,
	Matchmaking                              = 9,
	TravelToSession                          = 10,
	Finished                                 = 11,
	HandlingError                            = 12,
	ETBRoboCaptainState_MAX                  = 13,
};

// Enum OrionGame.ETBSearchFlags
// NumValues: 0x0002
enum class ETBSearchFlags : uint8
{
	None                                     = 0,
	ETBSearchFlags_MAX                       = 1,
};

// Enum OrionGame.ETBSearchState
// NumValues: 0x000B
enum class ETBSearchState : uint8
{
	NotSearching                             = 0,
	CancelingSearch                          = 1,
	HandlingFailure                          = 2,
	Searching                                = 3,
	NoResults                                = 4,
	PlayerFound                              = 5,
	InvitationSent                           = 6,
	RejectedPlayer                           = 7,
	TimerExpired                             = 8,
	Success                                  = 9,
	ETBSearchState_MAX                       = 10,
};

// Enum OrionGame.ETBSlotCompleteResult
// NumValues: 0x0008
enum class ETBSlotCompleteResult : uint8
{
	NotStarted                               = 0,
	Cancelled                                = 1,
	NoResults                                = 2,
	Rejected                                 = 3,
	TimerExpired                             = 4,
	Failure                                  = 5,
	PlayerFound                              = 6,
	ETBSlotCompleteResult_MAX                = 7,
};

// Enum OrionGame.EOrionTBSoloRiderState
// NumValues: 0x0009
enum class EOrionTBSoloRiderState : uint8
{
	None                                     = 0,
	Finalizing                               = 1,
	Cancelling                               = 2,
	HandlingError                            = 3,
	CreatingSession                          = 4,
	Advertising                              = 5,
	InvitePending                            = 6,
	JoiningParty                             = 7,
	EOrionTBSoloRiderState_MAX               = 8,
};

// Enum OrionGame.ETeamBuilderState
// NumValues: 0x0005
enum class ETeamBuilderState : uint8
{
	None                                     = 0,
	FindingTeam                              = 1,
	TeamBuilding                             = 2,
	TeamMatchmaking                          = 3,
	ETeamBuilderState_MAX                    = 4,
};

// Enum OrionGame.ETeamBuilderPlayerFilterReason
// NumValues: 0x0009
enum class ETeamBuilderPlayerFilterReason : uint8
{
	None                                     = 0,
	RejectedByCaptain                        = 1,
	RejectedByPlayer                         = 2,
	CaptainApprovalExpired                   = 3,
	PlayerApprovalExpired                    = 4,
	HeroTaken                                = 5,
	BeingEvaluatedByCaptain                  = 6,
	ExitedTeamBuilder                        = 7,
	ETeamBuilderPlayerFilterReason_MAX       = 8,
};

// Enum OrionGame.EOrionTeamBuilderPartyGameStateFlags
// NumValues: 0x000A
enum class EOrionTeamBuilderPartyGameStateFlags : uint8
{
	SessionId                                = 0,
	PartyProgression                         = 1,
	ReservedSlots                            = 2,
	ChatRoomId                               = 3,
	PendingMember0                           = 4,
	PendingMember1                           = 5,
	PendingMember2                           = 6,
	PendingMember3                           = 7,
	PendingMember4                           = 8,
	EOrionTeamBuilderPartyGameStateFlags_MAX = 9,
};

// Enum OrionGame.ETeamBuilderProgression
// NumValues: 0x0005
enum class ETeamBuilderProgression : uint8
{
	Idle                                     = 0,
	BuildingTeam                             = 1,
	Matchmaking                              = 2,
	PostMatchmaking                          = 3,
	ETeamBuilderProgression_MAX              = 4,
};

// Enum OrionGame.EOrionTeamBuilderPartyMemberStateFlags
// NumValues: 0x000E
enum class EOrionTeamBuilderPartyMemberStateFlags : uint8
{
	AccountLevel                             = 0,
	LevelProgress                            = 1,
	MatchmakingLevel                         = 2,
	bAfk                                     = 3,
	SlotIdx                                  = 4,
	HeroName                                 = 5,
	DeckId                                   = 6,
	Position                                 = 7,
	Role                                     = 8,
	Ready                                    = 9,
	BlockedPlayers                           = 10,
	Platform                                 = 11,
	CosmeticString                           = 12,
	EOrionTeamBuilderPartyMemberStateFlags_MAX = 13,
};

// Enum OrionGame.ETeamBuilderRole
// NumValues: 0x0005
enum class ETeamBuilderRole : uint8
{
	None                                     = 0,
	Captain                                  = 1,
	TeamMember                               = 2,
	SoloRider                                = 3,
	ETeamBuilderRole_MAX                     = 4,
};

// Enum OrionGame.EOrionTBMemberState
// NumValues: 0x0006
enum class EOrionTBMemberState : uint8
{
	Found                                    = 0,
	Invited                                  = 1,
	Accepted                                 = 2,
	Joined                                   = 3,
	MAX_None                                 = 4,
	EOrionTBMemberState_MAX                  = 5,
};

// Enum OrionGame.EOrionTBSoloRiderResult
// NumValues: 0x0009
enum class EOrionTBSoloRiderResult : uint8
{
	Error                                    = 0,
	InvalidState                             = 1,
	FailedToCreateSession                    = 2,
	FailedToJoinParty                        = 3,
	Success                                  = 4,
	Cancelled                                = 5,
	DeclinedInvite                           = 6,
	MAX_None                                 = 7,
	EOrionTBSoloRiderResult_MAX              = 8,
};

// Enum OrionGame.ESurrenderVote
// NumValues: 0x0005
enum class ESurrenderVote : uint8
{
	CantVote                                 = 0,
	NoVote                                   = 1,
	VotedYes                                 = 2,
	VotedNo                                  = 3,
	ESurrenderVote_MAX                       = 4,
};

// Enum OrionGame.ETeamSurrenderStatus
// NumValues: 0x0006
enum class ETeamSurrenderStatus : uint8
{
	TooEarlyToSurrender                      = 0,
	VoteNotStarted                           = 1,
	VoteStarted                              = 2,
	VotePassed                               = 3,
	VoteFailed                               = 4,
	ETeamSurrenderStatus_MAX                 = 5,
};

// Enum OrionGame.EPathLerpType
// NumValues: 0x000B
enum class EPathLerpType : uint8
{
	Linear                                   = 0,
	CircularIn                               = 1,
	CircularOut                              = 2,
	CircularInOut                            = 3,
	SineIn                                   = 4,
	SineOut                                  = 5,
	SineInOut                                = 6,
	EaseIn                                   = 7,
	EaseOut                                  = 8,
	EaseInOut                                = 9,
	EPathLerpType_MAX                        = 10,
};

// Enum OrionGame.EOrionPlayerStartType
// NumValues: 0x0004
enum class EOrionPlayerStartType : uint8
{
	AnyHero                                  = 0,
	BotsOnly                                 = 1,
	PlayersOnly                              = 2,
	EOrionPlayerStartType_MAX                = 3,
};

// Enum OrionGame.EArcadeEffectTeamType
// NumValues: 0x0004
enum class EArcadeEffectTeamType : uint8
{
	All                                      = 0,
	FriendlyOnly                             = 1,
	EnemyOnly                                = 2,
	EArcadeEffectTeamType_MAX                = 3,
};

// Enum OrionGame.EArcadeEffectPlayerType
// NumValues: 0x0004
enum class EArcadeEffectPlayerType : uint8
{
	All                                      = 0,
	HumansOnly                               = 1,
	BotsOnly                                 = 2,
	EArcadeEffectPlayerType_MAX              = 3,
};

// Enum OrionGame.ECMSRelevantContentType
// NumValues: 0x0006
enum class ECMSRelevantContentType : uint8
{
	Invalid                                  = 0,
	Skin                                     = 1,
	Mastery                                  = 2,
	Emote                                    = 3,
	Coin                                     = 4,
	ECMSRelevantContentType_MAX              = 5,
};

// Enum OrionGame.ECarriedBuffType
// NumValues: 0x000B
enum class ECarriedBuffType : uint8
{
	Hidden                                   = 0,
	Default                                  = 1,
	Jungle                                   = 2,
	RiverAbilityDamage                       = 3,
	RiverDOT                                 = 4,
	RiverMoveSpeed                           = 5,
	RiverShadowPlane                         = 6,
	SafeLane                                 = 7,
	Prime                                    = 8,
	BlackBuff                                = 9,
	MAX                                      = 10,
};

// Enum OrionGame.ELaneRoleSlot
// NumValues: 0x0006
enum class ELaneRoleSlot : uint8
{
	Offlane                                  = 0,
	Midlane                                  = 1,
	SafelaneCary                             = 2,
	SafelaneHelp                             = 3,
	Jungle                                   = 4,
	MAX                                      = 5,
};

// Enum OrionGame.EHUDTutorialVisibilityState
// NumValues: 0x0003
enum class EHUDTutorialVisibilityState : uint8
{
	StartVisible                             = 0,
	StartHidden                              = 1,
	EHUDTutorialVisibilityState_MAX          = 2,
};

// Enum OrionGame.EPlayerRatingResult
// NumValues: 0x000C
enum class EPlayerRatingResult : uint8
{
	None                                     = 0,
	MoraleBooster                            = 1,
	TeamPlayer                               = 2,
	Teacher                                  = 3,
	Strategist                               = 4,
	Pro                                      = 5,
	CommsAbuser                              = 6,
	Deserter                                 = 7,
	Saboteur                                 = 8,
	Cheater                                  = 9,
	Mismatched                               = 10,
	EPlayerRatingResult_MAX                  = 11,
};

// Enum OrionGame.EOrionHeroAvailability
// NumValues: 0x0005
enum class EOrionHeroAvailability : uint8
{
	Available                                = 0,
	Banned                                   = 1,
	Locked                                   = 2,
	Taken                                    = 3,
	MAX                                      = 4,
};

// Enum OrionGame.ETravelModeModes
// NumValues: 0x0003
enum class ETravelModeModes : uint8
{
	MoveWhileCast                            = 0,
	StopWhileCast                            = 1,
	ETravelModeModes_MAX                     = 2,
};

// Enum OrionGame.EOrionEmoteType
// NumValues: 0x0003
enum class EOrionEmoteType : uint8
{
	Flavor                                   = 0,
	Emote_MAX                                = 1,
	EOrionEmoteType_MAX                      = 2,
};

// Enum OrionGame.EOrionHeroAbilityType
// NumValues: 0x0005
enum class EOrionHeroAbilityType : uint8
{
	Primary                                  = 0,
	Normal                                   = 1,
	Passive                                  = 2,
	Ultimate                                 = 3,
	EOrionHeroAbilityType_MAX                = 4,
};

// Enum OrionGame.EOrionHeroStat
// NumValues: 0x0006
enum class EOrionHeroStat : uint8
{
	BasicAttack                              = 0,
	AbilityAttack                            = 1,
	Durability                               = 2,
	Mobility                                 = 3,
	Total                                    = 4,
	EOrionHeroStat_MAX                       = 5,
};

// Enum OrionGame.EOrionAcceptMatchState
// NumValues: 0x0004
enum class EOrionAcceptMatchState : uint8
{
	Invalid                                  = 0,
	Accept                                   = 1,
	Decline                                  = 2,
	MAX                                      = 3,
};

// Enum OrionGame.EOrionPlayerPlatform
// NumValues: 0x0003
enum class EOrionPlayerPlatform : uint8
{
	PC                                       = 0,
	PS4                                      = 1,
	EOrionPlayerPlatform_MAX                 = 2,
};

// Enum OrionGame.EOrionStatTypes
// NumValues: 0x0015
enum class EOrionStatTypes : uint8
{
	PhysicalRating                           = 0,
	EnergyRating                             = 1,
	PhysicalArmorPierce                      = 2,
	EnergyArmorPierce                        = 3,
	ShieldPierce                             = 4,
	AttackSpeed                              = 5,
	CriticalStrikeChance                     = 6,
	CriticalStrikeDamage                     = 7,
	Cleave                                   = 8,
	MaxHealth                                = 9,
	HealthRegen                              = 10,
	PhysicalArmor                            = 11,
	EnergyArmor                              = 12,
	Lifesteal                                = 13,
	Perserverance                            = 14,
	MaxMana                                  = 15,
	ManaRegen                                = 16,
	CooldownReduction                        = 17,
	MovementSpeed                            = 18,
	TravelSpeed                              = 19,
	Max                                      = 20,
};

// Enum OrionGame.EOrionInputType
// NumValues: 0x0004
enum class EOrionInputType : uint8
{
	Mouse_Keyboard                           = 0,
	DualShock4                               = 1,
	Xbox360                                  = 2,
	MAX                                      = 3,
};

// Enum OrionGame.EOrionChunkId
// NumValues: 0x0003
enum class EOrionChunkId : uint8
{
	DefaultChunk                             = 0,
	GameplayChunk                            = 1,
	EOrionChunkId_MAX                        = 2,
};

// Enum OrionGame.ESpectatorCameraType
// NumValues: 0x0007
enum class ESpectatorCameraType : uint8
{
	DebugFree                                = 0,
	Drone                                    = 1,
	Chase                                    = 2,
	Isometric                                = 3,
	Arena                                    = 4,
	OverTheShoulder                          = 5,
	MAX                                      = 6,
};

// Enum OrionGame.EOrionOutlineType
// NumValues: 0x0004
enum class EOrionOutlineType : uint8
{
	Teammate                                 = 1,
	Enemy                                    = 2,
	Neutral                                  = 3,
	EOrionOutlineType_MAX                    = 4,
};

// Enum OrionGame.EOrionPickUpSpeed
// NumValues: 0x0007
enum class EOrionPickUpSpeed : uint8
{
	VerySlow                                 = 0,
	Slow                                     = 1,
	Default                                  = 2,
	Fast                                     = 3,
	MaxSpeed                                 = 4,
	COUNT                                    = 5,
	EOrionPickUpSpeed_MAX                    = 6,
};

// Enum OrionGame.EOrionCardRarity
// NumValues: 0x0006
enum class EOrionCardRarity : uint8
{
	Starter                                  = 0,
	Common                                   = 1,
	Uncommon                                 = 2,
	Rare                                     = 3,
	Epic                                     = 4,
	MAX                                      = 5,
};

// Enum OrionGame.EOrionCardSlottypes
// NumValues: 0x0007
enum class EOrionCardSlottypes : uint8
{
	CST_Passive                              = 0,
	CST_Active                               = 1,
	CST_Upgrade                              = 2,
	CST_Prime                                = 3,
	CST_HandSlot_ActiveAndPassive            = 4,
	CST_None                                 = 5,
	CST_MAX                                  = 6,
};

// Enum OrionGame.EOrionVisionType
// NumValues: 0x0004
enum class EOrionVisionType : uint8
{
	Hidden                                   = 0,
	VisibleWithLOS                           = 1,
	Visible                                  = 2,
	EOrionVisionType_MAX                     = 3,
};

// Enum OrionGame.EOrionTickInterval
// NumValues: 0x0008
enum class EOrionTickInterval : uint8
{
	VerySlow                                 = 0,
	Slower                                   = 1,
	Slow                                     = 2,
	Default                                  = 3,
	Fast                                     = 4,
	VeryFast                                 = 5,
	COUNT                                    = 6,
	EOrionTickInterval_MAX                   = 7,
};

// Enum OrionGame.EOrionTeamCompare
// NumValues: 0x0007
enum class EOrionTeamCompare : uint8
{
	Any                                      = 0,
	Same                                     = 1,
	NotSame                                  = 2,
	Ally                                     = 3,
	Enemy                                    = 4,
	Neutral                                  = 5,
	EOrionTeamCompare_MAX                    = 6,
};

// Enum OrionGame.EMatchEndTeamPlacement
// NumValues: 0x0006
enum class EMatchEndTeamPlacement : uint8
{
	FirstPlace                               = 0,
	SecondPlace                              = 1,
	ThirdPlace                               = 2,
	FourthPlace                              = 3,
	FifthPlace                               = 4,
	MAX                                      = 5,
};

// Enum OrionGame.ETeamRelationship
// NumValues: 0x0004
enum class ETeamRelationship : uint8
{
	Allies                                   = 0,
	Neutral                                  = 1,
	Enemies                                  = 2,
	ETeamRelationship_MAX                    = 3,
};

// Enum OrionGame.EOrionTargetType
// NumValues: 0x0009
enum class EOrionTargetType : uint8
{
	OTT_Default                              = 0,
	OTT_Player                               = 1,
	OTT_Minion                               = 2,
	OTT_Tower                                = 3,
	OTT_Rigs                                 = 4,
	OTT_Wells                                = 5,
	OTT_Damageable                           = 6,
	OTT_TypeMax                              = 7,
	OTT_MAX                                  = 8,
};

// Enum OrionGame.ECharacterSelectionType
// NumValues: 0x0006
enum class ECharacterSelectionType : uint8
{
	CST_AllPick                              = 0,
	CST_StandardDraft                        = 1,
	CST_AllRandom                            = 2,
	CST_CaptainsMode                         = 3,
	CST_Tutorial                             = 4,
	CST_MAX                                  = 5,
};

// Enum OrionGame.ELocalVisiblityState
// NumValues: 0x0005
enum class ELocalVisiblityState : uint8
{
	None                                     = 0,
	Visible                                  = 1,
	InShadowPlane                            = 2,
	VIS_MAX                                  = 32,
	ELocalVisiblityState_MAX                 = 33,
};

// Enum OrionGame.EMiniMapDepth
// NumValues: 0x000B
enum class EMiniMapDepth : uint8
{
	LowestDepth                              = 0,
	Objects                                  = 1,
	Turrets                                  = 2,
	SmallBots                                = 3,
	TankBots                                 = 4,
	Player                                   = 5,
	Objective                                = 6,
	LocalPlayer                              = 7,
	TeamCommunications                       = 8,
	HighestDepth                             = 9,
	EMiniMapDepth_MAX                        = 10,
};

// Enum OrionGame.EMiniMapVisionChannel
// NumValues: 0x0004
enum class EMiniMapVisionChannel : uint8
{
	GameObjective                            = 0,
	WorldObjective                           = 1,
	GameObjects                              = 2,
	EMiniMapVisionChannel_MAX                = 3,
};

// Enum OrionGame.EOrionTeamCommRadialLabel
// NumValues: 0x0006
enum class EOrionTeamCommRadialLabel : uint8
{
	Option_1_Left                            = 0,
	Option_2_Up                              = 1,
	Option_3_Right                           = 2,
	Option_4_Down                            = 3,
	None                                     = 4,
	EOrionTeamCommRadialLabel_MAX            = 5,
};

// Enum OrionGame.EOrionTeamCommSelectionType
// NumValues: 0x0008
enum class EOrionTeamCommSelectionType : uint8
{
	Option_Back                              = 0,
	Option_1                                 = 1,
	Option_2                                 = 2,
	Option_3                                 = 3,
	Option_4                                 = 4,
	Option_Commit                            = 5,
	None                                     = 6,
	EOrionTeamCommSelectionType_MAX          = 7,
};

// Enum OrionGame.EButtonSelectionBehavior
// NumValues: 0x0004
enum class EButtonSelectionBehavior : uint8
{
	Stop                                     = 0,
	Wrap                                     = 1,
	Escape                                   = 2,
	EButtonSelectionBehavior_MAX             = 3,
};

// Enum OrionGame.EArcadeRoundPhase
// NumValues: 0x000B
enum class EArcadeRoundPhase : uint8
{
	PreMatch                                 = 0,
	WaitingForRecall                         = 1,
	PreRound                                 = 2,
	InRound                                  = 3,
	PostRound                                = 4,
	AllRoundsOver                            = 5,
	Restarting                               = 6,
	Overtime                                 = 7,
	MatchFinished                            = 8,
	None                                     = 9,
	EArcadeRoundPhase_MAX                    = 10,
};

// Enum OrionGame.EPedestalActorType
// NumValues: 0x0005
enum class EPedestalActorType : uint8
{
	Normal                                   = 0,
	Featured                                 = 1,
	DawnDraft                                = 2,
	DuskDraft                                = 3,
	EPedestalActorType_MAX                   = 4,
};

// Enum OrionGame.EOrionGamepadType
// NumValues: 0x0004
enum class EOrionGamepadType : uint8
{
	PS4                                      = 0,
	XBox                                     = 1,
	Shield                                   = 2,
	EOrionGamepadType_MAX                    = 3,
};

// Enum OrionGame.EOrionTeamMemberType
// NumValues: 0x0005
enum class EOrionTeamMemberType : uint8
{
	Invalid                                  = 0,
	LocalPlayer                              = 1,
	Friendly                                 = 2,
	Enemy                                    = 3,
	MAX                                      = 4,
};

// Enum OrionGame.EOrionStoreFront
// NumValues: 0x000E
enum class EOrionStoreFront : uint8
{
	Invalid                                  = 0,
	CardPacks                                = 1,
	Boosts                                   = 2,
	MtxCurrency                              = 3,
	Crafting                                 = 4,
	Decks                                    = 5,
	Skins                                    = 6,
	Bundles                                  = 7,
	Heroes                                   = 8,
	Banners                                  = 9,
	Emotes                                   = 10,
	LootCrates                               = 11,
	VaultKeys                                = 12,
	MAX                                      = 13,
};

// Enum OrionGame.EOrionStatusEffect
// NumValues: 0x000A
enum class EOrionStatusEffect : uint8
{
	Slow                                     = 0,
	Root                                     = 1,
	Silence                                  = 2,
	Stun                                     = 3,
	Bleed                                    = 4,
	Burn                                     = 5,
	Poison                                   = 6,
	KnockBack                                = 7,
	CriticallyWounded                        = 8,
	MAX                                      = 9,
};

// Enum OrionGame.EOrionAbilityValueType
// NumValues: 0x000E
enum class EOrionAbilityValueType : uint8
{
	EnergyDamage                             = 0,
	PhysicalDamage                           = 1,
	Heal                                     = 2,
	LifeSteal                                = 3,
	EnergyCost                               = 4,
	Shield                                   = 5,
	MoveSpeed                                = 6,
	CoolDown                                 = 7,
	Duration                                 = 8,
	PhysicalArmor                            = 9,
	EnergyArmor                              = 10,
	MaxHealth                                = 11,
	MaxHealthPercent                         = 12,
	MAX                                      = 13,
};

// Enum OrionGame.EOrionAttributeSummand
// NumValues: 0x0005
enum class EOrionAttributeSummand : uint8
{
	Base                                     = 0,
	Upgrade                                  = 1,
	Unlocked                                 = 2,
	None                                     = 3,
	EOrionAttributeSummand_MAX               = 4,
};

// Enum OrionGame.EOrionLevelTypes
// NumValues: 0x0002
enum class EOrionLevelTypes : uint8
{
	Account                                  = 0,
	MAX                                      = 1,
};

// Enum OrionGame.EOrionCurrencyType
// NumValues: 0x0006
enum class EOrionCurrencyType : uint8
{
	TimeCurrency                             = 0,
	MtxCurrency                              = 1,
	RealMoney                                = 2,
	InGameGold                               = 3,
	FreeToken                                = 4,
	MAX                                      = 5,
};

// Enum OrionGame.EOrionTextColor
// NumValues: 0x0006
enum class EOrionTextColor : uint8
{
	Light                                    = 0,
	Dark                                     = 1,
	Emphasis                                 = 2,
	Black                                    = 3,
	Custom                                   = 4,
	MAX                                      = 5,
};

// Enum OrionGame.EOrionWidgetStyleSize
// NumValues: 0x0004
enum class EOrionWidgetStyleSize : uint8
{
	Small                                    = 0,
	Medium                                   = 1,
	Large                                    = 2,
	MAX                                      = 3,
};

// Enum OrionGame.EOrionDialogResult
// NumValues: 0x0006
enum class EOrionDialogResult : uint8
{
	ButtonOne                                = 0,
	ButtonTwo                                = 1,
	Killed                                   = 2,
	TimedOut                                 = 3,
	Unknown                                  = 4,
	EOrionDialogResult_MAX                   = 5,
};

// Enum OrionGame.EOrionUIAnalyticsTrackingLevel
// NumValues: 0x0005
enum class EOrionUIAnalyticsTrackingLevel : uint8
{
	None                                     = 0,
	Verbose                                  = 1,
	Normal                                   = 2,
	Important                                = 3,
	EOrionUIAnalyticsTrackingLevel_MAX       = 4,
};

// Enum OrionGame.EOrionVisionDef
// NumValues: 0x0010
enum class EOrionVisionDef : uint8
{
	Hero                                     = 0,
	Minion                                   = 1,
	Tower                                    = 2,
	Rig                                      = 3,
	Inhibitor                                = 4,
	Core                                     = 5,
	Well                                     = 6,
	Ward                                     = 7,
	PlacedObject                             = 8,
	PlacedObject_NoHealthBar                 = 9,
	JungleCamp                               = 10,
	PrimeHelixSpawn                          = 11,
	PrimeHelixReturn                         = 12,
	PrimeHelixCarry                          = 13,
	Spectator                                = 14,
	MAX                                      = 15,
};

// Enum OrionGame.EMinimapPingType
// NumValues: 0x0007
enum class EMinimapPingType : uint8
{
	Info                                     = 0,
	Attack                                   = 1,
	Defend                                   = 2,
	Danger                                   = 3,
	Ward                                     = 4,
	UnderAttack                              = 5,
	MAX                                      = 6,
};

// Enum OrionGame.EMinimapLocation
// NumValues: 0x000B
enum class EMinimapLocation : uint8
{
	PushLeft                                 = 0,
	PushMiddle                               = 1,
	PushRight                                = 2,
	AttackOrbPrime                           = 3,
	DefendLeft                               = 4,
	DefendMiddle                             = 5,
	DefendRight                              = 6,
	DefendCore                               = 7,
	AttackCamps                              = 8,
	Explicit                                 = 9,
	MAX                                      = 10,
};

// Enum OrionGame.EVisionManagerDebugMode
// NumValues: 0x0004
enum class EVisionManagerDebugMode : uint8
{
	Off                                      = 0,
	Continous                                = 1,
	Single                                   = 2,
	MAX                                      = 3,
};

// Enum OrionGame.EVisionManagerDebugSingleFilter
// NumValues: 0x0003
enum class EVisionManagerDebugSingleFilter : uint8
{
	Actual                                   = 0,
	Complete                                 = 1,
	MAX                                      = 2,
};

// Enum OrionGame.EVisionManagerDebugFilter
// NumValues: 0x0005
enum class EVisionManagerDebugFilter : uint8
{
	NoFilter                                 = 0,
	FilterViewingTeam                        = 1,
	FilterViewingActor                       = 2,
	FilterTargetActor                        = 3,
	MAX                                      = 4,
};

// Enum OrionGame.EVisionManagerDebug
// NumValues: 0x000A
enum class EVisionManagerDebug : uint8
{
	DistanceFail                             = 0,
	FOVFail                                  = 1,
	LOSFail                                  = 2,
	ShadowplaneFail                          = 3,
	PassWithLOS                              = 4,
	PassWithoutLOS                           = 5,
	ZoneVisionFail                           = 6,
	PassWithRearView                         = 7,
	ViewerBlindFail                          = 8,
	EVisionManagerDebug_MAX                  = 9,
};

// Enum OrionGame.EOrionVisionCheck
// NumValues: 0x0008
enum class EOrionVisionCheck : uint8
{
	None                                     = 0,
	Check_ShadowPlane                        = 1,
	Check_ZoneVision                         = 2,
	Check_Distance                           = 4,
	Check_LOS                                = 8,
	Check_FOV                                = 16,
	Check_MAX                                = 32,
	EOrionVisionCheck_MAX                    = 33,
};

// Enum OrionGame.EMyBPVisionBitIndices
// NumValues: 0x0007
enum class EMyBPVisionBitIndices : uint8
{
	Check_ShadowPlaneBitIndex                = 0,
	Check_ZoneVisionBitIndex                 = 1,
	Check_DistanceBitIndex                   = 2,
	Check_LOSBitIndex                        = 3,
	Check_FOVBitIndex                        = 4,
	Check_MAXBitIndex                        = 5,
	Check_MAX                                = 6,
};

// Enum OrionGame.EHeroToHeroVision
// NumValues: 0x0004
enum class EHeroToHeroVision : uint8
{
	EHasNoVision                             = 0,
	EHasOccludedVision                       = 1,
	EHasDirectVision                         = 2,
	EHeroToHeroVision_MAX                    = 3,
};

// Enum OrionGame.EStatusEffectIcon
// NumValues: 0x0013
enum class EStatusEffectIcon : uint8
{
	None                                     = 0,
	Slow                                     = 1,
	Root                                     = 2,
	Silence                                  = 3,
	Stun                                     = 4,
	ArmorShred                               = 5,
	Immunity_Damage                          = 6,
	Blind                                    = 7,
	HealthRegen                              = 8,
	AbilityArmorShred                        = 9,
	PositiveGeneric                          = 10,
	NegativeGeneric                          = 11,
	Blight                                   = 12,
	DOT                                      = 13,
	Unused1                                  = 14,
	Unused2                                  = 15,
	Unused3                                  = 16,
	Unused4                                  = 17,
	Max                                      = 18,
};

// Enum OrionGame.EOrionVisionIndividualRules
// NumValues: 0x0004
enum class EOrionVisionIndividualRules : uint8
{
	Default                                  = 0,
	VisibleToAll                             = 1,
	VisibleToNone                            = 2,
	EOrionVisionIndividualRules_MAX          = 3,
};

// Enum OrionGame.EOrionVisionManagerIndexMapping
// NumValues: 0x001B
enum class EOrionVisionManagerIndexMapping : uint8
{
	RedHeroes                                = 0,
	RedMinion                                = 1,
	RedWards                                 = 2,
	RedPlacedObject_WithHealth               = 3,
	RedPlacedObject_NoHealth                 = 4,
	RedInhibitor                             = 5,
	RedCore                                  = 6,
	RedTowers                                = 7,
	RedWells                                 = 8,
	RedPrimeHelixReturn                      = 9,
	BlueHeroes                               = 10,
	BlueMinion                               = 11,
	BlueWards                                = 12,
	BluePlacedObject_WithHealth              = 13,
	BluePlacedObject_NoHealth                = 14,
	BlueInhibitor                            = 15,
	BlueCore                                 = 16,
	BlueTowers                               = 17,
	BlueWells                                = 18,
	BluePrimeHelixReturn                     = 19,
	JungleMinions                            = 20,
	Wells                                    = 21,
	JungleCamps                              = 22,
	PrimeHelixSpawn                          = 23,
	PrimeHelixCarry                          = 24,
	Spectator                                = 25,
	MAX                                      = 26,
};

// Enum OrionGame.EOrionVisionManagerConcept
// NumValues: 0x0003
enum class EOrionVisionManagerConcept : uint8
{
	CanSee                                   = 0,
	In                                       = 1,
	EOrionVisionManagerConcept_MAX           = 2,
};

// Enum OrionGame.EOrionWellReplicatedTimers
// NumValues: 0x0004
enum class EOrionWellReplicatedTimers : uint8
{
	RT_Collection                            = 0,
	RT_RigPlacement                          = 1,
	RT_RigBuilding                           = 2,
	MAX                                      = 3,
};

// Enum OrionGame.EOrionWellState
// NumValues: 0x0006
enum class EOrionWellState : uint8
{
	InitalState                              = 0,
	DeadZone                                 = 1,
	Geyser                                   = 2,
	Active                                   = 3,
	RanDry                                   = 4,
	EOrionWellState_MAX                      = 5,
};

// Enum OrionGame.EQuickChatMessageSubject
// NumValues: 0x0006
enum class EQuickChatMessageSubject : uint8
{
	None                                     = 0,
	Role                                     = 1,
	Position                                 = 2,
	Hero                                     = 3,
	Player                                   = 4,
	EQuickChatMessageSubject_MAX             = 5,
};

// Enum OrionGame.EOrionQuickChatMessageSlot
// NumValues: 0x0005
enum class EOrionQuickChatMessageSlot : uint8
{
	Up                                       = 0,
	Left                                     = 1,
	Down                                     = 2,
	Right                                    = 3,
	MAX                                      = 4,
};

// Enum OrionGame.EOrionQuickChatTopic
// NumValues: 0x0013
enum class EOrionQuickChatTopic : uint8
{
	Invalid                                  = 0,
	Generic                                  = 1,
	Role                                     = 2,
	AnyRole                                  = 3,
	Position                                 = 4,
	AnyPosition                              = 5,
	Hero_NotSelected                         = 6,
	Hero_PlayerSelected                      = 7,
	Hero_TeammateSelected                    = 8,
	Hero_EnemySelected                       = 9,
	Player_LockedIn                          = 10,
	Player_Preselected                       = 11,
	Player_NoHero                            = 12,
	Teammate_LockedIn                        = 13,
	Teammate_Preselected                     = 14,
	Teammate_NoHero                          = 15,
	Enemy_LockedIn                           = 16,
	Enemy_NoHero                             = 17,
	MAX                                      = 18,
};

// Enum OrionGame.EAbilityDisplayValueModifierOperation
// NumValues: 0x0005
enum class EAbilityDisplayValueModifierOperation : uint32
{
	Add                                      = 0,
	Subtract                                 = 1,
	Multiply                                 = 2,
	Divide                                   = 3,
	EAbilityDisplayValueModifierOperation_MAX = 4,
};

// Enum OrionGame.EItemEffectApplicationTarget
// NumValues: 0x0004
enum class EItemEffectApplicationTarget : uint8
{
	Invalid                                  = 0,
	Player                                   = 1,
	Auxiliary                                = 2,
	EItemEffectApplicationTarget_MAX         = 3,
};

// Enum OrionGame.EItemEffectActivationMethod
// NumValues: 0x0004
enum class EItemEffectActivationMethod : uint8
{
	Equip                                    = 0,
	Input                                    = 1,
	Toggle                                   = 2,
	EItemEffectActivationMethod_MAX          = 3,
};

// ScriptStruct OrionGame.OrionDialogDescription
// 0x00B0 (0x00B0 - 0x0000)
struct alignas(0x10) FOrionDialogDescription final
{
public:
	class FText                                   MessageHeader;                                     // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   MessageBody;                                       // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ButtonOneText;                                     // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ButtonTwoText;                                     // 0x0048(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         DisplayTime;                                       // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanCancel;                                        // 0x0064(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x4B];                                      // 0x0065(0x004B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionDialogDescription) == 0x000010, "Wrong alignment on FOrionDialogDescription");
static_assert(sizeof(FOrionDialogDescription) == 0x0000B0, "Wrong size on FOrionDialogDescription");
static_assert(offsetof(FOrionDialogDescription, MessageHeader) == 0x000000, "Member 'FOrionDialogDescription::MessageHeader' has a wrong offset!");
static_assert(offsetof(FOrionDialogDescription, MessageBody) == 0x000018, "Member 'FOrionDialogDescription::MessageBody' has a wrong offset!");
static_assert(offsetof(FOrionDialogDescription, ButtonOneText) == 0x000030, "Member 'FOrionDialogDescription::ButtonOneText' has a wrong offset!");
static_assert(offsetof(FOrionDialogDescription, ButtonTwoText) == 0x000048, "Member 'FOrionDialogDescription::ButtonTwoText' has a wrong offset!");
static_assert(offsetof(FOrionDialogDescription, DisplayTime) == 0x000060, "Member 'FOrionDialogDescription::DisplayTime' has a wrong offset!");
static_assert(offsetof(FOrionDialogDescription, bCanCancel) == 0x000064, "Member 'FOrionDialogDescription::bCanCancel' has a wrong offset!");

// ScriptStruct OrionGame.TeamSetupData
// 0x0020 (0x0020 - 0x0000)
struct FTeamSetupData final
{
public:
	EOrionTeam                                    TeamIndex;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TeamName;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerTeam;                                       // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxPlayers;                                        // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AOrionTeamInfo>             DefaultTeamClass;                                  // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTeamSetupData) == 0x000008, "Wrong alignment on FTeamSetupData");
static_assert(sizeof(FTeamSetupData) == 0x000020, "Wrong size on FTeamSetupData");
static_assert(offsetof(FTeamSetupData, TeamIndex) == 0x000000, "Member 'FTeamSetupData::TeamIndex' has a wrong offset!");
static_assert(offsetof(FTeamSetupData, TeamName) == 0x000008, "Member 'FTeamSetupData::TeamName' has a wrong offset!");
static_assert(offsetof(FTeamSetupData, bPlayerTeam) == 0x000010, "Member 'FTeamSetupData::bPlayerTeam' has a wrong offset!");
static_assert(offsetof(FTeamSetupData, MaxPlayers) == 0x000014, "Member 'FTeamSetupData::MaxPlayers' has a wrong offset!");
static_assert(offsetof(FTeamSetupData, DefaultTeamClass) == 0x000018, "Member 'FTeamSetupData::DefaultTeamClass' has a wrong offset!");

// ScriptStruct OrionGame.OrionAnimNode_SimpleSlopeAndAim
// 0x0080 (0x00B0 - 0x0030)
struct FOrionAnimNode_SimpleSlopeAndAim final : public FAnimNode_Base
{
public:
	struct FPoseLink                              IncomingPose;                                      // 0x0030(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                WorldSpaceFloorNormal;                             // 0x0048(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoneReference                         UprightCompensationSpineBone;                      // 0x0058(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                CompSpaceAimDir;                                   // 0x0070(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EAxisOption                                   ForwardAimingAxis;                                 // 0x007C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7D[0x23];                                      // 0x007D(0x0023)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  RelativeMovementRot;                               // 0x00A0(0x0010)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOrionAnimNode_SimpleSlopeAndAim) == 0x000010, "Wrong alignment on FOrionAnimNode_SimpleSlopeAndAim");
static_assert(sizeof(FOrionAnimNode_SimpleSlopeAndAim) == 0x0000B0, "Wrong size on FOrionAnimNode_SimpleSlopeAndAim");
static_assert(offsetof(FOrionAnimNode_SimpleSlopeAndAim, IncomingPose) == 0x000030, "Member 'FOrionAnimNode_SimpleSlopeAndAim::IncomingPose' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SimpleSlopeAndAim, WorldSpaceFloorNormal) == 0x000048, "Member 'FOrionAnimNode_SimpleSlopeAndAim::WorldSpaceFloorNormal' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SimpleSlopeAndAim, UprightCompensationSpineBone) == 0x000058, "Member 'FOrionAnimNode_SimpleSlopeAndAim::UprightCompensationSpineBone' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SimpleSlopeAndAim, CompSpaceAimDir) == 0x000070, "Member 'FOrionAnimNode_SimpleSlopeAndAim::CompSpaceAimDir' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SimpleSlopeAndAim, ForwardAimingAxis) == 0x00007C, "Member 'FOrionAnimNode_SimpleSlopeAndAim::ForwardAimingAxis' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SimpleSlopeAndAim, RelativeMovementRot) == 0x0000A0, "Member 'FOrionAnimNode_SimpleSlopeAndAim::RelativeMovementRot' has a wrong offset!");

// ScriptStruct OrionGame.OrionLevelUpData
// 0x0098 (0x00A0 - 0x0008)
struct FOrionLevelUpData final : public FTableRowBase
{
public:
	int32                                         Index;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 HeroName;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XP;                                                // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UOrionMcpItemDefinition> SpecificItem;                                      // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LootTierGroup;                                     // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MasterQuantity;                                    // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UOrionMcpItemDefinition> MasterSpecificItem;                                // 0x0068(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MasterLootTierGroup;                               // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionLevelUpData) == 0x000008, "Wrong alignment on FOrionLevelUpData");
static_assert(sizeof(FOrionLevelUpData) == 0x0000A0, "Wrong size on FOrionLevelUpData");
static_assert(offsetof(FOrionLevelUpData, Index) == 0x000008, "Member 'FOrionLevelUpData::Index' has a wrong offset!");
static_assert(offsetof(FOrionLevelUpData, HeroName) == 0x000010, "Member 'FOrionLevelUpData::HeroName' has a wrong offset!");
static_assert(offsetof(FOrionLevelUpData, XP) == 0x000020, "Member 'FOrionLevelUpData::XP' has a wrong offset!");
static_assert(offsetof(FOrionLevelUpData, Quantity) == 0x000024, "Member 'FOrionLevelUpData::Quantity' has a wrong offset!");
static_assert(offsetof(FOrionLevelUpData, SpecificItem) == 0x000028, "Member 'FOrionLevelUpData::SpecificItem' has a wrong offset!");
static_assert(offsetof(FOrionLevelUpData, LootTierGroup) == 0x000050, "Member 'FOrionLevelUpData::LootTierGroup' has a wrong offset!");
static_assert(offsetof(FOrionLevelUpData, MasterQuantity) == 0x000060, "Member 'FOrionLevelUpData::MasterQuantity' has a wrong offset!");
static_assert(offsetof(FOrionLevelUpData, MasterSpecificItem) == 0x000068, "Member 'FOrionLevelUpData::MasterSpecificItem' has a wrong offset!");
static_assert(offsetof(FOrionLevelUpData, MasterLootTierGroup) == 0x000090, "Member 'FOrionLevelUpData::MasterLootTierGroup' has a wrong offset!");

// ScriptStruct OrionGame.OrionActorFilterTeam
// 0x0003 (0x0003 - 0x0000)
struct FOrionActorFilterTeam final
{
public:
	bool                                          bAlly;                                             // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnemy;                                            // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeutral;                                          // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionActorFilterTeam) == 0x000001, "Wrong alignment on FOrionActorFilterTeam");
static_assert(sizeof(FOrionActorFilterTeam) == 0x000003, "Wrong size on FOrionActorFilterTeam");
static_assert(offsetof(FOrionActorFilterTeam, bAlly) == 0x000000, "Member 'FOrionActorFilterTeam::bAlly' has a wrong offset!");
static_assert(offsetof(FOrionActorFilterTeam, bEnemy) == 0x000001, "Member 'FOrionActorFilterTeam::bEnemy' has a wrong offset!");
static_assert(offsetof(FOrionActorFilterTeam, bNeutral) == 0x000002, "Member 'FOrionActorFilterTeam::bNeutral' has a wrong offset!");

// ScriptStruct OrionGame.OrionActorFilterType
// 0x0005 (0x0005 - 0x0000)
struct FOrionActorFilterType final
{
public:
	bool                                          bHeroes;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreeps;                                           // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStructures;                                       // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWells;                                            // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDamageables;                                      // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionActorFilterType) == 0x000001, "Wrong alignment on FOrionActorFilterType");
static_assert(sizeof(FOrionActorFilterType) == 0x000005, "Wrong size on FOrionActorFilterType");
static_assert(offsetof(FOrionActorFilterType, bHeroes) == 0x000000, "Member 'FOrionActorFilterType::bHeroes' has a wrong offset!");
static_assert(offsetof(FOrionActorFilterType, bCreeps) == 0x000001, "Member 'FOrionActorFilterType::bCreeps' has a wrong offset!");
static_assert(offsetof(FOrionActorFilterType, bStructures) == 0x000002, "Member 'FOrionActorFilterType::bStructures' has a wrong offset!");
static_assert(offsetof(FOrionActorFilterType, bWells) == 0x000003, "Member 'FOrionActorFilterType::bWells' has a wrong offset!");
static_assert(offsetof(FOrionActorFilterType, bDamageables) == 0x000004, "Member 'FOrionActorFilterType::bDamageables' has a wrong offset!");

// ScriptStruct OrionGame.OrionActorFilterOcclusion
// 0x0010 (0x0010 - 0x0000)
struct FOrionActorFilterOcclusion final
{
public:
	bool                                          bRequiresLineOfSight;                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCollisionProfileName                  Profile;                                           // 0x0008(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionActorFilterOcclusion) == 0x000008, "Wrong alignment on FOrionActorFilterOcclusion");
static_assert(sizeof(FOrionActorFilterOcclusion) == 0x000010, "Wrong size on FOrionActorFilterOcclusion");
static_assert(offsetof(FOrionActorFilterOcclusion, bRequiresLineOfSight) == 0x000000, "Member 'FOrionActorFilterOcclusion::bRequiresLineOfSight' has a wrong offset!");
static_assert(offsetof(FOrionActorFilterOcclusion, Profile) == 0x000008, "Member 'FOrionActorFilterOcclusion::Profile' has a wrong offset!");

// ScriptStruct OrionGame.OrionActorFilter
// 0x0060 (0x0060 - 0x0000)
struct FOrionActorFilter final
{
public:
	bool                                          bAllowSelf;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckIsTargetable;                                // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckIsSelectable;                                // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckShadowPlane;                                 // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStealthedTargetsAreValid;                         // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFriendlyStealthedTargetsAreValid;                 // 0x0005(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionActorFilterTeam                  Team;                                              // 0x0006(0x0003)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FOrionActorFilterType                  Type;                                              // 0x0009(0x0005)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionActorFilterOcclusion             Occlusion;                                         // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               Tags;                                              // 0x0020(0x0040)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionActorFilter) == 0x000008, "Wrong alignment on FOrionActorFilter");
static_assert(sizeof(FOrionActorFilter) == 0x000060, "Wrong size on FOrionActorFilter");
static_assert(offsetof(FOrionActorFilter, bAllowSelf) == 0x000000, "Member 'FOrionActorFilter::bAllowSelf' has a wrong offset!");
static_assert(offsetof(FOrionActorFilter, bCheckIsTargetable) == 0x000001, "Member 'FOrionActorFilter::bCheckIsTargetable' has a wrong offset!");
static_assert(offsetof(FOrionActorFilter, bCheckIsSelectable) == 0x000002, "Member 'FOrionActorFilter::bCheckIsSelectable' has a wrong offset!");
static_assert(offsetof(FOrionActorFilter, bCheckShadowPlane) == 0x000003, "Member 'FOrionActorFilter::bCheckShadowPlane' has a wrong offset!");
static_assert(offsetof(FOrionActorFilter, bStealthedTargetsAreValid) == 0x000004, "Member 'FOrionActorFilter::bStealthedTargetsAreValid' has a wrong offset!");
static_assert(offsetof(FOrionActorFilter, bFriendlyStealthedTargetsAreValid) == 0x000005, "Member 'FOrionActorFilter::bFriendlyStealthedTargetsAreValid' has a wrong offset!");
static_assert(offsetof(FOrionActorFilter, Team) == 0x000006, "Member 'FOrionActorFilter::Team' has a wrong offset!");
static_assert(offsetof(FOrionActorFilter, Type) == 0x000009, "Member 'FOrionActorFilter::Type' has a wrong offset!");
static_assert(offsetof(FOrionActorFilter, Occlusion) == 0x000010, "Member 'FOrionActorFilter::Occlusion' has a wrong offset!");
static_assert(offsetof(FOrionActorFilter, Tags) == 0x000020, "Member 'FOrionActorFilter::Tags' has a wrong offset!");

// ScriptStruct OrionGame.OrionEffectStack
// 0x0010 (0x0010 - 0x0000)
struct FOrionEffectStack final
{
public:
	TSubclassOf<class UGameplayEffect>            GameplayEffect;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StackCount;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionEffectStack) == 0x000008, "Wrong alignment on FOrionEffectStack");
static_assert(sizeof(FOrionEffectStack) == 0x000010, "Wrong size on FOrionEffectStack");
static_assert(offsetof(FOrionEffectStack, GameplayEffect) == 0x000000, "Member 'FOrionEffectStack::GameplayEffect' has a wrong offset!");
static_assert(offsetof(FOrionEffectStack, StackCount) == 0x000008, "Member 'FOrionEffectStack::StackCount' has a wrong offset!");

// ScriptStruct OrionGame.OrionFilterEffectsMap
// 0x0090 (0x0090 - 0x0000)
struct FOrionFilterEffectsMap final
{
public:
	struct FOrionActorFilter                      Filter;                                            // 0x0000(0x0060)(Edit, Protected, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UGameplayEffect>>    GameplayEffectsToApply;                            // 0x0060(0x0010)(Edit, ZeroConstructor, RepSkip, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FOrionEffectStack>              StackedGameplayEffectsToApply;                     // 0x0070(0x0010)(Edit, ZeroConstructor, RepSkip, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayEffectSpecHandle>      GameplayEffectSpecsToApply;                        // 0x0080(0x0010)(ZeroConstructor, RepSkip, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FOrionFilterEffectsMap) == 0x000008, "Wrong alignment on FOrionFilterEffectsMap");
static_assert(sizeof(FOrionFilterEffectsMap) == 0x000090, "Wrong size on FOrionFilterEffectsMap");
static_assert(offsetof(FOrionFilterEffectsMap, Filter) == 0x000000, "Member 'FOrionFilterEffectsMap::Filter' has a wrong offset!");
static_assert(offsetof(FOrionFilterEffectsMap, GameplayEffectsToApply) == 0x000060, "Member 'FOrionFilterEffectsMap::GameplayEffectsToApply' has a wrong offset!");
static_assert(offsetof(FOrionFilterEffectsMap, StackedGameplayEffectsToApply) == 0x000070, "Member 'FOrionFilterEffectsMap::StackedGameplayEffectsToApply' has a wrong offset!");
static_assert(offsetof(FOrionFilterEffectsMap, GameplayEffectSpecsToApply) == 0x000080, "Member 'FOrionFilterEffectsMap::GameplayEffectSpecsToApply' has a wrong offset!");

// ScriptStruct OrionGame.EventEvaluatorTagApplied
// 0x0010 (0x0010 - 0x0000)
struct FEventEvaluatorTagApplied final
{
public:
	struct FGameplayTag                           GameplayTag_Added;                                 // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayTag_Removed;                               // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventEvaluatorTagApplied) == 0x000008, "Wrong alignment on FEventEvaluatorTagApplied");
static_assert(sizeof(FEventEvaluatorTagApplied) == 0x000010, "Wrong size on FEventEvaluatorTagApplied");
static_assert(offsetof(FEventEvaluatorTagApplied, GameplayTag_Added) == 0x000000, "Member 'FEventEvaluatorTagApplied::GameplayTag_Added' has a wrong offset!");
static_assert(offsetof(FEventEvaluatorTagApplied, GameplayTag_Removed) == 0x000008, "Member 'FEventEvaluatorTagApplied::GameplayTag_Removed' has a wrong offset!");

// ScriptStruct OrionGame.FriendCodeIssuedNotification
// 0x0020 (0x0020 - 0x0000)
struct FFriendCodeIssuedNotification final
{
public:
	class FString                                 Code;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CodeType;                                          // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFriendCodeIssuedNotification) == 0x000008, "Wrong alignment on FFriendCodeIssuedNotification");
static_assert(sizeof(FFriendCodeIssuedNotification) == 0x000020, "Wrong size on FFriendCodeIssuedNotification");
static_assert(offsetof(FFriendCodeIssuedNotification, Code) == 0x000000, "Member 'FFriendCodeIssuedNotification::Code' has a wrong offset!");
static_assert(offsetof(FFriendCodeIssuedNotification, CodeType) == 0x000010, "Member 'FFriendCodeIssuedNotification::CodeType' has a wrong offset!");

// ScriptStruct OrionGame.AxisBindingsRedirectStruct
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FAxisBindingsRedirectStruct final
{
public:
	class FName                                   MetaAxisName;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AxisName;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AxisScale;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAxisBindingsRedirectStruct) == 0x000008, "Wrong alignment on FAxisBindingsRedirectStruct");
static_assert(sizeof(FAxisBindingsRedirectStruct) == 0x000018, "Wrong size on FAxisBindingsRedirectStruct");
static_assert(offsetof(FAxisBindingsRedirectStruct, MetaAxisName) == 0x000000, "Member 'FAxisBindingsRedirectStruct::MetaAxisName' has a wrong offset!");
static_assert(offsetof(FAxisBindingsRedirectStruct, AxisName) == 0x000008, "Member 'FAxisBindingsRedirectStruct::AxisName' has a wrong offset!");
static_assert(offsetof(FAxisBindingsRedirectStruct, AxisScale) == 0x000010, "Member 'FAxisBindingsRedirectStruct::AxisScale' has a wrong offset!");

// ScriptStruct OrionGame.GameplayStatEventValueTag
// 0x0000 (0x0008 - 0x0008)
struct FGameplayStatEventValueTag final : public FGameplayTag
{
};
static_assert(alignof(FGameplayStatEventValueTag) == 0x000008, "Wrong alignment on FGameplayStatEventValueTag");
static_assert(sizeof(FGameplayStatEventValueTag) == 0x000008, "Wrong size on FGameplayStatEventValueTag");

// ScriptStruct OrionGame.OrionUIDamageEventInfo
// 0x0030 (0x0030 - 0x0000)
struct FOrionUIDamageEventInfo final
{
public:
	float                                         DamageAmount;                                      // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamagePCT;                                         // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InstigatorLocation;                                // 0x0008(0x000C)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Target;                                            // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0020(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionDamageNumberType                        DamageType;                                        // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionUIDamageEventInfo) == 0x000008, "Wrong alignment on FOrionUIDamageEventInfo");
static_assert(sizeof(FOrionUIDamageEventInfo) == 0x000030, "Wrong size on FOrionUIDamageEventInfo");
static_assert(offsetof(FOrionUIDamageEventInfo, DamageAmount) == 0x000000, "Member 'FOrionUIDamageEventInfo::DamageAmount' has a wrong offset!");
static_assert(offsetof(FOrionUIDamageEventInfo, DamagePCT) == 0x000004, "Member 'FOrionUIDamageEventInfo::DamagePCT' has a wrong offset!");
static_assert(offsetof(FOrionUIDamageEventInfo, InstigatorLocation) == 0x000008, "Member 'FOrionUIDamageEventInfo::InstigatorLocation' has a wrong offset!");
static_assert(offsetof(FOrionUIDamageEventInfo, Target) == 0x000018, "Member 'FOrionUIDamageEventInfo::Target' has a wrong offset!");
static_assert(offsetof(FOrionUIDamageEventInfo, Instigator) == 0x000020, "Member 'FOrionUIDamageEventInfo::Instigator' has a wrong offset!");
static_assert(offsetof(FOrionUIDamageEventInfo, DamageType) == 0x000028, "Member 'FOrionUIDamageEventInfo::DamageType' has a wrong offset!");

// ScriptStruct OrionGame.OrionQuickChatPayload
// 0x0018 (0x0018 - 0x0000)
struct FOrionQuickChatPayload final
{
public:
	EOrionQuickChatTopic                          Topic;                                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EOrionQuickChatMessageSlot                    MessageSlot;                                       // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RawSubjectString;                                  // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOrionQuickChatPayload) == 0x000008, "Wrong alignment on FOrionQuickChatPayload");
static_assert(sizeof(FOrionQuickChatPayload) == 0x000018, "Wrong size on FOrionQuickChatPayload");
static_assert(offsetof(FOrionQuickChatPayload, Topic) == 0x000000, "Member 'FOrionQuickChatPayload::Topic' has a wrong offset!");
static_assert(offsetof(FOrionQuickChatPayload, MessageSlot) == 0x000001, "Member 'FOrionQuickChatPayload::MessageSlot' has a wrong offset!");
static_assert(offsetof(FOrionQuickChatPayload, RawSubjectString) == 0x000008, "Member 'FOrionQuickChatPayload::RawSubjectString' has a wrong offset!");

// ScriptStruct OrionGame.HomingWithoutTargetData
// 0x0018 (0x0018 - 0x0000)
struct FHomingWithoutTargetData final
{
public:
	bool                                          bHomingTargetLocationInitialized;                  // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bDoHomingWhenNoTargetActor : 1;                    // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHomingTargetMovesWithProjectile : 1;              // 0x0004(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInitializeUsingTargetDataEndPoint : 1;            // 0x0004(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HomingDistanceWhenNoTargetActor;                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HomingTargetLocation;                              // 0x000C(0x000C)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHomingWithoutTargetData) == 0x000004, "Wrong alignment on FHomingWithoutTargetData");
static_assert(sizeof(FHomingWithoutTargetData) == 0x000018, "Wrong size on FHomingWithoutTargetData");
static_assert(offsetof(FHomingWithoutTargetData, bHomingTargetLocationInitialized) == 0x000000, "Member 'FHomingWithoutTargetData::bHomingTargetLocationInitialized' has a wrong offset!");
static_assert(offsetof(FHomingWithoutTargetData, HomingDistanceWhenNoTargetActor) == 0x000008, "Member 'FHomingWithoutTargetData::HomingDistanceWhenNoTargetActor' has a wrong offset!");
static_assert(offsetof(FHomingWithoutTargetData, HomingTargetLocation) == 0x00000C, "Member 'FHomingWithoutTargetData::HomingTargetLocation' has a wrong offset!");

// ScriptStruct OrionGame.OrionGameplayCueLevelRequirements
// 0x000C (0x000C - 0x0000)
struct FOrionGameplayCueLevelRequirements final
{
public:
	EGCLevelRequirement                           ReqType;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinLevel;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxLevel;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionGameplayCueLevelRequirements) == 0x000004, "Wrong alignment on FOrionGameplayCueLevelRequirements");
static_assert(sizeof(FOrionGameplayCueLevelRequirements) == 0x00000C, "Wrong size on FOrionGameplayCueLevelRequirements");
static_assert(offsetof(FOrionGameplayCueLevelRequirements, ReqType) == 0x000000, "Member 'FOrionGameplayCueLevelRequirements::ReqType' has a wrong offset!");
static_assert(offsetof(FOrionGameplayCueLevelRequirements, MinLevel) == 0x000004, "Member 'FOrionGameplayCueLevelRequirements::MinLevel' has a wrong offset!");
static_assert(offsetof(FOrionGameplayCueLevelRequirements, MaxLevel) == 0x000008, "Member 'FOrionGameplayCueLevelRequirements::MaxLevel' has a wrong offset!");

// ScriptStruct OrionGame.OrionGameplayCueConditionedNiagaraParticles
// 0x0028 (0x0028 - 0x0000)
struct FOrionGameplayCueConditionedNiagaraParticles final
{
public:
	EParticleCondition                            Condition;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOrionGameplayCueLevelRequirements> LevelRequirements;                                 // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         ParticleSystem;                                    // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketNameOverride;                                // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionGameplayCueConditionedNiagaraParticles) == 0x000008, "Wrong alignment on FOrionGameplayCueConditionedNiagaraParticles");
static_assert(sizeof(FOrionGameplayCueConditionedNiagaraParticles) == 0x000028, "Wrong size on FOrionGameplayCueConditionedNiagaraParticles");
static_assert(offsetof(FOrionGameplayCueConditionedNiagaraParticles, Condition) == 0x000000, "Member 'FOrionGameplayCueConditionedNiagaraParticles::Condition' has a wrong offset!");
static_assert(offsetof(FOrionGameplayCueConditionedNiagaraParticles, LevelRequirements) == 0x000008, "Member 'FOrionGameplayCueConditionedNiagaraParticles::LevelRequirements' has a wrong offset!");
static_assert(offsetof(FOrionGameplayCueConditionedNiagaraParticles, ParticleSystem) == 0x000018, "Member 'FOrionGameplayCueConditionedNiagaraParticles::ParticleSystem' has a wrong offset!");
static_assert(offsetof(FOrionGameplayCueConditionedNiagaraParticles, SocketNameOverride) == 0x000020, "Member 'FOrionGameplayCueConditionedNiagaraParticles::SocketNameOverride' has a wrong offset!");

// ScriptStruct OrionGame.AIBotPerfConfig
// 0x0040 (0x0040 - 0x0000)
struct FAIBotPerfConfig final
{
public:
	float                                         CombatAbilitiesUpdateInterval;                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AbilityTasksUpdateInterval;                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentLaneInfoUpdateInterval;                     // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyTowerDangerInterval;                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaneLocationUpdateInterval;                        // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BuffingUpdateInterval;                             // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FriendSupportingUpdateInterval;                    // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocusUpdateInterval;                               // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TacticalAssessmentUpdateInterval;                  // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunAwayUpdateInterval;                             // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyDistanceUpdateInterval;                       // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MobilityAbilityUpdateInterval;                     // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemySelectionUpdateInterval;                      // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveUrgencyUpdateInterval;                         // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FriendProximityUpdateInterval;                     // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PipsUpdateInterval;                                // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIBotPerfConfig) == 0x000004, "Wrong alignment on FAIBotPerfConfig");
static_assert(sizeof(FAIBotPerfConfig) == 0x000040, "Wrong size on FAIBotPerfConfig");
static_assert(offsetof(FAIBotPerfConfig, CombatAbilitiesUpdateInterval) == 0x000000, "Member 'FAIBotPerfConfig::CombatAbilitiesUpdateInterval' has a wrong offset!");
static_assert(offsetof(FAIBotPerfConfig, AbilityTasksUpdateInterval) == 0x000004, "Member 'FAIBotPerfConfig::AbilityTasksUpdateInterval' has a wrong offset!");
static_assert(offsetof(FAIBotPerfConfig, CurrentLaneInfoUpdateInterval) == 0x000008, "Member 'FAIBotPerfConfig::CurrentLaneInfoUpdateInterval' has a wrong offset!");
static_assert(offsetof(FAIBotPerfConfig, EnemyTowerDangerInterval) == 0x00000C, "Member 'FAIBotPerfConfig::EnemyTowerDangerInterval' has a wrong offset!");
static_assert(offsetof(FAIBotPerfConfig, LaneLocationUpdateInterval) == 0x000010, "Member 'FAIBotPerfConfig::LaneLocationUpdateInterval' has a wrong offset!");
static_assert(offsetof(FAIBotPerfConfig, BuffingUpdateInterval) == 0x000014, "Member 'FAIBotPerfConfig::BuffingUpdateInterval' has a wrong offset!");
static_assert(offsetof(FAIBotPerfConfig, FriendSupportingUpdateInterval) == 0x000018, "Member 'FAIBotPerfConfig::FriendSupportingUpdateInterval' has a wrong offset!");
static_assert(offsetof(FAIBotPerfConfig, FocusUpdateInterval) == 0x00001C, "Member 'FAIBotPerfConfig::FocusUpdateInterval' has a wrong offset!");
static_assert(offsetof(FAIBotPerfConfig, TacticalAssessmentUpdateInterval) == 0x000020, "Member 'FAIBotPerfConfig::TacticalAssessmentUpdateInterval' has a wrong offset!");
static_assert(offsetof(FAIBotPerfConfig, RunAwayUpdateInterval) == 0x000024, "Member 'FAIBotPerfConfig::RunAwayUpdateInterval' has a wrong offset!");
static_assert(offsetof(FAIBotPerfConfig, EnemyDistanceUpdateInterval) == 0x000028, "Member 'FAIBotPerfConfig::EnemyDistanceUpdateInterval' has a wrong offset!");
static_assert(offsetof(FAIBotPerfConfig, MobilityAbilityUpdateInterval) == 0x00002C, "Member 'FAIBotPerfConfig::MobilityAbilityUpdateInterval' has a wrong offset!");
static_assert(offsetof(FAIBotPerfConfig, EnemySelectionUpdateInterval) == 0x000030, "Member 'FAIBotPerfConfig::EnemySelectionUpdateInterval' has a wrong offset!");
static_assert(offsetof(FAIBotPerfConfig, MoveUrgencyUpdateInterval) == 0x000034, "Member 'FAIBotPerfConfig::MoveUrgencyUpdateInterval' has a wrong offset!");
static_assert(offsetof(FAIBotPerfConfig, FriendProximityUpdateInterval) == 0x000038, "Member 'FAIBotPerfConfig::FriendProximityUpdateInterval' has a wrong offset!");
static_assert(offsetof(FAIBotPerfConfig, PipsUpdateInterval) == 0x00003C, "Member 'FAIBotPerfConfig::PipsUpdateInterval' has a wrong offset!");

// ScriptStruct OrionGame.WorldMusicCue
// 0x0060 (0x0060 - 0x0000)
struct FWorldMusicCue final
{
public:
	class FString                                 MusicId;                                           // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundCue>               WorldMusicCue;                                     // 0x0010(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundCue>               WorldMusicContinuousCue;                           // 0x0038(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWorldMusicCue) == 0x000008, "Wrong alignment on FWorldMusicCue");
static_assert(sizeof(FWorldMusicCue) == 0x000060, "Wrong size on FWorldMusicCue");
static_assert(offsetof(FWorldMusicCue, MusicId) == 0x000000, "Member 'FWorldMusicCue::MusicId' has a wrong offset!");
static_assert(offsetof(FWorldMusicCue, WorldMusicCue) == 0x000010, "Member 'FWorldMusicCue::WorldMusicCue' has a wrong offset!");
static_assert(offsetof(FWorldMusicCue, WorldMusicContinuousCue) == 0x000038, "Member 'FWorldMusicCue::WorldMusicContinuousCue' has a wrong offset!");

// ScriptStruct OrionGame.UniqueAIBotID
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FUniqueAIBotID final
{
public:
	class FName                                   UniqueId;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUniqueAIBotID) == 0x000008, "Wrong alignment on FUniqueAIBotID");
static_assert(sizeof(FUniqueAIBotID) == 0x000008, "Wrong size on FUniqueAIBotID");
static_assert(offsetof(FUniqueAIBotID, UniqueId) == 0x000000, "Member 'FUniqueAIBotID::UniqueId' has a wrong offset!");

// ScriptStruct OrionGame.OrionPlayerStateUIID
// 0x0028 (0x0028 - 0x0000)
struct FOrionPlayerStateUIID final
{
public:
	struct FUniqueNetIdRepl                       UniqueId;                                          // 0x0000(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUniqueAIBotID                         BotID;                                             // 0x0018(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionPlayerStateUIID) == 0x000008, "Wrong alignment on FOrionPlayerStateUIID");
static_assert(sizeof(FOrionPlayerStateUIID) == 0x000028, "Wrong size on FOrionPlayerStateUIID");
static_assert(offsetof(FOrionPlayerStateUIID, UniqueId) == 0x000000, "Member 'FOrionPlayerStateUIID::UniqueId' has a wrong offset!");
static_assert(offsetof(FOrionPlayerStateUIID, BotID) == 0x000018, "Member 'FOrionPlayerStateUIID::BotID' has a wrong offset!");

// ScriptStruct OrionGame.ObjectiveBackdoorProtection
// 0x0010 (0x0010 - 0x0000)
struct FObjectiveBackdoorProtection final
{
public:
	TSubclassOf<class UGameplayEffect>            BackdoorProtectionEffect;                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            BackdoorProtectionHandle;                          // 0x0008(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObjectiveBackdoorProtection) == 0x000008, "Wrong alignment on FObjectiveBackdoorProtection");
static_assert(sizeof(FObjectiveBackdoorProtection) == 0x000010, "Wrong size on FObjectiveBackdoorProtection");
static_assert(offsetof(FObjectiveBackdoorProtection, BackdoorProtectionEffect) == 0x000000, "Member 'FObjectiveBackdoorProtection::BackdoorProtectionEffect' has a wrong offset!");
static_assert(offsetof(FObjectiveBackdoorProtection, BackdoorProtectionHandle) == 0x000008, "Member 'FObjectiveBackdoorProtection::BackdoorProtectionHandle' has a wrong offset!");

// ScriptStruct OrionGame.UIUpdateHelperStruct
// 0x0001 (0x0001 - 0x0000)
struct FUIUpdateHelperStruct
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIUpdateHelperStruct) == 0x000001, "Wrong alignment on FUIUpdateHelperStruct");
static_assert(sizeof(FUIUpdateHelperStruct) == 0x000001, "Wrong size on FUIUpdateHelperStruct");

// ScriptStruct OrionGame.OrionArcadePlayerScoreInfo
// 0x0097 (0x0098 - 0x0001)
struct FOrionArcadePlayerScoreInfo final : public FUIUpdateHelperStruct
{
public:
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionPlayerStateUIID                  PlayerStateUIID;                                   // 0x0008(0x0028)(Edit, BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	class FString                                 PlayerName;                                        // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HeroId;                                            // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HeroName;                                          // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    TeamNum;                                           // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    LocalPlayerTeamNum;                                // 0x0061(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x6];                                       // 0x0062(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             HeroIcon;                                          // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentLevel;                                      // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCurrentlyDead;                                  // 0x0074(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RespawnTime;                                       // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLocalPlayer;                                    // 0x007C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x1B];                                      // 0x007D(0x001B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionArcadePlayerScoreInfo) == 0x000008, "Wrong alignment on FOrionArcadePlayerScoreInfo");
static_assert(sizeof(FOrionArcadePlayerScoreInfo) == 0x000098, "Wrong size on FOrionArcadePlayerScoreInfo");
static_assert(offsetof(FOrionArcadePlayerScoreInfo, PlayerStateUIID) == 0x000008, "Member 'FOrionArcadePlayerScoreInfo::PlayerStateUIID' has a wrong offset!");
static_assert(offsetof(FOrionArcadePlayerScoreInfo, PlayerName) == 0x000030, "Member 'FOrionArcadePlayerScoreInfo::PlayerName' has a wrong offset!");
static_assert(offsetof(FOrionArcadePlayerScoreInfo, HeroId) == 0x000040, "Member 'FOrionArcadePlayerScoreInfo::HeroId' has a wrong offset!");
static_assert(offsetof(FOrionArcadePlayerScoreInfo, HeroName) == 0x000050, "Member 'FOrionArcadePlayerScoreInfo::HeroName' has a wrong offset!");
static_assert(offsetof(FOrionArcadePlayerScoreInfo, TeamNum) == 0x000060, "Member 'FOrionArcadePlayerScoreInfo::TeamNum' has a wrong offset!");
static_assert(offsetof(FOrionArcadePlayerScoreInfo, LocalPlayerTeamNum) == 0x000061, "Member 'FOrionArcadePlayerScoreInfo::LocalPlayerTeamNum' has a wrong offset!");
static_assert(offsetof(FOrionArcadePlayerScoreInfo, HeroIcon) == 0x000068, "Member 'FOrionArcadePlayerScoreInfo::HeroIcon' has a wrong offset!");
static_assert(offsetof(FOrionArcadePlayerScoreInfo, CurrentLevel) == 0x000070, "Member 'FOrionArcadePlayerScoreInfo::CurrentLevel' has a wrong offset!");
static_assert(offsetof(FOrionArcadePlayerScoreInfo, bIsCurrentlyDead) == 0x000074, "Member 'FOrionArcadePlayerScoreInfo::bIsCurrentlyDead' has a wrong offset!");
static_assert(offsetof(FOrionArcadePlayerScoreInfo, RespawnTime) == 0x000078, "Member 'FOrionArcadePlayerScoreInfo::RespawnTime' has a wrong offset!");
static_assert(offsetof(FOrionArcadePlayerScoreInfo, bIsLocalPlayer) == 0x00007C, "Member 'FOrionArcadePlayerScoreInfo::bIsLocalPlayer' has a wrong offset!");

// ScriptStruct OrionGame.OrionArcadeTeamScoreInfo
// 0x001F (0x0020 - 0x0001)
struct FOrionArcadeTeamScoreInfo final : public FUIUpdateHelperStruct
{
public:
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOrionArcadePlayerScoreInfo>    Players;                                           // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	EOrionTeam                                    TeamNum;                                           // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionArcadeTeamScoreInfo) == 0x000008, "Wrong alignment on FOrionArcadeTeamScoreInfo");
static_assert(sizeof(FOrionArcadeTeamScoreInfo) == 0x000020, "Wrong size on FOrionArcadeTeamScoreInfo");
static_assert(offsetof(FOrionArcadeTeamScoreInfo, Players) == 0x000008, "Member 'FOrionArcadeTeamScoreInfo::Players' has a wrong offset!");
static_assert(offsetof(FOrionArcadeTeamScoreInfo, TeamNum) == 0x000018, "Member 'FOrionArcadeTeamScoreInfo::TeamNum' has a wrong offset!");

// ScriptStruct OrionGame.OrionArcadeScoreInfo
// 0x0048 (0x0048 - 0x0000)
struct FOrionArcadeScoreInfo final
{
public:
	struct FOrionArcadeTeamScoreInfo              RedTeam;                                           // 0x0000(0x0020)(NativeAccessSpecifierPublic)
	struct FOrionArcadeTeamScoreInfo              BlueTeam;                                          // 0x0020(0x0020)(NativeAccessSpecifierPublic)
	int32                                         VictoryPointMargin;                                // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionArcadeScoreInfo) == 0x000008, "Wrong alignment on FOrionArcadeScoreInfo");
static_assert(sizeof(FOrionArcadeScoreInfo) == 0x000048, "Wrong size on FOrionArcadeScoreInfo");
static_assert(offsetof(FOrionArcadeScoreInfo, RedTeam) == 0x000000, "Member 'FOrionArcadeScoreInfo::RedTeam' has a wrong offset!");
static_assert(offsetof(FOrionArcadeScoreInfo, BlueTeam) == 0x000020, "Member 'FOrionArcadeScoreInfo::BlueTeam' has a wrong offset!");
static_assert(offsetof(FOrionArcadeScoreInfo, VictoryPointMargin) == 0x000040, "Member 'FOrionArcadeScoreInfo::VictoryPointMargin' has a wrong offset!");

// ScriptStruct OrionGame.BannerSocketEntry
// 0x0038 (0x0038 - 0x0000)
struct FBannerSocketEntry final
{
public:
	class FName                                   SocketIdent;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionBannerType                              SocketType;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UOrionMcpBannerItemDefinition> DefaultSocketTemplate;                             // 0x0010(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBannerSocketEntry) == 0x000008, "Wrong alignment on FBannerSocketEntry");
static_assert(sizeof(FBannerSocketEntry) == 0x000038, "Wrong size on FBannerSocketEntry");
static_assert(offsetof(FBannerSocketEntry, SocketIdent) == 0x000000, "Member 'FBannerSocketEntry::SocketIdent' has a wrong offset!");
static_assert(offsetof(FBannerSocketEntry, SocketType) == 0x000008, "Member 'FBannerSocketEntry::SocketType' has a wrong offset!");
static_assert(offsetof(FBannerSocketEntry, DefaultSocketTemplate) == 0x000010, "Member 'FBannerSocketEntry::DefaultSocketTemplate' has a wrong offset!");

// ScriptStruct OrionGame.SingleBannerEntry
// 0x0058 (0x0058 - 0x0000)
struct FSingleBannerEntry final
{
public:
	class FString                                 EntryID;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBannerSocketEntry                     SocketEntry;                                       // 0x0010(0x0038)(NativeAccessSpecifierPublic)
	TArray<class FString>                         Alterations;                                       // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSingleBannerEntry) == 0x000008, "Wrong alignment on FSingleBannerEntry");
static_assert(sizeof(FSingleBannerEntry) == 0x000058, "Wrong size on FSingleBannerEntry");
static_assert(offsetof(FSingleBannerEntry, EntryID) == 0x000000, "Member 'FSingleBannerEntry::EntryID' has a wrong offset!");
static_assert(offsetof(FSingleBannerEntry, SocketEntry) == 0x000010, "Member 'FSingleBannerEntry::SocketEntry' has a wrong offset!");
static_assert(offsetof(FSingleBannerEntry, Alterations) == 0x000048, "Member 'FSingleBannerEntry::Alterations' has a wrong offset!");

// ScriptStruct OrionGame.BannerSpec
// 0x0068 (0x0068 - 0x0000)
struct FBannerSpec final
{
public:
	struct FSingleBannerEntry                     RootSocket;                                        // 0x0000(0x0058)(BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FSingleBannerEntry>             Sockets;                                           // 0x0058(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBannerSpec) == 0x000008, "Wrong alignment on FBannerSpec");
static_assert(sizeof(FBannerSpec) == 0x000068, "Wrong size on FBannerSpec");
static_assert(offsetof(FBannerSpec, RootSocket) == 0x000000, "Member 'FBannerSpec::RootSocket' has a wrong offset!");
static_assert(offsetof(FBannerSpec, Sockets) == 0x000058, "Member 'FBannerSpec::Sockets' has a wrong offset!");

// ScriptStruct OrionGame.OrionCosmeticPlayerChoices
// 0x00E0 (0x00E0 - 0x0000)
struct FOrionCosmeticPlayerChoices final
{
public:
	class FString                                 SkinName;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UOrionMcpItemDefinition*>        BannerItems;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBannerSpec                            BannerSpec;                                        // 0x0020(0x0068)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 SkinVariationName;                                 // 0x0088(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Emote0Name;                                        // 0x0098(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Emote1Name;                                        // 0x00A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Emote2Name;                                        // 0x00B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Emote3Name;                                        // 0x00C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowCrown;                                        // 0x00D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOwned;                                            // 0x00D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DA[0x2];                                       // 0x00DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HeroRank;                                          // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionCosmeticPlayerChoices) == 0x000008, "Wrong alignment on FOrionCosmeticPlayerChoices");
static_assert(sizeof(FOrionCosmeticPlayerChoices) == 0x0000E0, "Wrong size on FOrionCosmeticPlayerChoices");
static_assert(offsetof(FOrionCosmeticPlayerChoices, SkinName) == 0x000000, "Member 'FOrionCosmeticPlayerChoices::SkinName' has a wrong offset!");
static_assert(offsetof(FOrionCosmeticPlayerChoices, BannerItems) == 0x000010, "Member 'FOrionCosmeticPlayerChoices::BannerItems' has a wrong offset!");
static_assert(offsetof(FOrionCosmeticPlayerChoices, BannerSpec) == 0x000020, "Member 'FOrionCosmeticPlayerChoices::BannerSpec' has a wrong offset!");
static_assert(offsetof(FOrionCosmeticPlayerChoices, SkinVariationName) == 0x000088, "Member 'FOrionCosmeticPlayerChoices::SkinVariationName' has a wrong offset!");
static_assert(offsetof(FOrionCosmeticPlayerChoices, Emote0Name) == 0x000098, "Member 'FOrionCosmeticPlayerChoices::Emote0Name' has a wrong offset!");
static_assert(offsetof(FOrionCosmeticPlayerChoices, Emote1Name) == 0x0000A8, "Member 'FOrionCosmeticPlayerChoices::Emote1Name' has a wrong offset!");
static_assert(offsetof(FOrionCosmeticPlayerChoices, Emote2Name) == 0x0000B8, "Member 'FOrionCosmeticPlayerChoices::Emote2Name' has a wrong offset!");
static_assert(offsetof(FOrionCosmeticPlayerChoices, Emote3Name) == 0x0000C8, "Member 'FOrionCosmeticPlayerChoices::Emote3Name' has a wrong offset!");
static_assert(offsetof(FOrionCosmeticPlayerChoices, bShowCrown) == 0x0000D8, "Member 'FOrionCosmeticPlayerChoices::bShowCrown' has a wrong offset!");
static_assert(offsetof(FOrionCosmeticPlayerChoices, bOwned) == 0x0000D9, "Member 'FOrionCosmeticPlayerChoices::bOwned' has a wrong offset!");
static_assert(offsetof(FOrionCosmeticPlayerChoices, HeroRank) == 0x0000DC, "Member 'FOrionCosmeticPlayerChoices::HeroRank' has a wrong offset!");

// ScriptStruct OrionGame.OrionFilterAndEffectsContainer
// 0x0020 (0x0020 - 0x0000)
struct FOrionFilterAndEffectsContainer final
{
public:
	TArray<struct FOrionFilterEffectsMap>         FiltersToUse;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  CachedSourceActor;                                 // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrionTeam                                    CachedSourceTeamNum;                               // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bGeneratedEffectSpecs;                             // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionFilterAndEffectsContainer) == 0x000008, "Wrong alignment on FOrionFilterAndEffectsContainer");
static_assert(sizeof(FOrionFilterAndEffectsContainer) == 0x000020, "Wrong size on FOrionFilterAndEffectsContainer");
static_assert(offsetof(FOrionFilterAndEffectsContainer, FiltersToUse) == 0x000000, "Member 'FOrionFilterAndEffectsContainer::FiltersToUse' has a wrong offset!");
static_assert(offsetof(FOrionFilterAndEffectsContainer, CachedSourceActor) == 0x000010, "Member 'FOrionFilterAndEffectsContainer::CachedSourceActor' has a wrong offset!");
static_assert(offsetof(FOrionFilterAndEffectsContainer, CachedSourceTeamNum) == 0x000018, "Member 'FOrionFilterAndEffectsContainer::CachedSourceTeamNum' has a wrong offset!");
static_assert(offsetof(FOrionFilterAndEffectsContainer, bGeneratedEffectSpecs) == 0x000019, "Member 'FOrionFilterAndEffectsContainer::bGeneratedEffectSpecs' has a wrong offset!");

// ScriptStruct OrionGame.PassiveHUDInfo
// 0x0180 (0x0180 - 0x0000)
struct FPassiveHUDInfo final
{
public:
	EPassiveHUDType                               Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHUDDisplayType                               DurationStyle;                                     // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0xE];                                        // 0x0002(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayEffectQuery                   Query;                                             // 0x0010(0x0170)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPassiveHUDInfo) == 0x000010, "Wrong alignment on FPassiveHUDInfo");
static_assert(sizeof(FPassiveHUDInfo) == 0x000180, "Wrong size on FPassiveHUDInfo");
static_assert(offsetof(FPassiveHUDInfo, Type) == 0x000000, "Member 'FPassiveHUDInfo::Type' has a wrong offset!");
static_assert(offsetof(FPassiveHUDInfo, DurationStyle) == 0x000001, "Member 'FPassiveHUDInfo::DurationStyle' has a wrong offset!");
static_assert(offsetof(FPassiveHUDInfo, Query) == 0x000010, "Member 'FPassiveHUDInfo::Query' has a wrong offset!");

// ScriptStruct OrionGame.AIRefineryManager
// 0x0010 (0x0010 - 0x0000)
struct FAIRefineryManager final
{
public:
	class AOrionJungleRefinery*                   Refineries[0x2];                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FAIRefineryManager) == 0x000008, "Wrong alignment on FAIRefineryManager");
static_assert(sizeof(FAIRefineryManager) == 0x000010, "Wrong size on FAIRefineryManager");
static_assert(offsetof(FAIRefineryManager, Refineries) == 0x000000, "Member 'FAIRefineryManager::Refineries' has a wrong offset!");

// ScriptStruct OrionGame.UserCreatedDeck
// 0x0048 (0x0048 - 0x0000)
struct FUserCreatedDeck final
{
public:
	class FText                                   DeckName;                                          // 0x0000(0x0018)(NativeAccessSpecifierPublic)
	TArray<class FString>                         Affinities;                                        // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FString>                         GemInstanceIds;                                    // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FString>                         CardInstanceIds;                                   // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FUserCreatedDeck) == 0x000008, "Wrong alignment on FUserCreatedDeck");
static_assert(sizeof(FUserCreatedDeck) == 0x000048, "Wrong size on FUserCreatedDeck");
static_assert(offsetof(FUserCreatedDeck, DeckName) == 0x000000, "Member 'FUserCreatedDeck::DeckName' has a wrong offset!");
static_assert(offsetof(FUserCreatedDeck, Affinities) == 0x000018, "Member 'FUserCreatedDeck::Affinities' has a wrong offset!");
static_assert(offsetof(FUserCreatedDeck, GemInstanceIds) == 0x000028, "Member 'FUserCreatedDeck::GemInstanceIds' has a wrong offset!");
static_assert(offsetof(FUserCreatedDeck, CardInstanceIds) == 0x000038, "Member 'FUserCreatedDeck::CardInstanceIds' has a wrong offset!");

// ScriptStruct OrionGame.OrionPlayerEndMatchData
// 0x00B0 (0x00B0 - 0x0000)
struct FOrionPlayerEndMatchData final
{
public:
	class FString                                 MatchSessionId;                                    // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlaylistId;                                        // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGameConcludedViaSurrender;                        // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCustomGame;                                     // 0x0015(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         GameTags;                                          // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 HeroSkin;                                          // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         TeamSkins;                                         // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         OpponentSkins;                                     // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 DeckId;                                            // 0x0058(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUserCreatedDeck                       DeckContents;                                      // 0x0068(0x0048)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionPlayerEndMatchData) == 0x000008, "Wrong alignment on FOrionPlayerEndMatchData");
static_assert(sizeof(FOrionPlayerEndMatchData) == 0x0000B0, "Wrong size on FOrionPlayerEndMatchData");
static_assert(offsetof(FOrionPlayerEndMatchData, MatchSessionId) == 0x000000, "Member 'FOrionPlayerEndMatchData::MatchSessionId' has a wrong offset!");
static_assert(offsetof(FOrionPlayerEndMatchData, PlaylistId) == 0x000010, "Member 'FOrionPlayerEndMatchData::PlaylistId' has a wrong offset!");
static_assert(offsetof(FOrionPlayerEndMatchData, bGameConcludedViaSurrender) == 0x000014, "Member 'FOrionPlayerEndMatchData::bGameConcludedViaSurrender' has a wrong offset!");
static_assert(offsetof(FOrionPlayerEndMatchData, bIsCustomGame) == 0x000015, "Member 'FOrionPlayerEndMatchData::bIsCustomGame' has a wrong offset!");
static_assert(offsetof(FOrionPlayerEndMatchData, GameTags) == 0x000018, "Member 'FOrionPlayerEndMatchData::GameTags' has a wrong offset!");
static_assert(offsetof(FOrionPlayerEndMatchData, HeroSkin) == 0x000028, "Member 'FOrionPlayerEndMatchData::HeroSkin' has a wrong offset!");
static_assert(offsetof(FOrionPlayerEndMatchData, TeamSkins) == 0x000038, "Member 'FOrionPlayerEndMatchData::TeamSkins' has a wrong offset!");
static_assert(offsetof(FOrionPlayerEndMatchData, OpponentSkins) == 0x000048, "Member 'FOrionPlayerEndMatchData::OpponentSkins' has a wrong offset!");
static_assert(offsetof(FOrionPlayerEndMatchData, DeckId) == 0x000058, "Member 'FOrionPlayerEndMatchData::DeckId' has a wrong offset!");
static_assert(offsetof(FOrionPlayerEndMatchData, DeckContents) == 0x000068, "Member 'FOrionPlayerEndMatchData::DeckContents' has a wrong offset!");

// ScriptStruct OrionGame.OrionAILane
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FOrionAILane final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionAILane) == 0x000008, "Wrong alignment on FOrionAILane");
static_assert(sizeof(FOrionAILane) == 0x000030, "Wrong size on FOrionAILane");

// ScriptStruct OrionGame.OrionAimAssistSettings
// 0x0048 (0x0048 - 0x0000)
struct FOrionAimAssistSettings final
{
public:
	class UCurveFloat*                            TargetWeightCurve;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeroTargetWeightScale;                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinionTargetWeightScale;                           // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinionTargetStrengthScale;                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            PullStrengthYawCurve;                              // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            PullStrengthPitchCurve;                            // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PullMaxRate;                                       // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            SlowStrengthYawCurve;                              // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SlowStrengthPitchCurve;                            // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlowDecayTime;                                     // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionAimAssistSettings) == 0x000008, "Wrong alignment on FOrionAimAssistSettings");
static_assert(sizeof(FOrionAimAssistSettings) == 0x000048, "Wrong size on FOrionAimAssistSettings");
static_assert(offsetof(FOrionAimAssistSettings, TargetWeightCurve) == 0x000000, "Member 'FOrionAimAssistSettings::TargetWeightCurve' has a wrong offset!");
static_assert(offsetof(FOrionAimAssistSettings, HeroTargetWeightScale) == 0x000008, "Member 'FOrionAimAssistSettings::HeroTargetWeightScale' has a wrong offset!");
static_assert(offsetof(FOrionAimAssistSettings, MinionTargetWeightScale) == 0x00000C, "Member 'FOrionAimAssistSettings::MinionTargetWeightScale' has a wrong offset!");
static_assert(offsetof(FOrionAimAssistSettings, MinionTargetStrengthScale) == 0x000010, "Member 'FOrionAimAssistSettings::MinionTargetStrengthScale' has a wrong offset!");
static_assert(offsetof(FOrionAimAssistSettings, PullStrengthYawCurve) == 0x000018, "Member 'FOrionAimAssistSettings::PullStrengthYawCurve' has a wrong offset!");
static_assert(offsetof(FOrionAimAssistSettings, PullStrengthPitchCurve) == 0x000020, "Member 'FOrionAimAssistSettings::PullStrengthPitchCurve' has a wrong offset!");
static_assert(offsetof(FOrionAimAssistSettings, PullMaxRate) == 0x000028, "Member 'FOrionAimAssistSettings::PullMaxRate' has a wrong offset!");
static_assert(offsetof(FOrionAimAssistSettings, SlowStrengthYawCurve) == 0x000030, "Member 'FOrionAimAssistSettings::SlowStrengthYawCurve' has a wrong offset!");
static_assert(offsetof(FOrionAimAssistSettings, SlowStrengthPitchCurve) == 0x000038, "Member 'FOrionAimAssistSettings::SlowStrengthPitchCurve' has a wrong offset!");
static_assert(offsetof(FOrionAimAssistSettings, SlowDecayTime) == 0x000040, "Member 'FOrionAimAssistSettings::SlowDecayTime' has a wrong offset!");

// ScriptStruct OrionGame.OrionLevelInfo
// 0x0010 (0x0010 - 0x0000)
struct FOrionLevelInfo final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentXP;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XPNeeded;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionLevelTypes                              LevelType;                                         // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionLevelInfo) == 0x000004, "Wrong alignment on FOrionLevelInfo");
static_assert(sizeof(FOrionLevelInfo) == 0x000010, "Wrong size on FOrionLevelInfo");
static_assert(offsetof(FOrionLevelInfo, Level) == 0x000000, "Member 'FOrionLevelInfo::Level' has a wrong offset!");
static_assert(offsetof(FOrionLevelInfo, CurrentXP) == 0x000004, "Member 'FOrionLevelInfo::CurrentXP' has a wrong offset!");
static_assert(offsetof(FOrionLevelInfo, XPNeeded) == 0x000008, "Member 'FOrionLevelInfo::XPNeeded' has a wrong offset!");
static_assert(offsetof(FOrionLevelInfo, LevelType) == 0x00000C, "Member 'FOrionLevelInfo::LevelType' has a wrong offset!");

// ScriptStruct OrionGame.BannerBulkCommand
// 0x0030 (0x0030 - 0x0000)
struct FBannerBulkCommand final
{
public:
	EBannerCommandType                            BannerCommandType;                                 // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 bannerId;                                          // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OtherId;                                           // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBannerBulkCommand) == 0x000008, "Wrong alignment on FBannerBulkCommand");
static_assert(sizeof(FBannerBulkCommand) == 0x000030, "Wrong size on FBannerBulkCommand");
static_assert(offsetof(FBannerBulkCommand, BannerCommandType) == 0x000000, "Member 'FBannerBulkCommand::BannerCommandType' has a wrong offset!");
static_assert(offsetof(FBannerBulkCommand, bannerId) == 0x000008, "Member 'FBannerBulkCommand::bannerId' has a wrong offset!");
static_assert(offsetof(FBannerBulkCommand, OtherId) == 0x000018, "Member 'FBannerBulkCommand::OtherId' has a wrong offset!");
static_assert(offsetof(FBannerBulkCommand, Index) == 0x000028, "Member 'FBannerBulkCommand::Index' has a wrong offset!");

// ScriptStruct OrionGame.ConstellationNodeWeight
// 0x0004 (0x0004 - 0x0000)
struct FConstellationNodeWeight final
{
public:
	int32                                         Weight;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConstellationNodeWeight) == 0x000004, "Wrong alignment on FConstellationNodeWeight");
static_assert(sizeof(FConstellationNodeWeight) == 0x000004, "Wrong size on FConstellationNodeWeight");
static_assert(offsetof(FConstellationNodeWeight, Weight) == 0x000000, "Member 'FConstellationNodeWeight::Weight' has a wrong offset!");

// ScriptStruct OrionGame.OrionTemplateOverridePair
// 0x0050 (0x0058 - 0x0008)
struct FOrionTemplateOverridePair final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UOrionMcpItemDefinition> FromTemplate;                                      // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UOrionMcpItemDefinition> ToTemplate;                                        // 0x0030(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionTemplateOverridePair) == 0x000008, "Wrong alignment on FOrionTemplateOverridePair");
static_assert(sizeof(FOrionTemplateOverridePair) == 0x000058, "Wrong size on FOrionTemplateOverridePair");
static_assert(offsetof(FOrionTemplateOverridePair, FromTemplate) == 0x000008, "Member 'FOrionTemplateOverridePair::FromTemplate' has a wrong offset!");
static_assert(offsetof(FOrionTemplateOverridePair, ToTemplate) == 0x000030, "Member 'FOrionTemplateOverridePair::ToTemplate' has a wrong offset!");

// ScriptStruct OrionGame.OrionDeveloperMenuCommand
// 0x0020 (0x0020 - 0x0000)
struct FOrionDeveloperMenuCommand final
{
public:
	class FString                                 Category;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Commands;                                          // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionDeveloperMenuCommand) == 0x000008, "Wrong alignment on FOrionDeveloperMenuCommand");
static_assert(sizeof(FOrionDeveloperMenuCommand) == 0x000020, "Wrong size on FOrionDeveloperMenuCommand");
static_assert(offsetof(FOrionDeveloperMenuCommand, Category) == 0x000000, "Member 'FOrionDeveloperMenuCommand::Category' has a wrong offset!");
static_assert(offsetof(FOrionDeveloperMenuCommand, Commands) == 0x000010, "Member 'FOrionDeveloperMenuCommand::Commands' has a wrong offset!");

// ScriptStruct OrionGame.VaultHistoryEntry
// 0x0020 (0x0020 - 0x0000)
struct FVaultHistoryEntry final
{
public:
	class FString                                 VaultTemplateId;                                   // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ReceivedRewards;                                   // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVaultHistoryEntry) == 0x000008, "Wrong alignment on FVaultHistoryEntry");
static_assert(sizeof(FVaultHistoryEntry) == 0x000020, "Wrong size on FVaultHistoryEntry");
static_assert(offsetof(FVaultHistoryEntry, VaultTemplateId) == 0x000000, "Member 'FVaultHistoryEntry::VaultTemplateId' has a wrong offset!");
static_assert(offsetof(FVaultHistoryEntry, ReceivedRewards) == 0x000010, "Member 'FVaultHistoryEntry::ReceivedRewards' has a wrong offset!");

// ScriptStruct OrionGame.DynamicGrantedCooldownTags
// 0x0028 (0x0028 - 0x0000)
struct FDynamicGrantedCooldownTags final
{
public:
	struct FGameplayAbilitySpecHandle             AbilitySpecHandle;                                 // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  DynamicCooldownTags;                               // 0x0008(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FDynamicGrantedCooldownTags) == 0x000008, "Wrong alignment on FDynamicGrantedCooldownTags");
static_assert(sizeof(FDynamicGrantedCooldownTags) == 0x000028, "Wrong size on FDynamicGrantedCooldownTags");
static_assert(offsetof(FDynamicGrantedCooldownTags, AbilitySpecHandle) == 0x000000, "Member 'FDynamicGrantedCooldownTags::AbilitySpecHandle' has a wrong offset!");
static_assert(offsetof(FDynamicGrantedCooldownTags, DynamicCooldownTags) == 0x000008, "Member 'FDynamicGrantedCooldownTags::DynamicCooldownTags' has a wrong offset!");

// ScriptStruct OrionGame.OrionDirectionalAnimRef
// 0x0020 (0x0020 - 0x0000)
struct FOrionDirectionalAnimRef final
{
public:
	class UAnimSequenceBase*                      North;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      South;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      East;                                              // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      West;                                              // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionDirectionalAnimRef) == 0x000008, "Wrong alignment on FOrionDirectionalAnimRef");
static_assert(sizeof(FOrionDirectionalAnimRef) == 0x000020, "Wrong size on FOrionDirectionalAnimRef");
static_assert(offsetof(FOrionDirectionalAnimRef, North) == 0x000000, "Member 'FOrionDirectionalAnimRef::North' has a wrong offset!");
static_assert(offsetof(FOrionDirectionalAnimRef, South) == 0x000008, "Member 'FOrionDirectionalAnimRef::South' has a wrong offset!");
static_assert(offsetof(FOrionDirectionalAnimRef, East) == 0x000010, "Member 'FOrionDirectionalAnimRef::East' has a wrong offset!");
static_assert(offsetof(FOrionDirectionalAnimRef, West) == 0x000018, "Member 'FOrionDirectionalAnimRef::West' has a wrong offset!");

// ScriptStruct OrionGame.OrionJungleBuffInfo
// 0x01BF (0x01C0 - 0x0001)
struct alignas(0x10) FOrionJungleBuffInfo final : public FUIUpdateHelperStruct
{
public:
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TotalDuration;                                     // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeRemaining;                                     // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuffIndex;                                         // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           BuffAssetTag;                                      // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           BuffGrantedTag;                                    // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEmpty;                                          // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasCombatMessage;                                 // 0x0021(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionCombatMessageType                       AssociatedCombatMessage;                           // 0x0022(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x5];                                       // 0x0023(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  BuffGrantedTagContainer;                           // 0x0028(0x0020)(NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x178];                                     // 0x0048(0x0178)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionJungleBuffInfo) == 0x000010, "Wrong alignment on FOrionJungleBuffInfo");
static_assert(sizeof(FOrionJungleBuffInfo) == 0x0001C0, "Wrong size on FOrionJungleBuffInfo");
static_assert(offsetof(FOrionJungleBuffInfo, TotalDuration) == 0x000004, "Member 'FOrionJungleBuffInfo::TotalDuration' has a wrong offset!");
static_assert(offsetof(FOrionJungleBuffInfo, TimeRemaining) == 0x000008, "Member 'FOrionJungleBuffInfo::TimeRemaining' has a wrong offset!");
static_assert(offsetof(FOrionJungleBuffInfo, BuffIndex) == 0x00000C, "Member 'FOrionJungleBuffInfo::BuffIndex' has a wrong offset!");
static_assert(offsetof(FOrionJungleBuffInfo, BuffAssetTag) == 0x000010, "Member 'FOrionJungleBuffInfo::BuffAssetTag' has a wrong offset!");
static_assert(offsetof(FOrionJungleBuffInfo, BuffGrantedTag) == 0x000018, "Member 'FOrionJungleBuffInfo::BuffGrantedTag' has a wrong offset!");
static_assert(offsetof(FOrionJungleBuffInfo, bIsEmpty) == 0x000020, "Member 'FOrionJungleBuffInfo::bIsEmpty' has a wrong offset!");
static_assert(offsetof(FOrionJungleBuffInfo, bHasCombatMessage) == 0x000021, "Member 'FOrionJungleBuffInfo::bHasCombatMessage' has a wrong offset!");
static_assert(offsetof(FOrionJungleBuffInfo, AssociatedCombatMessage) == 0x000022, "Member 'FOrionJungleBuffInfo::AssociatedCombatMessage' has a wrong offset!");
static_assert(offsetof(FOrionJungleBuffInfo, BuffGrantedTagContainer) == 0x000028, "Member 'FOrionJungleBuffInfo::BuffGrantedTagContainer' has a wrong offset!");

// ScriptStruct OrionGame.OrionGameplayCueAttachInfo
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FOrionGameplayCueAttachInfo final
{
public:
	class FName                                   SocketName;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionGameplayCueParticleAttachType           AttachType;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionGameplayCueAttachInfo) == 0x000008, "Wrong alignment on FOrionGameplayCueAttachInfo");
static_assert(sizeof(FOrionGameplayCueAttachInfo) == 0x000010, "Wrong size on FOrionGameplayCueAttachInfo");
static_assert(offsetof(FOrionGameplayCueAttachInfo, SocketName) == 0x000000, "Member 'FOrionGameplayCueAttachInfo::SocketName' has a wrong offset!");
static_assert(offsetof(FOrionGameplayCueAttachInfo, AttachType) == 0x000008, "Member 'FOrionGameplayCueAttachInfo::AttachType' has a wrong offset!");

// ScriptStruct OrionGame.GameplayCueNiagaraParticleInfo
// 0x0040 (0x0040 - 0x0000)
struct FGameplayCueNiagaraParticleInfo final
{
public:
	class UNiagaraSystem*                         ParticleSystem;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOrionGameplayCueConditionedNiagaraParticles> AdditionalParticleSystems;                         // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FOrionGameplayCueAttachInfo            AttachmentInfo;                                    // 0x0018(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	ELocalVisiblityPolicy                         LocalVisiblityPolicy;                              // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EParticleTeamColorAdjustStyle                 TeamColorAdjust;                                   // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CastShadow;                                        // 0x002A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x1];                                       // 0x002B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Scale;                                             // 0x002C(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAbsoluteScale;                                 // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayCueNiagaraParticleInfo) == 0x000008, "Wrong alignment on FGameplayCueNiagaraParticleInfo");
static_assert(sizeof(FGameplayCueNiagaraParticleInfo) == 0x000040, "Wrong size on FGameplayCueNiagaraParticleInfo");
static_assert(offsetof(FGameplayCueNiagaraParticleInfo, ParticleSystem) == 0x000000, "Member 'FGameplayCueNiagaraParticleInfo::ParticleSystem' has a wrong offset!");
static_assert(offsetof(FGameplayCueNiagaraParticleInfo, AdditionalParticleSystems) == 0x000008, "Member 'FGameplayCueNiagaraParticleInfo::AdditionalParticleSystems' has a wrong offset!");
static_assert(offsetof(FGameplayCueNiagaraParticleInfo, AttachmentInfo) == 0x000018, "Member 'FGameplayCueNiagaraParticleInfo::AttachmentInfo' has a wrong offset!");
static_assert(offsetof(FGameplayCueNiagaraParticleInfo, LocalVisiblityPolicy) == 0x000028, "Member 'FGameplayCueNiagaraParticleInfo::LocalVisiblityPolicy' has a wrong offset!");
static_assert(offsetof(FGameplayCueNiagaraParticleInfo, TeamColorAdjust) == 0x000029, "Member 'FGameplayCueNiagaraParticleInfo::TeamColorAdjust' has a wrong offset!");
static_assert(offsetof(FGameplayCueNiagaraParticleInfo, CastShadow) == 0x00002A, "Member 'FGameplayCueNiagaraParticleInfo::CastShadow' has a wrong offset!");
static_assert(offsetof(FGameplayCueNiagaraParticleInfo, Scale) == 0x00002C, "Member 'FGameplayCueNiagaraParticleInfo::Scale' has a wrong offset!");
static_assert(offsetof(FGameplayCueNiagaraParticleInfo, bUseAbsoluteScale) == 0x000038, "Member 'FGameplayCueNiagaraParticleInfo::bUseAbsoluteScale' has a wrong offset!");

// ScriptStruct OrionGame.OrionMcpIncludedItem
// 0x0010 (0x0010 - 0x0000)
struct FOrionMcpIncludedItem final
{
public:
	class UOrionMcpItemDefinition*                ItemDefinition;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionMcpIncludedItem) == 0x000008, "Wrong alignment on FOrionMcpIncludedItem");
static_assert(sizeof(FOrionMcpIncludedItem) == 0x000010, "Wrong size on FOrionMcpIncludedItem");
static_assert(offsetof(FOrionMcpIncludedItem, ItemDefinition) == 0x000000, "Member 'FOrionMcpIncludedItem::ItemDefinition' has a wrong offset!");
static_assert(offsetof(FOrionMcpIncludedItem, Quantity) == 0x000008, "Member 'FOrionMcpIncludedItem::Quantity' has a wrong offset!");

// ScriptStruct OrionGame.OrionMcpItemDefinitionRewardDisplay
// 0x0090 (0x0090 - 0x0000)
struct FOrionMcpItemDefinitionRewardDisplay final
{
public:
	struct FInt32Range                            Quantity;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UObject>                 DisplayAsset;                                      // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionItemRarity                              Rarity;                                            // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   StingerOverride;                                   // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          HideQuantity;                                      // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOrionMcpIncludedItem>          IncludedItems;                                     // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bShowMore;                                         // 0x0088(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionMcpItemDefinitionRewardDisplay) == 0x000008, "Wrong alignment on FOrionMcpItemDefinitionRewardDisplay");
static_assert(sizeof(FOrionMcpItemDefinitionRewardDisplay) == 0x000090, "Wrong size on FOrionMcpItemDefinitionRewardDisplay");
static_assert(offsetof(FOrionMcpItemDefinitionRewardDisplay, Quantity) == 0x000000, "Member 'FOrionMcpItemDefinitionRewardDisplay::Quantity' has a wrong offset!");
static_assert(offsetof(FOrionMcpItemDefinitionRewardDisplay, DisplayName) == 0x000010, "Member 'FOrionMcpItemDefinitionRewardDisplay::DisplayName' has a wrong offset!");
static_assert(offsetof(FOrionMcpItemDefinitionRewardDisplay, DisplayAsset) == 0x000028, "Member 'FOrionMcpItemDefinitionRewardDisplay::DisplayAsset' has a wrong offset!");
static_assert(offsetof(FOrionMcpItemDefinitionRewardDisplay, Rarity) == 0x000050, "Member 'FOrionMcpItemDefinitionRewardDisplay::Rarity' has a wrong offset!");
static_assert(offsetof(FOrionMcpItemDefinitionRewardDisplay, StingerOverride) == 0x000058, "Member 'FOrionMcpItemDefinitionRewardDisplay::StingerOverride' has a wrong offset!");
static_assert(offsetof(FOrionMcpItemDefinitionRewardDisplay, HideQuantity) == 0x000070, "Member 'FOrionMcpItemDefinitionRewardDisplay::HideQuantity' has a wrong offset!");
static_assert(offsetof(FOrionMcpItemDefinitionRewardDisplay, IncludedItems) == 0x000078, "Member 'FOrionMcpItemDefinitionRewardDisplay::IncludedItems' has a wrong offset!");
static_assert(offsetof(FOrionMcpItemDefinitionRewardDisplay, bShowMore) == 0x000088, "Member 'FOrionMcpItemDefinitionRewardDisplay::bShowMore' has a wrong offset!");

// ScriptStruct OrionGame.BotObjectiveGraphPathfindingCost
// 0x0014 (0x0014 - 0x0000)
struct FBotObjectiveGraphPathfindingCost final
{
public:
	float                                         DefaultNodeEnterCost;                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyTowerCost;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OwnTowerCost;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmptyLaneNodeCost;                                 // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrefferedLanesCostMultiplier;                      // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBotObjectiveGraphPathfindingCost) == 0x000004, "Wrong alignment on FBotObjectiveGraphPathfindingCost");
static_assert(sizeof(FBotObjectiveGraphPathfindingCost) == 0x000014, "Wrong size on FBotObjectiveGraphPathfindingCost");
static_assert(offsetof(FBotObjectiveGraphPathfindingCost, DefaultNodeEnterCost) == 0x000000, "Member 'FBotObjectiveGraphPathfindingCost::DefaultNodeEnterCost' has a wrong offset!");
static_assert(offsetof(FBotObjectiveGraphPathfindingCost, EnemyTowerCost) == 0x000004, "Member 'FBotObjectiveGraphPathfindingCost::EnemyTowerCost' has a wrong offset!");
static_assert(offsetof(FBotObjectiveGraphPathfindingCost, OwnTowerCost) == 0x000008, "Member 'FBotObjectiveGraphPathfindingCost::OwnTowerCost' has a wrong offset!");
static_assert(offsetof(FBotObjectiveGraphPathfindingCost, EmptyLaneNodeCost) == 0x00000C, "Member 'FBotObjectiveGraphPathfindingCost::EmptyLaneNodeCost' has a wrong offset!");
static_assert(offsetof(FBotObjectiveGraphPathfindingCost, PrefferedLanesCostMultiplier) == 0x000010, "Member 'FBotObjectiveGraphPathfindingCost::PrefferedLanesCostMultiplier' has a wrong offset!");

// ScriptStruct OrionGame.OrionProjectileCues
// 0x0048 (0x0048 - 0x0000)
struct FOrionProjectileCues final
{
public:
	struct FGameplayCueTag                        Spawn;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        Destroy;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        HitCharacter;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        HitCharacterShield;                                // 0x0018(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        HitWorld;                                          // 0x0020(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bOrientHitGCsToProjectileVelocity;                 // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSurfaceNormalDeviationAngle;                    // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        Bounce;                                            // 0x0030(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        Explosion;                                         // 0x0038(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        NoHit;                                             // 0x0040(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionProjectileCues) == 0x000008, "Wrong alignment on FOrionProjectileCues");
static_assert(sizeof(FOrionProjectileCues) == 0x000048, "Wrong size on FOrionProjectileCues");
static_assert(offsetof(FOrionProjectileCues, Spawn) == 0x000000, "Member 'FOrionProjectileCues::Spawn' has a wrong offset!");
static_assert(offsetof(FOrionProjectileCues, Destroy) == 0x000008, "Member 'FOrionProjectileCues::Destroy' has a wrong offset!");
static_assert(offsetof(FOrionProjectileCues, HitCharacter) == 0x000010, "Member 'FOrionProjectileCues::HitCharacter' has a wrong offset!");
static_assert(offsetof(FOrionProjectileCues, HitCharacterShield) == 0x000018, "Member 'FOrionProjectileCues::HitCharacterShield' has a wrong offset!");
static_assert(offsetof(FOrionProjectileCues, HitWorld) == 0x000020, "Member 'FOrionProjectileCues::HitWorld' has a wrong offset!");
static_assert(offsetof(FOrionProjectileCues, bOrientHitGCsToProjectileVelocity) == 0x000028, "Member 'FOrionProjectileCues::bOrientHitGCsToProjectileVelocity' has a wrong offset!");
static_assert(offsetof(FOrionProjectileCues, MaxSurfaceNormalDeviationAngle) == 0x00002C, "Member 'FOrionProjectileCues::MaxSurfaceNormalDeviationAngle' has a wrong offset!");
static_assert(offsetof(FOrionProjectileCues, Bounce) == 0x000030, "Member 'FOrionProjectileCues::Bounce' has a wrong offset!");
static_assert(offsetof(FOrionProjectileCues, Explosion) == 0x000038, "Member 'FOrionProjectileCues::Explosion' has a wrong offset!");
static_assert(offsetof(FOrionProjectileCues, NoHit) == 0x000040, "Member 'FOrionProjectileCues::NoHit' has a wrong offset!");

// ScriptStruct OrionGame.OrionMcpTranslateTokenMapping
// 0x0010 (0x0010 - 0x0000)
struct FOrionMcpTranslateTokenMapping final
{
public:
	class UOrionMcpTranslateTokenItemDefinition*  TranslateToken;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionMcpItemDefinition*                Item;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionMcpTranslateTokenMapping) == 0x000008, "Wrong alignment on FOrionMcpTranslateTokenMapping");
static_assert(sizeof(FOrionMcpTranslateTokenMapping) == 0x000010, "Wrong size on FOrionMcpTranslateTokenMapping");
static_assert(offsetof(FOrionMcpTranslateTokenMapping, TranslateToken) == 0x000000, "Member 'FOrionMcpTranslateTokenMapping::TranslateToken' has a wrong offset!");
static_assert(offsetof(FOrionMcpTranslateTokenMapping, Item) == 0x000008, "Member 'FOrionMcpTranslateTokenMapping::Item' has a wrong offset!");

// ScriptStruct OrionGame.QualifierContextBase
// 0x0000 (0x0000 - 0x0000)
#pragma pack(push, 0x1)
struct alignas(0x01) FQualifierContextBase
{
};
#pragma pack(pop)
static_assert(alignof(FQualifierContextBase) == 0x000001, "Wrong alignment on FQualifierContextBase");
static_assert(sizeof(FQualifierContextBase) == 0x000001, "Wrong size on FQualifierContextBase");

// ScriptStruct OrionGame.MouseButtonArt
// 0x0090 (0x0090 - 0x0000)
struct FMouseButtonArt final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Edit, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            ButtonIcon;                                        // 0x0018(0x0078)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMouseButtonArt) == 0x000008, "Wrong alignment on FMouseButtonArt");
static_assert(sizeof(FMouseButtonArt) == 0x000090, "Wrong size on FMouseButtonArt");
static_assert(offsetof(FMouseButtonArt, Key) == 0x000000, "Member 'FMouseButtonArt::Key' has a wrong offset!");
static_assert(offsetof(FMouseButtonArt, ButtonIcon) == 0x000018, "Member 'FMouseButtonArt::ButtonIcon' has a wrong offset!");

// ScriptStruct OrionGame.QualifierContextDamage
// 0x0028 (0x0028 - 0x0000)
struct FQualifierContextDamage final : public FQualifierContextBase
{
public:
	float                                         TotalUnmitigatedDamage;                            // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalMitigatedDamage;                              // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinalHealthLost;                                   // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinalShieldLost;                                   // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartingHealthPCT;                                 // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndingHealthPCT;                                   // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartingHealthValue;                               // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndingHealthValue;                                 // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeStealDone;                                     // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DidCrit;                                           // 0x0024(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MinHealthClampedDamage;                            // 0x0025(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQualifierContextDamage) == 0x000004, "Wrong alignment on FQualifierContextDamage");
static_assert(sizeof(FQualifierContextDamage) == 0x000028, "Wrong size on FQualifierContextDamage");
static_assert(offsetof(FQualifierContextDamage, TotalUnmitigatedDamage) == 0x000000, "Member 'FQualifierContextDamage::TotalUnmitigatedDamage' has a wrong offset!");
static_assert(offsetof(FQualifierContextDamage, TotalMitigatedDamage) == 0x000004, "Member 'FQualifierContextDamage::TotalMitigatedDamage' has a wrong offset!");
static_assert(offsetof(FQualifierContextDamage, FinalHealthLost) == 0x000008, "Member 'FQualifierContextDamage::FinalHealthLost' has a wrong offset!");
static_assert(offsetof(FQualifierContextDamage, FinalShieldLost) == 0x00000C, "Member 'FQualifierContextDamage::FinalShieldLost' has a wrong offset!");
static_assert(offsetof(FQualifierContextDamage, StartingHealthPCT) == 0x000010, "Member 'FQualifierContextDamage::StartingHealthPCT' has a wrong offset!");
static_assert(offsetof(FQualifierContextDamage, EndingHealthPCT) == 0x000014, "Member 'FQualifierContextDamage::EndingHealthPCT' has a wrong offset!");
static_assert(offsetof(FQualifierContextDamage, StartingHealthValue) == 0x000018, "Member 'FQualifierContextDamage::StartingHealthValue' has a wrong offset!");
static_assert(offsetof(FQualifierContextDamage, EndingHealthValue) == 0x00001C, "Member 'FQualifierContextDamage::EndingHealthValue' has a wrong offset!");
static_assert(offsetof(FQualifierContextDamage, LifeStealDone) == 0x000020, "Member 'FQualifierContextDamage::LifeStealDone' has a wrong offset!");
static_assert(offsetof(FQualifierContextDamage, DidCrit) == 0x000024, "Member 'FQualifierContextDamage::DidCrit' has a wrong offset!");
static_assert(offsetof(FQualifierContextDamage, MinHealthClampedDamage) == 0x000025, "Member 'FQualifierContextDamage::MinHealthClampedDamage' has a wrong offset!");

// ScriptStruct OrionGame.OrionAbilityUIData
// 0x00BF (0x00C0 - 0x0001)
struct FOrionAbilityUIData final : public FUIUpdateHelperStruct
{
public:
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CooldownTimeRemaining;                             // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanActivate;                                      // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUnlocked;                                       // 0x0009(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnlockHappened;                                   // 0x000A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             AbilityImage;                                      // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 KeyString;                                         // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EmptyAbility;                                      // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CachedHeroLevel;                                   // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AbilityLevel;                                      // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AbilityLevelMax;                                   // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanLevelUpAbility;                                // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StacksRemaining;                                   // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StacksMax;                                         // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   AbilityDisplayName;                                // 0x0048(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   AbilityDescription;                                // 0x0060(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   AbilityShortDescription;                           // 0x0078(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UOrionAbility*                          Ability;                                           // 0x0090(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionHeroData*                         HeroData;                                          // 0x0098(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AbilityCost;                                       // 0x00A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StackCount;                                        // 0x00A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StackCountMax;                                     // 0x00A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasStacks;                                        // 0x00AC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DurationEndTime;                                   // 0x00B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationLength;                                    // 0x00B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHUDDisplayType                               DurationDisplayType;                               // 0x00B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCurrentlyEngaged;                                 // 0x00B9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSilenced;                                         // 0x00BA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeverActivated;                                   // 0x00BB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InputID;                                           // 0x00BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionAbilityUIData) == 0x000008, "Wrong alignment on FOrionAbilityUIData");
static_assert(sizeof(FOrionAbilityUIData) == 0x0000C0, "Wrong size on FOrionAbilityUIData");
static_assert(offsetof(FOrionAbilityUIData, CooldownTimeRemaining) == 0x000004, "Member 'FOrionAbilityUIData::CooldownTimeRemaining' has a wrong offset!");
static_assert(offsetof(FOrionAbilityUIData, bCanActivate) == 0x000008, "Member 'FOrionAbilityUIData::bCanActivate' has a wrong offset!");
static_assert(offsetof(FOrionAbilityUIData, bIsUnlocked) == 0x000009, "Member 'FOrionAbilityUIData::bIsUnlocked' has a wrong offset!");
static_assert(offsetof(FOrionAbilityUIData, bUnlockHappened) == 0x00000A, "Member 'FOrionAbilityUIData::bUnlockHappened' has a wrong offset!");
static_assert(offsetof(FOrionAbilityUIData, AbilityImage) == 0x000010, "Member 'FOrionAbilityUIData::AbilityImage' has a wrong offset!");
static_assert(offsetof(FOrionAbilityUIData, KeyString) == 0x000018, "Member 'FOrionAbilityUIData::KeyString' has a wrong offset!");
static_assert(offsetof(FOrionAbilityUIData, EmptyAbility) == 0x000028, "Member 'FOrionAbilityUIData::EmptyAbility' has a wrong offset!");
static_assert(offsetof(FOrionAbilityUIData, CachedHeroLevel) == 0x00002C, "Member 'FOrionAbilityUIData::CachedHeroLevel' has a wrong offset!");
static_assert(offsetof(FOrionAbilityUIData, AbilityLevel) == 0x000030, "Member 'FOrionAbilityUIData::AbilityLevel' has a wrong offset!");
static_assert(offsetof(FOrionAbilityUIData, AbilityLevelMax) == 0x000034, "Member 'FOrionAbilityUIData::AbilityLevelMax' has a wrong offset!");
static_assert(offsetof(FOrionAbilityUIData, bCanLevelUpAbility) == 0x000038, "Member 'FOrionAbilityUIData::bCanLevelUpAbility' has a wrong offset!");
static_assert(offsetof(FOrionAbilityUIData, StacksRemaining) == 0x00003C, "Member 'FOrionAbilityUIData::StacksRemaining' has a wrong offset!");
static_assert(offsetof(FOrionAbilityUIData, StacksMax) == 0x000040, "Member 'FOrionAbilityUIData::StacksMax' has a wrong offset!");
static_assert(offsetof(FOrionAbilityUIData, AbilityDisplayName) == 0x000048, "Member 'FOrionAbilityUIData::AbilityDisplayName' has a wrong offset!");
static_assert(offsetof(FOrionAbilityUIData, AbilityDescription) == 0x000060, "Member 'FOrionAbilityUIData::AbilityDescription' has a wrong offset!");
static_assert(offsetof(FOrionAbilityUIData, AbilityShortDescription) == 0x000078, "Member 'FOrionAbilityUIData::AbilityShortDescription' has a wrong offset!");
static_assert(offsetof(FOrionAbilityUIData, Ability) == 0x000090, "Member 'FOrionAbilityUIData::Ability' has a wrong offset!");
static_assert(offsetof(FOrionAbilityUIData, HeroData) == 0x000098, "Member 'FOrionAbilityUIData::HeroData' has a wrong offset!");
static_assert(offsetof(FOrionAbilityUIData, AbilityCost) == 0x0000A0, "Member 'FOrionAbilityUIData::AbilityCost' has a wrong offset!");
static_assert(offsetof(FOrionAbilityUIData, StackCount) == 0x0000A4, "Member 'FOrionAbilityUIData::StackCount' has a wrong offset!");
static_assert(offsetof(FOrionAbilityUIData, StackCountMax) == 0x0000A8, "Member 'FOrionAbilityUIData::StackCountMax' has a wrong offset!");
static_assert(offsetof(FOrionAbilityUIData, bHasStacks) == 0x0000AC, "Member 'FOrionAbilityUIData::bHasStacks' has a wrong offset!");
static_assert(offsetof(FOrionAbilityUIData, DurationEndTime) == 0x0000B0, "Member 'FOrionAbilityUIData::DurationEndTime' has a wrong offset!");
static_assert(offsetof(FOrionAbilityUIData, DurationLength) == 0x0000B4, "Member 'FOrionAbilityUIData::DurationLength' has a wrong offset!");
static_assert(offsetof(FOrionAbilityUIData, DurationDisplayType) == 0x0000B8, "Member 'FOrionAbilityUIData::DurationDisplayType' has a wrong offset!");
static_assert(offsetof(FOrionAbilityUIData, bCurrentlyEngaged) == 0x0000B9, "Member 'FOrionAbilityUIData::bCurrentlyEngaged' has a wrong offset!");
static_assert(offsetof(FOrionAbilityUIData, bSilenced) == 0x0000BA, "Member 'FOrionAbilityUIData::bSilenced' has a wrong offset!");
static_assert(offsetof(FOrionAbilityUIData, bNeverActivated) == 0x0000BB, "Member 'FOrionAbilityUIData::bNeverActivated' has a wrong offset!");
static_assert(offsetof(FOrionAbilityUIData, InputID) == 0x0000BC, "Member 'FOrionAbilityUIData::InputID' has a wrong offset!");

// ScriptStruct OrionGame.AIRouteMarkup
// 0x0018 (0x0018 - 0x0000)
struct FAIRouteMarkup
{
public:
	TArray<class AActor*>                         Path;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         RouteID;                                           // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         MaxBotsPerTeam;                                    // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAIBotTeamDisplay                             Team;                                              // 0x0015(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bSingleTeam : 1;                                   // 0x0016(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsCircular : 1;                                   // 0x0016(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsRandom : 1;                                     // 0x0016(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_17[0x1];                                       // 0x0017(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIRouteMarkup) == 0x000008, "Wrong alignment on FAIRouteMarkup");
static_assert(sizeof(FAIRouteMarkup) == 0x000018, "Wrong size on FAIRouteMarkup");
static_assert(offsetof(FAIRouteMarkup, Path) == 0x000000, "Member 'FAIRouteMarkup::Path' has a wrong offset!");
static_assert(offsetof(FAIRouteMarkup, RouteID) == 0x000010, "Member 'FAIRouteMarkup::RouteID' has a wrong offset!");
static_assert(offsetof(FAIRouteMarkup, MaxBotsPerTeam) == 0x000014, "Member 'FAIRouteMarkup::MaxBotsPerTeam' has a wrong offset!");
static_assert(offsetof(FAIRouteMarkup, Team) == 0x000015, "Member 'FAIRouteMarkup::Team' has a wrong offset!");

// ScriptStruct OrionGame.VisionManagerDebugItem
// 0x0040 (0x0040 - 0x0000)
struct FVisionManagerDebugItem final
{
public:
	EVisionManagerDebug                           Type;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    Team;                                              // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize10                  TraceStart;                                        // 0x0004(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize10                  TraceEnd;                                          // 0x0010(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize10                  TraceHit;                                          // 0x001C(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ViewerActor;                                       // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 HitActor;                                          // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVisionManagerDebugItem) == 0x000008, "Wrong alignment on FVisionManagerDebugItem");
static_assert(sizeof(FVisionManagerDebugItem) == 0x000040, "Wrong size on FVisionManagerDebugItem");
static_assert(offsetof(FVisionManagerDebugItem, Type) == 0x000000, "Member 'FVisionManagerDebugItem::Type' has a wrong offset!");
static_assert(offsetof(FVisionManagerDebugItem, Team) == 0x000001, "Member 'FVisionManagerDebugItem::Team' has a wrong offset!");
static_assert(offsetof(FVisionManagerDebugItem, TraceStart) == 0x000004, "Member 'FVisionManagerDebugItem::TraceStart' has a wrong offset!");
static_assert(offsetof(FVisionManagerDebugItem, TraceEnd) == 0x000010, "Member 'FVisionManagerDebugItem::TraceEnd' has a wrong offset!");
static_assert(offsetof(FVisionManagerDebugItem, TraceHit) == 0x00001C, "Member 'FVisionManagerDebugItem::TraceHit' has a wrong offset!");
static_assert(offsetof(FVisionManagerDebugItem, TargetActor) == 0x000028, "Member 'FVisionManagerDebugItem::TargetActor' has a wrong offset!");
static_assert(offsetof(FVisionManagerDebugItem, ViewerActor) == 0x000030, "Member 'FVisionManagerDebugItem::ViewerActor' has a wrong offset!");
static_assert(offsetof(FVisionManagerDebugItem, HitActor) == 0x000038, "Member 'FVisionManagerDebugItem::HitActor' has a wrong offset!");

// ScriptStruct OrionGame.NativePlaylistIDs
// 0x0020 (0x0020 - 0x0000)
struct FNativePlaylistIDs final
{
public:
	int32                                         PlaylistID_Training;                               // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlaylistID_Solo_Sovereign;                         // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlaylistID_PVP_Sovereign;                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlaylistID_PVP;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlaylistID_CoopVsAI;                               // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlaylistID_SoloVsAI;                               // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlaylistID_Sandbox;                                // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlaylistID_PerfTest;                               // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNativePlaylistIDs) == 0x000004, "Wrong alignment on FNativePlaylistIDs");
static_assert(sizeof(FNativePlaylistIDs) == 0x000020, "Wrong size on FNativePlaylistIDs");
static_assert(offsetof(FNativePlaylistIDs, PlaylistID_Training) == 0x000000, "Member 'FNativePlaylistIDs::PlaylistID_Training' has a wrong offset!");
static_assert(offsetof(FNativePlaylistIDs, PlaylistID_Solo_Sovereign) == 0x000004, "Member 'FNativePlaylistIDs::PlaylistID_Solo_Sovereign' has a wrong offset!");
static_assert(offsetof(FNativePlaylistIDs, PlaylistID_PVP_Sovereign) == 0x000008, "Member 'FNativePlaylistIDs::PlaylistID_PVP_Sovereign' has a wrong offset!");
static_assert(offsetof(FNativePlaylistIDs, PlaylistID_PVP) == 0x00000C, "Member 'FNativePlaylistIDs::PlaylistID_PVP' has a wrong offset!");
static_assert(offsetof(FNativePlaylistIDs, PlaylistID_CoopVsAI) == 0x000010, "Member 'FNativePlaylistIDs::PlaylistID_CoopVsAI' has a wrong offset!");
static_assert(offsetof(FNativePlaylistIDs, PlaylistID_SoloVsAI) == 0x000014, "Member 'FNativePlaylistIDs::PlaylistID_SoloVsAI' has a wrong offset!");
static_assert(offsetof(FNativePlaylistIDs, PlaylistID_Sandbox) == 0x000018, "Member 'FNativePlaylistIDs::PlaylistID_Sandbox' has a wrong offset!");
static_assert(offsetof(FNativePlaylistIDs, PlaylistID_PerfTest) == 0x00001C, "Member 'FNativePlaylistIDs::PlaylistID_PerfTest' has a wrong offset!");

// ScriptStruct OrionGame.OrionMMRStep
// 0x000C (0x000C - 0x0000)
struct FOrionMMRStep final
{
public:
	int32                                         DeltaBase;                                         // 0x0000(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxDelta;                                          // 0x0004(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxExpansionTime;                                  // 0x0008(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionMMRStep) == 0x000004, "Wrong alignment on FOrionMMRStep");
static_assert(sizeof(FOrionMMRStep) == 0x00000C, "Wrong size on FOrionMMRStep");
static_assert(offsetof(FOrionMMRStep, DeltaBase) == 0x000000, "Member 'FOrionMMRStep::DeltaBase' has a wrong offset!");
static_assert(offsetof(FOrionMMRStep, MaxDelta) == 0x000004, "Member 'FOrionMMRStep::MaxDelta' has a wrong offset!");
static_assert(offsetof(FOrionMMRStep, MaxExpansionTime) == 0x000008, "Member 'FOrionMMRStep::MaxExpansionTime' has a wrong offset!");

// ScriptStruct OrionGame.OrionStarterDecks
// 0x0038 (0x0038 - 0x0000)
struct FOrionStarterDecks final
{
public:
	TSoftObjectPtr<class UOrionMcpCuratedDeckItemDefinition> TutorialDeck;                                      // 0x0000(0x0028)(Edit, DisableEditOnTemplate, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UOrionMcpCuratedDeckItemDefinition>> StarterDeckCollection;                             // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionStarterDecks) == 0x000008, "Wrong alignment on FOrionStarterDecks");
static_assert(sizeof(FOrionStarterDecks) == 0x000038, "Wrong size on FOrionStarterDecks");
static_assert(offsetof(FOrionStarterDecks, TutorialDeck) == 0x000000, "Member 'FOrionStarterDecks::TutorialDeck' has a wrong offset!");
static_assert(offsetof(FOrionStarterDecks, StarterDeckCollection) == 0x000028, "Member 'FOrionStarterDecks::StarterDeckCollection' has a wrong offset!");

// ScriptStruct OrionGame.OrionAffinityStruct
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FOrionAffinityStruct final
{
public:
	uint8                                         bGrowthAffinity : 1;                               // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bChaosAffinity : 1;                                // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bKnowledgeAffinity : 1;                            // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bOrderAffinity : 1;                                // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDeathAffinity : 1;                                // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionAffinityStruct) == 0x000004, "Wrong alignment on FOrionAffinityStruct");
static_assert(sizeof(FOrionAffinityStruct) == 0x000004, "Wrong size on FOrionAffinityStruct");

// ScriptStruct OrionGame.OrionCardLevel
// 0x0008 (0x0008 - 0x0000)
struct FOrionCardLevel final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredXP;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionCardLevel) == 0x000004, "Wrong alignment on FOrionCardLevel");
static_assert(sizeof(FOrionCardLevel) == 0x000008, "Wrong size on FOrionCardLevel");
static_assert(offsetof(FOrionCardLevel, Level) == 0x000000, "Member 'FOrionCardLevel::Level' has a wrong offset!");
static_assert(offsetof(FOrionCardLevel, RequiredXP) == 0x000004, "Member 'FOrionCardLevel::RequiredXP' has a wrong offset!");

// ScriptStruct OrionGame.OrionCachedFloatCurve
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FOrionCachedFloatCurve
{
public:
	class FName                                   CurveName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionCachedFloatCurve) == 0x000008, "Wrong alignment on FOrionCachedFloatCurve");
static_assert(sizeof(FOrionCachedFloatCurve) == 0x000010, "Wrong size on FOrionCachedFloatCurve");
static_assert(offsetof(FOrionCachedFloatCurve, CurveName) == 0x000000, "Member 'FOrionCachedFloatCurve::CurveName' has a wrong offset!");

// ScriptStruct OrionGame.OrionPotentialTarget
// 0x0018 (0x0018 - 0x0000)
struct FOrionPotentialTarget final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCapsuleComponent*                      Capsule;                                           // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionPotentialTarget) == 0x000008, "Wrong alignment on FOrionPotentialTarget");
static_assert(sizeof(FOrionPotentialTarget) == 0x000018, "Wrong size on FOrionPotentialTarget");
static_assert(offsetof(FOrionPotentialTarget, Actor) == 0x000000, "Member 'FOrionPotentialTarget::Actor' has a wrong offset!");
static_assert(offsetof(FOrionPotentialTarget, Capsule) == 0x000008, "Member 'FOrionPotentialTarget::Capsule' has a wrong offset!");

// ScriptStruct OrionGame.LanePath
// 0x0018 (0x0018 - 0x0000)
struct FLanePath
{
public:
	TArray<int32>                                 Nodes;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         LaneID;                                            // 0x0010(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLanePath) == 0x000008, "Wrong alignment on FLanePath");
static_assert(sizeof(FLanePath) == 0x000018, "Wrong size on FLanePath");
static_assert(offsetof(FLanePath, Nodes) == 0x000000, "Member 'FLanePath::Nodes' has a wrong offset!");
static_assert(offsetof(FLanePath, LaneID) == 0x000010, "Member 'FLanePath::LaneID' has a wrong offset!");

// ScriptStruct OrionGame.TeamOwnershipXPBonusEntry
// 0x0020 (0x0020 - 0x0000)
struct FTeamOwnershipXPBonusEntry final
{
public:
	class FString                                 PlayerNetId;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HeroRank;                                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMe;                                             // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TeamBonusStarsContrib;                             // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTeamOwnershipXPBonusEntry) == 0x000008, "Wrong alignment on FTeamOwnershipXPBonusEntry");
static_assert(sizeof(FTeamOwnershipXPBonusEntry) == 0x000020, "Wrong size on FTeamOwnershipXPBonusEntry");
static_assert(offsetof(FTeamOwnershipXPBonusEntry, PlayerNetId) == 0x000000, "Member 'FTeamOwnershipXPBonusEntry::PlayerNetId' has a wrong offset!");
static_assert(offsetof(FTeamOwnershipXPBonusEntry, HeroRank) == 0x000010, "Member 'FTeamOwnershipXPBonusEntry::HeroRank' has a wrong offset!");
static_assert(offsetof(FTeamOwnershipXPBonusEntry, bIsMe) == 0x000014, "Member 'FTeamOwnershipXPBonusEntry::bIsMe' has a wrong offset!");
static_assert(offsetof(FTeamOwnershipXPBonusEntry, TeamBonusStarsContrib) == 0x000018, "Member 'FTeamOwnershipXPBonusEntry::TeamBonusStarsContrib' has a wrong offset!");

// ScriptStruct OrionGame.OrionHeroTraitEntry
// 0x0008 (0x0008 - 0x0000)
struct FOrionHeroTraitEntry final
{
public:
	EOrionHeroTrait                               Trait;                                             // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Weight;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionHeroTraitEntry) == 0x000004, "Wrong alignment on FOrionHeroTraitEntry");
static_assert(sizeof(FOrionHeroTraitEntry) == 0x000008, "Wrong size on FOrionHeroTraitEntry");
static_assert(offsetof(FOrionHeroTraitEntry, Trait) == 0x000000, "Member 'FOrionHeroTraitEntry::Trait' has a wrong offset!");
static_assert(offsetof(FOrionHeroTraitEntry, Weight) == 0x000004, "Member 'FOrionHeroTraitEntry::Weight' has a wrong offset!");

// ScriptStruct OrionGame.OrionHeroRoleEntry
// 0x0008 (0x0008 - 0x0000)
struct FOrionHeroRoleEntry final
{
public:
	EOrionRole                                    Role;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionHeroRoleEntry) == 0x000004, "Wrong alignment on FOrionHeroRoleEntry");
static_assert(sizeof(FOrionHeroRoleEntry) == 0x000008, "Wrong size on FOrionHeroRoleEntry");
static_assert(offsetof(FOrionHeroRoleEntry, Role) == 0x000000, "Member 'FOrionHeroRoleEntry::Role' has a wrong offset!");
static_assert(offsetof(FOrionHeroRoleEntry, Weight) == 0x000004, "Member 'FOrionHeroRoleEntry::Weight' has a wrong offset!");

// ScriptStruct OrionGame.OrionHeroRoles
// 0x0018 (0x0018 - 0x0000)
struct FOrionHeroRoles final
{
public:
	EOrionHeroRangeType                           RangeType;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOrionHeroRoleEntry>            PossibleRoles;                                     // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionHeroRoles) == 0x000008, "Wrong alignment on FOrionHeroRoles");
static_assert(sizeof(FOrionHeroRoles) == 0x000018, "Wrong size on FOrionHeroRoles");
static_assert(offsetof(FOrionHeroRoles, RangeType) == 0x000000, "Member 'FOrionHeroRoles::RangeType' has a wrong offset!");
static_assert(offsetof(FOrionHeroRoles, PossibleRoles) == 0x000008, "Member 'FOrionHeroRoles::PossibleRoles' has a wrong offset!");

// ScriptStruct OrionGame.ParamIdMap
// 0x0050 (0x0050 - 0x0000)
struct FParamIdMap final
{
public:
	TMap<uint32, class FName>                     NamesByHashedId;                                   // 0x0000(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FParamIdMap) == 0x000008, "Wrong alignment on FParamIdMap");
static_assert(sizeof(FParamIdMap) == 0x000050, "Wrong size on FParamIdMap");
static_assert(offsetof(FParamIdMap, NamesByHashedId) == 0x000000, "Member 'FParamIdMap::NamesByHashedId' has a wrong offset!");

// ScriptStruct OrionGame.OrionRewardTypeInfo
// 0x0068 (0x0068 - 0x0000)
struct FOrionRewardTypeInfo
{
public:
	class UTexture2D*                             DisplayIcons[0x3];                                 // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   ShortDescription;                                  // 0x0030(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   FullDescription;                                   // 0x0048(0x0018)(Edit, NativeAccessSpecifierPublic)
	bool                                          bShowTypeInChest;                                  // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionRewardTypeInfo) == 0x000008, "Wrong alignment on FOrionRewardTypeInfo");
static_assert(sizeof(FOrionRewardTypeInfo) == 0x000068, "Wrong size on FOrionRewardTypeInfo");
static_assert(offsetof(FOrionRewardTypeInfo, DisplayIcons) == 0x000000, "Member 'FOrionRewardTypeInfo::DisplayIcons' has a wrong offset!");
static_assert(offsetof(FOrionRewardTypeInfo, DisplayName) == 0x000018, "Member 'FOrionRewardTypeInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(FOrionRewardTypeInfo, ShortDescription) == 0x000030, "Member 'FOrionRewardTypeInfo::ShortDescription' has a wrong offset!");
static_assert(offsetof(FOrionRewardTypeInfo, FullDescription) == 0x000048, "Member 'FOrionRewardTypeInfo::FullDescription' has a wrong offset!");
static_assert(offsetof(FOrionRewardTypeInfo, bShowTypeInChest) == 0x000060, "Member 'FOrionRewardTypeInfo::bShowTypeInChest' has a wrong offset!");

// ScriptStruct OrionGame.OrionItemRewardInfo
// 0x0008 (0x0070 - 0x0068)
struct FOrionItemRewardInfo final : public FOrionRewardTypeInfo
{
public:
	TSubclassOf<class UOrionMcpItemDefinition>    McpItemType;                                       // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionItemRewardInfo) == 0x000008, "Wrong alignment on FOrionItemRewardInfo");
static_assert(sizeof(FOrionItemRewardInfo) == 0x000070, "Wrong size on FOrionItemRewardInfo");
static_assert(offsetof(FOrionItemRewardInfo, McpItemType) == 0x000068, "Member 'FOrionItemRewardInfo::McpItemType' has a wrong offset!");

// ScriptStruct OrionGame.OrionLoreData
// 0x0010 (0x0010 - 0x0000)
struct FOrionLoreData final
{
public:
	TArray<class FText>                           BackgroundBullets;                                 // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionLoreData) == 0x000008, "Wrong alignment on FOrionLoreData");
static_assert(sizeof(FOrionLoreData) == 0x000010, "Wrong size on FOrionLoreData");
static_assert(offsetof(FOrionLoreData, BackgroundBullets) == 0x000000, "Member 'FOrionLoreData::BackgroundBullets' has a wrong offset!");

// ScriptStruct OrionGame.MovementAbilitySyncKey
// 0x000C (0x000C - 0x0000)
struct FMovementAbilitySyncKey final
{
public:
	int16                                         PredictionKey;                                     // 0x0000(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Index;                                             // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClientTimeStamp;                                   // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ServerTimeStamp;                                   // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMovementAbilitySyncKey) == 0x000004, "Wrong alignment on FMovementAbilitySyncKey");
static_assert(sizeof(FMovementAbilitySyncKey) == 0x00000C, "Wrong size on FMovementAbilitySyncKey");
static_assert(offsetof(FMovementAbilitySyncKey, PredictionKey) == 0x000000, "Member 'FMovementAbilitySyncKey::PredictionKey' has a wrong offset!");
static_assert(offsetof(FMovementAbilitySyncKey, Index) == 0x000002, "Member 'FMovementAbilitySyncKey::Index' has a wrong offset!");
static_assert(offsetof(FMovementAbilitySyncKey, ClientTimeStamp) == 0x000004, "Member 'FMovementAbilitySyncKey::ClientTimeStamp' has a wrong offset!");
static_assert(offsetof(FMovementAbilitySyncKey, ServerTimeStamp) == 0x000008, "Member 'FMovementAbilitySyncKey::ServerTimeStamp' has a wrong offset!");

// ScriptStruct OrionGame.OrionPartyRepState
// 0x0010 (0x0020 - 0x0010)
struct FOrionPartyRepState : public FPartyState
{
public:
	class FString                                 SessionId;                                         // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionPartyRepState) == 0x000008, "Wrong alignment on FOrionPartyRepState");
static_assert(sizeof(FOrionPartyRepState) == 0x000020, "Wrong size on FOrionPartyRepState");
static_assert(offsetof(FOrionPartyRepState, SessionId) == 0x000010, "Member 'FOrionPartyRepState::SessionId' has a wrong offset!");

// ScriptStruct OrionGame.GenericGameplayParameterDynamicStruct
// 0x0090 (0x0090 - 0x0000)
struct alignas(0x10) FGenericGameplayParameterDynamicStruct final
{
public:
	class UScriptStruct*                          ScriptStruct;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint8>                                 StructValueData;                                   // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x78];                                      // 0x0018(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGenericGameplayParameterDynamicStruct) == 0x000010, "Wrong alignment on FGenericGameplayParameterDynamicStruct");
static_assert(sizeof(FGenericGameplayParameterDynamicStruct) == 0x000090, "Wrong size on FGenericGameplayParameterDynamicStruct");
static_assert(offsetof(FGenericGameplayParameterDynamicStruct, ScriptStruct) == 0x000000, "Member 'FGenericGameplayParameterDynamicStruct::ScriptStruct' has a wrong offset!");
static_assert(offsetof(FGenericGameplayParameterDynamicStruct, StructValueData) == 0x000008, "Member 'FGenericGameplayParameterDynamicStruct::StructValueData' has a wrong offset!");

// ScriptStruct OrionGame.GenericGameplayParameterDefinition
// 0x00C0 (0x00C0 - 0x0000)
struct FGenericGameplayParameterDefinition
{
public:
	class FName                                   Identifier;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGenericGameplayParameterDynamicStruct DynamicStruct;                                     // 0x0020(0x0090)(Edit, NativeAccessSpecifierPublic)
	bool                                          ExposeByDefault;                                   // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0xF];                                       // 0x00B1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGenericGameplayParameterDefinition) == 0x000010, "Wrong alignment on FGenericGameplayParameterDefinition");
static_assert(sizeof(FGenericGameplayParameterDefinition) == 0x0000C0, "Wrong size on FGenericGameplayParameterDefinition");
static_assert(offsetof(FGenericGameplayParameterDefinition, Identifier) == 0x000000, "Member 'FGenericGameplayParameterDefinition::Identifier' has a wrong offset!");
static_assert(offsetof(FGenericGameplayParameterDefinition, Description) == 0x000008, "Member 'FGenericGameplayParameterDefinition::Description' has a wrong offset!");
static_assert(offsetof(FGenericGameplayParameterDefinition, DynamicStruct) == 0x000020, "Member 'FGenericGameplayParameterDefinition::DynamicStruct' has a wrong offset!");
static_assert(offsetof(FGenericGameplayParameterDefinition, ExposeByDefault) == 0x0000B0, "Member 'FGenericGameplayParameterDefinition::ExposeByDefault' has a wrong offset!");

// ScriptStruct OrionGame.GenericGameplayParameterUserData
// 0x00B0 (0x00B0 - 0x0000)
struct FGenericGameplayParameterUserData final
{
public:
	class FName                                   Identifier;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGGPUserDataOpType                            OpType;                                            // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Expose;                                            // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGenericGameplayParameterDynamicStruct DynamicStruct;                                     // 0x0010(0x0090)(Edit, NativeAccessSpecifierPublic)
	class FName                                   TransformedFromDefIdentifier;                      // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGenericGameplayParameterUserData) == 0x000010, "Wrong alignment on FGenericGameplayParameterUserData");
static_assert(sizeof(FGenericGameplayParameterUserData) == 0x0000B0, "Wrong size on FGenericGameplayParameterUserData");
static_assert(offsetof(FGenericGameplayParameterUserData, Identifier) == 0x000000, "Member 'FGenericGameplayParameterUserData::Identifier' has a wrong offset!");
static_assert(offsetof(FGenericGameplayParameterUserData, OpType) == 0x000008, "Member 'FGenericGameplayParameterUserData::OpType' has a wrong offset!");
static_assert(offsetof(FGenericGameplayParameterUserData, Expose) == 0x000009, "Member 'FGenericGameplayParameterUserData::Expose' has a wrong offset!");
static_assert(offsetof(FGenericGameplayParameterUserData, DynamicStruct) == 0x000010, "Member 'FGenericGameplayParameterUserData::DynamicStruct' has a wrong offset!");
static_assert(offsetof(FGenericGameplayParameterUserData, TransformedFromDefIdentifier) == 0x0000A0, "Member 'FGenericGameplayParameterUserData::TransformedFromDefIdentifier' has a wrong offset!");

// ScriptStruct OrionGame.GenericGameplayParameterBundle
// 0x0130 (0x0130 - 0x0000)
struct alignas(0x10) FGenericGameplayParameterBundle
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGenericGameplayParameterDefinition> GatheredParameterDefinitions;                      // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGenericGameplayParameterDefinition> RequiredParameterDefinitions;                      // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGenericGameplayParameterDefinition> TransformedParameterDefinitions;                   // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGenericGameplayParameterUserData> UserParameterData;                                 // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0xE0];                                      // 0x0050(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGenericGameplayParameterBundle) == 0x000010, "Wrong alignment on FGenericGameplayParameterBundle");
static_assert(sizeof(FGenericGameplayParameterBundle) == 0x000130, "Wrong size on FGenericGameplayParameterBundle");
static_assert(offsetof(FGenericGameplayParameterBundle, GatheredParameterDefinitions) == 0x000010, "Member 'FGenericGameplayParameterBundle::GatheredParameterDefinitions' has a wrong offset!");
static_assert(offsetof(FGenericGameplayParameterBundle, RequiredParameterDefinitions) == 0x000020, "Member 'FGenericGameplayParameterBundle::RequiredParameterDefinitions' has a wrong offset!");
static_assert(offsetof(FGenericGameplayParameterBundle, TransformedParameterDefinitions) == 0x000030, "Member 'FGenericGameplayParameterBundle::TransformedParameterDefinitions' has a wrong offset!");
static_assert(offsetof(FGenericGameplayParameterBundle, UserParameterData) == 0x000040, "Member 'FGenericGameplayParameterBundle::UserParameterData' has a wrong offset!");

// ScriptStruct OrionGame.OrionMockGameItemKeywordTag
// 0x0020 (0x0020 - 0x0000)
struct FOrionMockGameItemKeywordTag final
{
public:
	class FString                                 TagString;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionMockGameItemKeywordTag) == 0x000008, "Wrong alignment on FOrionMockGameItemKeywordTag");
static_assert(sizeof(FOrionMockGameItemKeywordTag) == 0x000020, "Wrong size on FOrionMockGameItemKeywordTag");
static_assert(offsetof(FOrionMockGameItemKeywordTag, TagString) == 0x000000, "Member 'FOrionMockGameItemKeywordTag::TagString' has a wrong offset!");

// ScriptStruct OrionGame.OrionMockGameItemKeywordTagWithData
// 0x0150 (0x0150 - 0x0000)
struct FOrionMockGameItemKeywordTagWithData final
{
public:
	struct FOrionMockGameItemKeywordTag           Keyword;                                           // 0x0000(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGenericGameplayParameterBundle        ParameterBundle;                                   // 0x0020(0x0130)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionMockGameItemKeywordTagWithData) == 0x000010, "Wrong alignment on FOrionMockGameItemKeywordTagWithData");
static_assert(sizeof(FOrionMockGameItemKeywordTagWithData) == 0x000150, "Wrong size on FOrionMockGameItemKeywordTagWithData");
static_assert(offsetof(FOrionMockGameItemKeywordTagWithData, Keyword) == 0x000000, "Member 'FOrionMockGameItemKeywordTagWithData::Keyword' has a wrong offset!");
static_assert(offsetof(FOrionMockGameItemKeywordTagWithData, ParameterBundle) == 0x000020, "Member 'FOrionMockGameItemKeywordTagWithData::ParameterBundle' has a wrong offset!");

// ScriptStruct OrionGame.OrionMockGameItemDefinition
// 0x0270 (0x0270 - 0x0000)
struct FOrionMockGameItemDefinition final
{
public:
	struct FGenericGameplayParameterBundle        AuxiliaryParameterBundle;                          // 0x0000(0x0130)(Edit, NativeAccessSpecifierPublic)
	struct FGenericGameplayParameterBundle        TopLevelParameterBundle;                           // 0x0130(0x0130)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FOrionMockGameItemKeywordTagWithData> MyKeywords;                                        // 0x0260(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionMockGameItemDefinition) == 0x000010, "Wrong alignment on FOrionMockGameItemDefinition");
static_assert(sizeof(FOrionMockGameItemDefinition) == 0x000270, "Wrong size on FOrionMockGameItemDefinition");
static_assert(offsetof(FOrionMockGameItemDefinition, AuxiliaryParameterBundle) == 0x000000, "Member 'FOrionMockGameItemDefinition::AuxiliaryParameterBundle' has a wrong offset!");
static_assert(offsetof(FOrionMockGameItemDefinition, TopLevelParameterBundle) == 0x000130, "Member 'FOrionMockGameItemDefinition::TopLevelParameterBundle' has a wrong offset!");
static_assert(offsetof(FOrionMockGameItemDefinition, MyKeywords) == 0x000260, "Member 'FOrionMockGameItemDefinition::MyKeywords' has a wrong offset!");

// ScriptStruct OrionGame.BannerBulkCommandList
// 0x0010 (0x0010 - 0x0000)
struct FBannerBulkCommandList final
{
public:
	TArray<struct FBannerBulkCommand>             Values;                                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBannerBulkCommandList) == 0x000008, "Wrong alignment on FBannerBulkCommandList");
static_assert(sizeof(FBannerBulkCommandList) == 0x000010, "Wrong size on FBannerBulkCommandList");
static_assert(offsetof(FBannerBulkCommandList, Values) == 0x000000, "Member 'FBannerBulkCommandList::Values' has a wrong offset!");

// ScriptStruct OrionGame.GameplayEventKeywordTag
// 0x0000 (0x0008 - 0x0008)
struct FGameplayEventKeywordTag final : public FGameplayTag
{
};
static_assert(alignof(FGameplayEventKeywordTag) == 0x000008, "Wrong alignment on FGameplayEventKeywordTag");
static_assert(sizeof(FGameplayEventKeywordTag) == 0x000008, "Wrong size on FGameplayEventKeywordTag");

// ScriptStruct OrionGame.GameplayQualifierKeywordTag
// 0x0000 (0x0008 - 0x0008)
struct FGameplayQualifierKeywordTag final : public FGameplayTag
{
};
static_assert(alignof(FGameplayQualifierKeywordTag) == 0x000008, "Wrong alignment on FGameplayQualifierKeywordTag");
static_assert(sizeof(FGameplayQualifierKeywordTag) == 0x000008, "Wrong size on FGameplayQualifierKeywordTag");

// ScriptStruct OrionGame.GameplayQualifierParameters
// 0x0018 (0x0018 - 0x0000)
struct FGameplayQualifierParameters
{
public:
	struct FGameplayQualifierKeywordTag           Qualifier;                                         // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Var1;                                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Var2;                                              // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Var3;                                              // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayQualifierParameters) == 0x000008, "Wrong alignment on FGameplayQualifierParameters");
static_assert(sizeof(FGameplayQualifierParameters) == 0x000018, "Wrong size on FGameplayQualifierParameters");
static_assert(offsetof(FGameplayQualifierParameters, Qualifier) == 0x000000, "Member 'FGameplayQualifierParameters::Qualifier' has a wrong offset!");
static_assert(offsetof(FGameplayQualifierParameters, Var1) == 0x000008, "Member 'FGameplayQualifierParameters::Var1' has a wrong offset!");
static_assert(offsetof(FGameplayQualifierParameters, Var2) == 0x00000C, "Member 'FGameplayQualifierParameters::Var2' has a wrong offset!");
static_assert(offsetof(FGameplayQualifierParameters, Var3) == 0x000010, "Member 'FGameplayQualifierParameters::Var3' has a wrong offset!");

// ScriptStruct OrionGame.GameplayQualifierAggregationWindow
// 0x0008 (0x0008 - 0x0000)
struct FGameplayQualifierAggregationWindow final
{
public:
	EQualifierAggregationType                     Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeSeconds;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayQualifierAggregationWindow) == 0x000004, "Wrong alignment on FGameplayQualifierAggregationWindow");
static_assert(sizeof(FGameplayQualifierAggregationWindow) == 0x000008, "Wrong size on FGameplayQualifierAggregationWindow");
static_assert(offsetof(FGameplayQualifierAggregationWindow, Type) == 0x000000, "Member 'FGameplayQualifierAggregationWindow::Type' has a wrong offset!");
static_assert(offsetof(FGameplayQualifierAggregationWindow, TimeSeconds) == 0x000004, "Member 'FGameplayQualifierAggregationWindow::TimeSeconds' has a wrong offset!");

// ScriptStruct OrionGame.QualifierKeywordsWithContext
// 0x0078 (0x0078 - 0x0000)
struct FQualifierKeywordsWithContext
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayQualifierParameters>   Qualifiers;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayQualifierAggregationWindow    AggregationWindow;                                 // 0x0018(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          AggregationWindowResetsOnPass;                     // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x57];                                      // 0x0021(0x0057)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQualifierKeywordsWithContext) == 0x000008, "Wrong alignment on FQualifierKeywordsWithContext");
static_assert(sizeof(FQualifierKeywordsWithContext) == 0x000078, "Wrong size on FQualifierKeywordsWithContext");
static_assert(offsetof(FQualifierKeywordsWithContext, Qualifiers) == 0x000008, "Member 'FQualifierKeywordsWithContext::Qualifiers' has a wrong offset!");
static_assert(offsetof(FQualifierKeywordsWithContext, AggregationWindow) == 0x000018, "Member 'FQualifierKeywordsWithContext::AggregationWindow' has a wrong offset!");
static_assert(offsetof(FQualifierKeywordsWithContext, AggregationWindowResetsOnPass) == 0x000020, "Member 'FQualifierKeywordsWithContext::AggregationWindowResetsOnPass' has a wrong offset!");

// ScriptStruct OrionGame.EventKeywordWithQualifiers
// 0x0090 (0x0090 - 0x0000)
struct FEventKeywordWithQualifiers final
{
public:
	struct FGameplayEventKeywordTag               EventKeyword;                                      // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQualifierKeywordsWithContext          AdditionalQualifiers;                              // 0x0008(0x0078)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x10];                                      // 0x0080(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEventKeywordWithQualifiers) == 0x000008, "Wrong alignment on FEventKeywordWithQualifiers");
static_assert(sizeof(FEventKeywordWithQualifiers) == 0x000090, "Wrong size on FEventKeywordWithQualifiers");
static_assert(offsetof(FEventKeywordWithQualifiers, EventKeyword) == 0x000000, "Member 'FEventKeywordWithQualifiers::EventKeyword' has a wrong offset!");
static_assert(offsetof(FEventKeywordWithQualifiers, AdditionalQualifiers) == 0x000008, "Member 'FEventKeywordWithQualifiers::AdditionalQualifiers' has a wrong offset!");

// ScriptStruct OrionGame.OrionBaseHUDPlayerInfo
// 0x006F (0x0070 - 0x0001)
struct FOrionBaseHUDPlayerInfo : public FUIUpdateHelperStruct
{
public:
	uint8                                         Pad_1[0xB];                                        // 0x0001(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Health;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthMax;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthRegen;                                       // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Shield;                                            // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldMax;                                         // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Energy;                                            // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnergyMax;                                         // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnergyRegen;                                       // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Kills;                                             // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Deaths;                                            // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Assists;                                           // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Minions;                                           // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CardXP;                                            // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CardMaxXP;                                         // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalXP;                                           // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         XPToNextLevel;                                     // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerLevel;                                       // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCurrentlyDead;                                  // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCritiallyWounded;                               // 0x0051(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x2];                                       // 0x0052(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RespawnTimer;                                      // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CardPointsSpent;                                   // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CardPointsMax;                                     // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumEquippedCards;                                  // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    TeamNum;                                           // 0x0064(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionHeroData*                         HeroData;                                          // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionBaseHUDPlayerInfo) == 0x000008, "Wrong alignment on FOrionBaseHUDPlayerInfo");
static_assert(sizeof(FOrionBaseHUDPlayerInfo) == 0x000070, "Wrong size on FOrionBaseHUDPlayerInfo");
static_assert(offsetof(FOrionBaseHUDPlayerInfo, Health) == 0x00000C, "Member 'FOrionBaseHUDPlayerInfo::Health' has a wrong offset!");
static_assert(offsetof(FOrionBaseHUDPlayerInfo, HealthMax) == 0x000010, "Member 'FOrionBaseHUDPlayerInfo::HealthMax' has a wrong offset!");
static_assert(offsetof(FOrionBaseHUDPlayerInfo, HealthRegen) == 0x000014, "Member 'FOrionBaseHUDPlayerInfo::HealthRegen' has a wrong offset!");
static_assert(offsetof(FOrionBaseHUDPlayerInfo, Shield) == 0x000018, "Member 'FOrionBaseHUDPlayerInfo::Shield' has a wrong offset!");
static_assert(offsetof(FOrionBaseHUDPlayerInfo, ShieldMax) == 0x00001C, "Member 'FOrionBaseHUDPlayerInfo::ShieldMax' has a wrong offset!");
static_assert(offsetof(FOrionBaseHUDPlayerInfo, Energy) == 0x000020, "Member 'FOrionBaseHUDPlayerInfo::Energy' has a wrong offset!");
static_assert(offsetof(FOrionBaseHUDPlayerInfo, EnergyMax) == 0x000024, "Member 'FOrionBaseHUDPlayerInfo::EnergyMax' has a wrong offset!");
static_assert(offsetof(FOrionBaseHUDPlayerInfo, EnergyRegen) == 0x000028, "Member 'FOrionBaseHUDPlayerInfo::EnergyRegen' has a wrong offset!");
static_assert(offsetof(FOrionBaseHUDPlayerInfo, Kills) == 0x00002C, "Member 'FOrionBaseHUDPlayerInfo::Kills' has a wrong offset!");
static_assert(offsetof(FOrionBaseHUDPlayerInfo, Deaths) == 0x000030, "Member 'FOrionBaseHUDPlayerInfo::Deaths' has a wrong offset!");
static_assert(offsetof(FOrionBaseHUDPlayerInfo, Assists) == 0x000034, "Member 'FOrionBaseHUDPlayerInfo::Assists' has a wrong offset!");
static_assert(offsetof(FOrionBaseHUDPlayerInfo, Minions) == 0x000038, "Member 'FOrionBaseHUDPlayerInfo::Minions' has a wrong offset!");
static_assert(offsetof(FOrionBaseHUDPlayerInfo, CardXP) == 0x00003C, "Member 'FOrionBaseHUDPlayerInfo::CardXP' has a wrong offset!");
static_assert(offsetof(FOrionBaseHUDPlayerInfo, CardMaxXP) == 0x000040, "Member 'FOrionBaseHUDPlayerInfo::CardMaxXP' has a wrong offset!");
static_assert(offsetof(FOrionBaseHUDPlayerInfo, TotalXP) == 0x000044, "Member 'FOrionBaseHUDPlayerInfo::TotalXP' has a wrong offset!");
static_assert(offsetof(FOrionBaseHUDPlayerInfo, XPToNextLevel) == 0x000048, "Member 'FOrionBaseHUDPlayerInfo::XPToNextLevel' has a wrong offset!");
static_assert(offsetof(FOrionBaseHUDPlayerInfo, PlayerLevel) == 0x00004C, "Member 'FOrionBaseHUDPlayerInfo::PlayerLevel' has a wrong offset!");
static_assert(offsetof(FOrionBaseHUDPlayerInfo, bIsCurrentlyDead) == 0x000050, "Member 'FOrionBaseHUDPlayerInfo::bIsCurrentlyDead' has a wrong offset!");
static_assert(offsetof(FOrionBaseHUDPlayerInfo, bIsCritiallyWounded) == 0x000051, "Member 'FOrionBaseHUDPlayerInfo::bIsCritiallyWounded' has a wrong offset!");
static_assert(offsetof(FOrionBaseHUDPlayerInfo, RespawnTimer) == 0x000054, "Member 'FOrionBaseHUDPlayerInfo::RespawnTimer' has a wrong offset!");
static_assert(offsetof(FOrionBaseHUDPlayerInfo, CardPointsSpent) == 0x000058, "Member 'FOrionBaseHUDPlayerInfo::CardPointsSpent' has a wrong offset!");
static_assert(offsetof(FOrionBaseHUDPlayerInfo, CardPointsMax) == 0x00005C, "Member 'FOrionBaseHUDPlayerInfo::CardPointsMax' has a wrong offset!");
static_assert(offsetof(FOrionBaseHUDPlayerInfo, NumEquippedCards) == 0x000060, "Member 'FOrionBaseHUDPlayerInfo::NumEquippedCards' has a wrong offset!");
static_assert(offsetof(FOrionBaseHUDPlayerInfo, TeamNum) == 0x000064, "Member 'FOrionBaseHUDPlayerInfo::TeamNum' has a wrong offset!");
static_assert(offsetof(FOrionBaseHUDPlayerInfo, HeroData) == 0x000068, "Member 'FOrionBaseHUDPlayerInfo::HeroData' has a wrong offset!");

// ScriptStruct OrionGame.OrionNotification
// 0x0180 (0x0180 - 0x0000)
struct alignas(0x10) FOrionNotification final
{
public:
	class FText                                   TitleText;                                         // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   BodyText;                                          // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateBrush                            Icon;                                              // 0x0030(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ENotificationType                             Type;                                              // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           ButtonText;                                        // 0x00B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   Identifier;                                        // 0x00C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              Time;                                              // 0x00C8(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D0[0x60];                                      // 0x00D0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  UniqueId;                                          // 0x0130(0x0010)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_140[0x40];                                     // 0x0140(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionNotification) == 0x000010, "Wrong alignment on FOrionNotification");
static_assert(sizeof(FOrionNotification) == 0x000180, "Wrong size on FOrionNotification");
static_assert(offsetof(FOrionNotification, TitleText) == 0x000000, "Member 'FOrionNotification::TitleText' has a wrong offset!");
static_assert(offsetof(FOrionNotification, BodyText) == 0x000018, "Member 'FOrionNotification::BodyText' has a wrong offset!");
static_assert(offsetof(FOrionNotification, Icon) == 0x000030, "Member 'FOrionNotification::Icon' has a wrong offset!");
static_assert(offsetof(FOrionNotification, Type) == 0x0000A8, "Member 'FOrionNotification::Type' has a wrong offset!");
static_assert(offsetof(FOrionNotification, ButtonText) == 0x0000B0, "Member 'FOrionNotification::ButtonText' has a wrong offset!");
static_assert(offsetof(FOrionNotification, Identifier) == 0x0000C0, "Member 'FOrionNotification::Identifier' has a wrong offset!");
static_assert(offsetof(FOrionNotification, Time) == 0x0000C8, "Member 'FOrionNotification::Time' has a wrong offset!");
static_assert(offsetof(FOrionNotification, UniqueId) == 0x000130, "Member 'FOrionNotification::UniqueId' has a wrong offset!");

// ScriptStruct OrionGame.OrionObjectLibraryEntry
// 0x0020 (0x0020 - 0x0000)
struct FOrionObjectLibraryEntry final
{
public:
	class UObjectLibrary*                         Library;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionItemType                                ItemType;                                          // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         LoadedPaths;                                       // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionObjectLibraryEntry) == 0x000008, "Wrong alignment on FOrionObjectLibraryEntry");
static_assert(sizeof(FOrionObjectLibraryEntry) == 0x000020, "Wrong size on FOrionObjectLibraryEntry");
static_assert(offsetof(FOrionObjectLibraryEntry, Library) == 0x000000, "Member 'FOrionObjectLibraryEntry::Library' has a wrong offset!");
static_assert(offsetof(FOrionObjectLibraryEntry, ItemType) == 0x000008, "Member 'FOrionObjectLibraryEntry::ItemType' has a wrong offset!");
static_assert(offsetof(FOrionObjectLibraryEntry, LoadedPaths) == 0x000010, "Member 'FOrionObjectLibraryEntry::LoadedPaths' has a wrong offset!");

// ScriptStruct OrionGame.TeamOwnershipXPBonus
// 0x0010 (0x0010 - 0x0000)
struct FTeamOwnershipXPBonus final
{
public:
	TArray<struct FTeamOwnershipXPBonusEntry>     Contributions;                                     // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTeamOwnershipXPBonus) == 0x000008, "Wrong alignment on FTeamOwnershipXPBonus");
static_assert(sizeof(FTeamOwnershipXPBonus) == 0x000010, "Wrong size on FTeamOwnershipXPBonus");
static_assert(offsetof(FTeamOwnershipXPBonus, Contributions) == 0x000000, "Member 'FTeamOwnershipXPBonus::Contributions' has a wrong offset!");

// ScriptStruct OrionGame.TeamElo
// 0x0008 (0x0008 - 0x0000)
struct FTeamElo final
{
public:
	int32                                         Rating;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewPlayerAdjusted;                                // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTeamElo) == 0x000004, "Wrong alignment on FTeamElo");
static_assert(sizeof(FTeamElo) == 0x000008, "Wrong size on FTeamElo");
static_assert(offsetof(FTeamElo, Rating) == 0x000000, "Member 'FTeamElo::Rating' has a wrong offset!");
static_assert(offsetof(FTeamElo, bNewPlayerAdjusted) == 0x000004, "Member 'FTeamElo::bNewPlayerAdjusted' has a wrong offset!");

// ScriptStruct OrionGame.MCPPlayerStats
// 0x0018 (0x0018 - 0x0000)
struct FMCPPlayerStats final
{
public:
	class FString                                 StatName;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMCPPlayerStats) == 0x000008, "Wrong alignment on FMCPPlayerStats");
static_assert(sizeof(FMCPPlayerStats) == 0x000018, "Wrong size on FMCPPlayerStats");
static_assert(offsetof(FMCPPlayerStats, StatName) == 0x000000, "Member 'FMCPPlayerStats::StatName' has a wrong offset!");
static_assert(offsetof(FMCPPlayerStats, Value) == 0x000010, "Member 'FMCPPlayerStats::Value' has a wrong offset!");

// ScriptStruct OrionGame.GameplayStats
// 0x0108 (0x0108 - 0x0000)
struct FGameplayStats final
{
public:
	uint8                                         Pad_0[0xF0];                                       // 0x0000(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMCPPlayerStats>                TrackedStats;                                      // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class AOrionPlayerState_Game*                 Owner;                                             // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGameplayStats) == 0x000008, "Wrong alignment on FGameplayStats");
static_assert(sizeof(FGameplayStats) == 0x000108, "Wrong size on FGameplayStats");
static_assert(offsetof(FGameplayStats, TrackedStats) == 0x0000F0, "Member 'FGameplayStats::TrackedStats' has a wrong offset!");
static_assert(offsetof(FGameplayStats, Owner) == 0x000100, "Member 'FGameplayStats::Owner' has a wrong offset!");

// ScriptStruct OrionGame.OrionCharDeathData
// 0x0018 (0x0018 - 0x0000)
struct FOrionCharDeathData final
{
public:
	class AActor*                                 KilledBy;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              DamageNormal;                                      // 0x0008(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         DamageMagnitude;                                   // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionCharDeathData) == 0x000008, "Wrong alignment on FOrionCharDeathData");
static_assert(sizeof(FOrionCharDeathData) == 0x000018, "Wrong size on FOrionCharDeathData");
static_assert(offsetof(FOrionCharDeathData, KilledBy) == 0x000000, "Member 'FOrionCharDeathData::KilledBy' has a wrong offset!");
static_assert(offsetof(FOrionCharDeathData, DamageNormal) == 0x000008, "Member 'FOrionCharDeathData::DamageNormal' has a wrong offset!");
static_assert(offsetof(FOrionCharDeathData, DamageMagnitude) == 0x000014, "Member 'FOrionCharDeathData::DamageMagnitude' has a wrong offset!");

// ScriptStruct OrionGame.OrionAIGAGameTeamResult
// 0x0020 (0x0020 - 0x0000)
struct FOrionAIGAGameTeamResult final
{
public:
	int32                                         PlacedWards;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CardPoints;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InhibKills;                                        // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Genome;                                            // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionAIGAGameTeamResult) == 0x000008, "Wrong alignment on FOrionAIGAGameTeamResult");
static_assert(sizeof(FOrionAIGAGameTeamResult) == 0x000020, "Wrong size on FOrionAIGAGameTeamResult");
static_assert(offsetof(FOrionAIGAGameTeamResult, PlacedWards) == 0x000000, "Member 'FOrionAIGAGameTeamResult::PlacedWards' has a wrong offset!");
static_assert(offsetof(FOrionAIGAGameTeamResult, CardPoints) == 0x000004, "Member 'FOrionAIGAGameTeamResult::CardPoints' has a wrong offset!");
static_assert(offsetof(FOrionAIGAGameTeamResult, InhibKills) == 0x000008, "Member 'FOrionAIGAGameTeamResult::InhibKills' has a wrong offset!");
static_assert(offsetof(FOrionAIGAGameTeamResult, Genome) == 0x000010, "Member 'FOrionAIGAGameTeamResult::Genome' has a wrong offset!");

// ScriptStruct OrionGame.OrionAIGAGameResult
// 0x0048 (0x0048 - 0x0000)
struct FOrionAIGAGameResult final
{
public:
	int32                                         MatchTime;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionAIGAGameTeamResult               Winner;                                            // 0x0008(0x0020)(NativeAccessSpecifierPublic)
	struct FOrionAIGAGameTeamResult               Loser;                                             // 0x0028(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionAIGAGameResult) == 0x000008, "Wrong alignment on FOrionAIGAGameResult");
static_assert(sizeof(FOrionAIGAGameResult) == 0x000048, "Wrong size on FOrionAIGAGameResult");
static_assert(offsetof(FOrionAIGAGameResult, MatchTime) == 0x000000, "Member 'FOrionAIGAGameResult::MatchTime' has a wrong offset!");
static_assert(offsetof(FOrionAIGAGameResult, Winner) == 0x000008, "Member 'FOrionAIGAGameResult::Winner' has a wrong offset!");
static_assert(offsetof(FOrionAIGAGameResult, Loser) == 0x000028, "Member 'FOrionAIGAGameResult::Loser' has a wrong offset!");

// ScriptStruct OrionGame.ItemIdList
// 0x0010 (0x0010 - 0x0000)
struct FItemIdList final
{
public:
	TArray<class FString>                         Values;                                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemIdList) == 0x000008, "Wrong alignment on FItemIdList");
static_assert(sizeof(FItemIdList) == 0x000010, "Wrong size on FItemIdList");
static_assert(offsetof(FItemIdList, Values) == 0x000000, "Member 'FItemIdList::Values' has a wrong offset!");

// ScriptStruct OrionGame.HeroDamageLogEntry
// 0x0060 (0x0060 - 0x0000)
struct FHeroDamageLogEntry final
{
public:
	class UOrionMcpItemDefinition*                InstigatorData;                                    // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionPlayerState_Base*                 InstigatorPlayer;                                  // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionCharAI*                           InstigatorAICharacter;                             // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionDamageableObjective_Base*         InstigatorObjective;                               // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            GameplayEffect;                                    // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionAbility*                          InstigatorAbility;                                 // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  SourceTags;                                        // 0x0030(0x0020)(RepSkip, NativeAccessSpecifierPublic)
	float                                         DamageTime;                                        // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageAmount;                                      // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumDamageEvents;                                   // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PackedFlags;                                       // 0x005C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHeroDamageLogEntry) == 0x000008, "Wrong alignment on FHeroDamageLogEntry");
static_assert(sizeof(FHeroDamageLogEntry) == 0x000060, "Wrong size on FHeroDamageLogEntry");
static_assert(offsetof(FHeroDamageLogEntry, InstigatorData) == 0x000000, "Member 'FHeroDamageLogEntry::InstigatorData' has a wrong offset!");
static_assert(offsetof(FHeroDamageLogEntry, InstigatorPlayer) == 0x000008, "Member 'FHeroDamageLogEntry::InstigatorPlayer' has a wrong offset!");
static_assert(offsetof(FHeroDamageLogEntry, InstigatorAICharacter) == 0x000010, "Member 'FHeroDamageLogEntry::InstigatorAICharacter' has a wrong offset!");
static_assert(offsetof(FHeroDamageLogEntry, InstigatorObjective) == 0x000018, "Member 'FHeroDamageLogEntry::InstigatorObjective' has a wrong offset!");
static_assert(offsetof(FHeroDamageLogEntry, GameplayEffect) == 0x000020, "Member 'FHeroDamageLogEntry::GameplayEffect' has a wrong offset!");
static_assert(offsetof(FHeroDamageLogEntry, InstigatorAbility) == 0x000028, "Member 'FHeroDamageLogEntry::InstigatorAbility' has a wrong offset!");
static_assert(offsetof(FHeroDamageLogEntry, SourceTags) == 0x000030, "Member 'FHeroDamageLogEntry::SourceTags' has a wrong offset!");
static_assert(offsetof(FHeroDamageLogEntry, DamageTime) == 0x000050, "Member 'FHeroDamageLogEntry::DamageTime' has a wrong offset!");
static_assert(offsetof(FHeroDamageLogEntry, DamageAmount) == 0x000054, "Member 'FHeroDamageLogEntry::DamageAmount' has a wrong offset!");
static_assert(offsetof(FHeroDamageLogEntry, NumDamageEvents) == 0x000058, "Member 'FHeroDamageLogEntry::NumDamageEvents' has a wrong offset!");
static_assert(offsetof(FHeroDamageLogEntry, PackedFlags) == 0x00005C, "Member 'FHeroDamageLogEntry::PackedFlags' has a wrong offset!");

// ScriptStruct OrionGame.ActiveBannerStruct
// 0x0010 (0x0010 - 0x0000)
struct FActiveBannerStruct final
{
public:
	class FString                                 bannerId;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActiveBannerStruct) == 0x000008, "Wrong alignment on FActiveBannerStruct");
static_assert(sizeof(FActiveBannerStruct) == 0x000010, "Wrong size on FActiveBannerStruct");
static_assert(offsetof(FActiveBannerStruct, bannerId) == 0x000000, "Member 'FActiveBannerStruct::bannerId' has a wrong offset!");

// ScriptStruct OrionGame.GameplayCueForceFeedbackInfo
// 0x0018 (0x0018 - 0x0000)
struct FGameplayCueForceFeedbackInfo final
{
public:
	class UForceFeedbackEffect*                   ForceFeedbackEffect;                               // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLooping;                                          // 0x0008(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0xF];                                        // 0x0009(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayCueForceFeedbackInfo) == 0x000008, "Wrong alignment on FGameplayCueForceFeedbackInfo");
static_assert(sizeof(FGameplayCueForceFeedbackInfo) == 0x000018, "Wrong size on FGameplayCueForceFeedbackInfo");
static_assert(offsetof(FGameplayCueForceFeedbackInfo, ForceFeedbackEffect) == 0x000000, "Member 'FGameplayCueForceFeedbackInfo::ForceFeedbackEffect' has a wrong offset!");
static_assert(offsetof(FGameplayCueForceFeedbackInfo, bLooping) == 0x000008, "Member 'FGameplayCueForceFeedbackInfo::bLooping' has a wrong offset!");

// ScriptStruct OrionGame.OrientationWarpingSpineBoneSettings
// 0x0018 (0x0018 - 0x0000)
struct FOrientationWarpingSpineBoneSettings final
{
public:
	struct FBoneReference                         Bone;                                              // 0x0000(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrientationWarpingSpineBoneSettings) == 0x000008, "Wrong alignment on FOrientationWarpingSpineBoneSettings");
static_assert(sizeof(FOrientationWarpingSpineBoneSettings) == 0x000018, "Wrong size on FOrientationWarpingSpineBoneSettings");
static_assert(offsetof(FOrientationWarpingSpineBoneSettings, Bone) == 0x000000, "Member 'FOrientationWarpingSpineBoneSettings::Bone' has a wrong offset!");

// ScriptStruct OrionGame.StatTranslationData
// 0x0028 (0x0030 - 0x0008)
struct FStatTranslationData final : public FTableRowBase
{
public:
	class FName                                   StatName;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionQuestVerbType                           Verb;                                              // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LegacyName;                                        // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAccountPVP;                                       // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAccountTotal;                                     // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHeroPVP;                                          // 0x002A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHeroTotal;                                        // 0x002B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCommunity;                                        // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClientLegal;                                      // 0x002D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatTranslationData) == 0x000008, "Wrong alignment on FStatTranslationData");
static_assert(sizeof(FStatTranslationData) == 0x000030, "Wrong size on FStatTranslationData");
static_assert(offsetof(FStatTranslationData, StatName) == 0x000008, "Member 'FStatTranslationData::StatName' has a wrong offset!");
static_assert(offsetof(FStatTranslationData, Verb) == 0x000010, "Member 'FStatTranslationData::Verb' has a wrong offset!");
static_assert(offsetof(FStatTranslationData, LegacyName) == 0x000018, "Member 'FStatTranslationData::LegacyName' has a wrong offset!");
static_assert(offsetof(FStatTranslationData, bAccountPVP) == 0x000028, "Member 'FStatTranslationData::bAccountPVP' has a wrong offset!");
static_assert(offsetof(FStatTranslationData, bAccountTotal) == 0x000029, "Member 'FStatTranslationData::bAccountTotal' has a wrong offset!");
static_assert(offsetof(FStatTranslationData, bHeroPVP) == 0x00002A, "Member 'FStatTranslationData::bHeroPVP' has a wrong offset!");
static_assert(offsetof(FStatTranslationData, bHeroTotal) == 0x00002B, "Member 'FStatTranslationData::bHeroTotal' has a wrong offset!");
static_assert(offsetof(FStatTranslationData, bCommunity) == 0x00002C, "Member 'FStatTranslationData::bCommunity' has a wrong offset!");
static_assert(offsetof(FStatTranslationData, bClientLegal) == 0x00002D, "Member 'FStatTranslationData::bClientLegal' has a wrong offset!");

// ScriptStruct OrionGame.SimpleAchievementStatus
// 0x0008 (0x0008 - 0x0000)
struct FSimpleAchievementStatus final
{
public:
	EOrionSimpleAchievementType                   Key;                                               // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Count;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSimpleAchievementStatus) == 0x000004, "Wrong alignment on FSimpleAchievementStatus");
static_assert(sizeof(FSimpleAchievementStatus) == 0x000008, "Wrong size on FSimpleAchievementStatus");
static_assert(offsetof(FSimpleAchievementStatus, Key) == 0x000000, "Member 'FSimpleAchievementStatus::Key' has a wrong offset!");
static_assert(offsetof(FSimpleAchievementStatus, Count) == 0x000004, "Member 'FSimpleAchievementStatus::Count' has a wrong offset!");

// ScriptStruct OrionGame.SimpleAchievements
// 0x0010 (0x0010 - 0x0000)
struct FSimpleAchievements final
{
public:
	TArray<struct FSimpleAchievementStatus>       Status;                                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSimpleAchievements) == 0x000008, "Wrong alignment on FSimpleAchievements");
static_assert(sizeof(FSimpleAchievements) == 0x000010, "Wrong size on FSimpleAchievements");
static_assert(offsetof(FSimpleAchievements, Status) == 0x000000, "Member 'FSimpleAchievements::Status' has a wrong offset!");

// ScriptStruct OrionGame.OrionFeaturedHero
// 0x0070 (0x0070 - 0x0000)
struct FOrionFeaturedHero final
{
public:
	class FString                                 Hero;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Skin;                                              // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SkinVariation;                                     // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionFeaturedHeroType                        Type;                                              // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BundleTag;                                         // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EventID;                                           // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionFeaturedHeroAction                      Action;                                            // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StartTime;                                         // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionFeaturedHero) == 0x000008, "Wrong alignment on FOrionFeaturedHero");
static_assert(sizeof(FOrionFeaturedHero) == 0x000070, "Wrong size on FOrionFeaturedHero");
static_assert(offsetof(FOrionFeaturedHero, Hero) == 0x000000, "Member 'FOrionFeaturedHero::Hero' has a wrong offset!");
static_assert(offsetof(FOrionFeaturedHero, Skin) == 0x000010, "Member 'FOrionFeaturedHero::Skin' has a wrong offset!");
static_assert(offsetof(FOrionFeaturedHero, SkinVariation) == 0x000020, "Member 'FOrionFeaturedHero::SkinVariation' has a wrong offset!");
static_assert(offsetof(FOrionFeaturedHero, Type) == 0x000030, "Member 'FOrionFeaturedHero::Type' has a wrong offset!");
static_assert(offsetof(FOrionFeaturedHero, BundleTag) == 0x000038, "Member 'FOrionFeaturedHero::BundleTag' has a wrong offset!");
static_assert(offsetof(FOrionFeaturedHero, EventID) == 0x000048, "Member 'FOrionFeaturedHero::EventID' has a wrong offset!");
static_assert(offsetof(FOrionFeaturedHero, Action) == 0x000058, "Member 'FOrionFeaturedHero::Action' has a wrong offset!");
static_assert(offsetof(FOrionFeaturedHero, StartTime) == 0x000060, "Member 'FOrionFeaturedHero::StartTime' has a wrong offset!");

// ScriptStruct OrionGame.OrionSentryTurretAnimInstanceProxy
// 0x0030 (0x0510 - 0x04E0)
struct FOrionSentryTurretAnimInstanceProxy final : public FAnimInstanceProxy
{
public:
	struct FVector                                PivotLocation;                                     // 0x04D8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LookAtDirection;                                   // 0x04E4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LookAtPoint;                                       // 0x04F0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceToTarget;                                  // 0x04FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimingCurveValue;                                  // 0x0500(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAimingCurveRelevant;                            // 0x0504(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_505[0xB];                                      // 0x0505(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionSentryTurretAnimInstanceProxy) == 0x000010, "Wrong alignment on FOrionSentryTurretAnimInstanceProxy");
static_assert(sizeof(FOrionSentryTurretAnimInstanceProxy) == 0x000510, "Wrong size on FOrionSentryTurretAnimInstanceProxy");
static_assert(offsetof(FOrionSentryTurretAnimInstanceProxy, PivotLocation) == 0x0004D8, "Member 'FOrionSentryTurretAnimInstanceProxy::PivotLocation' has a wrong offset!");
static_assert(offsetof(FOrionSentryTurretAnimInstanceProxy, LookAtDirection) == 0x0004E4, "Member 'FOrionSentryTurretAnimInstanceProxy::LookAtDirection' has a wrong offset!");
static_assert(offsetof(FOrionSentryTurretAnimInstanceProxy, LookAtPoint) == 0x0004F0, "Member 'FOrionSentryTurretAnimInstanceProxy::LookAtPoint' has a wrong offset!");
static_assert(offsetof(FOrionSentryTurretAnimInstanceProxy, DistanceToTarget) == 0x0004FC, "Member 'FOrionSentryTurretAnimInstanceProxy::DistanceToTarget' has a wrong offset!");
static_assert(offsetof(FOrionSentryTurretAnimInstanceProxy, AimingCurveValue) == 0x000500, "Member 'FOrionSentryTurretAnimInstanceProxy::AimingCurveValue' has a wrong offset!");
static_assert(offsetof(FOrionSentryTurretAnimInstanceProxy, bIsAimingCurveRelevant) == 0x000504, "Member 'FOrionSentryTurretAnimInstanceProxy::bIsAimingCurveRelevant' has a wrong offset!");

// ScriptStruct OrionGame.OrionHeroDataSpec
// 0x00A8 (0x00A8 - 0x0000)
struct FOrionHeroDataSpec final
{
public:
	class UOrionHeroData*                         HeroData;                                          // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionSkinItemDefinition*               Skin;                                              // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionSkinVariationItemDefinition*      SkinVariation;                                     // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionMcpCrownItemDefinition*           Crown;                                             // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UOrionMcpItemDefinition*>        BannerSpecList;                                    // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FBannerSpec                            BannerSpec;                                        // 0x0030(0x0068)(BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class UOrionEmoteItemDefinition*>      Emotes;                                            // 0x0098(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionHeroDataSpec) == 0x000008, "Wrong alignment on FOrionHeroDataSpec");
static_assert(sizeof(FOrionHeroDataSpec) == 0x0000A8, "Wrong size on FOrionHeroDataSpec");
static_assert(offsetof(FOrionHeroDataSpec, HeroData) == 0x000000, "Member 'FOrionHeroDataSpec::HeroData' has a wrong offset!");
static_assert(offsetof(FOrionHeroDataSpec, Skin) == 0x000008, "Member 'FOrionHeroDataSpec::Skin' has a wrong offset!");
static_assert(offsetof(FOrionHeroDataSpec, SkinVariation) == 0x000010, "Member 'FOrionHeroDataSpec::SkinVariation' has a wrong offset!");
static_assert(offsetof(FOrionHeroDataSpec, Crown) == 0x000018, "Member 'FOrionHeroDataSpec::Crown' has a wrong offset!");
static_assert(offsetof(FOrionHeroDataSpec, BannerSpecList) == 0x000020, "Member 'FOrionHeroDataSpec::BannerSpecList' has a wrong offset!");
static_assert(offsetof(FOrionHeroDataSpec, BannerSpec) == 0x000030, "Member 'FOrionHeroDataSpec::BannerSpec' has a wrong offset!");
static_assert(offsetof(FOrionHeroDataSpec, Emotes) == 0x000098, "Member 'FOrionHeroDataSpec::Emotes' has a wrong offset!");

// ScriptStruct OrionGame.OrionAuxiliaryTagTable
// 0x0028 (0x0028 - 0x0000)
struct FOrionAuxiliaryTagTable final
{
public:
	TSoftObjectPtr<class UDataTable>              AuxiliaryTable;                                    // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionAuxiliaryTagTable) == 0x000008, "Wrong alignment on FOrionAuxiliaryTagTable");
static_assert(sizeof(FOrionAuxiliaryTagTable) == 0x000028, "Wrong size on FOrionAuxiliaryTagTable");
static_assert(offsetof(FOrionAuxiliaryTagTable, AuxiliaryTable) == 0x000000, "Member 'FOrionAuxiliaryTagTable::AuxiliaryTable' has a wrong offset!");

// ScriptStruct OrionGame.OrionTagTableMergeSet
// 0x0040 (0x0040 - 0x0000)
struct FOrionTagTableMergeSet final
{
public:
	TSoftObjectPtr<class UDataTable>              MasterTable;                                       // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             MasterBackup;                                      // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOrionAuxiliaryTagTable>        AuxiliaryTables;                                   // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionTagTableMergeSet) == 0x000008, "Wrong alignment on FOrionTagTableMergeSet");
static_assert(sizeof(FOrionTagTableMergeSet) == 0x000040, "Wrong size on FOrionTagTableMergeSet");
static_assert(offsetof(FOrionTagTableMergeSet, MasterTable) == 0x000000, "Member 'FOrionTagTableMergeSet::MasterTable' has a wrong offset!");
static_assert(offsetof(FOrionTagTableMergeSet, MasterBackup) == 0x000028, "Member 'FOrionTagTableMergeSet::MasterBackup' has a wrong offset!");
static_assert(offsetof(FOrionTagTableMergeSet, AuxiliaryTables) == 0x000030, "Member 'FOrionTagTableMergeSet::AuxiliaryTables' has a wrong offset!");

// ScriptStruct OrionGame.OrionGenericAITest
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FOrionGenericAITest final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionGenericAITest) == 0x000008, "Wrong alignment on FOrionGenericAITest");
static_assert(sizeof(FOrionGenericAITest) == 0x000010, "Wrong size on FOrionGenericAITest");

// ScriptStruct OrionGame.SpecificHeroInfo
// 0x0040 (0x0040 - 0x0000)
struct FSpecificHeroInfo final
{
public:
	TSoftObjectPtr<class UOrionHeroData>          HeroDataWeakRef;                                   // 0x0000(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UOrionAbilitySet>> OverrideAbilitiesWeakRef;                          // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	EOrionTeam                                    TeamNum;                                           // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpecificHeroInfo) == 0x000008, "Wrong alignment on FSpecificHeroInfo");
static_assert(sizeof(FSpecificHeroInfo) == 0x000040, "Wrong size on FSpecificHeroInfo");
static_assert(offsetof(FSpecificHeroInfo, HeroDataWeakRef) == 0x000000, "Member 'FSpecificHeroInfo::HeroDataWeakRef' has a wrong offset!");
static_assert(offsetof(FSpecificHeroInfo, OverrideAbilitiesWeakRef) == 0x000028, "Member 'FSpecificHeroInfo::OverrideAbilitiesWeakRef' has a wrong offset!");
static_assert(offsetof(FSpecificHeroInfo, TeamNum) == 0x000038, "Member 'FSpecificHeroInfo::TeamNum' has a wrong offset!");

// ScriptStruct OrionGame.OrionDailyRewardInfo
// 0x0028 (0x0028 - 0x0000)
struct FOrionDailyRewardInfo final
{
public:
	int32                                         DaysUntilAvailable;                                // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDailyRewardType                              RewardType;                                        // 0x0004(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RewardName;                                        // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionMcpItemDefinition*                ItemDefinition;                                    // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionDailyRewardInfo) == 0x000008, "Wrong alignment on FOrionDailyRewardInfo");
static_assert(sizeof(FOrionDailyRewardInfo) == 0x000028, "Wrong size on FOrionDailyRewardInfo");
static_assert(offsetof(FOrionDailyRewardInfo, DaysUntilAvailable) == 0x000000, "Member 'FOrionDailyRewardInfo::DaysUntilAvailable' has a wrong offset!");
static_assert(offsetof(FOrionDailyRewardInfo, RewardType) == 0x000004, "Member 'FOrionDailyRewardInfo::RewardType' has a wrong offset!");
static_assert(offsetof(FOrionDailyRewardInfo, RewardName) == 0x000008, "Member 'FOrionDailyRewardInfo::RewardName' has a wrong offset!");
static_assert(offsetof(FOrionDailyRewardInfo, Quantity) == 0x000018, "Member 'FOrionDailyRewardInfo::Quantity' has a wrong offset!");
static_assert(offsetof(FOrionDailyRewardInfo, ItemDefinition) == 0x000020, "Member 'FOrionDailyRewardInfo::ItemDefinition' has a wrong offset!");

// ScriptStruct OrionGame.OrionShapeDimension
// 0x0038 (0x0038 - 0x0000)
struct FOrionShapeDimension final
{
public:
	EOrionShapeDimensionType                      Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         ScalableFloatValue;                                // 0x0008(0x0028)(Edit, NativeAccessSpecifierPublic)
	TSubclassOf<class AOrionProjectile>           ProjectileValue;                                   // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionShapeDimension) == 0x000008, "Wrong alignment on FOrionShapeDimension");
static_assert(sizeof(FOrionShapeDimension) == 0x000038, "Wrong size on FOrionShapeDimension");
static_assert(offsetof(FOrionShapeDimension, Type) == 0x000000, "Member 'FOrionShapeDimension::Type' has a wrong offset!");
static_assert(offsetof(FOrionShapeDimension, ScalableFloatValue) == 0x000008, "Member 'FOrionShapeDimension::ScalableFloatValue' has a wrong offset!");
static_assert(offsetof(FOrionShapeDimension, ProjectileValue) == 0x000030, "Member 'FOrionShapeDimension::ProjectileValue' has a wrong offset!");

// ScriptStruct OrionGame.OrionShapeFacetDefinition
// 0x0310 (0x0310 - 0x0000)
struct FOrionShapeFacetDefinition final
{
public:
	EOrionShapeFacetType                          Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         AngleHorizontalDegrees;                            // 0x0008(0x0028)(NativeAccessSpecifierPublic)
	struct FOrionShapeDimension                   AngleHorizontalDegreesDim;                         // 0x0030(0x0038)(Edit, NativeAccessSpecifierPublic)
	struct FScalableFloat                         RadiusMin;                                         // 0x0068(0x0028)(NativeAccessSpecifierPublic)
	struct FOrionShapeDimension                   RadiusMinDim;                                      // 0x0090(0x0038)(Edit, NativeAccessSpecifierPublic)
	struct FScalableFloat                         RadiusMax;                                         // 0x00C8(0x0028)(NativeAccessSpecifierPublic)
	struct FOrionShapeDimension                   RadiusMaxDim;                                      // 0x00F0(0x0038)(Edit, NativeAccessSpecifierPublic)
	struct FScalableFloat                         Width;                                             // 0x0128(0x0028)(NativeAccessSpecifierPublic)
	struct FOrionShapeDimension                   WidthDim;                                          // 0x0150(0x0038)(Edit, NativeAccessSpecifierPublic)
	struct FScalableFloat                         LengthMin;                                         // 0x0188(0x0028)(NativeAccessSpecifierPublic)
	struct FOrionShapeDimension                   LengthMinDim;                                      // 0x01B0(0x0038)(Edit, NativeAccessSpecifierPublic)
	struct FScalableFloat                         LengthMax;                                         // 0x01E8(0x0028)(NativeAccessSpecifierPublic)
	struct FOrionShapeDimension                   LengthMaxDim;                                      // 0x0210(0x0038)(Edit, NativeAccessSpecifierPublic)
	struct FScalableFloat                         HeightMin;                                         // 0x0248(0x0028)(NativeAccessSpecifierPublic)
	struct FOrionShapeDimension                   HeightMinDim;                                      // 0x0270(0x0038)(Edit, NativeAccessSpecifierPublic)
	struct FScalableFloat                         HeightMax;                                         // 0x02A8(0x0028)(NativeAccessSpecifierPublic)
	struct FOrionShapeDimension                   HeightMaxDim;                                      // 0x02D0(0x0038)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionShapeFacetDefinition) == 0x000008, "Wrong alignment on FOrionShapeFacetDefinition");
static_assert(sizeof(FOrionShapeFacetDefinition) == 0x000310, "Wrong size on FOrionShapeFacetDefinition");
static_assert(offsetof(FOrionShapeFacetDefinition, Type) == 0x000000, "Member 'FOrionShapeFacetDefinition::Type' has a wrong offset!");
static_assert(offsetof(FOrionShapeFacetDefinition, AngleHorizontalDegrees) == 0x000008, "Member 'FOrionShapeFacetDefinition::AngleHorizontalDegrees' has a wrong offset!");
static_assert(offsetof(FOrionShapeFacetDefinition, AngleHorizontalDegreesDim) == 0x000030, "Member 'FOrionShapeFacetDefinition::AngleHorizontalDegreesDim' has a wrong offset!");
static_assert(offsetof(FOrionShapeFacetDefinition, RadiusMin) == 0x000068, "Member 'FOrionShapeFacetDefinition::RadiusMin' has a wrong offset!");
static_assert(offsetof(FOrionShapeFacetDefinition, RadiusMinDim) == 0x000090, "Member 'FOrionShapeFacetDefinition::RadiusMinDim' has a wrong offset!");
static_assert(offsetof(FOrionShapeFacetDefinition, RadiusMax) == 0x0000C8, "Member 'FOrionShapeFacetDefinition::RadiusMax' has a wrong offset!");
static_assert(offsetof(FOrionShapeFacetDefinition, RadiusMaxDim) == 0x0000F0, "Member 'FOrionShapeFacetDefinition::RadiusMaxDim' has a wrong offset!");
static_assert(offsetof(FOrionShapeFacetDefinition, Width) == 0x000128, "Member 'FOrionShapeFacetDefinition::Width' has a wrong offset!");
static_assert(offsetof(FOrionShapeFacetDefinition, WidthDim) == 0x000150, "Member 'FOrionShapeFacetDefinition::WidthDim' has a wrong offset!");
static_assert(offsetof(FOrionShapeFacetDefinition, LengthMin) == 0x000188, "Member 'FOrionShapeFacetDefinition::LengthMin' has a wrong offset!");
static_assert(offsetof(FOrionShapeFacetDefinition, LengthMinDim) == 0x0001B0, "Member 'FOrionShapeFacetDefinition::LengthMinDim' has a wrong offset!");
static_assert(offsetof(FOrionShapeFacetDefinition, LengthMax) == 0x0001E8, "Member 'FOrionShapeFacetDefinition::LengthMax' has a wrong offset!");
static_assert(offsetof(FOrionShapeFacetDefinition, LengthMaxDim) == 0x000210, "Member 'FOrionShapeFacetDefinition::LengthMaxDim' has a wrong offset!");
static_assert(offsetof(FOrionShapeFacetDefinition, HeightMin) == 0x000248, "Member 'FOrionShapeFacetDefinition::HeightMin' has a wrong offset!");
static_assert(offsetof(FOrionShapeFacetDefinition, HeightMinDim) == 0x000270, "Member 'FOrionShapeFacetDefinition::HeightMinDim' has a wrong offset!");
static_assert(offsetof(FOrionShapeFacetDefinition, HeightMax) == 0x0002A8, "Member 'FOrionShapeFacetDefinition::HeightMax' has a wrong offset!");
static_assert(offsetof(FOrionShapeFacetDefinition, HeightMaxDim) == 0x0002D0, "Member 'FOrionShapeFacetDefinition::HeightMaxDim' has a wrong offset!");

// ScriptStruct OrionGame.OrionShapeDefinition
// 0x0010 (0x0010 - 0x0000)
struct FOrionShapeDefinition final
{
public:
	TArray<struct FOrionShapeFacetDefinition>     Facets;                                            // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionShapeDefinition) == 0x000008, "Wrong alignment on FOrionShapeDefinition");
static_assert(sizeof(FOrionShapeDefinition) == 0x000010, "Wrong size on FOrionShapeDefinition");
static_assert(offsetof(FOrionShapeDefinition, Facets) == 0x000000, "Member 'FOrionShapeDefinition::Facets' has a wrong offset!");

// ScriptStruct OrionGame.OrionCoreInfo
// 0x0027 (0x0028 - 0x0001)
struct FOrionCoreInfo final : public FUIUpdateHelperStruct
{
public:
	EOrionTeam                                    TeamNum;                                           // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Health;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthMax;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticallyWoundedThresholdPCT;                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCriticallyWounded;                                // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Shield;                                            // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldMax;                                         // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCurrentlyDead;                                    // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCurrentlyExposed;                                 // 0x001D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEmptyStruct;                                      // 0x001E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F[0x1];                                       // 0x001F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  CoreActor;                                         // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionCoreInfo) == 0x000004, "Wrong alignment on FOrionCoreInfo");
static_assert(sizeof(FOrionCoreInfo) == 0x000028, "Wrong size on FOrionCoreInfo");
static_assert(offsetof(FOrionCoreInfo, TeamNum) == 0x000001, "Member 'FOrionCoreInfo::TeamNum' has a wrong offset!");
static_assert(offsetof(FOrionCoreInfo, Health) == 0x000004, "Member 'FOrionCoreInfo::Health' has a wrong offset!");
static_assert(offsetof(FOrionCoreInfo, HealthMax) == 0x000008, "Member 'FOrionCoreInfo::HealthMax' has a wrong offset!");
static_assert(offsetof(FOrionCoreInfo, CriticallyWoundedThresholdPCT) == 0x00000C, "Member 'FOrionCoreInfo::CriticallyWoundedThresholdPCT' has a wrong offset!");
static_assert(offsetof(FOrionCoreInfo, bCriticallyWounded) == 0x000010, "Member 'FOrionCoreInfo::bCriticallyWounded' has a wrong offset!");
static_assert(offsetof(FOrionCoreInfo, Shield) == 0x000014, "Member 'FOrionCoreInfo::Shield' has a wrong offset!");
static_assert(offsetof(FOrionCoreInfo, ShieldMax) == 0x000018, "Member 'FOrionCoreInfo::ShieldMax' has a wrong offset!");
static_assert(offsetof(FOrionCoreInfo, bCurrentlyDead) == 0x00001C, "Member 'FOrionCoreInfo::bCurrentlyDead' has a wrong offset!");
static_assert(offsetof(FOrionCoreInfo, bCurrentlyExposed) == 0x00001D, "Member 'FOrionCoreInfo::bCurrentlyExposed' has a wrong offset!");
static_assert(offsetof(FOrionCoreInfo, bEmptyStruct) == 0x00001E, "Member 'FOrionCoreInfo::bEmptyStruct' has a wrong offset!");
static_assert(offsetof(FOrionCoreInfo, CoreActor) == 0x000020, "Member 'FOrionCoreInfo::CoreActor' has a wrong offset!");

// ScriptStruct OrionGame.MinionWaveInfo
// 0x0028 (0x0028 - 0x0000)
struct FMinionWaveInfo final
{
public:
	TArray<class AOrionCharAI*>                   Minions;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x18];                                      // 0x0010(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMinionWaveInfo) == 0x000008, "Wrong alignment on FMinionWaveInfo");
static_assert(sizeof(FMinionWaveInfo) == 0x000028, "Wrong size on FMinionWaveInfo");
static_assert(offsetof(FMinionWaveInfo, Minions) == 0x000000, "Member 'FMinionWaveInfo::Minions' has a wrong offset!");

// ScriptStruct OrionGame.LaneMinionWaves
// 0x0010 (0x0010 - 0x0000)
struct FLaneMinionWaves final
{
public:
	TArray<struct FMinionWaveInfo>                Waves;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLaneMinionWaves) == 0x000008, "Wrong alignment on FLaneMinionWaves");
static_assert(sizeof(FLaneMinionWaves) == 0x000010, "Wrong size on FLaneMinionWaves");
static_assert(offsetof(FLaneMinionWaves, Waves) == 0x000000, "Member 'FLaneMinionWaves::Waves' has a wrong offset!");

// ScriptStruct OrionGame.LaneInfo
// 0x0058 (0x0070 - 0x0018)
struct FLaneInfo final : public FLanePath
{
public:
	struct FLaneMinionWaves                       LaneWaves[0x2];                                    // 0x0018(0x0010)(NativeAccessSpecifierPublic)
	struct FVector                                ActiveTowerLocation[0x2];                          // 0x0038(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x20];                                      // 0x0050(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLaneInfo) == 0x000008, "Wrong alignment on FLaneInfo");
static_assert(sizeof(FLaneInfo) == 0x000070, "Wrong size on FLaneInfo");
static_assert(offsetof(FLaneInfo, LaneWaves) == 0x000018, "Member 'FLaneInfo::LaneWaves' has a wrong offset!");
static_assert(offsetof(FLaneInfo, ActiveTowerLocation) == 0x000038, "Member 'FLaneInfo::ActiveTowerLocation' has a wrong offset!");

// ScriptStruct OrionGame.OrionHUDTeamStatusInfo
// 0x0067 (0x0068 - 0x0001)
struct FOrionHUDTeamStatusInfo final : public FUIUpdateHelperStruct
{
public:
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AOrionPlayerState_Game>  PlayerState;                                       // 0x0004(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             PortraitTexture;                                   // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthPercent;                                     // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnergyPercent;                                     // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RespawnTime;                                       // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCurrentlyDead;                                    // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSelectedForHeal;                                  // 0x0029(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEmptySlot;                                      // 0x002A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x1];                                       // 0x002B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Kills;                                             // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Deaths;                                            // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUltimateReady;                                  // 0x0034(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVisibleToLocalPlayer;                             // 0x0035(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionPlayerStateUIID                  PlayerStateUIID;                                   // 0x0038(0x0028)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EOrionTeam                                    TeamNum;                                           // 0x0060(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionHUDTeamStatusInfo) == 0x000008, "Wrong alignment on FOrionHUDTeamStatusInfo");
static_assert(sizeof(FOrionHUDTeamStatusInfo) == 0x000068, "Wrong size on FOrionHUDTeamStatusInfo");
static_assert(offsetof(FOrionHUDTeamStatusInfo, PlayerState) == 0x000004, "Member 'FOrionHUDTeamStatusInfo::PlayerState' has a wrong offset!");
static_assert(offsetof(FOrionHUDTeamStatusInfo, PortraitTexture) == 0x000010, "Member 'FOrionHUDTeamStatusInfo::PortraitTexture' has a wrong offset!");
static_assert(offsetof(FOrionHUDTeamStatusInfo, HealthPercent) == 0x000018, "Member 'FOrionHUDTeamStatusInfo::HealthPercent' has a wrong offset!");
static_assert(offsetof(FOrionHUDTeamStatusInfo, EnergyPercent) == 0x00001C, "Member 'FOrionHUDTeamStatusInfo::EnergyPercent' has a wrong offset!");
static_assert(offsetof(FOrionHUDTeamStatusInfo, Level) == 0x000020, "Member 'FOrionHUDTeamStatusInfo::Level' has a wrong offset!");
static_assert(offsetof(FOrionHUDTeamStatusInfo, RespawnTime) == 0x000024, "Member 'FOrionHUDTeamStatusInfo::RespawnTime' has a wrong offset!");
static_assert(offsetof(FOrionHUDTeamStatusInfo, bCurrentlyDead) == 0x000028, "Member 'FOrionHUDTeamStatusInfo::bCurrentlyDead' has a wrong offset!");
static_assert(offsetof(FOrionHUDTeamStatusInfo, bSelectedForHeal) == 0x000029, "Member 'FOrionHUDTeamStatusInfo::bSelectedForHeal' has a wrong offset!");
static_assert(offsetof(FOrionHUDTeamStatusInfo, bIsEmptySlot) == 0x00002A, "Member 'FOrionHUDTeamStatusInfo::bIsEmptySlot' has a wrong offset!");
static_assert(offsetof(FOrionHUDTeamStatusInfo, Kills) == 0x00002C, "Member 'FOrionHUDTeamStatusInfo::Kills' has a wrong offset!");
static_assert(offsetof(FOrionHUDTeamStatusInfo, Deaths) == 0x000030, "Member 'FOrionHUDTeamStatusInfo::Deaths' has a wrong offset!");
static_assert(offsetof(FOrionHUDTeamStatusInfo, bIsUltimateReady) == 0x000034, "Member 'FOrionHUDTeamStatusInfo::bIsUltimateReady' has a wrong offset!");
static_assert(offsetof(FOrionHUDTeamStatusInfo, bVisibleToLocalPlayer) == 0x000035, "Member 'FOrionHUDTeamStatusInfo::bVisibleToLocalPlayer' has a wrong offset!");
static_assert(offsetof(FOrionHUDTeamStatusInfo, PlayerStateUIID) == 0x000038, "Member 'FOrionHUDTeamStatusInfo::PlayerStateUIID' has a wrong offset!");
static_assert(offsetof(FOrionHUDTeamStatusInfo, TeamNum) == 0x000060, "Member 'FOrionHUDTeamStatusInfo::TeamNum' has a wrong offset!");

// ScriptStruct OrionGame.OrionTowerTargetingInfo
// 0x004F (0x0050 - 0x0001)
struct FOrionTowerTargetingInfo final : public FUIUpdateHelperStruct
{
public:
	EOrionTowerTargetingType                      TargetingType;                                     // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumberOfTargetedMinions;                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TargetedHeroName;                                  // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   TargetedPlayerName;                                // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             TargetedHeroPortrait;                              // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TowerHealth;                                       // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TowerHealthPercent;                                // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNearTower;                                      // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    TowerTeamNum;                                      // 0x0049(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x2];                                       // 0x004A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RespawnTime;                                       // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionTowerTargetingInfo) == 0x000008, "Wrong alignment on FOrionTowerTargetingInfo");
static_assert(sizeof(FOrionTowerTargetingInfo) == 0x000050, "Wrong size on FOrionTowerTargetingInfo");
static_assert(offsetof(FOrionTowerTargetingInfo, TargetingType) == 0x000001, "Member 'FOrionTowerTargetingInfo::TargetingType' has a wrong offset!");
static_assert(offsetof(FOrionTowerTargetingInfo, NumberOfTargetedMinions) == 0x000004, "Member 'FOrionTowerTargetingInfo::NumberOfTargetedMinions' has a wrong offset!");
static_assert(offsetof(FOrionTowerTargetingInfo, TargetedHeroName) == 0x000008, "Member 'FOrionTowerTargetingInfo::TargetedHeroName' has a wrong offset!");
static_assert(offsetof(FOrionTowerTargetingInfo, TargetedPlayerName) == 0x000020, "Member 'FOrionTowerTargetingInfo::TargetedPlayerName' has a wrong offset!");
static_assert(offsetof(FOrionTowerTargetingInfo, TargetedHeroPortrait) == 0x000038, "Member 'FOrionTowerTargetingInfo::TargetedHeroPortrait' has a wrong offset!");
static_assert(offsetof(FOrionTowerTargetingInfo, TowerHealth) == 0x000040, "Member 'FOrionTowerTargetingInfo::TowerHealth' has a wrong offset!");
static_assert(offsetof(FOrionTowerTargetingInfo, TowerHealthPercent) == 0x000044, "Member 'FOrionTowerTargetingInfo::TowerHealthPercent' has a wrong offset!");
static_assert(offsetof(FOrionTowerTargetingInfo, bIsNearTower) == 0x000048, "Member 'FOrionTowerTargetingInfo::bIsNearTower' has a wrong offset!");
static_assert(offsetof(FOrionTowerTargetingInfo, TowerTeamNum) == 0x000049, "Member 'FOrionTowerTargetingInfo::TowerTeamNum' has a wrong offset!");
static_assert(offsetof(FOrionTowerTargetingInfo, RespawnTime) == 0x00004C, "Member 'FOrionTowerTargetingInfo::RespawnTime' has a wrong offset!");

// ScriptStruct OrionGame.OrionHUDInputInfo
// 0x0013 (0x0014 - 0x0001)
struct FOrionHUDInputInfo final : public FUIUpdateHelperStruct
{
public:
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              StickDirection;                                    // 0x0004(0x0008)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInSelectionMode;                                // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsModiferHeldDown;                                // 0x000D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInTargetingMode;                                  // 0x000E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConfirmAllowed;                                   // 0x000F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Direction_Selected_Up;                             // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Direction_Selected_Down;                           // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Direction_Selected_Left;                           // 0x0012(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Direction_Selected_Right;                          // 0x0013(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FOrionHUDInputInfo) == 0x000004, "Wrong alignment on FOrionHUDInputInfo");
static_assert(sizeof(FOrionHUDInputInfo) == 0x000014, "Wrong size on FOrionHUDInputInfo");
static_assert(offsetof(FOrionHUDInputInfo, StickDirection) == 0x000004, "Member 'FOrionHUDInputInfo::StickDirection' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputInfo, bIsInSelectionMode) == 0x00000C, "Member 'FOrionHUDInputInfo::bIsInSelectionMode' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputInfo, bIsModiferHeldDown) == 0x00000D, "Member 'FOrionHUDInputInfo::bIsModiferHeldDown' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputInfo, bInTargetingMode) == 0x00000E, "Member 'FOrionHUDInputInfo::bInTargetingMode' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputInfo, bConfirmAllowed) == 0x00000F, "Member 'FOrionHUDInputInfo::bConfirmAllowed' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputInfo, Direction_Selected_Up) == 0x000010, "Member 'FOrionHUDInputInfo::Direction_Selected_Up' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputInfo, Direction_Selected_Down) == 0x000011, "Member 'FOrionHUDInputInfo::Direction_Selected_Down' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputInfo, Direction_Selected_Left) == 0x000012, "Member 'FOrionHUDInputInfo::Direction_Selected_Left' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputInfo, Direction_Selected_Right) == 0x000013, "Member 'FOrionHUDInputInfo::Direction_Selected_Right' has a wrong offset!");

// ScriptStruct OrionGame.OrionGameEventMessageData
// 0x00D0 (0x00D0 - 0x0000)
struct FOrionGameEventMessageData final
{
public:
	TSoftObjectPtr<class UObject>                 Icon1;                                             // 0x0000(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UObject>                 Icon2;                                             // 0x0028(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Text1;                                             // 0x0050(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Text2;                                             // 0x0068(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EOrionTeam                                    TeamNum1;                                          // 0x0080(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    TeamNum2;                                          // 0x0081(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MessageTypeIdentifier;                             // 0x0088(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionGameEventMessagePrio                    MessagePrio;                                       // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionGameEventMessageType                    MessageType;                                       // 0x0091(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x6];                                       // 0x0092(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UPCTeamCommunicationsData*              TeamCommData;                                      // 0x0098(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Payload1;                                          // 0x00A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Payload2;                                          // 0x00A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveMessagesOfSameMessageType;                  // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearLowerPrioMessages;                           // 0x00A9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlushAllLowerPrioMessages;                        // 0x00AA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStompCurrentMessage;                              // 0x00AB(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              MessageSound;                                      // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionPlayerState_Game*                 SendingPlayer;                                     // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionGameEventMessageData) == 0x000008, "Wrong alignment on FOrionGameEventMessageData");
static_assert(sizeof(FOrionGameEventMessageData) == 0x0000D0, "Wrong size on FOrionGameEventMessageData");
static_assert(offsetof(FOrionGameEventMessageData, Icon1) == 0x000000, "Member 'FOrionGameEventMessageData::Icon1' has a wrong offset!");
static_assert(offsetof(FOrionGameEventMessageData, Icon2) == 0x000028, "Member 'FOrionGameEventMessageData::Icon2' has a wrong offset!");
static_assert(offsetof(FOrionGameEventMessageData, Text1) == 0x000050, "Member 'FOrionGameEventMessageData::Text1' has a wrong offset!");
static_assert(offsetof(FOrionGameEventMessageData, Text2) == 0x000068, "Member 'FOrionGameEventMessageData::Text2' has a wrong offset!");
static_assert(offsetof(FOrionGameEventMessageData, TeamNum1) == 0x000080, "Member 'FOrionGameEventMessageData::TeamNum1' has a wrong offset!");
static_assert(offsetof(FOrionGameEventMessageData, TeamNum2) == 0x000081, "Member 'FOrionGameEventMessageData::TeamNum2' has a wrong offset!");
static_assert(offsetof(FOrionGameEventMessageData, MessageTypeIdentifier) == 0x000088, "Member 'FOrionGameEventMessageData::MessageTypeIdentifier' has a wrong offset!");
static_assert(offsetof(FOrionGameEventMessageData, MessagePrio) == 0x000090, "Member 'FOrionGameEventMessageData::MessagePrio' has a wrong offset!");
static_assert(offsetof(FOrionGameEventMessageData, MessageType) == 0x000091, "Member 'FOrionGameEventMessageData::MessageType' has a wrong offset!");
static_assert(offsetof(FOrionGameEventMessageData, TeamCommData) == 0x000098, "Member 'FOrionGameEventMessageData::TeamCommData' has a wrong offset!");
static_assert(offsetof(FOrionGameEventMessageData, Payload1) == 0x0000A0, "Member 'FOrionGameEventMessageData::Payload1' has a wrong offset!");
static_assert(offsetof(FOrionGameEventMessageData, Payload2) == 0x0000A4, "Member 'FOrionGameEventMessageData::Payload2' has a wrong offset!");
static_assert(offsetof(FOrionGameEventMessageData, bRemoveMessagesOfSameMessageType) == 0x0000A8, "Member 'FOrionGameEventMessageData::bRemoveMessagesOfSameMessageType' has a wrong offset!");
static_assert(offsetof(FOrionGameEventMessageData, bClearLowerPrioMessages) == 0x0000A9, "Member 'FOrionGameEventMessageData::bClearLowerPrioMessages' has a wrong offset!");
static_assert(offsetof(FOrionGameEventMessageData, bFlushAllLowerPrioMessages) == 0x0000AA, "Member 'FOrionGameEventMessageData::bFlushAllLowerPrioMessages' has a wrong offset!");
static_assert(offsetof(FOrionGameEventMessageData, bStompCurrentMessage) == 0x0000AB, "Member 'FOrionGameEventMessageData::bStompCurrentMessage' has a wrong offset!");
static_assert(offsetof(FOrionGameEventMessageData, MessageSound) == 0x0000B0, "Member 'FOrionGameEventMessageData::MessageSound' has a wrong offset!");
static_assert(offsetof(FOrionGameEventMessageData, SendingPlayer) == 0x0000B8, "Member 'FOrionGameEventMessageData::SendingPlayer' has a wrong offset!");

// ScriptStruct OrionGame.OrionLootNotification
// 0x0048 (0x0048 - 0x0000)
struct FOrionLootNotification final
{
public:
	class FString                                 LootSource;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LootSourceInstance;                                // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMcpLootResult                         LootGranted;                                       // 0x0020(0x0020)(NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionLootNotification) == 0x000008, "Wrong alignment on FOrionLootNotification");
static_assert(sizeof(FOrionLootNotification) == 0x000048, "Wrong size on FOrionLootNotification");
static_assert(offsetof(FOrionLootNotification, LootSource) == 0x000000, "Member 'FOrionLootNotification::LootSource' has a wrong offset!");
static_assert(offsetof(FOrionLootNotification, LootSourceInstance) == 0x000010, "Member 'FOrionLootNotification::LootSourceInstance' has a wrong offset!");
static_assert(offsetof(FOrionLootNotification, LootGranted) == 0x000020, "Member 'FOrionLootNotification::LootGranted' has a wrong offset!");
static_assert(offsetof(FOrionLootNotification, Level) == 0x000040, "Member 'FOrionLootNotification::Level' has a wrong offset!");

// ScriptStruct OrionGame.DraftStats_Team
// 0x0018 (0x0018 - 0x0000)
struct FDraftStats_Team final
{
public:
	int32                                         TeamNum;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamMMR;                                           // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FUniqueNetIdRepl>               Players;                                           // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDraftStats_Team) == 0x000008, "Wrong alignment on FDraftStats_Team");
static_assert(sizeof(FDraftStats_Team) == 0x000018, "Wrong size on FDraftStats_Team");
static_assert(offsetof(FDraftStats_Team, TeamNum) == 0x000000, "Member 'FDraftStats_Team::TeamNum' has a wrong offset!");
static_assert(offsetof(FDraftStats_Team, TeamMMR) == 0x000004, "Member 'FDraftStats_Team::TeamMMR' has a wrong offset!");
static_assert(offsetof(FDraftStats_Team, Players) == 0x000008, "Member 'FDraftStats_Team::Players' has a wrong offset!");

// ScriptStruct OrionGame.OrionSpectatorHUDPlayerInfo
// 0x0050 (0x00C0 - 0x0070)
struct FOrionSpectatorHUDPlayerInfo final : public FOrionBaseHUDPlayerInfo
{
public:
	TWeakObjectPtr<class AOrionPlayerState_Game>  PlayerState;                                       // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             PortraitTexture;                                   // 0x0078(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEmptySlot;                                      // 0x0080(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUltimateReady;                                  // 0x0081(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBeingWatched;                                   // 0x0082(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_83[0x5];                                       // 0x0083(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionPlayerStateUIID                  PlayerStateUIID;                                   // 0x0088(0x0028)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionSpectatorHUDPlayerInfo) == 0x000008, "Wrong alignment on FOrionSpectatorHUDPlayerInfo");
static_assert(sizeof(FOrionSpectatorHUDPlayerInfo) == 0x0000C0, "Wrong size on FOrionSpectatorHUDPlayerInfo");
static_assert(offsetof(FOrionSpectatorHUDPlayerInfo, PlayerState) == 0x000070, "Member 'FOrionSpectatorHUDPlayerInfo::PlayerState' has a wrong offset!");
static_assert(offsetof(FOrionSpectatorHUDPlayerInfo, PortraitTexture) == 0x000078, "Member 'FOrionSpectatorHUDPlayerInfo::PortraitTexture' has a wrong offset!");
static_assert(offsetof(FOrionSpectatorHUDPlayerInfo, bIsEmptySlot) == 0x000080, "Member 'FOrionSpectatorHUDPlayerInfo::bIsEmptySlot' has a wrong offset!");
static_assert(offsetof(FOrionSpectatorHUDPlayerInfo, bIsUltimateReady) == 0x000081, "Member 'FOrionSpectatorHUDPlayerInfo::bIsUltimateReady' has a wrong offset!");
static_assert(offsetof(FOrionSpectatorHUDPlayerInfo, bIsBeingWatched) == 0x000082, "Member 'FOrionSpectatorHUDPlayerInfo::bIsBeingWatched' has a wrong offset!");
static_assert(offsetof(FOrionSpectatorHUDPlayerInfo, PlayerStateUIID) == 0x000088, "Member 'FOrionSpectatorHUDPlayerInfo::PlayerStateUIID' has a wrong offset!");

// ScriptStruct OrionGame.AlwaysVisibleComponenets
// 0x0010 (0x0010 - 0x0000)
struct FAlwaysVisibleComponenets final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Owner;                                             // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAlwaysVisibleComponenets) == 0x000008, "Wrong alignment on FAlwaysVisibleComponenets");
static_assert(sizeof(FAlwaysVisibleComponenets) == 0x000010, "Wrong size on FAlwaysVisibleComponenets");
static_assert(offsetof(FAlwaysVisibleComponenets, Owner) == 0x000008, "Member 'FAlwaysVisibleComponenets::Owner' has a wrong offset!");

// ScriptStruct OrionGame.AILaneInfoManager
// 0x0178 (0x0178 - 0x0000)
struct FAILaneInfoManager final
{
public:
	class AOrionAIInfluenceMapManager*            InfluenceMap;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABotObjectiveGraph*                     ObjectiveGraph;                                    // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLaneInfo                              Lanes[0x3];                                        // 0x0010(0x0070)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_160[0x18];                                     // 0x0160(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAILaneInfoManager) == 0x000008, "Wrong alignment on FAILaneInfoManager");
static_assert(sizeof(FAILaneInfoManager) == 0x000178, "Wrong size on FAILaneInfoManager");
static_assert(offsetof(FAILaneInfoManager, InfluenceMap) == 0x000000, "Member 'FAILaneInfoManager::InfluenceMap' has a wrong offset!");
static_assert(offsetof(FAILaneInfoManager, ObjectiveGraph) == 0x000008, "Member 'FAILaneInfoManager::ObjectiveGraph' has a wrong offset!");
static_assert(offsetof(FAILaneInfoManager, Lanes) == 0x000010, "Member 'FAILaneInfoManager::Lanes' has a wrong offset!");

// ScriptStruct OrionGame.MinionAnimSource
// 0x0020 (0x0020 - 0x0000)
struct FMinionAnimSource final
{
public:
	bool                                          bShowBehaviorEnum;                                 // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionMinionPrioritizedBehavior               Behavior;                                          // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      AnimationSequence;                                 // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMinionAnimSource) == 0x000008, "Wrong alignment on FMinionAnimSource");
static_assert(sizeof(FMinionAnimSource) == 0x000020, "Wrong size on FMinionAnimSource");
static_assert(offsetof(FMinionAnimSource, bShowBehaviorEnum) == 0x000000, "Member 'FMinionAnimSource::bShowBehaviorEnum' has a wrong offset!");
static_assert(offsetof(FMinionAnimSource, Behavior) == 0x000001, "Member 'FMinionAnimSource::Behavior' has a wrong offset!");
static_assert(offsetof(FMinionAnimSource, AnimationSequence) == 0x000008, "Member 'FMinionAnimSource::AnimationSequence' has a wrong offset!");
static_assert(offsetof(FMinionAnimSource, BlendInTime) == 0x000010, "Member 'FMinionAnimSource::BlendInTime' has a wrong offset!");
static_assert(offsetof(FMinionAnimSource, BlendOutTime) == 0x000014, "Member 'FMinionAnimSource::BlendOutTime' has a wrong offset!");
static_assert(offsetof(FMinionAnimSource, PlayRate) == 0x000018, "Member 'FMinionAnimSource::PlayRate' has a wrong offset!");

// ScriptStruct OrionGame.MinionDeathAnimSource
// 0x0028 (0x0028 - 0x0000)
struct FMinionDeathAnimSource final
{
public:
	EOrionMinionAnimDirection                     HitDirection;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMinionAnimSource                      AnimSource;                                        // 0x0008(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMinionDeathAnimSource) == 0x000008, "Wrong alignment on FMinionDeathAnimSource");
static_assert(sizeof(FMinionDeathAnimSource) == 0x000028, "Wrong size on FMinionDeathAnimSource");
static_assert(offsetof(FMinionDeathAnimSource, HitDirection) == 0x000000, "Member 'FMinionDeathAnimSource::HitDirection' has a wrong offset!");
static_assert(offsetof(FMinionDeathAnimSource, AnimSource) == 0x000008, "Member 'FMinionDeathAnimSource::AnimSource' has a wrong offset!");

// ScriptStruct OrionGame.MinionBehaviorAnimation
// 0x02A0 (0x02A0 - 0x0000)
struct FMinionBehaviorAnimation final
{
public:
	TArray<struct FMinionAnimSource>              AnimationSources;                                  // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FMinionDeathAnimSource>         DeathAnimSources;                                  // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	float                                         SplitBodyInterpSpeed;                              // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SplitBodySpeedThreshold;                           // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28[0x278];                                     // 0x0028(0x0278)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMinionBehaviorAnimation) == 0x000008, "Wrong alignment on FMinionBehaviorAnimation");
static_assert(sizeof(FMinionBehaviorAnimation) == 0x0002A0, "Wrong size on FMinionBehaviorAnimation");
static_assert(offsetof(FMinionBehaviorAnimation, AnimationSources) == 0x000000, "Member 'FMinionBehaviorAnimation::AnimationSources' has a wrong offset!");
static_assert(offsetof(FMinionBehaviorAnimation, DeathAnimSources) == 0x000010, "Member 'FMinionBehaviorAnimation::DeathAnimSources' has a wrong offset!");
static_assert(offsetof(FMinionBehaviorAnimation, SplitBodyInterpSpeed) == 0x000020, "Member 'FMinionBehaviorAnimation::SplitBodyInterpSpeed' has a wrong offset!");
static_assert(offsetof(FMinionBehaviorAnimation, SplitBodySpeedThreshold) == 0x000024, "Member 'FMinionBehaviorAnimation::SplitBodySpeedThreshold' has a wrong offset!");

// ScriptStruct OrionGame.OrionAnimNode_MinionBehavior
// 0x02C0 (0x02F0 - 0x0030)
struct FOrionAnimNode_MinionBehavior final : public FAnimNode_Base
{
public:
	struct FPoseLink                              DefaultPose;                                       // 0x0030(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FMinionBehaviorAnimation               MinionBehaviorHandler;                             // 0x0048(0x02A0)(Edit, NativeAccessSpecifierPrivate)
	bool                                          bIsValid;                                          // 0x02E8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E9[0x3];                                      // 0x02E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultWeight;                                     // 0x02EC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOrionAnimNode_MinionBehavior) == 0x000008, "Wrong alignment on FOrionAnimNode_MinionBehavior");
static_assert(sizeof(FOrionAnimNode_MinionBehavior) == 0x0002F0, "Wrong size on FOrionAnimNode_MinionBehavior");
static_assert(offsetof(FOrionAnimNode_MinionBehavior, DefaultPose) == 0x000030, "Member 'FOrionAnimNode_MinionBehavior::DefaultPose' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_MinionBehavior, MinionBehaviorHandler) == 0x000048, "Member 'FOrionAnimNode_MinionBehavior::MinionBehaviorHandler' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_MinionBehavior, bIsValid) == 0x0002E8, "Member 'FOrionAnimNode_MinionBehavior::bIsValid' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_MinionBehavior, DefaultWeight) == 0x0002EC, "Member 'FOrionAnimNode_MinionBehavior::DefaultWeight' has a wrong offset!");

// ScriptStruct OrionGame.OrionSearchPassParams
// 0x0028 (0x0028 - 0x0000)
struct FOrionSearchPassParams final
{
public:
	int32                                         ControllerId;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SessionName;                                       // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RegionId;                                          // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatchmakingFlags                             Flags;                                             // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionSearchPassParams) == 0x000008, "Wrong alignment on FOrionSearchPassParams");
static_assert(sizeof(FOrionSearchPassParams) == 0x000028, "Wrong size on FOrionSearchPassParams");
static_assert(offsetof(FOrionSearchPassParams, ControllerId) == 0x000000, "Member 'FOrionSearchPassParams::ControllerId' has a wrong offset!");
static_assert(offsetof(FOrionSearchPassParams, SessionName) == 0x000008, "Member 'FOrionSearchPassParams::SessionName' has a wrong offset!");
static_assert(offsetof(FOrionSearchPassParams, RegionId) == 0x000010, "Member 'FOrionSearchPassParams::RegionId' has a wrong offset!");
static_assert(offsetof(FOrionSearchPassParams, Flags) == 0x000020, "Member 'FOrionSearchPassParams::Flags' has a wrong offset!");

// ScriptStruct OrionGame.AIScriptedBehaviorInstanceWrapper
// 0x0008 (0x0008 - 0x0000)
struct FAIScriptedBehaviorInstanceWrapper final
{
public:
	class UAIScriptedBehavior*                    ScriptedBehavior;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIScriptedBehaviorInstanceWrapper) == 0x000008, "Wrong alignment on FAIScriptedBehaviorInstanceWrapper");
static_assert(sizeof(FAIScriptedBehaviorInstanceWrapper) == 0x000008, "Wrong size on FAIScriptedBehaviorInstanceWrapper");
static_assert(offsetof(FAIScriptedBehaviorInstanceWrapper, ScriptedBehavior) == 0x000000, "Member 'FAIScriptedBehaviorInstanceWrapper::ScriptedBehavior' has a wrong offset!");

// ScriptStruct OrionGame.GameplayCueNotifySubset
// 0x00B0 (0x00B0 - 0x0000)
struct alignas(0x10) FGameplayCueNotifySubset final
{
public:
	uint8                                         Pad_0[0x78];                                       // 0x0000(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UClass*>                         LoadedClasses;                                     // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UObjectLibrary*                         GameplayCueNotifyActorObjectLibrary;               // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObjectLibrary*                         GameplayCueNotifyStaticObjectLibrary;              // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x18];                                      // 0x0098(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayCueNotifySubset) == 0x000010, "Wrong alignment on FGameplayCueNotifySubset");
static_assert(sizeof(FGameplayCueNotifySubset) == 0x0000B0, "Wrong size on FGameplayCueNotifySubset");
static_assert(offsetof(FGameplayCueNotifySubset, LoadedClasses) == 0x000078, "Member 'FGameplayCueNotifySubset::LoadedClasses' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotifySubset, GameplayCueNotifyActorObjectLibrary) == 0x000088, "Member 'FGameplayCueNotifySubset::GameplayCueNotifyActorObjectLibrary' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotifySubset, GameplayCueNotifyStaticObjectLibrary) == 0x000090, "Member 'FGameplayCueNotifySubset::GameplayCueNotifyStaticObjectLibrary' has a wrong offset!");

// ScriptStruct OrionGame.ObjectiveGraphDebugNodeOverride
// 0x0001 (0x0001 - 0x0000)
struct FObjectiveGraphDebugNodeOverride final
{
public:
	EOrionTeam                                    TeamNum;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObjectiveGraphDebugNodeOverride) == 0x000001, "Wrong alignment on FObjectiveGraphDebugNodeOverride");
static_assert(sizeof(FObjectiveGraphDebugNodeOverride) == 0x000001, "Wrong size on FObjectiveGraphDebugNodeOverride");
static_assert(offsetof(FObjectiveGraphDebugNodeOverride, TeamNum) == 0x000000, "Member 'FObjectiveGraphDebugNodeOverride::TeamNum' has a wrong offset!");

// ScriptStruct OrionGame.GemAbilityLevel
// 0x0004 (0x0004 - 0x0000)
struct FGemAbilityLevel
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGemAbilityLevel) == 0x000004, "Wrong alignment on FGemAbilityLevel");
static_assert(sizeof(FGemAbilityLevel) == 0x000004, "Wrong size on FGemAbilityLevel");
static_assert(offsetof(FGemAbilityLevel, Level) == 0x000000, "Member 'FGemAbilityLevel::Level' has a wrong offset!");

// ScriptStruct OrionGame.OrionRigCues
// 0x0018 (0x0018 - 0x0000)
struct FOrionRigCues final
{
public:
	struct FGameplayCueTag                        RigBuilding;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        RigWorking;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        RigCollected;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionRigCues) == 0x000008, "Wrong alignment on FOrionRigCues");
static_assert(sizeof(FOrionRigCues) == 0x000018, "Wrong size on FOrionRigCues");
static_assert(offsetof(FOrionRigCues, RigBuilding) == 0x000000, "Member 'FOrionRigCues::RigBuilding' has a wrong offset!");
static_assert(offsetof(FOrionRigCues, RigWorking) == 0x000008, "Member 'FOrionRigCues::RigWorking' has a wrong offset!");
static_assert(offsetof(FOrionRigCues, RigCollected) == 0x000010, "Member 'FOrionRigCues::RigCollected' has a wrong offset!");

// ScriptStruct OrionGame.OrionStackCostInfo
// 0x00D0 (0x00D0 - 0x0000)
struct FOrionStackCostInfo final
{
public:
	TSubclassOf<class UGameplayEffect>            GameplayEffect;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FScalableFloat                         InitialStacks;                                     // 0x0008(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScalableFloat                         StacksRequired;                                    // 0x0030(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScalableFloat                         StacksConsumedOnCommit;                            // 0x0058(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScalableFloat                         StackRefreshTime;                                  // 0x0080(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScalableFloat                         StacksGrantedOnAbilityLevelUp;                     // 0x00A8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionStackCostInfo) == 0x000008, "Wrong alignment on FOrionStackCostInfo");
static_assert(sizeof(FOrionStackCostInfo) == 0x0000D0, "Wrong size on FOrionStackCostInfo");
static_assert(offsetof(FOrionStackCostInfo, GameplayEffect) == 0x000000, "Member 'FOrionStackCostInfo::GameplayEffect' has a wrong offset!");
static_assert(offsetof(FOrionStackCostInfo, InitialStacks) == 0x000008, "Member 'FOrionStackCostInfo::InitialStacks' has a wrong offset!");
static_assert(offsetof(FOrionStackCostInfo, StacksRequired) == 0x000030, "Member 'FOrionStackCostInfo::StacksRequired' has a wrong offset!");
static_assert(offsetof(FOrionStackCostInfo, StacksConsumedOnCommit) == 0x000058, "Member 'FOrionStackCostInfo::StacksConsumedOnCommit' has a wrong offset!");
static_assert(offsetof(FOrionStackCostInfo, StackRefreshTime) == 0x000080, "Member 'FOrionStackCostInfo::StackRefreshTime' has a wrong offset!");
static_assert(offsetof(FOrionStackCostInfo, StacksGrantedOnAbilityLevelUp) == 0x0000A8, "Member 'FOrionStackCostInfo::StacksGrantedOnAbilityLevelUp' has a wrong offset!");

// ScriptStruct OrionGame.OrionCostInfo
// 0x0100 (0x0100 - 0x0000)
struct FOrionCostInfo final
{
public:
	TSubclassOf<class UGameplayEffect>            CostGameplayEffect;                                // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FScalableFloat                         ExplicitValue;                                     // 0x0008(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FOrionStackCostInfo                    StackCost;                                         // 0x0030(0x00D0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionCostInfo) == 0x000008, "Wrong alignment on FOrionCostInfo");
static_assert(sizeof(FOrionCostInfo) == 0x000100, "Wrong size on FOrionCostInfo");
static_assert(offsetof(FOrionCostInfo, CostGameplayEffect) == 0x000000, "Member 'FOrionCostInfo::CostGameplayEffect' has a wrong offset!");
static_assert(offsetof(FOrionCostInfo, ExplicitValue) == 0x000008, "Member 'FOrionCostInfo::ExplicitValue' has a wrong offset!");
static_assert(offsetof(FOrionCostInfo, StackCost) == 0x000030, "Member 'FOrionCostInfo::StackCost' has a wrong offset!");

// ScriptStruct OrionGame.OrionCardLevelTierFlareLayout
// 0x0038 (0x0038 - 0x0000)
struct FOrionCardLevelTierFlareLayout final
{
public:
	struct FWidgetTransform                       BigFlareRenderTransform;                           // 0x0000(0x001C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWidgetTransform                       SmallFlareRenderTransform;                         // 0x001C(0x001C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionCardLevelTierFlareLayout) == 0x000004, "Wrong alignment on FOrionCardLevelTierFlareLayout");
static_assert(sizeof(FOrionCardLevelTierFlareLayout) == 0x000038, "Wrong size on FOrionCardLevelTierFlareLayout");
static_assert(offsetof(FOrionCardLevelTierFlareLayout, BigFlareRenderTransform) == 0x000000, "Member 'FOrionCardLevelTierFlareLayout::BigFlareRenderTransform' has a wrong offset!");
static_assert(offsetof(FOrionCardLevelTierFlareLayout, SmallFlareRenderTransform) == 0x00001C, "Member 'FOrionCardLevelTierFlareLayout::SmallFlareRenderTransform' has a wrong offset!");

// ScriptStruct OrionGame.FakeObjectiveGraphMinionWave
// 0x0028 (0x0028 - 0x0000)
struct FFakeObjectiveGraphMinionWave final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        MinionLocations;                                   // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint32                                        MinionsCount;                                      // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    TeamNum;                                           // 0x0024(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuperMinions;                                     // 0x0025(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFakeObjectiveGraphMinionWave) == 0x000008, "Wrong alignment on FFakeObjectiveGraphMinionWave");
static_assert(sizeof(FFakeObjectiveGraphMinionWave) == 0x000028, "Wrong size on FFakeObjectiveGraphMinionWave");
static_assert(offsetof(FFakeObjectiveGraphMinionWave, Location) == 0x000000, "Member 'FFakeObjectiveGraphMinionWave::Location' has a wrong offset!");
static_assert(offsetof(FFakeObjectiveGraphMinionWave, MinionLocations) == 0x000010, "Member 'FFakeObjectiveGraphMinionWave::MinionLocations' has a wrong offset!");
static_assert(offsetof(FFakeObjectiveGraphMinionWave, MinionsCount) == 0x000020, "Member 'FFakeObjectiveGraphMinionWave::MinionsCount' has a wrong offset!");
static_assert(offsetof(FFakeObjectiveGraphMinionWave, TeamNum) == 0x000024, "Member 'FFakeObjectiveGraphMinionWave::TeamNum' has a wrong offset!");
static_assert(offsetof(FFakeObjectiveGraphMinionWave, bSuperMinions) == 0x000025, "Member 'FFakeObjectiveGraphMinionWave::bSuperMinions' has a wrong offset!");

// ScriptStruct OrionGame.OrionCharReplicatedStatus
// 0x0020 (0x0020 - 0x0000)
struct FOrionCharReplicatedStatus final
{
public:
	uint8                                         Status;                                            // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EndTime;                                           // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0008(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         InstigatorList;                                    // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionCharReplicatedStatus) == 0x000008, "Wrong alignment on FOrionCharReplicatedStatus");
static_assert(sizeof(FOrionCharReplicatedStatus) == 0x000020, "Wrong size on FOrionCharReplicatedStatus");
static_assert(offsetof(FOrionCharReplicatedStatus, Status) == 0x000000, "Member 'FOrionCharReplicatedStatus::Status' has a wrong offset!");
static_assert(offsetof(FOrionCharReplicatedStatus, EndTime) == 0x000004, "Member 'FOrionCharReplicatedStatus::EndTime' has a wrong offset!");
static_assert(offsetof(FOrionCharReplicatedStatus, Tag) == 0x000008, "Member 'FOrionCharReplicatedStatus::Tag' has a wrong offset!");
static_assert(offsetof(FOrionCharReplicatedStatus, InstigatorList) == 0x000010, "Member 'FOrionCharReplicatedStatus::InstigatorList' has a wrong offset!");

// ScriptStruct OrionGame.FakeObjectiveGraphCharacter
// 0x0014 (0x0014 - 0x0000)
struct FFakeObjectiveGraphCharacter final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTargetType                              Type;                                              // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    TeamNum;                                           // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFakeObjectiveGraphCharacter) == 0x000004, "Wrong alignment on FFakeObjectiveGraphCharacter");
static_assert(sizeof(FFakeObjectiveGraphCharacter) == 0x000014, "Wrong size on FFakeObjectiveGraphCharacter");
static_assert(offsetof(FFakeObjectiveGraphCharacter, Location) == 0x000000, "Member 'FFakeObjectiveGraphCharacter::Location' has a wrong offset!");
static_assert(offsetof(FFakeObjectiveGraphCharacter, Level) == 0x00000C, "Member 'FFakeObjectiveGraphCharacter::Level' has a wrong offset!");
static_assert(offsetof(FFakeObjectiveGraphCharacter, Type) == 0x000010, "Member 'FFakeObjectiveGraphCharacter::Type' has a wrong offset!");
static_assert(offsetof(FFakeObjectiveGraphCharacter, TeamNum) == 0x000011, "Member 'FFakeObjectiveGraphCharacter::TeamNum' has a wrong offset!");

// ScriptStruct OrionGame.AutoExportScalableFloat
// 0x0038 (0x0038 - 0x0000)
struct FAutoExportScalableFloat
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ParameterName;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FScalableFloat                         ParameterValue;                                    // 0x0010(0x0028)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAutoExportScalableFloat) == 0x000008, "Wrong alignment on FAutoExportScalableFloat");
static_assert(sizeof(FAutoExportScalableFloat) == 0x000038, "Wrong size on FAutoExportScalableFloat");
static_assert(offsetof(FAutoExportScalableFloat, ParameterName) == 0x000008, "Member 'FAutoExportScalableFloat::ParameterName' has a wrong offset!");
static_assert(offsetof(FAutoExportScalableFloat, ParameterValue) == 0x000010, "Member 'FAutoExportScalableFloat::ParameterValue' has a wrong offset!");

// ScriptStruct OrionGame.PerfTestDataEvent
// 0x0110 (0x0110 - 0x0000)
struct FPerfTestDataEvent final
{
public:
	class FString                                 AppId;                                             // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AppVersion;                                        // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UserID;                                            // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IpAddress;                                         // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TimeOfGenerationUTC;                               // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TestRunTime;                                       // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StatName;                                          // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MapName;                                           // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TestName;                                          // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterName;                                     // 0x0090(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SkinName;                                          // 0x00A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DeviceProfile;                                     // 0x00B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Platform;                                          // 0x00C0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinVal;                                            // 0x00D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvgVal;                                            // 0x00D4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxVal;                                            // 0x00D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumFrames;                                         // 0x00DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CL;                                                // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CurrentDate;                                       // 0x00E8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  TestGuid;                                          // 0x00F8(0x0010)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IterationNumber;                                   // 0x0108(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPerfTestDataEvent) == 0x000008, "Wrong alignment on FPerfTestDataEvent");
static_assert(sizeof(FPerfTestDataEvent) == 0x000110, "Wrong size on FPerfTestDataEvent");
static_assert(offsetof(FPerfTestDataEvent, AppId) == 0x000000, "Member 'FPerfTestDataEvent::AppId' has a wrong offset!");
static_assert(offsetof(FPerfTestDataEvent, AppVersion) == 0x000010, "Member 'FPerfTestDataEvent::AppVersion' has a wrong offset!");
static_assert(offsetof(FPerfTestDataEvent, UserID) == 0x000020, "Member 'FPerfTestDataEvent::UserID' has a wrong offset!");
static_assert(offsetof(FPerfTestDataEvent, IpAddress) == 0x000030, "Member 'FPerfTestDataEvent::IpAddress' has a wrong offset!");
static_assert(offsetof(FPerfTestDataEvent, TimeOfGenerationUTC) == 0x000040, "Member 'FPerfTestDataEvent::TimeOfGenerationUTC' has a wrong offset!");
static_assert(offsetof(FPerfTestDataEvent, TestRunTime) == 0x000050, "Member 'FPerfTestDataEvent::TestRunTime' has a wrong offset!");
static_assert(offsetof(FPerfTestDataEvent, StatName) == 0x000060, "Member 'FPerfTestDataEvent::StatName' has a wrong offset!");
static_assert(offsetof(FPerfTestDataEvent, MapName) == 0x000070, "Member 'FPerfTestDataEvent::MapName' has a wrong offset!");
static_assert(offsetof(FPerfTestDataEvent, TestName) == 0x000080, "Member 'FPerfTestDataEvent::TestName' has a wrong offset!");
static_assert(offsetof(FPerfTestDataEvent, CharacterName) == 0x000090, "Member 'FPerfTestDataEvent::CharacterName' has a wrong offset!");
static_assert(offsetof(FPerfTestDataEvent, SkinName) == 0x0000A0, "Member 'FPerfTestDataEvent::SkinName' has a wrong offset!");
static_assert(offsetof(FPerfTestDataEvent, DeviceProfile) == 0x0000B0, "Member 'FPerfTestDataEvent::DeviceProfile' has a wrong offset!");
static_assert(offsetof(FPerfTestDataEvent, Platform) == 0x0000C0, "Member 'FPerfTestDataEvent::Platform' has a wrong offset!");
static_assert(offsetof(FPerfTestDataEvent, MinVal) == 0x0000D0, "Member 'FPerfTestDataEvent::MinVal' has a wrong offset!");
static_assert(offsetof(FPerfTestDataEvent, AvgVal) == 0x0000D4, "Member 'FPerfTestDataEvent::AvgVal' has a wrong offset!");
static_assert(offsetof(FPerfTestDataEvent, MaxVal) == 0x0000D8, "Member 'FPerfTestDataEvent::MaxVal' has a wrong offset!");
static_assert(offsetof(FPerfTestDataEvent, NumFrames) == 0x0000DC, "Member 'FPerfTestDataEvent::NumFrames' has a wrong offset!");
static_assert(offsetof(FPerfTestDataEvent, CL) == 0x0000E0, "Member 'FPerfTestDataEvent::CL' has a wrong offset!");
static_assert(offsetof(FPerfTestDataEvent, CurrentDate) == 0x0000E8, "Member 'FPerfTestDataEvent::CurrentDate' has a wrong offset!");
static_assert(offsetof(FPerfTestDataEvent, TestGuid) == 0x0000F8, "Member 'FPerfTestDataEvent::TestGuid' has a wrong offset!");
static_assert(offsetof(FPerfTestDataEvent, IterationNumber) == 0x000108, "Member 'FPerfTestDataEvent::IterationNumber' has a wrong offset!");

// ScriptStruct OrionGame.PerfTestHitch
// 0x0018 (0x0018 - 0x0000)
struct FPerfTestHitch final
{
public:
	class FString                                 HitchType;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitchDuration;                                     // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPerfTestHitch) == 0x000008, "Wrong alignment on FPerfTestHitch");
static_assert(sizeof(FPerfTestHitch) == 0x000018, "Wrong size on FPerfTestHitch");
static_assert(offsetof(FPerfTestHitch, HitchType) == 0x000000, "Member 'FPerfTestHitch::HitchType' has a wrong offset!");
static_assert(offsetof(FPerfTestHitch, HitchDuration) == 0x000010, "Member 'FPerfTestHitch::HitchDuration' has a wrong offset!");

// ScriptStruct OrionGame.PerfTestHitchCollection
// 0x0078 (0x0078 - 0x0000)
struct FPerfTestHitchCollection final
{
public:
	class FString                                 MapName;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TestName;                                          // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterName;                                     // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SkinName;                                          // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DeviceProfile;                                     // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Platform;                                          // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IterationNumber;                                   // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPerfTestHitch>                 HitchList;                                         // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerfTestHitchCollection) == 0x000008, "Wrong alignment on FPerfTestHitchCollection");
static_assert(sizeof(FPerfTestHitchCollection) == 0x000078, "Wrong size on FPerfTestHitchCollection");
static_assert(offsetof(FPerfTestHitchCollection, MapName) == 0x000000, "Member 'FPerfTestHitchCollection::MapName' has a wrong offset!");
static_assert(offsetof(FPerfTestHitchCollection, TestName) == 0x000010, "Member 'FPerfTestHitchCollection::TestName' has a wrong offset!");
static_assert(offsetof(FPerfTestHitchCollection, CharacterName) == 0x000020, "Member 'FPerfTestHitchCollection::CharacterName' has a wrong offset!");
static_assert(offsetof(FPerfTestHitchCollection, SkinName) == 0x000030, "Member 'FPerfTestHitchCollection::SkinName' has a wrong offset!");
static_assert(offsetof(FPerfTestHitchCollection, DeviceProfile) == 0x000040, "Member 'FPerfTestHitchCollection::DeviceProfile' has a wrong offset!");
static_assert(offsetof(FPerfTestHitchCollection, Platform) == 0x000050, "Member 'FPerfTestHitchCollection::Platform' has a wrong offset!");
static_assert(offsetof(FPerfTestHitchCollection, IterationNumber) == 0x000060, "Member 'FPerfTestHitchCollection::IterationNumber' has a wrong offset!");
static_assert(offsetof(FPerfTestHitchCollection, HitchList) == 0x000068, "Member 'FPerfTestHitchCollection::HitchList' has a wrong offset!");

// ScriptStruct OrionGame.AnalogCursorSettings
// 0x0038 (0x0038 - 0x0000)
struct FAnalogCursorSettings final
{
public:
	class UCurveFloat*                            InputCurve;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ScrollCurve;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultSpeed;                                      // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinHoverWidgetSize;                                // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHoverWidgetSize;                                // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinHoverSpeedScale;                                // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHoverSpeedScale;                                // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverSpeedScaleDecayRate;                          // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeadZone;                                          // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyAxisScaling;                                 // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayDebug;                                     // 0x0031(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnalogCursorSettings) == 0x000008, "Wrong alignment on FAnalogCursorSettings");
static_assert(sizeof(FAnalogCursorSettings) == 0x000038, "Wrong size on FAnalogCursorSettings");
static_assert(offsetof(FAnalogCursorSettings, InputCurve) == 0x000000, "Member 'FAnalogCursorSettings::InputCurve' has a wrong offset!");
static_assert(offsetof(FAnalogCursorSettings, ScrollCurve) == 0x000008, "Member 'FAnalogCursorSettings::ScrollCurve' has a wrong offset!");
static_assert(offsetof(FAnalogCursorSettings, DefaultSpeed) == 0x000010, "Member 'FAnalogCursorSettings::DefaultSpeed' has a wrong offset!");
static_assert(offsetof(FAnalogCursorSettings, MinHoverWidgetSize) == 0x000014, "Member 'FAnalogCursorSettings::MinHoverWidgetSize' has a wrong offset!");
static_assert(offsetof(FAnalogCursorSettings, MaxHoverWidgetSize) == 0x000018, "Member 'FAnalogCursorSettings::MaxHoverWidgetSize' has a wrong offset!");
static_assert(offsetof(FAnalogCursorSettings, MinHoverSpeedScale) == 0x00001C, "Member 'FAnalogCursorSettings::MinHoverSpeedScale' has a wrong offset!");
static_assert(offsetof(FAnalogCursorSettings, MaxHoverSpeedScale) == 0x000020, "Member 'FAnalogCursorSettings::MaxHoverSpeedScale' has a wrong offset!");
static_assert(offsetof(FAnalogCursorSettings, HoverSpeedScaleDecayRate) == 0x000024, "Member 'FAnalogCursorSettings::HoverSpeedScaleDecayRate' has a wrong offset!");
static_assert(offsetof(FAnalogCursorSettings, DeadZone) == 0x000028, "Member 'FAnalogCursorSettings::DeadZone' has a wrong offset!");
static_assert(offsetof(FAnalogCursorSettings, Radius) == 0x00002C, "Member 'FAnalogCursorSettings::Radius' has a wrong offset!");
static_assert(offsetof(FAnalogCursorSettings, bApplyAxisScaling) == 0x000030, "Member 'FAnalogCursorSettings::bApplyAxisScaling' has a wrong offset!");
static_assert(offsetof(FAnalogCursorSettings, bDisplayDebug) == 0x000031, "Member 'FAnalogCursorSettings::bDisplayDebug' has a wrong offset!");

// ScriptStruct OrionGame.OrionHeroMasteryProgression
// 0x0020 (0x0020 - 0x0000)
struct FOrionHeroMasteryProgression final
{
public:
	int32                                         CurrentXP;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxRank;                                           // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rank;                                              // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalEarnedXP;                                     // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastMatchUnearnedXP;                               // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalXP;                                           // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FreeTokensUsed;                                    // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionHeroMasteryProgression) == 0x000004, "Wrong alignment on FOrionHeroMasteryProgression");
static_assert(sizeof(FOrionHeroMasteryProgression) == 0x000020, "Wrong size on FOrionHeroMasteryProgression");
static_assert(offsetof(FOrionHeroMasteryProgression, CurrentXP) == 0x000000, "Member 'FOrionHeroMasteryProgression::CurrentXP' has a wrong offset!");
static_assert(offsetof(FOrionHeroMasteryProgression, Level) == 0x000004, "Member 'FOrionHeroMasteryProgression::Level' has a wrong offset!");
static_assert(offsetof(FOrionHeroMasteryProgression, MaxRank) == 0x000008, "Member 'FOrionHeroMasteryProgression::MaxRank' has a wrong offset!");
static_assert(offsetof(FOrionHeroMasteryProgression, Rank) == 0x00000C, "Member 'FOrionHeroMasteryProgression::Rank' has a wrong offset!");
static_assert(offsetof(FOrionHeroMasteryProgression, TotalEarnedXP) == 0x000010, "Member 'FOrionHeroMasteryProgression::TotalEarnedXP' has a wrong offset!");
static_assert(offsetof(FOrionHeroMasteryProgression, LastMatchUnearnedXP) == 0x000014, "Member 'FOrionHeroMasteryProgression::LastMatchUnearnedXP' has a wrong offset!");
static_assert(offsetof(FOrionHeroMasteryProgression, TotalXP) == 0x000018, "Member 'FOrionHeroMasteryProgression::TotalXP' has a wrong offset!");
static_assert(offsetof(FOrionHeroMasteryProgression, FreeTokensUsed) == 0x00001C, "Member 'FOrionHeroMasteryProgression::FreeTokensUsed' has a wrong offset!");

// ScriptStruct OrionGame.CameraSpeedFovSettings
// 0x0018 (0x0018 - 0x0000)
struct FCameraSpeedFovSettings final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeltaAngle;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSpeed;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpRateUp;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpRateDown;                                      // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraSpeedFovSettings) == 0x000004, "Wrong alignment on FCameraSpeedFovSettings");
static_assert(sizeof(FCameraSpeedFovSettings) == 0x000018, "Wrong size on FCameraSpeedFovSettings");
static_assert(offsetof(FCameraSpeedFovSettings, bEnabled) == 0x000000, "Member 'FCameraSpeedFovSettings::bEnabled' has a wrong offset!");
static_assert(offsetof(FCameraSpeedFovSettings, DeltaAngle) == 0x000004, "Member 'FCameraSpeedFovSettings::DeltaAngle' has a wrong offset!");
static_assert(offsetof(FCameraSpeedFovSettings, MinSpeed) == 0x000008, "Member 'FCameraSpeedFovSettings::MinSpeed' has a wrong offset!");
static_assert(offsetof(FCameraSpeedFovSettings, MaxSpeed) == 0x00000C, "Member 'FCameraSpeedFovSettings::MaxSpeed' has a wrong offset!");
static_assert(offsetof(FCameraSpeedFovSettings, LerpRateUp) == 0x000010, "Member 'FCameraSpeedFovSettings::LerpRateUp' has a wrong offset!");
static_assert(offsetof(FCameraSpeedFovSettings, LerpRateDown) == 0x000014, "Member 'FCameraSpeedFovSettings::LerpRateDown' has a wrong offset!");

// ScriptStruct OrionGame.OrionGestureEntry
// 0x0018 (0x0018 - 0x0000)
struct FOrionGestureEntry final
{
public:
	TArray<EOrionGestureDirection>                GestureDirections;                                 // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UPCTeamCommunicationsData*              TeamCommData;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionGestureEntry) == 0x000008, "Wrong alignment on FOrionGestureEntry");
static_assert(sizeof(FOrionGestureEntry) == 0x000018, "Wrong size on FOrionGestureEntry");
static_assert(offsetof(FOrionGestureEntry, GestureDirections) == 0x000000, "Member 'FOrionGestureEntry::GestureDirections' has a wrong offset!");
static_assert(offsetof(FOrionGestureEntry, TeamCommData) == 0x000010, "Member 'FOrionGestureEntry::TeamCommData' has a wrong offset!");

// ScriptStruct OrionGame.BotKnowledgeHub
// 0x0110 (0x0110 - 0x0000)
struct alignas(0x10) FBotKnowledgeHub final
{
public:
	class UOrionAISystem*                         AISystem;                                          // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AOrionAIInfluenceMapManager*            CachedInfluenceMapManager;                         // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10[0x100];                                     // 0x0010(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBotKnowledgeHub) == 0x000010, "Wrong alignment on FBotKnowledgeHub");
static_assert(sizeof(FBotKnowledgeHub) == 0x000110, "Wrong size on FBotKnowledgeHub");
static_assert(offsetof(FBotKnowledgeHub, AISystem) == 0x000000, "Member 'FBotKnowledgeHub::AISystem' has a wrong offset!");
static_assert(offsetof(FBotKnowledgeHub, CachedInfluenceMapManager) == 0x000008, "Member 'FBotKnowledgeHub::CachedInfluenceMapManager' has a wrong offset!");

// ScriptStruct OrionGame.BotObjectiveDescription
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FBotObjectiveDescription
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBotObjectiveDescription) == 0x000008, "Wrong alignment on FBotObjectiveDescription");
static_assert(sizeof(FBotObjectiveDescription) == 0x000030, "Wrong size on FBotObjectiveDescription");

// ScriptStruct OrionGame.OrionItemQuantity
// 0x0030 (0x0030 - 0x0000)
struct FOrionItemQuantity final
{
public:
	TSoftObjectPtr<class UOrionMcpItemDefinition> ItemDefinition;                                    // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionItemQuantity) == 0x000008, "Wrong alignment on FOrionItemQuantity");
static_assert(sizeof(FOrionItemQuantity) == 0x000030, "Wrong size on FOrionItemQuantity");
static_assert(offsetof(FOrionItemQuantity, ItemDefinition) == 0x000000, "Member 'FOrionItemQuantity::ItemDefinition' has a wrong offset!");
static_assert(offsetof(FOrionItemQuantity, Quantity) == 0x000028, "Member 'FOrionItemQuantity::Quantity' has a wrong offset!");

// ScriptStruct OrionGame.GenericGameplayParameter_SimpleBase
// 0x0000 (0x0000 - 0x0000)
#pragma pack(push, 0x1)
struct alignas(0x01) FGenericGameplayParameter_SimpleBase
{
};
#pragma pack(pop)
static_assert(alignof(FGenericGameplayParameter_SimpleBase) == 0x000001, "Wrong alignment on FGenericGameplayParameter_SimpleBase");
static_assert(sizeof(FGenericGameplayParameter_SimpleBase) == 0x000001, "Wrong size on FGenericGameplayParameter_SimpleBase");

// ScriptStruct OrionGame.GameplayEffectParameter
// 0x0008 (0x0040 - 0x0038)
struct FGameplayEffectParameter final : public FAutoExportScalableFloat
{
public:
	struct FGameplayTag                           ParameterTag;                                      // 0x0038(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayEffectParameter) == 0x000008, "Wrong alignment on FGameplayEffectParameter");
static_assert(sizeof(FGameplayEffectParameter) == 0x000040, "Wrong size on FGameplayEffectParameter");
static_assert(offsetof(FGameplayEffectParameter, ParameterTag) == 0x000038, "Member 'FGameplayEffectParameter::ParameterTag' has a wrong offset!");

// ScriptStruct OrionGame.GenericGameplayParameter_GameplayEffectParameter
// 0x0040 (0x0040 - 0x0000)
struct FGenericGameplayParameter_GameplayEffectParameter final : public FGenericGameplayParameter_SimpleBase
{
public:
	struct FGameplayEffectParameter               Value;                                             // 0x0000(0x0040)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGenericGameplayParameter_GameplayEffectParameter) == 0x000008, "Wrong alignment on FGenericGameplayParameter_GameplayEffectParameter");
static_assert(sizeof(FGenericGameplayParameter_GameplayEffectParameter) == 0x000040, "Wrong size on FGenericGameplayParameter_GameplayEffectParameter");
static_assert(offsetof(FGenericGameplayParameter_GameplayEffectParameter, Value) == 0x000000, "Member 'FGenericGameplayParameter_GameplayEffectParameter::Value' has a wrong offset!");

// ScriptStruct OrionGame.BotObjectiveAgent
// 0x0010 (0x0010 - 0x0000)
struct FBotObjectiveAgent final
{
public:
	class AOrionAIBot*                            BotController;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionPlayerController_Game*            PlayerController;                                  // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBotObjectiveAgent) == 0x000008, "Wrong alignment on FBotObjectiveAgent");
static_assert(sizeof(FBotObjectiveAgent) == 0x000010, "Wrong size on FBotObjectiveAgent");
static_assert(offsetof(FBotObjectiveAgent, BotController) == 0x000000, "Member 'FBotObjectiveAgent::BotController' has a wrong offset!");
static_assert(offsetof(FBotObjectiveAgent, PlayerController) == 0x000008, "Member 'FBotObjectiveAgent::PlayerController' has a wrong offset!");

// ScriptStruct OrionGame.BotObjectivesArray
// 0x0010 (0x0010 - 0x0000)
struct FBotObjectivesArray final
{
public:
	TArray<class UBotObjective*>                  Objectives;                                        // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBotObjectivesArray) == 0x000008, "Wrong alignment on FBotObjectivesArray");
static_assert(sizeof(FBotObjectivesArray) == 0x000010, "Wrong size on FBotObjectivesArray");
static_assert(offsetof(FBotObjectivesArray, Objectives) == 0x000000, "Member 'FBotObjectivesArray::Objectives' has a wrong offset!");

// ScriptStruct OrionGame.BotTeamObjectives
// 0x0020 (0x0020 - 0x0000)
struct FBotTeamObjectives final
{
public:
	struct FBotObjectivesArray                    Teams[0x2];                                        // 0x0000(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FBotTeamObjectives) == 0x000008, "Wrong alignment on FBotTeamObjectives");
static_assert(sizeof(FBotTeamObjectives) == 0x000020, "Wrong size on FBotTeamObjectives");
static_assert(offsetof(FBotTeamObjectives, Teams) == 0x000000, "Member 'FBotTeamObjectives::Teams' has a wrong offset!");

// ScriptStruct OrionGame.SkinAnimMontagePair
// 0x0050 (0x0050 - 0x0000)
struct FSkinAnimMontagePair final
{
public:
	TSoftObjectPtr<class UOrionSkinItemDefinition> SkinDefinition;                                    // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            AnimMontage;                                       // 0x0028(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkinAnimMontagePair) == 0x000008, "Wrong alignment on FSkinAnimMontagePair");
static_assert(sizeof(FSkinAnimMontagePair) == 0x000050, "Wrong size on FSkinAnimMontagePair");
static_assert(offsetof(FSkinAnimMontagePair, SkinDefinition) == 0x000000, "Member 'FSkinAnimMontagePair::SkinDefinition' has a wrong offset!");
static_assert(offsetof(FSkinAnimMontagePair, AnimMontage) == 0x000028, "Member 'FSkinAnimMontagePair::AnimMontage' has a wrong offset!");

// ScriptStruct OrionGame.MMRWaitTime
// 0x0010 (0x0010 - 0x0000)
struct FMMRWaitTime final
{
public:
	int32                                         MMR;                                               // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimespan                              WaitTime;                                          // 0x0008(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMMRWaitTime) == 0x000008, "Wrong alignment on FMMRWaitTime");
static_assert(sizeof(FMMRWaitTime) == 0x000010, "Wrong size on FMMRWaitTime");
static_assert(offsetof(FMMRWaitTime, MMR) == 0x000000, "Member 'FMMRWaitTime::MMR' has a wrong offset!");
static_assert(offsetof(FMMRWaitTime, WaitTime) == 0x000008, "Member 'FMMRWaitTime::WaitTime' has a wrong offset!");

// ScriptStruct OrionGame.BotObjectiveGraphAuxNode
// 0x0010 (0x0010 - 0x0000)
struct FBotObjectiveGraphAuxNode final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LaneID;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIncludeInClosestNodeGrids : 1;                    // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBotObjectiveGraphAuxNode) == 0x000008, "Wrong alignment on FBotObjectiveGraphAuxNode");
static_assert(sizeof(FBotObjectiveGraphAuxNode) == 0x000010, "Wrong size on FBotObjectiveGraphAuxNode");
static_assert(offsetof(FBotObjectiveGraphAuxNode, Actor) == 0x000000, "Member 'FBotObjectiveGraphAuxNode::Actor' has a wrong offset!");
static_assert(offsetof(FBotObjectiveGraphAuxNode, LaneID) == 0x000008, "Member 'FBotObjectiveGraphAuxNode::LaneID' has a wrong offset!");

// ScriptStruct OrionGame.OrionLoadedDataCache
// 0x0030 (0x0030 - 0x0000)
struct FOrionLoadedDataCache final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        LoadedObjects;                                     // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionLoadedDataCache) == 0x000008, "Wrong alignment on FOrionLoadedDataCache");
static_assert(sizeof(FOrionLoadedDataCache) == 0x000030, "Wrong size on FOrionLoadedDataCache");
static_assert(offsetof(FOrionLoadedDataCache, LoadedObjects) == 0x000018, "Member 'FOrionLoadedDataCache::LoadedObjects' has a wrong offset!");

// ScriptStruct OrionGame.NavFieldLane
// 0x0020 (0x0020 - 0x0000)
struct FNavFieldLane final
{
public:
	TArray<struct FVector>                        KeyLocations;                                      // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	EOrionTeam                                    TeamNum;                                           // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bIsCircular : 1;                                   // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LaneID;                                            // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UniqueRouteId;                                     // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNavFieldLane) == 0x000008, "Wrong alignment on FNavFieldLane");
static_assert(sizeof(FNavFieldLane) == 0x000020, "Wrong size on FNavFieldLane");
static_assert(offsetof(FNavFieldLane, KeyLocations) == 0x000000, "Member 'FNavFieldLane::KeyLocations' has a wrong offset!");
static_assert(offsetof(FNavFieldLane, TeamNum) == 0x000010, "Member 'FNavFieldLane::TeamNum' has a wrong offset!");
static_assert(offsetof(FNavFieldLane, LaneID) == 0x000018, "Member 'FNavFieldLane::LaneID' has a wrong offset!");
static_assert(offsetof(FNavFieldLane, UniqueRouteId) == 0x00001C, "Member 'FNavFieldLane::UniqueRouteId' has a wrong offset!");

// ScriptStruct OrionGame.BotObjectiveGraphEdge
// 0x000C (0x000C - 0x0000)
struct FBotObjectiveGraphEdge final
{
public:
	int32                                         EndNodeIndex;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeDistance;                                      // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPruned;                                           // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBotObjectiveGraphEdge) == 0x000004, "Wrong alignment on FBotObjectiveGraphEdge");
static_assert(sizeof(FBotObjectiveGraphEdge) == 0x00000C, "Wrong size on FBotObjectiveGraphEdge");
static_assert(offsetof(FBotObjectiveGraphEdge, EndNodeIndex) == 0x000000, "Member 'FBotObjectiveGraphEdge::EndNodeIndex' has a wrong offset!");
static_assert(offsetof(FBotObjectiveGraphEdge, TimeDistance) == 0x000004, "Member 'FBotObjectiveGraphEdge::TimeDistance' has a wrong offset!");
static_assert(offsetof(FBotObjectiveGraphEdge, bPruned) == 0x000008, "Member 'FBotObjectiveGraphEdge::bPruned' has a wrong offset!");

// ScriptStruct OrionGame.BotObjectiveGraphNode
// 0x0050 (0x0050 - 0x0000)
struct FBotObjectiveGraphNode final
{
public:
	class UBotObjective*                          StaticBotObjectives[0x2];                          // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionBaseActor*                        ObjectiveActor;                                    // 0x0010(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectiveNodeType                            Type;                                              // 0x0018(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBotObjectiveGraphEdge>         Edges;                                             // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x4];                                       // 0x0030(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LaneID;                                            // 0x0034(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x4];                                       // 0x0038(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NodeLocation;                                      // 0x003C(0x000C)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsTeleportLocation : 1;                           // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsForcedLaneNode : 1;                             // 0x0048(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBotObjectiveGraphNode) == 0x000008, "Wrong alignment on FBotObjectiveGraphNode");
static_assert(sizeof(FBotObjectiveGraphNode) == 0x000050, "Wrong size on FBotObjectiveGraphNode");
static_assert(offsetof(FBotObjectiveGraphNode, StaticBotObjectives) == 0x000000, "Member 'FBotObjectiveGraphNode::StaticBotObjectives' has a wrong offset!");
static_assert(offsetof(FBotObjectiveGraphNode, ObjectiveActor) == 0x000010, "Member 'FBotObjectiveGraphNode::ObjectiveActor' has a wrong offset!");
static_assert(offsetof(FBotObjectiveGraphNode, Type) == 0x000018, "Member 'FBotObjectiveGraphNode::Type' has a wrong offset!");
static_assert(offsetof(FBotObjectiveGraphNode, Edges) == 0x000020, "Member 'FBotObjectiveGraphNode::Edges' has a wrong offset!");
static_assert(offsetof(FBotObjectiveGraphNode, LaneID) == 0x000034, "Member 'FBotObjectiveGraphNode::LaneID' has a wrong offset!");
static_assert(offsetof(FBotObjectiveGraphNode, NodeLocation) == 0x00003C, "Member 'FBotObjectiveGraphNode::NodeLocation' has a wrong offset!");

// ScriptStruct OrionGame.DraftStats_Phase
// 0x0030 (0x0030 - 0x0000)
struct FDraftStats_Phase final
{
public:
	int32                                         PhaseIdx;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamIndex;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PhaseDuration;                                     // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUniqueNetIdRepl>               Players;                                           // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDraftStats_Phase) == 0x000008, "Wrong alignment on FDraftStats_Phase");
static_assert(sizeof(FDraftStats_Phase) == 0x000030, "Wrong size on FDraftStats_Phase");
static_assert(offsetof(FDraftStats_Phase, PhaseIdx) == 0x000000, "Member 'FDraftStats_Phase::PhaseIdx' has a wrong offset!");
static_assert(offsetof(FDraftStats_Phase, TeamIndex) == 0x000004, "Member 'FDraftStats_Phase::TeamIndex' has a wrong offset!");
static_assert(offsetof(FDraftStats_Phase, PhaseDuration) == 0x000018, "Member 'FDraftStats_Phase::PhaseDuration' has a wrong offset!");
static_assert(offsetof(FDraftStats_Phase, Players) == 0x000020, "Member 'FDraftStats_Phase::Players' has a wrong offset!");

// ScriptStruct OrionGame.QualifierContextAggregated_GameplayEffect
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FQualifierContextAggregated_GameplayEffect final : public FQualifierContextBase
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQualifierContextAggregated_GameplayEffect) == 0x000008, "Wrong alignment on FQualifierContextAggregated_GameplayEffect");
static_assert(sizeof(FQualifierContextAggregated_GameplayEffect) == 0x000018, "Wrong size on FQualifierContextAggregated_GameplayEffect");

// ScriptStruct OrionGame.SimpleAbilityKeywordTag
// 0x0000 (0x0008 - 0x0008)
struct FSimpleAbilityKeywordTag final : public FGameplayTag
{
};
static_assert(alignof(FSimpleAbilityKeywordTag) == 0x000008, "Wrong alignment on FSimpleAbilityKeywordTag");
static_assert(sizeof(FSimpleAbilityKeywordTag) == 0x000008, "Wrong size on FSimpleAbilityKeywordTag");

// ScriptStruct OrionGame.ItemSetTag
// 0x0000 (0x0008 - 0x0008)
struct FItemSetTag final : public FGameplayTag
{
};
static_assert(alignof(FItemSetTag) == 0x000008, "Wrong alignment on FItemSetTag");
static_assert(sizeof(FItemSetTag) == 0x000008, "Wrong size on FItemSetTag");

// ScriptStruct OrionGame.GameItemDataRowBase
// 0x0008 (0x0010 - 0x0008)
struct FGameItemDataRowBase : public FTableRowBase
{
public:
	struct FItemSetTag                            Collection;                                        // 0x0008(0x0008)(Edit, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FGameItemDataRowBase) == 0x000008, "Wrong alignment on FGameItemDataRowBase");
static_assert(sizeof(FGameItemDataRowBase) == 0x000010, "Wrong size on FGameItemDataRowBase");
static_assert(offsetof(FGameItemDataRowBase, Collection) == 0x000008, "Member 'FGameItemDataRowBase::Collection' has a wrong offset!");

// ScriptStruct OrionGame.GemDataRow
// 0x0058 (0x0068 - 0x0010)
struct FGemDataRow final : public FGameItemDataRowBase
{
public:
	EOrionGemBranchType                           GemBranch;                                         // 0x0010(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSimpleAbilityKeywordTag               AbilityKeyword;                                    // 0x0018(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UOrionMcpGemKeywordBucketItemDefinition>> BucketDefs;                                        // 0x0020(0x0010)(Edit, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         Tier;                                              // 0x0030(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionGemType                                 Type;                                              // 0x0034(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Dexterity;                                         // 0x0035(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          Vitality;                                          // 0x0036(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          Intellect;                                         // 0x0037(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 Bucket1;                                           // 0x0038(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 Bucket2;                                           // 0x0048(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 Bucket3;                                           // 0x0058(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGemDataRow) == 0x000008, "Wrong alignment on FGemDataRow");
static_assert(sizeof(FGemDataRow) == 0x000068, "Wrong size on FGemDataRow");
static_assert(offsetof(FGemDataRow, GemBranch) == 0x000010, "Member 'FGemDataRow::GemBranch' has a wrong offset!");
static_assert(offsetof(FGemDataRow, AbilityKeyword) == 0x000018, "Member 'FGemDataRow::AbilityKeyword' has a wrong offset!");
static_assert(offsetof(FGemDataRow, BucketDefs) == 0x000020, "Member 'FGemDataRow::BucketDefs' has a wrong offset!");
static_assert(offsetof(FGemDataRow, Tier) == 0x000030, "Member 'FGemDataRow::Tier' has a wrong offset!");
static_assert(offsetof(FGemDataRow, Type) == 0x000034, "Member 'FGemDataRow::Type' has a wrong offset!");
static_assert(offsetof(FGemDataRow, Dexterity) == 0x000035, "Member 'FGemDataRow::Dexterity' has a wrong offset!");
static_assert(offsetof(FGemDataRow, Vitality) == 0x000036, "Member 'FGemDataRow::Vitality' has a wrong offset!");
static_assert(offsetof(FGemDataRow, Intellect) == 0x000037, "Member 'FGemDataRow::Intellect' has a wrong offset!");
static_assert(offsetof(FGemDataRow, Bucket1) == 0x000038, "Member 'FGemDataRow::Bucket1' has a wrong offset!");
static_assert(offsetof(FGemDataRow, Bucket2) == 0x000048, "Member 'FGemDataRow::Bucket2' has a wrong offset!");
static_assert(offsetof(FGemDataRow, Bucket3) == 0x000058, "Member 'FGemDataRow::Bucket3' has a wrong offset!");

// ScriptStruct OrionGame.OrionViewKickRangedValue
// 0x0008 (0x0008 - 0x0000)
struct FOrionViewKickRangedValue final
{
public:
	float                                         Min;                                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionViewKickRangedValue) == 0x000004, "Wrong alignment on FOrionViewKickRangedValue");
static_assert(sizeof(FOrionViewKickRangedValue) == 0x000008, "Wrong size on FOrionViewKickRangedValue");
static_assert(offsetof(FOrionViewKickRangedValue, Min) == 0x000000, "Member 'FOrionViewKickRangedValue::Min' has a wrong offset!");
static_assert(offsetof(FOrionViewKickRangedValue, Max) == 0x000004, "Member 'FOrionViewKickRangedValue::Max' has a wrong offset!");

// ScriptStruct OrionGame.BotObjectiveGraphForcedEdge
// 0x0018 (0x0018 - 0x0000)
struct FBotObjectiveGraphForcedEdge final
{
public:
	class AOrionBaseActor*                        StartNodeActor;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionBaseActor*                        EndNodeActor;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBotObjectiveGraphForcedEdge) == 0x000008, "Wrong alignment on FBotObjectiveGraphForcedEdge");
static_assert(sizeof(FBotObjectiveGraphForcedEdge) == 0x000018, "Wrong size on FBotObjectiveGraphForcedEdge");
static_assert(offsetof(FBotObjectiveGraphForcedEdge, StartNodeActor) == 0x000000, "Member 'FBotObjectiveGraphForcedEdge::StartNodeActor' has a wrong offset!");
static_assert(offsetof(FBotObjectiveGraphForcedEdge, EndNodeActor) == 0x000008, "Member 'FBotObjectiveGraphForcedEdge::EndNodeActor' has a wrong offset!");

// ScriptStruct OrionGame.BotObjectiveGraphDebugDrawingParams
// 0x0010 (0x0010 - 0x0000)
struct FBotObjectiveGraphDebugDrawingParams final
{
public:
	int32                                         DetailedNodeIndex;                                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBotObjectiveDebugDrawingMode                 DrawingMode;                                       // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bDisplayDetailNodeInfo : 1;                        // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawPrunedEdges : 1;                              // 0x0008(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawUnprunedEdges : 1;                            // 0x0008(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawGraphNodes : 1;                               // 0x0008(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawNodeIndexGrid : 1;                            // 0x0008(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawNormalizedInfluenceGraphLabels : 1;           // 0x0008(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawRawInfluenceGraphLabels : 1;                  // 0x0008(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawLaneLocation : 1;                             // 0x0008(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EObjectiveNodeTeam                            SingleTeamInfluence;                               // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectiveGraphProximityMode                  ProximityGridMode;                                 // 0x000D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBotObjectiveGraphDebugDrawingParams) == 0x000004, "Wrong alignment on FBotObjectiveGraphDebugDrawingParams");
static_assert(sizeof(FBotObjectiveGraphDebugDrawingParams) == 0x000010, "Wrong size on FBotObjectiveGraphDebugDrawingParams");
static_assert(offsetof(FBotObjectiveGraphDebugDrawingParams, DetailedNodeIndex) == 0x000000, "Member 'FBotObjectiveGraphDebugDrawingParams::DetailedNodeIndex' has a wrong offset!");
static_assert(offsetof(FBotObjectiveGraphDebugDrawingParams, DrawingMode) == 0x000004, "Member 'FBotObjectiveGraphDebugDrawingParams::DrawingMode' has a wrong offset!");
static_assert(offsetof(FBotObjectiveGraphDebugDrawingParams, SingleTeamInfluence) == 0x00000C, "Member 'FBotObjectiveGraphDebugDrawingParams::SingleTeamInfluence' has a wrong offset!");
static_assert(offsetof(FBotObjectiveGraphDebugDrawingParams, ProximityGridMode) == 0x00000D, "Member 'FBotObjectiveGraphDebugDrawingParams::ProximityGridMode' has a wrong offset!");

// ScriptStruct OrionGame.OrionHUDInputActionNames
// 0x0138 (0x0138 - 0x0000)
struct alignas(0x08) FOrionHUDInputActionNames final
{
public:
	class FName                                   ToggleMouseKeyName;                                // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ToggleCardMenuKeyName;                             // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CloseCardMenuKeyName;                              // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ToggleScoreboardKeyName;                           // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ToggleLargeMinimapKeyName;                         // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ToggleReplayScoreboardKeyName;                     // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OpenScoreboardKeyName;                             // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CloseScoreboardKeyName;                            // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ToggleEscapeMenuKeyName;                           // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IgnoreToggleScoreboardKeyName;                     // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ToggleTeamCommsMenuName;                           // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CloseTeamCommsMenuName;                            // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ToggleEmoteMenuName;                               // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TeamComms_Option_1;                                // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TeamComms_Option_2;                                // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TeamComms_Option_3;                                // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TeamComms_Option_4;                                // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TeamComms_Option_Commit;                           // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TeamComms_Option_Back;                             // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TeamComms_Option_Emote_Toggle;                     // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TeamComms_Option_AutoRun_Toggle;                   // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TabLeft;                                           // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TabRight;                                          // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CardTabLeft;                                       // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CardTabRight;                                      // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TrashItem;                                         // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SpectatorToggleControllerCursor;                   // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FreeCursorModePress;                               // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FreeCursorModeRelease;                             // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HUDCursorModePress;                                // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HUDCursorModeRelease;                              // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HUDCursorModeToggle;                               // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UpgradeButtonPress;                                // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UpgradeButtonRelease;                              // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ShowUpgradePanelPullTab;                           // 0x0110(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ToggleUpgradeAbilityModeKeyName;                   // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UpgradeAbilityModeKeyName;                         // 0x0120(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AbilityCancelKeyName;                              // 0x0128(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AbilityModifyKeyName;                              // 0x0130(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionHUDInputActionNames) == 0x000008, "Wrong alignment on FOrionHUDInputActionNames");
static_assert(sizeof(FOrionHUDInputActionNames) == 0x000138, "Wrong size on FOrionHUDInputActionNames");
static_assert(offsetof(FOrionHUDInputActionNames, ToggleMouseKeyName) == 0x000000, "Member 'FOrionHUDInputActionNames::ToggleMouseKeyName' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, ToggleCardMenuKeyName) == 0x000008, "Member 'FOrionHUDInputActionNames::ToggleCardMenuKeyName' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, CloseCardMenuKeyName) == 0x000010, "Member 'FOrionHUDInputActionNames::CloseCardMenuKeyName' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, ToggleScoreboardKeyName) == 0x000018, "Member 'FOrionHUDInputActionNames::ToggleScoreboardKeyName' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, ToggleLargeMinimapKeyName) == 0x000020, "Member 'FOrionHUDInputActionNames::ToggleLargeMinimapKeyName' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, ToggleReplayScoreboardKeyName) == 0x000028, "Member 'FOrionHUDInputActionNames::ToggleReplayScoreboardKeyName' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, OpenScoreboardKeyName) == 0x000030, "Member 'FOrionHUDInputActionNames::OpenScoreboardKeyName' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, CloseScoreboardKeyName) == 0x000038, "Member 'FOrionHUDInputActionNames::CloseScoreboardKeyName' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, ToggleEscapeMenuKeyName) == 0x000040, "Member 'FOrionHUDInputActionNames::ToggleEscapeMenuKeyName' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, IgnoreToggleScoreboardKeyName) == 0x000048, "Member 'FOrionHUDInputActionNames::IgnoreToggleScoreboardKeyName' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, ToggleTeamCommsMenuName) == 0x000050, "Member 'FOrionHUDInputActionNames::ToggleTeamCommsMenuName' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, CloseTeamCommsMenuName) == 0x000058, "Member 'FOrionHUDInputActionNames::CloseTeamCommsMenuName' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, ToggleEmoteMenuName) == 0x000060, "Member 'FOrionHUDInputActionNames::ToggleEmoteMenuName' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, TeamComms_Option_1) == 0x000068, "Member 'FOrionHUDInputActionNames::TeamComms_Option_1' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, TeamComms_Option_2) == 0x000070, "Member 'FOrionHUDInputActionNames::TeamComms_Option_2' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, TeamComms_Option_3) == 0x000078, "Member 'FOrionHUDInputActionNames::TeamComms_Option_3' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, TeamComms_Option_4) == 0x000080, "Member 'FOrionHUDInputActionNames::TeamComms_Option_4' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, TeamComms_Option_Commit) == 0x000088, "Member 'FOrionHUDInputActionNames::TeamComms_Option_Commit' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, TeamComms_Option_Back) == 0x000090, "Member 'FOrionHUDInputActionNames::TeamComms_Option_Back' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, TeamComms_Option_Emote_Toggle) == 0x000098, "Member 'FOrionHUDInputActionNames::TeamComms_Option_Emote_Toggle' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, TeamComms_Option_AutoRun_Toggle) == 0x0000A0, "Member 'FOrionHUDInputActionNames::TeamComms_Option_AutoRun_Toggle' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, TabLeft) == 0x0000A8, "Member 'FOrionHUDInputActionNames::TabLeft' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, TabRight) == 0x0000B0, "Member 'FOrionHUDInputActionNames::TabRight' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, CardTabLeft) == 0x0000B8, "Member 'FOrionHUDInputActionNames::CardTabLeft' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, CardTabRight) == 0x0000C0, "Member 'FOrionHUDInputActionNames::CardTabRight' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, TrashItem) == 0x0000C8, "Member 'FOrionHUDInputActionNames::TrashItem' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, SpectatorToggleControllerCursor) == 0x0000D0, "Member 'FOrionHUDInputActionNames::SpectatorToggleControllerCursor' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, FreeCursorModePress) == 0x0000D8, "Member 'FOrionHUDInputActionNames::FreeCursorModePress' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, FreeCursorModeRelease) == 0x0000E0, "Member 'FOrionHUDInputActionNames::FreeCursorModeRelease' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, HUDCursorModePress) == 0x0000E8, "Member 'FOrionHUDInputActionNames::HUDCursorModePress' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, HUDCursorModeRelease) == 0x0000F0, "Member 'FOrionHUDInputActionNames::HUDCursorModeRelease' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, HUDCursorModeToggle) == 0x0000F8, "Member 'FOrionHUDInputActionNames::HUDCursorModeToggle' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, UpgradeButtonPress) == 0x000100, "Member 'FOrionHUDInputActionNames::UpgradeButtonPress' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, UpgradeButtonRelease) == 0x000108, "Member 'FOrionHUDInputActionNames::UpgradeButtonRelease' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, ShowUpgradePanelPullTab) == 0x000110, "Member 'FOrionHUDInputActionNames::ShowUpgradePanelPullTab' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, ToggleUpgradeAbilityModeKeyName) == 0x000118, "Member 'FOrionHUDInputActionNames::ToggleUpgradeAbilityModeKeyName' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, UpgradeAbilityModeKeyName) == 0x000120, "Member 'FOrionHUDInputActionNames::UpgradeAbilityModeKeyName' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, AbilityCancelKeyName) == 0x000128, "Member 'FOrionHUDInputActionNames::AbilityCancelKeyName' has a wrong offset!");
static_assert(offsetof(FOrionHUDInputActionNames, AbilityModifyKeyName) == 0x000130, "Member 'FOrionHUDInputActionNames::AbilityModifyKeyName' has a wrong offset!");

// ScriptStruct OrionGame.OrionCardLevelTierInfo
// 0x0040 (0x0040 - 0x0000)
struct FOrionCardLevelTierInfo final
{
public:
	int32                                         MinLevel;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyFoilEffect;                                  // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     BigFlare;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     SmallFlare;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     RarityBorders[0x5];                                // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionCardLevelTierInfo) == 0x000008, "Wrong alignment on FOrionCardLevelTierInfo");
static_assert(sizeof(FOrionCardLevelTierInfo) == 0x000040, "Wrong size on FOrionCardLevelTierInfo");
static_assert(offsetof(FOrionCardLevelTierInfo, MinLevel) == 0x000000, "Member 'FOrionCardLevelTierInfo::MinLevel' has a wrong offset!");
static_assert(offsetof(FOrionCardLevelTierInfo, bApplyFoilEffect) == 0x000004, "Member 'FOrionCardLevelTierInfo::bApplyFoilEffect' has a wrong offset!");
static_assert(offsetof(FOrionCardLevelTierInfo, BigFlare) == 0x000008, "Member 'FOrionCardLevelTierInfo::BigFlare' has a wrong offset!");
static_assert(offsetof(FOrionCardLevelTierInfo, SmallFlare) == 0x000010, "Member 'FOrionCardLevelTierInfo::SmallFlare' has a wrong offset!");
static_assert(offsetof(FOrionCardLevelTierInfo, RarityBorders) == 0x000018, "Member 'FOrionCardLevelTierInfo::RarityBorders' has a wrong offset!");

// ScriptStruct OrionGame.DefaultTextureDataEntry
// 0x0010 (0x0010 - 0x0000)
struct FDefaultTextureDataEntry final
{
public:
	class FName                                   DefaultTextureName;                                // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             DefaultTexture;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDefaultTextureDataEntry) == 0x000008, "Wrong alignment on FDefaultTextureDataEntry");
static_assert(sizeof(FDefaultTextureDataEntry) == 0x000010, "Wrong size on FDefaultTextureDataEntry");
static_assert(offsetof(FDefaultTextureDataEntry, DefaultTextureName) == 0x000000, "Member 'FDefaultTextureDataEntry::DefaultTextureName' has a wrong offset!");
static_assert(offsetof(FDefaultTextureDataEntry, DefaultTexture) == 0x000008, "Member 'FDefaultTextureDataEntry::DefaultTexture' has a wrong offset!");

// ScriptStruct OrionGame.NetSyncAction
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x04) FNetSyncAction final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNetSyncAction) == 0x000004, "Wrong alignment on FNetSyncAction");
static_assert(sizeof(FNetSyncAction) == 0x000030, "Wrong size on FNetSyncAction");

// ScriptStruct OrionGame.SlopeWarpingFootDefinition
// 0x0050 (0x0050 - 0x0000)
struct FSlopeWarpingFootDefinition final
{
public:
	struct FBoneReference                         IKFootBone;                                        // 0x0000(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         FKFootBone;                                        // 0x0018(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         NumBonesInLimb;                                    // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ToeSocketName;                                     // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HeelSocketName;                                    // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootSize;                                          // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSlopeWarpingFootDefinition) == 0x000008, "Wrong alignment on FSlopeWarpingFootDefinition");
static_assert(sizeof(FSlopeWarpingFootDefinition) == 0x000050, "Wrong size on FSlopeWarpingFootDefinition");
static_assert(offsetof(FSlopeWarpingFootDefinition, IKFootBone) == 0x000000, "Member 'FSlopeWarpingFootDefinition::IKFootBone' has a wrong offset!");
static_assert(offsetof(FSlopeWarpingFootDefinition, FKFootBone) == 0x000018, "Member 'FSlopeWarpingFootDefinition::FKFootBone' has a wrong offset!");
static_assert(offsetof(FSlopeWarpingFootDefinition, NumBonesInLimb) == 0x000030, "Member 'FSlopeWarpingFootDefinition::NumBonesInLimb' has a wrong offset!");
static_assert(offsetof(FSlopeWarpingFootDefinition, ToeSocketName) == 0x000038, "Member 'FSlopeWarpingFootDefinition::ToeSocketName' has a wrong offset!");
static_assert(offsetof(FSlopeWarpingFootDefinition, HeelSocketName) == 0x000040, "Member 'FSlopeWarpingFootDefinition::HeelSocketName' has a wrong offset!");
static_assert(offsetof(FSlopeWarpingFootDefinition, FootSize) == 0x000048, "Member 'FSlopeWarpingFootDefinition::FootSize' has a wrong offset!");

// ScriptStruct OrionGame.SlopeWarpingFootData
// 0x00E0 (0x00E0 - 0x0000)
struct alignas(0x10) FSlopeWarpingFootData final
{
public:
	uint8                                         Pad_0[0xE0];                                       // 0x0000(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSlopeWarpingFootData) == 0x000010, "Wrong alignment on FSlopeWarpingFootData");
static_assert(sizeof(FSlopeWarpingFootData) == 0x0000E0, "Wrong size on FSlopeWarpingFootData");

// ScriptStruct OrionGame.OrionAnimNode_SlopeWarping
// 0x0168 (0x01D8 - 0x0070)
struct FOrionAnimNode_SlopeWarping final : public FAnimNode_SkeletalControlBase
{
public:
	uint8                                         Pad_70[0x18];                                      // 0x0070(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoneReference                         IKFootRootBone;                                    // 0x0088(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         PelvisBone;                                        // 0x00A0(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FSlopeWarpingFootDefinition>    FeetDefinitions;                                   // 0x00B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSlopeWarpingFootData>          FeetData;                                          // 0x00C8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	struct FVectorRK4SpringInterpolator           PelvisOffsetInterpolator;                          // 0x00D8(0x0008)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x34];                                      // 0x00E0(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                GravityDir;                                        // 0x0114(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CachedDeltaTime;                                   // 0x0120(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetFloorNormalWorldSpace;                       // 0x0124(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVectorRK4SpringInterpolator           FloorNormalInterpolator;                           // 0x0130(0x0008)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_138[0x34];                                     // 0x0138(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetFloorOffsetLocalSpace;                       // 0x016C(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVectorRK4SpringInterpolator           FloorOffsetInterpolator;                           // 0x0178(0x0008)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_180[0x34];                                     // 0x0180(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxStepHeight;                                     // 0x01B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCapsuleInfoInsteadOfFootTraces;                // 0x01B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasOnGround;                                      // 0x01B9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDebug;                                        // 0x01BA(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFloorSmoothingInitialized;                        // 0x01BB(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ActorLocation;                                     // 0x01BC(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GravityDirCompSpace;                               // 0x01C8(0x000C)(Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D4[0x4];                                      // 0x01D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionAnimNode_SlopeWarping) == 0x000008, "Wrong alignment on FOrionAnimNode_SlopeWarping");
static_assert(sizeof(FOrionAnimNode_SlopeWarping) == 0x0001D8, "Wrong size on FOrionAnimNode_SlopeWarping");
static_assert(offsetof(FOrionAnimNode_SlopeWarping, IKFootRootBone) == 0x000088, "Member 'FOrionAnimNode_SlopeWarping::IKFootRootBone' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SlopeWarping, PelvisBone) == 0x0000A0, "Member 'FOrionAnimNode_SlopeWarping::PelvisBone' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SlopeWarping, FeetDefinitions) == 0x0000B8, "Member 'FOrionAnimNode_SlopeWarping::FeetDefinitions' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SlopeWarping, FeetData) == 0x0000C8, "Member 'FOrionAnimNode_SlopeWarping::FeetData' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SlopeWarping, PelvisOffsetInterpolator) == 0x0000D8, "Member 'FOrionAnimNode_SlopeWarping::PelvisOffsetInterpolator' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SlopeWarping, GravityDir) == 0x000114, "Member 'FOrionAnimNode_SlopeWarping::GravityDir' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SlopeWarping, CachedDeltaTime) == 0x000120, "Member 'FOrionAnimNode_SlopeWarping::CachedDeltaTime' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SlopeWarping, TargetFloorNormalWorldSpace) == 0x000124, "Member 'FOrionAnimNode_SlopeWarping::TargetFloorNormalWorldSpace' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SlopeWarping, FloorNormalInterpolator) == 0x000130, "Member 'FOrionAnimNode_SlopeWarping::FloorNormalInterpolator' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SlopeWarping, TargetFloorOffsetLocalSpace) == 0x00016C, "Member 'FOrionAnimNode_SlopeWarping::TargetFloorOffsetLocalSpace' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SlopeWarping, FloorOffsetInterpolator) == 0x000178, "Member 'FOrionAnimNode_SlopeWarping::FloorOffsetInterpolator' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SlopeWarping, MaxStepHeight) == 0x0001B4, "Member 'FOrionAnimNode_SlopeWarping::MaxStepHeight' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SlopeWarping, bUseCapsuleInfoInsteadOfFootTraces) == 0x0001B8, "Member 'FOrionAnimNode_SlopeWarping::bUseCapsuleInfoInsteadOfFootTraces' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SlopeWarping, bWasOnGround) == 0x0001B9, "Member 'FOrionAnimNode_SlopeWarping::bWasOnGround' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SlopeWarping, bShowDebug) == 0x0001BA, "Member 'FOrionAnimNode_SlopeWarping::bShowDebug' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SlopeWarping, bFloorSmoothingInitialized) == 0x0001BB, "Member 'FOrionAnimNode_SlopeWarping::bFloorSmoothingInitialized' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SlopeWarping, ActorLocation) == 0x0001BC, "Member 'FOrionAnimNode_SlopeWarping::ActorLocation' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SlopeWarping, GravityDirCompSpace) == 0x0001C8, "Member 'FOrionAnimNode_SlopeWarping::GravityDirCompSpace' has a wrong offset!");

// ScriptStruct OrionGame.HeroDataCollection
// 0x0010 (0x0010 - 0x0000)
struct FHeroDataCollection final
{
public:
	TArray<class UOrionHeroData*>                 Collection;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHeroDataCollection) == 0x000008, "Wrong alignment on FHeroDataCollection");
static_assert(sizeof(FHeroDataCollection) == 0x000010, "Wrong size on FHeroDataCollection");
static_assert(offsetof(FHeroDataCollection, Collection) == 0x000000, "Member 'FHeroDataCollection::Collection' has a wrong offset!");

// ScriptStruct OrionGame.OrionMcpCardPackPreviewItem
// 0x0010 (0x0010 - 0x0000)
struct FOrionMcpCardPackPreviewItem final
{
public:
	class UOrionMcpItemDefinition*                ItemDefinition;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionMcpCardPackPreviewItem) == 0x000008, "Wrong alignment on FOrionMcpCardPackPreviewItem");
static_assert(sizeof(FOrionMcpCardPackPreviewItem) == 0x000010, "Wrong size on FOrionMcpCardPackPreviewItem");
static_assert(offsetof(FOrionMcpCardPackPreviewItem, ItemDefinition) == 0x000000, "Member 'FOrionMcpCardPackPreviewItem::ItemDefinition' has a wrong offset!");
static_assert(offsetof(FOrionMcpCardPackPreviewItem, Quantity) == 0x000008, "Member 'FOrionMcpCardPackPreviewItem::Quantity' has a wrong offset!");

// ScriptStruct OrionGame.CameraModeView
// 0x0028 (0x0028 - 0x0000)
struct FCameraModeView final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x000C(0x000C)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsFirstPerson;                                    // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FieldOfView;                                       // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMin;                                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMax;                                          // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraModeView) == 0x000004, "Wrong alignment on FCameraModeView");
static_assert(sizeof(FCameraModeView) == 0x000028, "Wrong size on FCameraModeView");
static_assert(offsetof(FCameraModeView, Location) == 0x000000, "Member 'FCameraModeView::Location' has a wrong offset!");
static_assert(offsetof(FCameraModeView, Rotation) == 0x00000C, "Member 'FCameraModeView::Rotation' has a wrong offset!");
static_assert(offsetof(FCameraModeView, bIsFirstPerson) == 0x000018, "Member 'FCameraModeView::bIsFirstPerson' has a wrong offset!");
static_assert(offsetof(FCameraModeView, FieldOfView) == 0x00001C, "Member 'FCameraModeView::FieldOfView' has a wrong offset!");
static_assert(offsetof(FCameraModeView, PitchMin) == 0x000020, "Member 'FCameraModeView::PitchMin' has a wrong offset!");
static_assert(offsetof(FCameraModeView, PitchMax) == 0x000024, "Member 'FCameraModeView::PitchMax' has a wrong offset!");

// ScriptStruct OrionGame.AIBotHandledTask
// 0x0028 (0x0028 - 0x0000)
struct FAIBotHandledTask final
{
public:
	class UOrionAbility*                          Ability;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityTask*                           TaskToActUpon;                                     // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 RelatedActor;                                      // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x10];                                      // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIBotHandledTask) == 0x000008, "Wrong alignment on FAIBotHandledTask");
static_assert(sizeof(FAIBotHandledTask) == 0x000028, "Wrong size on FAIBotHandledTask");
static_assert(offsetof(FAIBotHandledTask, Ability) == 0x000000, "Member 'FAIBotHandledTask::Ability' has a wrong offset!");
static_assert(offsetof(FAIBotHandledTask, TaskToActUpon) == 0x000008, "Member 'FAIBotHandledTask::TaskToActUpon' has a wrong offset!");
static_assert(offsetof(FAIBotHandledTask, RelatedActor) == 0x000010, "Member 'FAIBotHandledTask::RelatedActor' has a wrong offset!");

// ScriptStruct OrionGame.GemAbilityLevel_Param
// 0x000C (0x0010 - 0x0004)
struct FGemAbilityLevel_Param final : public FGemAbilityLevel
{
public:
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ParamTag;                                          // 0x0008(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGemAbilityLevel_Param) == 0x000008, "Wrong alignment on FGemAbilityLevel_Param");
static_assert(sizeof(FGemAbilityLevel_Param) == 0x000010, "Wrong size on FGemAbilityLevel_Param");
static_assert(offsetof(FGemAbilityLevel_Param, ParamTag) == 0x000008, "Member 'FGemAbilityLevel_Param::ParamTag' has a wrong offset!");

// ScriptStruct OrionGame.CardDataRow
// 0x0050 (0x0060 - 0x0010)
struct FCardDataRow final : public FGameItemDataRowBase
{
public:
	EAffinityType                                 Affinity;                                          // 0x0010(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EOrionItemRarity                              Rarity;                                            // 0x0011(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EOrionCardTraits                              CardTrait;                                         // 0x0012(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GoldCost;                                          // 0x0014(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         DexterityCost;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         VitalityCost;                                      // 0x001C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         IntellectCost;                                     // 0x0020(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSimpleAbilityKeywordTag               AbilityKeyword1;                                   // 0x0028(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSimpleAbilityKeywordTag               AbilityKeyword2;                                   // 0x0030(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSimpleAbilityKeywordTag               AbilityKeyword3;                                   // 0x0038(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BasePower;                                         // 0x0040(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BaseAttackSpeedRating;                             // 0x0044(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BaseMaxHealth;                                     // 0x0048(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BaseHealthRegen;                                   // 0x004C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BaseMaxEnergy;                                     // 0x0050(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BaseEnergyRegen;                                   // 0x0054(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BaseAbilityResistanceRating;                       // 0x0058(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BaseBasicResistanceRating;                         // 0x005C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FCardDataRow) == 0x000008, "Wrong alignment on FCardDataRow");
static_assert(sizeof(FCardDataRow) == 0x000060, "Wrong size on FCardDataRow");
static_assert(offsetof(FCardDataRow, Affinity) == 0x000010, "Member 'FCardDataRow::Affinity' has a wrong offset!");
static_assert(offsetof(FCardDataRow, Rarity) == 0x000011, "Member 'FCardDataRow::Rarity' has a wrong offset!");
static_assert(offsetof(FCardDataRow, CardTrait) == 0x000012, "Member 'FCardDataRow::CardTrait' has a wrong offset!");
static_assert(offsetof(FCardDataRow, GoldCost) == 0x000014, "Member 'FCardDataRow::GoldCost' has a wrong offset!");
static_assert(offsetof(FCardDataRow, DexterityCost) == 0x000018, "Member 'FCardDataRow::DexterityCost' has a wrong offset!");
static_assert(offsetof(FCardDataRow, VitalityCost) == 0x00001C, "Member 'FCardDataRow::VitalityCost' has a wrong offset!");
static_assert(offsetof(FCardDataRow, IntellectCost) == 0x000020, "Member 'FCardDataRow::IntellectCost' has a wrong offset!");
static_assert(offsetof(FCardDataRow, AbilityKeyword1) == 0x000028, "Member 'FCardDataRow::AbilityKeyword1' has a wrong offset!");
static_assert(offsetof(FCardDataRow, AbilityKeyword2) == 0x000030, "Member 'FCardDataRow::AbilityKeyword2' has a wrong offset!");
static_assert(offsetof(FCardDataRow, AbilityKeyword3) == 0x000038, "Member 'FCardDataRow::AbilityKeyword3' has a wrong offset!");
static_assert(offsetof(FCardDataRow, BasePower) == 0x000040, "Member 'FCardDataRow::BasePower' has a wrong offset!");
static_assert(offsetof(FCardDataRow, BaseAttackSpeedRating) == 0x000044, "Member 'FCardDataRow::BaseAttackSpeedRating' has a wrong offset!");
static_assert(offsetof(FCardDataRow, BaseMaxHealth) == 0x000048, "Member 'FCardDataRow::BaseMaxHealth' has a wrong offset!");
static_assert(offsetof(FCardDataRow, BaseHealthRegen) == 0x00004C, "Member 'FCardDataRow::BaseHealthRegen' has a wrong offset!");
static_assert(offsetof(FCardDataRow, BaseMaxEnergy) == 0x000050, "Member 'FCardDataRow::BaseMaxEnergy' has a wrong offset!");
static_assert(offsetof(FCardDataRow, BaseEnergyRegen) == 0x000054, "Member 'FCardDataRow::BaseEnergyRegen' has a wrong offset!");
static_assert(offsetof(FCardDataRow, BaseAbilityResistanceRating) == 0x000058, "Member 'FCardDataRow::BaseAbilityResistanceRating' has a wrong offset!");
static_assert(offsetof(FCardDataRow, BaseBasicResistanceRating) == 0x00005C, "Member 'FCardDataRow::BaseBasicResistanceRating' has a wrong offset!");

// ScriptStruct OrionGame.OrionObjectivesToCapture
// 0x0030 (0x0030 - 0x0000)
struct FOrionObjectivesToCapture final
{
public:
	TSubclassOf<class AActor>                     ObjectiveToLookFor;                                // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionCaptureResults                          CapturedResponse;                                  // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UGameplayEffect>>    GameplayEffectsToApply;                            // 0x0010(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	EOrionTeamCompare                             CaptureTeamCompareType;                            // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyToDeadPlayers;                               // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumTimesCaptured;                                  // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCapStacksAllowed;                               // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionObjectivesToCapture) == 0x000008, "Wrong alignment on FOrionObjectivesToCapture");
static_assert(sizeof(FOrionObjectivesToCapture) == 0x000030, "Wrong size on FOrionObjectivesToCapture");
static_assert(offsetof(FOrionObjectivesToCapture, ObjectiveToLookFor) == 0x000000, "Member 'FOrionObjectivesToCapture::ObjectiveToLookFor' has a wrong offset!");
static_assert(offsetof(FOrionObjectivesToCapture, CapturedResponse) == 0x000008, "Member 'FOrionObjectivesToCapture::CapturedResponse' has a wrong offset!");
static_assert(offsetof(FOrionObjectivesToCapture, GameplayEffectsToApply) == 0x000010, "Member 'FOrionObjectivesToCapture::GameplayEffectsToApply' has a wrong offset!");
static_assert(offsetof(FOrionObjectivesToCapture, CaptureTeamCompareType) == 0x000020, "Member 'FOrionObjectivesToCapture::CaptureTeamCompareType' has a wrong offset!");
static_assert(offsetof(FOrionObjectivesToCapture, bApplyToDeadPlayers) == 0x000021, "Member 'FOrionObjectivesToCapture::bApplyToDeadPlayers' has a wrong offset!");
static_assert(offsetof(FOrionObjectivesToCapture, NumTimesCaptured) == 0x000024, "Member 'FOrionObjectivesToCapture::NumTimesCaptured' has a wrong offset!");
static_assert(offsetof(FOrionObjectivesToCapture, MaxCapStacksAllowed) == 0x000028, "Member 'FOrionObjectivesToCapture::MaxCapStacksAllowed' has a wrong offset!");

// ScriptStruct OrionGame.OrionBasicDisplayInfo
// 0x0048 (0x0048 - 0x0000)
struct FOrionBasicDisplayInfo final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             DawnScreenshot;                                    // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             DuskScreenshot;                                    // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionBasicDisplayInfo) == 0x000008, "Wrong alignment on FOrionBasicDisplayInfo");
static_assert(sizeof(FOrionBasicDisplayInfo) == 0x000048, "Wrong size on FOrionBasicDisplayInfo");
static_assert(offsetof(FOrionBasicDisplayInfo, DisplayName) == 0x000000, "Member 'FOrionBasicDisplayInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(FOrionBasicDisplayInfo, Description) == 0x000018, "Member 'FOrionBasicDisplayInfo::Description' has a wrong offset!");
static_assert(offsetof(FOrionBasicDisplayInfo, Icon) == 0x000030, "Member 'FOrionBasicDisplayInfo::Icon' has a wrong offset!");
static_assert(offsetof(FOrionBasicDisplayInfo, DawnScreenshot) == 0x000038, "Member 'FOrionBasicDisplayInfo::DawnScreenshot' has a wrong offset!");
static_assert(offsetof(FOrionBasicDisplayInfo, DuskScreenshot) == 0x000040, "Member 'FOrionBasicDisplayInfo::DuskScreenshot' has a wrong offset!");

// ScriptStruct OrionGame.MatchmakingDisplayEntry
// 0x00B0 (0x00B0 - 0x0000)
struct FMatchmakingDisplayEntry final
{
public:
	int32                                         PlaylistId;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   GameTypeName;                                      // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   GameTypeDescription;                               // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            GameTypeIcon;                                      // 0x0038(0x0078)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchmakingDisplayEntry) == 0x000008, "Wrong alignment on FMatchmakingDisplayEntry");
static_assert(sizeof(FMatchmakingDisplayEntry) == 0x0000B0, "Wrong size on FMatchmakingDisplayEntry");
static_assert(offsetof(FMatchmakingDisplayEntry, PlaylistId) == 0x000000, "Member 'FMatchmakingDisplayEntry::PlaylistId' has a wrong offset!");
static_assert(offsetof(FMatchmakingDisplayEntry, GameTypeName) == 0x000008, "Member 'FMatchmakingDisplayEntry::GameTypeName' has a wrong offset!");
static_assert(offsetof(FMatchmakingDisplayEntry, GameTypeDescription) == 0x000020, "Member 'FMatchmakingDisplayEntry::GameTypeDescription' has a wrong offset!");
static_assert(offsetof(FMatchmakingDisplayEntry, GameTypeIcon) == 0x000038, "Member 'FMatchmakingDisplayEntry::GameTypeIcon' has a wrong offset!");

// ScriptStruct OrionGame.OrionTagTranslate
// 0x0010 (0x0010 - 0x0000)
struct FOrionTagTranslate final
{
public:
	struct FGameplayTag                           TagID;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TranslatedTagID;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionTagTranslate) == 0x000008, "Wrong alignment on FOrionTagTranslate");
static_assert(sizeof(FOrionTagTranslate) == 0x000010, "Wrong size on FOrionTagTranslate");
static_assert(offsetof(FOrionTagTranslate, TagID) == 0x000000, "Member 'FOrionTagTranslate::TagID' has a wrong offset!");
static_assert(offsetof(FOrionTagTranslate, TranslatedTagID) == 0x000008, "Member 'FOrionTagTranslate::TranslatedTagID' has a wrong offset!");

// ScriptStruct OrionGame.AxisKeyOverride
// 0x0040 (0x0040 - 0x0000)
struct FAxisKeyOverride final
{
public:
	class FName                                   BindingName;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   OldKey;                                            // 0x0010(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   NewKey;                                            // 0x0028(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAxisKeyOverride) == 0x000008, "Wrong alignment on FAxisKeyOverride");
static_assert(sizeof(FAxisKeyOverride) == 0x000040, "Wrong size on FAxisKeyOverride");
static_assert(offsetof(FAxisKeyOverride, BindingName) == 0x000000, "Member 'FAxisKeyOverride::BindingName' has a wrong offset!");
static_assert(offsetof(FAxisKeyOverride, Scale) == 0x000008, "Member 'FAxisKeyOverride::Scale' has a wrong offset!");
static_assert(offsetof(FAxisKeyOverride, OldKey) == 0x000010, "Member 'FAxisKeyOverride::OldKey' has a wrong offset!");
static_assert(offsetof(FAxisKeyOverride, NewKey) == 0x000028, "Member 'FAxisKeyOverride::NewKey' has a wrong offset!");

// ScriptStruct OrionGame.OrionJungleRefineryCues
// 0x0010 (0x0010 - 0x0000)
struct FOrionJungleRefineryCues final
{
public:
	struct FGameplayCueTag                        Collect;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        Release;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionJungleRefineryCues) == 0x000008, "Wrong alignment on FOrionJungleRefineryCues");
static_assert(sizeof(FOrionJungleRefineryCues) == 0x000010, "Wrong size on FOrionJungleRefineryCues");
static_assert(offsetof(FOrionJungleRefineryCues, Collect) == 0x000000, "Member 'FOrionJungleRefineryCues::Collect' has a wrong offset!");
static_assert(offsetof(FOrionJungleRefineryCues, Release) == 0x000008, "Member 'FOrionJungleRefineryCues::Release' has a wrong offset!");

// ScriptStruct OrionGame.GraphicsCardVendorEntry
// 0x0068 (0x0068 - 0x0000)
struct FGraphicsCardVendorEntry final
{
public:
	uint32                                        VendorID;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 VendorDisplayName;                                 // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x50];                                      // 0x0018(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGraphicsCardVendorEntry) == 0x000008, "Wrong alignment on FGraphicsCardVendorEntry");
static_assert(sizeof(FGraphicsCardVendorEntry) == 0x000068, "Wrong size on FGraphicsCardVendorEntry");
static_assert(offsetof(FGraphicsCardVendorEntry, VendorID) == 0x000000, "Member 'FGraphicsCardVendorEntry::VendorID' has a wrong offset!");
static_assert(offsetof(FGraphicsCardVendorEntry, VendorDisplayName) == 0x000008, "Member 'FGraphicsCardVendorEntry::VendorDisplayName' has a wrong offset!");

// ScriptStruct OrionGame.CardTraitInfo
// 0x0040 (0x0040 - 0x0000)
struct FCardTraitInfo final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   DisplayDescription;                                // 0x0018(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FLinearColor                           TextTint;                                          // 0x0030(0x0010)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCardTraitInfo) == 0x000008, "Wrong alignment on FCardTraitInfo");
static_assert(sizeof(FCardTraitInfo) == 0x000040, "Wrong size on FCardTraitInfo");
static_assert(offsetof(FCardTraitInfo, DisplayName) == 0x000000, "Member 'FCardTraitInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(FCardTraitInfo, DisplayDescription) == 0x000018, "Member 'FCardTraitInfo::DisplayDescription' has a wrong offset!");
static_assert(offsetof(FCardTraitInfo, TextTint) == 0x000030, "Member 'FCardTraitInfo::TextTint' has a wrong offset!");

// ScriptStruct OrionGame.ActionKeyOverride
// 0x0048 (0x0048 - 0x0000)
struct FActionKeyOverride final
{
public:
	class FName                                   BindingName;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputChord                            OldKey;                                            // 0x0008(0x0020)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputChord                            NewKey;                                            // 0x0028(0x0020)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActionKeyOverride) == 0x000008, "Wrong alignment on FActionKeyOverride");
static_assert(sizeof(FActionKeyOverride) == 0x000048, "Wrong size on FActionKeyOverride");
static_assert(offsetof(FActionKeyOverride, BindingName) == 0x000000, "Member 'FActionKeyOverride::BindingName' has a wrong offset!");
static_assert(offsetof(FActionKeyOverride, OldKey) == 0x000008, "Member 'FActionKeyOverride::OldKey' has a wrong offset!");
static_assert(offsetof(FActionKeyOverride, NewKey) == 0x000028, "Member 'FActionKeyOverride::NewKey' has a wrong offset!");

// ScriptStruct OrionGame.SkinVariantParamOverrides
// 0x0150 (0x0150 - 0x0000)
struct FSkinVariantParamOverrides final
{
public:
	TMap<class FName, struct FLinearColor>        ColorsByName;                                      // 0x0000(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      ScalarsByName;                                     // 0x0050(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, TSoftObjectPtr<class UTexture>> TexturesByName;                                    // 0x00A0(0x0050)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<TSoftObjectPtr<class UObject>, struct FParamIdMap> ParamIdMapsByOuter;                                // 0x00F0(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UTexture*>                       LoadedTextures;                                    // 0x0140(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkinVariantParamOverrides) == 0x000008, "Wrong alignment on FSkinVariantParamOverrides");
static_assert(sizeof(FSkinVariantParamOverrides) == 0x000150, "Wrong size on FSkinVariantParamOverrides");
static_assert(offsetof(FSkinVariantParamOverrides, ColorsByName) == 0x000000, "Member 'FSkinVariantParamOverrides::ColorsByName' has a wrong offset!");
static_assert(offsetof(FSkinVariantParamOverrides, ScalarsByName) == 0x000050, "Member 'FSkinVariantParamOverrides::ScalarsByName' has a wrong offset!");
static_assert(offsetof(FSkinVariantParamOverrides, TexturesByName) == 0x0000A0, "Member 'FSkinVariantParamOverrides::TexturesByName' has a wrong offset!");
static_assert(offsetof(FSkinVariantParamOverrides, ParamIdMapsByOuter) == 0x0000F0, "Member 'FSkinVariantParamOverrides::ParamIdMapsByOuter' has a wrong offset!");
static_assert(offsetof(FSkinVariantParamOverrides, LoadedTextures) == 0x000140, "Member 'FSkinVariantParamOverrides::LoadedTextures' has a wrong offset!");

// ScriptStruct OrionGame.FrontEndCamera
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FFrontEndCamera final
{
public:
	class FName                                   SceneName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TLazyObjectPtr<class ACameraActor>            SceneCamera;                                       // 0x0008(0x001C)(Edit, DisableEditOnTemplate, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFrontEndCamera) == 0x000008, "Wrong alignment on FFrontEndCamera");
static_assert(sizeof(FFrontEndCamera) == 0x000028, "Wrong size on FFrontEndCamera");
static_assert(offsetof(FFrontEndCamera, SceneName) == 0x000000, "Member 'FFrontEndCamera::SceneName' has a wrong offset!");
static_assert(offsetof(FFrontEndCamera, SceneCamera) == 0x000008, "Member 'FFrontEndCamera::SceneCamera' has a wrong offset!");

// ScriptStruct OrionGame.OrionMovementProfileData
// 0x0018 (0x0018 - 0x0000)
struct FOrionMovementProfileData final
{
public:
	EOrionHeroMovementProfile                     ProfileIndex;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxAcceleration;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakingDecelerationWalking;                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakingFrictionFactor;                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakingFriction;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundFriction;                                    // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionMovementProfileData) == 0x000004, "Wrong alignment on FOrionMovementProfileData");
static_assert(sizeof(FOrionMovementProfileData) == 0x000018, "Wrong size on FOrionMovementProfileData");
static_assert(offsetof(FOrionMovementProfileData, ProfileIndex) == 0x000000, "Member 'FOrionMovementProfileData::ProfileIndex' has a wrong offset!");
static_assert(offsetof(FOrionMovementProfileData, MaxAcceleration) == 0x000004, "Member 'FOrionMovementProfileData::MaxAcceleration' has a wrong offset!");
static_assert(offsetof(FOrionMovementProfileData, BrakingDecelerationWalking) == 0x000008, "Member 'FOrionMovementProfileData::BrakingDecelerationWalking' has a wrong offset!");
static_assert(offsetof(FOrionMovementProfileData, BrakingFrictionFactor) == 0x00000C, "Member 'FOrionMovementProfileData::BrakingFrictionFactor' has a wrong offset!");
static_assert(offsetof(FOrionMovementProfileData, BrakingFriction) == 0x000010, "Member 'FOrionMovementProfileData::BrakingFriction' has a wrong offset!");
static_assert(offsetof(FOrionMovementProfileData, GroundFriction) == 0x000014, "Member 'FOrionMovementProfileData::GroundFriction' has a wrong offset!");

// ScriptStruct OrionGame.RewardToSource
// 0x0020 (0x0028 - 0x0008)
struct FRewardToSource final : public FTableRowBase
{
public:
	class FString                                 PersistentName;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    RewardLocHandle;                                   // 0x0018(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRewardToSource) == 0x000008, "Wrong alignment on FRewardToSource");
static_assert(sizeof(FRewardToSource) == 0x000028, "Wrong size on FRewardToSource");
static_assert(offsetof(FRewardToSource, PersistentName) == 0x000008, "Member 'FRewardToSource::PersistentName' has a wrong offset!");
static_assert(offsetof(FRewardToSource, RewardLocHandle) == 0x000018, "Member 'FRewardToSource::RewardLocHandle' has a wrong offset!");

// ScriptStruct OrionGame.OrionIconTextureOverrides
// 0x0010 (0x0010 - 0x0000)
struct FOrionIconTextureOverrides final
{
public:
	struct FGameplayTag                           GameplayTag;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             TextureOverride;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionIconTextureOverrides) == 0x000008, "Wrong alignment on FOrionIconTextureOverrides");
static_assert(sizeof(FOrionIconTextureOverrides) == 0x000010, "Wrong size on FOrionIconTextureOverrides");
static_assert(offsetof(FOrionIconTextureOverrides, GameplayTag) == 0x000000, "Member 'FOrionIconTextureOverrides::GameplayTag' has a wrong offset!");
static_assert(offsetof(FOrionIconTextureOverrides, TextureOverride) == 0x000008, "Member 'FOrionIconTextureOverrides::TextureOverride' has a wrong offset!");

// ScriptStruct OrionGame.CardAffinityDisplayInfo
// 0x00D8 (0x00D8 - 0x0000)
struct FCardAffinityDisplayInfo final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0018(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     SimpleAffinityIcon;                                // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     TranslucentAffinityIcon;                           // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           NameBarTint;                                       // 0x0040(0x0010)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           GlowTint;                                          // 0x0050(0x0010)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            InnerFlourishBorder;                               // 0x0060(0x0078)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCardAffinityDisplayInfo) == 0x000008, "Wrong alignment on FCardAffinityDisplayInfo");
static_assert(sizeof(FCardAffinityDisplayInfo) == 0x0000D8, "Wrong size on FCardAffinityDisplayInfo");
static_assert(offsetof(FCardAffinityDisplayInfo, DisplayName) == 0x000000, "Member 'FCardAffinityDisplayInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(FCardAffinityDisplayInfo, Description) == 0x000018, "Member 'FCardAffinityDisplayInfo::Description' has a wrong offset!");
static_assert(offsetof(FCardAffinityDisplayInfo, SimpleAffinityIcon) == 0x000030, "Member 'FCardAffinityDisplayInfo::SimpleAffinityIcon' has a wrong offset!");
static_assert(offsetof(FCardAffinityDisplayInfo, TranslucentAffinityIcon) == 0x000038, "Member 'FCardAffinityDisplayInfo::TranslucentAffinityIcon' has a wrong offset!");
static_assert(offsetof(FCardAffinityDisplayInfo, NameBarTint) == 0x000040, "Member 'FCardAffinityDisplayInfo::NameBarTint' has a wrong offset!");
static_assert(offsetof(FCardAffinityDisplayInfo, GlowTint) == 0x000050, "Member 'FCardAffinityDisplayInfo::GlowTint' has a wrong offset!");
static_assert(offsetof(FCardAffinityDisplayInfo, InnerFlourishBorder) == 0x000060, "Member 'FCardAffinityDisplayInfo::InnerFlourishBorder' has a wrong offset!");

// ScriptStruct OrionGame.EquipCardData
// 0x0020 (0x0020 - 0x0000)
struct FEquipCardData final
{
public:
	class UOrionMcpCardItemDefinition*            Card;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Level;                                             // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Slot;                                              // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEquipCardData) == 0x000008, "Wrong alignment on FEquipCardData");
static_assert(sizeof(FEquipCardData) == 0x000020, "Wrong size on FEquipCardData");
static_assert(offsetof(FEquipCardData, Card) == 0x000000, "Member 'FEquipCardData::Card' has a wrong offset!");
static_assert(offsetof(FEquipCardData, Level) == 0x000018, "Member 'FEquipCardData::Level' has a wrong offset!");
static_assert(offsetof(FEquipCardData, Slot) == 0x00001C, "Member 'FEquipCardData::Slot' has a wrong offset!");

// ScriptStruct OrionGame.GameplayEffectKeywordTag
// 0x0000 (0x0008 - 0x0008)
struct FGameplayEffectKeywordTag final : public FGameplayTag
{
};
static_assert(alignof(FGameplayEffectKeywordTag) == 0x000008, "Wrong alignment on FGameplayEffectKeywordTag");
static_assert(sizeof(FGameplayEffectKeywordTag) == 0x000008, "Wrong size on FGameplayEffectKeywordTag");

// ScriptStruct OrionGame.ObjectiveDependencyBuff
// 0x0010 (0x0010 - 0x0000)
struct FObjectiveDependencyBuff final
{
public:
	TSubclassOf<class UGameplayEffect>            BuffGameplayEffect;                                // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            BuffHandle;                                        // 0x0008(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObjectiveDependencyBuff) == 0x000008, "Wrong alignment on FObjectiveDependencyBuff");
static_assert(sizeof(FObjectiveDependencyBuff) == 0x000010, "Wrong size on FObjectiveDependencyBuff");
static_assert(offsetof(FObjectiveDependencyBuff, BuffGameplayEffect) == 0x000000, "Member 'FObjectiveDependencyBuff::BuffGameplayEffect' has a wrong offset!");
static_assert(offsetof(FObjectiveDependencyBuff, BuffHandle) == 0x000008, "Member 'FObjectiveDependencyBuff::BuffHandle' has a wrong offset!");

// ScriptStruct OrionGame.ObjectiveDependency
// 0x0030 (0x0030 - 0x0000)
struct FObjectiveDependency final
{
public:
	TWeakObjectPtr<class AActor>                  DependencyActor;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectiveDependecyRelation                   Relationship;                                      // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FObjectiveDependencyBuff>       DependencyBuffs;                                   // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            DeathGameplayEffect;                               // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            DeathGameplayEffectHandle;                         // 0x0028(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObjectiveDependency) == 0x000008, "Wrong alignment on FObjectiveDependency");
static_assert(sizeof(FObjectiveDependency) == 0x000030, "Wrong size on FObjectiveDependency");
static_assert(offsetof(FObjectiveDependency, DependencyActor) == 0x000000, "Member 'FObjectiveDependency::DependencyActor' has a wrong offset!");
static_assert(offsetof(FObjectiveDependency, Relationship) == 0x000008, "Member 'FObjectiveDependency::Relationship' has a wrong offset!");
static_assert(offsetof(FObjectiveDependency, DependencyBuffs) == 0x000010, "Member 'FObjectiveDependency::DependencyBuffs' has a wrong offset!");
static_assert(offsetof(FObjectiveDependency, DeathGameplayEffect) == 0x000020, "Member 'FObjectiveDependency::DeathGameplayEffect' has a wrong offset!");
static_assert(offsetof(FObjectiveDependency, DeathGameplayEffectHandle) == 0x000028, "Member 'FObjectiveDependency::DeathGameplayEffectHandle' has a wrong offset!");

// ScriptStruct OrionGame.GameplayEffectKeywordData
// 0x0018 (0x0020 - 0x0008)
struct FGameplayEffectKeywordData final : public FTableRowBase
{
public:
	TSubclassOf<class UGameplayEffect>            GameplayEffect;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayEffectParameter>       EffectParameters;                                  // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGameplayEffectKeywordData) == 0x000008, "Wrong alignment on FGameplayEffectKeywordData");
static_assert(sizeof(FGameplayEffectKeywordData) == 0x000020, "Wrong size on FGameplayEffectKeywordData");
static_assert(offsetof(FGameplayEffectKeywordData, GameplayEffect) == 0x000008, "Member 'FGameplayEffectKeywordData::GameplayEffect' has a wrong offset!");
static_assert(offsetof(FGameplayEffectKeywordData, EffectParameters) == 0x000010, "Member 'FGameplayEffectKeywordData::EffectParameters' has a wrong offset!");

// ScriptStruct OrionGame.GameplayCueViewKickInfo
// 0x0008 (0x0008 - 0x0000)
struct FGameplayCueViewKickInfo final
{
public:
	TSubclassOf<class UOrionViewKick>             ViewKickClass;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayCueViewKickInfo) == 0x000008, "Wrong alignment on FGameplayCueViewKickInfo");
static_assert(sizeof(FGameplayCueViewKickInfo) == 0x000008, "Wrong size on FGameplayCueViewKickInfo");
static_assert(offsetof(FGameplayCueViewKickInfo, ViewKickClass) == 0x000000, "Member 'FGameplayCueViewKickInfo::ViewKickClass' has a wrong offset!");

// ScriptStruct OrionGame.GenericGameplayParameterTransform
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FGenericGameplayParameterTransform
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGenericGameplayParameterTransform) == 0x000008, "Wrong alignment on FGenericGameplayParameterTransform");
static_assert(sizeof(FGenericGameplayParameterTransform) == 0x000008, "Wrong size on FGenericGameplayParameterTransform");

// ScriptStruct OrionGame.IssuedFriendCode
// 0x0028 (0x0028 - 0x0000)
struct FIssuedFriendCode final
{
public:
	class FString                                 CodeId;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CodeType;                                          // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              DateCreated;                                       // 0x0020(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIssuedFriendCode) == 0x000008, "Wrong alignment on FIssuedFriendCode");
static_assert(sizeof(FIssuedFriendCode) == 0x000028, "Wrong size on FIssuedFriendCode");
static_assert(offsetof(FIssuedFriendCode, CodeId) == 0x000000, "Member 'FIssuedFriendCode::CodeId' has a wrong offset!");
static_assert(offsetof(FIssuedFriendCode, CodeType) == 0x000010, "Member 'FIssuedFriendCode::CodeType' has a wrong offset!");
static_assert(offsetof(FIssuedFriendCode, DateCreated) == 0x000020, "Member 'FIssuedFriendCode::DateCreated' has a wrong offset!");

// ScriptStruct OrionGame.GenericGameplayParameterTransform_AutoExportCurve
// 0x0188 (0x0190 - 0x0008)
struct FGenericGameplayParameterTransform_AutoExportCurve final : public FGenericGameplayParameterTransform
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGenericGameplayParameterDefinition    ParameterDefinition;                               // 0x0010(0x00C0)(NativeAccessSpecifierPrivate)
	struct FGenericGameplayParameterDefinition    LevelDefinition;                                   // 0x00D0(0x00C0)(NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGenericGameplayParameterTransform_AutoExportCurve) == 0x000010, "Wrong alignment on FGenericGameplayParameterTransform_AutoExportCurve");
static_assert(sizeof(FGenericGameplayParameterTransform_AutoExportCurve) == 0x000190, "Wrong size on FGenericGameplayParameterTransform_AutoExportCurve");
static_assert(offsetof(FGenericGameplayParameterTransform_AutoExportCurve, ParameterDefinition) == 0x000010, "Member 'FGenericGameplayParameterTransform_AutoExportCurve::ParameterDefinition' has a wrong offset!");
static_assert(offsetof(FGenericGameplayParameterTransform_AutoExportCurve, LevelDefinition) == 0x0000D0, "Member 'FGenericGameplayParameterTransform_AutoExportCurve::LevelDefinition' has a wrong offset!");

// ScriptStruct OrionGame.SaveDeckNotification
// 0x0010 (0x0010 - 0x0000)
struct FSaveDeckNotification final
{
public:
	class FString                                 DeckId;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSaveDeckNotification) == 0x000008, "Wrong alignment on FSaveDeckNotification");
static_assert(sizeof(FSaveDeckNotification) == 0x000010, "Wrong size on FSaveDeckNotification");
static_assert(offsetof(FSaveDeckNotification, DeckId) == 0x000000, "Member 'FSaveDeckNotification::DeckId' has a wrong offset!");

// ScriptStruct OrionGame.OrionDecalLibraryEntry
// 0x0030 (0x0030 - 0x0000)
struct FOrionDecalLibraryEntry final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Priority;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInTime;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutTime;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     Material;                                          // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionDecalOrientation                        Orientation;                                       // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SortOrder;                                         // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeScreenSize;                                    // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachToSkeletalMeshBone;                         // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionDecalLibraryEntry) == 0x000008, "Wrong alignment on FOrionDecalLibraryEntry");
static_assert(sizeof(FOrionDecalLibraryEntry) == 0x000030, "Wrong size on FOrionDecalLibraryEntry");
static_assert(offsetof(FOrionDecalLibraryEntry, Name) == 0x000000, "Member 'FOrionDecalLibraryEntry::Name' has a wrong offset!");
static_assert(offsetof(FOrionDecalLibraryEntry, Priority) == 0x000008, "Member 'FOrionDecalLibraryEntry::Priority' has a wrong offset!");
static_assert(offsetof(FOrionDecalLibraryEntry, FadeInTime) == 0x00000C, "Member 'FOrionDecalLibraryEntry::FadeInTime' has a wrong offset!");
static_assert(offsetof(FOrionDecalLibraryEntry, FadeOutTime) == 0x000010, "Member 'FOrionDecalLibraryEntry::FadeOutTime' has a wrong offset!");
static_assert(offsetof(FOrionDecalLibraryEntry, Material) == 0x000018, "Member 'FOrionDecalLibraryEntry::Material' has a wrong offset!");
static_assert(offsetof(FOrionDecalLibraryEntry, Orientation) == 0x000020, "Member 'FOrionDecalLibraryEntry::Orientation' has a wrong offset!");
static_assert(offsetof(FOrionDecalLibraryEntry, SortOrder) == 0x000024, "Member 'FOrionDecalLibraryEntry::SortOrder' has a wrong offset!");
static_assert(offsetof(FOrionDecalLibraryEntry, FadeScreenSize) == 0x000028, "Member 'FOrionDecalLibraryEntry::FadeScreenSize' has a wrong offset!");
static_assert(offsetof(FOrionDecalLibraryEntry, bAttachToSkeletalMeshBone) == 0x00002C, "Member 'FOrionDecalLibraryEntry::bAttachToSkeletalMeshBone' has a wrong offset!");

// ScriptStruct OrionGame.MinionSightData
// 0x0010 (0x0010 - 0x0000)
struct FMinionSightData final
{
public:
	class AOrionAIController_MinionBase*          AI;                                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMinionSightData) == 0x000008, "Wrong alignment on FMinionSightData");
static_assert(sizeof(FMinionSightData) == 0x000010, "Wrong size on FMinionSightData");
static_assert(offsetof(FMinionSightData, AI) == 0x000000, "Member 'FMinionSightData::AI' has a wrong offset!");

// ScriptStruct OrionGame.OrionGameGGPBundle
// 0x0000 (0x0130 - 0x0130)
struct FOrionGameGGPBundle final : public FGenericGameplayParameterBundle
{
};
static_assert(alignof(FOrionGameGGPBundle) == 0x000010, "Wrong alignment on FOrionGameGGPBundle");
static_assert(sizeof(FOrionGameGGPBundle) == 0x000130, "Wrong size on FOrionGameGGPBundle");

// ScriptStruct OrionGame.GameplayEffectWithParameters
// 0x0160 (0x0160 - 0x0000)
struct FGameplayEffectWithParameters final
{
public:
	TSubclassOf<class UGameplayEffect>            GameplayEffect;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayEffectParameter>       Parameters;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   ExpectedRownamePrefix;                             // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveTable*                            ExpectedCurveTable;                                // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionGameGGPBundle                    ParameterBundle;                                   // 0x0030(0x0130)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayEffectWithParameters) == 0x000010, "Wrong alignment on FGameplayEffectWithParameters");
static_assert(sizeof(FGameplayEffectWithParameters) == 0x000160, "Wrong size on FGameplayEffectWithParameters");
static_assert(offsetof(FGameplayEffectWithParameters, GameplayEffect) == 0x000000, "Member 'FGameplayEffectWithParameters::GameplayEffect' has a wrong offset!");
static_assert(offsetof(FGameplayEffectWithParameters, Parameters) == 0x000008, "Member 'FGameplayEffectWithParameters::Parameters' has a wrong offset!");
static_assert(offsetof(FGameplayEffectWithParameters, ExpectedRownamePrefix) == 0x000018, "Member 'FGameplayEffectWithParameters::ExpectedRownamePrefix' has a wrong offset!");
static_assert(offsetof(FGameplayEffectWithParameters, ExpectedCurveTable) == 0x000020, "Member 'FGameplayEffectWithParameters::ExpectedCurveTable' has a wrong offset!");
static_assert(offsetof(FGameplayEffectWithParameters, ParameterBundle) == 0x000030, "Member 'FGameplayEffectWithParameters::ParameterBundle' has a wrong offset!");

// ScriptStruct OrionGame.OrionMatchBotConfig
// 0x0028 (0x0028 - 0x0000)
struct FOrionMatchBotConfig final
{
public:
	EAIBotDifficulty                              FriendlyBotDifficulty;                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIBotDifficulty                              EnemyBotDifficulty;                                // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FriendlyBotHeroList;                               // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EnemyBotHeroList;                                  // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionMatchBotConfig) == 0x000008, "Wrong alignment on FOrionMatchBotConfig");
static_assert(sizeof(FOrionMatchBotConfig) == 0x000028, "Wrong size on FOrionMatchBotConfig");
static_assert(offsetof(FOrionMatchBotConfig, FriendlyBotDifficulty) == 0x000000, "Member 'FOrionMatchBotConfig::FriendlyBotDifficulty' has a wrong offset!");
static_assert(offsetof(FOrionMatchBotConfig, EnemyBotDifficulty) == 0x000001, "Member 'FOrionMatchBotConfig::EnemyBotDifficulty' has a wrong offset!");
static_assert(offsetof(FOrionMatchBotConfig, FriendlyBotHeroList) == 0x000008, "Member 'FOrionMatchBotConfig::FriendlyBotHeroList' has a wrong offset!");
static_assert(offsetof(FOrionMatchBotConfig, EnemyBotHeroList) == 0x000018, "Member 'FOrionMatchBotConfig::EnemyBotHeroList' has a wrong offset!");

// ScriptStruct OrionGame.OrionMatchConfig
// 0x0040 (0x0040 - 0x0000)
struct FOrionMatchConfig final
{
public:
	int32                                         PlaylistId;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamElo;                                           // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CustomKey;                                         // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionMatchBotConfig                   BotConfig;                                         // 0x0018(0x0028)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionMatchConfig) == 0x000008, "Wrong alignment on FOrionMatchConfig");
static_assert(sizeof(FOrionMatchConfig) == 0x000040, "Wrong size on FOrionMatchConfig");
static_assert(offsetof(FOrionMatchConfig, PlaylistId) == 0x000000, "Member 'FOrionMatchConfig::PlaylistId' has a wrong offset!");
static_assert(offsetof(FOrionMatchConfig, TeamElo) == 0x000004, "Member 'FOrionMatchConfig::TeamElo' has a wrong offset!");
static_assert(offsetof(FOrionMatchConfig, CustomKey) == 0x000008, "Member 'FOrionMatchConfig::CustomKey' has a wrong offset!");
static_assert(offsetof(FOrionMatchConfig, BotConfig) == 0x000018, "Member 'FOrionMatchConfig::BotConfig' has a wrong offset!");

// ScriptStruct OrionGame.MatchmakingParams
// 0x0098 (0x0098 - 0x0000)
struct FMatchmakingParams final
{
public:
	int32                                         ControllerId;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PartySize;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RegionId;                                          // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumAttempts;                                       // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CreateGameChance;                                  // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RerunSearchDelay;                                  // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RerunNoCreateDelay;                                // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NextResultDelay;                                   // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchFailureDelay;                                // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatchmakingFlags                             Flags;                                             // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionMatchConfig                      MatchConfig;                                       // 0x0038(0x0040)(NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x20];                                      // 0x0078(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMatchmakingParams) == 0x000008, "Wrong alignment on FMatchmakingParams");
static_assert(sizeof(FMatchmakingParams) == 0x000098, "Wrong size on FMatchmakingParams");
static_assert(offsetof(FMatchmakingParams, ControllerId) == 0x000000, "Member 'FMatchmakingParams::ControllerId' has a wrong offset!");
static_assert(offsetof(FMatchmakingParams, PartySize) == 0x000004, "Member 'FMatchmakingParams::PartySize' has a wrong offset!");
static_assert(offsetof(FMatchmakingParams, RegionId) == 0x000008, "Member 'FMatchmakingParams::RegionId' has a wrong offset!");
static_assert(offsetof(FMatchmakingParams, NumAttempts) == 0x000018, "Member 'FMatchmakingParams::NumAttempts' has a wrong offset!");
static_assert(offsetof(FMatchmakingParams, CreateGameChance) == 0x00001C, "Member 'FMatchmakingParams::CreateGameChance' has a wrong offset!");
static_assert(offsetof(FMatchmakingParams, RerunSearchDelay) == 0x000020, "Member 'FMatchmakingParams::RerunSearchDelay' has a wrong offset!");
static_assert(offsetof(FMatchmakingParams, RerunNoCreateDelay) == 0x000024, "Member 'FMatchmakingParams::RerunNoCreateDelay' has a wrong offset!");
static_assert(offsetof(FMatchmakingParams, NextResultDelay) == 0x000028, "Member 'FMatchmakingParams::NextResultDelay' has a wrong offset!");
static_assert(offsetof(FMatchmakingParams, SearchFailureDelay) == 0x00002C, "Member 'FMatchmakingParams::SearchFailureDelay' has a wrong offset!");
static_assert(offsetof(FMatchmakingParams, Flags) == 0x000030, "Member 'FMatchmakingParams::Flags' has a wrong offset!");
static_assert(offsetof(FMatchmakingParams, MatchConfig) == 0x000038, "Member 'FMatchmakingParams::MatchConfig' has a wrong offset!");

// ScriptStruct OrionGame.OrionShapeFacet
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FOrionShapeFacet
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionShapeFacet) == 0x000008, "Wrong alignment on FOrionShapeFacet");
static_assert(sizeof(FOrionShapeFacet) == 0x000010, "Wrong size on FOrionShapeFacet");

// ScriptStruct OrionGame.OrionShapeFacetBox
// 0x0030 (0x0040 - 0x0010)
struct FOrionShapeFacetBox final : public FOrionShapeFacet
{
public:
	uint8                                         Pad_10[0x30];                                      // 0x0010(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionShapeFacetBox) == 0x000008, "Wrong alignment on FOrionShapeFacetBox");
static_assert(sizeof(FOrionShapeFacetBox) == 0x000040, "Wrong size on FOrionShapeFacetBox");

// ScriptStruct OrionGame.OrionHUDTutorialWidgetNames
// 0x0100 (0x0100 - 0x0000)
struct alignas(0x08) FOrionHUDTutorialWidgetNames final
{
public:
	class FName                                   KDAWidget;                                         // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Core_Friendly;                                     // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Core_Enemy;                                        // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RespawnTimer;                                      // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MiniMap;                                           // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ChatWidget;                                        // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CardWidgets;                                       // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PlayerStatus;                                      // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AbilityWidgets;                                    // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DigitalFlame;                                      // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MiscAbilityWidget;                                 // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SprintWidget;                                      // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   JungleBuffs;                                       // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BuffWidgets;                                       // 0x0068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReticleWidget;                                     // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CombatMessages;                                    // 0x0078(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TopLeft;                                           // 0x0080(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TopCenter;                                         // 0x0088(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TopRight;                                          // 0x0090(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MiddleLeft;                                        // 0x0098(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MiddleCenter;                                      // 0x00A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MiddleRight;                                       // 0x00A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BottomLeft;                                        // 0x00B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BottomCenter;                                      // 0x00B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BottomRight;                                       // 0x00C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Ability_Q;                                         // 0x00C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Ability_E;                                         // 0x00D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Ability_R;                                         // 0x00D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Ability_LMB;                                       // 0x00E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Ability_RMB;                                       // 0x00E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AbilityUpgradePrompt;                              // 0x00F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   XPMeter;                                           // 0x00F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionHUDTutorialWidgetNames) == 0x000008, "Wrong alignment on FOrionHUDTutorialWidgetNames");
static_assert(sizeof(FOrionHUDTutorialWidgetNames) == 0x000100, "Wrong size on FOrionHUDTutorialWidgetNames");
static_assert(offsetof(FOrionHUDTutorialWidgetNames, KDAWidget) == 0x000000, "Member 'FOrionHUDTutorialWidgetNames::KDAWidget' has a wrong offset!");
static_assert(offsetof(FOrionHUDTutorialWidgetNames, Core_Friendly) == 0x000008, "Member 'FOrionHUDTutorialWidgetNames::Core_Friendly' has a wrong offset!");
static_assert(offsetof(FOrionHUDTutorialWidgetNames, Core_Enemy) == 0x000010, "Member 'FOrionHUDTutorialWidgetNames::Core_Enemy' has a wrong offset!");
static_assert(offsetof(FOrionHUDTutorialWidgetNames, RespawnTimer) == 0x000018, "Member 'FOrionHUDTutorialWidgetNames::RespawnTimer' has a wrong offset!");
static_assert(offsetof(FOrionHUDTutorialWidgetNames, MiniMap) == 0x000020, "Member 'FOrionHUDTutorialWidgetNames::MiniMap' has a wrong offset!");
static_assert(offsetof(FOrionHUDTutorialWidgetNames, ChatWidget) == 0x000028, "Member 'FOrionHUDTutorialWidgetNames::ChatWidget' has a wrong offset!");
static_assert(offsetof(FOrionHUDTutorialWidgetNames, CardWidgets) == 0x000030, "Member 'FOrionHUDTutorialWidgetNames::CardWidgets' has a wrong offset!");
static_assert(offsetof(FOrionHUDTutorialWidgetNames, PlayerStatus) == 0x000038, "Member 'FOrionHUDTutorialWidgetNames::PlayerStatus' has a wrong offset!");
static_assert(offsetof(FOrionHUDTutorialWidgetNames, AbilityWidgets) == 0x000040, "Member 'FOrionHUDTutorialWidgetNames::AbilityWidgets' has a wrong offset!");
static_assert(offsetof(FOrionHUDTutorialWidgetNames, DigitalFlame) == 0x000048, "Member 'FOrionHUDTutorialWidgetNames::DigitalFlame' has a wrong offset!");
static_assert(offsetof(FOrionHUDTutorialWidgetNames, MiscAbilityWidget) == 0x000050, "Member 'FOrionHUDTutorialWidgetNames::MiscAbilityWidget' has a wrong offset!");
static_assert(offsetof(FOrionHUDTutorialWidgetNames, SprintWidget) == 0x000058, "Member 'FOrionHUDTutorialWidgetNames::SprintWidget' has a wrong offset!");
static_assert(offsetof(FOrionHUDTutorialWidgetNames, JungleBuffs) == 0x000060, "Member 'FOrionHUDTutorialWidgetNames::JungleBuffs' has a wrong offset!");
static_assert(offsetof(FOrionHUDTutorialWidgetNames, BuffWidgets) == 0x000068, "Member 'FOrionHUDTutorialWidgetNames::BuffWidgets' has a wrong offset!");
static_assert(offsetof(FOrionHUDTutorialWidgetNames, ReticleWidget) == 0x000070, "Member 'FOrionHUDTutorialWidgetNames::ReticleWidget' has a wrong offset!");
static_assert(offsetof(FOrionHUDTutorialWidgetNames, CombatMessages) == 0x000078, "Member 'FOrionHUDTutorialWidgetNames::CombatMessages' has a wrong offset!");
static_assert(offsetof(FOrionHUDTutorialWidgetNames, TopLeft) == 0x000080, "Member 'FOrionHUDTutorialWidgetNames::TopLeft' has a wrong offset!");
static_assert(offsetof(FOrionHUDTutorialWidgetNames, TopCenter) == 0x000088, "Member 'FOrionHUDTutorialWidgetNames::TopCenter' has a wrong offset!");
static_assert(offsetof(FOrionHUDTutorialWidgetNames, TopRight) == 0x000090, "Member 'FOrionHUDTutorialWidgetNames::TopRight' has a wrong offset!");
static_assert(offsetof(FOrionHUDTutorialWidgetNames, MiddleLeft) == 0x000098, "Member 'FOrionHUDTutorialWidgetNames::MiddleLeft' has a wrong offset!");
static_assert(offsetof(FOrionHUDTutorialWidgetNames, MiddleCenter) == 0x0000A0, "Member 'FOrionHUDTutorialWidgetNames::MiddleCenter' has a wrong offset!");
static_assert(offsetof(FOrionHUDTutorialWidgetNames, MiddleRight) == 0x0000A8, "Member 'FOrionHUDTutorialWidgetNames::MiddleRight' has a wrong offset!");
static_assert(offsetof(FOrionHUDTutorialWidgetNames, BottomLeft) == 0x0000B0, "Member 'FOrionHUDTutorialWidgetNames::BottomLeft' has a wrong offset!");
static_assert(offsetof(FOrionHUDTutorialWidgetNames, BottomCenter) == 0x0000B8, "Member 'FOrionHUDTutorialWidgetNames::BottomCenter' has a wrong offset!");
static_assert(offsetof(FOrionHUDTutorialWidgetNames, BottomRight) == 0x0000C0, "Member 'FOrionHUDTutorialWidgetNames::BottomRight' has a wrong offset!");
static_assert(offsetof(FOrionHUDTutorialWidgetNames, Ability_Q) == 0x0000C8, "Member 'FOrionHUDTutorialWidgetNames::Ability_Q' has a wrong offset!");
static_assert(offsetof(FOrionHUDTutorialWidgetNames, Ability_E) == 0x0000D0, "Member 'FOrionHUDTutorialWidgetNames::Ability_E' has a wrong offset!");
static_assert(offsetof(FOrionHUDTutorialWidgetNames, Ability_R) == 0x0000D8, "Member 'FOrionHUDTutorialWidgetNames::Ability_R' has a wrong offset!");
static_assert(offsetof(FOrionHUDTutorialWidgetNames, Ability_LMB) == 0x0000E0, "Member 'FOrionHUDTutorialWidgetNames::Ability_LMB' has a wrong offset!");
static_assert(offsetof(FOrionHUDTutorialWidgetNames, Ability_RMB) == 0x0000E8, "Member 'FOrionHUDTutorialWidgetNames::Ability_RMB' has a wrong offset!");
static_assert(offsetof(FOrionHUDTutorialWidgetNames, AbilityUpgradePrompt) == 0x0000F0, "Member 'FOrionHUDTutorialWidgetNames::AbilityUpgradePrompt' has a wrong offset!");
static_assert(offsetof(FOrionHUDTutorialWidgetNames, XPMeter) == 0x0000F8, "Member 'FOrionHUDTutorialWidgetNames::XPMeter' has a wrong offset!");

// ScriptStruct OrionGame.GameplayCueTraceSpawnInfo
// 0x0028 (0x0028 - 0x0000)
struct FGameplayCueTraceSpawnInfo final
{
public:
	class UParticleSystem*                        ParticleSystem;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bParticleSystemCastShadow;                         // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ADecalActor>                Decal;                                             // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DecalScale;                                        // 0x0018(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionGameplayCueTraceOrientation             SpawnOrientation;                                  // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayCueTraceSpawnInfo) == 0x000008, "Wrong alignment on FGameplayCueTraceSpawnInfo");
static_assert(sizeof(FGameplayCueTraceSpawnInfo) == 0x000028, "Wrong size on FGameplayCueTraceSpawnInfo");
static_assert(offsetof(FGameplayCueTraceSpawnInfo, ParticleSystem) == 0x000000, "Member 'FGameplayCueTraceSpawnInfo::ParticleSystem' has a wrong offset!");
static_assert(offsetof(FGameplayCueTraceSpawnInfo, bParticleSystemCastShadow) == 0x000008, "Member 'FGameplayCueTraceSpawnInfo::bParticleSystemCastShadow' has a wrong offset!");
static_assert(offsetof(FGameplayCueTraceSpawnInfo, Decal) == 0x000010, "Member 'FGameplayCueTraceSpawnInfo::Decal' has a wrong offset!");
static_assert(offsetof(FGameplayCueTraceSpawnInfo, DecalScale) == 0x000018, "Member 'FGameplayCueTraceSpawnInfo::DecalScale' has a wrong offset!");
static_assert(offsetof(FGameplayCueTraceSpawnInfo, SpawnOrientation) == 0x000024, "Member 'FGameplayCueTraceSpawnInfo::SpawnOrientation' has a wrong offset!");

// ScriptStruct OrionGame.ParticleSystemPoolElem
// 0x0020 (0x0020 - 0x0000)
struct FParticleSystemPoolElem final
{
public:
	TArray<class UParticleSystemComponent*>       PSComponents;                                      // 0x0000(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FParticleSystemPoolElem) == 0x000008, "Wrong alignment on FParticleSystemPoolElem");
static_assert(sizeof(FParticleSystemPoolElem) == 0x000020, "Wrong size on FParticleSystemPoolElem");
static_assert(offsetof(FParticleSystemPoolElem, PSComponents) == 0x000000, "Member 'FParticleSystemPoolElem::PSComponents' has a wrong offset!");

// ScriptStruct OrionGame.QualifierContext_AttributeChange
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FQualifierContext_AttributeChange final : public FQualifierContextBase
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQualifierContext_AttributeChange) == 0x000008, "Wrong alignment on FQualifierContext_AttributeChange");
static_assert(sizeof(FQualifierContext_AttributeChange) == 0x000028, "Wrong size on FQualifierContext_AttributeChange");

// ScriptStruct OrionGame.GameplayCueTrailInfo
// 0x0008 (0x0008 - 0x0000)
struct FGameplayCueTrailInfo final
{
public:
	class UOrionAnimNotifyState_TrailEffectTeamAdjusted* TrailNotify;                                       // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayCueTrailInfo) == 0x000008, "Wrong alignment on FGameplayCueTrailInfo");
static_assert(sizeof(FGameplayCueTrailInfo) == 0x000008, "Wrong size on FGameplayCueTrailInfo");
static_assert(offsetof(FGameplayCueTrailInfo, TrailNotify) == 0x000000, "Member 'FGameplayCueTrailInfo::TrailNotify' has a wrong offset!");

// ScriptStruct OrionGame.OrionMockGameItemKeywordData
// 0x0010 (0x0010 - 0x0000)
struct FOrionMockGameItemKeywordData final
{
public:
	TArray<struct FGenericGameplayParameterDefinition> MyParameters;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionMockGameItemKeywordData) == 0x000008, "Wrong alignment on FOrionMockGameItemKeywordData");
static_assert(sizeof(FOrionMockGameItemKeywordData) == 0x000010, "Wrong size on FOrionMockGameItemKeywordData");
static_assert(offsetof(FOrionMockGameItemKeywordData, MyParameters) == 0x000000, "Member 'FOrionMockGameItemKeywordData::MyParameters' has a wrong offset!");

// ScriptStruct OrionGame.GenericGameplayParameterTransform_SimpleFloatMath
// 0x0248 (0x0250 - 0x0008)
struct FGenericGameplayParameterTransform_SimpleFloatMath final : public FGenericGameplayParameterTransform
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGenericGameplayParameterDefinition    BaseValue;                                         // 0x0010(0x00C0)(NativeAccessSpecifierPrivate)
	struct FGenericGameplayParameterDefinition    Operator;                                          // 0x00D0(0x00C0)(NativeAccessSpecifierPrivate)
	struct FGenericGameplayParameterDefinition    Operand;                                           // 0x0190(0x00C0)(NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGenericGameplayParameterTransform_SimpleFloatMath) == 0x000010, "Wrong alignment on FGenericGameplayParameterTransform_SimpleFloatMath");
static_assert(sizeof(FGenericGameplayParameterTransform_SimpleFloatMath) == 0x000250, "Wrong size on FGenericGameplayParameterTransform_SimpleFloatMath");
static_assert(offsetof(FGenericGameplayParameterTransform_SimpleFloatMath, BaseValue) == 0x000010, "Member 'FGenericGameplayParameterTransform_SimpleFloatMath::BaseValue' has a wrong offset!");
static_assert(offsetof(FGenericGameplayParameterTransform_SimpleFloatMath, Operator) == 0x0000D0, "Member 'FGenericGameplayParameterTransform_SimpleFloatMath::Operator' has a wrong offset!");
static_assert(offsetof(FGenericGameplayParameterTransform_SimpleFloatMath, Operand) == 0x000190, "Member 'FGenericGameplayParameterTransform_SimpleFloatMath::Operand' has a wrong offset!");

// ScriptStruct OrionGame.OrionTeamCompDebugSlot
// 0x0020 (0x0020 - 0x0000)
struct FOrionTeamCompDebugSlot final
{
public:
	int32                                         SlotIdx;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeamCompDebugSlotStatus                 Status;                                            // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 HeroName;                                          // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionRole                                    SelectedRole;                                      // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SelectedRoleWeight;                                // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionTeamCompDebugSlot) == 0x000008, "Wrong alignment on FOrionTeamCompDebugSlot");
static_assert(sizeof(FOrionTeamCompDebugSlot) == 0x000020, "Wrong size on FOrionTeamCompDebugSlot");
static_assert(offsetof(FOrionTeamCompDebugSlot, SlotIdx) == 0x000000, "Member 'FOrionTeamCompDebugSlot::SlotIdx' has a wrong offset!");
static_assert(offsetof(FOrionTeamCompDebugSlot, Status) == 0x000004, "Member 'FOrionTeamCompDebugSlot::Status' has a wrong offset!");
static_assert(offsetof(FOrionTeamCompDebugSlot, HeroName) == 0x000008, "Member 'FOrionTeamCompDebugSlot::HeroName' has a wrong offset!");
static_assert(offsetof(FOrionTeamCompDebugSlot, SelectedRole) == 0x000018, "Member 'FOrionTeamCompDebugSlot::SelectedRole' has a wrong offset!");
static_assert(offsetof(FOrionTeamCompDebugSlot, SelectedRoleWeight) == 0x00001C, "Member 'FOrionTeamCompDebugSlot::SelectedRoleWeight' has a wrong offset!");

// ScriptStruct OrionGame.ConstellationNodeConnections
// 0x0018 (0x0018 - 0x0000)
struct FConstellationNodeConnections final
{
public:
	int32                                         SourceNodeIdx;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ConnectedNodeIndices;                              // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConstellationNodeConnections) == 0x000008, "Wrong alignment on FConstellationNodeConnections");
static_assert(sizeof(FConstellationNodeConnections) == 0x000018, "Wrong size on FConstellationNodeConnections");
static_assert(offsetof(FConstellationNodeConnections, SourceNodeIdx) == 0x000000, "Member 'FConstellationNodeConnections::SourceNodeIdx' has a wrong offset!");
static_assert(offsetof(FConstellationNodeConnections, ConnectedNodeIndices) == 0x000008, "Member 'FConstellationNodeConnections::ConnectedNodeIndices' has a wrong offset!");

// ScriptStruct OrionGame.ConstellationDrawPhase
// 0x0010 (0x0010 - 0x0000)
struct FConstellationDrawPhase final
{
public:
	TArray<struct FConstellationNodeConnections>  ConnectionsInPhase;                                // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConstellationDrawPhase) == 0x000008, "Wrong alignment on FConstellationDrawPhase");
static_assert(sizeof(FConstellationDrawPhase) == 0x000010, "Wrong size on FConstellationDrawPhase");
static_assert(offsetof(FConstellationDrawPhase, ConnectionsInPhase) == 0x000000, "Member 'FConstellationDrawPhase::ConnectionsInPhase' has a wrong offset!");

// ScriptStruct OrionGame.OrionItemQuantityPair
// 0x0030 (0x0030 - 0x0000)
struct FOrionItemQuantityPair final
{
public:
	TSoftObjectPtr<class UOrionMcpItemDefinition> ItemDefinition;                                    // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionItemQuantityPair) == 0x000008, "Wrong alignment on FOrionItemQuantityPair");
static_assert(sizeof(FOrionItemQuantityPair) == 0x000030, "Wrong size on FOrionItemQuantityPair");
static_assert(offsetof(FOrionItemQuantityPair, ItemDefinition) == 0x000000, "Member 'FOrionItemQuantityPair::ItemDefinition' has a wrong offset!");
static_assert(offsetof(FOrionItemQuantityPair, Quantity) == 0x000028, "Member 'FOrionItemQuantityPair::Quantity' has a wrong offset!");

// ScriptStruct OrionGame.ClashMobThreshold
// 0x0020 (0x0020 - 0x0000)
struct FClashMobThreshold final
{
public:
	EClashMobSocialType                           SocialType;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         Count;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOrionItemQuantityPair>         Rewards;                                           // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FClashMobThreshold) == 0x000008, "Wrong alignment on FClashMobThreshold");
static_assert(sizeof(FClashMobThreshold) == 0x000020, "Wrong size on FClashMobThreshold");
static_assert(offsetof(FClashMobThreshold, SocialType) == 0x000000, "Member 'FClashMobThreshold::SocialType' has a wrong offset!");
static_assert(offsetof(FClashMobThreshold, Count) == 0x000008, "Member 'FClashMobThreshold::Count' has a wrong offset!");
static_assert(offsetof(FClashMobThreshold, Rewards) == 0x000010, "Member 'FClashMobThreshold::Rewards' has a wrong offset!");

// ScriptStruct OrionGame.GenericGameplayParameter_SimpleMathOperator
// 0x0001 (0x0001 - 0x0000)
struct FGenericGameplayParameter_SimpleMathOperator final
{
public:
	EGGPSimpleMathOperator                        Operator;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGenericGameplayParameter_SimpleMathOperator) == 0x000001, "Wrong alignment on FGenericGameplayParameter_SimpleMathOperator");
static_assert(sizeof(FGenericGameplayParameter_SimpleMathOperator) == 0x000001, "Wrong size on FGenericGameplayParameter_SimpleMathOperator");
static_assert(offsetof(FGenericGameplayParameter_SimpleMathOperator, Operator) == 0x000000, "Member 'FGenericGameplayParameter_SimpleMathOperator::Operator' has a wrong offset!");

// ScriptStruct OrionGame.GenericGameplayParameterTransform_FloatToCurve
// 0x0248 (0x0250 - 0x0008)
struct alignas(0x10) FGenericGameplayParameterTransform_FloatToCurve final : public FGenericGameplayParameterTransform
{
public:
	uint8                                         Pad_8[0x248];                                      // 0x0008(0x0248)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGenericGameplayParameterTransform_FloatToCurve) == 0x000010, "Wrong alignment on FGenericGameplayParameterTransform_FloatToCurve");
static_assert(sizeof(FGenericGameplayParameterTransform_FloatToCurve) == 0x000250, "Wrong size on FGenericGameplayParameterTransform_FloatToCurve");

// ScriptStruct OrionGame.GenericGameplayParameter_Text
// 0x0018 (0x0018 - 0x0000)
struct FGenericGameplayParameter_Text final : public FGenericGameplayParameter_SimpleBase
{
public:
	class FText                                   Value;                                             // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGenericGameplayParameter_Text) == 0x000008, "Wrong alignment on FGenericGameplayParameter_Text");
static_assert(sizeof(FGenericGameplayParameter_Text) == 0x000018, "Wrong size on FGenericGameplayParameter_Text");
static_assert(offsetof(FGenericGameplayParameter_Text, Value) == 0x000000, "Member 'FGenericGameplayParameter_Text::Value' has a wrong offset!");

// ScriptStruct OrionGame.GenericGameplayParameter_GameplayTag
// 0x0008 (0x0008 - 0x0000)
struct FGenericGameplayParameter_GameplayTag final : public FGenericGameplayParameter_SimpleBase
{
public:
	struct FGameplayTag                           Value;                                             // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGenericGameplayParameter_GameplayTag) == 0x000008, "Wrong alignment on FGenericGameplayParameter_GameplayTag");
static_assert(sizeof(FGenericGameplayParameter_GameplayTag) == 0x000008, "Wrong size on FGenericGameplayParameter_GameplayTag");
static_assert(offsetof(FGenericGameplayParameter_GameplayTag, Value) == 0x000000, "Member 'FGenericGameplayParameter_GameplayTag::Value' has a wrong offset!");

// ScriptStruct OrionGame.CameraAutoCharacterOffsets
// 0x0014 (0x0014 - 0x0000)
struct FCameraAutoCharacterOffsets final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseHorizontalFov;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AboveCapsuleFov;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BelowCapsuleFov;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SideCapsuleFov;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraAutoCharacterOffsets) == 0x000004, "Wrong alignment on FCameraAutoCharacterOffsets");
static_assert(sizeof(FCameraAutoCharacterOffsets) == 0x000014, "Wrong size on FCameraAutoCharacterOffsets");
static_assert(offsetof(FCameraAutoCharacterOffsets, bEnabled) == 0x000000, "Member 'FCameraAutoCharacterOffsets::bEnabled' has a wrong offset!");
static_assert(offsetof(FCameraAutoCharacterOffsets, BaseHorizontalFov) == 0x000004, "Member 'FCameraAutoCharacterOffsets::BaseHorizontalFov' has a wrong offset!");
static_assert(offsetof(FCameraAutoCharacterOffsets, AboveCapsuleFov) == 0x000008, "Member 'FCameraAutoCharacterOffsets::AboveCapsuleFov' has a wrong offset!");
static_assert(offsetof(FCameraAutoCharacterOffsets, BelowCapsuleFov) == 0x00000C, "Member 'FCameraAutoCharacterOffsets::BelowCapsuleFov' has a wrong offset!");
static_assert(offsetof(FCameraAutoCharacterOffsets, SideCapsuleFov) == 0x000010, "Member 'FCameraAutoCharacterOffsets::SideCapsuleFov' has a wrong offset!");

// ScriptStruct OrionGame.GenericGameplayParameter_CurveTableRowHandle
// 0x0010 (0x0010 - 0x0000)
struct FGenericGameplayParameter_CurveTableRowHandle final : public FGenericGameplayParameter_SimpleBase
{
public:
	struct FCurveTableRowHandle                   Value;                                             // 0x0000(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGenericGameplayParameter_CurveTableRowHandle) == 0x000008, "Wrong alignment on FGenericGameplayParameter_CurveTableRowHandle");
static_assert(sizeof(FGenericGameplayParameter_CurveTableRowHandle) == 0x000010, "Wrong size on FGenericGameplayParameter_CurveTableRowHandle");
static_assert(offsetof(FGenericGameplayParameter_CurveTableRowHandle, Value) == 0x000000, "Member 'FGenericGameplayParameter_CurveTableRowHandle::Value' has a wrong offset!");

// ScriptStruct OrionGame.OrionBotTeamMember
// 0x00D0 (0x00D0 - 0x0000)
struct FOrionBotTeamMember final
{
public:
	class AOrionAIBot*                            BotController;                                     // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionPlayerController_Game*            PlayerController;                                  // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionPlayerState_Game*                 CachedOrionPlayerState;                            // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBotObjective*                          CurrentObjective;                                  // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0xB0];                                      // 0x0020(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionBotTeamMember) == 0x000008, "Wrong alignment on FOrionBotTeamMember");
static_assert(sizeof(FOrionBotTeamMember) == 0x0000D0, "Wrong size on FOrionBotTeamMember");
static_assert(offsetof(FOrionBotTeamMember, BotController) == 0x000000, "Member 'FOrionBotTeamMember::BotController' has a wrong offset!");
static_assert(offsetof(FOrionBotTeamMember, PlayerController) == 0x000008, "Member 'FOrionBotTeamMember::PlayerController' has a wrong offset!");
static_assert(offsetof(FOrionBotTeamMember, CachedOrionPlayerState) == 0x000010, "Member 'FOrionBotTeamMember::CachedOrionPlayerState' has a wrong offset!");
static_assert(offsetof(FOrionBotTeamMember, CurrentObjective) == 0x000018, "Member 'FOrionBotTeamMember::CurrentObjective' has a wrong offset!");

// ScriptStruct OrionGame.RuntimePlaybookObjective
// 0x0010 (0x0040 - 0x0030)
struct FRuntimePlaybookObjective final : public FBotObjectiveDescription
{
public:
	TArray<class UBotObjective*>                  ObjectiveInstances;                                // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRuntimePlaybookObjective) == 0x000008, "Wrong alignment on FRuntimePlaybookObjective");
static_assert(sizeof(FRuntimePlaybookObjective) == 0x000040, "Wrong size on FRuntimePlaybookObjective");
static_assert(offsetof(FRuntimePlaybookObjective, ObjectiveInstances) == 0x000030, "Member 'FRuntimePlaybookObjective::ObjectiveInstances' has a wrong offset!");

// ScriptStruct OrionGame.RuntimePlaybook
// 0x0018 (0x0018 - 0x0000)
struct FRuntimePlaybook final
{
public:
	class UBotPlaybook*                           PlaybookInstance;                                  // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRuntimePlaybookObjective>      ObjectivePriorityList;                             // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRuntimePlaybook) == 0x000008, "Wrong alignment on FRuntimePlaybook");
static_assert(sizeof(FRuntimePlaybook) == 0x000018, "Wrong size on FRuntimePlaybook");
static_assert(offsetof(FRuntimePlaybook, PlaybookInstance) == 0x000000, "Member 'FRuntimePlaybook::PlaybookInstance' has a wrong offset!");
static_assert(offsetof(FRuntimePlaybook, ObjectivePriorityList) == 0x000008, "Member 'FRuntimePlaybook::ObjectivePriorityList' has a wrong offset!");

// ScriptStruct OrionGame.OrionBotTeam
// 0x0120 (0x0120 - 0x0000)
struct FOrionBotTeam final
{
public:
	TArray<struct FOrionBotTeamMember>            Members;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UBotObjective*>                  AllObjectives;                                     // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UBotObjective_WholeLane*>        LaneObjectives;                                    // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UAITeamComm*                            TeamComm;                                          // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x58];                                      // 0x0038(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimePlaybook                       RolePlaybooks[0x5];                                // 0x0090(0x0018)(NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x18];                                     // 0x0108(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionBotTeam) == 0x000008, "Wrong alignment on FOrionBotTeam");
static_assert(sizeof(FOrionBotTeam) == 0x000120, "Wrong size on FOrionBotTeam");
static_assert(offsetof(FOrionBotTeam, Members) == 0x000000, "Member 'FOrionBotTeam::Members' has a wrong offset!");
static_assert(offsetof(FOrionBotTeam, AllObjectives) == 0x000010, "Member 'FOrionBotTeam::AllObjectives' has a wrong offset!");
static_assert(offsetof(FOrionBotTeam, LaneObjectives) == 0x000020, "Member 'FOrionBotTeam::LaneObjectives' has a wrong offset!");
static_assert(offsetof(FOrionBotTeam, TeamComm) == 0x000030, "Member 'FOrionBotTeam::TeamComm' has a wrong offset!");
static_assert(offsetof(FOrionBotTeam, RolePlaybooks) == 0x000090, "Member 'FOrionBotTeam::RolePlaybooks' has a wrong offset!");

// ScriptStruct OrionGame.GenericGameplayParameter_Float
// 0x0004 (0x0004 - 0x0000)
struct FGenericGameplayParameter_Float final : public FGenericGameplayParameter_SimpleBase
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGenericGameplayParameter_Float) == 0x000004, "Wrong alignment on FGenericGameplayParameter_Float");
static_assert(sizeof(FGenericGameplayParameter_Float) == 0x000004, "Wrong size on FGenericGameplayParameter_Float");
static_assert(offsetof(FGenericGameplayParameter_Float, Value) == 0x000000, "Member 'FGenericGameplayParameter_Float::Value' has a wrong offset!");

// ScriptStruct OrionGame.ForcedBenchmarkSettingsEntry
// 0x0020 (0x0020 - 0x0000)
struct FForcedBenchmarkSettingsEntry final
{
public:
	int32                                         ResolutionQualityOverrideWidth;                    // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResolutionQualityOverrideHeight;                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ViewDistanceQualityOverride;                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AntiAliasingQualityOverride;                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShadowQualityOverride;                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PostProcessQualityOverride;                        // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TextureQualityOverride;                            // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EffectsQualityOverride;                            // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FForcedBenchmarkSettingsEntry) == 0x000004, "Wrong alignment on FForcedBenchmarkSettingsEntry");
static_assert(sizeof(FForcedBenchmarkSettingsEntry) == 0x000020, "Wrong size on FForcedBenchmarkSettingsEntry");
static_assert(offsetof(FForcedBenchmarkSettingsEntry, ResolutionQualityOverrideWidth) == 0x000000, "Member 'FForcedBenchmarkSettingsEntry::ResolutionQualityOverrideWidth' has a wrong offset!");
static_assert(offsetof(FForcedBenchmarkSettingsEntry, ResolutionQualityOverrideHeight) == 0x000004, "Member 'FForcedBenchmarkSettingsEntry::ResolutionQualityOverrideHeight' has a wrong offset!");
static_assert(offsetof(FForcedBenchmarkSettingsEntry, ViewDistanceQualityOverride) == 0x000008, "Member 'FForcedBenchmarkSettingsEntry::ViewDistanceQualityOverride' has a wrong offset!");
static_assert(offsetof(FForcedBenchmarkSettingsEntry, AntiAliasingQualityOverride) == 0x00000C, "Member 'FForcedBenchmarkSettingsEntry::AntiAliasingQualityOverride' has a wrong offset!");
static_assert(offsetof(FForcedBenchmarkSettingsEntry, ShadowQualityOverride) == 0x000010, "Member 'FForcedBenchmarkSettingsEntry::ShadowQualityOverride' has a wrong offset!");
static_assert(offsetof(FForcedBenchmarkSettingsEntry, PostProcessQualityOverride) == 0x000014, "Member 'FForcedBenchmarkSettingsEntry::PostProcessQualityOverride' has a wrong offset!");
static_assert(offsetof(FForcedBenchmarkSettingsEntry, TextureQualityOverride) == 0x000018, "Member 'FForcedBenchmarkSettingsEntry::TextureQualityOverride' has a wrong offset!");
static_assert(offsetof(FForcedBenchmarkSettingsEntry, EffectsQualityOverride) == 0x00001C, "Member 'FForcedBenchmarkSettingsEntry::EffectsQualityOverride' has a wrong offset!");

// ScriptStruct OrionGame.GraphicsCardEntry
// 0x0060 (0x0060 - 0x0000)
struct FGraphicsCardEntry final
{
public:
	uint32                                        VendorID;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        DeviceID;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BenchmarkMultiplier;                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AdapterDisplayName;                                // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RequiredSourceName;                                // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint32>                                RequiredRevisionIds;                               // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FForcedBenchmarkSettingsEntry          ForcedBenchmarkSettings;                           // 0x0040(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGraphicsCardEntry) == 0x000008, "Wrong alignment on FGraphicsCardEntry");
static_assert(sizeof(FGraphicsCardEntry) == 0x000060, "Wrong size on FGraphicsCardEntry");
static_assert(offsetof(FGraphicsCardEntry, VendorID) == 0x000000, "Member 'FGraphicsCardEntry::VendorID' has a wrong offset!");
static_assert(offsetof(FGraphicsCardEntry, DeviceID) == 0x000004, "Member 'FGraphicsCardEntry::DeviceID' has a wrong offset!");
static_assert(offsetof(FGraphicsCardEntry, BenchmarkMultiplier) == 0x000008, "Member 'FGraphicsCardEntry::BenchmarkMultiplier' has a wrong offset!");
static_assert(offsetof(FGraphicsCardEntry, AdapterDisplayName) == 0x000010, "Member 'FGraphicsCardEntry::AdapterDisplayName' has a wrong offset!");
static_assert(offsetof(FGraphicsCardEntry, RequiredSourceName) == 0x000020, "Member 'FGraphicsCardEntry::RequiredSourceName' has a wrong offset!");
static_assert(offsetof(FGraphicsCardEntry, RequiredRevisionIds) == 0x000030, "Member 'FGraphicsCardEntry::RequiredRevisionIds' has a wrong offset!");
static_assert(offsetof(FGraphicsCardEntry, ForcedBenchmarkSettings) == 0x000040, "Member 'FGraphicsCardEntry::ForcedBenchmarkSettings' has a wrong offset!");

// ScriptStruct OrionGame.REGSMilestoneRewardRecord
// 0x0020 (0x0020 - 0x0000)
struct FREGSMilestoneRewardRecord final
{
public:
	int32                                         Stars;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CohortTemplateId;                                  // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              CompletionTime;                                    // 0x0018(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FREGSMilestoneRewardRecord) == 0x000008, "Wrong alignment on FREGSMilestoneRewardRecord");
static_assert(sizeof(FREGSMilestoneRewardRecord) == 0x000020, "Wrong size on FREGSMilestoneRewardRecord");
static_assert(offsetof(FREGSMilestoneRewardRecord, Stars) == 0x000000, "Member 'FREGSMilestoneRewardRecord::Stars' has a wrong offset!");
static_assert(offsetof(FREGSMilestoneRewardRecord, CohortTemplateId) == 0x000008, "Member 'FREGSMilestoneRewardRecord::CohortTemplateId' has a wrong offset!");
static_assert(offsetof(FREGSMilestoneRewardRecord, CompletionTime) == 0x000018, "Member 'FREGSMilestoneRewardRecord::CompletionTime' has a wrong offset!");

// ScriptStruct OrionGame.MOTDEntry
// 0x0040 (0x0040 - 0x0000)
struct FMOTDEntry final
{
public:
	class FString                                 Culture;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Title;                                             // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Body;                                              // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Date;                                              // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMOTDEntry) == 0x000008, "Wrong alignment on FMOTDEntry");
static_assert(sizeof(FMOTDEntry) == 0x000040, "Wrong size on FMOTDEntry");
static_assert(offsetof(FMOTDEntry, Culture) == 0x000000, "Member 'FMOTDEntry::Culture' has a wrong offset!");
static_assert(offsetof(FMOTDEntry, Title) == 0x000010, "Member 'FMOTDEntry::Title' has a wrong offset!");
static_assert(offsetof(FMOTDEntry, Body) == 0x000020, "Member 'FMOTDEntry::Body' has a wrong offset!");
static_assert(offsetof(FMOTDEntry, Date) == 0x000030, "Member 'FMOTDEntry::Date' has a wrong offset!");

// ScriptStruct OrionGame.OrionAbilityCues
// 0x0008 (0x0008 - 0x0000)
struct FOrionAbilityCues final
{
public:
	struct FGameplayCueTag                        COMMIT;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionAbilityCues) == 0x000008, "Wrong alignment on FOrionAbilityCues");
static_assert(sizeof(FOrionAbilityCues) == 0x000008, "Wrong size on FOrionAbilityCues");
static_assert(offsetof(FOrionAbilityCues, COMMIT) == 0x000000, "Member 'FOrionAbilityCues::COMMIT' has a wrong offset!");

// ScriptStruct OrionGame.MenuWidgetEntry
// 0x0010 (0x0010 - 0x0000)
struct FMenuWidgetEntry final
{
public:
	class UWidget*                                Widget;                                            // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionMenuSlotTypes                           WidgetSlotType;                                    // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionDesiredAnalogCursorState                CursorState;                                       // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMenuWidgetEntry) == 0x000008, "Wrong alignment on FMenuWidgetEntry");
static_assert(sizeof(FMenuWidgetEntry) == 0x000010, "Wrong size on FMenuWidgetEntry");
static_assert(offsetof(FMenuWidgetEntry, Widget) == 0x000000, "Member 'FMenuWidgetEntry::Widget' has a wrong offset!");
static_assert(offsetof(FMenuWidgetEntry, WidgetSlotType) == 0x000008, "Member 'FMenuWidgetEntry::WidgetSlotType' has a wrong offset!");
static_assert(offsetof(FMenuWidgetEntry, CursorState) == 0x000009, "Member 'FMenuWidgetEntry::CursorState' has a wrong offset!");

// ScriptStruct OrionGame.BaseCardSetData
// 0x0010 (0x0018 - 0x0008)
struct FBaseCardSetData final : public FTableRowBase
{
public:
	class UOrionLegacyCardItemDefinition*         CardData;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseSetQuantity;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBaseCardSetData) == 0x000008, "Wrong alignment on FBaseCardSetData");
static_assert(sizeof(FBaseCardSetData) == 0x000018, "Wrong size on FBaseCardSetData");
static_assert(offsetof(FBaseCardSetData, CardData) == 0x000008, "Member 'FBaseCardSetData::CardData' has a wrong offset!");
static_assert(offsetof(FBaseCardSetData, BaseSetQuantity) == 0x000010, "Member 'FBaseCardSetData::BaseSetQuantity' has a wrong offset!");

// ScriptStruct OrionGame.EventEvaluatorSpecGameplayEffectApplied
// 0x0098 (0x0098 - 0x0000)
struct FEventEvaluatorSpecGameplayEffectApplied final
{
public:
	EEventEvaluatorGameplayEffectListenType       Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagQuery                      SourceTagQuery;                                    // 0x0008(0x0048)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      TargetTagQuery;                                    // 0x0050(0x0048)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventEvaluatorSpecGameplayEffectApplied) == 0x000008, "Wrong alignment on FEventEvaluatorSpecGameplayEffectApplied");
static_assert(sizeof(FEventEvaluatorSpecGameplayEffectApplied) == 0x000098, "Wrong size on FEventEvaluatorSpecGameplayEffectApplied");
static_assert(offsetof(FEventEvaluatorSpecGameplayEffectApplied, Type) == 0x000000, "Member 'FEventEvaluatorSpecGameplayEffectApplied::Type' has a wrong offset!");
static_assert(offsetof(FEventEvaluatorSpecGameplayEffectApplied, SourceTagQuery) == 0x000008, "Member 'FEventEvaluatorSpecGameplayEffectApplied::SourceTagQuery' has a wrong offset!");
static_assert(offsetof(FEventEvaluatorSpecGameplayEffectApplied, TargetTagQuery) == 0x000050, "Member 'FEventEvaluatorSpecGameplayEffectApplied::TargetTagQuery' has a wrong offset!");

// ScriptStruct OrionGame.EventEvaluatorAbilityActivated
// 0x0050 (0x0050 - 0x0000)
struct FEventEvaluatorAbilityActivated final
{
public:
	EEventEvaluatorAbilityActivateType            Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagQuery                      AbilityTagQuery;                                   // 0x0008(0x0048)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventEvaluatorAbilityActivated) == 0x000008, "Wrong alignment on FEventEvaluatorAbilityActivated");
static_assert(sizeof(FEventEvaluatorAbilityActivated) == 0x000050, "Wrong size on FEventEvaluatorAbilityActivated");
static_assert(offsetof(FEventEvaluatorAbilityActivated, Type) == 0x000000, "Member 'FEventEvaluatorAbilityActivated::Type' has a wrong offset!");
static_assert(offsetof(FEventEvaluatorAbilityActivated, AbilityTagQuery) == 0x000008, "Member 'FEventEvaluatorAbilityActivated::AbilityTagQuery' has a wrong offset!");

// ScriptStruct OrionGame.EventEvaluatorGameplayEvent
// 0x0010 (0x0010 - 0x0000)
struct FEventEvaluatorGameplayEvent final
{
public:
	struct FGameplayEventKeywordTag               EventKeywordTag;                                   // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayEventTag;                                  // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventEvaluatorGameplayEvent) == 0x000008, "Wrong alignment on FEventEvaluatorGameplayEvent");
static_assert(sizeof(FEventEvaluatorGameplayEvent) == 0x000010, "Wrong size on FEventEvaluatorGameplayEvent");
static_assert(offsetof(FEventEvaluatorGameplayEvent, EventKeywordTag) == 0x000000, "Member 'FEventEvaluatorGameplayEvent::EventKeywordTag' has a wrong offset!");
static_assert(offsetof(FEventEvaluatorGameplayEvent, GameplayEventTag) == 0x000008, "Member 'FEventEvaluatorGameplayEvent::GameplayEventTag' has a wrong offset!");

// ScriptStruct OrionGame.EventEvaluatorAttributeChange
// 0x0020 (0x0020 - 0x0000)
struct FEventEvaluatorAttributeChange final
{
public:
	struct FGameplayAttribute                     Attribute;                                         // 0x0000(0x0020)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventEvaluatorAttributeChange) == 0x000008, "Wrong alignment on FEventEvaluatorAttributeChange");
static_assert(sizeof(FEventEvaluatorAttributeChange) == 0x000020, "Wrong size on FEventEvaluatorAttributeChange");
static_assert(offsetof(FEventEvaluatorAttributeChange, Attribute) == 0x000000, "Member 'FEventEvaluatorAttributeChange::Attribute' has a wrong offset!");

// ScriptStruct OrionGame.EventEvaluatorExecutionSpec
// 0x01A0 (0x01A0 - 0x0000)
struct FEventEvaluatorExecutionSpec final
{
public:
	struct FEventEvaluatorSpecGameplayEffectApplied GameplayEffectApplied;                             // 0x0000(0x0098)(Edit, NativeAccessSpecifierPublic)
	struct FEventEvaluatorAbilityActivated        AbilityActivated;                                  // 0x0098(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FEventEvaluatorTagApplied              Tag;                                               // 0x00E8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FEventEvaluatorAttributeChange         AttributeChange;                                   // 0x00F8(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FEventEvaluatorGameplayEvent           Event;                                             // 0x0118(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FQualifierKeywordsWithContext          InternalQualifiers;                                // 0x0128(0x0078)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventEvaluatorExecutionSpec) == 0x000008, "Wrong alignment on FEventEvaluatorExecutionSpec");
static_assert(sizeof(FEventEvaluatorExecutionSpec) == 0x0001A0, "Wrong size on FEventEvaluatorExecutionSpec");
static_assert(offsetof(FEventEvaluatorExecutionSpec, GameplayEffectApplied) == 0x000000, "Member 'FEventEvaluatorExecutionSpec::GameplayEffectApplied' has a wrong offset!");
static_assert(offsetof(FEventEvaluatorExecutionSpec, AbilityActivated) == 0x000098, "Member 'FEventEvaluatorExecutionSpec::AbilityActivated' has a wrong offset!");
static_assert(offsetof(FEventEvaluatorExecutionSpec, Tag) == 0x0000E8, "Member 'FEventEvaluatorExecutionSpec::Tag' has a wrong offset!");
static_assert(offsetof(FEventEvaluatorExecutionSpec, AttributeChange) == 0x0000F8, "Member 'FEventEvaluatorExecutionSpec::AttributeChange' has a wrong offset!");
static_assert(offsetof(FEventEvaluatorExecutionSpec, Event) == 0x000118, "Member 'FEventEvaluatorExecutionSpec::Event' has a wrong offset!");
static_assert(offsetof(FEventEvaluatorExecutionSpec, InternalQualifiers) == 0x000128, "Member 'FEventEvaluatorExecutionSpec::InternalQualifiers' has a wrong offset!");

// ScriptStruct OrionGame.SimpleAchievementEarnedNotification
// 0x0008 (0x0008 - 0x0000)
struct FSimpleAchievementEarnedNotification final
{
public:
	int32                                         EarnedAchievementIndex;                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFirstTimeEarned;                                  // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSimpleAchievementEarnedNotification) == 0x000004, "Wrong alignment on FSimpleAchievementEarnedNotification");
static_assert(sizeof(FSimpleAchievementEarnedNotification) == 0x000008, "Wrong size on FSimpleAchievementEarnedNotification");
static_assert(offsetof(FSimpleAchievementEarnedNotification, EarnedAchievementIndex) == 0x000000, "Member 'FSimpleAchievementEarnedNotification::EarnedAchievementIndex' has a wrong offset!");
static_assert(offsetof(FSimpleAchievementEarnedNotification, bFirstTimeEarned) == 0x000004, "Member 'FSimpleAchievementEarnedNotification::bFirstTimeEarned' has a wrong offset!");

// ScriptStruct OrionGame.ProgressionEntry
// 0x0008 (0x0008 - 0x0000)
struct FProgressionEntry final
{
public:
	int32                                         ProgressionId;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProgressValue;                                     // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProgressionEntry) == 0x000004, "Wrong alignment on FProgressionEntry");
static_assert(sizeof(FProgressionEntry) == 0x000008, "Wrong size on FProgressionEntry");
static_assert(offsetof(FProgressionEntry, ProgressionId) == 0x000000, "Member 'FProgressionEntry::ProgressionId' has a wrong offset!");
static_assert(offsetof(FProgressionEntry, ProgressValue) == 0x000004, "Member 'FProgressionEntry::ProgressValue' has a wrong offset!");

// ScriptStruct OrionGame.EventEntry
// 0x0020 (0x0020 - 0x0000)
struct FEventEntry final
{
public:
	class FString                                 EventName;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FProgressionEntry>              Progressions;                                      // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventEntry) == 0x000008, "Wrong alignment on FEventEntry");
static_assert(sizeof(FEventEntry) == 0x000020, "Wrong size on FEventEntry");
static_assert(offsetof(FEventEntry, EventName) == 0x000000, "Member 'FEventEntry::EventName' has a wrong offset!");
static_assert(offsetof(FEventEntry, Progressions) == 0x000010, "Member 'FEventEntry::Progressions' has a wrong offset!");

// ScriptStruct OrionGame.OrionEventReward
// 0x0038 (0x0038 - 0x0000)
struct FOrionEventReward final
{
public:
	TSoftObjectPtr<class UOrionMcpItemDefinition> RewardAsset;                                       // 0x0000(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProgressValue;                                     // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionEventReward) == 0x000008, "Wrong alignment on FOrionEventReward");
static_assert(sizeof(FOrionEventReward) == 0x000038, "Wrong size on FOrionEventReward");
static_assert(offsetof(FOrionEventReward, RewardAsset) == 0x000000, "Member 'FOrionEventReward::RewardAsset' has a wrong offset!");
static_assert(offsetof(FOrionEventReward, ProgressValue) == 0x000028, "Member 'FOrionEventReward::ProgressValue' has a wrong offset!");
static_assert(offsetof(FOrionEventReward, Quantity) == 0x00002C, "Member 'FOrionEventReward::Quantity' has a wrong offset!");

// ScriptStruct OrionGame.OrionEventProgression
// 0x0040 (0x0040 - 0x0000)
struct FOrionEventProgression final
{
public:
	class FString                                 EventID;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EventPeriodId;                                     // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              StartTime;                                         // 0x0018(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              EndTime;                                           // 0x0020(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOrionEventReward>              Rewards;                                           // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionEventProgression) == 0x000008, "Wrong alignment on FOrionEventProgression");
static_assert(sizeof(FOrionEventProgression) == 0x000040, "Wrong size on FOrionEventProgression");
static_assert(offsetof(FOrionEventProgression, EventID) == 0x000000, "Member 'FOrionEventProgression::EventID' has a wrong offset!");
static_assert(offsetof(FOrionEventProgression, EventPeriodId) == 0x000010, "Member 'FOrionEventProgression::EventPeriodId' has a wrong offset!");
static_assert(offsetof(FOrionEventProgression, StartTime) == 0x000018, "Member 'FOrionEventProgression::StartTime' has a wrong offset!");
static_assert(offsetof(FOrionEventProgression, EndTime) == 0x000020, "Member 'FOrionEventProgression::EndTime' has a wrong offset!");
static_assert(offsetof(FOrionEventProgression, Rewards) == 0x000028, "Member 'FOrionEventProgression::Rewards' has a wrong offset!");

// ScriptStruct OrionGame.OrionMcpEvent
// 0x0028 (0x0028 - 0x0000)
struct FOrionMcpEvent final
{
public:
	class FString                                 QuestGroup;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOrionEventProgression>         Progressions;                                      // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ActiveProgressionIdx;                              // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionMcpEvent) == 0x000008, "Wrong alignment on FOrionMcpEvent");
static_assert(sizeof(FOrionMcpEvent) == 0x000028, "Wrong size on FOrionMcpEvent");
static_assert(offsetof(FOrionMcpEvent, QuestGroup) == 0x000000, "Member 'FOrionMcpEvent::QuestGroup' has a wrong offset!");
static_assert(offsetof(FOrionMcpEvent, Progressions) == 0x000010, "Member 'FOrionMcpEvent::Progressions' has a wrong offset!");
static_assert(offsetof(FOrionMcpEvent, ActiveProgressionIdx) == 0x000020, "Member 'FOrionMcpEvent::ActiveProgressionIdx' has a wrong offset!");

// ScriptStruct OrionGame.GamepadButtonArt
// 0x0180 (0x0180 - 0x0000)
struct FGamepadButtonArt final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Edit, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            PS4Icon;                                           // 0x0018(0x0078)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            XBoxIcon;                                          // 0x0090(0x0078)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            NVShieldIcon;                                      // 0x0108(0x0078)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGamepadButtonArt) == 0x000008, "Wrong alignment on FGamepadButtonArt");
static_assert(sizeof(FGamepadButtonArt) == 0x000180, "Wrong size on FGamepadButtonArt");
static_assert(offsetof(FGamepadButtonArt, Key) == 0x000000, "Member 'FGamepadButtonArt::Key' has a wrong offset!");
static_assert(offsetof(FGamepadButtonArt, PS4Icon) == 0x000018, "Member 'FGamepadButtonArt::PS4Icon' has a wrong offset!");
static_assert(offsetof(FGamepadButtonArt, XBoxIcon) == 0x000090, "Member 'FGamepadButtonArt::XBoxIcon' has a wrong offset!");
static_assert(offsetof(FGamepadButtonArt, NVShieldIcon) == 0x000108, "Member 'FGamepadButtonArt::NVShieldIcon' has a wrong offset!");

// ScriptStruct OrionGame.OrionCharNetworkSmoothingLod
// 0x0014 (0x0014 - 0x0000)
struct FOrionCharNetworkSmoothingLod final
{
public:
	float                                         DelayBetweenUpdates;                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceInMeters;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x4];                                        // 0x0008(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bSimulationEnabled : 1;                            // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForceRootMotionSimulationEnabled : 1;             // 0x000C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForceRootMotionSimulationMinVelocity;              // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionCharNetworkSmoothingLod) == 0x000004, "Wrong alignment on FOrionCharNetworkSmoothingLod");
static_assert(sizeof(FOrionCharNetworkSmoothingLod) == 0x000014, "Wrong size on FOrionCharNetworkSmoothingLod");
static_assert(offsetof(FOrionCharNetworkSmoothingLod, DelayBetweenUpdates) == 0x000000, "Member 'FOrionCharNetworkSmoothingLod::DelayBetweenUpdates' has a wrong offset!");
static_assert(offsetof(FOrionCharNetworkSmoothingLod, DistanceInMeters) == 0x000004, "Member 'FOrionCharNetworkSmoothingLod::DistanceInMeters' has a wrong offset!");
static_assert(offsetof(FOrionCharNetworkSmoothingLod, ForceRootMotionSimulationMinVelocity) == 0x000010, "Member 'FOrionCharNetworkSmoothingLod::ForceRootMotionSimulationMinVelocity' has a wrong offset!");

// ScriptStruct OrionGame.OrionMeleeAttack
// 0x0030 (0x0030 - 0x0000)
struct FOrionMeleeAttack final
{
public:
	class FName                                   MeleeAttackName;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MeleeAttackAnimation;                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            MeleeAttackGameplayEffect;                         // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnKeyRelease;                                     // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OnKeyReleaseAnimSection;                           // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdealMeleeDistance;                                // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseAttackTimeScale;                               // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionMeleeAttack) == 0x000008, "Wrong alignment on FOrionMeleeAttack");
static_assert(sizeof(FOrionMeleeAttack) == 0x000030, "Wrong size on FOrionMeleeAttack");
static_assert(offsetof(FOrionMeleeAttack, MeleeAttackName) == 0x000000, "Member 'FOrionMeleeAttack::MeleeAttackName' has a wrong offset!");
static_assert(offsetof(FOrionMeleeAttack, MeleeAttackAnimation) == 0x000008, "Member 'FOrionMeleeAttack::MeleeAttackAnimation' has a wrong offset!");
static_assert(offsetof(FOrionMeleeAttack, MeleeAttackGameplayEffect) == 0x000010, "Member 'FOrionMeleeAttack::MeleeAttackGameplayEffect' has a wrong offset!");
static_assert(offsetof(FOrionMeleeAttack, bOnKeyRelease) == 0x000018, "Member 'FOrionMeleeAttack::bOnKeyRelease' has a wrong offset!");
static_assert(offsetof(FOrionMeleeAttack, OnKeyReleaseAnimSection) == 0x000020, "Member 'FOrionMeleeAttack::OnKeyReleaseAnimSection' has a wrong offset!");
static_assert(offsetof(FOrionMeleeAttack, IdealMeleeDistance) == 0x000028, "Member 'FOrionMeleeAttack::IdealMeleeDistance' has a wrong offset!");
static_assert(offsetof(FOrionMeleeAttack, BaseAttackTimeScale) == 0x00002C, "Member 'FOrionMeleeAttack::BaseAttackTimeScale' has a wrong offset!");

// ScriptStruct OrionGame.DeckGemData
// 0x0018 (0x0018 - 0x0000)
struct FDeckGemData final
{
public:
	class FString                                 GemId;                                             // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         GemTreeBranchIndex;                                // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         GemTreePipIndex;                                   // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDeckGemData) == 0x000008, "Wrong alignment on FDeckGemData");
static_assert(sizeof(FDeckGemData) == 0x000018, "Wrong size on FDeckGemData");
static_assert(offsetof(FDeckGemData, GemId) == 0x000000, "Member 'FDeckGemData::GemId' has a wrong offset!");
static_assert(offsetof(FDeckGemData, GemTreeBranchIndex) == 0x000010, "Member 'FDeckGemData::GemTreeBranchIndex' has a wrong offset!");
static_assert(offsetof(FDeckGemData, GemTreePipIndex) == 0x000011, "Member 'FDeckGemData::GemTreePipIndex' has a wrong offset!");

// ScriptStruct OrionGame.OrionAbilityBindInfo
// 0x0010 (0x0010 - 0x0000)
struct FOrionAbilityBindInfo final
{
public:
	EOrionAbilityBinding                          KeyBinding;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionAbilityBinding                          UnlocksWithKeyBinding;                             // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UOrionAbility>              Ability;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionAbilityBindInfo) == 0x000008, "Wrong alignment on FOrionAbilityBindInfo");
static_assert(sizeof(FOrionAbilityBindInfo) == 0x000010, "Wrong size on FOrionAbilityBindInfo");
static_assert(offsetof(FOrionAbilityBindInfo, KeyBinding) == 0x000000, "Member 'FOrionAbilityBindInfo::KeyBinding' has a wrong offset!");
static_assert(offsetof(FOrionAbilityBindInfo, UnlocksWithKeyBinding) == 0x000001, "Member 'FOrionAbilityBindInfo::UnlocksWithKeyBinding' has a wrong offset!");
static_assert(offsetof(FOrionAbilityBindInfo, Ability) == 0x000008, "Member 'FOrionAbilityBindInfo::Ability' has a wrong offset!");

// ScriptStruct OrionGame.SkinAttachmentMaterial
// 0x0038 (0x0038 - 0x0000)
struct FSkinAttachmentMaterial final
{
public:
	TSoftObjectPtr<class UMaterialInterface>      LazyMaterial;                                      // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     LoadedMaterial;                                    // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SlotName;                                          // 0x0030(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkinAttachmentMaterial) == 0x000008, "Wrong alignment on FSkinAttachmentMaterial");
static_assert(sizeof(FSkinAttachmentMaterial) == 0x000038, "Wrong size on FSkinAttachmentMaterial");
static_assert(offsetof(FSkinAttachmentMaterial, LazyMaterial) == 0x000000, "Member 'FSkinAttachmentMaterial::LazyMaterial' has a wrong offset!");
static_assert(offsetof(FSkinAttachmentMaterial, LoadedMaterial) == 0x000028, "Member 'FSkinAttachmentMaterial::LoadedMaterial' has a wrong offset!");
static_assert(offsetof(FSkinAttachmentMaterial, SlotName) == 0x000030, "Member 'FSkinAttachmentMaterial::SlotName' has a wrong offset!");

// ScriptStruct OrionGame.TeamXPBonus
// 0x0008 (0x0010 - 0x0008)
struct FTeamXPBonus final : public FTableRowBase
{
public:
	float                                         BonusForMe;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BonusForTeammate;                                  // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTeamXPBonus) == 0x000008, "Wrong alignment on FTeamXPBonus");
static_assert(sizeof(FTeamXPBonus) == 0x000010, "Wrong size on FTeamXPBonus");
static_assert(offsetof(FTeamXPBonus, BonusForMe) == 0x000008, "Member 'FTeamXPBonus::BonusForMe' has a wrong offset!");
static_assert(offsetof(FTeamXPBonus, BonusForTeammate) == 0x00000C, "Member 'FTeamXPBonus::BonusForTeammate' has a wrong offset!");

// ScriptStruct OrionGame.BeamHitResult
// 0x0098 (0x0098 - 0x0000)
struct FBeamHitResult final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x0088)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               HitParticleComponent;                              // 0x0088(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timestamp;                                         // 0x0090(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBeamHitResult) == 0x000008, "Wrong alignment on FBeamHitResult");
static_assert(sizeof(FBeamHitResult) == 0x000098, "Wrong size on FBeamHitResult");
static_assert(offsetof(FBeamHitResult, HitResult) == 0x000000, "Member 'FBeamHitResult::HitResult' has a wrong offset!");
static_assert(offsetof(FBeamHitResult, HitParticleComponent) == 0x000088, "Member 'FBeamHitResult::HitParticleComponent' has a wrong offset!");
static_assert(offsetof(FBeamHitResult, Timestamp) == 0x000090, "Member 'FBeamHitResult::Timestamp' has a wrong offset!");

// ScriptStruct OrionGame.OrionTextFormatInfo
// 0x0010 (0x0010 - 0x0000)
struct FOrionTextFormatInfo final
{
public:
	TSubclassOf<class UOrionTextStyle>            OrionTextStyle;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionWidgetStyleSize                         StyleSize;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTextColor                               ColorType;                                         // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDropShadow;                                    // 0x000A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionTextFormatInfo) == 0x000008, "Wrong alignment on FOrionTextFormatInfo");
static_assert(sizeof(FOrionTextFormatInfo) == 0x000010, "Wrong size on FOrionTextFormatInfo");
static_assert(offsetof(FOrionTextFormatInfo, OrionTextStyle) == 0x000000, "Member 'FOrionTextFormatInfo::OrionTextStyle' has a wrong offset!");
static_assert(offsetof(FOrionTextFormatInfo, StyleSize) == 0x000008, "Member 'FOrionTextFormatInfo::StyleSize' has a wrong offset!");
static_assert(offsetof(FOrionTextFormatInfo, ColorType) == 0x000009, "Member 'FOrionTextFormatInfo::ColorType' has a wrong offset!");
static_assert(offsetof(FOrionTextFormatInfo, bUseDropShadow) == 0x00000A, "Member 'FOrionTextFormatInfo::bUseDropShadow' has a wrong offset!");

// ScriptStruct OrionGame.EventHistory
// 0x0010 (0x0010 - 0x0000)
struct FEventHistory final
{
public:
	TArray<struct FEventEntry>                    EventRecords;                                      // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventHistory) == 0x000008, "Wrong alignment on FEventHistory");
static_assert(sizeof(FEventHistory) == 0x000010, "Wrong size on FEventHistory");
static_assert(offsetof(FEventHistory, EventRecords) == 0x000000, "Member 'FEventHistory::EventRecords' has a wrong offset!");

// ScriptStruct OrionGame.SelectSingleTargetSorter
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FSelectSingleTargetSorter final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSelectSingleTargetSorter) == 0x000008, "Wrong alignment on FSelectSingleTargetSorter");
static_assert(sizeof(FSelectSingleTargetSorter) == 0x000010, "Wrong size on FSelectSingleTargetSorter");

// ScriptStruct OrionGame.OrionMcpRecipeCost
// 0x0018 (0x0018 - 0x0000)
struct FOrionMcpRecipeCost final
{
public:
	TArray<struct FOrionItemQuantity>             Items;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         MtxEquivalency;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionMcpRecipeCost) == 0x000008, "Wrong alignment on FOrionMcpRecipeCost");
static_assert(sizeof(FOrionMcpRecipeCost) == 0x000018, "Wrong size on FOrionMcpRecipeCost");
static_assert(offsetof(FOrionMcpRecipeCost, Items) == 0x000000, "Member 'FOrionMcpRecipeCost::Items' has a wrong offset!");
static_assert(offsetof(FOrionMcpRecipeCost, MtxEquivalency) == 0x000010, "Member 'FOrionMcpRecipeCost::MtxEquivalency' has a wrong offset!");

// ScriptStruct OrionGame.OrionGameplayTagContainerMappingEntry_Base
// 0x0020 (0x0020 - 0x0000)
struct FOrionGameplayTagContainerMappingEntry_Base
{
public:
	TArray<class FName>                           PreloadPackageNames;                               // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           StreamingLevelNamesToLoad;                         // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionGameplayTagContainerMappingEntry_Base) == 0x000008, "Wrong alignment on FOrionGameplayTagContainerMappingEntry_Base");
static_assert(sizeof(FOrionGameplayTagContainerMappingEntry_Base) == 0x000020, "Wrong size on FOrionGameplayTagContainerMappingEntry_Base");
static_assert(offsetof(FOrionGameplayTagContainerMappingEntry_Base, PreloadPackageNames) == 0x000000, "Member 'FOrionGameplayTagContainerMappingEntry_Base::PreloadPackageNames' has a wrong offset!");
static_assert(offsetof(FOrionGameplayTagContainerMappingEntry_Base, StreamingLevelNamesToLoad) == 0x000010, "Member 'FOrionGameplayTagContainerMappingEntry_Base::StreamingLevelNamesToLoad' has a wrong offset!");

// ScriptStruct OrionGame.OrionGameplayTagContentMappingEntry_WithTags
// 0x0020 (0x0040 - 0x0020)
struct FOrionGameplayTagContentMappingEntry_WithTags final : public FOrionGameplayTagContainerMappingEntry_Base
{
public:
	struct FGameplayTagContainer                  BoundRotationalContentTags;                        // 0x0020(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionGameplayTagContentMappingEntry_WithTags) == 0x000008, "Wrong alignment on FOrionGameplayTagContentMappingEntry_WithTags");
static_assert(sizeof(FOrionGameplayTagContentMappingEntry_WithTags) == 0x000040, "Wrong size on FOrionGameplayTagContentMappingEntry_WithTags");
static_assert(offsetof(FOrionGameplayTagContentMappingEntry_WithTags, BoundRotationalContentTags) == 0x000020, "Member 'FOrionGameplayTagContentMappingEntry_WithTags::BoundRotationalContentTags' has a wrong offset!");

// ScriptStruct OrionGame.OrionGameplayTagContentMapping
// 0x0050 (0x0050 - 0x0000)
struct FOrionGameplayTagContentMapping final
{
public:
	class FString                                 OwningMapPath;                                     // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           AlwaysLoadedMapBuildDataPackageNames;              // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FOrionGameplayTagContainerMappingEntry_Base DefaultAssets;                                     // 0x0020(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FOrionGameplayTagContentMappingEntry_WithTags> ContentEntries;                                    // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionGameplayTagContentMapping) == 0x000008, "Wrong alignment on FOrionGameplayTagContentMapping");
static_assert(sizeof(FOrionGameplayTagContentMapping) == 0x000050, "Wrong size on FOrionGameplayTagContentMapping");
static_assert(offsetof(FOrionGameplayTagContentMapping, OwningMapPath) == 0x000000, "Member 'FOrionGameplayTagContentMapping::OwningMapPath' has a wrong offset!");
static_assert(offsetof(FOrionGameplayTagContentMapping, AlwaysLoadedMapBuildDataPackageNames) == 0x000010, "Member 'FOrionGameplayTagContentMapping::AlwaysLoadedMapBuildDataPackageNames' has a wrong offset!");
static_assert(offsetof(FOrionGameplayTagContentMapping, DefaultAssets) == 0x000020, "Member 'FOrionGameplayTagContentMapping::DefaultAssets' has a wrong offset!");
static_assert(offsetof(FOrionGameplayTagContentMapping, ContentEntries) == 0x000040, "Member 'FOrionGameplayTagContentMapping::ContentEntries' has a wrong offset!");

// ScriptStruct OrionGame.OrionAbilityTargetDataFilter
// 0x0008 (0x0030 - 0x0028)
struct FOrionAbilityTargetDataFilter final : public FGameplayTargetDataFilter
{
public:
	EOrionTeam                                    SelfTeam;                                          // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeamCompare                             RequiredRelationshipType;                          // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionAbilityTargetDataFilter) == 0x000008, "Wrong alignment on FOrionAbilityTargetDataFilter");
static_assert(sizeof(FOrionAbilityTargetDataFilter) == 0x000030, "Wrong size on FOrionAbilityTargetDataFilter");
static_assert(offsetof(FOrionAbilityTargetDataFilter, SelfTeam) == 0x000028, "Member 'FOrionAbilityTargetDataFilter::SelfTeam' has a wrong offset!");
static_assert(offsetof(FOrionAbilityTargetDataFilter, RequiredRelationshipType) == 0x000029, "Member 'FOrionAbilityTargetDataFilter::RequiredRelationshipType' has a wrong offset!");

// ScriptStruct OrionGame.OrionVideoInfo
// 0x0090 (0x0090 - 0x0000)
struct FOrionVideoInfo final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMediaSource*                           Video;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class UMediaSource*>      LocalizedAudio;                                    // 0x0010(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bAllowSkips;                                       // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   VideoTitlesClass;                                  // 0x0068(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionVideoInfo) == 0x000008, "Wrong alignment on FOrionVideoInfo");
static_assert(sizeof(FOrionVideoInfo) == 0x000090, "Wrong size on FOrionVideoInfo");
static_assert(offsetof(FOrionVideoInfo, ID) == 0x000000, "Member 'FOrionVideoInfo::ID' has a wrong offset!");
static_assert(offsetof(FOrionVideoInfo, Video) == 0x000008, "Member 'FOrionVideoInfo::Video' has a wrong offset!");
static_assert(offsetof(FOrionVideoInfo, LocalizedAudio) == 0x000010, "Member 'FOrionVideoInfo::LocalizedAudio' has a wrong offset!");
static_assert(offsetof(FOrionVideoInfo, bAllowSkips) == 0x000060, "Member 'FOrionVideoInfo::bAllowSkips' has a wrong offset!");
static_assert(offsetof(FOrionVideoInfo, VideoTitlesClass) == 0x000068, "Member 'FOrionVideoInfo::VideoTitlesClass' has a wrong offset!");

// ScriptStruct OrionGame.ArcadeScore
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FArcadeScore final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FArcadeScore) == 0x000004, "Wrong alignment on FArcadeScore");
static_assert(sizeof(FArcadeScore) == 0x000008, "Wrong size on FArcadeScore");

// ScriptStruct OrionGame.DamageQualifierKeywordsWithContext
// 0x0000 (0x0078 - 0x0078)
struct FDamageQualifierKeywordsWithContext final : public FQualifierKeywordsWithContext
{
};
static_assert(alignof(FDamageQualifierKeywordsWithContext) == 0x000008, "Wrong alignment on FDamageQualifierKeywordsWithContext");
static_assert(sizeof(FDamageQualifierKeywordsWithContext) == 0x000078, "Wrong size on FDamageQualifierKeywordsWithContext");

// ScriptStruct OrionGame.OrionAbilityActorInfo
// 0x0008 (0x0048 - 0x0040)
struct FOrionAbilityActorInfo final : public FGameplayAbilityActorInfo
{
public:
	class AOrionChar*                             OrionChar;                                         // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionAbilityActorInfo) == 0x000008, "Wrong alignment on FOrionAbilityActorInfo");
static_assert(sizeof(FOrionAbilityActorInfo) == 0x000048, "Wrong size on FOrionAbilityActorInfo");
static_assert(offsetof(FOrionAbilityActorInfo, OrionChar) == 0x000040, "Member 'FOrionAbilityActorInfo::OrionChar' has a wrong offset!");

// ScriptStruct OrionGame.OrionGoldXPGameplayCueBatch_Item
// 0x0010 (0x0010 - 0x0000)
struct FOrionGoldXPGameplayCueBatch_Item final
{
public:
	class AActor*                                 SourceActor;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionGoldXPGameplayCueBatch_Item) == 0x000008, "Wrong alignment on FOrionGoldXPGameplayCueBatch_Item");
static_assert(sizeof(FOrionGoldXPGameplayCueBatch_Item) == 0x000010, "Wrong size on FOrionGoldXPGameplayCueBatch_Item");
static_assert(offsetof(FOrionGoldXPGameplayCueBatch_Item, SourceActor) == 0x000000, "Member 'FOrionGoldXPGameplayCueBatch_Item::SourceActor' has a wrong offset!");

// ScriptStruct OrionGame.OrionGoldXPGameplayCueBatch
// 0x0018 (0x0018 - 0x0000)
struct FOrionGoldXPGameplayCueBatch final
{
public:
	TArray<struct FOrionGoldXPGameplayCueBatch_Item> Items;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionGoldXPGameplayCueBatch) == 0x000008, "Wrong alignment on FOrionGoldXPGameplayCueBatch");
static_assert(sizeof(FOrionGoldXPGameplayCueBatch) == 0x000018, "Wrong size on FOrionGoldXPGameplayCueBatch");
static_assert(offsetof(FOrionGoldXPGameplayCueBatch, Items) == 0x000000, "Member 'FOrionGoldXPGameplayCueBatch::Items' has a wrong offset!");

// ScriptStruct OrionGame.OrionGameplayCueBatch_Item
// 0x0028 (0x0028 - 0x0000)
struct FOrionGameplayCueBatch_Item final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Magnitude;                                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPredictionKey                         PredictionKey;                                     // 0x0010(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionGameplayCueBatch_Item) == 0x000008, "Wrong alignment on FOrionGameplayCueBatch_Item");
static_assert(sizeof(FOrionGameplayCueBatch_Item) == 0x000028, "Wrong size on FOrionGameplayCueBatch_Item");
static_assert(offsetof(FOrionGameplayCueBatch_Item, GameplayCueTag) == 0x000000, "Member 'FOrionGameplayCueBatch_Item::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(FOrionGameplayCueBatch_Item, Magnitude) == 0x000008, "Member 'FOrionGameplayCueBatch_Item::Magnitude' has a wrong offset!");
static_assert(offsetof(FOrionGameplayCueBatch_Item, PredictionKey) == 0x000010, "Member 'FOrionGameplayCueBatch_Item::PredictionKey' has a wrong offset!");

// ScriptStruct OrionGame.OrionGameplayCueBatch
// 0x00C8 (0x00C8 - 0x0000)
struct FOrionGameplayCueBatch final
{
public:
	TArray<struct FOrionGameplayCueBatch_Item>    Items;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 Parameters;                                        // 0x0010(0x00B8)(ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionGameplayCueBatch) == 0x000008, "Wrong alignment on FOrionGameplayCueBatch");
static_assert(sizeof(FOrionGameplayCueBatch) == 0x0000C8, "Wrong size on FOrionGameplayCueBatch");
static_assert(offsetof(FOrionGameplayCueBatch, Items) == 0x000000, "Member 'FOrionGameplayCueBatch::Items' has a wrong offset!");
static_assert(offsetof(FOrionGameplayCueBatch, Parameters) == 0x000010, "Member 'FOrionGameplayCueBatch::Parameters' has a wrong offset!");

// ScriptStruct OrionGame.SkinAttachmentBase
// 0x0030 (0x0030 - 0x0000)
struct FSkinAttachmentBase
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShowInGameOnly;                                   // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInterface*>             LoadedMaterials;                                   // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FSkinAttachmentMaterial>        AttachmentMaterials;                               // 0x0020(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkinAttachmentBase) == 0x000008, "Wrong alignment on FSkinAttachmentBase");
static_assert(sizeof(FSkinAttachmentBase) == 0x000030, "Wrong size on FSkinAttachmentBase");
static_assert(offsetof(FSkinAttachmentBase, bShowInGameOnly) == 0x000008, "Member 'FSkinAttachmentBase::bShowInGameOnly' has a wrong offset!");
static_assert(offsetof(FSkinAttachmentBase, LoadedMaterials) == 0x000010, "Member 'FSkinAttachmentBase::LoadedMaterials' has a wrong offset!");
static_assert(offsetof(FSkinAttachmentBase, AttachmentMaterials) == 0x000020, "Member 'FSkinAttachmentBase::AttachmentMaterials' has a wrong offset!");

// ScriptStruct OrionGame.SkinSocketedAttachment
// 0x0070 (0x00A0 - 0x0030)
struct FSkinSocketedAttachment final : public FSkinAttachmentBase
{
public:
	class FName                                   SocketName;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             AttachTransform;                                   // 0x0040(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UObject>                 Attachment;                                        // 0x0070(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                LoadedAttachment;                                  // 0x0098(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkinSocketedAttachment) == 0x000010, "Wrong alignment on FSkinSocketedAttachment");
static_assert(sizeof(FSkinSocketedAttachment) == 0x0000A0, "Wrong size on FSkinSocketedAttachment");
static_assert(offsetof(FSkinSocketedAttachment, SocketName) == 0x000030, "Member 'FSkinSocketedAttachment::SocketName' has a wrong offset!");
static_assert(offsetof(FSkinSocketedAttachment, AttachTransform) == 0x000040, "Member 'FSkinSocketedAttachment::AttachTransform' has a wrong offset!");
static_assert(offsetof(FSkinSocketedAttachment, Attachment) == 0x000070, "Member 'FSkinSocketedAttachment::Attachment' has a wrong offset!");
static_assert(offsetof(FSkinSocketedAttachment, LoadedAttachment) == 0x000098, "Member 'FSkinSocketedAttachment::LoadedAttachment' has a wrong offset!");

// ScriptStruct OrionGame.OrionAITeamParamsConfig
// 0x0020 (0x0020 - 0x0000)
struct FOrionAITeamParamsConfig final
{
public:
	class FString                                 HexGenome;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionAITeamParamsConfig) == 0x000008, "Wrong alignment on FOrionAITeamParamsConfig");
static_assert(sizeof(FOrionAITeamParamsConfig) == 0x000020, "Wrong size on FOrionAITeamParamsConfig");
static_assert(offsetof(FOrionAITeamParamsConfig, HexGenome) == 0x000000, "Member 'FOrionAITeamParamsConfig::HexGenome' has a wrong offset!");

// ScriptStruct OrionGame.OrionAbilityMontageContainer
// 0x0010 (0x0010 - 0x0000)
struct FOrionAbilityMontageContainer final
{
public:
	TArray<class UAnimMontage*>                   Montages;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionAbilityMontageContainer) == 0x000008, "Wrong alignment on FOrionAbilityMontageContainer");
static_assert(sizeof(FOrionAbilityMontageContainer) == 0x000010, "Wrong size on FOrionAbilityMontageContainer");
static_assert(offsetof(FOrionAbilityMontageContainer, Montages) == 0x000000, "Member 'FOrionAbilityMontageContainer::Montages' has a wrong offset!");

// ScriptStruct OrionGame.VictoryPlayerTracker
// 0x0010 (0x0010 - 0x0000)
struct FVictoryPlayerTracker final
{
public:
	class APlayerState*                           PlayerState;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  SpawnedVictoryChar;                                // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVictoryPlayerTracker) == 0x000008, "Wrong alignment on FVictoryPlayerTracker");
static_assert(sizeof(FVictoryPlayerTracker) == 0x000010, "Wrong size on FVictoryPlayerTracker");
static_assert(offsetof(FVictoryPlayerTracker, PlayerState) == 0x000000, "Member 'FVictoryPlayerTracker::PlayerState' has a wrong offset!");
static_assert(offsetof(FVictoryPlayerTracker, SpawnedVictoryChar) == 0x000008, "Member 'FVictoryPlayerTracker::SpawnedVictoryChar' has a wrong offset!");

// ScriptStruct OrionGame.OrionHeroAbilityFlags
// 0x0009 (0x0009 - 0x0000)
struct FOrionHeroAbilityFlags final
{
public:
	bool                                          bIsLMB;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRMB;                                            // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsQ;                                              // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsE;                                              // 0x0003(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsR;                                              // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCustom1;                                        // 0x0005(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCustom2;                                        // 0x0006(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCustom3;                                        // 0x0007(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAnyExceptLMB;                                   // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionHeroAbilityFlags) == 0x000001, "Wrong alignment on FOrionHeroAbilityFlags");
static_assert(sizeof(FOrionHeroAbilityFlags) == 0x000009, "Wrong size on FOrionHeroAbilityFlags");
static_assert(offsetof(FOrionHeroAbilityFlags, bIsLMB) == 0x000000, "Member 'FOrionHeroAbilityFlags::bIsLMB' has a wrong offset!");
static_assert(offsetof(FOrionHeroAbilityFlags, bIsRMB) == 0x000001, "Member 'FOrionHeroAbilityFlags::bIsRMB' has a wrong offset!");
static_assert(offsetof(FOrionHeroAbilityFlags, bIsQ) == 0x000002, "Member 'FOrionHeroAbilityFlags::bIsQ' has a wrong offset!");
static_assert(offsetof(FOrionHeroAbilityFlags, bIsE) == 0x000003, "Member 'FOrionHeroAbilityFlags::bIsE' has a wrong offset!");
static_assert(offsetof(FOrionHeroAbilityFlags, bIsR) == 0x000004, "Member 'FOrionHeroAbilityFlags::bIsR' has a wrong offset!");
static_assert(offsetof(FOrionHeroAbilityFlags, bIsCustom1) == 0x000005, "Member 'FOrionHeroAbilityFlags::bIsCustom1' has a wrong offset!");
static_assert(offsetof(FOrionHeroAbilityFlags, bIsCustom2) == 0x000006, "Member 'FOrionHeroAbilityFlags::bIsCustom2' has a wrong offset!");
static_assert(offsetof(FOrionHeroAbilityFlags, bIsCustom3) == 0x000007, "Member 'FOrionHeroAbilityFlags::bIsCustom3' has a wrong offset!");
static_assert(offsetof(FOrionHeroAbilityFlags, bIsAnyExceptLMB) == 0x000008, "Member 'FOrionHeroAbilityFlags::bIsAnyExceptLMB' has a wrong offset!");

// ScriptStruct OrionGame.OrionDraftHeroSelectionInfo
// 0x0030 (0x0030 - 0x0000)
struct FOrionDraftHeroSelectionInfo final
{
public:
	class FString                                 HeroName;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionHeroMasteryProgression           Mastery;                                           // 0x0010(0x0020)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionDraftHeroSelectionInfo) == 0x000008, "Wrong alignment on FOrionDraftHeroSelectionInfo");
static_assert(sizeof(FOrionDraftHeroSelectionInfo) == 0x000030, "Wrong size on FOrionDraftHeroSelectionInfo");
static_assert(offsetof(FOrionDraftHeroSelectionInfo, HeroName) == 0x000000, "Member 'FOrionDraftHeroSelectionInfo::HeroName' has a wrong offset!");
static_assert(offsetof(FOrionDraftHeroSelectionInfo, Mastery) == 0x000010, "Member 'FOrionDraftHeroSelectionInfo::Mastery' has a wrong offset!");

// ScriptStruct OrionGame.UICustomDescriptionLookup
// 0x0030 (0x0030 - 0x0000)
struct FUICustomDescriptionLookup final
{
public:
	class FString                                 Label;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   CurveRow;                                          // 0x0010(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionAbilitYToolTipLevelType                 LevelType;                                         // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SpecificColumn;                                    // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Coefficient;                                       // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AbsoluteValue;                                     // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUICustomDescriptionLookup) == 0x000008, "Wrong alignment on FUICustomDescriptionLookup");
static_assert(sizeof(FUICustomDescriptionLookup) == 0x000030, "Wrong size on FUICustomDescriptionLookup");
static_assert(offsetof(FUICustomDescriptionLookup, Label) == 0x000000, "Member 'FUICustomDescriptionLookup::Label' has a wrong offset!");
static_assert(offsetof(FUICustomDescriptionLookup, CurveRow) == 0x000010, "Member 'FUICustomDescriptionLookup::CurveRow' has a wrong offset!");
static_assert(offsetof(FUICustomDescriptionLookup, LevelType) == 0x000020, "Member 'FUICustomDescriptionLookup::LevelType' has a wrong offset!");
static_assert(offsetof(FUICustomDescriptionLookup, SpecificColumn) == 0x000024, "Member 'FUICustomDescriptionLookup::SpecificColumn' has a wrong offset!");
static_assert(offsetof(FUICustomDescriptionLookup, Coefficient) == 0x000028, "Member 'FUICustomDescriptionLookup::Coefficient' has a wrong offset!");
static_assert(offsetof(FUICustomDescriptionLookup, AbsoluteValue) == 0x00002C, "Member 'FUICustomDescriptionLookup::AbsoluteValue' has a wrong offset!");

// ScriptStruct OrionGame.UIDescriptionLookup
// 0x0020 (0x0020 - 0x0000)
struct FUIDescriptionLookup final
{
public:
	EOrionAbilityTooltipFactors                   Factor;                                            // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCurveTableRowHandle                   CurveRow;                                          // 0x0008(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionAbilitYToolTipLevelType                 LevelType;                                         // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIDescriptionLookup) == 0x000008, "Wrong alignment on FUIDescriptionLookup");
static_assert(sizeof(FUIDescriptionLookup) == 0x000020, "Wrong size on FUIDescriptionLookup");
static_assert(offsetof(FUIDescriptionLookup, Factor) == 0x000000, "Member 'FUIDescriptionLookup::Factor' has a wrong offset!");
static_assert(offsetof(FUIDescriptionLookup, CurveRow) == 0x000008, "Member 'FUIDescriptionLookup::CurveRow' has a wrong offset!");
static_assert(offsetof(FUIDescriptionLookup, LevelType) == 0x000018, "Member 'FUIDescriptionLookup::LevelType' has a wrong offset!");

// ScriptStruct OrionGame.PassiveHudRuntimeState
// 0x0020 (0x0020 - 0x0000)
struct FPassiveHudRuntimeState final
{
public:
	class UOrionAbility*                          Ability;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StackCount;                                        // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StackCountMax;                                     // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndTime;                                           // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHUDDisplayType                               DisplayType;                                       // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPassiveHudRuntimeState) == 0x000008, "Wrong alignment on FPassiveHudRuntimeState");
static_assert(sizeof(FPassiveHudRuntimeState) == 0x000020, "Wrong size on FPassiveHudRuntimeState");
static_assert(offsetof(FPassiveHudRuntimeState, Ability) == 0x000000, "Member 'FPassiveHudRuntimeState::Ability' has a wrong offset!");
static_assert(offsetof(FPassiveHudRuntimeState, StackCount) == 0x000008, "Member 'FPassiveHudRuntimeState::StackCount' has a wrong offset!");
static_assert(offsetof(FPassiveHudRuntimeState, StackCountMax) == 0x00000C, "Member 'FPassiveHudRuntimeState::StackCountMax' has a wrong offset!");
static_assert(offsetof(FPassiveHudRuntimeState, Duration) == 0x000010, "Member 'FPassiveHudRuntimeState::Duration' has a wrong offset!");
static_assert(offsetof(FPassiveHudRuntimeState, EndTime) == 0x000014, "Member 'FPassiveHudRuntimeState::EndTime' has a wrong offset!");
static_assert(offsetof(FPassiveHudRuntimeState, DisplayType) == 0x000018, "Member 'FPassiveHudRuntimeState::DisplayType' has a wrong offset!");

// ScriptStruct OrionGame.OrionAIBotCardEntry
// 0x0018 (0x0018 - 0x0000)
struct FOrionAIBotCardEntry final
{
public:
	TArray<TSoftObjectPtr<class UOrionLegacyCardItemDefinition>> CardData;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         RequiredActivationPoints;                          // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionAIBotCardEntry) == 0x000008, "Wrong alignment on FOrionAIBotCardEntry");
static_assert(sizeof(FOrionAIBotCardEntry) == 0x000018, "Wrong size on FOrionAIBotCardEntry");
static_assert(offsetof(FOrionAIBotCardEntry, CardData) == 0x000000, "Member 'FOrionAIBotCardEntry::CardData' has a wrong offset!");
static_assert(offsetof(FOrionAIBotCardEntry, RequiredActivationPoints) == 0x000010, "Member 'FOrionAIBotCardEntry::RequiredActivationPoints' has a wrong offset!");

// ScriptStruct OrionGame.OrionTBPlayerChoices
// 0x0108 (0x0108 - 0x0000)
struct FOrionTBPlayerChoices final
{
public:
	class FString                                 HeroName;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionCosmeticPlayerChoices            Cosmetic;                                          // 0x0010(0x00E0)(NativeAccessSpecifierPublic)
	class FString                                 DeckId;                                            // 0x00F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionPosition                                Position;                                          // 0x0100(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionRole                                    Role;                                              // 0x0101(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_102[0x6];                                      // 0x0102(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionTBPlayerChoices) == 0x000008, "Wrong alignment on FOrionTBPlayerChoices");
static_assert(sizeof(FOrionTBPlayerChoices) == 0x000108, "Wrong size on FOrionTBPlayerChoices");
static_assert(offsetof(FOrionTBPlayerChoices, HeroName) == 0x000000, "Member 'FOrionTBPlayerChoices::HeroName' has a wrong offset!");
static_assert(offsetof(FOrionTBPlayerChoices, Cosmetic) == 0x000010, "Member 'FOrionTBPlayerChoices::Cosmetic' has a wrong offset!");
static_assert(offsetof(FOrionTBPlayerChoices, DeckId) == 0x0000F0, "Member 'FOrionTBPlayerChoices::DeckId' has a wrong offset!");
static_assert(offsetof(FOrionTBPlayerChoices, Position) == 0x000100, "Member 'FOrionTBPlayerChoices::Position' has a wrong offset!");
static_assert(offsetof(FOrionTBPlayerChoices, Role) == 0x000101, "Member 'FOrionTBPlayerChoices::Role' has a wrong offset!");

// ScriptStruct OrionGame.OrionTBMemberInfo
// 0x0150 (0x0150 - 0x0000)
struct FOrionTBMemberInfo final
{
public:
	struct FUniqueNetIdRepl                       UniqueId;                                          // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIdx;                                           // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTBMemberState                           State;                                             // 0x001C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionTBPlayerChoices                  PlayerData;                                        // 0x0020(0x0108)(BlueprintVisible, NativeAccessSpecifierPublic)
	EAIBotDifficulty                              BotDifficulty;                                     // 0x0128(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBot;                                            // 0x0129(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12A[0x6];                                      // 0x012A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUniqueNetIdRepl                       PartyLeaderId;                                     // 0x0130(0x0018)(BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSocialParty;                                  // 0x0148(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bValidPlayer;                                      // 0x0149(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14A[0x6];                                      // 0x014A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionTBMemberInfo) == 0x000008, "Wrong alignment on FOrionTBMemberInfo");
static_assert(sizeof(FOrionTBMemberInfo) == 0x000150, "Wrong size on FOrionTBMemberInfo");
static_assert(offsetof(FOrionTBMemberInfo, UniqueId) == 0x000000, "Member 'FOrionTBMemberInfo::UniqueId' has a wrong offset!");
static_assert(offsetof(FOrionTBMemberInfo, SlotIdx) == 0x000018, "Member 'FOrionTBMemberInfo::SlotIdx' has a wrong offset!");
static_assert(offsetof(FOrionTBMemberInfo, State) == 0x00001C, "Member 'FOrionTBMemberInfo::State' has a wrong offset!");
static_assert(offsetof(FOrionTBMemberInfo, PlayerData) == 0x000020, "Member 'FOrionTBMemberInfo::PlayerData' has a wrong offset!");
static_assert(offsetof(FOrionTBMemberInfo, BotDifficulty) == 0x000128, "Member 'FOrionTBMemberInfo::BotDifficulty' has a wrong offset!");
static_assert(offsetof(FOrionTBMemberInfo, bIsBot) == 0x000129, "Member 'FOrionTBMemberInfo::bIsBot' has a wrong offset!");
static_assert(offsetof(FOrionTBMemberInfo, PartyLeaderId) == 0x000130, "Member 'FOrionTBMemberInfo::PartyLeaderId' has a wrong offset!");
static_assert(offsetof(FOrionTBMemberInfo, bFromSocialParty) == 0x000148, "Member 'FOrionTBMemberInfo::bFromSocialParty' has a wrong offset!");
static_assert(offsetof(FOrionTBMemberInfo, bValidPlayer) == 0x000149, "Member 'FOrionTBMemberInfo::bValidPlayer' has a wrong offset!");

// ScriptStruct OrionGame.GemTypeImageData
// 0x0030 (0x0030 - 0x0000)
struct FGemTypeImageData final
{
public:
	EOrionGemType                                 Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayText;                                       // 0x0008(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UTexture2D*>                     SizeTextures;                                      // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGemTypeImageData) == 0x000008, "Wrong alignment on FGemTypeImageData");
static_assert(sizeof(FGemTypeImageData) == 0x000030, "Wrong size on FGemTypeImageData");
static_assert(offsetof(FGemTypeImageData, Type) == 0x000000, "Member 'FGemTypeImageData::Type' has a wrong offset!");
static_assert(offsetof(FGemTypeImageData, DisplayText) == 0x000008, "Member 'FGemTypeImageData::DisplayText' has a wrong offset!");
static_assert(offsetof(FGemTypeImageData, SizeTextures) == 0x000020, "Member 'FGemTypeImageData::SizeTextures' has a wrong offset!");

// ScriptStruct OrionGame.StackCountRefreshInfo
// 0x0008 (0x0008 - 0x0000)
struct FStackCountRefreshInfo final
{
public:
	struct FGameplayAbilitySpecHandle             AbilitySpec;                                       // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ServerExpectedRefreshTime;                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStackCountRefreshInfo) == 0x000004, "Wrong alignment on FStackCountRefreshInfo");
static_assert(sizeof(FStackCountRefreshInfo) == 0x000008, "Wrong size on FStackCountRefreshInfo");
static_assert(offsetof(FStackCountRefreshInfo, AbilitySpec) == 0x000000, "Member 'FStackCountRefreshInfo::AbilitySpec' has a wrong offset!");
static_assert(offsetof(FStackCountRefreshInfo, ServerExpectedRefreshTime) == 0x000004, "Member 'FStackCountRefreshInfo::ServerExpectedRefreshTime' has a wrong offset!");

// ScriptStruct OrionGame.TrackedActorEntry
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FTrackedActorEntry final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTrackedActorEntry) == 0x000004, "Wrong alignment on FTrackedActorEntry");
static_assert(sizeof(FTrackedActorEntry) == 0x00000C, "Wrong size on FTrackedActorEntry");

// ScriptStruct OrionGame.OrionAimAssistOwnerInfo
// 0x00A0 (0x00A0 - 0x0000)
struct alignas(0x10) FOrionAimAssistOwnerInfo final
{
public:
	uint8                                         Pad_0[0xA0];                                       // 0x0000(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionAimAssistOwnerInfo) == 0x000010, "Wrong alignment on FOrionAimAssistOwnerInfo");
static_assert(sizeof(FOrionAimAssistOwnerInfo) == 0x0000A0, "Wrong size on FOrionAimAssistOwnerInfo");

// ScriptStruct OrionGame.TeamMemberInfo
// 0x0030 (0x0030 - 0x0000)
struct FTeamMemberInfo final
{
public:
	struct FUniqueNetIdRepl                       AccountId;                                         // 0x0000(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUniqueNetIdRepl                       PartyLeaderId;                                     // 0x0018(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTeamMemberInfo) == 0x000008, "Wrong alignment on FTeamMemberInfo");
static_assert(sizeof(FTeamMemberInfo) == 0x000030, "Wrong size on FTeamMemberInfo");
static_assert(offsetof(FTeamMemberInfo, AccountId) == 0x000000, "Member 'FTeamMemberInfo::AccountId' has a wrong offset!");
static_assert(offsetof(FTeamMemberInfo, PartyLeaderId) == 0x000018, "Member 'FTeamMemberInfo::PartyLeaderId' has a wrong offset!");

// ScriptStruct OrionGame.OrionSecondaryCooldownInfo
// 0x0050 (0x0050 - 0x0000)
struct FOrionSecondaryCooldownInfo final
{
public:
	struct FGameplayTagContainer                  AdditionalAbilityTags;                             // 0x0000(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EOrionCooldownType                            CooldownType;                                      // 0x0020(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         ExplicitValue;                                     // 0x0028(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionSecondaryCooldownInfo) == 0x000008, "Wrong alignment on FOrionSecondaryCooldownInfo");
static_assert(sizeof(FOrionSecondaryCooldownInfo) == 0x000050, "Wrong size on FOrionSecondaryCooldownInfo");
static_assert(offsetof(FOrionSecondaryCooldownInfo, AdditionalAbilityTags) == 0x000000, "Member 'FOrionSecondaryCooldownInfo::AdditionalAbilityTags' has a wrong offset!");
static_assert(offsetof(FOrionSecondaryCooldownInfo, CooldownType) == 0x000020, "Member 'FOrionSecondaryCooldownInfo::CooldownType' has a wrong offset!");
static_assert(offsetof(FOrionSecondaryCooldownInfo, ExplicitValue) == 0x000028, "Member 'FOrionSecondaryCooldownInfo::ExplicitValue' has a wrong offset!");

// ScriptStruct OrionGame.OrionCooldownInfo
// 0x0068 (0x0068 - 0x0000)
struct FOrionCooldownInfo final
{
public:
	EOrionCooldownType                            CooldownType;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  CooldownTags;                                      // 0x0008(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScalableFloat                         ExplicitValue;                                     // 0x0028(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FOrionSecondaryCooldownInfo>    SecondaryCooldowns;                                // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            CooldownGameplayEffect;                            // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionCooldownInfo) == 0x000008, "Wrong alignment on FOrionCooldownInfo");
static_assert(sizeof(FOrionCooldownInfo) == 0x000068, "Wrong size on FOrionCooldownInfo");
static_assert(offsetof(FOrionCooldownInfo, CooldownType) == 0x000000, "Member 'FOrionCooldownInfo::CooldownType' has a wrong offset!");
static_assert(offsetof(FOrionCooldownInfo, CooldownTags) == 0x000008, "Member 'FOrionCooldownInfo::CooldownTags' has a wrong offset!");
static_assert(offsetof(FOrionCooldownInfo, ExplicitValue) == 0x000028, "Member 'FOrionCooldownInfo::ExplicitValue' has a wrong offset!");
static_assert(offsetof(FOrionCooldownInfo, SecondaryCooldowns) == 0x000050, "Member 'FOrionCooldownInfo::SecondaryCooldowns' has a wrong offset!");
static_assert(offsetof(FOrionCooldownInfo, CooldownGameplayEffect) == 0x000060, "Member 'FOrionCooldownInfo::CooldownGameplayEffect' has a wrong offset!");

// ScriptStruct OrionGame.DefaultEQSQueries
// 0x02B8 (0x02B8 - 0x0000)
struct FDefaultEQSQueries final
{
public:
	TSoftObjectPtr<class UEnvQuery>               MeleePositioning;                                  // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UEnvQuery>               RangedPositioning;                                 // 0x0028(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UEnvQuery>               TacticalFallbackQuery;                             // 0x0050(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UEnvQuery>               BaseRecallQuery;                                   // 0x0078(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UEnvQuery>               RunAwayQuery;                                      // 0x00A0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UEnvQuery>               EnemySelectionInsideTurret;                        // 0x00C8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UEnvQuery>>       AuxQueries;                                        // 0x00F0(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UEnvQuery>               BodyguardEnemySelection;                           // 0x0100(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UEnvQuery>               MeleeEnemySelection[0x5];                          // 0x0128(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UEnvQuery>               RangedEnemySelection[0x5];                         // 0x01F0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDefaultEQSQueries) == 0x000008, "Wrong alignment on FDefaultEQSQueries");
static_assert(sizeof(FDefaultEQSQueries) == 0x0002B8, "Wrong size on FDefaultEQSQueries");
static_assert(offsetof(FDefaultEQSQueries, MeleePositioning) == 0x000000, "Member 'FDefaultEQSQueries::MeleePositioning' has a wrong offset!");
static_assert(offsetof(FDefaultEQSQueries, RangedPositioning) == 0x000028, "Member 'FDefaultEQSQueries::RangedPositioning' has a wrong offset!");
static_assert(offsetof(FDefaultEQSQueries, TacticalFallbackQuery) == 0x000050, "Member 'FDefaultEQSQueries::TacticalFallbackQuery' has a wrong offset!");
static_assert(offsetof(FDefaultEQSQueries, BaseRecallQuery) == 0x000078, "Member 'FDefaultEQSQueries::BaseRecallQuery' has a wrong offset!");
static_assert(offsetof(FDefaultEQSQueries, RunAwayQuery) == 0x0000A0, "Member 'FDefaultEQSQueries::RunAwayQuery' has a wrong offset!");
static_assert(offsetof(FDefaultEQSQueries, EnemySelectionInsideTurret) == 0x0000C8, "Member 'FDefaultEQSQueries::EnemySelectionInsideTurret' has a wrong offset!");
static_assert(offsetof(FDefaultEQSQueries, AuxQueries) == 0x0000F0, "Member 'FDefaultEQSQueries::AuxQueries' has a wrong offset!");
static_assert(offsetof(FDefaultEQSQueries, BodyguardEnemySelection) == 0x000100, "Member 'FDefaultEQSQueries::BodyguardEnemySelection' has a wrong offset!");
static_assert(offsetof(FDefaultEQSQueries, MeleeEnemySelection) == 0x000128, "Member 'FDefaultEQSQueries::MeleeEnemySelection' has a wrong offset!");
static_assert(offsetof(FDefaultEQSQueries, RangedEnemySelection) == 0x0001F0, "Member 'FDefaultEQSQueries::RangedEnemySelection' has a wrong offset!");

// ScriptStruct OrionGame.ActiveBoost
// 0x0018 (0x0018 - 0x0000)
struct FActiveBoost final
{
public:
	EOrionBoostType                               BoostType;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              ExpirationTime;                                    // 0x0008(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UsesRemaining;                                     // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActiveBoost) == 0x000008, "Wrong alignment on FActiveBoost");
static_assert(sizeof(FActiveBoost) == 0x000018, "Wrong size on FActiveBoost");
static_assert(offsetof(FActiveBoost, BoostType) == 0x000000, "Member 'FActiveBoost::BoostType' has a wrong offset!");
static_assert(offsetof(FActiveBoost, ExpirationTime) == 0x000008, "Member 'FActiveBoost::ExpirationTime' has a wrong offset!");
static_assert(offsetof(FActiveBoost, UsesRemaining) == 0x000010, "Member 'FActiveBoost::UsesRemaining' has a wrong offset!");

// ScriptStruct OrionGame.GemRankNames
// 0x0020 (0x0020 - 0x0000)
struct FGemRankNames final
{
public:
	EOrionGemRank                                 Rank;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   RankText;                                          // 0x0008(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGemRankNames) == 0x000008, "Wrong alignment on FGemRankNames");
static_assert(sizeof(FGemRankNames) == 0x000020, "Wrong size on FGemRankNames");
static_assert(offsetof(FGemRankNames, Rank) == 0x000000, "Member 'FGemRankNames::Rank' has a wrong offset!");
static_assert(offsetof(FGemRankNames, RankText) == 0x000008, "Member 'FGemRankNames::RankText' has a wrong offset!");

// ScriptStruct OrionGame.ButtonLegendItem
// 0x0020 (0x0020 - 0x0000)
struct FButtonLegendItem final
{
public:
	class FName                                   Action;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ActionText;                                        // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FButtonLegendItem) == 0x000008, "Wrong alignment on FButtonLegendItem");
static_assert(sizeof(FButtonLegendItem) == 0x000020, "Wrong size on FButtonLegendItem");
static_assert(offsetof(FButtonLegendItem, Action) == 0x000000, "Member 'FButtonLegendItem::Action' has a wrong offset!");
static_assert(offsetof(FButtonLegendItem, ActionText) == 0x000008, "Member 'FButtonLegendItem::ActionText' has a wrong offset!");

// ScriptStruct OrionGame.OrionActorPrioritizer
// 0x0008 (0x0008 - 0x0000)
struct FOrionActorPrioritizer final
{
public:
	EOrionActorPrioritizerOriginPolicy            RelativeTo;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionActorPrioritizerSortPolicy              SortOn;                                            // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionActorPrioritizerDimensionPolicy         Dimension;                                         // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxResults;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionActorPrioritizer) == 0x000004, "Wrong alignment on FOrionActorPrioritizer");
static_assert(sizeof(FOrionActorPrioritizer) == 0x000008, "Wrong size on FOrionActorPrioritizer");
static_assert(offsetof(FOrionActorPrioritizer, RelativeTo) == 0x000000, "Member 'FOrionActorPrioritizer::RelativeTo' has a wrong offset!");
static_assert(offsetof(FOrionActorPrioritizer, SortOn) == 0x000001, "Member 'FOrionActorPrioritizer::SortOn' has a wrong offset!");
static_assert(offsetof(FOrionActorPrioritizer, Dimension) == 0x000002, "Member 'FOrionActorPrioritizer::Dimension' has a wrong offset!");
static_assert(offsetof(FOrionActorPrioritizer, MaxResults) == 0x000004, "Member 'FOrionActorPrioritizer::MaxResults' has a wrong offset!");

// ScriptStruct OrionGame.OrionPartyMemberRepState
// 0x0010 (0x0018 - 0x0008)
struct FOrionPartyMemberRepState : public FPartyMemberRepState
{
public:
	int32                                         AccountLevel;                                      // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LevelProgress;                                     // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAfk;                                              // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsConsole;                                        // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionPartyMemberRepState) == 0x000008, "Wrong alignment on FOrionPartyMemberRepState");
static_assert(sizeof(FOrionPartyMemberRepState) == 0x000018, "Wrong size on FOrionPartyMemberRepState");
static_assert(offsetof(FOrionPartyMemberRepState, AccountLevel) == 0x000008, "Member 'FOrionPartyMemberRepState::AccountLevel' has a wrong offset!");
static_assert(offsetof(FOrionPartyMemberRepState, LevelProgress) == 0x00000C, "Member 'FOrionPartyMemberRepState::LevelProgress' has a wrong offset!");
static_assert(offsetof(FOrionPartyMemberRepState, bAfk) == 0x000010, "Member 'FOrionPartyMemberRepState::bAfk' has a wrong offset!");
static_assert(offsetof(FOrionPartyMemberRepState, bIsConsole) == 0x000011, "Member 'FOrionPartyMemberRepState::bIsConsole' has a wrong offset!");

// ScriptStruct OrionGame.OrionPersistentPartyMemberRepState
// 0x0028 (0x0040 - 0x0018)
struct FOrionPersistentPartyMemberRepState final : public FOrionPartyMemberRepState
{
public:
	EOrionPartyMemberLocation                     Location;                                          // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReady;                                            // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionAcceptMatchState                        AcceptMatchState;                                  // 0x001A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x5];                                       // 0x001B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 HeroName;                                          // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoaded;                                           // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MMR;                                               // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMMRAdjustedForNewPlayer;                          // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionBanReason                               BanReason;                                         // 0x0039(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionPersistentPartyMemberRepState) == 0x000008, "Wrong alignment on FOrionPersistentPartyMemberRepState");
static_assert(sizeof(FOrionPersistentPartyMemberRepState) == 0x000040, "Wrong size on FOrionPersistentPartyMemberRepState");
static_assert(offsetof(FOrionPersistentPartyMemberRepState, Location) == 0x000018, "Member 'FOrionPersistentPartyMemberRepState::Location' has a wrong offset!");
static_assert(offsetof(FOrionPersistentPartyMemberRepState, bReady) == 0x000019, "Member 'FOrionPersistentPartyMemberRepState::bReady' has a wrong offset!");
static_assert(offsetof(FOrionPersistentPartyMemberRepState, AcceptMatchState) == 0x00001A, "Member 'FOrionPersistentPartyMemberRepState::AcceptMatchState' has a wrong offset!");
static_assert(offsetof(FOrionPersistentPartyMemberRepState, HeroName) == 0x000020, "Member 'FOrionPersistentPartyMemberRepState::HeroName' has a wrong offset!");
static_assert(offsetof(FOrionPersistentPartyMemberRepState, bLoaded) == 0x000030, "Member 'FOrionPersistentPartyMemberRepState::bLoaded' has a wrong offset!");
static_assert(offsetof(FOrionPersistentPartyMemberRepState, MMR) == 0x000034, "Member 'FOrionPersistentPartyMemberRepState::MMR' has a wrong offset!");
static_assert(offsetof(FOrionPersistentPartyMemberRepState, bMMRAdjustedForNewPlayer) == 0x000038, "Member 'FOrionPersistentPartyMemberRepState::bMMRAdjustedForNewPlayer' has a wrong offset!");
static_assert(offsetof(FOrionPersistentPartyMemberRepState, BanReason) == 0x000039, "Member 'FOrionPersistentPartyMemberRepState::BanReason' has a wrong offset!");

// ScriptStruct OrionGame.OrionLoadedMCPItemManager
// 0x00B0 (0x00B0 - 0x0000)
struct FOrionLoadedMCPItemManager final
{
public:
	uint8                                         Pad_0[0xA0];                                       // 0x0000(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionMcpItemDefinition*                NewItem;                                           // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLimitsEnabled;                                    // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionLoadedMCPItemManager) == 0x000008, "Wrong alignment on FOrionLoadedMCPItemManager");
static_assert(sizeof(FOrionLoadedMCPItemManager) == 0x0000B0, "Wrong size on FOrionLoadedMCPItemManager");
static_assert(offsetof(FOrionLoadedMCPItemManager, NewItem) == 0x0000A0, "Member 'FOrionLoadedMCPItemManager::NewItem' has a wrong offset!");
static_assert(offsetof(FOrionLoadedMCPItemManager, bLimitsEnabled) == 0x0000A8, "Member 'FOrionLoadedMCPItemManager::bLimitsEnabled' has a wrong offset!");

// ScriptStruct OrionGame.OrionShapeFacetBeam
// 0x0030 (0x0040 - 0x0010)
struct FOrionShapeFacetBeam final : public FOrionShapeFacet
{
public:
	uint8                                         Pad_10[0x30];                                      // 0x0010(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionShapeFacetBeam) == 0x000008, "Wrong alignment on FOrionShapeFacetBeam");
static_assert(sizeof(FOrionShapeFacetBeam) == 0x000040, "Wrong size on FOrionShapeFacetBeam");

// ScriptStruct OrionGame.AIAbilityTarget
// 0x0028 (0x0028 - 0x0000)
struct FAIAbilityTarget final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 AsActor;                                           // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIAbilityTarget) == 0x000008, "Wrong alignment on FAIAbilityTarget");
static_assert(sizeof(FAIAbilityTarget) == 0x000028, "Wrong size on FAIAbilityTarget");
static_assert(offsetof(FAIAbilityTarget, AsActor) == 0x000020, "Member 'FAIAbilityTarget::AsActor' has a wrong offset!");

// ScriptStruct OrionGame.BotEnemySelection
// 0x0028 (0x0028 - 0x0000)
struct FBotEnemySelection final
{
public:
	class UEnvQuery*                              DefaultQuery;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEnvQuery*                              OverrideQuery;                                     // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         AdditionalTargets;                                 // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         EnemySelectionTeamMask;                            // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBotEnemySelection) == 0x000008, "Wrong alignment on FBotEnemySelection");
static_assert(sizeof(FBotEnemySelection) == 0x000028, "Wrong size on FBotEnemySelection");
static_assert(offsetof(FBotEnemySelection, DefaultQuery) == 0x000000, "Member 'FBotEnemySelection::DefaultQuery' has a wrong offset!");
static_assert(offsetof(FBotEnemySelection, OverrideQuery) == 0x000008, "Member 'FBotEnemySelection::OverrideQuery' has a wrong offset!");
static_assert(offsetof(FBotEnemySelection, AdditionalTargets) == 0x000010, "Member 'FBotEnemySelection::AdditionalTargets' has a wrong offset!");
static_assert(offsetof(FBotEnemySelection, EnemySelectionTeamMask) == 0x000020, "Member 'FBotEnemySelection::EnemySelectionTeamMask' has a wrong offset!");

// ScriptStruct OrionGame.AIEnemy
// 0x0010 (0x0010 - 0x0000)
struct FAIEnemy final
{
public:
	class AOrionChar*                             AsChar;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionDamageableActor*                  AsDamagable;                                       // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIEnemy) == 0x000008, "Wrong alignment on FAIEnemy");
static_assert(sizeof(FAIEnemy) == 0x000010, "Wrong size on FAIEnemy");
static_assert(offsetof(FAIEnemy, AsChar) == 0x000000, "Member 'FAIEnemy::AsChar' has a wrong offset!");
static_assert(offsetof(FAIEnemy, AsDamagable) == 0x000008, "Member 'FAIEnemy::AsDamagable' has a wrong offset!");

// ScriptStruct OrionGame.EventKeywordCollectionItem
// 0x00B0 (0x00B0 - 0x0000)
struct FEventKeywordCollectionItem final
{
public:
	struct FEventKeywordWithQualifiers            Event;                                             // 0x0000(0x0090)(Edit, NativeAccessSpecifierPublic)
	int32                                         GrantFlags;                                        // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnTriggered;                                       // 0x0098(0x0010)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   NamedEventOnTriggered;                             // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventKeywordCollectionItem) == 0x000008, "Wrong alignment on FEventKeywordCollectionItem");
static_assert(sizeof(FEventKeywordCollectionItem) == 0x0000B0, "Wrong size on FEventKeywordCollectionItem");
static_assert(offsetof(FEventKeywordCollectionItem, Event) == 0x000000, "Member 'FEventKeywordCollectionItem::Event' has a wrong offset!");
static_assert(offsetof(FEventKeywordCollectionItem, GrantFlags) == 0x000090, "Member 'FEventKeywordCollectionItem::GrantFlags' has a wrong offset!");
static_assert(offsetof(FEventKeywordCollectionItem, OnTriggered) == 0x000098, "Member 'FEventKeywordCollectionItem::OnTriggered' has a wrong offset!");
static_assert(offsetof(FEventKeywordCollectionItem, NamedEventOnTriggered) == 0x0000A8, "Member 'FEventKeywordCollectionItem::NamedEventOnTriggered' has a wrong offset!");

// ScriptStruct OrionGame.HighlightDefinition
// 0x00E0 (0x00E0 - 0x0000)
struct FHighlightDefinition final
{
public:
	class FName                                   HighlightID;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   HighlightText;                                     // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FEventKeywordCollectionItem            TrackedEvent;                                      // 0x0020(0x00B0)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         StartDeltaMS;                                      // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndDeltaMS;                                        // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionHighlightType                           HighlightTags;                                     // 0x00D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionHighlightSignificance                   Significance;                                      // 0x00D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DA[0x6];                                       // 0x00DA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHighlightDefinition) == 0x000008, "Wrong alignment on FHighlightDefinition");
static_assert(sizeof(FHighlightDefinition) == 0x0000E0, "Wrong size on FHighlightDefinition");
static_assert(offsetof(FHighlightDefinition, HighlightID) == 0x000000, "Member 'FHighlightDefinition::HighlightID' has a wrong offset!");
static_assert(offsetof(FHighlightDefinition, HighlightText) == 0x000008, "Member 'FHighlightDefinition::HighlightText' has a wrong offset!");
static_assert(offsetof(FHighlightDefinition, TrackedEvent) == 0x000020, "Member 'FHighlightDefinition::TrackedEvent' has a wrong offset!");
static_assert(offsetof(FHighlightDefinition, StartDeltaMS) == 0x0000D0, "Member 'FHighlightDefinition::StartDeltaMS' has a wrong offset!");
static_assert(offsetof(FHighlightDefinition, EndDeltaMS) == 0x0000D4, "Member 'FHighlightDefinition::EndDeltaMS' has a wrong offset!");
static_assert(offsetof(FHighlightDefinition, HighlightTags) == 0x0000D8, "Member 'FHighlightDefinition::HighlightTags' has a wrong offset!");
static_assert(offsetof(FHighlightDefinition, Significance) == 0x0000D9, "Member 'FHighlightDefinition::Significance' has a wrong offset!");

// ScriptStruct OrionGame.DraftStats_PenalizedPlayers
// 0x0020 (0x0020 - 0x0000)
struct FDraftStats_PenalizedPlayers final
{
public:
	struct FUniqueNetIdRepl                       UniqueId;                                          // 0x0000(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionDraftAbortPenaltyReason                 AbortReason;                                       // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDraftStats_PenalizedPlayers) == 0x000008, "Wrong alignment on FDraftStats_PenalizedPlayers");
static_assert(sizeof(FDraftStats_PenalizedPlayers) == 0x000020, "Wrong size on FDraftStats_PenalizedPlayers");
static_assert(offsetof(FDraftStats_PenalizedPlayers, UniqueId) == 0x000000, "Member 'FDraftStats_PenalizedPlayers::UniqueId' has a wrong offset!");
static_assert(offsetof(FDraftStats_PenalizedPlayers, AbortReason) == 0x000018, "Member 'FDraftStats_PenalizedPlayers::AbortReason' has a wrong offset!");

// ScriptStruct OrionGame.OrionLandingEffectEntry
// 0x0010 (0x0010 - 0x0000)
struct FOrionLandingEffectEntry final
{
public:
	float                                         MinImpactSpeed;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayCueTag                        GCToTrigger;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionLandingEffectEntry) == 0x000008, "Wrong alignment on FOrionLandingEffectEntry");
static_assert(sizeof(FOrionLandingEffectEntry) == 0x000010, "Wrong size on FOrionLandingEffectEntry");
static_assert(offsetof(FOrionLandingEffectEntry, MinImpactSpeed) == 0x000000, "Member 'FOrionLandingEffectEntry::MinImpactSpeed' has a wrong offset!");
static_assert(offsetof(FOrionLandingEffectEntry, GCToTrigger) == 0x000008, "Member 'FOrionLandingEffectEntry::GCToTrigger' has a wrong offset!");

// ScriptStruct OrionGame.ItemAbilityHandle
// 0x0010 (0x0010 - 0x0000)
struct FItemAbilityHandle final
{
public:
	struct FSimpleAbilityKeywordTag               AbilityKeyword;                                    // 0x0000(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilitySpecHandle             BaseHandle;                                        // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilitySpecHandle             GrantedAbilityHandle;                              // 0x000C(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemAbilityHandle) == 0x000008, "Wrong alignment on FItemAbilityHandle");
static_assert(sizeof(FItemAbilityHandle) == 0x000010, "Wrong size on FItemAbilityHandle");
static_assert(offsetof(FItemAbilityHandle, AbilityKeyword) == 0x000000, "Member 'FItemAbilityHandle::AbilityKeyword' has a wrong offset!");
static_assert(offsetof(FItemAbilityHandle, BaseHandle) == 0x000008, "Member 'FItemAbilityHandle::BaseHandle' has a wrong offset!");
static_assert(offsetof(FItemAbilityHandle, GrantedAbilityHandle) == 0x00000C, "Member 'FItemAbilityHandle::GrantedAbilityHandle' has a wrong offset!");

// ScriptStruct OrionGame.NamedHeroList
// 0x0020 (0x0020 - 0x0000)
struct FNamedHeroList final
{
public:
	class FString                                 HeroSetName;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UOrionHeroData>>  HeroList;                                          // 0x0010(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNamedHeroList) == 0x000008, "Wrong alignment on FNamedHeroList");
static_assert(sizeof(FNamedHeroList) == 0x000020, "Wrong size on FNamedHeroList");
static_assert(offsetof(FNamedHeroList, HeroSetName) == 0x000000, "Member 'FNamedHeroList::HeroSetName' has a wrong offset!");
static_assert(offsetof(FNamedHeroList, HeroList) == 0x000010, "Member 'FNamedHeroList::HeroList' has a wrong offset!");

// ScriptStruct OrionGame.AIGenericQueryinCachedValue
// 0x0018 (0x0018 - 0x0000)
struct FAIGenericQueryinCachedValue final
{
public:
	TArray<class AActor*>                         Actors;                                            // 0x0000(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIGenericQueryinCachedValue) == 0x000008, "Wrong alignment on FAIGenericQueryinCachedValue");
static_assert(sizeof(FAIGenericQueryinCachedValue) == 0x000018, "Wrong size on FAIGenericQueryinCachedValue");
static_assert(offsetof(FAIGenericQueryinCachedValue, Actors) == 0x000000, "Member 'FAIGenericQueryinCachedValue::Actors' has a wrong offset!");

// ScriptStruct OrionGame.AIGenericQueryingContext
// 0x0038 (0x0038 - 0x0000)
struct FAIGenericQueryingContext final
{
public:
	class AOrionAIBot*                            QuerierAI;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AOrionPlayerController_Game*            QuerierPC;                                         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOrionAICommander*                      AICommander;                                       // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AOrionPlayerState_Game*                 PlayerState;                                       // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FAIGenericQueryinCachedValue>   CachedValues;                                      // 0x0020(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIGenericQueryingContext) == 0x000008, "Wrong alignment on FAIGenericQueryingContext");
static_assert(sizeof(FAIGenericQueryingContext) == 0x000038, "Wrong size on FAIGenericQueryingContext");
static_assert(offsetof(FAIGenericQueryingContext, QuerierAI) == 0x000000, "Member 'FAIGenericQueryingContext::QuerierAI' has a wrong offset!");
static_assert(offsetof(FAIGenericQueryingContext, QuerierPC) == 0x000008, "Member 'FAIGenericQueryingContext::QuerierPC' has a wrong offset!");
static_assert(offsetof(FAIGenericQueryingContext, AICommander) == 0x000010, "Member 'FAIGenericQueryingContext::AICommander' has a wrong offset!");
static_assert(offsetof(FAIGenericQueryingContext, PlayerState) == 0x000018, "Member 'FAIGenericQueryingContext::PlayerState' has a wrong offset!");
static_assert(offsetof(FAIGenericQueryingContext, CachedValues) == 0x000020, "Member 'FAIGenericQueryingContext::CachedValues' has a wrong offset!");

// ScriptStruct OrionGame.MenuClassEntry
// 0x0010 (0x0010 - 0x0000)
struct FMenuClassEntry final
{
public:
	TSubclassOf<class UUserWidget>                WidgetClass;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionMenuSlotTypes                           WidgetSlotType;                                    // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionDesiredAnalogCursorState                CursorState;                                       // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMenuClassEntry) == 0x000008, "Wrong alignment on FMenuClassEntry");
static_assert(sizeof(FMenuClassEntry) == 0x000010, "Wrong size on FMenuClassEntry");
static_assert(offsetof(FMenuClassEntry, WidgetClass) == 0x000000, "Member 'FMenuClassEntry::WidgetClass' has a wrong offset!");
static_assert(offsetof(FMenuClassEntry, WidgetSlotType) == 0x000008, "Member 'FMenuClassEntry::WidgetSlotType' has a wrong offset!");
static_assert(offsetof(FMenuClassEntry, CursorState) == 0x000009, "Member 'FMenuClassEntry::CursorState' has a wrong offset!");

// ScriptStruct OrionGame.AILaneMarkup
// 0x0028 (0x0040 - 0x0018)
struct FAILaneMarkup final : public FAIRouteMarkup
{
public:
	TArray<class AOrionDamageableObjective_Base*> Towers;                                            // 0x0018(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class AOrionCharAISpawner*                    Spawners[0x2];                                     // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAILanePosition                               TeamLaneType[0x2];                                 // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAILaneMarkup) == 0x000008, "Wrong alignment on FAILaneMarkup");
static_assert(sizeof(FAILaneMarkup) == 0x000040, "Wrong size on FAILaneMarkup");
static_assert(offsetof(FAILaneMarkup, Towers) == 0x000018, "Member 'FAILaneMarkup::Towers' has a wrong offset!");
static_assert(offsetof(FAILaneMarkup, Spawners) == 0x000028, "Member 'FAILaneMarkup::Spawners' has a wrong offset!");
static_assert(offsetof(FAILaneMarkup, TeamLaneType) == 0x000038, "Member 'FAILaneMarkup::TeamLaneType' has a wrong offset!");

// ScriptStruct OrionGame.OrionAimAssist
// 0x00E0 (0x00E0 - 0x0000)
struct alignas(0x10) FOrionAimAssist final
{
public:
	uint8                                         Pad_0[0xE0];                                       // 0x0000(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionAimAssist) == 0x000010, "Wrong alignment on FOrionAimAssist");
static_assert(sizeof(FOrionAimAssist) == 0x0000E0, "Wrong size on FOrionAimAssist");

// ScriptStruct OrionGame.OrionAimAssistTarget
// 0x0048 (0x0048 - 0x0000)
struct FOrionAimAssistTarget final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCapsuleComponent*                      Capsule;                                           // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x38];                                      // 0x0010(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionAimAssistTarget) == 0x000008, "Wrong alignment on FOrionAimAssistTarget");
static_assert(sizeof(FOrionAimAssistTarget) == 0x000048, "Wrong size on FOrionAimAssistTarget");
static_assert(offsetof(FOrionAimAssistTarget, Actor) == 0x000000, "Member 'FOrionAimAssistTarget::Actor' has a wrong offset!");
static_assert(offsetof(FOrionAimAssistTarget, Capsule) == 0x000008, "Member 'FOrionAimAssistTarget::Capsule' has a wrong offset!");

// ScriptStruct OrionGame.OrionAimAssistTargetAggregator
// 0x0028 (0x0028 - 0x0000)
struct FOrionAimAssistTargetAggregator final
{
public:
	TArray<struct FOrionAimAssistTarget>          TargetCache0;                                      // 0x0000(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FOrionAimAssistTarget>          TargetCache1;                                      // 0x0010(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionAimAssistTargetAggregator) == 0x000008, "Wrong alignment on FOrionAimAssistTargetAggregator");
static_assert(sizeof(FOrionAimAssistTargetAggregator) == 0x000028, "Wrong size on FOrionAimAssistTargetAggregator");
static_assert(offsetof(FOrionAimAssistTargetAggregator, TargetCache0) == 0x000000, "Member 'FOrionAimAssistTargetAggregator::TargetCache0' has a wrong offset!");
static_assert(offsetof(FOrionAimAssistTargetAggregator, TargetCache1) == 0x000010, "Member 'FOrionAimAssistTargetAggregator::TargetCache1' has a wrong offset!");

// ScriptStruct OrionGame.OrionAimAssistResults
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FOrionAimAssistResults final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionAimAssistResults) == 0x000004, "Wrong alignment on FOrionAimAssistResults");
static_assert(sizeof(FOrionAimAssistResults) == 0x000018, "Wrong size on FOrionAimAssistResults");

// ScriptStruct OrionGame.OrionHeroAbilityTags
// 0x0040 (0x0040 - 0x0000)
struct FOrionHeroAbilityTags final
{
public:
	struct FGameplayTag                           LMB;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           RMB;                                               // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Q;                                                 // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           E;                                                 // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           R;                                                 // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Custom1;                                           // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Custom2;                                           // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Custom3;                                           // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionHeroAbilityTags) == 0x000008, "Wrong alignment on FOrionHeroAbilityTags");
static_assert(sizeof(FOrionHeroAbilityTags) == 0x000040, "Wrong size on FOrionHeroAbilityTags");
static_assert(offsetof(FOrionHeroAbilityTags, LMB) == 0x000000, "Member 'FOrionHeroAbilityTags::LMB' has a wrong offset!");
static_assert(offsetof(FOrionHeroAbilityTags, RMB) == 0x000008, "Member 'FOrionHeroAbilityTags::RMB' has a wrong offset!");
static_assert(offsetof(FOrionHeroAbilityTags, Q) == 0x000010, "Member 'FOrionHeroAbilityTags::Q' has a wrong offset!");
static_assert(offsetof(FOrionHeroAbilityTags, E) == 0x000018, "Member 'FOrionHeroAbilityTags::E' has a wrong offset!");
static_assert(offsetof(FOrionHeroAbilityTags, R) == 0x000020, "Member 'FOrionHeroAbilityTags::R' has a wrong offset!");
static_assert(offsetof(FOrionHeroAbilityTags, Custom1) == 0x000028, "Member 'FOrionHeroAbilityTags::Custom1' has a wrong offset!");
static_assert(offsetof(FOrionHeroAbilityTags, Custom2) == 0x000030, "Member 'FOrionHeroAbilityTags::Custom2' has a wrong offset!");
static_assert(offsetof(FOrionHeroAbilityTags, Custom3) == 0x000038, "Member 'FOrionHeroAbilityTags::Custom3' has a wrong offset!");

// ScriptStruct OrionGame.OrionPlaylistInfo
// 0x00C0 (0x00C0 - 0x0000)
struct FOrionPlaylistInfo final
{
public:
	int32                                         PlaylistId;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlaylistName;                                      // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShipping;                                         // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxTeams;                                          // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamSize;                                          // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPlayers;                                        // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRanked;                                           // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSupportsCustomMMKey;                              // 0x0029(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAwardXP;                                          // 0x002A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowRejoin;                                      // 0x002B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowSurrender;                                   // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasFriendlyBots;                                  // 0x002D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasEnemyBots;                                     // 0x002E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSoloMode;                                       // 0x002F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowMirrorMatches;                               // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSupportsDraftInReplays;                           // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdvertisedByMMS;                                  // 0x0032(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33[0x5];                                       // 0x0033(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RatingType;                                        // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LoadingScreen;                                     // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowPostMatchSummary;                             // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTutorial;                                       // 0x0059(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReplayFlag;                                        // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LobbyMap;                                          // 0x0070(0x0010)(Edit, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameMap;                                           // 0x0080(0x0010)(Edit, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameModeClass;                                     // 0x0090(0x0010)(Edit, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LobbyGameModeClass;                                // 0x00A0(0x0010)(Edit, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ArcadeURL;                                         // 0x00B0(0x0010)(Edit, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionPlaylistInfo) == 0x000008, "Wrong alignment on FOrionPlaylistInfo");
static_assert(sizeof(FOrionPlaylistInfo) == 0x0000C0, "Wrong size on FOrionPlaylistInfo");
static_assert(offsetof(FOrionPlaylistInfo, PlaylistId) == 0x000000, "Member 'FOrionPlaylistInfo::PlaylistId' has a wrong offset!");
static_assert(offsetof(FOrionPlaylistInfo, PlaylistName) == 0x000008, "Member 'FOrionPlaylistInfo::PlaylistName' has a wrong offset!");
static_assert(offsetof(FOrionPlaylistInfo, bShipping) == 0x000018, "Member 'FOrionPlaylistInfo::bShipping' has a wrong offset!");
static_assert(offsetof(FOrionPlaylistInfo, MaxTeams) == 0x00001C, "Member 'FOrionPlaylistInfo::MaxTeams' has a wrong offset!");
static_assert(offsetof(FOrionPlaylistInfo, TeamSize) == 0x000020, "Member 'FOrionPlaylistInfo::TeamSize' has a wrong offset!");
static_assert(offsetof(FOrionPlaylistInfo, MaxPlayers) == 0x000024, "Member 'FOrionPlaylistInfo::MaxPlayers' has a wrong offset!");
static_assert(offsetof(FOrionPlaylistInfo, bRanked) == 0x000028, "Member 'FOrionPlaylistInfo::bRanked' has a wrong offset!");
static_assert(offsetof(FOrionPlaylistInfo, bSupportsCustomMMKey) == 0x000029, "Member 'FOrionPlaylistInfo::bSupportsCustomMMKey' has a wrong offset!");
static_assert(offsetof(FOrionPlaylistInfo, bAwardXP) == 0x00002A, "Member 'FOrionPlaylistInfo::bAwardXP' has a wrong offset!");
static_assert(offsetof(FOrionPlaylistInfo, bAllowRejoin) == 0x00002B, "Member 'FOrionPlaylistInfo::bAllowRejoin' has a wrong offset!");
static_assert(offsetof(FOrionPlaylistInfo, bAllowSurrender) == 0x00002C, "Member 'FOrionPlaylistInfo::bAllowSurrender' has a wrong offset!");
static_assert(offsetof(FOrionPlaylistInfo, bHasFriendlyBots) == 0x00002D, "Member 'FOrionPlaylistInfo::bHasFriendlyBots' has a wrong offset!");
static_assert(offsetof(FOrionPlaylistInfo, bHasEnemyBots) == 0x00002E, "Member 'FOrionPlaylistInfo::bHasEnemyBots' has a wrong offset!");
static_assert(offsetof(FOrionPlaylistInfo, bIsSoloMode) == 0x00002F, "Member 'FOrionPlaylistInfo::bIsSoloMode' has a wrong offset!");
static_assert(offsetof(FOrionPlaylistInfo, bAllowMirrorMatches) == 0x000030, "Member 'FOrionPlaylistInfo::bAllowMirrorMatches' has a wrong offset!");
static_assert(offsetof(FOrionPlaylistInfo, bSupportsDraftInReplays) == 0x000031, "Member 'FOrionPlaylistInfo::bSupportsDraftInReplays' has a wrong offset!");
static_assert(offsetof(FOrionPlaylistInfo, bAdvertisedByMMS) == 0x000032, "Member 'FOrionPlaylistInfo::bAdvertisedByMMS' has a wrong offset!");
static_assert(offsetof(FOrionPlaylistInfo, RatingType) == 0x000038, "Member 'FOrionPlaylistInfo::RatingType' has a wrong offset!");
static_assert(offsetof(FOrionPlaylistInfo, LoadingScreen) == 0x000048, "Member 'FOrionPlaylistInfo::LoadingScreen' has a wrong offset!");
static_assert(offsetof(FOrionPlaylistInfo, bShowPostMatchSummary) == 0x000058, "Member 'FOrionPlaylistInfo::bShowPostMatchSummary' has a wrong offset!");
static_assert(offsetof(FOrionPlaylistInfo, bIsTutorial) == 0x000059, "Member 'FOrionPlaylistInfo::bIsTutorial' has a wrong offset!");
static_assert(offsetof(FOrionPlaylistInfo, ReplayFlag) == 0x000060, "Member 'FOrionPlaylistInfo::ReplayFlag' has a wrong offset!");
static_assert(offsetof(FOrionPlaylistInfo, LobbyMap) == 0x000070, "Member 'FOrionPlaylistInfo::LobbyMap' has a wrong offset!");
static_assert(offsetof(FOrionPlaylistInfo, GameMap) == 0x000080, "Member 'FOrionPlaylistInfo::GameMap' has a wrong offset!");
static_assert(offsetof(FOrionPlaylistInfo, GameModeClass) == 0x000090, "Member 'FOrionPlaylistInfo::GameModeClass' has a wrong offset!");
static_assert(offsetof(FOrionPlaylistInfo, LobbyGameModeClass) == 0x0000A0, "Member 'FOrionPlaylistInfo::LobbyGameModeClass' has a wrong offset!");
static_assert(offsetof(FOrionPlaylistInfo, ArcadeURL) == 0x0000B0, "Member 'FOrionPlaylistInfo::ArcadeURL' has a wrong offset!");

// ScriptStruct OrionGame.RoboSelectParams
// 0x0010 (0x0010 - 0x0000)
struct FRoboSelectParams final
{
public:
	class FString                                 BucketId;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoboSelectParams) == 0x000008, "Wrong alignment on FRoboSelectParams");
static_assert(sizeof(FRoboSelectParams) == 0x000010, "Wrong size on FRoboSelectParams");
static_assert(offsetof(FRoboSelectParams, BucketId) == 0x000000, "Member 'FRoboSelectParams::BucketId' has a wrong offset!");

// ScriptStruct OrionGame.OrionAimAssistParams
// 0x0028 (0x0028 - 0x0000)
struct FOrionAimAssistParams final
{
public:
	class AOrionCharHero*                         OwningHero;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x20];                                       // 0x0008(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionAimAssistParams) == 0x000008, "Wrong alignment on FOrionAimAssistParams");
static_assert(sizeof(FOrionAimAssistParams) == 0x000028, "Wrong size on FOrionAimAssistParams");
static_assert(offsetof(FOrionAimAssistParams, OwningHero) == 0x000000, "Member 'FOrionAimAssistParams::OwningHero' has a wrong offset!");

// ScriptStruct OrionGame.MinionAuxAggroSet
// 0x0010 (0x0010 - 0x0000)
struct FMinionAuxAggroSet final
{
public:
	TArray<class AOrionDamageableActor*>          Targets;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMinionAuxAggroSet) == 0x000008, "Wrong alignment on FMinionAuxAggroSet");
static_assert(sizeof(FMinionAuxAggroSet) == 0x000010, "Wrong size on FMinionAuxAggroSet");
static_assert(offsetof(FMinionAuxAggroSet, Targets) == 0x000000, "Member 'FMinionAuxAggroSet::Targets' has a wrong offset!");

// ScriptStruct OrionGame.GravesiteData
// 0x0014 (0x0014 - 0x0000)
struct FGravesiteData final
{
public:
	bool                                          bGravesitesEnabled;                                // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SecondsWithinRadiusForBannerSpawn;                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifespanSeconds;                                   // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnDelaySeconds;                                 // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBannerEntrance                               BannerEntrance;                                    // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGravesiteData) == 0x000004, "Wrong alignment on FGravesiteData");
static_assert(sizeof(FGravesiteData) == 0x000014, "Wrong size on FGravesiteData");
static_assert(offsetof(FGravesiteData, bGravesitesEnabled) == 0x000000, "Member 'FGravesiteData::bGravesitesEnabled' has a wrong offset!");
static_assert(offsetof(FGravesiteData, SecondsWithinRadiusForBannerSpawn) == 0x000004, "Member 'FGravesiteData::SecondsWithinRadiusForBannerSpawn' has a wrong offset!");
static_assert(offsetof(FGravesiteData, LifespanSeconds) == 0x000008, "Member 'FGravesiteData::LifespanSeconds' has a wrong offset!");
static_assert(offsetof(FGravesiteData, SpawnDelaySeconds) == 0x00000C, "Member 'FGravesiteData::SpawnDelaySeconds' has a wrong offset!");
static_assert(offsetof(FGravesiteData, BannerEntrance) == 0x000010, "Member 'FGravesiteData::BannerEntrance' has a wrong offset!");

// ScriptStruct OrionGame.GameplayVolumeComponentEffectsOverlapTracker
// 0x0030 (0x0030 - 0x0000)
struct FGameplayVolumeComponentEffectsOverlapTracker final
{
public:
	int32                                         OverlapCount;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasAppliedPeriodicEffect;                         // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTickDisabled;                                     // 0x0005(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FActiveGameplayEffectHandle>    EffectsApplied;                                    // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayAbilitySpecHandle             GrantedAbilitySpecHandle;                          // 0x0018(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  Actor;                                             // 0x001C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UOrionGameplayVolumeComponent> ParentVolume;                                      // 0x0024(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayVolumeComponentEffectsOverlapTracker) == 0x000008, "Wrong alignment on FGameplayVolumeComponentEffectsOverlapTracker");
static_assert(sizeof(FGameplayVolumeComponentEffectsOverlapTracker) == 0x000030, "Wrong size on FGameplayVolumeComponentEffectsOverlapTracker");
static_assert(offsetof(FGameplayVolumeComponentEffectsOverlapTracker, OverlapCount) == 0x000000, "Member 'FGameplayVolumeComponentEffectsOverlapTracker::OverlapCount' has a wrong offset!");
static_assert(offsetof(FGameplayVolumeComponentEffectsOverlapTracker, bHasAppliedPeriodicEffect) == 0x000004, "Member 'FGameplayVolumeComponentEffectsOverlapTracker::bHasAppliedPeriodicEffect' has a wrong offset!");
static_assert(offsetof(FGameplayVolumeComponentEffectsOverlapTracker, bTickDisabled) == 0x000005, "Member 'FGameplayVolumeComponentEffectsOverlapTracker::bTickDisabled' has a wrong offset!");
static_assert(offsetof(FGameplayVolumeComponentEffectsOverlapTracker, EffectsApplied) == 0x000008, "Member 'FGameplayVolumeComponentEffectsOverlapTracker::EffectsApplied' has a wrong offset!");
static_assert(offsetof(FGameplayVolumeComponentEffectsOverlapTracker, GrantedAbilitySpecHandle) == 0x000018, "Member 'FGameplayVolumeComponentEffectsOverlapTracker::GrantedAbilitySpecHandle' has a wrong offset!");
static_assert(offsetof(FGameplayVolumeComponentEffectsOverlapTracker, Actor) == 0x00001C, "Member 'FGameplayVolumeComponentEffectsOverlapTracker::Actor' has a wrong offset!");
static_assert(offsetof(FGameplayVolumeComponentEffectsOverlapTracker, ParentVolume) == 0x000024, "Member 'FGameplayVolumeComponentEffectsOverlapTracker::ParentVolume' has a wrong offset!");

// ScriptStruct OrionGame.MinionProjectileData
// 0x0068 (0x0068 - 0x0000)
struct FMinionProjectileData final
{
public:
	class UParticleSystemComponent*               PSC;                                               // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NCmp;                                              // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x50];                                      // 0x0018(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMinionProjectileData) == 0x000008, "Wrong alignment on FMinionProjectileData");
static_assert(sizeof(FMinionProjectileData) == 0x000068, "Wrong size on FMinionProjectileData");
static_assert(offsetof(FMinionProjectileData, PSC) == 0x000000, "Member 'FMinionProjectileData::PSC' has a wrong offset!");
static_assert(offsetof(FMinionProjectileData, NCmp) == 0x000008, "Member 'FMinionProjectileData::NCmp' has a wrong offset!");
static_assert(offsetof(FMinionProjectileData, TargetActor) == 0x000010, "Member 'FMinionProjectileData::TargetActor' has a wrong offset!");

// ScriptStruct OrionGame.OrionProjectileNiagaraComponentArray
// 0x0010 (0x0010 - 0x0000)
struct FOrionProjectileNiagaraComponentArray final
{
public:
	TArray<class UNiagaraComponent*>              Components;                                        // 0x0000(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionProjectileNiagaraComponentArray) == 0x000008, "Wrong alignment on FOrionProjectileNiagaraComponentArray");
static_assert(sizeof(FOrionProjectileNiagaraComponentArray) == 0x000010, "Wrong size on FOrionProjectileNiagaraComponentArray");
static_assert(offsetof(FOrionProjectileNiagaraComponentArray, Components) == 0x000000, "Member 'FOrionProjectileNiagaraComponentArray::Components' has a wrong offset!");

// ScriptStruct OrionGame.OrionDynamicWall_BaseDefinition
// 0x0018 (0x0018 - 0x0000)
struct FOrionDynamicWall_BaseDefinition final
{
public:
	class UStaticMesh*                            CollisionMesh;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            VisualMesh;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionDynamicWall_BaseDefinition) == 0x000008, "Wrong alignment on FOrionDynamicWall_BaseDefinition");
static_assert(sizeof(FOrionDynamicWall_BaseDefinition) == 0x000018, "Wrong size on FOrionDynamicWall_BaseDefinition");
static_assert(offsetof(FOrionDynamicWall_BaseDefinition, CollisionMesh) == 0x000000, "Member 'FOrionDynamicWall_BaseDefinition::CollisionMesh' has a wrong offset!");
static_assert(offsetof(FOrionDynamicWall_BaseDefinition, VisualMesh) == 0x000008, "Member 'FOrionDynamicWall_BaseDefinition::VisualMesh' has a wrong offset!");
static_assert(offsetof(FOrionDynamicWall_BaseDefinition, Height) == 0x000010, "Member 'FOrionDynamicWall_BaseDefinition::Height' has a wrong offset!");

// ScriptStruct OrionGame.OrionDesiredStencilValueEntry
// 0x0008 (0x0008 - 0x0000)
struct FOrionDesiredStencilValueEntry final
{
public:
	bool                                          bShouldBeActive;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DesiredStencilValue;                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionDesiredStencilValueEntry) == 0x000004, "Wrong alignment on FOrionDesiredStencilValueEntry");
static_assert(sizeof(FOrionDesiredStencilValueEntry) == 0x000008, "Wrong size on FOrionDesiredStencilValueEntry");
static_assert(offsetof(FOrionDesiredStencilValueEntry, bShouldBeActive) == 0x000000, "Member 'FOrionDesiredStencilValueEntry::bShouldBeActive' has a wrong offset!");
static_assert(offsetof(FOrionDesiredStencilValueEntry, DesiredStencilValue) == 0x000004, "Member 'FOrionDesiredStencilValueEntry::DesiredStencilValue' has a wrong offset!");

// ScriptStruct OrionGame.ObjectiveDifficultyAttributeModifier
// 0x00B0 (0x00B0 - 0x0000)
struct FObjectiveDifficultyAttributeModifier final
{
public:
	float                                         MaxHealth[0x4];                                    // 0x0000(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthRegenRate[0x4];                              // 0x0010(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AbilityResistanceRating[0x4];                      // 0x0020(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BasicResistanceRating[0x4];                        // 0x0030(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackRating[0x4];                                 // 0x0040(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseAttackTime[0x4];                               // 0x0050(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackSpeedRating[0x4];                            // 0x0060(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackRadius[0x4];                                 // 0x0070(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackHeight[0x4];                                 // 0x0080(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetDelayTime[0x4];                              // 0x0090(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisionRadius[0x4];                                 // 0x00A0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObjectiveDifficultyAttributeModifier) == 0x000004, "Wrong alignment on FObjectiveDifficultyAttributeModifier");
static_assert(sizeof(FObjectiveDifficultyAttributeModifier) == 0x0000B0, "Wrong size on FObjectiveDifficultyAttributeModifier");
static_assert(offsetof(FObjectiveDifficultyAttributeModifier, MaxHealth) == 0x000000, "Member 'FObjectiveDifficultyAttributeModifier::MaxHealth' has a wrong offset!");
static_assert(offsetof(FObjectiveDifficultyAttributeModifier, HealthRegenRate) == 0x000010, "Member 'FObjectiveDifficultyAttributeModifier::HealthRegenRate' has a wrong offset!");
static_assert(offsetof(FObjectiveDifficultyAttributeModifier, AbilityResistanceRating) == 0x000020, "Member 'FObjectiveDifficultyAttributeModifier::AbilityResistanceRating' has a wrong offset!");
static_assert(offsetof(FObjectiveDifficultyAttributeModifier, BasicResistanceRating) == 0x000030, "Member 'FObjectiveDifficultyAttributeModifier::BasicResistanceRating' has a wrong offset!");
static_assert(offsetof(FObjectiveDifficultyAttributeModifier, AttackRating) == 0x000040, "Member 'FObjectiveDifficultyAttributeModifier::AttackRating' has a wrong offset!");
static_assert(offsetof(FObjectiveDifficultyAttributeModifier, BaseAttackTime) == 0x000050, "Member 'FObjectiveDifficultyAttributeModifier::BaseAttackTime' has a wrong offset!");
static_assert(offsetof(FObjectiveDifficultyAttributeModifier, AttackSpeedRating) == 0x000060, "Member 'FObjectiveDifficultyAttributeModifier::AttackSpeedRating' has a wrong offset!");
static_assert(offsetof(FObjectiveDifficultyAttributeModifier, AttackRadius) == 0x000070, "Member 'FObjectiveDifficultyAttributeModifier::AttackRadius' has a wrong offset!");
static_assert(offsetof(FObjectiveDifficultyAttributeModifier, AttackHeight) == 0x000080, "Member 'FObjectiveDifficultyAttributeModifier::AttackHeight' has a wrong offset!");
static_assert(offsetof(FObjectiveDifficultyAttributeModifier, TargetDelayTime) == 0x000090, "Member 'FObjectiveDifficultyAttributeModifier::TargetDelayTime' has a wrong offset!");
static_assert(offsetof(FObjectiveDifficultyAttributeModifier, VisionRadius) == 0x0000A0, "Member 'FObjectiveDifficultyAttributeModifier::VisionRadius' has a wrong offset!");

// ScriptStruct OrionGame.MinionDifficultyAttributeModifier
// 0x0060 (0x0060 - 0x0000)
struct FMinionDifficultyAttributeModifier final
{
public:
	float                                         Damage[0x8];                                       // 0x0000(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Health[0x8];                                       // 0x0020(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSpeed[0x8];                                    // 0x0040(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMinionDifficultyAttributeModifier) == 0x000004, "Wrong alignment on FMinionDifficultyAttributeModifier");
static_assert(sizeof(FMinionDifficultyAttributeModifier) == 0x000060, "Wrong size on FMinionDifficultyAttributeModifier");
static_assert(offsetof(FMinionDifficultyAttributeModifier, Damage) == 0x000000, "Member 'FMinionDifficultyAttributeModifier::Damage' has a wrong offset!");
static_assert(offsetof(FMinionDifficultyAttributeModifier, Health) == 0x000020, "Member 'FMinionDifficultyAttributeModifier::Health' has a wrong offset!");
static_assert(offsetof(FMinionDifficultyAttributeModifier, MoveSpeed) == 0x000040, "Member 'FMinionDifficultyAttributeModifier::MoveSpeed' has a wrong offset!");

// ScriptStruct OrionGame.NavFieldSingleDirectionTile
// 0x0018 (0x0018 - 0x0000)
struct FNavFieldSingleDirectionTile final
{
public:
	int16                                         TileX;                                             // 0x0000(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         TileY;                                             // 0x0002(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UniqueRouteId;                                     // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint16>                                FieldData;                                         // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNavFieldSingleDirectionTile) == 0x000008, "Wrong alignment on FNavFieldSingleDirectionTile");
static_assert(sizeof(FNavFieldSingleDirectionTile) == 0x000018, "Wrong size on FNavFieldSingleDirectionTile");
static_assert(offsetof(FNavFieldSingleDirectionTile, TileX) == 0x000000, "Member 'FNavFieldSingleDirectionTile::TileX' has a wrong offset!");
static_assert(offsetof(FNavFieldSingleDirectionTile, TileY) == 0x000002, "Member 'FNavFieldSingleDirectionTile::TileY' has a wrong offset!");
static_assert(offsetof(FNavFieldSingleDirectionTile, UniqueRouteId) == 0x000004, "Member 'FNavFieldSingleDirectionTile::UniqueRouteId' has a wrong offset!");
static_assert(offsetof(FNavFieldSingleDirectionTile, FieldData) == 0x000008, "Member 'FNavFieldSingleDirectionTile::FieldData' has a wrong offset!");

// ScriptStruct OrionGame.AILaneWhitelist
// 0x0001 (0x0001 - 0x0000)
struct FAILaneWhitelist final
{
public:
	uint8                                         Left : 1;                                          // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Middle : 1;                                        // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Right : 1;                                         // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
};
static_assert(alignof(FAILaneWhitelist) == 0x000001, "Wrong alignment on FAILaneWhitelist");
static_assert(sizeof(FAILaneWhitelist) == 0x000001, "Wrong size on FAILaneWhitelist");

// ScriptStruct OrionGame.MiniMapRotationEntry
// 0x0008 (0x0008 - 0x0000)
struct FMiniMapRotationEntry final
{
public:
	float                                         Rotation;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    TeamNum;                                           // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMiniMapRotationEntry) == 0x000004, "Wrong alignment on FMiniMapRotationEntry");
static_assert(sizeof(FMiniMapRotationEntry) == 0x000008, "Wrong size on FMiniMapRotationEntry");
static_assert(offsetof(FMiniMapRotationEntry, Rotation) == 0x000000, "Member 'FMiniMapRotationEntry::Rotation' has a wrong offset!");
static_assert(offsetof(FMiniMapRotationEntry, TeamNum) == 0x000004, "Member 'FMiniMapRotationEntry::TeamNum' has a wrong offset!");

// ScriptStruct OrionGame.AIInfluence
// 0x0010 (0x0010 - 0x0000)
struct FAIInfluence final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FullEffectRadius;                                  // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIActorClassification                        SourceType;                                        // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIInfluence) == 0x000004, "Wrong alignment on FAIInfluence");
static_assert(sizeof(FAIInfluence) == 0x000010, "Wrong size on FAIInfluence");
static_assert(offsetof(FAIInfluence, Value) == 0x000000, "Member 'FAIInfluence::Value' has a wrong offset!");
static_assert(offsetof(FAIInfluence, FullEffectRadius) == 0x000004, "Member 'FAIInfluence::FullEffectRadius' has a wrong offset!");
static_assert(offsetof(FAIInfluence, SourceType) == 0x000008, "Member 'FAIInfluence::SourceType' has a wrong offset!");

// ScriptStruct OrionGame.BTRef
// 0x0020 (0x0020 - 0x0000)
struct FBTRef final
{
public:
	struct FSoftObjectPath                        Ref;                                               // 0x0000(0x0018)(Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBehaviorTree*                          BT;                                                // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBTRef) == 0x000008, "Wrong alignment on FBTRef");
static_assert(sizeof(FBTRef) == 0x000020, "Wrong size on FBTRef");
static_assert(offsetof(FBTRef, Ref) == 0x000000, "Member 'FBTRef::Ref' has a wrong offset!");
static_assert(offsetof(FBTRef, BT) == 0x000018, "Member 'FBTRef::BT' has a wrong offset!");

// ScriptStruct OrionGame.AIBotDifficultySettings
// 0x00A8 (0x00A8 - 0x0000)
struct FAIBotDifficultySettings final
{
public:
	float                                         RecommendedAbilityRangeModifier;                   // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrimaryCooldownModifier;                           // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownModifier;                                  // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvailableCardPointsModifier;                       // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalAngleDeviation;                          // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalAngleDeviationVsMinions;                 // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLevel;                                          // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxAbilityLevel;                                   // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalTimeToSpendAtHomeBase;                   // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemySelectionRange;                               // 0x0024(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrategyObjectiveAssigningDelay;                   // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthPctToRunAwayMelee;                           // 0x002C(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthPctToRunAwayRanged;                          // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowAbsoluteHealth;                                 // 0x0034(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthPercentageToStartHealing;                    // 0x0038(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ManaPercentageToStartRegenning;                    // 0x003C(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxManaPercentageToUseOnMinions;                   // 0x0040(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThreatRegularToFleeThreshold;                      // 0x0044(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThreatFleeToRegularThreshold;                      // 0x0048(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThreatRegularToAggressiveThreshold;                // 0x004C(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThreatAggressiveToRegularThreshold;                // 0x0050(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBTRef                                 BTOverride;                                        // 0x0058(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UEnvQuery>               EnemySelectionOverride;                            // 0x0078(0x0028)(BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x4];                                       // 0x00A0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bCanUseUlt : 1;                                    // 0x00A4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanUseActiveCards : 1;                            // 0x00A4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanPlaceAndUseRigs : 1;                           // 0x00A4(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowRecallingBack : 1;                           // 0x00A4(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAvoidBeingDamagedByTowers : 1;                    // 0x00A4(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAvoidAoEAttacks : 1;                              // 0x00A4(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (BlueprintVisible, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayerAsLastResortTarget : 1;                     // 0x00A4(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (BlueprintVisible, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseMapLogic : 1;                                  // 0x00A4(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (BlueprintVisible, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bReceivedDamageAwareness : 1;                      // 0x00A5(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A6[0x2];                                       // 0x00A6(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIBotDifficultySettings) == 0x000008, "Wrong alignment on FAIBotDifficultySettings");
static_assert(sizeof(FAIBotDifficultySettings) == 0x0000A8, "Wrong size on FAIBotDifficultySettings");
static_assert(offsetof(FAIBotDifficultySettings, RecommendedAbilityRangeModifier) == 0x000000, "Member 'FAIBotDifficultySettings::RecommendedAbilityRangeModifier' has a wrong offset!");
static_assert(offsetof(FAIBotDifficultySettings, PrimaryCooldownModifier) == 0x000004, "Member 'FAIBotDifficultySettings::PrimaryCooldownModifier' has a wrong offset!");
static_assert(offsetof(FAIBotDifficultySettings, CooldownModifier) == 0x000008, "Member 'FAIBotDifficultySettings::CooldownModifier' has a wrong offset!");
static_assert(offsetof(FAIBotDifficultySettings, AvailableCardPointsModifier) == 0x00000C, "Member 'FAIBotDifficultySettings::AvailableCardPointsModifier' has a wrong offset!");
static_assert(offsetof(FAIBotDifficultySettings, HorizontalAngleDeviation) == 0x000010, "Member 'FAIBotDifficultySettings::HorizontalAngleDeviation' has a wrong offset!");
static_assert(offsetof(FAIBotDifficultySettings, HorizontalAngleDeviationVsMinions) == 0x000014, "Member 'FAIBotDifficultySettings::HorizontalAngleDeviationVsMinions' has a wrong offset!");
static_assert(offsetof(FAIBotDifficultySettings, MaxLevel) == 0x000018, "Member 'FAIBotDifficultySettings::MaxLevel' has a wrong offset!");
static_assert(offsetof(FAIBotDifficultySettings, MaxAbilityLevel) == 0x00001C, "Member 'FAIBotDifficultySettings::MaxAbilityLevel' has a wrong offset!");
static_assert(offsetof(FAIBotDifficultySettings, AdditionalTimeToSpendAtHomeBase) == 0x000020, "Member 'FAIBotDifficultySettings::AdditionalTimeToSpendAtHomeBase' has a wrong offset!");
static_assert(offsetof(FAIBotDifficultySettings, EnemySelectionRange) == 0x000024, "Member 'FAIBotDifficultySettings::EnemySelectionRange' has a wrong offset!");
static_assert(offsetof(FAIBotDifficultySettings, StrategyObjectiveAssigningDelay) == 0x000028, "Member 'FAIBotDifficultySettings::StrategyObjectiveAssigningDelay' has a wrong offset!");
static_assert(offsetof(FAIBotDifficultySettings, HealthPctToRunAwayMelee) == 0x00002C, "Member 'FAIBotDifficultySettings::HealthPctToRunAwayMelee' has a wrong offset!");
static_assert(offsetof(FAIBotDifficultySettings, HealthPctToRunAwayRanged) == 0x000030, "Member 'FAIBotDifficultySettings::HealthPctToRunAwayRanged' has a wrong offset!");
static_assert(offsetof(FAIBotDifficultySettings, LowAbsoluteHealth) == 0x000034, "Member 'FAIBotDifficultySettings::LowAbsoluteHealth' has a wrong offset!");
static_assert(offsetof(FAIBotDifficultySettings, HealthPercentageToStartHealing) == 0x000038, "Member 'FAIBotDifficultySettings::HealthPercentageToStartHealing' has a wrong offset!");
static_assert(offsetof(FAIBotDifficultySettings, ManaPercentageToStartRegenning) == 0x00003C, "Member 'FAIBotDifficultySettings::ManaPercentageToStartRegenning' has a wrong offset!");
static_assert(offsetof(FAIBotDifficultySettings, MaxManaPercentageToUseOnMinions) == 0x000040, "Member 'FAIBotDifficultySettings::MaxManaPercentageToUseOnMinions' has a wrong offset!");
static_assert(offsetof(FAIBotDifficultySettings, ThreatRegularToFleeThreshold) == 0x000044, "Member 'FAIBotDifficultySettings::ThreatRegularToFleeThreshold' has a wrong offset!");
static_assert(offsetof(FAIBotDifficultySettings, ThreatFleeToRegularThreshold) == 0x000048, "Member 'FAIBotDifficultySettings::ThreatFleeToRegularThreshold' has a wrong offset!");
static_assert(offsetof(FAIBotDifficultySettings, ThreatRegularToAggressiveThreshold) == 0x00004C, "Member 'FAIBotDifficultySettings::ThreatRegularToAggressiveThreshold' has a wrong offset!");
static_assert(offsetof(FAIBotDifficultySettings, ThreatAggressiveToRegularThreshold) == 0x000050, "Member 'FAIBotDifficultySettings::ThreatAggressiveToRegularThreshold' has a wrong offset!");
static_assert(offsetof(FAIBotDifficultySettings, BTOverride) == 0x000058, "Member 'FAIBotDifficultySettings::BTOverride' has a wrong offset!");
static_assert(offsetof(FAIBotDifficultySettings, EnemySelectionOverride) == 0x000078, "Member 'FAIBotDifficultySettings::EnemySelectionOverride' has a wrong offset!");

// ScriptStruct OrionGame.OrientationWarpingSettings
// 0x0040 (0x0040 - 0x0000)
struct FOrientationWarpingSettings final
{
public:
	EAxis                                         YawRotationAxis;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BodyOrientationAlpha;                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOrientationWarpingSpineBoneSettings> SpineBones;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         IKFootRootBone;                                    // 0x0018(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FBoneReference>                 IKFootBones;                                       // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrientationWarpingSettings) == 0x000008, "Wrong alignment on FOrientationWarpingSettings");
static_assert(sizeof(FOrientationWarpingSettings) == 0x000040, "Wrong size on FOrientationWarpingSettings");
static_assert(offsetof(FOrientationWarpingSettings, YawRotationAxis) == 0x000000, "Member 'FOrientationWarpingSettings::YawRotationAxis' has a wrong offset!");
static_assert(offsetof(FOrientationWarpingSettings, BodyOrientationAlpha) == 0x000004, "Member 'FOrientationWarpingSettings::BodyOrientationAlpha' has a wrong offset!");
static_assert(offsetof(FOrientationWarpingSettings, SpineBones) == 0x000008, "Member 'FOrientationWarpingSettings::SpineBones' has a wrong offset!");
static_assert(offsetof(FOrientationWarpingSettings, IKFootRootBone) == 0x000018, "Member 'FOrientationWarpingSettings::IKFootRootBone' has a wrong offset!");
static_assert(offsetof(FOrientationWarpingSettings, IKFootBones) == 0x000030, "Member 'FOrientationWarpingSettings::IKFootBones' has a wrong offset!");

// ScriptStruct OrionGame.OrientationWarpingSpineBoneData
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FOrientationWarpingSpineBoneData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrientationWarpingSpineBoneData) == 0x000004, "Wrong alignment on FOrientationWarpingSpineBoneData");
static_assert(sizeof(FOrientationWarpingSpineBoneData) == 0x000008, "Wrong size on FOrientationWarpingSpineBoneData");

// ScriptStruct OrionGame.OrionAnimNode_OrientationWarping
// 0x0088 (0x00B8 - 0x0030)
struct FOrionAnimNode_OrientationWarping final : public FAnimNode_Base
{
public:
	struct FPoseLink                              Source;                                            // 0x0030(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LocomotionAngle;                                   // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrientationWarpingSettings            Settings;                                          // 0x0050(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FOrientationWarpingSpineBoneData> SpineBoneDataArray;                                // 0x0090(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x14];                                      // 0x00A0(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bBonesHaveBeenCached;                              // 0x00B4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionAnimNode_OrientationWarping) == 0x000008, "Wrong alignment on FOrionAnimNode_OrientationWarping");
static_assert(sizeof(FOrionAnimNode_OrientationWarping) == 0x0000B8, "Wrong size on FOrionAnimNode_OrientationWarping");
static_assert(offsetof(FOrionAnimNode_OrientationWarping, Source) == 0x000030, "Member 'FOrionAnimNode_OrientationWarping::Source' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_OrientationWarping, LocomotionAngle) == 0x000048, "Member 'FOrionAnimNode_OrientationWarping::LocomotionAngle' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_OrientationWarping, Settings) == 0x000050, "Member 'FOrionAnimNode_OrientationWarping::Settings' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_OrientationWarping, SpineBoneDataArray) == 0x000090, "Member 'FOrionAnimNode_OrientationWarping::SpineBoneDataArray' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_OrientationWarping, bBonesHaveBeenCached) == 0x0000B4, "Member 'FOrionAnimNode_OrientationWarping::bBonesHaveBeenCached' has a wrong offset!");

// ScriptStruct OrionGame.CardRef
// 0x0020 (0x0020 - 0x0000)
struct FCardRef final
{
public:
	struct FSoftObjectPath                        Ref;                                               // 0x0000(0x0018)(Edit, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionLegacyCardItemDefinition*         Card;                                              // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCardRef) == 0x000008, "Wrong alignment on FCardRef");
static_assert(sizeof(FCardRef) == 0x000020, "Wrong size on FCardRef");
static_assert(offsetof(FCardRef, Ref) == 0x000000, "Member 'FCardRef::Ref' has a wrong offset!");
static_assert(offsetof(FCardRef, Card) == 0x000018, "Member 'FCardRef::Card' has a wrong offset!");

// ScriptStruct OrionGame.AnalyticsDamageLogEntry
// 0x0040 (0x0040 - 0x0000)
struct FAnalyticsDamageLogEntry final
{
public:
	class FString                                 PlayerId;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InstigatorDisplayName;                             // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InstigatorAbilityName;                             // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumHits;                                           // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageAmount;                                      // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DamageWasPhysical;                                 // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DamageWasEnergy;                                   // 0x0039(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DamageWasPure;                                     // 0x003A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DamageWasCritical;                                 // 0x003B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PlayerHasRedBuff;                                  // 0x003C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PlayerHasPrimeHelix;                               // 0x003D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnalyticsDamageLogEntry) == 0x000008, "Wrong alignment on FAnalyticsDamageLogEntry");
static_assert(sizeof(FAnalyticsDamageLogEntry) == 0x000040, "Wrong size on FAnalyticsDamageLogEntry");
static_assert(offsetof(FAnalyticsDamageLogEntry, PlayerId) == 0x000000, "Member 'FAnalyticsDamageLogEntry::PlayerId' has a wrong offset!");
static_assert(offsetof(FAnalyticsDamageLogEntry, InstigatorDisplayName) == 0x000010, "Member 'FAnalyticsDamageLogEntry::InstigatorDisplayName' has a wrong offset!");
static_assert(offsetof(FAnalyticsDamageLogEntry, InstigatorAbilityName) == 0x000020, "Member 'FAnalyticsDamageLogEntry::InstigatorAbilityName' has a wrong offset!");
static_assert(offsetof(FAnalyticsDamageLogEntry, NumHits) == 0x000030, "Member 'FAnalyticsDamageLogEntry::NumHits' has a wrong offset!");
static_assert(offsetof(FAnalyticsDamageLogEntry, DamageAmount) == 0x000034, "Member 'FAnalyticsDamageLogEntry::DamageAmount' has a wrong offset!");
static_assert(offsetof(FAnalyticsDamageLogEntry, DamageWasPhysical) == 0x000038, "Member 'FAnalyticsDamageLogEntry::DamageWasPhysical' has a wrong offset!");
static_assert(offsetof(FAnalyticsDamageLogEntry, DamageWasEnergy) == 0x000039, "Member 'FAnalyticsDamageLogEntry::DamageWasEnergy' has a wrong offset!");
static_assert(offsetof(FAnalyticsDamageLogEntry, DamageWasPure) == 0x00003A, "Member 'FAnalyticsDamageLogEntry::DamageWasPure' has a wrong offset!");
static_assert(offsetof(FAnalyticsDamageLogEntry, DamageWasCritical) == 0x00003B, "Member 'FAnalyticsDamageLogEntry::DamageWasCritical' has a wrong offset!");
static_assert(offsetof(FAnalyticsDamageLogEntry, PlayerHasRedBuff) == 0x00003C, "Member 'FAnalyticsDamageLogEntry::PlayerHasRedBuff' has a wrong offset!");
static_assert(offsetof(FAnalyticsDamageLogEntry, PlayerHasPrimeHelix) == 0x00003D, "Member 'FAnalyticsDamageLogEntry::PlayerHasPrimeHelix' has a wrong offset!");

// ScriptStruct OrionGame.LinkedOverlapUpdateData
// 0x000C (0x000C - 0x0000)
struct FLinkedOverlapUpdateData final
{
public:
	int32                                         OverlapCounter;                                    // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  OverlapActor;                                      // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLinkedOverlapUpdateData) == 0x000004, "Wrong alignment on FLinkedOverlapUpdateData");
static_assert(sizeof(FLinkedOverlapUpdateData) == 0x00000C, "Wrong size on FLinkedOverlapUpdateData");
static_assert(offsetof(FLinkedOverlapUpdateData, OverlapCounter) == 0x000000, "Member 'FLinkedOverlapUpdateData::OverlapCounter' has a wrong offset!");
static_assert(offsetof(FLinkedOverlapUpdateData, OverlapActor) == 0x000004, "Member 'FLinkedOverlapUpdateData::OverlapActor' has a wrong offset!");

// ScriptStruct OrionGame.HeroRecord
// 0x0030 (0x0030 - 0x0000)
struct FHeroRecord final
{
public:
	class AOrionCharHero*                         HeroCharacter;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            PawnOwner;                                         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x20];                                      // 0x0010(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHeroRecord) == 0x000008, "Wrong alignment on FHeroRecord");
static_assert(sizeof(FHeroRecord) == 0x000030, "Wrong size on FHeroRecord");
static_assert(offsetof(FHeroRecord, HeroCharacter) == 0x000000, "Member 'FHeroRecord::HeroCharacter' has a wrong offset!");
static_assert(offsetof(FHeroRecord, PawnOwner) == 0x000008, "Member 'FHeroRecord::PawnOwner' has a wrong offset!");

// ScriptStruct OrionGame.OrionAnimNode_CardinalBlendByAngle
// 0x0048 (0x0078 - 0x0030)
struct FOrionAnimNode_CardinalBlendByAngle final : public FAnimNode_Base
{
public:
	TArray<struct FPoseLink>                      InputPoses;                                        // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTime;                                         // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendProfile*                          BlendProfile;                                      // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 PoseWeights;                                       // 0x0050(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bHasValidPoseWeights;                              // 0x0060(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBlendSampleData>               PerBoneSampleData;                                 // 0x0068(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FOrionAnimNode_CardinalBlendByAngle) == 0x000008, "Wrong alignment on FOrionAnimNode_CardinalBlendByAngle");
static_assert(sizeof(FOrionAnimNode_CardinalBlendByAngle) == 0x000078, "Wrong size on FOrionAnimNode_CardinalBlendByAngle");
static_assert(offsetof(FOrionAnimNode_CardinalBlendByAngle, InputPoses) == 0x000030, "Member 'FOrionAnimNode_CardinalBlendByAngle::InputPoses' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_CardinalBlendByAngle, Angle) == 0x000040, "Member 'FOrionAnimNode_CardinalBlendByAngle::Angle' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_CardinalBlendByAngle, BlendTime) == 0x000044, "Member 'FOrionAnimNode_CardinalBlendByAngle::BlendTime' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_CardinalBlendByAngle, BlendProfile) == 0x000048, "Member 'FOrionAnimNode_CardinalBlendByAngle::BlendProfile' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_CardinalBlendByAngle, PoseWeights) == 0x000050, "Member 'FOrionAnimNode_CardinalBlendByAngle::PoseWeights' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_CardinalBlendByAngle, bHasValidPoseWeights) == 0x000060, "Member 'FOrionAnimNode_CardinalBlendByAngle::bHasValidPoseWeights' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_CardinalBlendByAngle, PerBoneSampleData) == 0x000068, "Member 'FOrionAnimNode_CardinalBlendByAngle::PerBoneSampleData' has a wrong offset!");

// ScriptStruct OrionGame.OrionGameplayCueSignificanceSettings
// 0x0001 (0x0001 - 0x0000)
struct FOrionGameplayCueSignificanceSettings final
{
public:
	bool                                          bAlwaysSignificant;                                // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionGameplayCueSignificanceSettings) == 0x000001, "Wrong alignment on FOrionGameplayCueSignificanceSettings");
static_assert(sizeof(FOrionGameplayCueSignificanceSettings) == 0x000001, "Wrong size on FOrionGameplayCueSignificanceSettings");
static_assert(offsetof(FOrionGameplayCueSignificanceSettings, bAlwaysSignificant) == 0x000000, "Member 'FOrionGameplayCueSignificanceSettings::bAlwaysSignificant' has a wrong offset!");

// ScriptStruct OrionGame.AccountLevelUpNotification
// 0x0008 (0x0008 - 0x0000)
struct FAccountLevelUpNotification final
{
public:
	int32                                         OldLevel;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewLevel;                                          // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccountLevelUpNotification) == 0x000004, "Wrong alignment on FAccountLevelUpNotification");
static_assert(sizeof(FAccountLevelUpNotification) == 0x000008, "Wrong size on FAccountLevelUpNotification");
static_assert(offsetof(FAccountLevelUpNotification, OldLevel) == 0x000000, "Member 'FAccountLevelUpNotification::OldLevel' has a wrong offset!");
static_assert(offsetof(FAccountLevelUpNotification, NewLevel) == 0x000004, "Member 'FAccountLevelUpNotification::NewLevel' has a wrong offset!");

// ScriptStruct OrionGame.GameplayCueAOEInfo
// 0x0008 (0x0008 - 0x0000)
struct FGameplayCueAOEInfo final
{
public:
	float                                         InnerRadius;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OuterRadius;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayCueAOEInfo) == 0x000004, "Wrong alignment on FGameplayCueAOEInfo");
static_assert(sizeof(FGameplayCueAOEInfo) == 0x000008, "Wrong size on FGameplayCueAOEInfo");
static_assert(offsetof(FGameplayCueAOEInfo, InnerRadius) == 0x000000, "Member 'FGameplayCueAOEInfo::InnerRadius' has a wrong offset!");
static_assert(offsetof(FGameplayCueAOEInfo, OuterRadius) == 0x000004, "Member 'FGameplayCueAOEInfo::OuterRadius' has a wrong offset!");

// ScriptStruct OrionGame.MigrationRecord42UpdatedHero
// 0x0010 (0x0010 - 0x0000)
struct FMigrationRecord42UpdatedHero final
{
public:
	class FString                                 HeroTemplate;                                      // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMigrationRecord42UpdatedHero) == 0x000008, "Wrong alignment on FMigrationRecord42UpdatedHero");
static_assert(sizeof(FMigrationRecord42UpdatedHero) == 0x000010, "Wrong size on FMigrationRecord42UpdatedHero");
static_assert(offsetof(FMigrationRecord42UpdatedHero, HeroTemplate) == 0x000000, "Member 'FMigrationRecord42UpdatedHero::HeroTemplate' has a wrong offset!");

// ScriptStruct OrionGame.OrionLookAtTarget
// 0x0030 (0x0030 - 0x0000)
struct FOrionLookAtTarget final
{
public:
	class UObject*                                Instigator;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMeshComponent*                         TargetMesh;                                        // 0x0010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionLookAtTarget) == 0x000008, "Wrong alignment on FOrionLookAtTarget");
static_assert(sizeof(FOrionLookAtTarget) == 0x000030, "Wrong size on FOrionLookAtTarget");
static_assert(offsetof(FOrionLookAtTarget, Instigator) == 0x000000, "Member 'FOrionLookAtTarget::Instigator' has a wrong offset!");
static_assert(offsetof(FOrionLookAtTarget, TargetActor) == 0x000008, "Member 'FOrionLookAtTarget::TargetActor' has a wrong offset!");
static_assert(offsetof(FOrionLookAtTarget, TargetMesh) == 0x000010, "Member 'FOrionLookAtTarget::TargetMesh' has a wrong offset!");

// ScriptStruct OrionGame.OrionTeamComp
// 0x0018 (0x0018 - 0x0000)
struct FOrionTeamComp final
{
public:
	float                                         Weight;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EOrionRole>                            Roles;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionTeamComp) == 0x000008, "Wrong alignment on FOrionTeamComp");
static_assert(sizeof(FOrionTeamComp) == 0x000018, "Wrong size on FOrionTeamComp");
static_assert(offsetof(FOrionTeamComp, Weight) == 0x000000, "Member 'FOrionTeamComp::Weight' has a wrong offset!");
static_assert(offsetof(FOrionTeamComp, Roles) == 0x000008, "Member 'FOrionTeamComp::Roles' has a wrong offset!");

// ScriptStruct OrionGame.OrionMMRExpansion
// 0x0030 (0x0030 - 0x0000)
struct FOrionMMRExpansion final
{
public:
	int32                                         PlaylistId;                                        // 0x0000(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOrionMMRStep>                  Steps;                                             // 0x0008(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	float                                         X1;                                                // 0x0018(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X2;                                                // 0x001C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X3;                                                // 0x0020(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X4;                                                // 0x0024(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X5;                                                // 0x0028(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionMMRExpansion) == 0x000008, "Wrong alignment on FOrionMMRExpansion");
static_assert(sizeof(FOrionMMRExpansion) == 0x000030, "Wrong size on FOrionMMRExpansion");
static_assert(offsetof(FOrionMMRExpansion, PlaylistId) == 0x000000, "Member 'FOrionMMRExpansion::PlaylistId' has a wrong offset!");
static_assert(offsetof(FOrionMMRExpansion, Steps) == 0x000008, "Member 'FOrionMMRExpansion::Steps' has a wrong offset!");
static_assert(offsetof(FOrionMMRExpansion, X1) == 0x000018, "Member 'FOrionMMRExpansion::X1' has a wrong offset!");
static_assert(offsetof(FOrionMMRExpansion, X2) == 0x00001C, "Member 'FOrionMMRExpansion::X2' has a wrong offset!");
static_assert(offsetof(FOrionMMRExpansion, X3) == 0x000020, "Member 'FOrionMMRExpansion::X3' has a wrong offset!");
static_assert(offsetof(FOrionMMRExpansion, X4) == 0x000024, "Member 'FOrionMMRExpansion::X4' has a wrong offset!");
static_assert(offsetof(FOrionMMRExpansion, X5) == 0x000028, "Member 'FOrionMMRExpansion::X5' has a wrong offset!");

// ScriptStruct OrionGame.OrionFeaturedItem
// 0x00E8 (0x00E8 - 0x0000)
struct FOrionFeaturedItem final
{
public:
	class UOrionMcpItemDefinition*                ItemDefinition;                                    // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionHeroData*                         HeroData;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionFeaturedHeroAction                      Action;                                            // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionFeaturedHeroType                        Type;                                              // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BundleTag;                                         // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Title;                                             // 0x0028(0x0018)(NativeAccessSpecifierPublic)
	class FText                                   Subtitle;                                          // 0x0040(0x0018)(NativeAccessSpecifierPublic)
	class FText                                   EventTitle;                                        // 0x0058(0x0018)(NativeAccessSpecifierPublic)
	class FText                                   EventSubtitle;                                     // 0x0070(0x0018)(NativeAccessSpecifierPublic)
	class FText                                   EventActionText_Owned;                             // 0x0088(0x0018)(NativeAccessSpecifierPublic)
	class FText                                   EventSpecial_Owned;                                // 0x00A0(0x0018)(NativeAccessSpecifierPublic)
	class FText                                   EventActionText_Unowned;                           // 0x00B8(0x0018)(NativeAccessSpecifierPublic)
	class FText                                   EventSpecial_Unowned;                              // 0x00D0(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionFeaturedItem) == 0x000008, "Wrong alignment on FOrionFeaturedItem");
static_assert(sizeof(FOrionFeaturedItem) == 0x0000E8, "Wrong size on FOrionFeaturedItem");
static_assert(offsetof(FOrionFeaturedItem, ItemDefinition) == 0x000000, "Member 'FOrionFeaturedItem::ItemDefinition' has a wrong offset!");
static_assert(offsetof(FOrionFeaturedItem, HeroData) == 0x000008, "Member 'FOrionFeaturedItem::HeroData' has a wrong offset!");
static_assert(offsetof(FOrionFeaturedItem, Action) == 0x000010, "Member 'FOrionFeaturedItem::Action' has a wrong offset!");
static_assert(offsetof(FOrionFeaturedItem, Type) == 0x000011, "Member 'FOrionFeaturedItem::Type' has a wrong offset!");
static_assert(offsetof(FOrionFeaturedItem, BundleTag) == 0x000018, "Member 'FOrionFeaturedItem::BundleTag' has a wrong offset!");
static_assert(offsetof(FOrionFeaturedItem, Title) == 0x000028, "Member 'FOrionFeaturedItem::Title' has a wrong offset!");
static_assert(offsetof(FOrionFeaturedItem, Subtitle) == 0x000040, "Member 'FOrionFeaturedItem::Subtitle' has a wrong offset!");
static_assert(offsetof(FOrionFeaturedItem, EventTitle) == 0x000058, "Member 'FOrionFeaturedItem::EventTitle' has a wrong offset!");
static_assert(offsetof(FOrionFeaturedItem, EventSubtitle) == 0x000070, "Member 'FOrionFeaturedItem::EventSubtitle' has a wrong offset!");
static_assert(offsetof(FOrionFeaturedItem, EventActionText_Owned) == 0x000088, "Member 'FOrionFeaturedItem::EventActionText_Owned' has a wrong offset!");
static_assert(offsetof(FOrionFeaturedItem, EventSpecial_Owned) == 0x0000A0, "Member 'FOrionFeaturedItem::EventSpecial_Owned' has a wrong offset!");
static_assert(offsetof(FOrionFeaturedItem, EventActionText_Unowned) == 0x0000B8, "Member 'FOrionFeaturedItem::EventActionText_Unowned' has a wrong offset!");
static_assert(offsetof(FOrionFeaturedItem, EventSpecial_Unowned) == 0x0000D0, "Member 'FOrionFeaturedItem::EventSpecial_Unowned' has a wrong offset!");

// ScriptStruct OrionGame.SpeedWarpingFootDefinition
// 0x0038 (0x0038 - 0x0000)
struct FSpeedWarpingFootDefinition final
{
public:
	struct FBoneReference                         IKFootBone;                                        // 0x0000(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         FKFootBone;                                        // 0x0018(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         NumBonesInLimb;                                    // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpeedWarpingFootDefinition) == 0x000008, "Wrong alignment on FSpeedWarpingFootDefinition");
static_assert(sizeof(FSpeedWarpingFootDefinition) == 0x000038, "Wrong size on FSpeedWarpingFootDefinition");
static_assert(offsetof(FSpeedWarpingFootDefinition, IKFootBone) == 0x000000, "Member 'FSpeedWarpingFootDefinition::IKFootBone' has a wrong offset!");
static_assert(offsetof(FSpeedWarpingFootDefinition, FKFootBone) == 0x000018, "Member 'FSpeedWarpingFootDefinition::FKFootBone' has a wrong offset!");
static_assert(offsetof(FSpeedWarpingFootDefinition, NumBonesInLimb) == 0x000030, "Member 'FSpeedWarpingFootDefinition::NumBonesInLimb' has a wrong offset!");

// ScriptStruct OrionGame.SpeedWarpingFootData
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x10) FSpeedWarpingFootData final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpeedWarpingFootData) == 0x000010, "Wrong alignment on FSpeedWarpingFootData");
static_assert(sizeof(FSpeedWarpingFootData) == 0x000040, "Wrong size on FSpeedWarpingFootData");

// ScriptStruct OrionGame.OrionAnimNode_SpeedWarping
// 0x00C8 (0x0138 - 0x0070)
struct FOrionAnimNode_SpeedWarping final : public FAnimNode_SkeletalControlBase
{
public:
	struct FBoneReference                         IKFootRootBone;                                    // 0x0070(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FSpeedWarpingFootDefinition>    FeetDefinitions;                                   // 0x0088(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSpeedWarpingFootData>          FeetData;                                          // 0x0098(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	struct FBoneReference                         PelvisBone;                                        // 0x00A8(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	ESpeedWarpingAxisMode                         SpeedWarpingAxisMode;                              // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESpeedWarpingAxisMode                         FloorNormalAxisMode;                               // 0x00C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESpeedWarpingAxisMode                         GravityDirAxisMode;                                // 0x00C2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C3[0x1];                                       // 0x00C3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedScaling;                                      // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ManualSpeedWarpingDir;                             // 0x00C8(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ManualFloorNormalInput;                            // 0x00D4(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ManualGravityDirInput;                             // 0x00E0(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PelvisPostAdjustmentAlpha;                         // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PelvisAdjustmentMaxIter;                           // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVectorRK4SpringInterpolator           PelvisAdjustmentInterp;                            // 0x00F4(0x0008)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FC[0x34];                                      // 0x00FC(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAdjustThighBonesRotation;                         // 0x0130(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClampIKUsingFKLeg;                                // 0x0131(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOrientSpeedWarpingAxisBasedOnFloorNormal;         // 0x0132(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_133[0x1];                                      // 0x0133(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CachedDeltaTime;                                   // 0x0134(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FOrionAnimNode_SpeedWarping) == 0x000008, "Wrong alignment on FOrionAnimNode_SpeedWarping");
static_assert(sizeof(FOrionAnimNode_SpeedWarping) == 0x000138, "Wrong size on FOrionAnimNode_SpeedWarping");
static_assert(offsetof(FOrionAnimNode_SpeedWarping, IKFootRootBone) == 0x000070, "Member 'FOrionAnimNode_SpeedWarping::IKFootRootBone' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SpeedWarping, FeetDefinitions) == 0x000088, "Member 'FOrionAnimNode_SpeedWarping::FeetDefinitions' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SpeedWarping, FeetData) == 0x000098, "Member 'FOrionAnimNode_SpeedWarping::FeetData' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SpeedWarping, PelvisBone) == 0x0000A8, "Member 'FOrionAnimNode_SpeedWarping::PelvisBone' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SpeedWarping, SpeedWarpingAxisMode) == 0x0000C0, "Member 'FOrionAnimNode_SpeedWarping::SpeedWarpingAxisMode' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SpeedWarping, FloorNormalAxisMode) == 0x0000C1, "Member 'FOrionAnimNode_SpeedWarping::FloorNormalAxisMode' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SpeedWarping, GravityDirAxisMode) == 0x0000C2, "Member 'FOrionAnimNode_SpeedWarping::GravityDirAxisMode' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SpeedWarping, SpeedScaling) == 0x0000C4, "Member 'FOrionAnimNode_SpeedWarping::SpeedScaling' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SpeedWarping, ManualSpeedWarpingDir) == 0x0000C8, "Member 'FOrionAnimNode_SpeedWarping::ManualSpeedWarpingDir' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SpeedWarping, ManualFloorNormalInput) == 0x0000D4, "Member 'FOrionAnimNode_SpeedWarping::ManualFloorNormalInput' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SpeedWarping, ManualGravityDirInput) == 0x0000E0, "Member 'FOrionAnimNode_SpeedWarping::ManualGravityDirInput' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SpeedWarping, PelvisPostAdjustmentAlpha) == 0x0000EC, "Member 'FOrionAnimNode_SpeedWarping::PelvisPostAdjustmentAlpha' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SpeedWarping, PelvisAdjustmentMaxIter) == 0x0000F0, "Member 'FOrionAnimNode_SpeedWarping::PelvisAdjustmentMaxIter' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SpeedWarping, PelvisAdjustmentInterp) == 0x0000F4, "Member 'FOrionAnimNode_SpeedWarping::PelvisAdjustmentInterp' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SpeedWarping, bAdjustThighBonesRotation) == 0x000130, "Member 'FOrionAnimNode_SpeedWarping::bAdjustThighBonesRotation' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SpeedWarping, bClampIKUsingFKLeg) == 0x000131, "Member 'FOrionAnimNode_SpeedWarping::bClampIKUsingFKLeg' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SpeedWarping, bOrientSpeedWarpingAxisBasedOnFloorNormal) == 0x000132, "Member 'FOrionAnimNode_SpeedWarping::bOrientSpeedWarpingAxisBasedOnFloorNormal' has a wrong offset!");
static_assert(offsetof(FOrionAnimNode_SpeedWarping, CachedDeltaTime) == 0x000134, "Member 'FOrionAnimNode_SpeedWarping::CachedDeltaTime' has a wrong offset!");

// ScriptStruct OrionGame.ForceFullBodyMontageParams
// 0x0004 (0x0004 - 0x0000)
struct FForceFullBodyMontageParams final
{
public:
	bool                                          bWhenMoving;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWhenTurning;                                      // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWhenJumping;                                      // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWhenLanding;                                      // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FForceFullBodyMontageParams) == 0x000001, "Wrong alignment on FForceFullBodyMontageParams");
static_assert(sizeof(FForceFullBodyMontageParams) == 0x000004, "Wrong size on FForceFullBodyMontageParams");
static_assert(offsetof(FForceFullBodyMontageParams, bWhenMoving) == 0x000000, "Member 'FForceFullBodyMontageParams::bWhenMoving' has a wrong offset!");
static_assert(offsetof(FForceFullBodyMontageParams, bWhenTurning) == 0x000001, "Member 'FForceFullBodyMontageParams::bWhenTurning' has a wrong offset!");
static_assert(offsetof(FForceFullBodyMontageParams, bWhenJumping) == 0x000002, "Member 'FForceFullBodyMontageParams::bWhenJumping' has a wrong offset!");
static_assert(offsetof(FForceFullBodyMontageParams, bWhenLanding) == 0x000003, "Member 'FForceFullBodyMontageParams::bWhenLanding' has a wrong offset!");

// ScriptStruct OrionGame.PickupSpawningData
// 0x0120 (0x0120 - 0x0000)
struct FPickupSpawningData final
{
public:
	TSubclassOf<class AOrionPickup>               PickupToSpawn;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionFilterAndEffectsContainer        PickupFilterAndEffectsContainer;                   // 0x0008(0x0020)(RepSkip, NativeAccessSpecifierPublic)
	class AActor*                                 Owner;                                             // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            OwnerController;                                   // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnPointActor;                                  // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionPlayerState_Game*                 HomingPlayerState;                                 // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 HomingActor;                                       // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    OwnerTeam;                                         // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHasReturnPoint : 1;                               // 0x0051(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHoming : 1;                                       // 0x0051(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  SourceTags;                                        // 0x0058(0x0020)(NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  SourceAssetTags;                                   // 0x0078(0x0020)(NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  HomingCallbackTags;                                // 0x0098(0x0020)(NativeAccessSpecifierPublic)
	int32                                         NumToDrop;                                         // 0x00B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpawnLocation;                                     // 0x00BC(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        DropLocations;                                     // 0x00C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        TestLocations;                                     // 0x00D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 KillerCXP;                                         // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 AssisterCXP;                                       // 0x00F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AOrionPlayerState_Game*>         CoinAssisters;                                     // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         PickupGELevel;                                     // 0x0118(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastSpawnTime;                                     // 0x011C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPickupSpawningData) == 0x000008, "Wrong alignment on FPickupSpawningData");
static_assert(sizeof(FPickupSpawningData) == 0x000120, "Wrong size on FPickupSpawningData");
static_assert(offsetof(FPickupSpawningData, PickupToSpawn) == 0x000000, "Member 'FPickupSpawningData::PickupToSpawn' has a wrong offset!");
static_assert(offsetof(FPickupSpawningData, PickupFilterAndEffectsContainer) == 0x000008, "Member 'FPickupSpawningData::PickupFilterAndEffectsContainer' has a wrong offset!");
static_assert(offsetof(FPickupSpawningData, Owner) == 0x000028, "Member 'FPickupSpawningData::Owner' has a wrong offset!");
static_assert(offsetof(FPickupSpawningData, OwnerController) == 0x000030, "Member 'FPickupSpawningData::OwnerController' has a wrong offset!");
static_assert(offsetof(FPickupSpawningData, ReturnPointActor) == 0x000038, "Member 'FPickupSpawningData::ReturnPointActor' has a wrong offset!");
static_assert(offsetof(FPickupSpawningData, HomingPlayerState) == 0x000040, "Member 'FPickupSpawningData::HomingPlayerState' has a wrong offset!");
static_assert(offsetof(FPickupSpawningData, HomingActor) == 0x000048, "Member 'FPickupSpawningData::HomingActor' has a wrong offset!");
static_assert(offsetof(FPickupSpawningData, OwnerTeam) == 0x000050, "Member 'FPickupSpawningData::OwnerTeam' has a wrong offset!");
static_assert(offsetof(FPickupSpawningData, SourceTags) == 0x000058, "Member 'FPickupSpawningData::SourceTags' has a wrong offset!");
static_assert(offsetof(FPickupSpawningData, SourceAssetTags) == 0x000078, "Member 'FPickupSpawningData::SourceAssetTags' has a wrong offset!");
static_assert(offsetof(FPickupSpawningData, HomingCallbackTags) == 0x000098, "Member 'FPickupSpawningData::HomingCallbackTags' has a wrong offset!");
static_assert(offsetof(FPickupSpawningData, NumToDrop) == 0x0000B8, "Member 'FPickupSpawningData::NumToDrop' has a wrong offset!");
static_assert(offsetof(FPickupSpawningData, SpawnLocation) == 0x0000BC, "Member 'FPickupSpawningData::SpawnLocation' has a wrong offset!");
static_assert(offsetof(FPickupSpawningData, DropLocations) == 0x0000C8, "Member 'FPickupSpawningData::DropLocations' has a wrong offset!");
static_assert(offsetof(FPickupSpawningData, TestLocations) == 0x0000D8, "Member 'FPickupSpawningData::TestLocations' has a wrong offset!");
static_assert(offsetof(FPickupSpawningData, KillerCXP) == 0x0000E8, "Member 'FPickupSpawningData::KillerCXP' has a wrong offset!");
static_assert(offsetof(FPickupSpawningData, AssisterCXP) == 0x0000F8, "Member 'FPickupSpawningData::AssisterCXP' has a wrong offset!");
static_assert(offsetof(FPickupSpawningData, CoinAssisters) == 0x000108, "Member 'FPickupSpawningData::CoinAssisters' has a wrong offset!");
static_assert(offsetof(FPickupSpawningData, PickupGELevel) == 0x000118, "Member 'FPickupSpawningData::PickupGELevel' has a wrong offset!");
static_assert(offsetof(FPickupSpawningData, LastSpawnTime) == 0x00011C, "Member 'FPickupSpawningData::LastSpawnTime' has a wrong offset!");

// ScriptStruct OrionGame.TagAdjustedTrailInfo
// 0x0020 (0x0020 - 0x0000)
struct FTagAdjustedTrailInfo final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        P_Base;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        P_OverrideEnemy;                                   // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        P_OverrideFriendly;                                // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTagAdjustedTrailInfo) == 0x000008, "Wrong alignment on FTagAdjustedTrailInfo");
static_assert(sizeof(FTagAdjustedTrailInfo) == 0x000020, "Wrong size on FTagAdjustedTrailInfo");
static_assert(offsetof(FTagAdjustedTrailInfo, Tag) == 0x000000, "Member 'FTagAdjustedTrailInfo::Tag' has a wrong offset!");
static_assert(offsetof(FTagAdjustedTrailInfo, P_Base) == 0x000008, "Member 'FTagAdjustedTrailInfo::P_Base' has a wrong offset!");
static_assert(offsetof(FTagAdjustedTrailInfo, P_OverrideEnemy) == 0x000010, "Member 'FTagAdjustedTrailInfo::P_OverrideEnemy' has a wrong offset!");
static_assert(offsetof(FTagAdjustedTrailInfo, P_OverrideFriendly) == 0x000018, "Member 'FTagAdjustedTrailInfo::P_OverrideFriendly' has a wrong offset!");

// ScriptStruct OrionGame.OrionHeroSpeedWarpingSettings
// 0x0010 (0x0010 - 0x0000)
struct FOrionHeroSpeedWarpingSettings final
{
public:
	float                                         MinAuthoredSpeed;                                  // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAuthoredSpeed;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedWarpingAmount;                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClampedSpeed;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionHeroSpeedWarpingSettings) == 0x000004, "Wrong alignment on FOrionHeroSpeedWarpingSettings");
static_assert(sizeof(FOrionHeroSpeedWarpingSettings) == 0x000010, "Wrong size on FOrionHeroSpeedWarpingSettings");
static_assert(offsetof(FOrionHeroSpeedWarpingSettings, MinAuthoredSpeed) == 0x000000, "Member 'FOrionHeroSpeedWarpingSettings::MinAuthoredSpeed' has a wrong offset!");
static_assert(offsetof(FOrionHeroSpeedWarpingSettings, MaxAuthoredSpeed) == 0x000004, "Member 'FOrionHeroSpeedWarpingSettings::MaxAuthoredSpeed' has a wrong offset!");
static_assert(offsetof(FOrionHeroSpeedWarpingSettings, SpeedWarpingAmount) == 0x000008, "Member 'FOrionHeroSpeedWarpingSettings::SpeedWarpingAmount' has a wrong offset!");
static_assert(offsetof(FOrionHeroSpeedWarpingSettings, ClampedSpeed) == 0x00000C, "Member 'FOrionHeroSpeedWarpingSettings::ClampedSpeed' has a wrong offset!");

// ScriptStruct OrionGame.OrionDistanceCurve
// 0x0000 (0x0010 - 0x0010)
struct FOrionDistanceCurve final : public FOrionCachedFloatCurve
{
};
static_assert(alignof(FOrionDistanceCurve) == 0x000008, "Wrong alignment on FOrionDistanceCurve");
static_assert(sizeof(FOrionDistanceCurve) == 0x000010, "Wrong size on FOrionDistanceCurve");

// ScriptStruct OrionGame.OrionGameplayCueConditionedParticles
// 0x0028 (0x0028 - 0x0000)
struct FOrionGameplayCueConditionedParticles final
{
public:
	EParticleCondition                            Condition;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOrionGameplayCueLevelRequirements> LevelRequirements;                                 // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ParticleSystem;                                    // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketNameOverride;                                // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionGameplayCueConditionedParticles) == 0x000008, "Wrong alignment on FOrionGameplayCueConditionedParticles");
static_assert(sizeof(FOrionGameplayCueConditionedParticles) == 0x000028, "Wrong size on FOrionGameplayCueConditionedParticles");
static_assert(offsetof(FOrionGameplayCueConditionedParticles, Condition) == 0x000000, "Member 'FOrionGameplayCueConditionedParticles::Condition' has a wrong offset!");
static_assert(offsetof(FOrionGameplayCueConditionedParticles, LevelRequirements) == 0x000008, "Member 'FOrionGameplayCueConditionedParticles::LevelRequirements' has a wrong offset!");
static_assert(offsetof(FOrionGameplayCueConditionedParticles, ParticleSystem) == 0x000018, "Member 'FOrionGameplayCueConditionedParticles::ParticleSystem' has a wrong offset!");
static_assert(offsetof(FOrionGameplayCueConditionedParticles, SocketNameOverride) == 0x000020, "Member 'FOrionGameplayCueConditionedParticles::SocketNameOverride' has a wrong offset!");

// ScriptStruct OrionGame.GameplayCueParticleInfo
// 0x0040 (0x0040 - 0x0000)
struct FGameplayCueParticleInfo final
{
public:
	class UParticleSystem*                        ParticleSystem;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOrionGameplayCueConditionedParticles> AdditionalParticleSystems;                         // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FOrionGameplayCueAttachInfo            AttachmentInfo;                                    // 0x0018(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	ELocalVisiblityPolicy                         LocalVisiblityPolicy;                              // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EParticleTeamColorAdjustStyle                 TeamColorAdjust;                                   // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CastShadow;                                        // 0x002A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x1];                                       // 0x002B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Scale;                                             // 0x002C(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAbsoluteScale;                                 // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayCueParticleInfo) == 0x000008, "Wrong alignment on FGameplayCueParticleInfo");
static_assert(sizeof(FGameplayCueParticleInfo) == 0x000040, "Wrong size on FGameplayCueParticleInfo");
static_assert(offsetof(FGameplayCueParticleInfo, ParticleSystem) == 0x000000, "Member 'FGameplayCueParticleInfo::ParticleSystem' has a wrong offset!");
static_assert(offsetof(FGameplayCueParticleInfo, AdditionalParticleSystems) == 0x000008, "Member 'FGameplayCueParticleInfo::AdditionalParticleSystems' has a wrong offset!");
static_assert(offsetof(FGameplayCueParticleInfo, AttachmentInfo) == 0x000018, "Member 'FGameplayCueParticleInfo::AttachmentInfo' has a wrong offset!");
static_assert(offsetof(FGameplayCueParticleInfo, LocalVisiblityPolicy) == 0x000028, "Member 'FGameplayCueParticleInfo::LocalVisiblityPolicy' has a wrong offset!");
static_assert(offsetof(FGameplayCueParticleInfo, TeamColorAdjust) == 0x000029, "Member 'FGameplayCueParticleInfo::TeamColorAdjust' has a wrong offset!");
static_assert(offsetof(FGameplayCueParticleInfo, CastShadow) == 0x00002A, "Member 'FGameplayCueParticleInfo::CastShadow' has a wrong offset!");
static_assert(offsetof(FGameplayCueParticleInfo, Scale) == 0x00002C, "Member 'FGameplayCueParticleInfo::Scale' has a wrong offset!");
static_assert(offsetof(FGameplayCueParticleInfo, bUseAbsoluteScale) == 0x000038, "Member 'FGameplayCueParticleInfo::bUseAbsoluteScale' has a wrong offset!");

// ScriptStruct OrionGame.GameplayCueAudioInfo
// 0x0018 (0x0018 - 0x0000)
struct FGameplayCueAudioInfo
{
public:
	class USoundBase*                             SoundCue;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldAttach;                                      // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamAdjustStyle                              TeamAdjustStyle;                                   // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELocalVisiblityPolicy                         LocalVisiblityPolicy;                              // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChanceToPlay;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayBeforePlayInSeconds;                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayCueAudioInfo) == 0x000008, "Wrong alignment on FGameplayCueAudioInfo");
static_assert(sizeof(FGameplayCueAudioInfo) == 0x000018, "Wrong size on FGameplayCueAudioInfo");
static_assert(offsetof(FGameplayCueAudioInfo, SoundCue) == 0x000000, "Member 'FGameplayCueAudioInfo::SoundCue' has a wrong offset!");
static_assert(offsetof(FGameplayCueAudioInfo, ShouldAttach) == 0x000008, "Member 'FGameplayCueAudioInfo::ShouldAttach' has a wrong offset!");
static_assert(offsetof(FGameplayCueAudioInfo, TeamAdjustStyle) == 0x000009, "Member 'FGameplayCueAudioInfo::TeamAdjustStyle' has a wrong offset!");
static_assert(offsetof(FGameplayCueAudioInfo, LocalVisiblityPolicy) == 0x00000A, "Member 'FGameplayCueAudioInfo::LocalVisiblityPolicy' has a wrong offset!");
static_assert(offsetof(FGameplayCueAudioInfo, ChanceToPlay) == 0x00000C, "Member 'FGameplayCueAudioInfo::ChanceToPlay' has a wrong offset!");
static_assert(offsetof(FGameplayCueAudioInfo, DelayBeforePlayInSeconds) == 0x000010, "Member 'FGameplayCueAudioInfo::DelayBeforePlayInSeconds' has a wrong offset!");

// ScriptStruct OrionGame.GameplayCueCameraShakeInfo
// 0x0028 (0x0028 - 0x0000)
struct FGameplayCueCameraShakeInfo final
{
public:
	TSubclassOf<class UCameraShake>               Shake;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraAnimPlaySpace                          PlaySpace;                                         // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               UserPlaySpaceRotation;                             // 0x0010(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bCalculateUserPlaySpaceRotationFromLocation;       // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCancelOnRemove;                                   // 0x001D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayCueAOEInfo                    Falloff;                                           // 0x0020(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayCueCameraShakeInfo) == 0x000008, "Wrong alignment on FGameplayCueCameraShakeInfo");
static_assert(sizeof(FGameplayCueCameraShakeInfo) == 0x000028, "Wrong size on FGameplayCueCameraShakeInfo");
static_assert(offsetof(FGameplayCueCameraShakeInfo, Shake) == 0x000000, "Member 'FGameplayCueCameraShakeInfo::Shake' has a wrong offset!");
static_assert(offsetof(FGameplayCueCameraShakeInfo, Scale) == 0x000008, "Member 'FGameplayCueCameraShakeInfo::Scale' has a wrong offset!");
static_assert(offsetof(FGameplayCueCameraShakeInfo, PlaySpace) == 0x00000C, "Member 'FGameplayCueCameraShakeInfo::PlaySpace' has a wrong offset!");
static_assert(offsetof(FGameplayCueCameraShakeInfo, UserPlaySpaceRotation) == 0x000010, "Member 'FGameplayCueCameraShakeInfo::UserPlaySpaceRotation' has a wrong offset!");
static_assert(offsetof(FGameplayCueCameraShakeInfo, bCalculateUserPlaySpaceRotationFromLocation) == 0x00001C, "Member 'FGameplayCueCameraShakeInfo::bCalculateUserPlaySpaceRotationFromLocation' has a wrong offset!");
static_assert(offsetof(FGameplayCueCameraShakeInfo, bCancelOnRemove) == 0x00001D, "Member 'FGameplayCueCameraShakeInfo::bCancelOnRemove' has a wrong offset!");
static_assert(offsetof(FGameplayCueCameraShakeInfo, Falloff) == 0x000020, "Member 'FGameplayCueCameraShakeInfo::Falloff' has a wrong offset!");

// ScriptStruct OrionGame.GameplayCueCameraLensEffectInfo
// 0x0018 (0x0018 - 0x0000)
struct FGameplayCueCameraLensEffectInfo final
{
public:
	TSubclassOf<class AEmitterCameraLensEffectBase> CameraLensEffect;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueAOEInfo                    Falloff;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bCancelOnRemove;                                   // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayCueCameraLensEffectInfo) == 0x000008, "Wrong alignment on FGameplayCueCameraLensEffectInfo");
static_assert(sizeof(FGameplayCueCameraLensEffectInfo) == 0x000018, "Wrong size on FGameplayCueCameraLensEffectInfo");
static_assert(offsetof(FGameplayCueCameraLensEffectInfo, CameraLensEffect) == 0x000000, "Member 'FGameplayCueCameraLensEffectInfo::CameraLensEffect' has a wrong offset!");
static_assert(offsetof(FGameplayCueCameraLensEffectInfo, Falloff) == 0x000008, "Member 'FGameplayCueCameraLensEffectInfo::Falloff' has a wrong offset!");
static_assert(offsetof(FGameplayCueCameraLensEffectInfo, bCancelOnRemove) == 0x000010, "Member 'FGameplayCueCameraLensEffectInfo::bCancelOnRemove' has a wrong offset!");

// ScriptStruct OrionGame.GameplayCueDecalInfo
// 0x0038 (0x0038 - 0x0000)
struct FGameplayCueDecalInfo final
{
public:
	TSubclassOf<class ADecalActor>                Decal;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DecalScale;                                        // 0x0008(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDecalRotationOverride;                         // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               DecalRotationOverride;                             // 0x0018(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseFadeOutValues;                                 // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeOutStartDelay;                                 // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutDuration;                                   // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreLocalVisibility;                            // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayCueDecalInfo) == 0x000008, "Wrong alignment on FGameplayCueDecalInfo");
static_assert(sizeof(FGameplayCueDecalInfo) == 0x000038, "Wrong size on FGameplayCueDecalInfo");
static_assert(offsetof(FGameplayCueDecalInfo, Decal) == 0x000000, "Member 'FGameplayCueDecalInfo::Decal' has a wrong offset!");
static_assert(offsetof(FGameplayCueDecalInfo, DecalScale) == 0x000008, "Member 'FGameplayCueDecalInfo::DecalScale' has a wrong offset!");
static_assert(offsetof(FGameplayCueDecalInfo, bUseDecalRotationOverride) == 0x000014, "Member 'FGameplayCueDecalInfo::bUseDecalRotationOverride' has a wrong offset!");
static_assert(offsetof(FGameplayCueDecalInfo, DecalRotationOverride) == 0x000018, "Member 'FGameplayCueDecalInfo::DecalRotationOverride' has a wrong offset!");
static_assert(offsetof(FGameplayCueDecalInfo, bUseFadeOutValues) == 0x000024, "Member 'FGameplayCueDecalInfo::bUseFadeOutValues' has a wrong offset!");
static_assert(offsetof(FGameplayCueDecalInfo, FadeOutStartDelay) == 0x000028, "Member 'FGameplayCueDecalInfo::FadeOutStartDelay' has a wrong offset!");
static_assert(offsetof(FGameplayCueDecalInfo, FadeOutDuration) == 0x00002C, "Member 'FGameplayCueDecalInfo::FadeOutDuration' has a wrong offset!");
static_assert(offsetof(FGameplayCueDecalInfo, bIgnoreLocalVisibility) == 0x000030, "Member 'FGameplayCueDecalInfo::bIgnoreLocalVisibility' has a wrong offset!");

// ScriptStruct OrionGame.GameplayCueStencilDecalInfo
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FGameplayCueStencilDecalInfo final
{
public:
	class FName                                   DecalName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayCueStencilDecalInfo) == 0x000008, "Wrong alignment on FGameplayCueStencilDecalInfo");
static_assert(sizeof(FGameplayCueStencilDecalInfo) == 0x000010, "Wrong size on FGameplayCueStencilDecalInfo");
static_assert(offsetof(FGameplayCueStencilDecalInfo, DecalName) == 0x000000, "Member 'FGameplayCueStencilDecalInfo::DecalName' has a wrong offset!");
static_assert(offsetof(FGameplayCueStencilDecalInfo, Duration) == 0x000008, "Member 'FGameplayCueStencilDecalInfo::Duration' has a wrong offset!");

// ScriptStruct OrionGame.OrionBurstEffectData
// 0x0140 (0x0140 - 0x0000)
struct FOrionBurstEffectData final
{
public:
	struct FGameplayCueParticleInfo               BurstParticleEffect;                               // 0x0000(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayCueNiagaraParticleInfo        BurstNiagaraParticleEffect;                        // 0x0040(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayCueAudioInfo                  BurstSound;                                        // 0x0080(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueCameraShakeInfo            BurstCameraShake;                                  // 0x0098(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueViewKickInfo               BurstViewKick;                                     // 0x00C0(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueCameraLensEffectInfo       BurstCameraLensEffect;                             // 0x00C8(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueForceFeedbackInfo          BurstForceFeedbackEffect;                          // 0x00E0(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueDecalInfo                  BurstDecal;                                        // 0x00F8(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueStencilDecalInfo           BurstStencilDecal;                                 // 0x0130(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionBurstEffectData) == 0x000008, "Wrong alignment on FOrionBurstEffectData");
static_assert(sizeof(FOrionBurstEffectData) == 0x000140, "Wrong size on FOrionBurstEffectData");
static_assert(offsetof(FOrionBurstEffectData, BurstParticleEffect) == 0x000000, "Member 'FOrionBurstEffectData::BurstParticleEffect' has a wrong offset!");
static_assert(offsetof(FOrionBurstEffectData, BurstNiagaraParticleEffect) == 0x000040, "Member 'FOrionBurstEffectData::BurstNiagaraParticleEffect' has a wrong offset!");
static_assert(offsetof(FOrionBurstEffectData, BurstSound) == 0x000080, "Member 'FOrionBurstEffectData::BurstSound' has a wrong offset!");
static_assert(offsetof(FOrionBurstEffectData, BurstCameraShake) == 0x000098, "Member 'FOrionBurstEffectData::BurstCameraShake' has a wrong offset!");
static_assert(offsetof(FOrionBurstEffectData, BurstViewKick) == 0x0000C0, "Member 'FOrionBurstEffectData::BurstViewKick' has a wrong offset!");
static_assert(offsetof(FOrionBurstEffectData, BurstCameraLensEffect) == 0x0000C8, "Member 'FOrionBurstEffectData::BurstCameraLensEffect' has a wrong offset!");
static_assert(offsetof(FOrionBurstEffectData, BurstForceFeedbackEffect) == 0x0000E0, "Member 'FOrionBurstEffectData::BurstForceFeedbackEffect' has a wrong offset!");
static_assert(offsetof(FOrionBurstEffectData, BurstDecal) == 0x0000F8, "Member 'FOrionBurstEffectData::BurstDecal' has a wrong offset!");
static_assert(offsetof(FOrionBurstEffectData, BurstStencilDecal) == 0x000130, "Member 'FOrionBurstEffectData::BurstStencilDecal' has a wrong offset!");

// ScriptStruct OrionGame.ArcadeEffectData
// 0x0018 (0x0018 - 0x0000)
struct FArcadeEffectData final
{
public:
	float                                         Level;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseExplicitStackCount;                            // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ExplicitStackCount;                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EArcadeEffectPlayerType                       PlayerType;                                        // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EArcadeEffectTeamType                         TeamType;                                          // 0x000D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            GameplayEffectLoaded;                              // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArcadeEffectData) == 0x000008, "Wrong alignment on FArcadeEffectData");
static_assert(sizeof(FArcadeEffectData) == 0x000018, "Wrong size on FArcadeEffectData");
static_assert(offsetof(FArcadeEffectData, Level) == 0x000000, "Member 'FArcadeEffectData::Level' has a wrong offset!");
static_assert(offsetof(FArcadeEffectData, bUseExplicitStackCount) == 0x000004, "Member 'FArcadeEffectData::bUseExplicitStackCount' has a wrong offset!");
static_assert(offsetof(FArcadeEffectData, ExplicitStackCount) == 0x000008, "Member 'FArcadeEffectData::ExplicitStackCount' has a wrong offset!");
static_assert(offsetof(FArcadeEffectData, PlayerType) == 0x00000C, "Member 'FArcadeEffectData::PlayerType' has a wrong offset!");
static_assert(offsetof(FArcadeEffectData, TeamType) == 0x00000D, "Member 'FArcadeEffectData::TeamType' has a wrong offset!");
static_assert(offsetof(FArcadeEffectData, GameplayEffectLoaded) == 0x000010, "Member 'FArcadeEffectData::GameplayEffectLoaded' has a wrong offset!");

// ScriptStruct OrionGame.LadderURLData
// 0x0038 (0x0038 - 0x0000)
struct FLadderURLData final
{
public:
	int32                                         PlaylistId;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionArcadeLadderSetupData*            LadderData;                                        // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 ArcadeURL;                                         // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         StageIndex;                                        // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LadderAssetPath;                                   // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FLadderURLData) == 0x000008, "Wrong alignment on FLadderURLData");
static_assert(sizeof(FLadderURLData) == 0x000038, "Wrong size on FLadderURLData");
static_assert(offsetof(FLadderURLData, PlaylistId) == 0x000000, "Member 'FLadderURLData::PlaylistId' has a wrong offset!");
static_assert(offsetof(FLadderURLData, LadderData) == 0x000008, "Member 'FLadderURLData::LadderData' has a wrong offset!");
static_assert(offsetof(FLadderURLData, ArcadeURL) == 0x000010, "Member 'FLadderURLData::ArcadeURL' has a wrong offset!");
static_assert(offsetof(FLadderURLData, StageIndex) == 0x000020, "Member 'FLadderURLData::StageIndex' has a wrong offset!");
static_assert(offsetof(FLadderURLData, LadderAssetPath) == 0x000028, "Member 'FLadderURLData::LadderAssetPath' has a wrong offset!");

// ScriptStruct OrionGame.BalanceTweakerItem
// 0x0038 (0x0038 - 0x0000)
struct FBalanceTweakerItem final
{
public:
	struct FCurveTableRowHandle                   Curve;                                             // 0x0000(0x0010)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 Data;                                              // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SingleValue;                                       // 0x0024(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCurveTableRowHandle                   CachedCurve;                                       // 0x0028(0x0010)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBalanceTweakerItem) == 0x000008, "Wrong alignment on FBalanceTweakerItem");
static_assert(sizeof(FBalanceTweakerItem) == 0x000038, "Wrong size on FBalanceTweakerItem");
static_assert(offsetof(FBalanceTweakerItem, Curve) == 0x000000, "Member 'FBalanceTweakerItem::Curve' has a wrong offset!");
static_assert(offsetof(FBalanceTweakerItem, Data) == 0x000010, "Member 'FBalanceTweakerItem::Data' has a wrong offset!");
static_assert(offsetof(FBalanceTweakerItem, Value) == 0x000020, "Member 'FBalanceTweakerItem::Value' has a wrong offset!");
static_assert(offsetof(FBalanceTweakerItem, SingleValue) == 0x000024, "Member 'FBalanceTweakerItem::SingleValue' has a wrong offset!");
static_assert(offsetof(FBalanceTweakerItem, CachedCurve) == 0x000028, "Member 'FBalanceTweakerItem::CachedCurve' has a wrong offset!");

// ScriptStruct OrionGame.BalanceTweakerData
// 0x0010 (0x0010 - 0x0000)
struct FBalanceTweakerData final
{
public:
	TArray<struct FBalanceTweakerItem>            Items;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBalanceTweakerData) == 0x000008, "Wrong alignment on FBalanceTweakerData");
static_assert(sizeof(FBalanceTweakerData) == 0x000010, "Wrong size on FBalanceTweakerData");
static_assert(offsetof(FBalanceTweakerData, Items) == 0x000000, "Member 'FBalanceTweakerData::Items' has a wrong offset!");

// ScriptStruct OrionGame.HeroEntry
// 0x0020 (0x0020 - 0x0000)
struct FHeroEntry final
{
public:
	class UOrionHeroData*                         HeroData;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPlayerHero;                                     // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionArcadeEffectData*                 ArcadeEffectData;                                  // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionMcpCuratedDeckItemDefinition*     ArcadeDeck;                                        // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FHeroEntry) == 0x000008, "Wrong alignment on FHeroEntry");
static_assert(sizeof(FHeroEntry) == 0x000020, "Wrong size on FHeroEntry");
static_assert(offsetof(FHeroEntry, HeroData) == 0x000000, "Member 'FHeroEntry::HeroData' has a wrong offset!");
static_assert(offsetof(FHeroEntry, bIsPlayerHero) == 0x000008, "Member 'FHeroEntry::bIsPlayerHero' has a wrong offset!");
static_assert(offsetof(FHeroEntry, ArcadeEffectData) == 0x000010, "Member 'FHeroEntry::ArcadeEffectData' has a wrong offset!");
static_assert(offsetof(FHeroEntry, ArcadeDeck) == 0x000018, "Member 'FHeroEntry::ArcadeDeck' has a wrong offset!");

// ScriptStruct OrionGame.TeamLineup
// 0x0020 (0x0020 - 0x0000)
struct FTeamLineup final
{
public:
	class UOrionArcadeEffectData*                 ArcadeEffectData;                                  // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    TeamNum;                                           // 0x0008(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHeroEntry>                     HeroEntries;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTeamLineup) == 0x000008, "Wrong alignment on FTeamLineup");
static_assert(sizeof(FTeamLineup) == 0x000020, "Wrong size on FTeamLineup");
static_assert(offsetof(FTeamLineup, ArcadeEffectData) == 0x000000, "Member 'FTeamLineup::ArcadeEffectData' has a wrong offset!");
static_assert(offsetof(FTeamLineup, TeamNum) == 0x000008, "Member 'FTeamLineup::TeamNum' has a wrong offset!");
static_assert(offsetof(FTeamLineup, HeroEntries) == 0x000010, "Member 'FTeamLineup::HeroEntries' has a wrong offset!");

// ScriptStruct OrionGame.StageEntry
// 0x0118 (0x0118 - 0x0000)
struct FStageEntry final
{
public:
	struct FOrionPlaylistInfo                     PlaylistInfo;                                      // 0x0000(0x00C0)(Edit, NativeAccessSpecifierPublic)
	struct FTeamLineup                            RedTeamLineup;                                     // 0x00C0(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FTeamLineup                            BlueTeamLineup;                                    // 0x00E0(0x0020)(Edit, NativeAccessSpecifierPublic)
	int32                                         StageIndex;                                        // 0x0100(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionMcpCuratedDeckItemDefinition*     ArcadeDeck;                                        // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionArcadeEffectData*                 BeltEffect;                                        // 0x0110(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStageEntry) == 0x000008, "Wrong alignment on FStageEntry");
static_assert(sizeof(FStageEntry) == 0x000118, "Wrong size on FStageEntry");
static_assert(offsetof(FStageEntry, PlaylistInfo) == 0x000000, "Member 'FStageEntry::PlaylistInfo' has a wrong offset!");
static_assert(offsetof(FStageEntry, RedTeamLineup) == 0x0000C0, "Member 'FStageEntry::RedTeamLineup' has a wrong offset!");
static_assert(offsetof(FStageEntry, BlueTeamLineup) == 0x0000E0, "Member 'FStageEntry::BlueTeamLineup' has a wrong offset!");
static_assert(offsetof(FStageEntry, StageIndex) == 0x000100, "Member 'FStageEntry::StageIndex' has a wrong offset!");
static_assert(offsetof(FStageEntry, ArcadeDeck) == 0x000108, "Member 'FStageEntry::ArcadeDeck' has a wrong offset!");
static_assert(offsetof(FStageEntry, BeltEffect) == 0x000110, "Member 'FStageEntry::BeltEffect' has a wrong offset!");

// ScriptStruct OrionGame.OrionQuestObjectiveData
// 0x0040 (0x0040 - 0x0000)
struct FOrionQuestObjectiveData final
{
public:
	class FName                                   ObjectiveBackendName;                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ObjectiveText;                                     // 0x0008(0x0018)(NativeAccessSpecifierPublic)
	bool                                          bIsCompleted;                                      // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Count;                                             // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountMax;                                          // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHidden;                                           // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UOrionMcpQuestItem>      QuestItem;                                         // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AOrionPlayerState_Game>  PlayerState;                                       // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionQuestObjectiveData) == 0x000008, "Wrong alignment on FOrionQuestObjectiveData");
static_assert(sizeof(FOrionQuestObjectiveData) == 0x000040, "Wrong size on FOrionQuestObjectiveData");
static_assert(offsetof(FOrionQuestObjectiveData, ObjectiveBackendName) == 0x000000, "Member 'FOrionQuestObjectiveData::ObjectiveBackendName' has a wrong offset!");
static_assert(offsetof(FOrionQuestObjectiveData, ObjectiveText) == 0x000008, "Member 'FOrionQuestObjectiveData::ObjectiveText' has a wrong offset!");
static_assert(offsetof(FOrionQuestObjectiveData, bIsCompleted) == 0x000020, "Member 'FOrionQuestObjectiveData::bIsCompleted' has a wrong offset!");
static_assert(offsetof(FOrionQuestObjectiveData, Count) == 0x000024, "Member 'FOrionQuestObjectiveData::Count' has a wrong offset!");
static_assert(offsetof(FOrionQuestObjectiveData, CountMax) == 0x000028, "Member 'FOrionQuestObjectiveData::CountMax' has a wrong offset!");
static_assert(offsetof(FOrionQuestObjectiveData, bHidden) == 0x00002C, "Member 'FOrionQuestObjectiveData::bHidden' has a wrong offset!");
static_assert(offsetof(FOrionQuestObjectiveData, QuestItem) == 0x000030, "Member 'FOrionQuestObjectiveData::QuestItem' has a wrong offset!");
static_assert(offsetof(FOrionQuestObjectiveData, PlayerState) == 0x000038, "Member 'FOrionQuestObjectiveData::PlayerState' has a wrong offset!");

// ScriptStruct OrionGame.OrionRarityInfo
// 0x0028 (0x0028 - 0x0000)
struct FOrionRarityInfo final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0018(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionRarityInfo) == 0x000008, "Wrong alignment on FOrionRarityInfo");
static_assert(sizeof(FOrionRarityInfo) == 0x000028, "Wrong size on FOrionRarityInfo");
static_assert(offsetof(FOrionRarityInfo, Name) == 0x000000, "Member 'FOrionRarityInfo::Name' has a wrong offset!");
static_assert(offsetof(FOrionRarityInfo, Color) == 0x000018, "Member 'FOrionRarityInfo::Color' has a wrong offset!");

// ScriptStruct OrionGame.GemTreeBranchPipEffects
// 0x0038 (0x0038 - 0x0000)
struct FGemTreeBranchPipEffects final
{
public:
	TSubclassOf<class UGameplayEffect>            MinorPipEffect;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            MajorPipEffects[0x6];                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGemTreeBranchPipEffects) == 0x000008, "Wrong alignment on FGemTreeBranchPipEffects");
static_assert(sizeof(FGemTreeBranchPipEffects) == 0x000038, "Wrong size on FGemTreeBranchPipEffects");
static_assert(offsetof(FGemTreeBranchPipEffects, MinorPipEffect) == 0x000000, "Member 'FGemTreeBranchPipEffects::MinorPipEffect' has a wrong offset!");
static_assert(offsetof(FGemTreeBranchPipEffects, MajorPipEffects) == 0x000008, "Member 'FGemTreeBranchPipEffects::MajorPipEffects' has a wrong offset!");

// ScriptStruct OrionGame.ArcadeHUDScoreInfo
// 0x000B (0x000C - 0x0001)
struct FArcadeHUDScoreInfo final : public FUIUpdateHelperStruct
{
public:
	EOrionTeam                                    TeamNum;                                           // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Kills;                                             // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Deaths;                                            // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArcadeHUDScoreInfo) == 0x000004, "Wrong alignment on FArcadeHUDScoreInfo");
static_assert(sizeof(FArcadeHUDScoreInfo) == 0x00000C, "Wrong size on FArcadeHUDScoreInfo");
static_assert(offsetof(FArcadeHUDScoreInfo, TeamNum) == 0x000001, "Member 'FArcadeHUDScoreInfo::TeamNum' has a wrong offset!");
static_assert(offsetof(FArcadeHUDScoreInfo, Kills) == 0x000004, "Member 'FArcadeHUDScoreInfo::Kills' has a wrong offset!");
static_assert(offsetof(FArcadeHUDScoreInfo, Deaths) == 0x000008, "Member 'FArcadeHUDScoreInfo::Deaths' has a wrong offset!");

// ScriptStruct OrionGame.QualifierContextAggregator
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FQualifierContextAggregator final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQualifierContextAggregator) == 0x000008, "Wrong alignment on FQualifierContextAggregator");
static_assert(sizeof(FQualifierContextAggregator) == 0x000050, "Wrong size on FQualifierContextAggregator");

// ScriptStruct OrionGame.OrionLoadingMetaInfo
// 0x0010 (0x0010 - 0x0000)
struct FOrionLoadingMetaInfo final
{
public:
	class UProperty*                              Property;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionLoadingPhase                            LoadingPhase;                                      // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionLoadingMetaInfo) == 0x000008, "Wrong alignment on FOrionLoadingMetaInfo");
static_assert(sizeof(FOrionLoadingMetaInfo) == 0x000010, "Wrong size on FOrionLoadingMetaInfo");
static_assert(offsetof(FOrionLoadingMetaInfo, Property) == 0x000000, "Member 'FOrionLoadingMetaInfo::Property' has a wrong offset!");
static_assert(offsetof(FOrionLoadingMetaInfo, LoadingPhase) == 0x000008, "Member 'FOrionLoadingMetaInfo::LoadingPhase' has a wrong offset!");

// ScriptStruct OrionGame.QualifierContextAggregated_Damage
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FQualifierContextAggregated_Damage final : public FQualifierContextBase
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQualifierContextAggregated_Damage) == 0x000004, "Wrong alignment on FQualifierContextAggregated_Damage");
static_assert(sizeof(FQualifierContextAggregated_Damage) == 0x00000C, "Wrong size on FQualifierContextAggregated_Damage");

// ScriptStruct OrionGame.OrionAttributeViewItem
// 0x0110 (0x0110 - 0x0000)
struct FOrionAttributeViewItem final
{
public:
	struct FGuid                                  ViewItemId;                                        // 0x0000(0x0010)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             DisplayIcon;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MarkupAbbreviation;                                // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0028(0x0018)(Edit, NativeAccessSpecifierPublic)
	EAbilityDisplayValueFormat                    DisplayValueFormat;                                // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue;                                          // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttributeViewCategory                        Category;                                          // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAttribute                     Attribute;                                         // 0x0050(0x0020)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               SourceTags;                                        // 0x0070(0x0040)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TargetTags;                                        // 0x00B0(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  BuffStatusTags;                                    // 0x00D0(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  DebuffStatusTags;                                  // 0x00F0(0x0020)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionAttributeViewItem) == 0x000008, "Wrong alignment on FOrionAttributeViewItem");
static_assert(sizeof(FOrionAttributeViewItem) == 0x000110, "Wrong size on FOrionAttributeViewItem");
static_assert(offsetof(FOrionAttributeViewItem, ViewItemId) == 0x000000, "Member 'FOrionAttributeViewItem::ViewItemId' has a wrong offset!");
static_assert(offsetof(FOrionAttributeViewItem, DisplayIcon) == 0x000010, "Member 'FOrionAttributeViewItem::DisplayIcon' has a wrong offset!");
static_assert(offsetof(FOrionAttributeViewItem, MarkupAbbreviation) == 0x000018, "Member 'FOrionAttributeViewItem::MarkupAbbreviation' has a wrong offset!");
static_assert(offsetof(FOrionAttributeViewItem, DisplayName) == 0x000028, "Member 'FOrionAttributeViewItem::DisplayName' has a wrong offset!");
static_assert(offsetof(FOrionAttributeViewItem, DisplayValueFormat) == 0x000040, "Member 'FOrionAttributeViewItem::DisplayValueFormat' has a wrong offset!");
static_assert(offsetof(FOrionAttributeViewItem, MaxValue) == 0x000044, "Member 'FOrionAttributeViewItem::MaxValue' has a wrong offset!");
static_assert(offsetof(FOrionAttributeViewItem, Category) == 0x000048, "Member 'FOrionAttributeViewItem::Category' has a wrong offset!");
static_assert(offsetof(FOrionAttributeViewItem, Attribute) == 0x000050, "Member 'FOrionAttributeViewItem::Attribute' has a wrong offset!");
static_assert(offsetof(FOrionAttributeViewItem, SourceTags) == 0x000070, "Member 'FOrionAttributeViewItem::SourceTags' has a wrong offset!");
static_assert(offsetof(FOrionAttributeViewItem, TargetTags) == 0x0000B0, "Member 'FOrionAttributeViewItem::TargetTags' has a wrong offset!");
static_assert(offsetof(FOrionAttributeViewItem, BuffStatusTags) == 0x0000D0, "Member 'FOrionAttributeViewItem::BuffStatusTags' has a wrong offset!");
static_assert(offsetof(FOrionAttributeViewItem, DebuffStatusTags) == 0x0000F0, "Member 'FOrionAttributeViewItem::DebuffStatusTags' has a wrong offset!");

// ScriptStruct OrionGame.CoinCXPValueScalar
// 0x0008 (0x0008 - 0x0000)
struct FCoinCXPValueScalar final
{
public:
	float                                         CoinValue;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionCoinSize                                CoinSize;                                          // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCoinCXPValueScalar) == 0x000004, "Wrong alignment on FCoinCXPValueScalar");
static_assert(sizeof(FCoinCXPValueScalar) == 0x000008, "Wrong size on FCoinCXPValueScalar");
static_assert(offsetof(FCoinCXPValueScalar, CoinValue) == 0x000000, "Member 'FCoinCXPValueScalar::CoinValue' has a wrong offset!");
static_assert(offsetof(FCoinCXPValueScalar, CoinSize) == 0x000004, "Member 'FCoinCXPValueScalar::CoinSize' has a wrong offset!");

// ScriptStruct OrionGame.OrionAttributeViewItemHandle
// 0x0020 (0x0020 - 0x0000)
struct FOrionAttributeViewItemHandle final
{
public:
	struct FGuid                                  ViewItemId;                                        // 0x0000(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 ViewItemAbbreviation;                              // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOrionAttributeViewItemHandle) == 0x000008, "Wrong alignment on FOrionAttributeViewItemHandle");
static_assert(sizeof(FOrionAttributeViewItemHandle) == 0x000020, "Wrong size on FOrionAttributeViewItemHandle");
static_assert(offsetof(FOrionAttributeViewItemHandle, ViewItemId) == 0x000000, "Member 'FOrionAttributeViewItemHandle::ViewItemId' has a wrong offset!");
static_assert(offsetof(FOrionAttributeViewItemHandle, ViewItemAbbreviation) == 0x000010, "Member 'FOrionAttributeViewItemHandle::ViewItemAbbreviation' has a wrong offset!");

// ScriptStruct OrionGame.DataTableNameMappingPair
// 0x0020 (0x0020 - 0x0000)
struct FDataTableNameMappingPair final
{
public:
	class FString                                 MapName;                                           // 0x0000(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CurveSetName;                                      // 0x0010(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDataTableNameMappingPair) == 0x000008, "Wrong alignment on FDataTableNameMappingPair");
static_assert(sizeof(FDataTableNameMappingPair) == 0x000020, "Wrong size on FDataTableNameMappingPair");
static_assert(offsetof(FDataTableNameMappingPair, MapName) == 0x000000, "Member 'FDataTableNameMappingPair::MapName' has a wrong offset!");
static_assert(offsetof(FDataTableNameMappingPair, CurveSetName) == 0x000010, "Member 'FDataTableNameMappingPair::CurveSetName' has a wrong offset!");

// ScriptStruct OrionGame.OrionAcceptMatchData
// 0x0020 (0x0020 - 0x0000)
struct FOrionAcceptMatchData final
{
public:
	struct FUniqueNetIdRepl                       PlayerId;                                          // 0x0000(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionAcceptMatchState                        AcceptMatchState;                                  // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionAcceptMatchData) == 0x000008, "Wrong alignment on FOrionAcceptMatchData");
static_assert(sizeof(FOrionAcceptMatchData) == 0x000020, "Wrong size on FOrionAcceptMatchData");
static_assert(offsetof(FOrionAcceptMatchData, PlayerId) == 0x000000, "Member 'FOrionAcceptMatchData::PlayerId' has a wrong offset!");
static_assert(offsetof(FOrionAcceptMatchData, AcceptMatchState) == 0x000018, "Member 'FOrionAcceptMatchData::AcceptMatchState' has a wrong offset!");

// ScriptStruct OrionGame.OrionPersistentPartyRepState
// 0x0078 (0x0098 - 0x0020)
struct FOrionPersistentPartyRepState final : public FOrionPartyRepState
{
public:
	EOrionPartyState                              PartyProgression;                                  // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlaylistId;                                        // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIBotDifficulty                              AIDifficulty;                                      // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MatchmakingCustomKey;                              // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionPartyMatchmakingState                   MatchmakingState;                                  // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumPlayersNeeded;                                  // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionLobbyBuilderResult                      MatchmakingResult;                                 // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOrionAcceptMatchData>          AcceptMatchPlayers;                                // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FUniqueNetIdRepl>               PartyMembersSnapshot;                              // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 LockInHeroResponses;                               // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        MatchmakingEstWaitTime;                            // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MatchmakingBucketId;                               // 0x0088(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionPersistentPartyRepState) == 0x000008, "Wrong alignment on FOrionPersistentPartyRepState");
static_assert(sizeof(FOrionPersistentPartyRepState) == 0x000098, "Wrong size on FOrionPersistentPartyRepState");
static_assert(offsetof(FOrionPersistentPartyRepState, PartyProgression) == 0x000020, "Member 'FOrionPersistentPartyRepState::PartyProgression' has a wrong offset!");
static_assert(offsetof(FOrionPersistentPartyRepState, PlaylistId) == 0x000024, "Member 'FOrionPersistentPartyRepState::PlaylistId' has a wrong offset!");
static_assert(offsetof(FOrionPersistentPartyRepState, AIDifficulty) == 0x000028, "Member 'FOrionPersistentPartyRepState::AIDifficulty' has a wrong offset!");
static_assert(offsetof(FOrionPersistentPartyRepState, MatchmakingCustomKey) == 0x000030, "Member 'FOrionPersistentPartyRepState::MatchmakingCustomKey' has a wrong offset!");
static_assert(offsetof(FOrionPersistentPartyRepState, MatchmakingState) == 0x000040, "Member 'FOrionPersistentPartyRepState::MatchmakingState' has a wrong offset!");
static_assert(offsetof(FOrionPersistentPartyRepState, NumPlayersNeeded) == 0x000044, "Member 'FOrionPersistentPartyRepState::NumPlayersNeeded' has a wrong offset!");
static_assert(offsetof(FOrionPersistentPartyRepState, MatchmakingResult) == 0x000048, "Member 'FOrionPersistentPartyRepState::MatchmakingResult' has a wrong offset!");
static_assert(offsetof(FOrionPersistentPartyRepState, AcceptMatchPlayers) == 0x000050, "Member 'FOrionPersistentPartyRepState::AcceptMatchPlayers' has a wrong offset!");
static_assert(offsetof(FOrionPersistentPartyRepState, PartyMembersSnapshot) == 0x000060, "Member 'FOrionPersistentPartyRepState::PartyMembersSnapshot' has a wrong offset!");
static_assert(offsetof(FOrionPersistentPartyRepState, LockInHeroResponses) == 0x000070, "Member 'FOrionPersistentPartyRepState::LockInHeroResponses' has a wrong offset!");
static_assert(offsetof(FOrionPersistentPartyRepState, MatchmakingEstWaitTime) == 0x000080, "Member 'FOrionPersistentPartyRepState::MatchmakingEstWaitTime' has a wrong offset!");
static_assert(offsetof(FOrionPersistentPartyRepState, MatchmakingBucketId) == 0x000088, "Member 'FOrionPersistentPartyRepState::MatchmakingBucketId' has a wrong offset!");

// ScriptStruct OrionGame.OrionAuraHandle
// 0x0004 (0x0004 - 0x0000)
struct FOrionAuraHandle final
{
public:
	int32                                         Handle;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOrionAuraHandle) == 0x000004, "Wrong alignment on FOrionAuraHandle");
static_assert(sizeof(FOrionAuraHandle) == 0x000004, "Wrong size on FOrionAuraHandle");
static_assert(offsetof(FOrionAuraHandle, Handle) == 0x000000, "Member 'FOrionAuraHandle::Handle' has a wrong offset!");

// ScriptStruct OrionGame.ActiveAuraSpec
// 0x0050 (0x0050 - 0x0000)
struct FActiveAuraSpec final
{
public:
	struct FOrionFilterAndEffectsContainer        FilterAndEffectsContainers;                        // 0x0000(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOrionFilterAndEffectsContainer        PeriodicFilterAndEffectsContainers;                // 0x0020(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Period;                                            // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReapplyOnRemoval;                                  // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActiveAuraSpec) == 0x000008, "Wrong alignment on FActiveAuraSpec");
static_assert(sizeof(FActiveAuraSpec) == 0x000050, "Wrong size on FActiveAuraSpec");
static_assert(offsetof(FActiveAuraSpec, FilterAndEffectsContainers) == 0x000000, "Member 'FActiveAuraSpec::FilterAndEffectsContainers' has a wrong offset!");
static_assert(offsetof(FActiveAuraSpec, PeriodicFilterAndEffectsContainers) == 0x000020, "Member 'FActiveAuraSpec::PeriodicFilterAndEffectsContainers' has a wrong offset!");
static_assert(offsetof(FActiveAuraSpec, Radius) == 0x000040, "Member 'FActiveAuraSpec::Radius' has a wrong offset!");
static_assert(offsetof(FActiveAuraSpec, Period) == 0x000044, "Member 'FActiveAuraSpec::Period' has a wrong offset!");
static_assert(offsetof(FActiveAuraSpec, ReapplyOnRemoval) == 0x000048, "Member 'FActiveAuraSpec::ReapplyOnRemoval' has a wrong offset!");

// ScriptStruct OrionGame.PendingNewAura
// 0x0068 (0x0068 - 0x0000)
struct FPendingNewAura final
{
public:
	struct FOrionAuraHandle                       Handle;                                            // 0x0000(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAbilitySystemComponent*           Source;                                            // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionAbility*                          OwningAbility;                                     // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActiveAuraSpec                        AuraSpec;                                          // 0x0018(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FPendingNewAura) == 0x000008, "Wrong alignment on FPendingNewAura");
static_assert(sizeof(FPendingNewAura) == 0x000068, "Wrong size on FPendingNewAura");
static_assert(offsetof(FPendingNewAura, Handle) == 0x000000, "Member 'FPendingNewAura::Handle' has a wrong offset!");
static_assert(offsetof(FPendingNewAura, Source) == 0x000008, "Member 'FPendingNewAura::Source' has a wrong offset!");
static_assert(offsetof(FPendingNewAura, OwningAbility) == 0x000010, "Member 'FPendingNewAura::OwningAbility' has a wrong offset!");
static_assert(offsetof(FPendingNewAura, AuraSpec) == 0x000018, "Member 'FPendingNewAura::AuraSpec' has a wrong offset!");

// ScriptStruct OrionGame.OrionQuickChatMessageInfo
// 0x0020 (0x0020 - 0x0000)
struct FOrionQuickChatMessageInfo final
{
public:
	class FText                                   MessageFormat;                                     // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	EQuickChatMessageSubject                      SubjectType;                                       // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionQuickChatMessageInfo) == 0x000008, "Wrong alignment on FOrionQuickChatMessageInfo");
static_assert(sizeof(FOrionQuickChatMessageInfo) == 0x000020, "Wrong size on FOrionQuickChatMessageInfo");
static_assert(offsetof(FOrionQuickChatMessageInfo, MessageFormat) == 0x000000, "Member 'FOrionQuickChatMessageInfo::MessageFormat' has a wrong offset!");
static_assert(offsetof(FOrionQuickChatMessageInfo, SubjectType) == 0x000018, "Member 'FOrionQuickChatMessageInfo::SubjectType' has a wrong offset!");

// ScriptStruct OrionGame.OrionDamageNumberInfo
// 0x0108 (0x0108 - 0x0000)
struct FOrionDamageNumberInfo final
{
public:
	TWeakObjectPtr<class AActor>                  DamagedActor;                                      // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  Instigator;                                        // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  EffectCauser;                                      // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DamageLocation;                                    // 0x0018(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DesiredOffset;                                     // 0x0024(0x0008)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageAmount;                                      // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionDamageNumberType                        DamageNumberType;                                  // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCritical;                                         // 0x0031(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocalPlayerIsInstigator;                          // 0x0032(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocalPlayerIsTarget;                              // 0x0033(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DebugString;                                       // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   CachedText;                                        // 0x0048(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bIsOnLocalTeam;                                    // 0x0060(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               PortraitMID;                                       // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            PortraitBrush;                                     // 0x0070(0x0078)(NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0xC];                                       // 0x00E8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeRemaining;                                     // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TotalDuration;                                     // 0x00F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FC[0xC];                                       // 0x00FC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionDamageNumberInfo) == 0x000008, "Wrong alignment on FOrionDamageNumberInfo");
static_assert(sizeof(FOrionDamageNumberInfo) == 0x000108, "Wrong size on FOrionDamageNumberInfo");
static_assert(offsetof(FOrionDamageNumberInfo, DamagedActor) == 0x000000, "Member 'FOrionDamageNumberInfo::DamagedActor' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberInfo, Instigator) == 0x000008, "Member 'FOrionDamageNumberInfo::Instigator' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberInfo, EffectCauser) == 0x000010, "Member 'FOrionDamageNumberInfo::EffectCauser' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberInfo, DamageLocation) == 0x000018, "Member 'FOrionDamageNumberInfo::DamageLocation' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberInfo, DesiredOffset) == 0x000024, "Member 'FOrionDamageNumberInfo::DesiredOffset' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberInfo, DamageAmount) == 0x00002C, "Member 'FOrionDamageNumberInfo::DamageAmount' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberInfo, DamageNumberType) == 0x000030, "Member 'FOrionDamageNumberInfo::DamageNumberType' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberInfo, bCritical) == 0x000031, "Member 'FOrionDamageNumberInfo::bCritical' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberInfo, bLocalPlayerIsInstigator) == 0x000032, "Member 'FOrionDamageNumberInfo::bLocalPlayerIsInstigator' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberInfo, bLocalPlayerIsTarget) == 0x000033, "Member 'FOrionDamageNumberInfo::bLocalPlayerIsTarget' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberInfo, DebugString) == 0x000038, "Member 'FOrionDamageNumberInfo::DebugString' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberInfo, CachedText) == 0x000048, "Member 'FOrionDamageNumberInfo::CachedText' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberInfo, bIsOnLocalTeam) == 0x000060, "Member 'FOrionDamageNumberInfo::bIsOnLocalTeam' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberInfo, PortraitMID) == 0x000068, "Member 'FOrionDamageNumberInfo::PortraitMID' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberInfo, PortraitBrush) == 0x000070, "Member 'FOrionDamageNumberInfo::PortraitBrush' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberInfo, TimeRemaining) == 0x0000F4, "Member 'FOrionDamageNumberInfo::TimeRemaining' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberInfo, TotalDuration) == 0x0000F8, "Member 'FOrionDamageNumberInfo::TotalDuration' has a wrong offset!");

// ScriptStruct OrionGame.ActiveAuraInfo
// 0x0078 (0x0078 - 0x0000)
struct FActiveAuraInfo final
{
public:
	class UOrionAbilitySystemComponent*           Source;                                            // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionGameplayVolumeComponent*          ProxyComponent;                                    // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionAbility*                          OwningAbility;                                     // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiusSquared;                                     // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionAuraHandle                       Handle;                                            // 0x001C(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x58];                                      // 0x0020(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActiveAuraInfo) == 0x000008, "Wrong alignment on FActiveAuraInfo");
static_assert(sizeof(FActiveAuraInfo) == 0x000078, "Wrong size on FActiveAuraInfo");
static_assert(offsetof(FActiveAuraInfo, Source) == 0x000000, "Member 'FActiveAuraInfo::Source' has a wrong offset!");
static_assert(offsetof(FActiveAuraInfo, ProxyComponent) == 0x000008, "Member 'FActiveAuraInfo::ProxyComponent' has a wrong offset!");
static_assert(offsetof(FActiveAuraInfo, OwningAbility) == 0x000010, "Member 'FActiveAuraInfo::OwningAbility' has a wrong offset!");
static_assert(offsetof(FActiveAuraInfo, RadiusSquared) == 0x000018, "Member 'FActiveAuraInfo::RadiusSquared' has a wrong offset!");
static_assert(offsetof(FActiveAuraInfo, Handle) == 0x00001C, "Member 'FActiveAuraInfo::Handle' has a wrong offset!");

// ScriptStruct OrionGame.FrameStatData
// 0x0060 (0x0060 - 0x0000)
struct FFrameStatData final
{
public:
	TArray<float>                                 FrameTimeStamps;                                   // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 FrameDurations;                                    // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 FrameGameTimes;                                    // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 FrameGPUTimes;                                     // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 FrameRenderTimes;                                  // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FrameNumbers;                                      // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFrameStatData) == 0x000008, "Wrong alignment on FFrameStatData");
static_assert(sizeof(FFrameStatData) == 0x000060, "Wrong size on FFrameStatData");
static_assert(offsetof(FFrameStatData, FrameTimeStamps) == 0x000000, "Member 'FFrameStatData::FrameTimeStamps' has a wrong offset!");
static_assert(offsetof(FFrameStatData, FrameDurations) == 0x000010, "Member 'FFrameStatData::FrameDurations' has a wrong offset!");
static_assert(offsetof(FFrameStatData, FrameGameTimes) == 0x000020, "Member 'FFrameStatData::FrameGameTimes' has a wrong offset!");
static_assert(offsetof(FFrameStatData, FrameGPUTimes) == 0x000030, "Member 'FFrameStatData::FrameGPUTimes' has a wrong offset!");
static_assert(offsetof(FFrameStatData, FrameRenderTimes) == 0x000040, "Member 'FFrameStatData::FrameRenderTimes' has a wrong offset!");
static_assert(offsetof(FFrameStatData, FrameNumbers) == 0x000050, "Member 'FFrameStatData::FrameNumbers' has a wrong offset!");

// ScriptStruct OrionGame.SkillDetailedInfo
// 0x0100 (0x0100 - 0x0000)
struct FSkillDetailedInfo final
{
public:
	class FString                                 CharacterName;                                     // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AbilityFriendlyName;                               // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AbilityLevel;                                      // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BasePower;                                         // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleRate;                                         // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DamageType;                                        // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cooldown;                                          // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnergyCost;                                        // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Shield;                                            // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Heal;                                              // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSpeed;                                         // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnergyArmor;                                       // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicalArmor;                                     // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeSteal;                                         // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackSpeed;                                       // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AbilityRange;                                      // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AbilityRadius;                                     // 0x006C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPassive;                                         // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         TargetingTypes;                                    // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         GameplayTagsList;                                  // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FString, float>                    CustomValues;                                      // 0x0098(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         BuildNumber;                                       // 0x00E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BranchName;                                        // 0x00F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillDetailedInfo) == 0x000008, "Wrong alignment on FSkillDetailedInfo");
static_assert(sizeof(FSkillDetailedInfo) == 0x000100, "Wrong size on FSkillDetailedInfo");
static_assert(offsetof(FSkillDetailedInfo, CharacterName) == 0x000000, "Member 'FSkillDetailedInfo::CharacterName' has a wrong offset!");
static_assert(offsetof(FSkillDetailedInfo, AbilityFriendlyName) == 0x000010, "Member 'FSkillDetailedInfo::AbilityFriendlyName' has a wrong offset!");
static_assert(offsetof(FSkillDetailedInfo, AbilityLevel) == 0x000020, "Member 'FSkillDetailedInfo::AbilityLevel' has a wrong offset!");
static_assert(offsetof(FSkillDetailedInfo, BasePower) == 0x000024, "Member 'FSkillDetailedInfo::BasePower' has a wrong offset!");
static_assert(offsetof(FSkillDetailedInfo, ScaleRate) == 0x000028, "Member 'FSkillDetailedInfo::ScaleRate' has a wrong offset!");
static_assert(offsetof(FSkillDetailedInfo, DamageType) == 0x000030, "Member 'FSkillDetailedInfo::DamageType' has a wrong offset!");
static_assert(offsetof(FSkillDetailedInfo, Cooldown) == 0x000040, "Member 'FSkillDetailedInfo::Cooldown' has a wrong offset!");
static_assert(offsetof(FSkillDetailedInfo, EnergyCost) == 0x000044, "Member 'FSkillDetailedInfo::EnergyCost' has a wrong offset!");
static_assert(offsetof(FSkillDetailedInfo, Shield) == 0x000048, "Member 'FSkillDetailedInfo::Shield' has a wrong offset!");
static_assert(offsetof(FSkillDetailedInfo, Heal) == 0x00004C, "Member 'FSkillDetailedInfo::Heal' has a wrong offset!");
static_assert(offsetof(FSkillDetailedInfo, Duration) == 0x000050, "Member 'FSkillDetailedInfo::Duration' has a wrong offset!");
static_assert(offsetof(FSkillDetailedInfo, MoveSpeed) == 0x000054, "Member 'FSkillDetailedInfo::MoveSpeed' has a wrong offset!");
static_assert(offsetof(FSkillDetailedInfo, EnergyArmor) == 0x000058, "Member 'FSkillDetailedInfo::EnergyArmor' has a wrong offset!");
static_assert(offsetof(FSkillDetailedInfo, PhysicalArmor) == 0x00005C, "Member 'FSkillDetailedInfo::PhysicalArmor' has a wrong offset!");
static_assert(offsetof(FSkillDetailedInfo, LifeSteal) == 0x000060, "Member 'FSkillDetailedInfo::LifeSteal' has a wrong offset!");
static_assert(offsetof(FSkillDetailedInfo, AttackSpeed) == 0x000064, "Member 'FSkillDetailedInfo::AttackSpeed' has a wrong offset!");
static_assert(offsetof(FSkillDetailedInfo, AbilityRange) == 0x000068, "Member 'FSkillDetailedInfo::AbilityRange' has a wrong offset!");
static_assert(offsetof(FSkillDetailedInfo, AbilityRadius) == 0x00006C, "Member 'FSkillDetailedInfo::AbilityRadius' has a wrong offset!");
static_assert(offsetof(FSkillDetailedInfo, IsPassive) == 0x000070, "Member 'FSkillDetailedInfo::IsPassive' has a wrong offset!");
static_assert(offsetof(FSkillDetailedInfo, TargetingTypes) == 0x000078, "Member 'FSkillDetailedInfo::TargetingTypes' has a wrong offset!");
static_assert(offsetof(FSkillDetailedInfo, GameplayTagsList) == 0x000088, "Member 'FSkillDetailedInfo::GameplayTagsList' has a wrong offset!");
static_assert(offsetof(FSkillDetailedInfo, CustomValues) == 0x000098, "Member 'FSkillDetailedInfo::CustomValues' has a wrong offset!");
static_assert(offsetof(FSkillDetailedInfo, BuildNumber) == 0x0000E8, "Member 'FSkillDetailedInfo::BuildNumber' has a wrong offset!");
static_assert(offsetof(FSkillDetailedInfo, BranchName) == 0x0000F0, "Member 'FSkillDetailedInfo::BranchName' has a wrong offset!");

// ScriptStruct OrionGame.CurveTableSet
// 0x0070 (0x0070 - 0x0000)
struct FCurveTableSet final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObjectLibrary*                         ObjectLibrary;                                     // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UCurveTable*>                    LoadedTables;                                      // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x50];                                      // 0x0020(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCurveTableSet) == 0x000008, "Wrong alignment on FCurveTableSet");
static_assert(sizeof(FCurveTableSet) == 0x000070, "Wrong size on FCurveTableSet");
static_assert(offsetof(FCurveTableSet, Name) == 0x000000, "Member 'FCurveTableSet::Name' has a wrong offset!");
static_assert(offsetof(FCurveTableSet, ObjectLibrary) == 0x000008, "Member 'FCurveTableSet::ObjectLibrary' has a wrong offset!");
static_assert(offsetof(FCurveTableSet, LoadedTables) == 0x000010, "Member 'FCurveTableSet::LoadedTables' has a wrong offset!");

// ScriptStruct OrionGame.PortraitInfo
// 0x0018 (0x0018 - 0x0000)
struct FPortraitInfo final
{
public:
	bool                                          bInView;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentAlpha;                                      // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondsToTrace;                                    // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               PortraitMID;                                       // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPortraitInfo) == 0x000008, "Wrong alignment on FPortraitInfo");
static_assert(sizeof(FPortraitInfo) == 0x000018, "Wrong size on FPortraitInfo");
static_assert(offsetof(FPortraitInfo, bInView) == 0x000000, "Member 'FPortraitInfo::bInView' has a wrong offset!");
static_assert(offsetof(FPortraitInfo, CurrentAlpha) == 0x000004, "Member 'FPortraitInfo::CurrentAlpha' has a wrong offset!");
static_assert(offsetof(FPortraitInfo, SecondsToTrace) == 0x000008, "Member 'FPortraitInfo::SecondsToTrace' has a wrong offset!");
static_assert(offsetof(FPortraitInfo, PortraitMID) == 0x000010, "Member 'FPortraitInfo::PortraitMID' has a wrong offset!");

// ScriptStruct OrionGame.EventToStatMapping
// 0x0010 (0x0010 - 0x0000)
struct FEventToStatMapping final
{
public:
	struct FGameplayStatEventValueTag             Type;                                              // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayQualifierAggregationWindow    Aggregation;                                       // 0x0008(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventToStatMapping) == 0x000008, "Wrong alignment on FEventToStatMapping");
static_assert(sizeof(FEventToStatMapping) == 0x000010, "Wrong size on FEventToStatMapping");
static_assert(offsetof(FEventToStatMapping, Type) == 0x000000, "Member 'FEventToStatMapping::Type' has a wrong offset!");
static_assert(offsetof(FEventToStatMapping, Aggregation) == 0x000008, "Member 'FEventToStatMapping::Aggregation' has a wrong offset!");

// ScriptStruct OrionGame.AxisKeyRedirect
// 0x0038 (0x0038 - 0x0000)
struct FAxisKeyRedirect final
{
public:
	struct FKey                                   AxisKey;                                           // 0x0000(0x0018)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AxisScale;                                         // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   DisplayKey;                                        // 0x0020(0x0018)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAxisKeyRedirect) == 0x000008, "Wrong alignment on FAxisKeyRedirect");
static_assert(sizeof(FAxisKeyRedirect) == 0x000038, "Wrong size on FAxisKeyRedirect");
static_assert(offsetof(FAxisKeyRedirect, AxisKey) == 0x000000, "Member 'FAxisKeyRedirect::AxisKey' has a wrong offset!");
static_assert(offsetof(FAxisKeyRedirect, AxisScale) == 0x000018, "Member 'FAxisKeyRedirect::AxisScale' has a wrong offset!");
static_assert(offsetof(FAxisKeyRedirect, DisplayKey) == 0x000020, "Member 'FAxisKeyRedirect::DisplayKey' has a wrong offset!");

// ScriptStruct OrionGame.BannerEntranceData
// 0x0060 (0x0060 - 0x0000)
struct FBannerEntranceData final
{
public:
	float                                         EntranceTime;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetFromGround;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransInTimeProportion;                             // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransInDelayProportion;                            // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEntranceInterpolation                        TransCurveType;                                    // 0x0014(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotInTimeProportion;                               // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotInDelayProportion;                              // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEntranceInterpolation                        RotCurveType;                                      // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScaleDest;                                         // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ScaleStart;                                        // 0x0028(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleInTimeProportion;                             // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleInDelayProportion;                            // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEntranceInterpolation                        ScaleCurveType;                                    // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BannerFadeTime;                                    // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           TransCurve;                                        // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           ScaleCurve;                                        // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           RotCurve;                                          // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBannerEntranceData) == 0x000008, "Wrong alignment on FBannerEntranceData");
static_assert(sizeof(FBannerEntranceData) == 0x000060, "Wrong size on FBannerEntranceData");
static_assert(offsetof(FBannerEntranceData, EntranceTime) == 0x000000, "Member 'FBannerEntranceData::EntranceTime' has a wrong offset!");
static_assert(offsetof(FBannerEntranceData, Height) == 0x000004, "Member 'FBannerEntranceData::Height' has a wrong offset!");
static_assert(offsetof(FBannerEntranceData, OffsetFromGround) == 0x000008, "Member 'FBannerEntranceData::OffsetFromGround' has a wrong offset!");
static_assert(offsetof(FBannerEntranceData, TransInTimeProportion) == 0x00000C, "Member 'FBannerEntranceData::TransInTimeProportion' has a wrong offset!");
static_assert(offsetof(FBannerEntranceData, TransInDelayProportion) == 0x000010, "Member 'FBannerEntranceData::TransInDelayProportion' has a wrong offset!");
static_assert(offsetof(FBannerEntranceData, TransCurveType) == 0x000014, "Member 'FBannerEntranceData::TransCurveType' has a wrong offset!");
static_assert(offsetof(FBannerEntranceData, RotInTimeProportion) == 0x000018, "Member 'FBannerEntranceData::RotInTimeProportion' has a wrong offset!");
static_assert(offsetof(FBannerEntranceData, RotInDelayProportion) == 0x00001C, "Member 'FBannerEntranceData::RotInDelayProportion' has a wrong offset!");
static_assert(offsetof(FBannerEntranceData, RotCurveType) == 0x000020, "Member 'FBannerEntranceData::RotCurveType' has a wrong offset!");
static_assert(offsetof(FBannerEntranceData, ScaleDest) == 0x000024, "Member 'FBannerEntranceData::ScaleDest' has a wrong offset!");
static_assert(offsetof(FBannerEntranceData, ScaleStart) == 0x000028, "Member 'FBannerEntranceData::ScaleStart' has a wrong offset!");
static_assert(offsetof(FBannerEntranceData, ScaleInTimeProportion) == 0x000034, "Member 'FBannerEntranceData::ScaleInTimeProportion' has a wrong offset!");
static_assert(offsetof(FBannerEntranceData, ScaleInDelayProportion) == 0x000038, "Member 'FBannerEntranceData::ScaleInDelayProportion' has a wrong offset!");
static_assert(offsetof(FBannerEntranceData, ScaleCurveType) == 0x00003C, "Member 'FBannerEntranceData::ScaleCurveType' has a wrong offset!");
static_assert(offsetof(FBannerEntranceData, BannerFadeTime) == 0x000040, "Member 'FBannerEntranceData::BannerFadeTime' has a wrong offset!");
static_assert(offsetof(FBannerEntranceData, TransCurve) == 0x000048, "Member 'FBannerEntranceData::TransCurve' has a wrong offset!");
static_assert(offsetof(FBannerEntranceData, ScaleCurve) == 0x000050, "Member 'FBannerEntranceData::ScaleCurve' has a wrong offset!");
static_assert(offsetof(FBannerEntranceData, RotCurve) == 0x000058, "Member 'FBannerEntranceData::RotCurve' has a wrong offset!");

// ScriptStruct OrionGame.BannerActivationData
// 0x00B8 (0x00B8 - 0x0000)
struct FBannerActivationData final
{
public:
	struct FBannerSpec                            BannerSpec;                                        // 0x0000(0x0068)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVector                                DestLocation;                                      // 0x0068(0x000C)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               DestRotation;                                      // 0x0074(0x000C)(BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         DestScale;                                         // 0x0080(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreatedLocallyByClient;                           // 0x0084(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBannerEntrance                               BannerEntranceType;                                // 0x0085(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_86[0x2];                                       // 0x0086(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EntranceDelay;                                     // 0x0088(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostEntranceLifeTimeOverride;                      // 0x008C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldDeactivate;                                 // 0x0090(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMirrorView;                                       // 0x0091(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRotateTowardClientView;                           // 0x0092(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_93[0x5];                                       // 0x0093(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrionPlayerState_Game*                 PlayerStateForPortrait_Killer;                     // 0x0098(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionPlayerState_Game*                 PlayerStateForPortrait_Killed;                     // 0x00A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AOrionPlayerState_Game*>         PlayerStateForPortrait_Assists;                    // 0x00A8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBannerActivationData) == 0x000008, "Wrong alignment on FBannerActivationData");
static_assert(sizeof(FBannerActivationData) == 0x0000B8, "Wrong size on FBannerActivationData");
static_assert(offsetof(FBannerActivationData, BannerSpec) == 0x000000, "Member 'FBannerActivationData::BannerSpec' has a wrong offset!");
static_assert(offsetof(FBannerActivationData, DestLocation) == 0x000068, "Member 'FBannerActivationData::DestLocation' has a wrong offset!");
static_assert(offsetof(FBannerActivationData, DestRotation) == 0x000074, "Member 'FBannerActivationData::DestRotation' has a wrong offset!");
static_assert(offsetof(FBannerActivationData, DestScale) == 0x000080, "Member 'FBannerActivationData::DestScale' has a wrong offset!");
static_assert(offsetof(FBannerActivationData, bCreatedLocallyByClient) == 0x000084, "Member 'FBannerActivationData::bCreatedLocallyByClient' has a wrong offset!");
static_assert(offsetof(FBannerActivationData, BannerEntranceType) == 0x000085, "Member 'FBannerActivationData::BannerEntranceType' has a wrong offset!");
static_assert(offsetof(FBannerActivationData, EntranceDelay) == 0x000088, "Member 'FBannerActivationData::EntranceDelay' has a wrong offset!");
static_assert(offsetof(FBannerActivationData, PostEntranceLifeTimeOverride) == 0x00008C, "Member 'FBannerActivationData::PostEntranceLifeTimeOverride' has a wrong offset!");
static_assert(offsetof(FBannerActivationData, bShouldDeactivate) == 0x000090, "Member 'FBannerActivationData::bShouldDeactivate' has a wrong offset!");
static_assert(offsetof(FBannerActivationData, bMirrorView) == 0x000091, "Member 'FBannerActivationData::bMirrorView' has a wrong offset!");
static_assert(offsetof(FBannerActivationData, bRotateTowardClientView) == 0x000092, "Member 'FBannerActivationData::bRotateTowardClientView' has a wrong offset!");
static_assert(offsetof(FBannerActivationData, PlayerStateForPortrait_Killer) == 0x000098, "Member 'FBannerActivationData::PlayerStateForPortrait_Killer' has a wrong offset!");
static_assert(offsetof(FBannerActivationData, PlayerStateForPortrait_Killed) == 0x0000A0, "Member 'FBannerActivationData::PlayerStateForPortrait_Killed' has a wrong offset!");
static_assert(offsetof(FBannerActivationData, PlayerStateForPortrait_Assists) == 0x0000A8, "Member 'FBannerActivationData::PlayerStateForPortrait_Assists' has a wrong offset!");

// ScriptStruct OrionGame.TrackedComponent
// 0x000C (0x000C - 0x0000)
struct FTrackedComponent final
{
public:
	TWeakObjectPtr<class USceneComponent>         Component;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAttachedToRoot;                                 // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTrackedComponent) == 0x000004, "Wrong alignment on FTrackedComponent");
static_assert(sizeof(FTrackedComponent) == 0x00000C, "Wrong size on FTrackedComponent");
static_assert(offsetof(FTrackedComponent, Component) == 0x000000, "Member 'FTrackedComponent::Component' has a wrong offset!");
static_assert(offsetof(FTrackedComponent, bIsAttachedToRoot) == 0x000008, "Member 'FTrackedComponent::bIsAttachedToRoot' has a wrong offset!");

// ScriptStruct OrionGame.OrionBannerCues
// 0x0058 (0x0058 - 0x0000)
struct FOrionBannerCues final
{
public:
	struct FGameplayCueTag                        Landing;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        Landed;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        TimeOutAfterLanded;                                // 0x0010(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        BurrowingUp;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        BurrowedUp;                                        // 0x0020(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        AscendingAfterBurrow;                              // 0x0028(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        AscendedAfterBurrow;                               // 0x0030(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        TimeOutAfterAscendedFromBurrow;                    // 0x0038(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        Ascending;                                         // 0x0040(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        Ascended;                                          // 0x0048(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        TimeOutAfterAscended;                              // 0x0050(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionBannerCues) == 0x000008, "Wrong alignment on FOrionBannerCues");
static_assert(sizeof(FOrionBannerCues) == 0x000058, "Wrong size on FOrionBannerCues");
static_assert(offsetof(FOrionBannerCues, Landing) == 0x000000, "Member 'FOrionBannerCues::Landing' has a wrong offset!");
static_assert(offsetof(FOrionBannerCues, Landed) == 0x000008, "Member 'FOrionBannerCues::Landed' has a wrong offset!");
static_assert(offsetof(FOrionBannerCues, TimeOutAfterLanded) == 0x000010, "Member 'FOrionBannerCues::TimeOutAfterLanded' has a wrong offset!");
static_assert(offsetof(FOrionBannerCues, BurrowingUp) == 0x000018, "Member 'FOrionBannerCues::BurrowingUp' has a wrong offset!");
static_assert(offsetof(FOrionBannerCues, BurrowedUp) == 0x000020, "Member 'FOrionBannerCues::BurrowedUp' has a wrong offset!");
static_assert(offsetof(FOrionBannerCues, AscendingAfterBurrow) == 0x000028, "Member 'FOrionBannerCues::AscendingAfterBurrow' has a wrong offset!");
static_assert(offsetof(FOrionBannerCues, AscendedAfterBurrow) == 0x000030, "Member 'FOrionBannerCues::AscendedAfterBurrow' has a wrong offset!");
static_assert(offsetof(FOrionBannerCues, TimeOutAfterAscendedFromBurrow) == 0x000038, "Member 'FOrionBannerCues::TimeOutAfterAscendedFromBurrow' has a wrong offset!");
static_assert(offsetof(FOrionBannerCues, Ascending) == 0x000040, "Member 'FOrionBannerCues::Ascending' has a wrong offset!");
static_assert(offsetof(FOrionBannerCues, Ascended) == 0x000048, "Member 'FOrionBannerCues::Ascended' has a wrong offset!");
static_assert(offsetof(FOrionBannerCues, TimeOutAfterAscended) == 0x000050, "Member 'FOrionBannerCues::TimeOutAfterAscended' has a wrong offset!");

// ScriptStruct OrionGame.CameraDragSettings
// 0x0038 (0x0038 - 0x0000)
struct FCameraDragSettings final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PositiveDragDelta;                                 // 0x0004(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NegativeDragDelta;                                 // 0x0010(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PositiveDragVelocity;                              // 0x001C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NegativeDragVelocity;                              // 0x0028(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpRate;                                          // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraDragSettings) == 0x000004, "Wrong alignment on FCameraDragSettings");
static_assert(sizeof(FCameraDragSettings) == 0x000038, "Wrong size on FCameraDragSettings");
static_assert(offsetof(FCameraDragSettings, bEnabled) == 0x000000, "Member 'FCameraDragSettings::bEnabled' has a wrong offset!");
static_assert(offsetof(FCameraDragSettings, PositiveDragDelta) == 0x000004, "Member 'FCameraDragSettings::PositiveDragDelta' has a wrong offset!");
static_assert(offsetof(FCameraDragSettings, NegativeDragDelta) == 0x000010, "Member 'FCameraDragSettings::NegativeDragDelta' has a wrong offset!");
static_assert(offsetof(FCameraDragSettings, PositiveDragVelocity) == 0x00001C, "Member 'FCameraDragSettings::PositiveDragVelocity' has a wrong offset!");
static_assert(offsetof(FCameraDragSettings, NegativeDragVelocity) == 0x000028, "Member 'FCameraDragSettings::NegativeDragVelocity' has a wrong offset!");
static_assert(offsetof(FCameraDragSettings, LerpRate) == 0x000034, "Member 'FCameraDragSettings::LerpRate' has a wrong offset!");

// ScriptStruct OrionGame.OrionCharHoverData
// 0x0038 (0x0038 - 0x0000)
struct FOrionCharHoverData final
{
public:
	float                                         TraceResultNormalZThreshold;                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialZOffsetMinimum;                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverTraceDistance;                                // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesiredHeightOffFloor;                             // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpwardStrength;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpwardMaxSpeed;                                    // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DownwardStrength;                                  // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DownwardMaxSpeed;                                  // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayDebug;                                     // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VelocityLeadTimeStepMult;                          // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHoverInitialized;                                 // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DestZ;                                             // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VertAccel;                                         // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharHoverMovement                            HoverMovementType;                                 // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionCharHoverData) == 0x000004, "Wrong alignment on FOrionCharHoverData");
static_assert(sizeof(FOrionCharHoverData) == 0x000038, "Wrong size on FOrionCharHoverData");
static_assert(offsetof(FOrionCharHoverData, TraceResultNormalZThreshold) == 0x000000, "Member 'FOrionCharHoverData::TraceResultNormalZThreshold' has a wrong offset!");
static_assert(offsetof(FOrionCharHoverData, InitialZOffsetMinimum) == 0x000004, "Member 'FOrionCharHoverData::InitialZOffsetMinimum' has a wrong offset!");
static_assert(offsetof(FOrionCharHoverData, HoverTraceDistance) == 0x000008, "Member 'FOrionCharHoverData::HoverTraceDistance' has a wrong offset!");
static_assert(offsetof(FOrionCharHoverData, DesiredHeightOffFloor) == 0x00000C, "Member 'FOrionCharHoverData::DesiredHeightOffFloor' has a wrong offset!");
static_assert(offsetof(FOrionCharHoverData, UpwardStrength) == 0x000010, "Member 'FOrionCharHoverData::UpwardStrength' has a wrong offset!");
static_assert(offsetof(FOrionCharHoverData, UpwardMaxSpeed) == 0x000014, "Member 'FOrionCharHoverData::UpwardMaxSpeed' has a wrong offset!");
static_assert(offsetof(FOrionCharHoverData, DownwardStrength) == 0x000018, "Member 'FOrionCharHoverData::DownwardStrength' has a wrong offset!");
static_assert(offsetof(FOrionCharHoverData, DownwardMaxSpeed) == 0x00001C, "Member 'FOrionCharHoverData::DownwardMaxSpeed' has a wrong offset!");
static_assert(offsetof(FOrionCharHoverData, bDisplayDebug) == 0x000020, "Member 'FOrionCharHoverData::bDisplayDebug' has a wrong offset!");
static_assert(offsetof(FOrionCharHoverData, VelocityLeadTimeStepMult) == 0x000024, "Member 'FOrionCharHoverData::VelocityLeadTimeStepMult' has a wrong offset!");
static_assert(offsetof(FOrionCharHoverData, bHoverInitialized) == 0x000028, "Member 'FOrionCharHoverData::bHoverInitialized' has a wrong offset!");
static_assert(offsetof(FOrionCharHoverData, DestZ) == 0x00002C, "Member 'FOrionCharHoverData::DestZ' has a wrong offset!");
static_assert(offsetof(FOrionCharHoverData, VertAccel) == 0x000030, "Member 'FOrionCharHoverData::VertAccel' has a wrong offset!");
static_assert(offsetof(FOrionCharHoverData, HoverMovementType) == 0x000034, "Member 'FOrionCharHoverData::HoverMovementType' has a wrong offset!");

// ScriptStruct OrionGame.OrionMcpCardPackCalloutItem
// 0x0018 (0x0018 - 0x0000)
struct FOrionMcpCardPackCalloutItem final
{
public:
	class UOrionMcpItemDefinition*                ItemDefinition;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInt32Range                            Quantity;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionMcpCardPackCalloutItem) == 0x000008, "Wrong alignment on FOrionMcpCardPackCalloutItem");
static_assert(sizeof(FOrionMcpCardPackCalloutItem) == 0x000018, "Wrong size on FOrionMcpCardPackCalloutItem");
static_assert(offsetof(FOrionMcpCardPackCalloutItem, ItemDefinition) == 0x000000, "Member 'FOrionMcpCardPackCalloutItem::ItemDefinition' has a wrong offset!");
static_assert(offsetof(FOrionMcpCardPackCalloutItem, Quantity) == 0x000008, "Member 'FOrionMcpCardPackCalloutItem::Quantity' has a wrong offset!");

// ScriptStruct OrionGame.CameraViewOffset
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x08) FCameraViewOffset final
{
public:
	struct FVector                                HighPitchOffset;                                   // 0x0000(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MidPitchOffset;                                    // 0x000C(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LowPitchOffset;                                    // 0x0018(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x1C];                                      // 0x0024(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCameraViewOffset) == 0x000008, "Wrong alignment on FCameraViewOffset");
static_assert(sizeof(FCameraViewOffset) == 0x000040, "Wrong size on FCameraViewOffset");
static_assert(offsetof(FCameraViewOffset, HighPitchOffset) == 0x000000, "Member 'FCameraViewOffset::HighPitchOffset' has a wrong offset!");
static_assert(offsetof(FCameraViewOffset, MidPitchOffset) == 0x00000C, "Member 'FCameraViewOffset::MidPitchOffset' has a wrong offset!");
static_assert(offsetof(FCameraViewOffset, LowPitchOffset) == 0x000018, "Member 'FCameraViewOffset::LowPitchOffset' has a wrong offset!");

// ScriptStruct OrionGame.OrionCardCostIconInfo
// 0x0018 (0x0018 - 0x0000)
struct FOrionCardCostIconInfo final
{
public:
	class UMaterialInterface*                     IconMaterial;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RenderScale;                                       // 0x0008(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionWidgetStyleSize                         StyleSize;                                         // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTextColor                               ColorType;                                         // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionCardCostIconInfo) == 0x000008, "Wrong alignment on FOrionCardCostIconInfo");
static_assert(sizeof(FOrionCardCostIconInfo) == 0x000018, "Wrong size on FOrionCardCostIconInfo");
static_assert(offsetof(FOrionCardCostIconInfo, IconMaterial) == 0x000000, "Member 'FOrionCardCostIconInfo::IconMaterial' has a wrong offset!");
static_assert(offsetof(FOrionCardCostIconInfo, RenderScale) == 0x000008, "Member 'FOrionCardCostIconInfo::RenderScale' has a wrong offset!");
static_assert(offsetof(FOrionCardCostIconInfo, StyleSize) == 0x000010, "Member 'FOrionCardCostIconInfo::StyleSize' has a wrong offset!");
static_assert(offsetof(FOrionCardCostIconInfo, ColorType) == 0x000011, "Member 'FOrionCardCostIconInfo::ColorType' has a wrong offset!");

// ScriptStruct OrionGame.McpBannerEntry
// 0x0010 (0x0010 - 0x0000)
struct FMcpBannerEntry final
{
public:
	class FString                                 BannerPieceId;                                     // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMcpBannerEntry) == 0x000008, "Wrong alignment on FMcpBannerEntry");
static_assert(sizeof(FMcpBannerEntry) == 0x000010, "Wrong size on FMcpBannerEntry");
static_assert(offsetof(FMcpBannerEntry, BannerPieceId) == 0x000000, "Member 'FMcpBannerEntry::BannerPieceId' has a wrong offset!");

// ScriptStruct OrionGame.OrionLevelChainByRarity
// 0x0018 (0x0018 - 0x0000)
struct FOrionLevelChainByRarity final
{
public:
	EOrionItemRarity                              CardRarity;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOrionCardLevel>                Levels;                                            // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionLevelChainByRarity) == 0x000008, "Wrong alignment on FOrionLevelChainByRarity");
static_assert(sizeof(FOrionLevelChainByRarity) == 0x000018, "Wrong size on FOrionLevelChainByRarity");
static_assert(offsetof(FOrionLevelChainByRarity, CardRarity) == 0x000000, "Member 'FOrionLevelChainByRarity::CardRarity' has a wrong offset!");
static_assert(offsetof(FOrionLevelChainByRarity, Levels) == 0x000008, "Member 'FOrionLevelChainByRarity::Levels' has a wrong offset!");

// ScriptStruct OrionGame.OrionMcpCardPackLoot
// 0x0050 (0x0050 - 0x0000)
struct FOrionMcpCardPackLoot final
{
public:
	TArray<TSoftObjectPtr<class UOrionMcpItemDefinition>> ExplicitItems;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class FString                                 LootTierGroup;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LootTier;                                          // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UOrionMcpTokenItemDefinition> RequiredTokenToOpen;                               // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionMcpCardPackLoot) == 0x000008, "Wrong alignment on FOrionMcpCardPackLoot");
static_assert(sizeof(FOrionMcpCardPackLoot) == 0x000050, "Wrong size on FOrionMcpCardPackLoot");
static_assert(offsetof(FOrionMcpCardPackLoot, ExplicitItems) == 0x000000, "Member 'FOrionMcpCardPackLoot::ExplicitItems' has a wrong offset!");
static_assert(offsetof(FOrionMcpCardPackLoot, LootTierGroup) == 0x000010, "Member 'FOrionMcpCardPackLoot::LootTierGroup' has a wrong offset!");
static_assert(offsetof(FOrionMcpCardPackLoot, LootTier) == 0x000020, "Member 'FOrionMcpCardPackLoot::LootTier' has a wrong offset!");
static_assert(offsetof(FOrionMcpCardPackLoot, RequiredTokenToOpen) == 0x000028, "Member 'FOrionMcpCardPackLoot::RequiredTokenToOpen' has a wrong offset!");

// ScriptStruct OrionGame.GameplayCurrencyBundle
// 0x0010 (0x0010 - 0x0000)
struct FGameplayCurrencyBundle final
{
public:
	int32                                         Gold;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GemTreePips[0x3];                                  // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayCurrencyBundle) == 0x000004, "Wrong alignment on FGameplayCurrencyBundle");
static_assert(sizeof(FGameplayCurrencyBundle) == 0x000010, "Wrong size on FGameplayCurrencyBundle");
static_assert(offsetof(FGameplayCurrencyBundle, Gold) == 0x000000, "Member 'FGameplayCurrencyBundle::Gold' has a wrong offset!");
static_assert(offsetof(FGameplayCurrencyBundle, GemTreePips) == 0x000004, "Member 'FGameplayCurrencyBundle::GemTreePips' has a wrong offset!");

// ScriptStruct OrionGame.NormalAppearanceComponentMaterials
// 0x0018 (0x0018 - 0x0000)
struct FNormalAppearanceComponentMaterials final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInterface*>             NormalAppearanceMaterials;                         // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNormalAppearanceComponentMaterials) == 0x000008, "Wrong alignment on FNormalAppearanceComponentMaterials");
static_assert(sizeof(FNormalAppearanceComponentMaterials) == 0x000018, "Wrong size on FNormalAppearanceComponentMaterials");
static_assert(offsetof(FNormalAppearanceComponentMaterials, NormalAppearanceMaterials) == 0x000008, "Member 'FNormalAppearanceComponentMaterials::NormalAppearanceMaterials' has a wrong offset!");

// ScriptStruct OrionGame.AccountProgression
// 0x0014 (0x0014 - 0x0000)
struct FAccountProgression final
{
public:
	int32                                         ProfileXP;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalXP;                                           // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProfileRank;                                       // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ValorRank;                                         // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XPToNextLevel;                                     // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccountProgression) == 0x000004, "Wrong alignment on FAccountProgression");
static_assert(sizeof(FAccountProgression) == 0x000014, "Wrong size on FAccountProgression");
static_assert(offsetof(FAccountProgression, ProfileXP) == 0x000000, "Member 'FAccountProgression::ProfileXP' has a wrong offset!");
static_assert(offsetof(FAccountProgression, TotalXP) == 0x000004, "Member 'FAccountProgression::TotalXP' has a wrong offset!");
static_assert(offsetof(FAccountProgression, ProfileRank) == 0x000008, "Member 'FAccountProgression::ProfileRank' has a wrong offset!");
static_assert(offsetof(FAccountProgression, ValorRank) == 0x00000C, "Member 'FAccountProgression::ValorRank' has a wrong offset!");
static_assert(offsetof(FAccountProgression, XPToNextLevel) == 0x000010, "Member 'FAccountProgression::XPToNextLevel' has a wrong offset!");

// ScriptStruct OrionGame.OrionQuestionGroupInfo
// 0x0030 (0x0030 - 0x0000)
struct FOrionQuestionGroupInfo final
{
public:
	class FName                                   SurveyId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   MESSAGE;                                           // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FText>                           Questions;                                         // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionQuestionGroupInfo) == 0x000008, "Wrong alignment on FOrionQuestionGroupInfo");
static_assert(sizeof(FOrionQuestionGroupInfo) == 0x000030, "Wrong size on FOrionQuestionGroupInfo");
static_assert(offsetof(FOrionQuestionGroupInfo, SurveyId) == 0x000000, "Member 'FOrionQuestionGroupInfo::SurveyId' has a wrong offset!");
static_assert(offsetof(FOrionQuestionGroupInfo, MESSAGE) == 0x000008, "Member 'FOrionQuestionGroupInfo::MESSAGE' has a wrong offset!");
static_assert(offsetof(FOrionQuestionGroupInfo, Questions) == 0x000020, "Member 'FOrionQuestionGroupInfo::Questions' has a wrong offset!");

// ScriptStruct OrionGame.OrionMinionNudgeInfo
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x08) FOrionMinionNudgeInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRecentlyNudgedByHero;                             // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecentlyNudgedByMinion;                           // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NudgeVector;                                       // 0x001C(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NudgeByMinionVector;                               // 0x0028(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NudgeTimeTotal;                                    // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NudgeTimeRemaining;                                // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrevNudgeMoveTime;                                 // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionMinionNudgeInfo) == 0x000008, "Wrong alignment on FOrionMinionNudgeInfo");
static_assert(sizeof(FOrionMinionNudgeInfo) == 0x000040, "Wrong size on FOrionMinionNudgeInfo");
static_assert(offsetof(FOrionMinionNudgeInfo, bRecentlyNudgedByHero) == 0x000018, "Member 'FOrionMinionNudgeInfo::bRecentlyNudgedByHero' has a wrong offset!");
static_assert(offsetof(FOrionMinionNudgeInfo, bRecentlyNudgedByMinion) == 0x000019, "Member 'FOrionMinionNudgeInfo::bRecentlyNudgedByMinion' has a wrong offset!");
static_assert(offsetof(FOrionMinionNudgeInfo, NudgeVector) == 0x00001C, "Member 'FOrionMinionNudgeInfo::NudgeVector' has a wrong offset!");
static_assert(offsetof(FOrionMinionNudgeInfo, NudgeByMinionVector) == 0x000028, "Member 'FOrionMinionNudgeInfo::NudgeByMinionVector' has a wrong offset!");
static_assert(offsetof(FOrionMinionNudgeInfo, NudgeTimeTotal) == 0x000034, "Member 'FOrionMinionNudgeInfo::NudgeTimeTotal' has a wrong offset!");
static_assert(offsetof(FOrionMinionNudgeInfo, NudgeTimeRemaining) == 0x000038, "Member 'FOrionMinionNudgeInfo::NudgeTimeRemaining' has a wrong offset!");
static_assert(offsetof(FOrionMinionNudgeInfo, PrevNudgeMoveTime) == 0x00003C, "Member 'FOrionMinionNudgeInfo::PrevNudgeMoveTime' has a wrong offset!");

// ScriptStruct OrionGame.OrionMinionAttackInfo
// 0x0010 (0x0010 - 0x0000)
struct FOrionMinionAttackInfo final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TravelTime;                                        // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileArcFactor;                               // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionMinionAttackInfo) == 0x000008, "Wrong alignment on FOrionMinionAttackInfo");
static_assert(sizeof(FOrionMinionAttackInfo) == 0x000010, "Wrong size on FOrionMinionAttackInfo");
static_assert(offsetof(FOrionMinionAttackInfo, TargetActor) == 0x000000, "Member 'FOrionMinionAttackInfo::TargetActor' has a wrong offset!");
static_assert(offsetof(FOrionMinionAttackInfo, TravelTime) == 0x000008, "Member 'FOrionMinionAttackInfo::TravelTime' has a wrong offset!");
static_assert(offsetof(FOrionMinionAttackInfo, ProjectileArcFactor) == 0x00000C, "Member 'FOrionMinionAttackInfo::ProjectileArcFactor' has a wrong offset!");

// ScriptStruct OrionGame.OrionMinionAnimInstanceProxy
// 0x0280 (0x0760 - 0x04E0)
struct FOrionMinionAnimInstanceProxy final : public FAnimInstanceProxy
{
public:
	uint8                                         Pad_4D8[0xEC];                                     // 0x04D8(0x00EC)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CurrentFloorNormal;                                // 0x05C4(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SmoothedFloorNormal;                               // 0x05D0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGoingUphill;                                      // 0x05DC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGoingDownhill;                                    // 0x05DD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMoving;                                         // 0x05DE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMoving_LowSpeed;                                // 0x05DF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementAngle;                                     // 0x05E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalSpeed;                                   // 0x05E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshMovementSpeed;                                 // 0x05E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTurning;                                        // 0x05EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5ED[0x3];                                      // 0x05ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MeshYawAngularVelocity;                            // 0x05F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshYawTurnPlayRate;                               // 0x05F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVectorRK4SpringInterpolator           RelativeMovementDirInterpolator;                   // 0x05F8(0x0008)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_600[0x40];                                     // 0x0600(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  MovementRelativeRot;                               // 0x0640(0x0010)(Edit, BlueprintVisible, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ActiveLocomotionIndex;                             // 0x0650(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NonFullBodyWeight;                                 // 0x0654(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PoseTimeOffset;                                    // 0x0658(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLookingAtTarget;                                  // 0x065C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreventAiming;                                    // 0x065D(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65E[0x2];                                      // 0x065E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetLocation;                                    // 0x0660(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTargetingPlayer;                                // 0x066C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTargetingTower;                                 // 0x066D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTargetingTowerAndNotMoving;                     // 0x066E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_66F[0x1];                                      // 0x066F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVectorRK4SpringInterpolator           AimDirInterpolator;                                // 0x0670(0x0008)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_678[0x34];                                     // 0x0678(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVectorRK4SpringInterpolator           FloorNormalInterpolator;                           // 0x06AC(0x0008)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6B4[0x34];                                     // 0x06B4(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CompSpaceDesiredAimDir;                            // 0x06E8(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CompSpaceAimDir;                                   // 0x06F4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DefaultForwardAxisVector;                          // 0x0700(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LookAtTarget;                                      // 0x070C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PoseIndex;                                         // 0x0718(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UniqueMinionID;                                    // 0x071C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoneReference                         SplitBodyBone;                                     // 0x0720(0x0018)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bAllowedToRagdoll;                                 // 0x0738(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_739[0x3];                                      // 0x0739(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RagdollAlpha;                                      // 0x073C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayingDeathAnim;                                 // 0x0740(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_741[0x3];                                      // 0x0741(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeathAnimRagdollTriggerTime;                       // 0x0744(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeathAnimPlaybackTime;                             // 0x0748(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastFrameDeltaSeconds;                             // 0x074C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DeathAnimFrameCount;                               // 0x0750(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DeathAnimIndex;                                    // 0x0754(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInCombat;                                       // 0x0758(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_759[0x3];                                      // 0x0759(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastHitVulnerableAlpha;                            // 0x075C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionMinionAnimInstanceProxy) == 0x000010, "Wrong alignment on FOrionMinionAnimInstanceProxy");
static_assert(sizeof(FOrionMinionAnimInstanceProxy) == 0x000760, "Wrong size on FOrionMinionAnimInstanceProxy");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, CurrentFloorNormal) == 0x0005C4, "Member 'FOrionMinionAnimInstanceProxy::CurrentFloorNormal' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, SmoothedFloorNormal) == 0x0005D0, "Member 'FOrionMinionAnimInstanceProxy::SmoothedFloorNormal' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, bGoingUphill) == 0x0005DC, "Member 'FOrionMinionAnimInstanceProxy::bGoingUphill' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, bGoingDownhill) == 0x0005DD, "Member 'FOrionMinionAnimInstanceProxy::bGoingDownhill' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, bIsMoving) == 0x0005DE, "Member 'FOrionMinionAnimInstanceProxy::bIsMoving' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, bIsMoving_LowSpeed) == 0x0005DF, "Member 'FOrionMinionAnimInstanceProxy::bIsMoving_LowSpeed' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, MovementAngle) == 0x0005E0, "Member 'FOrionMinionAnimInstanceProxy::MovementAngle' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, HorizontalSpeed) == 0x0005E4, "Member 'FOrionMinionAnimInstanceProxy::HorizontalSpeed' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, MeshMovementSpeed) == 0x0005E8, "Member 'FOrionMinionAnimInstanceProxy::MeshMovementSpeed' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, bIsTurning) == 0x0005EC, "Member 'FOrionMinionAnimInstanceProxy::bIsTurning' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, MeshYawAngularVelocity) == 0x0005F0, "Member 'FOrionMinionAnimInstanceProxy::MeshYawAngularVelocity' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, MeshYawTurnPlayRate) == 0x0005F4, "Member 'FOrionMinionAnimInstanceProxy::MeshYawTurnPlayRate' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, RelativeMovementDirInterpolator) == 0x0005F8, "Member 'FOrionMinionAnimInstanceProxy::RelativeMovementDirInterpolator' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, MovementRelativeRot) == 0x000640, "Member 'FOrionMinionAnimInstanceProxy::MovementRelativeRot' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, ActiveLocomotionIndex) == 0x000650, "Member 'FOrionMinionAnimInstanceProxy::ActiveLocomotionIndex' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, NonFullBodyWeight) == 0x000654, "Member 'FOrionMinionAnimInstanceProxy::NonFullBodyWeight' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, PoseTimeOffset) == 0x000658, "Member 'FOrionMinionAnimInstanceProxy::PoseTimeOffset' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, bLookingAtTarget) == 0x00065C, "Member 'FOrionMinionAnimInstanceProxy::bLookingAtTarget' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, bPreventAiming) == 0x00065D, "Member 'FOrionMinionAnimInstanceProxy::bPreventAiming' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, TargetLocation) == 0x000660, "Member 'FOrionMinionAnimInstanceProxy::TargetLocation' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, bIsTargetingPlayer) == 0x00066C, "Member 'FOrionMinionAnimInstanceProxy::bIsTargetingPlayer' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, bIsTargetingTower) == 0x00066D, "Member 'FOrionMinionAnimInstanceProxy::bIsTargetingTower' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, bIsTargetingTowerAndNotMoving) == 0x00066E, "Member 'FOrionMinionAnimInstanceProxy::bIsTargetingTowerAndNotMoving' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, AimDirInterpolator) == 0x000670, "Member 'FOrionMinionAnimInstanceProxy::AimDirInterpolator' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, FloorNormalInterpolator) == 0x0006AC, "Member 'FOrionMinionAnimInstanceProxy::FloorNormalInterpolator' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, CompSpaceDesiredAimDir) == 0x0006E8, "Member 'FOrionMinionAnimInstanceProxy::CompSpaceDesiredAimDir' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, CompSpaceAimDir) == 0x0006F4, "Member 'FOrionMinionAnimInstanceProxy::CompSpaceAimDir' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, DefaultForwardAxisVector) == 0x000700, "Member 'FOrionMinionAnimInstanceProxy::DefaultForwardAxisVector' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, LookAtTarget) == 0x00070C, "Member 'FOrionMinionAnimInstanceProxy::LookAtTarget' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, PoseIndex) == 0x000718, "Member 'FOrionMinionAnimInstanceProxy::PoseIndex' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, UniqueMinionID) == 0x00071C, "Member 'FOrionMinionAnimInstanceProxy::UniqueMinionID' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, SplitBodyBone) == 0x000720, "Member 'FOrionMinionAnimInstanceProxy::SplitBodyBone' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, bAllowedToRagdoll) == 0x000738, "Member 'FOrionMinionAnimInstanceProxy::bAllowedToRagdoll' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, RagdollAlpha) == 0x00073C, "Member 'FOrionMinionAnimInstanceProxy::RagdollAlpha' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, bPlayingDeathAnim) == 0x000740, "Member 'FOrionMinionAnimInstanceProxy::bPlayingDeathAnim' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, DeathAnimRagdollTriggerTime) == 0x000744, "Member 'FOrionMinionAnimInstanceProxy::DeathAnimRagdollTriggerTime' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, DeathAnimPlaybackTime) == 0x000748, "Member 'FOrionMinionAnimInstanceProxy::DeathAnimPlaybackTime' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, LastFrameDeltaSeconds) == 0x00074C, "Member 'FOrionMinionAnimInstanceProxy::LastFrameDeltaSeconds' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, DeathAnimFrameCount) == 0x000750, "Member 'FOrionMinionAnimInstanceProxy::DeathAnimFrameCount' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, DeathAnimIndex) == 0x000754, "Member 'FOrionMinionAnimInstanceProxy::DeathAnimIndex' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, bIsInCombat) == 0x000758, "Member 'FOrionMinionAnimInstanceProxy::bIsInCombat' has a wrong offset!");
static_assert(offsetof(FOrionMinionAnimInstanceProxy, LastHitVulnerableAlpha) == 0x00075C, "Member 'FOrionMinionAnimInstanceProxy::LastHitVulnerableAlpha' has a wrong offset!");

// ScriptStruct OrionGame.AIWaveBeingSpawned
// 0x0050 (0x0050 - 0x0000)
struct FAIWaveBeingSpawned final
{
public:
	class UOrionAIFormation*                      FormationBeingSpawned;                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UOrionAIData*>                   AIWaitingToSpawn;                                  // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AOrionCharAI>            LastSpawnedAI;                                     // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AIIndexToSpawn;                                    // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x2C];                                      // 0x0024(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIWaveBeingSpawned) == 0x000008, "Wrong alignment on FAIWaveBeingSpawned");
static_assert(sizeof(FAIWaveBeingSpawned) == 0x000050, "Wrong size on FAIWaveBeingSpawned");
static_assert(offsetof(FAIWaveBeingSpawned, FormationBeingSpawned) == 0x000000, "Member 'FAIWaveBeingSpawned::FormationBeingSpawned' has a wrong offset!");
static_assert(offsetof(FAIWaveBeingSpawned, AIWaitingToSpawn) == 0x000008, "Member 'FAIWaveBeingSpawned::AIWaitingToSpawn' has a wrong offset!");
static_assert(offsetof(FAIWaveBeingSpawned, LastSpawnedAI) == 0x000018, "Member 'FAIWaveBeingSpawned::LastSpawnedAI' has a wrong offset!");
static_assert(offsetof(FAIWaveBeingSpawned, AIIndexToSpawn) == 0x000020, "Member 'FAIWaveBeingSpawned::AIIndexToSpawn' has a wrong offset!");

// ScriptStruct OrionGame.SkinChoices
// 0x0018 (0x0018 - 0x0000)
struct FSkinChoices final
{
public:
	class UOrionSkinItemDefinition*               CurrentSkin;                                       // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionSkinVariationItemDefinition*      CurrentSkinVariation;                              // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionMcpCrownItemDefinition*           CurrentCrown;                                      // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkinChoices) == 0x000008, "Wrong alignment on FSkinChoices");
static_assert(sizeof(FSkinChoices) == 0x000018, "Wrong size on FSkinChoices");
static_assert(offsetof(FSkinChoices, CurrentSkin) == 0x000000, "Member 'FSkinChoices::CurrentSkin' has a wrong offset!");
static_assert(offsetof(FSkinChoices, CurrentSkinVariation) == 0x000008, "Member 'FSkinChoices::CurrentSkinVariation' has a wrong offset!");
static_assert(offsetof(FSkinChoices, CurrentCrown) == 0x000010, "Member 'FSkinChoices::CurrentCrown' has a wrong offset!");

// ScriptStruct OrionGame.MatchInfo
// 0x0018 (0x0018 - 0x0000)
struct FMatchInfo final
{
public:
	class FString                                 SessionId;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RedScore;                                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MatchLengthSeconds;                                // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchInfo) == 0x000008, "Wrong alignment on FMatchInfo");
static_assert(sizeof(FMatchInfo) == 0x000018, "Wrong size on FMatchInfo");
static_assert(offsetof(FMatchInfo, SessionId) == 0x000000, "Member 'FMatchInfo::SessionId' has a wrong offset!");
static_assert(offsetof(FMatchInfo, RedScore) == 0x000010, "Member 'FMatchInfo::RedScore' has a wrong offset!");
static_assert(offsetof(FMatchInfo, MatchLengthSeconds) == 0x000014, "Member 'FMatchInfo::MatchLengthSeconds' has a wrong offset!");

// ScriptStruct OrionGame.TeamInfo
// 0x0018 (0x0018 - 0x0000)
struct FTeamInfo final
{
public:
	TArray<struct FTeamMemberInfo>                Members;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         SocialPartySize;                                   // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTeamInfo) == 0x000008, "Wrong alignment on FTeamInfo");
static_assert(sizeof(FTeamInfo) == 0x000018, "Wrong size on FTeamInfo");
static_assert(offsetof(FTeamInfo, Members) == 0x000000, "Member 'FTeamInfo::Members' has a wrong offset!");
static_assert(offsetof(FTeamInfo, SocialPartySize) == 0x000010, "Member 'FTeamInfo::SocialPartySize' has a wrong offset!");

// ScriptStruct OrionGame.MatchResult
// 0x0088 (0x0088 - 0x0000)
struct FMatchResult final
{
public:
	class FString                                 RegionId;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlaylistId;                                        // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlaylistName;                                      // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCustomGame;                                     // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RatingType;                                        // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMatchInfo                             MatchInfo;                                         // 0x0040(0x0018)(NativeAccessSpecifierPublic)
	struct FTeamInfo                              RedTeam;                                           // 0x0058(0x0018)(NativeAccessSpecifierPublic)
	struct FTeamInfo                              BlueTeam;                                          // 0x0070(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchResult) == 0x000008, "Wrong alignment on FMatchResult");
static_assert(sizeof(FMatchResult) == 0x000088, "Wrong size on FMatchResult");
static_assert(offsetof(FMatchResult, RegionId) == 0x000000, "Member 'FMatchResult::RegionId' has a wrong offset!");
static_assert(offsetof(FMatchResult, PlaylistId) == 0x000010, "Member 'FMatchResult::PlaylistId' has a wrong offset!");
static_assert(offsetof(FMatchResult, PlaylistName) == 0x000018, "Member 'FMatchResult::PlaylistName' has a wrong offset!");
static_assert(offsetof(FMatchResult, bIsCustomGame) == 0x000028, "Member 'FMatchResult::bIsCustomGame' has a wrong offset!");
static_assert(offsetof(FMatchResult, RatingType) == 0x000030, "Member 'FMatchResult::RatingType' has a wrong offset!");
static_assert(offsetof(FMatchResult, MatchInfo) == 0x000040, "Member 'FMatchResult::MatchInfo' has a wrong offset!");
static_assert(offsetof(FMatchResult, RedTeam) == 0x000058, "Member 'FMatchResult::RedTeam' has a wrong offset!");
static_assert(offsetof(FMatchResult, BlueTeam) == 0x000070, "Member 'FMatchResult::BlueTeam' has a wrong offset!");

// ScriptStruct OrionGame.RecordedIntervalsData
// 0x0024 (0x0024 - 0x0000)
struct FRecordedIntervalsData final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Pos;                                               // 0x0004(0x000C)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rot;                                               // 0x0010(0x000C)(BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Health;                                            // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Energy;                                            // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRecordedIntervalsData) == 0x000004, "Wrong alignment on FRecordedIntervalsData");
static_assert(sizeof(FRecordedIntervalsData) == 0x000024, "Wrong size on FRecordedIntervalsData");
static_assert(offsetof(FRecordedIntervalsData, Time) == 0x000000, "Member 'FRecordedIntervalsData::Time' has a wrong offset!");
static_assert(offsetof(FRecordedIntervalsData, Pos) == 0x000004, "Member 'FRecordedIntervalsData::Pos' has a wrong offset!");
static_assert(offsetof(FRecordedIntervalsData, Rot) == 0x000010, "Member 'FRecordedIntervalsData::Rot' has a wrong offset!");
static_assert(offsetof(FRecordedIntervalsData, Health) == 0x00001C, "Member 'FRecordedIntervalsData::Health' has a wrong offset!");
static_assert(offsetof(FRecordedIntervalsData, Energy) == 0x000020, "Member 'FRecordedIntervalsData::Energy' has a wrong offset!");

// ScriptStruct OrionGame.OrionReplicatedAcceleration
// 0x0002 (0x0002 - 0x0000)
struct FOrionReplicatedAcceleration final
{
public:
	uint8                                         AccelAngle;                                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AccelMagnitude;                                    // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionReplicatedAcceleration) == 0x000001, "Wrong alignment on FOrionReplicatedAcceleration");
static_assert(sizeof(FOrionReplicatedAcceleration) == 0x000002, "Wrong size on FOrionReplicatedAcceleration");
static_assert(offsetof(FOrionReplicatedAcceleration, AccelAngle) == 0x000000, "Member 'FOrionReplicatedAcceleration::AccelAngle' has a wrong offset!");
static_assert(offsetof(FOrionReplicatedAcceleration, AccelMagnitude) == 0x000001, "Member 'FOrionReplicatedAcceleration::AccelMagnitude' has a wrong offset!");

// ScriptStruct OrionGame.Orion2DReticle
// 0x0018 (0x0018 - 0x0000)
struct FOrion2DReticle final
{
public:
	class UMaterialInstanceDynamic*               Material;                                          // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ScreenSize;                                        // 0x0008(0x0008)(BlueprintVisible, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ScreenOffset;                                      // 0x0010(0x0008)(BlueprintVisible, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrion2DReticle) == 0x000008, "Wrong alignment on FOrion2DReticle");
static_assert(sizeof(FOrion2DReticle) == 0x000018, "Wrong size on FOrion2DReticle");
static_assert(offsetof(FOrion2DReticle, Material) == 0x000000, "Member 'FOrion2DReticle::Material' has a wrong offset!");
static_assert(offsetof(FOrion2DReticle, ScreenSize) == 0x000008, "Member 'FOrion2DReticle::ScreenSize' has a wrong offset!");
static_assert(offsetof(FOrion2DReticle, ScreenOffset) == 0x000010, "Member 'FOrion2DReticle::ScreenOffset' has a wrong offset!");

// ScriptStruct OrionGame.Orion2DReticleSourceData
// 0x0018 (0x0018 - 0x0000)
struct FOrion2DReticleSourceData final
{
public:
	class UMaterialInterface*                     Material;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ScreenSize;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ScreenOffset;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrion2DReticleSourceData) == 0x000008, "Wrong alignment on FOrion2DReticleSourceData");
static_assert(sizeof(FOrion2DReticleSourceData) == 0x000018, "Wrong size on FOrion2DReticleSourceData");
static_assert(offsetof(FOrion2DReticleSourceData, Material) == 0x000000, "Member 'FOrion2DReticleSourceData::Material' has a wrong offset!");
static_assert(offsetof(FOrion2DReticleSourceData, ScreenSize) == 0x000008, "Member 'FOrion2DReticleSourceData::ScreenSize' has a wrong offset!");
static_assert(offsetof(FOrion2DReticleSourceData, ScreenOffset) == 0x000010, "Member 'FOrion2DReticleSourceData::ScreenOffset' has a wrong offset!");

// ScriptStruct OrionGame.OrionMasteryLevel
// 0x0020 (0x0020 - 0x0000)
struct FOrionMasteryLevel final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOrionItemQuantity>             Rewards;                                           // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         RequiredXP;                                        // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionMasteryLevel) == 0x000008, "Wrong alignment on FOrionMasteryLevel");
static_assert(sizeof(FOrionMasteryLevel) == 0x000020, "Wrong size on FOrionMasteryLevel");
static_assert(offsetof(FOrionMasteryLevel, Level) == 0x000000, "Member 'FOrionMasteryLevel::Level' has a wrong offset!");
static_assert(offsetof(FOrionMasteryLevel, Rewards) == 0x000008, "Member 'FOrionMasteryLevel::Rewards' has a wrong offset!");
static_assert(offsetof(FOrionMasteryLevel, RequiredXP) == 0x000018, "Member 'FOrionMasteryLevel::RequiredXP' has a wrong offset!");

// ScriptStruct OrionGame.PickupLaunchInfo
// 0x0050 (0x0050 - 0x0000)
struct FPickupLaunchInfo final
{
public:
	TSubclassOf<class AOrionPickup>               PickupClass;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PickupClassIndex;                                  // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        UniquePickupID;                                    // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 HomingActor;                                       // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHoming : 1;                                       // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LaunchLocation;                                    // 0x0024(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DropLocation;                                      // 0x0030(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TestLocation;                                      // 0x003C(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewExpireTime;                                     // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchTime;                                        // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPickupLaunchInfo) == 0x000008, "Wrong alignment on FPickupLaunchInfo");
static_assert(sizeof(FPickupLaunchInfo) == 0x000050, "Wrong size on FPickupLaunchInfo");
static_assert(offsetof(FPickupLaunchInfo, PickupClass) == 0x000000, "Member 'FPickupLaunchInfo::PickupClass' has a wrong offset!");
static_assert(offsetof(FPickupLaunchInfo, PickupClassIndex) == 0x000008, "Member 'FPickupLaunchInfo::PickupClassIndex' has a wrong offset!");
static_assert(offsetof(FPickupLaunchInfo, UniquePickupID) == 0x000010, "Member 'FPickupLaunchInfo::UniquePickupID' has a wrong offset!");
static_assert(offsetof(FPickupLaunchInfo, HomingActor) == 0x000018, "Member 'FPickupLaunchInfo::HomingActor' has a wrong offset!");
static_assert(offsetof(FPickupLaunchInfo, LaunchLocation) == 0x000024, "Member 'FPickupLaunchInfo::LaunchLocation' has a wrong offset!");
static_assert(offsetof(FPickupLaunchInfo, DropLocation) == 0x000030, "Member 'FPickupLaunchInfo::DropLocation' has a wrong offset!");
static_assert(offsetof(FPickupLaunchInfo, TestLocation) == 0x00003C, "Member 'FPickupLaunchInfo::TestLocation' has a wrong offset!");
static_assert(offsetof(FPickupLaunchInfo, NewExpireTime) == 0x000048, "Member 'FPickupLaunchInfo::NewExpireTime' has a wrong offset!");
static_assert(offsetof(FPickupLaunchInfo, LaunchTime) == 0x00004C, "Member 'FPickupLaunchInfo::LaunchTime' has a wrong offset!");

// ScriptStruct OrionGame.RecentMovementSyncKeysEntry
// 0x0014 (0x0014 - 0x0000)
struct FRecentMovementSyncKeysEntry final
{
public:
	struct FMovementAbilitySyncKey                SyncKey;                                           // 0x0000(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ExpirationTime;                                    // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasServerMoveBeenProcessedWithMatchingKey;        // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRecentMovementSyncKeysEntry) == 0x000004, "Wrong alignment on FRecentMovementSyncKeysEntry");
static_assert(sizeof(FRecentMovementSyncKeysEntry) == 0x000014, "Wrong size on FRecentMovementSyncKeysEntry");
static_assert(offsetof(FRecentMovementSyncKeysEntry, SyncKey) == 0x000000, "Member 'FRecentMovementSyncKeysEntry::SyncKey' has a wrong offset!");
static_assert(offsetof(FRecentMovementSyncKeysEntry, ExpirationTime) == 0x00000C, "Member 'FRecentMovementSyncKeysEntry::ExpirationTime' has a wrong offset!");
static_assert(offsetof(FRecentMovementSyncKeysEntry, bHasServerMoveBeenProcessedWithMatchingKey) == 0x000010, "Member 'FRecentMovementSyncKeysEntry::bHasServerMoveBeenProcessedWithMatchingKey' has a wrong offset!");

// ScriptStruct OrionGame.RewardSourceLoc
// 0x0018 (0x0020 - 0x0008)
struct FRewardSourceLoc final : public FTableRowBase
{
public:
	class FText                                   Description;                                       // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRewardSourceLoc) == 0x000008, "Wrong alignment on FRewardSourceLoc");
static_assert(sizeof(FRewardSourceLoc) == 0x000020, "Wrong size on FRewardSourceLoc");
static_assert(offsetof(FRewardSourceLoc, Description) == 0x000008, "Member 'FRewardSourceLoc::Description' has a wrong offset!");

// ScriptStruct OrionGame.CuratedGemData
// 0x0020 (0x0020 - 0x0000)
struct FCuratedGemData final
{
public:
	class UOrionMcpGemItemDefinition*             GemDefinition;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GemLevel;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSimpleAbilityKeywordTag>       ExplicitSimpleAbilityKeywords;                     // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCuratedGemData) == 0x000008, "Wrong alignment on FCuratedGemData");
static_assert(sizeof(FCuratedGemData) == 0x000020, "Wrong size on FCuratedGemData");
static_assert(offsetof(FCuratedGemData, GemDefinition) == 0x000000, "Member 'FCuratedGemData::GemDefinition' has a wrong offset!");
static_assert(offsetof(FCuratedGemData, GemLevel) == 0x000008, "Member 'FCuratedGemData::GemLevel' has a wrong offset!");
static_assert(offsetof(FCuratedGemData, ExplicitSimpleAbilityKeywords) == 0x000010, "Member 'FCuratedGemData::ExplicitSimpleAbilityKeywords' has a wrong offset!");

// ScriptStruct OrionGame.OrionChaseCameraHelper
// 0x0120 (0x0120 - 0x0000)
struct FOrionChaseCameraHelper final
{
public:
	struct FTransform                             PivotToViewTarget;                                 // 0x0000(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             MinCameraToPivot;                                  // 0x0030(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             MaxCameraToPivot;                                  // 0x0060(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraToPivotAlphaInterpSpeed;                     // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraCollisionSphereRadius;                       // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PivotLocationInterpSpeed;                          // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PivotRotationInterpSpeed;                          // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAutoFollow : 1;                                   // 0x00A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLazyAutoFollow : 1;                               // 0x00A8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraTruckRate;                                   // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoFollowPitch;                                   // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LazyAutoFollowPitchMin;                            // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LazyAutoFollowPitchMax;                            // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x64];                                      // 0x00BC(0x0064)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionChaseCameraHelper) == 0x000010, "Wrong alignment on FOrionChaseCameraHelper");
static_assert(sizeof(FOrionChaseCameraHelper) == 0x000120, "Wrong size on FOrionChaseCameraHelper");
static_assert(offsetof(FOrionChaseCameraHelper, PivotToViewTarget) == 0x000000, "Member 'FOrionChaseCameraHelper::PivotToViewTarget' has a wrong offset!");
static_assert(offsetof(FOrionChaseCameraHelper, MinCameraToPivot) == 0x000030, "Member 'FOrionChaseCameraHelper::MinCameraToPivot' has a wrong offset!");
static_assert(offsetof(FOrionChaseCameraHelper, MaxCameraToPivot) == 0x000060, "Member 'FOrionChaseCameraHelper::MaxCameraToPivot' has a wrong offset!");
static_assert(offsetof(FOrionChaseCameraHelper, CameraToPivotAlphaInterpSpeed) == 0x000098, "Member 'FOrionChaseCameraHelper::CameraToPivotAlphaInterpSpeed' has a wrong offset!");
static_assert(offsetof(FOrionChaseCameraHelper, CameraCollisionSphereRadius) == 0x00009C, "Member 'FOrionChaseCameraHelper::CameraCollisionSphereRadius' has a wrong offset!");
static_assert(offsetof(FOrionChaseCameraHelper, PivotLocationInterpSpeed) == 0x0000A0, "Member 'FOrionChaseCameraHelper::PivotLocationInterpSpeed' has a wrong offset!");
static_assert(offsetof(FOrionChaseCameraHelper, PivotRotationInterpSpeed) == 0x0000A4, "Member 'FOrionChaseCameraHelper::PivotRotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(FOrionChaseCameraHelper, CameraTruckRate) == 0x0000AC, "Member 'FOrionChaseCameraHelper::CameraTruckRate' has a wrong offset!");
static_assert(offsetof(FOrionChaseCameraHelper, AutoFollowPitch) == 0x0000B0, "Member 'FOrionChaseCameraHelper::AutoFollowPitch' has a wrong offset!");
static_assert(offsetof(FOrionChaseCameraHelper, LazyAutoFollowPitchMin) == 0x0000B4, "Member 'FOrionChaseCameraHelper::LazyAutoFollowPitchMin' has a wrong offset!");
static_assert(offsetof(FOrionChaseCameraHelper, LazyAutoFollowPitchMax) == 0x0000B8, "Member 'FOrionChaseCameraHelper::LazyAutoFollowPitchMax' has a wrong offset!");

// ScriptStruct OrionGame.GameplayStatTag
// 0x0008 (0x0010 - 0x0008)
struct FGameplayStatTag final : public FGameplayTag
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0008(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FGameplayStatTag) == 0x000008, "Wrong alignment on FGameplayStatTag");
static_assert(sizeof(FGameplayStatTag) == 0x000010, "Wrong size on FGameplayStatTag");
static_assert(offsetof(FGameplayStatTag, Tag) == 0x000008, "Member 'FGameplayStatTag::Tag' has a wrong offset!");

// ScriptStruct OrionGame.PlayerStat
// 0x0024 (0x0030 - 0x000C)
struct FPlayerStat final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayStatTag                       Stat;                                              // 0x0010(0x0010)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ValueArray[0x3];                                   // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerStat) == 0x000008, "Wrong alignment on FPlayerStat");
static_assert(sizeof(FPlayerStat) == 0x000030, "Wrong size on FPlayerStat");
static_assert(offsetof(FPlayerStat, Stat) == 0x000010, "Member 'FPlayerStat::Stat' has a wrong offset!");
static_assert(offsetof(FPlayerStat, ValueArray) == 0x000020, "Member 'FPlayerStat::ValueArray' has a wrong offset!");

// ScriptStruct OrionGame.OrionTBWaitTimes
// 0x0030 (0x0030 - 0x0000)
struct FOrionTBWaitTimes final
{
public:
	struct FTimespan                              StartSoloRiderTime;                                // 0x0000(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        SoloRiderDuration;                                 // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              StartTeammateSearchTime;                           // 0x0010(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        TeammateSearchDuration;                            // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              StartEnemySearchTime;                              // 0x0020(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        EnemySearchDuration;                               // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionTBWaitTimes) == 0x000008, "Wrong alignment on FOrionTBWaitTimes");
static_assert(sizeof(FOrionTBWaitTimes) == 0x000030, "Wrong size on FOrionTBWaitTimes");
static_assert(offsetof(FOrionTBWaitTimes, StartSoloRiderTime) == 0x000000, "Member 'FOrionTBWaitTimes::StartSoloRiderTime' has a wrong offset!");
static_assert(offsetof(FOrionTBWaitTimes, SoloRiderDuration) == 0x000008, "Member 'FOrionTBWaitTimes::SoloRiderDuration' has a wrong offset!");
static_assert(offsetof(FOrionTBWaitTimes, StartTeammateSearchTime) == 0x000010, "Member 'FOrionTBWaitTimes::StartTeammateSearchTime' has a wrong offset!");
static_assert(offsetof(FOrionTBWaitTimes, TeammateSearchDuration) == 0x000018, "Member 'FOrionTBWaitTimes::TeammateSearchDuration' has a wrong offset!");
static_assert(offsetof(FOrionTBWaitTimes, StartEnemySearchTime) == 0x000020, "Member 'FOrionTBWaitTimes::StartEnemySearchTime' has a wrong offset!");
static_assert(offsetof(FOrionTBWaitTimes, EnemySearchDuration) == 0x000028, "Member 'FOrionTBWaitTimes::EnemySearchDuration' has a wrong offset!");

// ScriptStruct OrionGame.OrionCoreBaseAnimInstanceProxy
// 0x0030 (0x0510 - 0x04E0)
struct FOrionCoreBaseAnimInstanceProxy final : public FAnimInstanceProxy
{
public:
	float                                         RotationRate0;                                     // 0x04D8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationRate1;                                     // 0x04DC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationRate2;                                     // 0x04E0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation0;                                         // 0x04E4(0x000C)(BlueprintVisible, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation1;                                         // 0x04F0(0x000C)(BlueprintVisible, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation2;                                         // 0x04FC(0x000C)(BlueprintVisible, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_508[0x8];                                      // 0x0508(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionCoreBaseAnimInstanceProxy) == 0x000010, "Wrong alignment on FOrionCoreBaseAnimInstanceProxy");
static_assert(sizeof(FOrionCoreBaseAnimInstanceProxy) == 0x000510, "Wrong size on FOrionCoreBaseAnimInstanceProxy");
static_assert(offsetof(FOrionCoreBaseAnimInstanceProxy, RotationRate0) == 0x0004D8, "Member 'FOrionCoreBaseAnimInstanceProxy::RotationRate0' has a wrong offset!");
static_assert(offsetof(FOrionCoreBaseAnimInstanceProxy, RotationRate1) == 0x0004DC, "Member 'FOrionCoreBaseAnimInstanceProxy::RotationRate1' has a wrong offset!");
static_assert(offsetof(FOrionCoreBaseAnimInstanceProxy, RotationRate2) == 0x0004E0, "Member 'FOrionCoreBaseAnimInstanceProxy::RotationRate2' has a wrong offset!");
static_assert(offsetof(FOrionCoreBaseAnimInstanceProxy, Rotation0) == 0x0004E4, "Member 'FOrionCoreBaseAnimInstanceProxy::Rotation0' has a wrong offset!");
static_assert(offsetof(FOrionCoreBaseAnimInstanceProxy, Rotation1) == 0x0004F0, "Member 'FOrionCoreBaseAnimInstanceProxy::Rotation1' has a wrong offset!");
static_assert(offsetof(FOrionCoreBaseAnimInstanceProxy, Rotation2) == 0x0004FC, "Member 'FOrionCoreBaseAnimInstanceProxy::Rotation2' has a wrong offset!");

// ScriptStruct OrionGame.OrionAnalogCursorSettings
// 0x0038 (0x0038 - 0x0000)
struct FOrionAnalogCursorSettings final
{
public:
	class UCurveFloat*                            InputCurve;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ScrollCurve;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultSpeed;                                      // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinHoverWidgetSize;                                // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHoverWidgetSize;                                // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinHoverSpeedScale;                                // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHoverSpeedScale;                                // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverSpeedScaleDecayRate;                          // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeadZone;                                          // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyAxisScaling;                                 // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayDebug;                                     // 0x0031(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionAnalogCursorSettings) == 0x000008, "Wrong alignment on FOrionAnalogCursorSettings");
static_assert(sizeof(FOrionAnalogCursorSettings) == 0x000038, "Wrong size on FOrionAnalogCursorSettings");
static_assert(offsetof(FOrionAnalogCursorSettings, InputCurve) == 0x000000, "Member 'FOrionAnalogCursorSettings::InputCurve' has a wrong offset!");
static_assert(offsetof(FOrionAnalogCursorSettings, ScrollCurve) == 0x000008, "Member 'FOrionAnalogCursorSettings::ScrollCurve' has a wrong offset!");
static_assert(offsetof(FOrionAnalogCursorSettings, DefaultSpeed) == 0x000010, "Member 'FOrionAnalogCursorSettings::DefaultSpeed' has a wrong offset!");
static_assert(offsetof(FOrionAnalogCursorSettings, MinHoverWidgetSize) == 0x000014, "Member 'FOrionAnalogCursorSettings::MinHoverWidgetSize' has a wrong offset!");
static_assert(offsetof(FOrionAnalogCursorSettings, MaxHoverWidgetSize) == 0x000018, "Member 'FOrionAnalogCursorSettings::MaxHoverWidgetSize' has a wrong offset!");
static_assert(offsetof(FOrionAnalogCursorSettings, MinHoverSpeedScale) == 0x00001C, "Member 'FOrionAnalogCursorSettings::MinHoverSpeedScale' has a wrong offset!");
static_assert(offsetof(FOrionAnalogCursorSettings, MaxHoverSpeedScale) == 0x000020, "Member 'FOrionAnalogCursorSettings::MaxHoverSpeedScale' has a wrong offset!");
static_assert(offsetof(FOrionAnalogCursorSettings, HoverSpeedScaleDecayRate) == 0x000024, "Member 'FOrionAnalogCursorSettings::HoverSpeedScaleDecayRate' has a wrong offset!");
static_assert(offsetof(FOrionAnalogCursorSettings, DeadZone) == 0x000028, "Member 'FOrionAnalogCursorSettings::DeadZone' has a wrong offset!");
static_assert(offsetof(FOrionAnalogCursorSettings, Radius) == 0x00002C, "Member 'FOrionAnalogCursorSettings::Radius' has a wrong offset!");
static_assert(offsetof(FOrionAnalogCursorSettings, bApplyAxisScaling) == 0x000030, "Member 'FOrionAnalogCursorSettings::bApplyAxisScaling' has a wrong offset!");
static_assert(offsetof(FOrionAnalogCursorSettings, bDisplayDebug) == 0x000031, "Member 'FOrionAnalogCursorSettings::bDisplayDebug' has a wrong offset!");

// ScriptStruct OrionGame.OrionObjectiveCues
// 0x0038 (0x0038 - 0x0000)
struct FOrionObjectiveCues final
{
public:
	struct FGameplayCueTag                        Idle;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        TargetLocked;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        TargetAcquired;                                    // 0x0010(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        NoLongerHasTargets;                                // 0x0018(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        Recharge;                                          // 0x0020(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        Destroyed;                                         // 0x0028(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        ReviveFinished;                                    // 0x0030(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionObjectiveCues) == 0x000008, "Wrong alignment on FOrionObjectiveCues");
static_assert(sizeof(FOrionObjectiveCues) == 0x000038, "Wrong size on FOrionObjectiveCues");
static_assert(offsetof(FOrionObjectiveCues, Idle) == 0x000000, "Member 'FOrionObjectiveCues::Idle' has a wrong offset!");
static_assert(offsetof(FOrionObjectiveCues, TargetLocked) == 0x000008, "Member 'FOrionObjectiveCues::TargetLocked' has a wrong offset!");
static_assert(offsetof(FOrionObjectiveCues, TargetAcquired) == 0x000010, "Member 'FOrionObjectiveCues::TargetAcquired' has a wrong offset!");
static_assert(offsetof(FOrionObjectiveCues, NoLongerHasTargets) == 0x000018, "Member 'FOrionObjectiveCues::NoLongerHasTargets' has a wrong offset!");
static_assert(offsetof(FOrionObjectiveCues, Recharge) == 0x000020, "Member 'FOrionObjectiveCues::Recharge' has a wrong offset!");
static_assert(offsetof(FOrionObjectiveCues, Destroyed) == 0x000028, "Member 'FOrionObjectiveCues::Destroyed' has a wrong offset!");
static_assert(offsetof(FOrionObjectiveCues, ReviveFinished) == 0x000030, "Member 'FOrionObjectiveCues::ReviveFinished' has a wrong offset!");

// ScriptStruct OrionGame.UpdateTeamBuilderPathStatsParams
// 0x0018 (0x0018 - 0x0000)
struct FUpdateTeamBuilderPathStatsParams final
{
public:
	class FString                                 BucketId;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SocialPartySize;                                   // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUpdateTeamBuilderPathStatsParams) == 0x000008, "Wrong alignment on FUpdateTeamBuilderPathStatsParams");
static_assert(sizeof(FUpdateTeamBuilderPathStatsParams) == 0x000018, "Wrong size on FUpdateTeamBuilderPathStatsParams");
static_assert(offsetof(FUpdateTeamBuilderPathStatsParams, BucketId) == 0x000000, "Member 'FUpdateTeamBuilderPathStatsParams::BucketId' has a wrong offset!");
static_assert(offsetof(FUpdateTeamBuilderPathStatsParams, Count) == 0x000010, "Member 'FUpdateTeamBuilderPathStatsParams::Count' has a wrong offset!");
static_assert(offsetof(FUpdateTeamBuilderPathStatsParams, SocialPartySize) == 0x000014, "Member 'FUpdateTeamBuilderPathStatsParams::SocialPartySize' has a wrong offset!");

// ScriptStruct OrionGame.OrionAutoRemovedDecal
// 0x0018 (0x0018 - 0x0000)
struct FOrionAutoRemovedDecal final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DecalName;                                         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToRemove;                                      // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionAutoRemovedDecal) == 0x000008, "Wrong alignment on FOrionAutoRemovedDecal");
static_assert(sizeof(FOrionAutoRemovedDecal) == 0x000018, "Wrong size on FOrionAutoRemovedDecal");
static_assert(offsetof(FOrionAutoRemovedDecal, TargetActor) == 0x000000, "Member 'FOrionAutoRemovedDecal::TargetActor' has a wrong offset!");
static_assert(offsetof(FOrionAutoRemovedDecal, DecalName) == 0x000008, "Member 'FOrionAutoRemovedDecal::DecalName' has a wrong offset!");
static_assert(offsetof(FOrionAutoRemovedDecal, Duration) == 0x000010, "Member 'FOrionAutoRemovedDecal::Duration' has a wrong offset!");
static_assert(offsetof(FOrionAutoRemovedDecal, TimeToRemove) == 0x000014, "Member 'FOrionAutoRemovedDecal::TimeToRemove' has a wrong offset!");

// ScriptStruct OrionGame.OrionDecal
// 0x0028 (0x0028 - 0x0000)
struct FOrionDecal final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionDecalComponent*                   DecalComponent;                                    // 0x0018(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionDecal) == 0x000008, "Wrong alignment on FOrionDecal");
static_assert(sizeof(FOrionDecal) == 0x000028, "Wrong size on FOrionDecal");
static_assert(offsetof(FOrionDecal, DecalComponent) == 0x000018, "Member 'FOrionDecal::DecalComponent' has a wrong offset!");

// ScriptStruct OrionGame.OrionDecalTarget
// 0x0028 (0x0028 - 0x0000)
struct FOrionDecalTarget final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor;                                       // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOrionDecal>                    Decals;                                            // 0x0018(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionDecalTarget) == 0x000008, "Wrong alignment on FOrionDecalTarget");
static_assert(sizeof(FOrionDecalTarget) == 0x000028, "Wrong size on FOrionDecalTarget");
static_assert(offsetof(FOrionDecalTarget, TargetActor) == 0x000010, "Member 'FOrionDecalTarget::TargetActor' has a wrong offset!");
static_assert(offsetof(FOrionDecalTarget, Decals) == 0x000018, "Member 'FOrionDecalTarget::Decals' has a wrong offset!");

// ScriptStruct OrionGame.SimpleAchievementDescription
// 0x0020 (0x0020 - 0x0000)
struct FSimpleAchievementDescription final
{
public:
	EOrionSimpleAchievementType                   Key;                                               // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Description;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSimpleAchievementDescription) == 0x000008, "Wrong alignment on FSimpleAchievementDescription");
static_assert(sizeof(FSimpleAchievementDescription) == 0x000020, "Wrong size on FSimpleAchievementDescription");
static_assert(offsetof(FSimpleAchievementDescription, Key) == 0x000000, "Member 'FSimpleAchievementDescription::Key' has a wrong offset!");
static_assert(offsetof(FSimpleAchievementDescription, Description) == 0x000008, "Member 'FSimpleAchievementDescription::Description' has a wrong offset!");

// ScriptStruct OrionGame.SkinSkeletalAttachment
// 0x0060 (0x0090 - 0x0030)
struct FSkinSkeletalAttachment final : public FSkinAttachmentBase
{
public:
	TSoftObjectPtr<class USkeletalMesh>           SkeletalMesh;                                      // 0x0030(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   CustomAnimInstance;                                // 0x0058(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          LoadedMesh;                                        // 0x0080(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAnimInstance>              LoadedAnimInstance;                                // 0x0088(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkinSkeletalAttachment) == 0x000008, "Wrong alignment on FSkinSkeletalAttachment");
static_assert(sizeof(FSkinSkeletalAttachment) == 0x000090, "Wrong size on FSkinSkeletalAttachment");
static_assert(offsetof(FSkinSkeletalAttachment, SkeletalMesh) == 0x000030, "Member 'FSkinSkeletalAttachment::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(FSkinSkeletalAttachment, CustomAnimInstance) == 0x000058, "Member 'FSkinSkeletalAttachment::CustomAnimInstance' has a wrong offset!");
static_assert(offsetof(FSkinSkeletalAttachment, LoadedMesh) == 0x000080, "Member 'FSkinSkeletalAttachment::LoadedMesh' has a wrong offset!");
static_assert(offsetof(FSkinSkeletalAttachment, LoadedAnimInstance) == 0x000088, "Member 'FSkinSkeletalAttachment::LoadedAnimInstance' has a wrong offset!");

// ScriptStruct OrionGame.DraftLobbyPhase
// 0x0020 (0x0020 - 0x0000)
struct FDraftLobbyPhase final
{
public:
	int32                                         PhaseIdx;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    TeamIndex;                                         // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumBots;                                           // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUniqueNetIdRepl>               ChoosingPlayers;                                   // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDraftLobbyPhase) == 0x000008, "Wrong alignment on FDraftLobbyPhase");
static_assert(sizeof(FDraftLobbyPhase) == 0x000020, "Wrong size on FDraftLobbyPhase");
static_assert(offsetof(FDraftLobbyPhase, PhaseIdx) == 0x000000, "Member 'FDraftLobbyPhase::PhaseIdx' has a wrong offset!");
static_assert(offsetof(FDraftLobbyPhase, TeamIndex) == 0x000004, "Member 'FDraftLobbyPhase::TeamIndex' has a wrong offset!");
static_assert(offsetof(FDraftLobbyPhase, NumBots) == 0x000008, "Member 'FDraftLobbyPhase::NumBots' has a wrong offset!");
static_assert(offsetof(FDraftLobbyPhase, ChoosingPlayers) == 0x000010, "Member 'FDraftLobbyPhase::ChoosingPlayers' has a wrong offset!");

// ScriptStruct OrionGame.DraftStats_Player
// 0x0070 (0x0070 - 0x0000)
struct FDraftStats_Player final
{
public:
	struct FUniqueNetIdRepl                       UniqueId;                                          // 0x0000(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionPlayerPlatform                          Platform;                                          // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUniqueNetIdRepl                       PartyLeader;                                       // 0x0020(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamNum;                                           // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PickOrder;                                         // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBot;                                            // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MMR;                                               // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HeroChoice;                                        // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x10];                                      // 0x0058(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HeroChoiceDuration;                                // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHeroHardLock;                                     // 0x006C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDraftStats_Player) == 0x000008, "Wrong alignment on FDraftStats_Player");
static_assert(sizeof(FDraftStats_Player) == 0x000070, "Wrong size on FDraftStats_Player");
static_assert(offsetof(FDraftStats_Player, UniqueId) == 0x000000, "Member 'FDraftStats_Player::UniqueId' has a wrong offset!");
static_assert(offsetof(FDraftStats_Player, Platform) == 0x000018, "Member 'FDraftStats_Player::Platform' has a wrong offset!");
static_assert(offsetof(FDraftStats_Player, PartyLeader) == 0x000020, "Member 'FDraftStats_Player::PartyLeader' has a wrong offset!");
static_assert(offsetof(FDraftStats_Player, TeamNum) == 0x000038, "Member 'FDraftStats_Player::TeamNum' has a wrong offset!");
static_assert(offsetof(FDraftStats_Player, PickOrder) == 0x00003C, "Member 'FDraftStats_Player::PickOrder' has a wrong offset!");
static_assert(offsetof(FDraftStats_Player, bIsBot) == 0x000040, "Member 'FDraftStats_Player::bIsBot' has a wrong offset!");
static_assert(offsetof(FDraftStats_Player, MMR) == 0x000044, "Member 'FDraftStats_Player::MMR' has a wrong offset!");
static_assert(offsetof(FDraftStats_Player, HeroChoice) == 0x000048, "Member 'FDraftStats_Player::HeroChoice' has a wrong offset!");
static_assert(offsetof(FDraftStats_Player, HeroChoiceDuration) == 0x000068, "Member 'FDraftStats_Player::HeroChoiceDuration' has a wrong offset!");
static_assert(offsetof(FDraftStats_Player, bHeroHardLock) == 0x00006C, "Member 'FDraftStats_Player::bHeroHardLock' has a wrong offset!");

// ScriptStruct OrionGame.OrionDynamicWall_SegmentProperties
// 0x002C (0x002C - 0x0000)
struct FOrionDynamicWall_SegmentProperties final
{
public:
	float                                         BaseMinHeight;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseMaxHeight;                                     // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CapIndex;                                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 Location;                                          // 0x000C(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0018(0x000C)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bRotateCap;                                        // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AbilityLevel;                                      // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionDynamicWall_SegmentProperties) == 0x000004, "Wrong alignment on FOrionDynamicWall_SegmentProperties");
static_assert(sizeof(FOrionDynamicWall_SegmentProperties) == 0x00002C, "Wrong size on FOrionDynamicWall_SegmentProperties");
static_assert(offsetof(FOrionDynamicWall_SegmentProperties, BaseMinHeight) == 0x000000, "Member 'FOrionDynamicWall_SegmentProperties::BaseMinHeight' has a wrong offset!");
static_assert(offsetof(FOrionDynamicWall_SegmentProperties, BaseMaxHeight) == 0x000004, "Member 'FOrionDynamicWall_SegmentProperties::BaseMaxHeight' has a wrong offset!");
static_assert(offsetof(FOrionDynamicWall_SegmentProperties, CapIndex) == 0x000008, "Member 'FOrionDynamicWall_SegmentProperties::CapIndex' has a wrong offset!");
static_assert(offsetof(FOrionDynamicWall_SegmentProperties, Location) == 0x00000C, "Member 'FOrionDynamicWall_SegmentProperties::Location' has a wrong offset!");
static_assert(offsetof(FOrionDynamicWall_SegmentProperties, Rotation) == 0x000018, "Member 'FOrionDynamicWall_SegmentProperties::Rotation' has a wrong offset!");
static_assert(offsetof(FOrionDynamicWall_SegmentProperties, bRotateCap) == 0x000024, "Member 'FOrionDynamicWall_SegmentProperties::bRotateCap' has a wrong offset!");
static_assert(offsetof(FOrionDynamicWall_SegmentProperties, AbilityLevel) == 0x000028, "Member 'FOrionDynamicWall_SegmentProperties::AbilityLevel' has a wrong offset!");

// ScriptStruct OrionGame.OrionMessageAudio
// 0x0010 (0x0010 - 0x0000)
struct FOrionMessageAudio final
{
public:
	struct FGameplayCueTag                        AudioTag;                                          // 0x0000(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bOnlyPlayFirstTime;                                // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionMessageAudio) == 0x000008, "Wrong alignment on FOrionMessageAudio");
static_assert(sizeof(FOrionMessageAudio) == 0x000010, "Wrong size on FOrionMessageAudio");
static_assert(offsetof(FOrionMessageAudio, AudioTag) == 0x000000, "Member 'FOrionMessageAudio::AudioTag' has a wrong offset!");
static_assert(offsetof(FOrionMessageAudio, bOnlyPlayFirstTime) == 0x000008, "Member 'FOrionMessageAudio::bOnlyPlayFirstTime' has a wrong offset!");

// ScriptStruct OrionGame.OrionDynamicWall_CapDefinition
// 0x0018 (0x0018 - 0x0000)
struct FOrionDynamicWall_CapDefinition final
{
public:
	class UStaticMesh*                            CollisionMesh;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            VisualMesh;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Slope;                                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionDynamicWall_CapDefinition) == 0x000008, "Wrong alignment on FOrionDynamicWall_CapDefinition");
static_assert(sizeof(FOrionDynamicWall_CapDefinition) == 0x000018, "Wrong size on FOrionDynamicWall_CapDefinition");
static_assert(offsetof(FOrionDynamicWall_CapDefinition, CollisionMesh) == 0x000000, "Member 'FOrionDynamicWall_CapDefinition::CollisionMesh' has a wrong offset!");
static_assert(offsetof(FOrionDynamicWall_CapDefinition, VisualMesh) == 0x000008, "Member 'FOrionDynamicWall_CapDefinition::VisualMesh' has a wrong offset!");
static_assert(offsetof(FOrionDynamicWall_CapDefinition, Slope) == 0x000010, "Member 'FOrionDynamicWall_CapDefinition::Slope' has a wrong offset!");

// ScriptStruct OrionGame.OrionTBSlotState
// 0x0168 (0x0168 - 0x0000)
struct FOrionTBSlotState final
{
public:
	int32                                         SlotIdx;                                           // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionTBMemberInfo                     MemberInfo;                                        // 0x0008(0x0150)(BlueprintVisible, NativeAccessSpecifierPublic)
	class UOrionTeamBuilderPartyMember*           PartyMemberState;                                  // 0x0158(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsReserved;                                       // 0x0160(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPending;                                        // 0x0161(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCaptain;                                        // 0x0162(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_163[0x5];                                      // 0x0163(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionTBSlotState) == 0x000008, "Wrong alignment on FOrionTBSlotState");
static_assert(sizeof(FOrionTBSlotState) == 0x000168, "Wrong size on FOrionTBSlotState");
static_assert(offsetof(FOrionTBSlotState, SlotIdx) == 0x000000, "Member 'FOrionTBSlotState::SlotIdx' has a wrong offset!");
static_assert(offsetof(FOrionTBSlotState, MemberInfo) == 0x000008, "Member 'FOrionTBSlotState::MemberInfo' has a wrong offset!");
static_assert(offsetof(FOrionTBSlotState, PartyMemberState) == 0x000158, "Member 'FOrionTBSlotState::PartyMemberState' has a wrong offset!");
static_assert(offsetof(FOrionTBSlotState, bIsReserved) == 0x000160, "Member 'FOrionTBSlotState::bIsReserved' has a wrong offset!");
static_assert(offsetof(FOrionTBSlotState, bIsPending) == 0x000161, "Member 'FOrionTBSlotState::bIsPending' has a wrong offset!");
static_assert(offsetof(FOrionTBSlotState, bIsCaptain) == 0x000162, "Member 'FOrionTBSlotState::bIsCaptain' has a wrong offset!");

// ScriptStruct OrionGame.GameplayEventKeywordRequest
// 0x0080 (0x0080 - 0x0000)
struct alignas(0x10) FGameplayEventKeywordRequest final
{
public:
	class AOrionPlayerState_Game*                 PlayerState;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventKeywordTag               Event;                                             // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x70];                                      // 0x0010(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayEventKeywordRequest) == 0x000010, "Wrong alignment on FGameplayEventKeywordRequest");
static_assert(sizeof(FGameplayEventKeywordRequest) == 0x000080, "Wrong size on FGameplayEventKeywordRequest");
static_assert(offsetof(FGameplayEventKeywordRequest, PlayerState) == 0x000000, "Member 'FGameplayEventKeywordRequest::PlayerState' has a wrong offset!");
static_assert(offsetof(FGameplayEventKeywordRequest, Event) == 0x000008, "Member 'FGameplayEventKeywordRequest::Event' has a wrong offset!");

// ScriptStruct OrionGame.FutureDailyRewardDesc
// 0x0018 (0x0018 - 0x0000)
struct FFutureDailyRewardDesc final
{
public:
	int32                                         Day;                                               // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ItemDefinitionName;                                // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFutureDailyRewardDesc) == 0x000008, "Wrong alignment on FFutureDailyRewardDesc");
static_assert(sizeof(FFutureDailyRewardDesc) == 0x000018, "Wrong size on FFutureDailyRewardDesc");
static_assert(offsetof(FFutureDailyRewardDesc, Day) == 0x000000, "Member 'FFutureDailyRewardDesc::Day' has a wrong offset!");
static_assert(offsetof(FFutureDailyRewardDesc, ItemDefinitionName) == 0x000008, "Member 'FFutureDailyRewardDesc::ItemDefinitionName' has a wrong offset!");

// ScriptStruct OrionGame.DailyRewardsRetrievedNotification
// 0x0028 (0x0028 - 0x0000)
struct FDailyRewardsRetrievedNotification final
{
public:
	TArray<struct FFutureDailyRewardDesc>         ChronologicalRewards;                              // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FFutureDailyRewardDesc                 NextMajorReward;                                   // 0x0010(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FDailyRewardsRetrievedNotification) == 0x000008, "Wrong alignment on FDailyRewardsRetrievedNotification");
static_assert(sizeof(FDailyRewardsRetrievedNotification) == 0x000028, "Wrong size on FDailyRewardsRetrievedNotification");
static_assert(offsetof(FDailyRewardsRetrievedNotification, ChronologicalRewards) == 0x000000, "Member 'FDailyRewardsRetrievedNotification::ChronologicalRewards' has a wrong offset!");
static_assert(offsetof(FDailyRewardsRetrievedNotification, NextMajorReward) == 0x000010, "Member 'FDailyRewardsRetrievedNotification::NextMajorReward' has a wrong offset!");

// ScriptStruct OrionGame.OrionTeamChatRoomId
// 0x0020 (0x0020 - 0x0000)
struct FOrionTeamChatRoomId final
{
public:
	EOrionTeam                                    TeamIndex;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ChatRoomId;                                        // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        VoiceChatId;                                       // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionTeamChatRoomId) == 0x000008, "Wrong alignment on FOrionTeamChatRoomId");
static_assert(sizeof(FOrionTeamChatRoomId) == 0x000020, "Wrong size on FOrionTeamChatRoomId");
static_assert(offsetof(FOrionTeamChatRoomId, TeamIndex) == 0x000000, "Member 'FOrionTeamChatRoomId::TeamIndex' has a wrong offset!");
static_assert(offsetof(FOrionTeamChatRoomId, ChatRoomId) == 0x000008, "Member 'FOrionTeamChatRoomId::ChatRoomId' has a wrong offset!");
static_assert(offsetof(FOrionTeamChatRoomId, VoiceChatId) == 0x000018, "Member 'FOrionTeamChatRoomId::VoiceChatId' has a wrong offset!");

// ScriptStruct OrionGame.OrionTBTeamInfo
// 0x0188 (0x0188 - 0x0000)
struct FOrionTBTeamInfo final
{
public:
	int32                                         SocialPartySize;                                   // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionTBMemberInfo                     Captain;                                           // 0x0008(0x0150)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FOrionTBMemberInfo>             Members;                                           // 0x0158(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FOrionTeamChatRoomId                   ChatRoomId;                                        // 0x0168(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionTBTeamInfo) == 0x000008, "Wrong alignment on FOrionTBTeamInfo");
static_assert(sizeof(FOrionTBTeamInfo) == 0x000188, "Wrong size on FOrionTBTeamInfo");
static_assert(offsetof(FOrionTBTeamInfo, SocialPartySize) == 0x000000, "Member 'FOrionTBTeamInfo::SocialPartySize' has a wrong offset!");
static_assert(offsetof(FOrionTBTeamInfo, Captain) == 0x000008, "Member 'FOrionTBTeamInfo::Captain' has a wrong offset!");
static_assert(offsetof(FOrionTBTeamInfo, Members) == 0x000158, "Member 'FOrionTBTeamInfo::Members' has a wrong offset!");
static_assert(offsetof(FOrionTBTeamInfo, ChatRoomId) == 0x000168, "Member 'FOrionTBTeamInfo::ChatRoomId' has a wrong offset!");

// ScriptStruct OrionGame.OrionTBTeamInvite
// 0x02A8 (0x02A8 - 0x0000)
struct FOrionTBTeamInvite final
{
public:
	int32                                         SlotIdx;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SessionId;                                         // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionTBPlayerChoices                  RequestedChoices;                                  // 0x0018(0x0108)(NativeAccessSpecifierPublic)
	struct FOrionTBTeamInfo                       TeamInfo;                                          // 0x0120(0x0188)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionTBTeamInvite) == 0x000008, "Wrong alignment on FOrionTBTeamInvite");
static_assert(sizeof(FOrionTBTeamInvite) == 0x0002A8, "Wrong size on FOrionTBTeamInvite");
static_assert(offsetof(FOrionTBTeamInvite, SlotIdx) == 0x000000, "Member 'FOrionTBTeamInvite::SlotIdx' has a wrong offset!");
static_assert(offsetof(FOrionTBTeamInvite, SessionId) == 0x000008, "Member 'FOrionTBTeamInvite::SessionId' has a wrong offset!");
static_assert(offsetof(FOrionTBTeamInvite, RequestedChoices) == 0x000018, "Member 'FOrionTBTeamInvite::RequestedChoices' has a wrong offset!");
static_assert(offsetof(FOrionTBTeamInvite, TeamInfo) == 0x000120, "Member 'FOrionTBTeamInvite::TeamInfo' has a wrong offset!");

// ScriptStruct OrionGame.GameplayEventKeywordData
// 0x0248 (0x0250 - 0x0008)
struct alignas(0x10) FGameplayEventKeywordData final : public FTableRowBase
{
public:
	TSubclassOf<class UOrionAbility_EventEvaluator> EvaluatorAbility;                                  // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEventEvaluatorExecutionSpec           EvaluatorSpec;                                     // 0x0010(0x01A0)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B0[0xA0];                                     // 0x01B0(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayEventKeywordData) == 0x000010, "Wrong alignment on FGameplayEventKeywordData");
static_assert(sizeof(FGameplayEventKeywordData) == 0x000250, "Wrong size on FGameplayEventKeywordData");
static_assert(offsetof(FGameplayEventKeywordData, EvaluatorAbility) == 0x000008, "Member 'FGameplayEventKeywordData::EvaluatorAbility' has a wrong offset!");
static_assert(offsetof(FGameplayEventKeywordData, EvaluatorSpec) == 0x000010, "Member 'FGameplayEventKeywordData::EvaluatorSpec' has a wrong offset!");

// ScriptStruct OrionGame.OrionEmoteAbilityMapping
// 0x0018 (0x0018 - 0x0000)
struct FOrionEmoteAbilityMapping final
{
public:
	EOrionEmoteType                               EmoteType;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UOrionAbility>              Ability;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionAbilityBinding                          KeyBinding;                                        // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionEmoteAbilityMapping) == 0x000008, "Wrong alignment on FOrionEmoteAbilityMapping");
static_assert(sizeof(FOrionEmoteAbilityMapping) == 0x000018, "Wrong size on FOrionEmoteAbilityMapping");
static_assert(offsetof(FOrionEmoteAbilityMapping, EmoteType) == 0x000000, "Member 'FOrionEmoteAbilityMapping::EmoteType' has a wrong offset!");
static_assert(offsetof(FOrionEmoteAbilityMapping, Ability) == 0x000008, "Member 'FOrionEmoteAbilityMapping::Ability' has a wrong offset!");
static_assert(offsetof(FOrionEmoteAbilityMapping, KeyBinding) == 0x000010, "Member 'FOrionEmoteAbilityMapping::KeyBinding' has a wrong offset!");

// ScriptStruct OrionGame.OrionSpectatorHUDTeamInfo
// 0x0001 (0x0002 - 0x0001)
struct FOrionSpectatorHUDTeamInfo final : public FUIUpdateHelperStruct
{
public:
	EOrionTeam                                    TeamNum;                                           // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionSpectatorHUDTeamInfo) == 0x000001, "Wrong alignment on FOrionSpectatorHUDTeamInfo");
static_assert(sizeof(FOrionSpectatorHUDTeamInfo) == 0x000002, "Wrong size on FOrionSpectatorHUDTeamInfo");
static_assert(offsetof(FOrionSpectatorHUDTeamInfo, TeamNum) == 0x000001, "Member 'FOrionSpectatorHUDTeamInfo::TeamNum' has a wrong offset!");

// ScriptStruct OrionGame.OrionGoldTagMarkupData
// 0x0018 (0x0018 - 0x0000)
struct FOrionGoldTagMarkupData final
{
public:
	struct FGameplayTag                           SourceObjectTag;                                   // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GoldMarkupTag;                                     // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerStat                                   AnalyticPlayerStat;                                // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionGoldTagMarkupData) == 0x000008, "Wrong alignment on FOrionGoldTagMarkupData");
static_assert(sizeof(FOrionGoldTagMarkupData) == 0x000018, "Wrong size on FOrionGoldTagMarkupData");
static_assert(offsetof(FOrionGoldTagMarkupData, SourceObjectTag) == 0x000000, "Member 'FOrionGoldTagMarkupData::SourceObjectTag' has a wrong offset!");
static_assert(offsetof(FOrionGoldTagMarkupData, GoldMarkupTag) == 0x000008, "Member 'FOrionGoldTagMarkupData::GoldMarkupTag' has a wrong offset!");
static_assert(offsetof(FOrionGoldTagMarkupData, AnalyticPlayerStat) == 0x000010, "Member 'FOrionGoldTagMarkupData::AnalyticPlayerStat' has a wrong offset!");

// ScriptStruct OrionGame.OrionLocalPlayerUIInfo
// 0x0068 (0x00D8 - 0x0070)
struct FOrionLocalPlayerUIInfo final : public FOrionBaseHUDPlayerInfo
{
public:
	class FText                                   PlayerName;                                        // 0x0070(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   HeroName;                                          // 0x0088(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EOrionTeam                                    EnemyTeamNum;                                      // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CriticallyWoundedThresholdPCT;                     // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInBase;                                         // 0x00A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanShop;                                          // 0x00A9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x2];                                       // 0x00AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CharacterLocation;                                 // 0x00AC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CameraLocation;                                    // 0x00B8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CameraDirection;                                   // 0x00C4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInTravelMode;                                     // 0x00D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMatchHasStarted;                                  // 0x00D1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInTargetingMode;                                  // 0x00D2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConfirmAllowed;                                   // 0x00D3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionLocalPlayerUIInfo) == 0x000008, "Wrong alignment on FOrionLocalPlayerUIInfo");
static_assert(sizeof(FOrionLocalPlayerUIInfo) == 0x0000D8, "Wrong size on FOrionLocalPlayerUIInfo");
static_assert(offsetof(FOrionLocalPlayerUIInfo, PlayerName) == 0x000070, "Member 'FOrionLocalPlayerUIInfo::PlayerName' has a wrong offset!");
static_assert(offsetof(FOrionLocalPlayerUIInfo, HeroName) == 0x000088, "Member 'FOrionLocalPlayerUIInfo::HeroName' has a wrong offset!");
static_assert(offsetof(FOrionLocalPlayerUIInfo, EnemyTeamNum) == 0x0000A0, "Member 'FOrionLocalPlayerUIInfo::EnemyTeamNum' has a wrong offset!");
static_assert(offsetof(FOrionLocalPlayerUIInfo, CriticallyWoundedThresholdPCT) == 0x0000A4, "Member 'FOrionLocalPlayerUIInfo::CriticallyWoundedThresholdPCT' has a wrong offset!");
static_assert(offsetof(FOrionLocalPlayerUIInfo, bIsInBase) == 0x0000A8, "Member 'FOrionLocalPlayerUIInfo::bIsInBase' has a wrong offset!");
static_assert(offsetof(FOrionLocalPlayerUIInfo, bCanShop) == 0x0000A9, "Member 'FOrionLocalPlayerUIInfo::bCanShop' has a wrong offset!");
static_assert(offsetof(FOrionLocalPlayerUIInfo, CharacterLocation) == 0x0000AC, "Member 'FOrionLocalPlayerUIInfo::CharacterLocation' has a wrong offset!");
static_assert(offsetof(FOrionLocalPlayerUIInfo, CameraLocation) == 0x0000B8, "Member 'FOrionLocalPlayerUIInfo::CameraLocation' has a wrong offset!");
static_assert(offsetof(FOrionLocalPlayerUIInfo, CameraDirection) == 0x0000C4, "Member 'FOrionLocalPlayerUIInfo::CameraDirection' has a wrong offset!");
static_assert(offsetof(FOrionLocalPlayerUIInfo, bInTravelMode) == 0x0000D0, "Member 'FOrionLocalPlayerUIInfo::bInTravelMode' has a wrong offset!");
static_assert(offsetof(FOrionLocalPlayerUIInfo, bMatchHasStarted) == 0x0000D1, "Member 'FOrionLocalPlayerUIInfo::bMatchHasStarted' has a wrong offset!");
static_assert(offsetof(FOrionLocalPlayerUIInfo, bInTargetingMode) == 0x0000D2, "Member 'FOrionLocalPlayerUIInfo::bInTargetingMode' has a wrong offset!");
static_assert(offsetof(FOrionLocalPlayerUIInfo, bConfirmAllowed) == 0x0000D3, "Member 'FOrionLocalPlayerUIInfo::bConfirmAllowed' has a wrong offset!");

// ScriptStruct OrionGame.OrionPickupInfo
// 0x0010 (0x0010 - 0x0000)
struct FOrionPickupInfo final
{
public:
	TSubclassOf<class AOrionPickup>               DataRef;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InitialPoolSize;                                   // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionPickupInfo) == 0x000008, "Wrong alignment on FOrionPickupInfo");
static_assert(sizeof(FOrionPickupInfo) == 0x000010, "Wrong size on FOrionPickupInfo");
static_assert(offsetof(FOrionPickupInfo, DataRef) == 0x000000, "Member 'FOrionPickupInfo::DataRef' has a wrong offset!");
static_assert(offsetof(FOrionPickupInfo, InitialPoolSize) == 0x000008, "Member 'FOrionPickupInfo::InitialPoolSize' has a wrong offset!");

// ScriptStruct OrionGame.OrionTrackedQuests
// 0x0028 (0x0028 - 0x0000)
struct FOrionTrackedQuests final
{
public:
	struct FUniqueNetIdRepl                       PlayerNetId;                                       // 0x0000(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UOrionMcpQuestItem*>             Quests;                                            // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionTrackedQuests) == 0x000008, "Wrong alignment on FOrionTrackedQuests");
static_assert(sizeof(FOrionTrackedQuests) == 0x000028, "Wrong size on FOrionTrackedQuests");
static_assert(offsetof(FOrionTrackedQuests, PlayerNetId) == 0x000000, "Member 'FOrionTrackedQuests::PlayerNetId' has a wrong offset!");
static_assert(offsetof(FOrionTrackedQuests, Quests) == 0x000018, "Member 'FOrionTrackedQuests::Quests' has a wrong offset!");

// ScriptStruct OrionGame.OrionGameEventRequestHandle
// 0x0004 (0x0004 - 0x0000)
struct FOrionGameEventRequestHandle final
{
public:
	int32                                         Handle;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionGameEventRequestHandle) == 0x000004, "Wrong alignment on FOrionGameEventRequestHandle");
static_assert(sizeof(FOrionGameEventRequestHandle) == 0x000004, "Wrong size on FOrionGameEventRequestHandle");
static_assert(offsetof(FOrionGameEventRequestHandle, Handle) == 0x000000, "Member 'FOrionGameEventRequestHandle::Handle' has a wrong offset!");

// ScriptStruct OrionGame.EventKeywordOrGameplayStatTag
// 0x0000 (0x0008 - 0x0008)
struct FEventKeywordOrGameplayStatTag final : public FGameplayTag
{
};
static_assert(alignof(FEventKeywordOrGameplayStatTag) == 0x000008, "Wrong alignment on FEventKeywordOrGameplayStatTag");
static_assert(sizeof(FEventKeywordOrGameplayStatTag) == 0x000008, "Wrong size on FEventKeywordOrGameplayStatTag");

// ScriptStruct OrionGame.EventKeywordBasedStat
// 0x0090 (0x0090 - 0x0000)
struct FEventKeywordBasedStat final
{
public:
	struct FEventKeywordOrGameplayStatTag         BaseEventOrStat;                                   // 0x0000(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FQualifierKeywordsWithContext          AdditionalQualifiers;                              // 0x0008(0x0078)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayStatEventValueTag             Type;                                              // 0x0080(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayQualifierAggregationWindow    Aggregation;                                       // 0x0088(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventKeywordBasedStat) == 0x000008, "Wrong alignment on FEventKeywordBasedStat");
static_assert(sizeof(FEventKeywordBasedStat) == 0x000090, "Wrong size on FEventKeywordBasedStat");
static_assert(offsetof(FEventKeywordBasedStat, BaseEventOrStat) == 0x000000, "Member 'FEventKeywordBasedStat::BaseEventOrStat' has a wrong offset!");
static_assert(offsetof(FEventKeywordBasedStat, AdditionalQualifiers) == 0x000008, "Member 'FEventKeywordBasedStat::AdditionalQualifiers' has a wrong offset!");
static_assert(offsetof(FEventKeywordBasedStat, Type) == 0x000080, "Member 'FEventKeywordBasedStat::Type' has a wrong offset!");
static_assert(offsetof(FEventKeywordBasedStat, Aggregation) == 0x000088, "Member 'FEventKeywordBasedStat::Aggregation' has a wrong offset!");

// ScriptStruct OrionGame.OrionDraftTimings
// 0x0014 (0x0014 - 0x0000)
struct FOrionDraftTimings final
{
public:
	float                                         FirstTransitionDuration;                           // 0x0000(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionDuration;                                // 0x0004(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PickDuration;                                      // 0x0008(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BotPickTime;                                       // 0x000C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MatchCountdownSeconds;                             // 0x0010(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionDraftTimings) == 0x000004, "Wrong alignment on FOrionDraftTimings");
static_assert(sizeof(FOrionDraftTimings) == 0x000014, "Wrong size on FOrionDraftTimings");
static_assert(offsetof(FOrionDraftTimings, FirstTransitionDuration) == 0x000000, "Member 'FOrionDraftTimings::FirstTransitionDuration' has a wrong offset!");
static_assert(offsetof(FOrionDraftTimings, TransitionDuration) == 0x000004, "Member 'FOrionDraftTimings::TransitionDuration' has a wrong offset!");
static_assert(offsetof(FOrionDraftTimings, PickDuration) == 0x000008, "Member 'FOrionDraftTimings::PickDuration' has a wrong offset!");
static_assert(offsetof(FOrionDraftTimings, BotPickTime) == 0x00000C, "Member 'FOrionDraftTimings::BotPickTime' has a wrong offset!");
static_assert(offsetof(FOrionDraftTimings, MatchCountdownSeconds) == 0x000010, "Member 'FOrionDraftTimings::MatchCountdownSeconds' has a wrong offset!");

// ScriptStruct OrionGame.OrionTurnTransition
// 0x0020 (0x0020 - 0x0000)
struct FOrionTurnTransition final
{
public:
	class UAnimSequenceBase*                      Anim;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRightTurn;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayBeforeTrigger;                                // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CachedSign;                                        // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CachedTurnAngle;                                   // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTravelModeTransition;                           // 0x0018(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionTurnTransition) == 0x000008, "Wrong alignment on FOrionTurnTransition");
static_assert(sizeof(FOrionTurnTransition) == 0x000020, "Wrong size on FOrionTurnTransition");
static_assert(offsetof(FOrionTurnTransition, Anim) == 0x000000, "Member 'FOrionTurnTransition::Anim' has a wrong offset!");
static_assert(offsetof(FOrionTurnTransition, bRightTurn) == 0x000008, "Member 'FOrionTurnTransition::bRightTurn' has a wrong offset!");
static_assert(offsetof(FOrionTurnTransition, DelayBeforeTrigger) == 0x00000C, "Member 'FOrionTurnTransition::DelayBeforeTrigger' has a wrong offset!");
static_assert(offsetof(FOrionTurnTransition, CachedSign) == 0x000010, "Member 'FOrionTurnTransition::CachedSign' has a wrong offset!");
static_assert(offsetof(FOrionTurnTransition, CachedTurnAngle) == 0x000014, "Member 'FOrionTurnTransition::CachedTurnAngle' has a wrong offset!");
static_assert(offsetof(FOrionTurnTransition, bIsTravelModeTransition) == 0x000018, "Member 'FOrionTurnTransition::bIsTravelModeTransition' has a wrong offset!");

// ScriptStruct OrionGame.BannerMaterialDesc
// 0x00D8 (0x00D8 - 0x0000)
struct FBannerMaterialDesc final
{
public:
	class UTexture*                               DiffuseLoaded;                                     // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture*                               TextureLoaded;                                     // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture*                               NormalLoaded;                                      // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UTexture>                Diffuse;                                           // 0x0018(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture>                Texture;                                           // 0x0040(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture>                Normal;                                            // 0x0068(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           Color1;                                            // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color2;                                            // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Emissive;                                          // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Metallic1;                                         // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Metallic2;                                         // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Roughness1;                                        // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Roughness2;                                        // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tiling;                                            // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBannerMaterialDesc) == 0x000008, "Wrong alignment on FBannerMaterialDesc");
static_assert(sizeof(FBannerMaterialDesc) == 0x0000D8, "Wrong size on FBannerMaterialDesc");
static_assert(offsetof(FBannerMaterialDesc, DiffuseLoaded) == 0x000000, "Member 'FBannerMaterialDesc::DiffuseLoaded' has a wrong offset!");
static_assert(offsetof(FBannerMaterialDesc, TextureLoaded) == 0x000008, "Member 'FBannerMaterialDesc::TextureLoaded' has a wrong offset!");
static_assert(offsetof(FBannerMaterialDesc, NormalLoaded) == 0x000010, "Member 'FBannerMaterialDesc::NormalLoaded' has a wrong offset!");
static_assert(offsetof(FBannerMaterialDesc, Diffuse) == 0x000018, "Member 'FBannerMaterialDesc::Diffuse' has a wrong offset!");
static_assert(offsetof(FBannerMaterialDesc, Texture) == 0x000040, "Member 'FBannerMaterialDesc::Texture' has a wrong offset!");
static_assert(offsetof(FBannerMaterialDesc, Normal) == 0x000068, "Member 'FBannerMaterialDesc::Normal' has a wrong offset!");
static_assert(offsetof(FBannerMaterialDesc, Color1) == 0x000090, "Member 'FBannerMaterialDesc::Color1' has a wrong offset!");
static_assert(offsetof(FBannerMaterialDesc, Color2) == 0x0000A0, "Member 'FBannerMaterialDesc::Color2' has a wrong offset!");
static_assert(offsetof(FBannerMaterialDesc, Emissive) == 0x0000B0, "Member 'FBannerMaterialDesc::Emissive' has a wrong offset!");
static_assert(offsetof(FBannerMaterialDesc, Metallic1) == 0x0000C0, "Member 'FBannerMaterialDesc::Metallic1' has a wrong offset!");
static_assert(offsetof(FBannerMaterialDesc, Metallic2) == 0x0000C4, "Member 'FBannerMaterialDesc::Metallic2' has a wrong offset!");
static_assert(offsetof(FBannerMaterialDesc, Roughness1) == 0x0000C8, "Member 'FBannerMaterialDesc::Roughness1' has a wrong offset!");
static_assert(offsetof(FBannerMaterialDesc, Roughness2) == 0x0000CC, "Member 'FBannerMaterialDesc::Roughness2' has a wrong offset!");
static_assert(offsetof(FBannerMaterialDesc, Tiling) == 0x0000D0, "Member 'FBannerMaterialDesc::Tiling' has a wrong offset!");

// ScriptStruct OrionGame.OrionPlayerInput_ActionMapping
// 0x0048 (0x0048 - 0x0000)
struct FOrionPlayerInput_ActionMapping final
{
public:
	class FName                                   Action;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   Key;                                               // 0x0008(0x0018)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   ChordKey;                                          // 0x0020(0x0018)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiresModifier;                                 // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HoldTime;                                          // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipAdvanced;                                     // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionPlayerInput_ActionMapping) == 0x000008, "Wrong alignment on FOrionPlayerInput_ActionMapping");
static_assert(sizeof(FOrionPlayerInput_ActionMapping) == 0x000048, "Wrong size on FOrionPlayerInput_ActionMapping");
static_assert(offsetof(FOrionPlayerInput_ActionMapping, Action) == 0x000000, "Member 'FOrionPlayerInput_ActionMapping::Action' has a wrong offset!");
static_assert(offsetof(FOrionPlayerInput_ActionMapping, Key) == 0x000008, "Member 'FOrionPlayerInput_ActionMapping::Key' has a wrong offset!");
static_assert(offsetof(FOrionPlayerInput_ActionMapping, ChordKey) == 0x000020, "Member 'FOrionPlayerInput_ActionMapping::ChordKey' has a wrong offset!");
static_assert(offsetof(FOrionPlayerInput_ActionMapping, bRequiresModifier) == 0x000038, "Member 'FOrionPlayerInput_ActionMapping::bRequiresModifier' has a wrong offset!");
static_assert(offsetof(FOrionPlayerInput_ActionMapping, HoldTime) == 0x00003C, "Member 'FOrionPlayerInput_ActionMapping::HoldTime' has a wrong offset!");
static_assert(offsetof(FOrionPlayerInput_ActionMapping, bSkipAdvanced) == 0x000040, "Member 'FOrionPlayerInput_ActionMapping::bSkipAdvanced' has a wrong offset!");

// ScriptStruct OrionGame.TBPlayerFilterDuration
// 0x0008 (0x0008 - 0x0000)
struct FTBPlayerFilterDuration final
{
public:
	ETeamBuilderPlayerFilterReason                Reason;                                            // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Duration;                                          // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTBPlayerFilterDuration) == 0x000004, "Wrong alignment on FTBPlayerFilterDuration");
static_assert(sizeof(FTBPlayerFilterDuration) == 0x000008, "Wrong size on FTBPlayerFilterDuration");
static_assert(offsetof(FTBPlayerFilterDuration, Reason) == 0x000000, "Member 'FTBPlayerFilterDuration::Reason' has a wrong offset!");
static_assert(offsetof(FTBPlayerFilterDuration, Duration) == 0x000004, "Member 'FTBPlayerFilterDuration::Duration' has a wrong offset!");

// ScriptStruct OrionGame.OrionTargetingModePlacement
// 0x0268 (0x0268 - 0x0000)
struct FOrionTargetingModePlacement final
{
public:
	EOrionTargetingModePlacementPolicy            Policy;                                            // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionShapeDimension                   AimSphereCastRangeDim;                             // 0x0008(0x0038)(Edit, NativeAccessSpecifierPublic)
	struct FOrionShapeDimension                   AimSphereCastBlockRadiusDim;                       // 0x0040(0x0038)(Edit, NativeAccessSpecifierPublic)
	struct FOrionShapeDimension                   AimSphereCastOverlapRadiusDim;                     // 0x0078(0x0038)(Edit, NativeAccessSpecifierPublic)
	struct FCollisionProfileName                  AimSphereCastProfile;                              // 0x00B0(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FOrionActorFilter                      AimSphereCastFilter;                               // 0x00B8(0x0060)(Edit, NativeAccessSpecifierPublic)
	bool                                          bLockPitchAndRoll;                                 // 0x0118(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockViewToTarget;                                 // 0x0119(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11A[0x6];                                      // 0x011A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LockViewToTargetSocket;                            // 0x0120(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckOwnerLOSToSweepStart;                        // 0x0128(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionShapeDimension                   GroundPlacementRangeMinDim;                        // 0x0130(0x0038)(Edit, NativeAccessSpecifierPublic)
	struct FOrionShapeDimension                   GroundPlacementRangeMaxDim;                        // 0x0168(0x0038)(Edit, NativeAccessSpecifierPublic)
	struct FOrionShapeDimension                   GroundTargetingHeightLimitMin;                     // 0x01A0(0x0038)(Edit, NativeAccessSpecifierPublic)
	struct FOrionShapeDimension                   GroundTargetingHeightLimitMax;                     // 0x01D8(0x0038)(Edit, NativeAccessSpecifierPublic)
	struct FScalableFloat                         GroundTargetingMinPitch;                           // 0x0210(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FScalableFloat                         GroundTargetingMaxPitch;                           // 0x0238(0x0028)(Edit, NativeAccessSpecifierPublic)
	bool                                          bGroundPlacementNormalToGround;                    // 0x0260(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261[0x3];                                      // 0x0261(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ValidGroundNormalZMinimum;                         // 0x0264(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionTargetingModePlacement) == 0x000008, "Wrong alignment on FOrionTargetingModePlacement");
static_assert(sizeof(FOrionTargetingModePlacement) == 0x000268, "Wrong size on FOrionTargetingModePlacement");
static_assert(offsetof(FOrionTargetingModePlacement, Policy) == 0x000000, "Member 'FOrionTargetingModePlacement::Policy' has a wrong offset!");
static_assert(offsetof(FOrionTargetingModePlacement, AimSphereCastRangeDim) == 0x000008, "Member 'FOrionTargetingModePlacement::AimSphereCastRangeDim' has a wrong offset!");
static_assert(offsetof(FOrionTargetingModePlacement, AimSphereCastBlockRadiusDim) == 0x000040, "Member 'FOrionTargetingModePlacement::AimSphereCastBlockRadiusDim' has a wrong offset!");
static_assert(offsetof(FOrionTargetingModePlacement, AimSphereCastOverlapRadiusDim) == 0x000078, "Member 'FOrionTargetingModePlacement::AimSphereCastOverlapRadiusDim' has a wrong offset!");
static_assert(offsetof(FOrionTargetingModePlacement, AimSphereCastProfile) == 0x0000B0, "Member 'FOrionTargetingModePlacement::AimSphereCastProfile' has a wrong offset!");
static_assert(offsetof(FOrionTargetingModePlacement, AimSphereCastFilter) == 0x0000B8, "Member 'FOrionTargetingModePlacement::AimSphereCastFilter' has a wrong offset!");
static_assert(offsetof(FOrionTargetingModePlacement, bLockPitchAndRoll) == 0x000118, "Member 'FOrionTargetingModePlacement::bLockPitchAndRoll' has a wrong offset!");
static_assert(offsetof(FOrionTargetingModePlacement, bLockViewToTarget) == 0x000119, "Member 'FOrionTargetingModePlacement::bLockViewToTarget' has a wrong offset!");
static_assert(offsetof(FOrionTargetingModePlacement, LockViewToTargetSocket) == 0x000120, "Member 'FOrionTargetingModePlacement::LockViewToTargetSocket' has a wrong offset!");
static_assert(offsetof(FOrionTargetingModePlacement, bCheckOwnerLOSToSweepStart) == 0x000128, "Member 'FOrionTargetingModePlacement::bCheckOwnerLOSToSweepStart' has a wrong offset!");
static_assert(offsetof(FOrionTargetingModePlacement, GroundPlacementRangeMinDim) == 0x000130, "Member 'FOrionTargetingModePlacement::GroundPlacementRangeMinDim' has a wrong offset!");
static_assert(offsetof(FOrionTargetingModePlacement, GroundPlacementRangeMaxDim) == 0x000168, "Member 'FOrionTargetingModePlacement::GroundPlacementRangeMaxDim' has a wrong offset!");
static_assert(offsetof(FOrionTargetingModePlacement, GroundTargetingHeightLimitMin) == 0x0001A0, "Member 'FOrionTargetingModePlacement::GroundTargetingHeightLimitMin' has a wrong offset!");
static_assert(offsetof(FOrionTargetingModePlacement, GroundTargetingHeightLimitMax) == 0x0001D8, "Member 'FOrionTargetingModePlacement::GroundTargetingHeightLimitMax' has a wrong offset!");
static_assert(offsetof(FOrionTargetingModePlacement, GroundTargetingMinPitch) == 0x000210, "Member 'FOrionTargetingModePlacement::GroundTargetingMinPitch' has a wrong offset!");
static_assert(offsetof(FOrionTargetingModePlacement, GroundTargetingMaxPitch) == 0x000238, "Member 'FOrionTargetingModePlacement::GroundTargetingMaxPitch' has a wrong offset!");
static_assert(offsetof(FOrionTargetingModePlacement, bGroundPlacementNormalToGround) == 0x000260, "Member 'FOrionTargetingModePlacement::bGroundPlacementNormalToGround' has a wrong offset!");
static_assert(offsetof(FOrionTargetingModePlacement, ValidGroundNormalZMinimum) == 0x000264, "Member 'FOrionTargetingModePlacement::ValidGroundNormalZMinimum' has a wrong offset!");

// ScriptStruct OrionGame.GameplayCueTraceFailureSpawnInfo
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FGameplayCueTraceFailureSpawnInfo final
{
public:
	class FName                                   SpawnSocketName;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSocketUpVectorForRotation;                     // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayCueTraceFailureSpawnInfo) == 0x000008, "Wrong alignment on FGameplayCueTraceFailureSpawnInfo");
static_assert(sizeof(FGameplayCueTraceFailureSpawnInfo) == 0x000010, "Wrong size on FGameplayCueTraceFailureSpawnInfo");
static_assert(offsetof(FGameplayCueTraceFailureSpawnInfo, SpawnSocketName) == 0x000000, "Member 'FGameplayCueTraceFailureSpawnInfo::SpawnSocketName' has a wrong offset!");
static_assert(offsetof(FGameplayCueTraceFailureSpawnInfo, bUseSocketUpVectorForRotation) == 0x000008, "Member 'FGameplayCueTraceFailureSpawnInfo::bUseSocketUpVectorForRotation' has a wrong offset!");

// ScriptStruct OrionGame.GameplayCueTraceInfo
// 0x00A0 (0x00A0 - 0x0000)
struct FGameplayCueTraceInfo final
{
public:
	bool                                          bEnableTrace;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TraceStartSocketName;                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSocketRotation;                                // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceStartOffsetInLocalSpace;                     // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TraceStartOffset;                                  // 0x0014(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseTargetActorRotation;                           // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               TraceRotation;                                     // 0x0024(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TraceDistance;                                     // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceIgnoreHeroes;                                // 0x0035(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceIgnoreTargetActorOwner;                      // 0x0036(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreLocalVisibility;                            // 0x0037(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueTraceSpawnInfo             TraceSuccess;                                      // 0x0038(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTraceFailureSpawnInfo      TraceFailureSpawn;                                 // 0x0060(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTraceSpawnInfo             TraceFailure;                                      // 0x0070(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayCueTraceInfo) == 0x000008, "Wrong alignment on FGameplayCueTraceInfo");
static_assert(sizeof(FGameplayCueTraceInfo) == 0x0000A0, "Wrong size on FGameplayCueTraceInfo");
static_assert(offsetof(FGameplayCueTraceInfo, bEnableTrace) == 0x000000, "Member 'FGameplayCueTraceInfo::bEnableTrace' has a wrong offset!");
static_assert(offsetof(FGameplayCueTraceInfo, TraceStartSocketName) == 0x000008, "Member 'FGameplayCueTraceInfo::TraceStartSocketName' has a wrong offset!");
static_assert(offsetof(FGameplayCueTraceInfo, bUseSocketRotation) == 0x000010, "Member 'FGameplayCueTraceInfo::bUseSocketRotation' has a wrong offset!");
static_assert(offsetof(FGameplayCueTraceInfo, bTraceStartOffsetInLocalSpace) == 0x000011, "Member 'FGameplayCueTraceInfo::bTraceStartOffsetInLocalSpace' has a wrong offset!");
static_assert(offsetof(FGameplayCueTraceInfo, TraceStartOffset) == 0x000014, "Member 'FGameplayCueTraceInfo::TraceStartOffset' has a wrong offset!");
static_assert(offsetof(FGameplayCueTraceInfo, bUseTargetActorRotation) == 0x000020, "Member 'FGameplayCueTraceInfo::bUseTargetActorRotation' has a wrong offset!");
static_assert(offsetof(FGameplayCueTraceInfo, TraceRotation) == 0x000024, "Member 'FGameplayCueTraceInfo::TraceRotation' has a wrong offset!");
static_assert(offsetof(FGameplayCueTraceInfo, TraceDistance) == 0x000030, "Member 'FGameplayCueTraceInfo::TraceDistance' has a wrong offset!");
static_assert(offsetof(FGameplayCueTraceInfo, TraceChannel) == 0x000034, "Member 'FGameplayCueTraceInfo::TraceChannel' has a wrong offset!");
static_assert(offsetof(FGameplayCueTraceInfo, bTraceIgnoreHeroes) == 0x000035, "Member 'FGameplayCueTraceInfo::bTraceIgnoreHeroes' has a wrong offset!");
static_assert(offsetof(FGameplayCueTraceInfo, bTraceIgnoreTargetActorOwner) == 0x000036, "Member 'FGameplayCueTraceInfo::bTraceIgnoreTargetActorOwner' has a wrong offset!");
static_assert(offsetof(FGameplayCueTraceInfo, bIgnoreLocalVisibility) == 0x000037, "Member 'FGameplayCueTraceInfo::bIgnoreLocalVisibility' has a wrong offset!");
static_assert(offsetof(FGameplayCueTraceInfo, TraceSuccess) == 0x000038, "Member 'FGameplayCueTraceInfo::TraceSuccess' has a wrong offset!");
static_assert(offsetof(FGameplayCueTraceInfo, TraceFailureSpawn) == 0x000060, "Member 'FGameplayCueTraceInfo::TraceFailureSpawn' has a wrong offset!");
static_assert(offsetof(FGameplayCueTraceInfo, TraceFailure) == 0x000070, "Member 'FGameplayCueTraceInfo::TraceFailure' has a wrong offset!");

// ScriptStruct OrionGame.HighlightDefinitionTableRow
// 0x00E0 (0x00E8 - 0x0008)
struct FHighlightDefinitionTableRow final : public FTableRowBase
{
public:
	struct FHighlightDefinition                   Highlight;                                         // 0x0008(0x00E0)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHighlightDefinitionTableRow) == 0x000008, "Wrong alignment on FHighlightDefinitionTableRow");
static_assert(sizeof(FHighlightDefinitionTableRow) == 0x0000E8, "Wrong size on FHighlightDefinitionTableRow");
static_assert(offsetof(FHighlightDefinitionTableRow, Highlight) == 0x000008, "Member 'FHighlightDefinitionTableRow::Highlight' has a wrong offset!");

// ScriptStruct OrionGame.QualifierContextGameplayEffect
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FQualifierContextGameplayEffect final : public FQualifierContextBase
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQualifierContextGameplayEffect) == 0x000008, "Wrong alignment on FQualifierContextGameplayEffect");
static_assert(sizeof(FQualifierContextGameplayEffect) == 0x000010, "Wrong size on FQualifierContextGameplayEffect");

// ScriptStruct OrionGame.GameplayCueAudioInfo_Looping
// 0x0008 (0x0020 - 0x0018)
struct FGameplayCueAudioInfo_Looping final : public FGameplayCueAudioInfo
{
public:
	float                                         LoopingSoundFadeOutDuration;                       // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoopingSoundVolumeLevel;                           // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayCueAudioInfo_Looping) == 0x000008, "Wrong alignment on FGameplayCueAudioInfo_Looping");
static_assert(sizeof(FGameplayCueAudioInfo_Looping) == 0x000020, "Wrong size on FGameplayCueAudioInfo_Looping");
static_assert(offsetof(FGameplayCueAudioInfo_Looping, LoopingSoundFadeOutDuration) == 0x000018, "Member 'FGameplayCueAudioInfo_Looping::LoopingSoundFadeOutDuration' has a wrong offset!");
static_assert(offsetof(FGameplayCueAudioInfo_Looping, LoopingSoundVolumeLevel) == 0x00001C, "Member 'FGameplayCueAudioInfo_Looping::LoopingSoundVolumeLevel' has a wrong offset!");

// ScriptStruct OrionGame.PlayerStatContainer
// 0x0020 (0x00D0 - 0x00B0)
struct FPlayerStatContainer final : public FFastArraySerializer
{
public:
	TArray<struct FPlayerStat>                    PlayerStats;                                       // 0x00B0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class AOrionPlayerState_Game*                 Owner;                                             // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          LockedFromAddingNewStats;                          // 0x00C8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerStatContainer) == 0x000008, "Wrong alignment on FPlayerStatContainer");
static_assert(sizeof(FPlayerStatContainer) == 0x0000D0, "Wrong size on FPlayerStatContainer");
static_assert(offsetof(FPlayerStatContainer, PlayerStats) == 0x0000B0, "Member 'FPlayerStatContainer::PlayerStats' has a wrong offset!");
static_assert(offsetof(FPlayerStatContainer, Owner) == 0x0000C0, "Member 'FPlayerStatContainer::Owner' has a wrong offset!");
static_assert(offsetof(FPlayerStatContainer, LockedFromAddingNewStats) == 0x0000C8, "Member 'FPlayerStatContainer::LockedFromAddingNewStats' has a wrong offset!");

// ScriptStruct OrionGame.PlayerStatData
// 0x0170 (0x0170 - 0x0000)
struct alignas(0x10) FPlayerStatData final
{
public:
	struct FGameplayStatTag                       Stat;                                              // 0x0000(0x0010)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FastReplicationArrayIndex;                         // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ValueArray[0x3];                                   // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_20[0x150];                                     // 0x0020(0x0150)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerStatData) == 0x000010, "Wrong alignment on FPlayerStatData");
static_assert(sizeof(FPlayerStatData) == 0x000170, "Wrong size on FPlayerStatData");
static_assert(offsetof(FPlayerStatData, Stat) == 0x000000, "Member 'FPlayerStatData::Stat' has a wrong offset!");
static_assert(offsetof(FPlayerStatData, FastReplicationArrayIndex) == 0x000010, "Member 'FPlayerStatData::FastReplicationArrayIndex' has a wrong offset!");
static_assert(offsetof(FPlayerStatData, ValueArray) == 0x000014, "Member 'FPlayerStatData::ValueArray' has a wrong offset!");

// ScriptStruct OrionGame.GameplayStatsMetaData
// 0x00E8 (0x00F0 - 0x0008)
struct FGameplayStatsMetaData final : public FTableRowBase
{
public:
	class FString                                 BackendStatString;                                 // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAccountPVP;                                       // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAccountTotal;                                     // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHeroPVP;                                          // 0x001A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHeroTotal;                                        // 0x001B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCommunity;                                        // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClientLegal;                                      // 0x001D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvalidDataDontExport;                            // 0x001E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F[0x1];                                       // 0x001F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEventKeywordBasedStat                 EventData;                                         // 0x0020(0x0090)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagReferenceHelper            ReferenceHelper;                                   // 0x00B0(0x0040)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayStatsMetaData) == 0x000010, "Wrong alignment on FGameplayStatsMetaData");
static_assert(sizeof(FGameplayStatsMetaData) == 0x0000F0, "Wrong size on FGameplayStatsMetaData");
static_assert(offsetof(FGameplayStatsMetaData, BackendStatString) == 0x000008, "Member 'FGameplayStatsMetaData::BackendStatString' has a wrong offset!");
static_assert(offsetof(FGameplayStatsMetaData, bAccountPVP) == 0x000018, "Member 'FGameplayStatsMetaData::bAccountPVP' has a wrong offset!");
static_assert(offsetof(FGameplayStatsMetaData, bAccountTotal) == 0x000019, "Member 'FGameplayStatsMetaData::bAccountTotal' has a wrong offset!");
static_assert(offsetof(FGameplayStatsMetaData, bHeroPVP) == 0x00001A, "Member 'FGameplayStatsMetaData::bHeroPVP' has a wrong offset!");
static_assert(offsetof(FGameplayStatsMetaData, bHeroTotal) == 0x00001B, "Member 'FGameplayStatsMetaData::bHeroTotal' has a wrong offset!");
static_assert(offsetof(FGameplayStatsMetaData, bCommunity) == 0x00001C, "Member 'FGameplayStatsMetaData::bCommunity' has a wrong offset!");
static_assert(offsetof(FGameplayStatsMetaData, bClientLegal) == 0x00001D, "Member 'FGameplayStatsMetaData::bClientLegal' has a wrong offset!");
static_assert(offsetof(FGameplayStatsMetaData, bInvalidDataDontExport) == 0x00001E, "Member 'FGameplayStatsMetaData::bInvalidDataDontExport' has a wrong offset!");
static_assert(offsetof(FGameplayStatsMetaData, EventData) == 0x000020, "Member 'FGameplayStatsMetaData::EventData' has a wrong offset!");
static_assert(offsetof(FGameplayStatsMetaData, ReferenceHelper) == 0x0000B0, "Member 'FGameplayStatsMetaData::ReferenceHelper' has a wrong offset!");

// ScriptStruct OrionGame.QualifierContextAggregated_Basic
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FQualifierContextAggregated_Basic final : public FQualifierContextBase
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQualifierContextAggregated_Basic) == 0x000004, "Wrong alignment on FQualifierContextAggregated_Basic");
static_assert(sizeof(FQualifierContextAggregated_Basic) == 0x000004, "Wrong size on FQualifierContextAggregated_Basic");

// ScriptStruct OrionGame.GameplayVolumeEffectsOverlapTracker
// 0x0030 (0x0030 - 0x0000)
struct FGameplayVolumeEffectsOverlapTracker final
{
public:
	int32                                         OverlapCount;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FActiveGameplayEffectHandle>    EffectsApplied;                                    // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayAbilitySpecHandle             GrantedAbilitySpecHandle;                          // 0x0018(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  Actor;                                             // 0x001C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AOrionGameplayVolume>    ParentVolume;                                      // 0x0024(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayVolumeEffectsOverlapTracker) == 0x000008, "Wrong alignment on FGameplayVolumeEffectsOverlapTracker");
static_assert(sizeof(FGameplayVolumeEffectsOverlapTracker) == 0x000030, "Wrong size on FGameplayVolumeEffectsOverlapTracker");
static_assert(offsetof(FGameplayVolumeEffectsOverlapTracker, OverlapCount) == 0x000000, "Member 'FGameplayVolumeEffectsOverlapTracker::OverlapCount' has a wrong offset!");
static_assert(offsetof(FGameplayVolumeEffectsOverlapTracker, EffectsApplied) == 0x000008, "Member 'FGameplayVolumeEffectsOverlapTracker::EffectsApplied' has a wrong offset!");
static_assert(offsetof(FGameplayVolumeEffectsOverlapTracker, GrantedAbilitySpecHandle) == 0x000018, "Member 'FGameplayVolumeEffectsOverlapTracker::GrantedAbilitySpecHandle' has a wrong offset!");
static_assert(offsetof(FGameplayVolumeEffectsOverlapTracker, Actor) == 0x00001C, "Member 'FGameplayVolumeEffectsOverlapTracker::Actor' has a wrong offset!");
static_assert(offsetof(FGameplayVolumeEffectsOverlapTracker, ParentVolume) == 0x000024, "Member 'FGameplayVolumeEffectsOverlapTracker::ParentVolume' has a wrong offset!");

// ScriptStruct OrionGame.LinkedCollisionComp
// 0x0020 (0x0020 - 0x0000)
struct FLinkedCollisionComp final
{
public:
	TWeakObjectPtr<class UPrimitiveComponent>     LinkedPrimitiveComp;                               // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLinked;                                         // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           PrimitiveCompTag;                                  // 0x0010(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           LinkedPrimitiveTag;                                // 0x0018(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLinkedCollisionComp) == 0x000008, "Wrong alignment on FLinkedCollisionComp");
static_assert(sizeof(FLinkedCollisionComp) == 0x000020, "Wrong size on FLinkedCollisionComp");
static_assert(offsetof(FLinkedCollisionComp, LinkedPrimitiveComp) == 0x000000, "Member 'FLinkedCollisionComp::LinkedPrimitiveComp' has a wrong offset!");
static_assert(offsetof(FLinkedCollisionComp, bIsLinked) == 0x000008, "Member 'FLinkedCollisionComp::bIsLinked' has a wrong offset!");
static_assert(offsetof(FLinkedCollisionComp, PrimitiveCompTag) == 0x000010, "Member 'FLinkedCollisionComp::PrimitiveCompTag' has a wrong offset!");
static_assert(offsetof(FLinkedCollisionComp, LinkedPrimitiveTag) == 0x000018, "Member 'FLinkedCollisionComp::LinkedPrimitiveTag' has a wrong offset!");

// ScriptStruct OrionGame.ArcadeRoundState
// 0x0018 (0x0018 - 0x0000)
struct FArcadeRoundState final
{
public:
	EArcadeRoundPhase                             RoundPhase;                                        // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RoundIndex;                                        // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ServerRoundEndTime;                                // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInOvertime;                                       // 0x000C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumberOfRestarts;                                  // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRestartedWithBuff;                                // 0x0014(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FArcadeRoundState) == 0x000004, "Wrong alignment on FArcadeRoundState");
static_assert(sizeof(FArcadeRoundState) == 0x000018, "Wrong size on FArcadeRoundState");
static_assert(offsetof(FArcadeRoundState, RoundPhase) == 0x000000, "Member 'FArcadeRoundState::RoundPhase' has a wrong offset!");
static_assert(offsetof(FArcadeRoundState, RoundIndex) == 0x000004, "Member 'FArcadeRoundState::RoundIndex' has a wrong offset!");
static_assert(offsetof(FArcadeRoundState, ServerRoundEndTime) == 0x000008, "Member 'FArcadeRoundState::ServerRoundEndTime' has a wrong offset!");
static_assert(offsetof(FArcadeRoundState, bInOvertime) == 0x00000C, "Member 'FArcadeRoundState::bInOvertime' has a wrong offset!");
static_assert(offsetof(FArcadeRoundState, NumberOfRestarts) == 0x000010, "Member 'FArcadeRoundState::NumberOfRestarts' has a wrong offset!");
static_assert(offsetof(FArcadeRoundState, bRestartedWithBuff) == 0x000014, "Member 'FArcadeRoundState::bRestartedWithBuff' has a wrong offset!");

// ScriptStruct OrionGame.OccludedShadowplaneTest
// 0x0028 (0x0028 - 0x0000)
struct FOccludedShadowplaneTest final
{
public:
	class AOrionCharHero*                         ActorToTest;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MaterialApplied;                                   // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<bool>                                  PointOccludedResult;                               // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOccludedShadowplaneTest) == 0x000008, "Wrong alignment on FOccludedShadowplaneTest");
static_assert(sizeof(FOccludedShadowplaneTest) == 0x000028, "Wrong size on FOccludedShadowplaneTest");
static_assert(offsetof(FOccludedShadowplaneTest, ActorToTest) == 0x000000, "Member 'FOccludedShadowplaneTest::ActorToTest' has a wrong offset!");
static_assert(offsetof(FOccludedShadowplaneTest, MaterialApplied) == 0x000008, "Member 'FOccludedShadowplaneTest::MaterialApplied' has a wrong offset!");
static_assert(offsetof(FOccludedShadowplaneTest, PointOccludedResult) == 0x000010, "Member 'FOccludedShadowplaneTest::PointOccludedResult' has a wrong offset!");

// ScriptStruct OrionGame.REGSQuestEntry
// 0x0028 (0x0028 - 0x0000)
struct FREGSQuestEntry final
{
public:
	class FString                                 QuestId;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RewardTemplate;                                    // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardQuantity;                                    // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RewardWon;                                         // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FREGSQuestEntry) == 0x000008, "Wrong alignment on FREGSQuestEntry");
static_assert(sizeof(FREGSQuestEntry) == 0x000028, "Wrong size on FREGSQuestEntry");
static_assert(offsetof(FREGSQuestEntry, QuestId) == 0x000000, "Member 'FREGSQuestEntry::QuestId' has a wrong offset!");
static_assert(offsetof(FREGSQuestEntry, RewardTemplate) == 0x000010, "Member 'FREGSQuestEntry::RewardTemplate' has a wrong offset!");
static_assert(offsetof(FREGSQuestEntry, RewardQuantity) == 0x000020, "Member 'FREGSQuestEntry::RewardQuantity' has a wrong offset!");
static_assert(offsetof(FREGSQuestEntry, RewardWon) == 0x000024, "Member 'FREGSQuestEntry::RewardWon' has a wrong offset!");

// ScriptStruct OrionGame.REGSQuestRecord
// 0x0020 (0x0020 - 0x0000)
struct FREGSQuestRecord final
{
public:
	TArray<struct FREGSQuestEntry>                QuestEntries;                                      // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDateTime                              NextRerollTime;                                    // 0x0010(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumQuestSetsRolled;                                // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FREGSQuestRecord) == 0x000008, "Wrong alignment on FREGSQuestRecord");
static_assert(sizeof(FREGSQuestRecord) == 0x000020, "Wrong size on FREGSQuestRecord");
static_assert(offsetof(FREGSQuestRecord, QuestEntries) == 0x000000, "Member 'FREGSQuestRecord::QuestEntries' has a wrong offset!");
static_assert(offsetof(FREGSQuestRecord, NextRerollTime) == 0x000010, "Member 'FREGSQuestRecord::NextRerollTime' has a wrong offset!");
static_assert(offsetof(FREGSQuestRecord, NumQuestSetsRolled) == 0x000018, "Member 'FREGSQuestRecord::NumQuestSetsRolled' has a wrong offset!");

// ScriptStruct OrionGame.GemRarityInfo
// 0x0040 (0x0040 - 0x0000)
struct FGemRarityInfo final
{
public:
	EOrionItemRarity                              GemRarity;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   RarityDisplayText;                                 // 0x0008(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   SizeDisplayText;                                   // 0x0020(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         LevelThreshold;                                    // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGemRarityInfo) == 0x000008, "Wrong alignment on FGemRarityInfo");
static_assert(sizeof(FGemRarityInfo) == 0x000040, "Wrong size on FGemRarityInfo");
static_assert(offsetof(FGemRarityInfo, GemRarity) == 0x000000, "Member 'FGemRarityInfo::GemRarity' has a wrong offset!");
static_assert(offsetof(FGemRarityInfo, RarityDisplayText) == 0x000008, "Member 'FGemRarityInfo::RarityDisplayText' has a wrong offset!");
static_assert(offsetof(FGemRarityInfo, SizeDisplayText) == 0x000020, "Member 'FGemRarityInfo::SizeDisplayText' has a wrong offset!");
static_assert(offsetof(FGemRarityInfo, LevelThreshold) == 0x000038, "Member 'FGemRarityInfo::LevelThreshold' has a wrong offset!");

// ScriptStruct OrionGame.GemBranchDisplayInfo
// 0x0060 (0x0060 - 0x0000)
struct FGemBranchDisplayInfo final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0018(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ShopDescription;                                   // 0x0030(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FLinearColor                           Tint;                                              // 0x0048(0x0010)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Icon;                                              // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGemBranchDisplayInfo) == 0x000008, "Wrong alignment on FGemBranchDisplayInfo");
static_assert(sizeof(FGemBranchDisplayInfo) == 0x000060, "Wrong size on FGemBranchDisplayInfo");
static_assert(offsetof(FGemBranchDisplayInfo, DisplayName) == 0x000000, "Member 'FGemBranchDisplayInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(FGemBranchDisplayInfo, Description) == 0x000018, "Member 'FGemBranchDisplayInfo::Description' has a wrong offset!");
static_assert(offsetof(FGemBranchDisplayInfo, ShopDescription) == 0x000030, "Member 'FGemBranchDisplayInfo::ShopDescription' has a wrong offset!");
static_assert(offsetof(FGemBranchDisplayInfo, Tint) == 0x000048, "Member 'FGemBranchDisplayInfo::Tint' has a wrong offset!");
static_assert(offsetof(FGemBranchDisplayInfo, Icon) == 0x000058, "Member 'FGemBranchDisplayInfo::Icon' has a wrong offset!");

// ScriptStruct OrionGame.GemRankImageData
// 0x0020 (0x0020 - 0x0000)
struct FGemRankImageData final
{
public:
	EOrionGemRank                                 Rank;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             DisplayIcon;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UTexture2D*>                     FancyImages;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGemRankImageData) == 0x000008, "Wrong alignment on FGemRankImageData");
static_assert(sizeof(FGemRankImageData) == 0x000020, "Wrong size on FGemRankImageData");
static_assert(offsetof(FGemRankImageData, Rank) == 0x000000, "Member 'FGemRankImageData::Rank' has a wrong offset!");
static_assert(offsetof(FGemRankImageData, DisplayIcon) == 0x000008, "Member 'FGemRankImageData::DisplayIcon' has a wrong offset!");
static_assert(offsetof(FGemRankImageData, FancyImages) == 0x000010, "Member 'FGemRankImageData::FancyImages' has a wrong offset!");

// ScriptStruct OrionGame.SavedViewTargetInfo
// 0x0018 (0x0018 - 0x0000)
struct FSavedViewTargetInfo final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSavedViewTargetInfo) == 0x000008, "Wrong alignment on FSavedViewTargetInfo");
static_assert(sizeof(FSavedViewTargetInfo) == 0x000018, "Wrong size on FSavedViewTargetInfo");
static_assert(offsetof(FSavedViewTargetInfo, Actor) == 0x000000, "Member 'FSavedViewTargetInfo::Actor' has a wrong offset!");

// ScriptStruct OrionGame.GemBranchImageData
// 0x0018 (0x0018 - 0x0000)
struct FGemBranchImageData final
{
public:
	EOrionGemBranchType                           Branch;                                            // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGemTypeImageData>              TypeImages;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGemBranchImageData) == 0x000008, "Wrong alignment on FGemBranchImageData");
static_assert(sizeof(FGemBranchImageData) == 0x000018, "Wrong size on FGemBranchImageData");
static_assert(offsetof(FGemBranchImageData, Branch) == 0x000000, "Member 'FGemBranchImageData::Branch' has a wrong offset!");
static_assert(offsetof(FGemBranchImageData, TypeImages) == 0x000008, "Member 'FGemBranchImageData::TypeImages' has a wrong offset!");

// ScriptStruct OrionGame.GemAbilityLevel_BaseProperty
// 0x0004 (0x0008 - 0x0004)
struct FGemAbilityLevel_BaseProperty final : public FGemAbilityLevel
{
public:
	ESimpleAbilityBaseProperty                    BaseProperty;                                      // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGemAbilityLevel_BaseProperty) == 0x000004, "Wrong alignment on FGemAbilityLevel_BaseProperty");
static_assert(sizeof(FGemAbilityLevel_BaseProperty) == 0x000008, "Wrong size on FGemAbilityLevel_BaseProperty");
static_assert(offsetof(FGemAbilityLevel_BaseProperty, BaseProperty) == 0x000004, "Member 'FGemAbilityLevel_BaseProperty::BaseProperty' has a wrong offset!");

// ScriptStruct OrionGame.GemAbilityLevel_Qualifier
// 0x000C (0x0010 - 0x0004)
struct FGemAbilityLevel_Qualifier final : public FGemAbilityLevel
{
public:
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayQualifierKeywordTag           QualifierKeyword;                                  // 0x0008(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGemAbilityLevel_Qualifier) == 0x000008, "Wrong alignment on FGemAbilityLevel_Qualifier");
static_assert(sizeof(FGemAbilityLevel_Qualifier) == 0x000010, "Wrong size on FGemAbilityLevel_Qualifier");
static_assert(offsetof(FGemAbilityLevel_Qualifier, QualifierKeyword) == 0x000008, "Member 'FGemAbilityLevel_Qualifier::QualifierKeyword' has a wrong offset!");

// ScriptStruct OrionGame.GemAbilityPropertyLevels
// 0x0038 (0x0038 - 0x0000)
struct FGemAbilityPropertyLevels final
{
public:
	struct FSimpleAbilityKeywordTag               AbilityKeyword;                                    // 0x0000(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGemAbilityLevel_BaseProperty>  BasePropertyLevels;                                // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGemAbilityLevel_Param>         ParamLevels;                                       // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGemAbilityLevel_Qualifier>     QualifierLevels;                                   // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGemAbilityPropertyLevels) == 0x000008, "Wrong alignment on FGemAbilityPropertyLevels");
static_assert(sizeof(FGemAbilityPropertyLevels) == 0x000038, "Wrong size on FGemAbilityPropertyLevels");
static_assert(offsetof(FGemAbilityPropertyLevels, AbilityKeyword) == 0x000000, "Member 'FGemAbilityPropertyLevels::AbilityKeyword' has a wrong offset!");
static_assert(offsetof(FGemAbilityPropertyLevels, BasePropertyLevels) == 0x000008, "Member 'FGemAbilityPropertyLevels::BasePropertyLevels' has a wrong offset!");
static_assert(offsetof(FGemAbilityPropertyLevels, ParamLevels) == 0x000018, "Member 'FGemAbilityPropertyLevels::ParamLevels' has a wrong offset!");
static_assert(offsetof(FGemAbilityPropertyLevels, QualifierLevels) == 0x000028, "Member 'FGemAbilityPropertyLevels::QualifierLevels' has a wrong offset!");

// ScriptStruct OrionGame.OrionStorefrontInfo
// 0x0038 (0x0038 - 0x0000)
struct FOrionStorefrontInfo final
{
public:
	class UTexture2D*                             StorefrontIcon;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Title;                                             // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionStorefrontInfo) == 0x000008, "Wrong alignment on FOrionStorefrontInfo");
static_assert(sizeof(FOrionStorefrontInfo) == 0x000038, "Wrong size on FOrionStorefrontInfo");
static_assert(offsetof(FOrionStorefrontInfo, StorefrontIcon) == 0x000000, "Member 'FOrionStorefrontInfo::StorefrontIcon' has a wrong offset!");
static_assert(offsetof(FOrionStorefrontInfo, Title) == 0x000008, "Member 'FOrionStorefrontInfo::Title' has a wrong offset!");
static_assert(offsetof(FOrionStorefrontInfo, Description) == 0x000020, "Member 'FOrionStorefrontInfo::Description' has a wrong offset!");

// ScriptStruct OrionGame.OrionGameGGPDef
// 0x0000 (0x00C0 - 0x00C0)
struct FOrionGameGGPDef final : public FGenericGameplayParameterDefinition
{
};
static_assert(alignof(FOrionGameGGPDef) == 0x000010, "Wrong alignment on FOrionGameGGPDef");
static_assert(sizeof(FOrionGameGGPDef) == 0x0000C0, "Wrong size on FOrionGameGGPDef");

// ScriptStruct OrionGame.BannerGravesiteCameraData
// 0x0078 (0x0078 - 0x0000)
struct FBannerGravesiteCameraData final
{
public:
	bool                                          bGravesiteCameraEnabled;                           // 0x0000(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraMoveTimeTotal;                               // 0x0004(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayOnDeathBannerCreation;                        // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayOnTowerBannerCreation;                        // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GlobalSpacePivotOffset;                            // 0x0010(0x000C)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalSpaceOffsetEye;                               // 0x001C(0x000C)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalSpaceTargetDistance;                          // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalSpaceOffsetTarget;                            // 0x002C(0x000C)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesiredFOV;                                        // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialTransMoveSpeedDivValue;                     // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialRotMoveSpeedDivValue;                       // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialFOVMoveSpeedDivValue;                       // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PortraitAndNameplateRangeMin;                      // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PortraitAndNameplateRangeMax;                      // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PortraitAndNameplateSecondsBetweenBannerTraces;    // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            LerpPosCurve;                                      // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            LerpRotCurve;                                      // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            LerpFOVCurve;                                      // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           TransMovementCurve;                                // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBannerGravesiteCameraData) == 0x000008, "Wrong alignment on FBannerGravesiteCameraData");
static_assert(sizeof(FBannerGravesiteCameraData) == 0x000078, "Wrong size on FBannerGravesiteCameraData");
static_assert(offsetof(FBannerGravesiteCameraData, bGravesiteCameraEnabled) == 0x000000, "Member 'FBannerGravesiteCameraData::bGravesiteCameraEnabled' has a wrong offset!");
static_assert(offsetof(FBannerGravesiteCameraData, CameraMoveTimeTotal) == 0x000004, "Member 'FBannerGravesiteCameraData::CameraMoveTimeTotal' has a wrong offset!");
static_assert(offsetof(FBannerGravesiteCameraData, DelayOnDeathBannerCreation) == 0x000008, "Member 'FBannerGravesiteCameraData::DelayOnDeathBannerCreation' has a wrong offset!");
static_assert(offsetof(FBannerGravesiteCameraData, DelayOnTowerBannerCreation) == 0x00000C, "Member 'FBannerGravesiteCameraData::DelayOnTowerBannerCreation' has a wrong offset!");
static_assert(offsetof(FBannerGravesiteCameraData, GlobalSpacePivotOffset) == 0x000010, "Member 'FBannerGravesiteCameraData::GlobalSpacePivotOffset' has a wrong offset!");
static_assert(offsetof(FBannerGravesiteCameraData, LocalSpaceOffsetEye) == 0x00001C, "Member 'FBannerGravesiteCameraData::LocalSpaceOffsetEye' has a wrong offset!");
static_assert(offsetof(FBannerGravesiteCameraData, LocalSpaceTargetDistance) == 0x000028, "Member 'FBannerGravesiteCameraData::LocalSpaceTargetDistance' has a wrong offset!");
static_assert(offsetof(FBannerGravesiteCameraData, LocalSpaceOffsetTarget) == 0x00002C, "Member 'FBannerGravesiteCameraData::LocalSpaceOffsetTarget' has a wrong offset!");
static_assert(offsetof(FBannerGravesiteCameraData, DesiredFOV) == 0x000038, "Member 'FBannerGravesiteCameraData::DesiredFOV' has a wrong offset!");
static_assert(offsetof(FBannerGravesiteCameraData, InitialTransMoveSpeedDivValue) == 0x00003C, "Member 'FBannerGravesiteCameraData::InitialTransMoveSpeedDivValue' has a wrong offset!");
static_assert(offsetof(FBannerGravesiteCameraData, InitialRotMoveSpeedDivValue) == 0x000040, "Member 'FBannerGravesiteCameraData::InitialRotMoveSpeedDivValue' has a wrong offset!");
static_assert(offsetof(FBannerGravesiteCameraData, InitialFOVMoveSpeedDivValue) == 0x000044, "Member 'FBannerGravesiteCameraData::InitialFOVMoveSpeedDivValue' has a wrong offset!");
static_assert(offsetof(FBannerGravesiteCameraData, PortraitAndNameplateRangeMin) == 0x000048, "Member 'FBannerGravesiteCameraData::PortraitAndNameplateRangeMin' has a wrong offset!");
static_assert(offsetof(FBannerGravesiteCameraData, PortraitAndNameplateRangeMax) == 0x00004C, "Member 'FBannerGravesiteCameraData::PortraitAndNameplateRangeMax' has a wrong offset!");
static_assert(offsetof(FBannerGravesiteCameraData, PortraitAndNameplateSecondsBetweenBannerTraces) == 0x000050, "Member 'FBannerGravesiteCameraData::PortraitAndNameplateSecondsBetweenBannerTraces' has a wrong offset!");
static_assert(offsetof(FBannerGravesiteCameraData, LerpPosCurve) == 0x000058, "Member 'FBannerGravesiteCameraData::LerpPosCurve' has a wrong offset!");
static_assert(offsetof(FBannerGravesiteCameraData, LerpRotCurve) == 0x000060, "Member 'FBannerGravesiteCameraData::LerpRotCurve' has a wrong offset!");
static_assert(offsetof(FBannerGravesiteCameraData, LerpFOVCurve) == 0x000068, "Member 'FBannerGravesiteCameraData::LerpFOVCurve' has a wrong offset!");
static_assert(offsetof(FBannerGravesiteCameraData, TransMovementCurve) == 0x000070, "Member 'FBannerGravesiteCameraData::TransMovementCurve' has a wrong offset!");

// ScriptStruct OrionGame.OrionDeveloperAttributeOverride
// 0x0030 (0x0030 - 0x0000)
struct FOrionDeveloperAttributeOverride final
{
public:
	class FName                                   CharacterDataName;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     Attribute;                                         // 0x0008(0x0020)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewValue;                                          // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionDeveloperAttributeOverride) == 0x000008, "Wrong alignment on FOrionDeveloperAttributeOverride");
static_assert(sizeof(FOrionDeveloperAttributeOverride) == 0x000030, "Wrong size on FOrionDeveloperAttributeOverride");
static_assert(offsetof(FOrionDeveloperAttributeOverride, CharacterDataName) == 0x000000, "Member 'FOrionDeveloperAttributeOverride::CharacterDataName' has a wrong offset!");
static_assert(offsetof(FOrionDeveloperAttributeOverride, Attribute) == 0x000008, "Member 'FOrionDeveloperAttributeOverride::Attribute' has a wrong offset!");
static_assert(offsetof(FOrionDeveloperAttributeOverride, NewValue) == 0x000028, "Member 'FOrionDeveloperAttributeOverride::NewValue' has a wrong offset!");

// ScriptStruct OrionGame.OrionDeveloperUIToggles
// 0x0007 (0x0007 - 0x0000)
struct FOrionDeveloperUIToggles final
{
public:
	bool                                          bDisableHUD;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableIndicators;                                // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableHealthAndStatus;                           // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableAbilityWidgets;                            // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableTeamInfo;                                  // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableEnemyInfo;                                 // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableMiniMap;                                   // 0x0006(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionDeveloperUIToggles) == 0x000001, "Wrong alignment on FOrionDeveloperUIToggles");
static_assert(sizeof(FOrionDeveloperUIToggles) == 0x000007, "Wrong size on FOrionDeveloperUIToggles");
static_assert(offsetof(FOrionDeveloperUIToggles, bDisableHUD) == 0x000000, "Member 'FOrionDeveloperUIToggles::bDisableHUD' has a wrong offset!");
static_assert(offsetof(FOrionDeveloperUIToggles, bDisableIndicators) == 0x000001, "Member 'FOrionDeveloperUIToggles::bDisableIndicators' has a wrong offset!");
static_assert(offsetof(FOrionDeveloperUIToggles, bDisableHealthAndStatus) == 0x000002, "Member 'FOrionDeveloperUIToggles::bDisableHealthAndStatus' has a wrong offset!");
static_assert(offsetof(FOrionDeveloperUIToggles, bDisableAbilityWidgets) == 0x000003, "Member 'FOrionDeveloperUIToggles::bDisableAbilityWidgets' has a wrong offset!");
static_assert(offsetof(FOrionDeveloperUIToggles, bDisableTeamInfo) == 0x000004, "Member 'FOrionDeveloperUIToggles::bDisableTeamInfo' has a wrong offset!");
static_assert(offsetof(FOrionDeveloperUIToggles, bDisableEnemyInfo) == 0x000005, "Member 'FOrionDeveloperUIToggles::bDisableEnemyInfo' has a wrong offset!");
static_assert(offsetof(FOrionDeveloperUIToggles, bDisableMiniMap) == 0x000006, "Member 'FOrionDeveloperUIToggles::bDisableMiniMap' has a wrong offset!");

// ScriptStruct OrionGame.GravesiteActivationData
// 0x0020 (0x0020 - 0x0000)
struct FGravesiteActivationData final
{
public:
	struct FVector                                DestLocation;                                      // 0x0000(0x000C)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TriggerPos;                                        // 0x000C(0x000C)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabledForFriends;                                // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabledForEnemies;                                // 0x0019(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    VictimTeam;                                        // 0x001A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    KillerTeam;                                        // 0x001B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EntranceDelay;                                     // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGravesiteActivationData) == 0x000004, "Wrong alignment on FGravesiteActivationData");
static_assert(sizeof(FGravesiteActivationData) == 0x000020, "Wrong size on FGravesiteActivationData");
static_assert(offsetof(FGravesiteActivationData, DestLocation) == 0x000000, "Member 'FGravesiteActivationData::DestLocation' has a wrong offset!");
static_assert(offsetof(FGravesiteActivationData, TriggerPos) == 0x00000C, "Member 'FGravesiteActivationData::TriggerPos' has a wrong offset!");
static_assert(offsetof(FGravesiteActivationData, bEnabledForFriends) == 0x000018, "Member 'FGravesiteActivationData::bEnabledForFriends' has a wrong offset!");
static_assert(offsetof(FGravesiteActivationData, bEnabledForEnemies) == 0x000019, "Member 'FGravesiteActivationData::bEnabledForEnemies' has a wrong offset!");
static_assert(offsetof(FGravesiteActivationData, VictimTeam) == 0x00001A, "Member 'FGravesiteActivationData::VictimTeam' has a wrong offset!");
static_assert(offsetof(FGravesiteActivationData, KillerTeam) == 0x00001B, "Member 'FGravesiteActivationData::KillerTeam' has a wrong offset!");
static_assert(offsetof(FGravesiteActivationData, EntranceDelay) == 0x00001C, "Member 'FGravesiteActivationData::EntranceDelay' has a wrong offset!");

// ScriptStruct OrionGame.OrionGravesiteCues
// 0x0030 (0x0030 - 0x0000)
struct FOrionGravesiteCues final
{
public:
	struct FGameplayCueTag                        Initial;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        Timeout;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        PlayerOn;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        Activated;                                         // 0x0018(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        PlayerOff;                                         // 0x0020(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        BannerRaised;                                      // 0x0028(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionGravesiteCues) == 0x000008, "Wrong alignment on FOrionGravesiteCues");
static_assert(sizeof(FOrionGravesiteCues) == 0x000030, "Wrong size on FOrionGravesiteCues");
static_assert(offsetof(FOrionGravesiteCues, Initial) == 0x000000, "Member 'FOrionGravesiteCues::Initial' has a wrong offset!");
static_assert(offsetof(FOrionGravesiteCues, Timeout) == 0x000008, "Member 'FOrionGravesiteCues::Timeout' has a wrong offset!");
static_assert(offsetof(FOrionGravesiteCues, PlayerOn) == 0x000010, "Member 'FOrionGravesiteCues::PlayerOn' has a wrong offset!");
static_assert(offsetof(FOrionGravesiteCues, Activated) == 0x000018, "Member 'FOrionGravesiteCues::Activated' has a wrong offset!");
static_assert(offsetof(FOrionGravesiteCues, PlayerOff) == 0x000020, "Member 'FOrionGravesiteCues::PlayerOff' has a wrong offset!");
static_assert(offsetof(FOrionGravesiteCues, BannerRaised) == 0x000028, "Member 'FOrionGravesiteCues::BannerRaised' has a wrong offset!");

// ScriptStruct OrionGame.OrionHeroStatusFlags
// 0x0009 (0x0009 - 0x0000)
struct FOrionHeroStatusFlags final
{
public:
	bool                                          bIsKnockedBack;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsKnockedUp;                                      // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsStunned;                                        // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRecalling;                                      // 0x0003(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTravelMode;                                     // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRootMotionIsKnockbackLike;                        // 0x0005(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableStun;                                      // 0x0006(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInCombat;                                       // 0x0007(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDoingHitReact;                                  // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionHeroStatusFlags) == 0x000001, "Wrong alignment on FOrionHeroStatusFlags");
static_assert(sizeof(FOrionHeroStatusFlags) == 0x000009, "Wrong size on FOrionHeroStatusFlags");
static_assert(offsetof(FOrionHeroStatusFlags, bIsKnockedBack) == 0x000000, "Member 'FOrionHeroStatusFlags::bIsKnockedBack' has a wrong offset!");
static_assert(offsetof(FOrionHeroStatusFlags, bIsKnockedUp) == 0x000001, "Member 'FOrionHeroStatusFlags::bIsKnockedUp' has a wrong offset!");
static_assert(offsetof(FOrionHeroStatusFlags, bIsStunned) == 0x000002, "Member 'FOrionHeroStatusFlags::bIsStunned' has a wrong offset!");
static_assert(offsetof(FOrionHeroStatusFlags, bIsRecalling) == 0x000003, "Member 'FOrionHeroStatusFlags::bIsRecalling' has a wrong offset!");
static_assert(offsetof(FOrionHeroStatusFlags, bIsTravelMode) == 0x000004, "Member 'FOrionHeroStatusFlags::bIsTravelMode' has a wrong offset!");
static_assert(offsetof(FOrionHeroStatusFlags, bRootMotionIsKnockbackLike) == 0x000005, "Member 'FOrionHeroStatusFlags::bRootMotionIsKnockbackLike' has a wrong offset!");
static_assert(offsetof(FOrionHeroStatusFlags, bDisableStun) == 0x000006, "Member 'FOrionHeroStatusFlags::bDisableStun' has a wrong offset!");
static_assert(offsetof(FOrionHeroStatusFlags, bIsInCombat) == 0x000007, "Member 'FOrionHeroStatusFlags::bIsInCombat' has a wrong offset!");
static_assert(offsetof(FOrionHeroStatusFlags, bIsDoingHitReact) == 0x000008, "Member 'FOrionHeroStatusFlags::bIsDoingHitReact' has a wrong offset!");

// ScriptStruct OrionGame.OrionHeroAllowedTransitions
// 0x0007 (0x0007 - 0x0000)
struct FOrionHeroAllowedTransitions final
{
public:
	bool                                          bAllowStartTransition;                             // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowStopTransition;                              // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowPivotTransition;                             // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowSpinTransition;                              // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowTurnInPlaceTransition;                       // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowJumpTransition;                              // 0x0005(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDo180LookAround;                                  // 0x0006(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionHeroAllowedTransitions) == 0x000001, "Wrong alignment on FOrionHeroAllowedTransitions");
static_assert(sizeof(FOrionHeroAllowedTransitions) == 0x000007, "Wrong size on FOrionHeroAllowedTransitions");
static_assert(offsetof(FOrionHeroAllowedTransitions, bAllowStartTransition) == 0x000000, "Member 'FOrionHeroAllowedTransitions::bAllowStartTransition' has a wrong offset!");
static_assert(offsetof(FOrionHeroAllowedTransitions, bAllowStopTransition) == 0x000001, "Member 'FOrionHeroAllowedTransitions::bAllowStopTransition' has a wrong offset!");
static_assert(offsetof(FOrionHeroAllowedTransitions, bAllowPivotTransition) == 0x000002, "Member 'FOrionHeroAllowedTransitions::bAllowPivotTransition' has a wrong offset!");
static_assert(offsetof(FOrionHeroAllowedTransitions, bAllowSpinTransition) == 0x000003, "Member 'FOrionHeroAllowedTransitions::bAllowSpinTransition' has a wrong offset!");
static_assert(offsetof(FOrionHeroAllowedTransitions, bAllowTurnInPlaceTransition) == 0x000004, "Member 'FOrionHeroAllowedTransitions::bAllowTurnInPlaceTransition' has a wrong offset!");
static_assert(offsetof(FOrionHeroAllowedTransitions, bAllowJumpTransition) == 0x000005, "Member 'FOrionHeroAllowedTransitions::bAllowJumpTransition' has a wrong offset!");
static_assert(offsetof(FOrionHeroAllowedTransitions, bDo180LookAround) == 0x000006, "Member 'FOrionHeroAllowedTransitions::bDo180LookAround' has a wrong offset!");

// ScriptStruct OrionGame.OrionHeroSpinAnimSet
// 0x0020 (0x0020 - 0x0000)
struct FOrionHeroSpinAnimSet final
{
public:
	class UAnimSequenceBase*                      SpinNorth2South_CW_Anim;                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      SpinNorth2South_CCW_Anim;                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      SpinSouth2North_CW_Anim;                           // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      SpinSouth2North_CCW_Anim;                          // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionHeroSpinAnimSet) == 0x000008, "Wrong alignment on FOrionHeroSpinAnimSet");
static_assert(sizeof(FOrionHeroSpinAnimSet) == 0x000020, "Wrong size on FOrionHeroSpinAnimSet");
static_assert(offsetof(FOrionHeroSpinAnimSet, SpinNorth2South_CW_Anim) == 0x000000, "Member 'FOrionHeroSpinAnimSet::SpinNorth2South_CW_Anim' has a wrong offset!");
static_assert(offsetof(FOrionHeroSpinAnimSet, SpinNorth2South_CCW_Anim) == 0x000008, "Member 'FOrionHeroSpinAnimSet::SpinNorth2South_CCW_Anim' has a wrong offset!");
static_assert(offsetof(FOrionHeroSpinAnimSet, SpinSouth2North_CW_Anim) == 0x000010, "Member 'FOrionHeroSpinAnimSet::SpinSouth2North_CW_Anim' has a wrong offset!");
static_assert(offsetof(FOrionHeroSpinAnimSet, SpinSouth2North_CCW_Anim) == 0x000018, "Member 'FOrionHeroSpinAnimSet::SpinSouth2North_CCW_Anim' has a wrong offset!");

// ScriptStruct OrionGame.OrionHeroJumpAnimSet
// 0x0028 (0x0028 - 0x0000)
struct FOrionHeroJumpAnimSet final
{
public:
	class UAnimSequenceBase*                      Start;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Arc;                                               // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      PreLand;                                           // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      PostLand;                                          // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      PostLandAdditive;                                  // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionHeroJumpAnimSet) == 0x000008, "Wrong alignment on FOrionHeroJumpAnimSet");
static_assert(sizeof(FOrionHeroJumpAnimSet) == 0x000028, "Wrong size on FOrionHeroJumpAnimSet");
static_assert(offsetof(FOrionHeroJumpAnimSet, Start) == 0x000000, "Member 'FOrionHeroJumpAnimSet::Start' has a wrong offset!");
static_assert(offsetof(FOrionHeroJumpAnimSet, Arc) == 0x000008, "Member 'FOrionHeroJumpAnimSet::Arc' has a wrong offset!");
static_assert(offsetof(FOrionHeroJumpAnimSet, PreLand) == 0x000010, "Member 'FOrionHeroJumpAnimSet::PreLand' has a wrong offset!");
static_assert(offsetof(FOrionHeroJumpAnimSet, PostLand) == 0x000018, "Member 'FOrionHeroJumpAnimSet::PostLand' has a wrong offset!");
static_assert(offsetof(FOrionHeroJumpAnimSet, PostLandAdditive) == 0x000020, "Member 'FOrionHeroJumpAnimSet::PostLandAdditive' has a wrong offset!");

// ScriptStruct OrionGame.OrionHeroAnimData
// 0x0100 (0x0100 - 0x0000)
struct FOrionHeroAnimData final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJustTeleported;                                   // 0x0004(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOnGround;                                       // 0x0005(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMovementFalling;                                // 0x0006(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasRootMotionSources;                             // 0x0007(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLocalPlayerController;                          // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             MeshLocalToWorld;                                  // 0x0010(0x0030)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             LocalToWorld;                                      // 0x0040(0x0030)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0070(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldAccel;                                        // 0x007C(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalAccel;                                        // 0x0088(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAccel;                                          // 0x0094(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelMagnitude2D;                                  // 0x0098(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalAccelYawAngle;                                // 0x009C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAccelerating2D;                                 // 0x00A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WorldVelocity;                                     // 0x00A4(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalVelocity;                                     // 0x00B0(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x00BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed2D;                                           // 0x00C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedPercent;                                      // 0x00C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalVelocityYawAngle;                             // 0x00C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMoving2D;                                       // 0x00CC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  DeltaMeshRotation;                                 // 0x00D0(0x0010)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TurnDeltaYaw;                                      // 0x00E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnDeltaSpeedAverage;                             // 0x00E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnDeltaSpeedAverageAbs;                          // 0x00E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnDeltaSpeedAverageSign;                         // 0x00EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTurning;                                        // 0x00F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GravityZ;                                          // 0x00F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsJumpingUp;                                      // 0x00F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsJumpingDown;                                    // 0x00F9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSyncGroupIsBetweenMarkers;                        // 0x00FA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsForcedFacingForward;                            // 0x00FB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionHeroAnimData) == 0x000010, "Wrong alignment on FOrionHeroAnimData");
static_assert(sizeof(FOrionHeroAnimData) == 0x000100, "Wrong size on FOrionHeroAnimData");
static_assert(offsetof(FOrionHeroAnimData, DeltaSeconds) == 0x000000, "Member 'FOrionHeroAnimData::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(FOrionHeroAnimData, bJustTeleported) == 0x000004, "Member 'FOrionHeroAnimData::bJustTeleported' has a wrong offset!");
static_assert(offsetof(FOrionHeroAnimData, bIsOnGround) == 0x000005, "Member 'FOrionHeroAnimData::bIsOnGround' has a wrong offset!");
static_assert(offsetof(FOrionHeroAnimData, bIsMovementFalling) == 0x000006, "Member 'FOrionHeroAnimData::bIsMovementFalling' has a wrong offset!");
static_assert(offsetof(FOrionHeroAnimData, bHasRootMotionSources) == 0x000007, "Member 'FOrionHeroAnimData::bHasRootMotionSources' has a wrong offset!");
static_assert(offsetof(FOrionHeroAnimData, bIsLocalPlayerController) == 0x000008, "Member 'FOrionHeroAnimData::bIsLocalPlayerController' has a wrong offset!");
static_assert(offsetof(FOrionHeroAnimData, MeshLocalToWorld) == 0x000010, "Member 'FOrionHeroAnimData::MeshLocalToWorld' has a wrong offset!");
static_assert(offsetof(FOrionHeroAnimData, LocalToWorld) == 0x000040, "Member 'FOrionHeroAnimData::LocalToWorld' has a wrong offset!");
static_assert(offsetof(FOrionHeroAnimData, Location) == 0x000070, "Member 'FOrionHeroAnimData::Location' has a wrong offset!");
static_assert(offsetof(FOrionHeroAnimData, WorldAccel) == 0x00007C, "Member 'FOrionHeroAnimData::WorldAccel' has a wrong offset!");
static_assert(offsetof(FOrionHeroAnimData, LocalAccel) == 0x000088, "Member 'FOrionHeroAnimData::LocalAccel' has a wrong offset!");
static_assert(offsetof(FOrionHeroAnimData, MaxAccel) == 0x000094, "Member 'FOrionHeroAnimData::MaxAccel' has a wrong offset!");
static_assert(offsetof(FOrionHeroAnimData, AccelMagnitude2D) == 0x000098, "Member 'FOrionHeroAnimData::AccelMagnitude2D' has a wrong offset!");
static_assert(offsetof(FOrionHeroAnimData, LocalAccelYawAngle) == 0x00009C, "Member 'FOrionHeroAnimData::LocalAccelYawAngle' has a wrong offset!");
static_assert(offsetof(FOrionHeroAnimData, bIsAccelerating2D) == 0x0000A0, "Member 'FOrionHeroAnimData::bIsAccelerating2D' has a wrong offset!");
static_assert(offsetof(FOrionHeroAnimData, WorldVelocity) == 0x0000A4, "Member 'FOrionHeroAnimData::WorldVelocity' has a wrong offset!");
static_assert(offsetof(FOrionHeroAnimData, LocalVelocity) == 0x0000B0, "Member 'FOrionHeroAnimData::LocalVelocity' has a wrong offset!");
static_assert(offsetof(FOrionHeroAnimData, MaxSpeed) == 0x0000BC, "Member 'FOrionHeroAnimData::MaxSpeed' has a wrong offset!");
static_assert(offsetof(FOrionHeroAnimData, Speed2D) == 0x0000C0, "Member 'FOrionHeroAnimData::Speed2D' has a wrong offset!");
static_assert(offsetof(FOrionHeroAnimData, SpeedPercent) == 0x0000C4, "Member 'FOrionHeroAnimData::SpeedPercent' has a wrong offset!");
static_assert(offsetof(FOrionHeroAnimData, LocalVelocityYawAngle) == 0x0000C8, "Member 'FOrionHeroAnimData::LocalVelocityYawAngle' has a wrong offset!");
static_assert(offsetof(FOrionHeroAnimData, bIsMoving2D) == 0x0000CC, "Member 'FOrionHeroAnimData::bIsMoving2D' has a wrong offset!");
static_assert(offsetof(FOrionHeroAnimData, DeltaMeshRotation) == 0x0000D0, "Member 'FOrionHeroAnimData::DeltaMeshRotation' has a wrong offset!");
static_assert(offsetof(FOrionHeroAnimData, TurnDeltaYaw) == 0x0000E0, "Member 'FOrionHeroAnimData::TurnDeltaYaw' has a wrong offset!");
static_assert(offsetof(FOrionHeroAnimData, TurnDeltaSpeedAverage) == 0x0000E4, "Member 'FOrionHeroAnimData::TurnDeltaSpeedAverage' has a wrong offset!");
static_assert(offsetof(FOrionHeroAnimData, TurnDeltaSpeedAverageAbs) == 0x0000E8, "Member 'FOrionHeroAnimData::TurnDeltaSpeedAverageAbs' has a wrong offset!");
static_assert(offsetof(FOrionHeroAnimData, TurnDeltaSpeedAverageSign) == 0x0000EC, "Member 'FOrionHeroAnimData::TurnDeltaSpeedAverageSign' has a wrong offset!");
static_assert(offsetof(FOrionHeroAnimData, bIsTurning) == 0x0000F0, "Member 'FOrionHeroAnimData::bIsTurning' has a wrong offset!");
static_assert(offsetof(FOrionHeroAnimData, GravityZ) == 0x0000F4, "Member 'FOrionHeroAnimData::GravityZ' has a wrong offset!");
static_assert(offsetof(FOrionHeroAnimData, bIsJumpingUp) == 0x0000F8, "Member 'FOrionHeroAnimData::bIsJumpingUp' has a wrong offset!");
static_assert(offsetof(FOrionHeroAnimData, bIsJumpingDown) == 0x0000F9, "Member 'FOrionHeroAnimData::bIsJumpingDown' has a wrong offset!");
static_assert(offsetof(FOrionHeroAnimData, bSyncGroupIsBetweenMarkers) == 0x0000FA, "Member 'FOrionHeroAnimData::bSyncGroupIsBetweenMarkers' has a wrong offset!");
static_assert(offsetof(FOrionHeroAnimData, bIsForcedFacingForward) == 0x0000FB, "Member 'FOrionHeroAnimData::bIsForcedFacingForward' has a wrong offset!");

// ScriptStruct OrionGame.OrionHeroCapsuleAnimData
// 0x0060 (0x0060 - 0x0000)
struct FOrionHeroCapsuleAnimData final
{
public:
	struct FTransform                             LocalToWorld;                                      // 0x0000(0x0030)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0030(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldVelocity;                                     // 0x003C(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldAccel;                                        // 0x0048(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0xC];                                       // 0x0054(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionHeroCapsuleAnimData) == 0x000010, "Wrong alignment on FOrionHeroCapsuleAnimData");
static_assert(sizeof(FOrionHeroCapsuleAnimData) == 0x000060, "Wrong size on FOrionHeroCapsuleAnimData");
static_assert(offsetof(FOrionHeroCapsuleAnimData, LocalToWorld) == 0x000000, "Member 'FOrionHeroCapsuleAnimData::LocalToWorld' has a wrong offset!");
static_assert(offsetof(FOrionHeroCapsuleAnimData, Location) == 0x000030, "Member 'FOrionHeroCapsuleAnimData::Location' has a wrong offset!");
static_assert(offsetof(FOrionHeroCapsuleAnimData, WorldVelocity) == 0x00003C, "Member 'FOrionHeroCapsuleAnimData::WorldVelocity' has a wrong offset!");
static_assert(offsetof(FOrionHeroCapsuleAnimData, WorldAccel) == 0x000048, "Member 'FOrionHeroCapsuleAnimData::WorldAccel' has a wrong offset!");

// ScriptStruct OrionGame.OrionHeroDialogCueEntry
// 0x0030 (0x0030 - 0x0000)
struct FOrionHeroDialogCueEntry final
{
public:
	class FString                                 DialogEventID;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        TagIdent;                                          // 0x0010(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class USoundBase*                             SoundCue;                                          // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPlayFrequency;                                  // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayCueEvent                             EventTriggerType;                                  // 0x0024(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0xB];                                       // 0x0025(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionHeroDialogCueEntry) == 0x000008, "Wrong alignment on FOrionHeroDialogCueEntry");
static_assert(sizeof(FOrionHeroDialogCueEntry) == 0x000030, "Wrong size on FOrionHeroDialogCueEntry");
static_assert(offsetof(FOrionHeroDialogCueEntry, DialogEventID) == 0x000000, "Member 'FOrionHeroDialogCueEntry::DialogEventID' has a wrong offset!");
static_assert(offsetof(FOrionHeroDialogCueEntry, TagIdent) == 0x000010, "Member 'FOrionHeroDialogCueEntry::TagIdent' has a wrong offset!");
static_assert(offsetof(FOrionHeroDialogCueEntry, SoundCue) == 0x000018, "Member 'FOrionHeroDialogCueEntry::SoundCue' has a wrong offset!");
static_assert(offsetof(FOrionHeroDialogCueEntry, MaxPlayFrequency) == 0x000020, "Member 'FOrionHeroDialogCueEntry::MaxPlayFrequency' has a wrong offset!");
static_assert(offsetof(FOrionHeroDialogCueEntry, EventTriggerType) == 0x000024, "Member 'FOrionHeroDialogCueEntry::EventTriggerType' has a wrong offset!");

// ScriptStruct OrionGame.OrionHeroDialogAudioControl
// 0x0080 (0x0080 - 0x0000)
struct alignas(0x10) FOrionHeroDialogAudioControl final
{
public:
	TArray<class FString>                         DialogEventIDS;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EGameplayCueEvent                             DefaultTriggerType;                                // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOrionHeroDialogCueEntry>       TagsToHandle;                                      // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x58];                                      // 0x0028(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionHeroDialogAudioControl) == 0x000010, "Wrong alignment on FOrionHeroDialogAudioControl");
static_assert(sizeof(FOrionHeroDialogAudioControl) == 0x000080, "Wrong size on FOrionHeroDialogAudioControl");
static_assert(offsetof(FOrionHeroDialogAudioControl, DialogEventIDS) == 0x000000, "Member 'FOrionHeroDialogAudioControl::DialogEventIDS' has a wrong offset!");
static_assert(offsetof(FOrionHeroDialogAudioControl, DefaultTriggerType) == 0x000010, "Member 'FOrionHeroDialogAudioControl::DefaultTriggerType' has a wrong offset!");
static_assert(offsetof(FOrionHeroDialogAudioControl, TagsToHandle) == 0x000018, "Member 'FOrionHeroDialogAudioControl::TagsToHandle' has a wrong offset!");

// ScriptStruct OrionGame.ArcadeEffectEvent
// 0x0018 (0x0018 - 0x0000)
struct FArcadeEffectEvent final
{
public:
	class AOrionPlayerState_Arcade*               PlayerState;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            GameplayEffect;                                    // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Level;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoved;                                          // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FArcadeEffectEvent) == 0x000008, "Wrong alignment on FArcadeEffectEvent");
static_assert(sizeof(FArcadeEffectEvent) == 0x000018, "Wrong size on FArcadeEffectEvent");
static_assert(offsetof(FArcadeEffectEvent, PlayerState) == 0x000000, "Member 'FArcadeEffectEvent::PlayerState' has a wrong offset!");
static_assert(offsetof(FArcadeEffectEvent, GameplayEffect) == 0x000008, "Member 'FArcadeEffectEvent::GameplayEffect' has a wrong offset!");
static_assert(offsetof(FArcadeEffectEvent, Level) == 0x000010, "Member 'FArcadeEffectEvent::Level' has a wrong offset!");
static_assert(offsetof(FArcadeEffectEvent, bRemoved) == 0x000014, "Member 'FArcadeEffectEvent::bRemoved' has a wrong offset!");

// ScriptStruct OrionGame.OrionDamageNumberStyleData
// 0x0170 (0x0170 - 0x0000)
struct FOrionDamageNumberStyleData final
{
public:
	EOrionDamageNumberType                        DamageNumberType;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFont*                                  DamageNumberFont;                                  // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            IsPlayingOutro;                                    // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveVector*                           DistanceAlongPathOverTime;                         // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            ScaleOverTimeCurve;                                // 0x0020(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            ScaleOverDistanceFromPlayerCurve;                  // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            ScaleOverMagnitudeCurve;                           // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveLinearColor*                      ColorOverTimeCurve;                                // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveLinearColor*                      DropShadowColorOverTimeCurve;                      // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              DropShadowOffset;                                  // 0x0048(0x0008)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveLinearColor*                      GlowColorOverTimeCurve;                            // 0x0050(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              MotionVector;                                      // 0x0058(0x0008)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              MotionVectorRandMagnitude;                         // 0x0060(0x0008)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSlateBrush                            PrefixImage;                                       // 0x0068(0x0078)(Deprecated, NativeAccessSpecifierPrivate)
	struct FSlateBrush                            SuffixImage;                                       // 0x00E0(0x0078)(Deprecated, NativeAccessSpecifierPrivate)
	class UMaterial*                              PortraitMaterial;                                  // 0x0158(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GlowSize;                                          // 0x0160(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AggregationAgeSeconds;                             // 0x0164(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTetheredToActor;                                  // 0x0168(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_169[0x2];                                      // 0x0169(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDrawIfTarget;                                     // 0x016B(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDrawIfInstigator;                                 // 0x016C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDrawIfOnSameTeam;                                 // 0x016D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAlwaysDraw;                                       // 0x016E(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_16F[0x1];                                      // 0x016F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionDamageNumberStyleData) == 0x000008, "Wrong alignment on FOrionDamageNumberStyleData");
static_assert(sizeof(FOrionDamageNumberStyleData) == 0x000170, "Wrong size on FOrionDamageNumberStyleData");
static_assert(offsetof(FOrionDamageNumberStyleData, DamageNumberType) == 0x000000, "Member 'FOrionDamageNumberStyleData::DamageNumberType' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberStyleData, DamageNumberFont) == 0x000008, "Member 'FOrionDamageNumberStyleData::DamageNumberFont' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberStyleData, IsPlayingOutro) == 0x000010, "Member 'FOrionDamageNumberStyleData::IsPlayingOutro' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberStyleData, DistanceAlongPathOverTime) == 0x000018, "Member 'FOrionDamageNumberStyleData::DistanceAlongPathOverTime' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberStyleData, ScaleOverTimeCurve) == 0x000020, "Member 'FOrionDamageNumberStyleData::ScaleOverTimeCurve' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberStyleData, ScaleOverDistanceFromPlayerCurve) == 0x000028, "Member 'FOrionDamageNumberStyleData::ScaleOverDistanceFromPlayerCurve' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberStyleData, ScaleOverMagnitudeCurve) == 0x000030, "Member 'FOrionDamageNumberStyleData::ScaleOverMagnitudeCurve' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberStyleData, ColorOverTimeCurve) == 0x000038, "Member 'FOrionDamageNumberStyleData::ColorOverTimeCurve' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberStyleData, DropShadowColorOverTimeCurve) == 0x000040, "Member 'FOrionDamageNumberStyleData::DropShadowColorOverTimeCurve' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberStyleData, DropShadowOffset) == 0x000048, "Member 'FOrionDamageNumberStyleData::DropShadowOffset' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberStyleData, GlowColorOverTimeCurve) == 0x000050, "Member 'FOrionDamageNumberStyleData::GlowColorOverTimeCurve' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberStyleData, MotionVector) == 0x000058, "Member 'FOrionDamageNumberStyleData::MotionVector' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberStyleData, MotionVectorRandMagnitude) == 0x000060, "Member 'FOrionDamageNumberStyleData::MotionVectorRandMagnitude' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberStyleData, PrefixImage) == 0x000068, "Member 'FOrionDamageNumberStyleData::PrefixImage' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberStyleData, SuffixImage) == 0x0000E0, "Member 'FOrionDamageNumberStyleData::SuffixImage' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberStyleData, PortraitMaterial) == 0x000158, "Member 'FOrionDamageNumberStyleData::PortraitMaterial' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberStyleData, GlowSize) == 0x000160, "Member 'FOrionDamageNumberStyleData::GlowSize' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberStyleData, AggregationAgeSeconds) == 0x000164, "Member 'FOrionDamageNumberStyleData::AggregationAgeSeconds' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberStyleData, bTetheredToActor) == 0x000168, "Member 'FOrionDamageNumberStyleData::bTetheredToActor' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberStyleData, bDrawIfTarget) == 0x00016B, "Member 'FOrionDamageNumberStyleData::bDrawIfTarget' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberStyleData, bDrawIfInstigator) == 0x00016C, "Member 'FOrionDamageNumberStyleData::bDrawIfInstigator' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberStyleData, bDrawIfOnSameTeam) == 0x00016D, "Member 'FOrionDamageNumberStyleData::bDrawIfOnSameTeam' has a wrong offset!");
static_assert(offsetof(FOrionDamageNumberStyleData, bAlwaysDraw) == 0x00016E, "Member 'FOrionDamageNumberStyleData::bAlwaysDraw' has a wrong offset!");

// ScriptStruct OrionGame.SimpleItemAttributeModifierEffect
// 0x0028 (0x0028 - 0x0000)
struct FSimpleItemAttributeModifierEffect final
{
public:
	struct FGameplayAttribute                     Attribute;                                         // 0x0000(0x0020)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            GameplayEffect;                                    // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSimpleItemAttributeModifierEffect) == 0x000008, "Wrong alignment on FSimpleItemAttributeModifierEffect");
static_assert(sizeof(FSimpleItemAttributeModifierEffect) == 0x000028, "Wrong size on FSimpleItemAttributeModifierEffect");
static_assert(offsetof(FSimpleItemAttributeModifierEffect, Attribute) == 0x000000, "Member 'FSimpleItemAttributeModifierEffect::Attribute' has a wrong offset!");
static_assert(offsetof(FSimpleItemAttributeModifierEffect, GameplayEffect) == 0x000020, "Member 'FSimpleItemAttributeModifierEffect::GameplayEffect' has a wrong offset!");

// ScriptStruct OrionGame.OrionLobbyBuilderParams
// 0x0058 (0x0058 - 0x0000)
struct FOrionLobbyBuilderParams final
{
public:
	struct FUniqueNetIdRepl                       UserID;                                            // 0x0000(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ControllerId;                                      // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlaylistId;                                        // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CustomKey;                                         // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionMatchBotConfig                   BotConfig;                                         // 0x0030(0x0028)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionLobbyBuilderParams) == 0x000008, "Wrong alignment on FOrionLobbyBuilderParams");
static_assert(sizeof(FOrionLobbyBuilderParams) == 0x000058, "Wrong size on FOrionLobbyBuilderParams");
static_assert(offsetof(FOrionLobbyBuilderParams, UserID) == 0x000000, "Member 'FOrionLobbyBuilderParams::UserID' has a wrong offset!");
static_assert(offsetof(FOrionLobbyBuilderParams, ControllerId) == 0x000018, "Member 'FOrionLobbyBuilderParams::ControllerId' has a wrong offset!");
static_assert(offsetof(FOrionLobbyBuilderParams, PlaylistId) == 0x00001C, "Member 'FOrionLobbyBuilderParams::PlaylistId' has a wrong offset!");
static_assert(offsetof(FOrionLobbyBuilderParams, CustomKey) == 0x000020, "Member 'FOrionLobbyBuilderParams::CustomKey' has a wrong offset!");
static_assert(offsetof(FOrionLobbyBuilderParams, BotConfig) == 0x000030, "Member 'FOrionLobbyBuilderParams::BotConfig' has a wrong offset!");

// ScriptStruct OrionGame.OrionHeroAvailabilityInfo
// 0x0038 (0x0038 - 0x0000)
struct FOrionHeroAvailabilityInfo final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   MessageFormat;                                     // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	class UTexture2D*                             AvailabilityIcon;                                  // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionHeroAvailabilityInfo) == 0x000008, "Wrong alignment on FOrionHeroAvailabilityInfo");
static_assert(sizeof(FOrionHeroAvailabilityInfo) == 0x000038, "Wrong size on FOrionHeroAvailabilityInfo");
static_assert(offsetof(FOrionHeroAvailabilityInfo, DisplayName) == 0x000000, "Member 'FOrionHeroAvailabilityInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(FOrionHeroAvailabilityInfo, MessageFormat) == 0x000018, "Member 'FOrionHeroAvailabilityInfo::MessageFormat' has a wrong offset!");
static_assert(offsetof(FOrionHeroAvailabilityInfo, AvailabilityIcon) == 0x000030, "Member 'FOrionHeroAvailabilityInfo::AvailabilityIcon' has a wrong offset!");

// ScriptStruct OrionGame.OrionStarterDeckContextInfo
// 0x0038 (0x0038 - 0x0000)
struct FOrionStarterDeckContextInfo final
{
public:
	class FText                                   SubText;                                           // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	int32                                         GamesPlayed;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionStarterDeckContextInfo) == 0x000008, "Wrong alignment on FOrionStarterDeckContextInfo");
static_assert(sizeof(FOrionStarterDeckContextInfo) == 0x000038, "Wrong size on FOrionStarterDeckContextInfo");
static_assert(offsetof(FOrionStarterDeckContextInfo, SubText) == 0x000000, "Member 'FOrionStarterDeckContextInfo::SubText' has a wrong offset!");
static_assert(offsetof(FOrionStarterDeckContextInfo, Description) == 0x000018, "Member 'FOrionStarterDeckContextInfo::Description' has a wrong offset!");
static_assert(offsetof(FOrionStarterDeckContextInfo, GamesPlayed) == 0x000030, "Member 'FOrionStarterDeckContextInfo::GamesPlayed' has a wrong offset!");

// ScriptStruct OrionGame.CuratedCardData
// 0x0010 (0x0010 - 0x0000)
struct FCuratedCardData final
{
public:
	class UOrionMcpCardItemDefinition*            CardDefinition;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CardLevel;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCuratedCardData) == 0x000008, "Wrong alignment on FCuratedCardData");
static_assert(sizeof(FCuratedCardData) == 0x000010, "Wrong size on FCuratedCardData");
static_assert(offsetof(FCuratedCardData, CardDefinition) == 0x000000, "Member 'FCuratedCardData::CardDefinition' has a wrong offset!");
static_assert(offsetof(FCuratedCardData, CardLevel) == 0x000008, "Member 'FCuratedCardData::CardLevel' has a wrong offset!");

// ScriptStruct OrionGame.SimpleAbilityQualifierParameters
// 0x0120 (0x0138 - 0x0018)
struct FSimpleAbilityQualifierParameters final : public FGameplayQualifierParameters
{
public:
	struct FAutoExportScalableFloat               Var1AutoExport;                                    // 0x0018(0x0038)(Edit, NativeAccessSpecifierPublic)
	struct FAutoExportScalableFloat               Var2AutoExport;                                    // 0x0050(0x0038)(Edit, NativeAccessSpecifierPublic)
	struct FAutoExportScalableFloat               Var3AutoExport;                                    // 0x0088(0x0038)(Edit, NativeAccessSpecifierPublic)
	struct FScalableFloat                         Var1Curve;                                         // 0x00C0(0x0028)(NativeAccessSpecifierPrivate)
	struct FScalableFloat                         Var2Curve;                                         // 0x00E8(0x0028)(NativeAccessSpecifierPrivate)
	struct FScalableFloat                         Var3Curve;                                         // 0x0110(0x0028)(NativeAccessSpecifierPrivate)
};
static_assert(alignof(FSimpleAbilityQualifierParameters) == 0x000008, "Wrong alignment on FSimpleAbilityQualifierParameters");
static_assert(sizeof(FSimpleAbilityQualifierParameters) == 0x000138, "Wrong size on FSimpleAbilityQualifierParameters");
static_assert(offsetof(FSimpleAbilityQualifierParameters, Var1AutoExport) == 0x000018, "Member 'FSimpleAbilityQualifierParameters::Var1AutoExport' has a wrong offset!");
static_assert(offsetof(FSimpleAbilityQualifierParameters, Var2AutoExport) == 0x000050, "Member 'FSimpleAbilityQualifierParameters::Var2AutoExport' has a wrong offset!");
static_assert(offsetof(FSimpleAbilityQualifierParameters, Var3AutoExport) == 0x000088, "Member 'FSimpleAbilityQualifierParameters::Var3AutoExport' has a wrong offset!");
static_assert(offsetof(FSimpleAbilityQualifierParameters, Var1Curve) == 0x0000C0, "Member 'FSimpleAbilityQualifierParameters::Var1Curve' has a wrong offset!");
static_assert(offsetof(FSimpleAbilityQualifierParameters, Var2Curve) == 0x0000E8, "Member 'FSimpleAbilityQualifierParameters::Var2Curve' has a wrong offset!");
static_assert(offsetof(FSimpleAbilityQualifierParameters, Var3Curve) == 0x000110, "Member 'FSimpleAbilityQualifierParameters::Var3Curve' has a wrong offset!");

// ScriptStruct OrionGame.QualifiedSimpleAbilityEvent
// 0x0050 (0x0050 - 0x0000)
struct FQualifiedSimpleAbilityEvent final
{
public:
	struct FGameplayEventKeywordTag               EventKeyword;                                      // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FSimpleAbilityQualifierParameters> AbilityEventQualifiers;                            // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FGameplayQualifierAggregationWindow    AggregationWindow;                                 // 0x0018(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          AggregationWindowResetsOnPass;                     // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         ListenDuration;                                    // 0x0028(0x0028)(Edit, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FQualifiedSimpleAbilityEvent) == 0x000008, "Wrong alignment on FQualifiedSimpleAbilityEvent");
static_assert(sizeof(FQualifiedSimpleAbilityEvent) == 0x000050, "Wrong size on FQualifiedSimpleAbilityEvent");
static_assert(offsetof(FQualifiedSimpleAbilityEvent, EventKeyword) == 0x000000, "Member 'FQualifiedSimpleAbilityEvent::EventKeyword' has a wrong offset!");
static_assert(offsetof(FQualifiedSimpleAbilityEvent, AbilityEventQualifiers) == 0x000008, "Member 'FQualifiedSimpleAbilityEvent::AbilityEventQualifiers' has a wrong offset!");
static_assert(offsetof(FQualifiedSimpleAbilityEvent, AggregationWindow) == 0x000018, "Member 'FQualifiedSimpleAbilityEvent::AggregationWindow' has a wrong offset!");
static_assert(offsetof(FQualifiedSimpleAbilityEvent, AggregationWindowResetsOnPass) == 0x000020, "Member 'FQualifiedSimpleAbilityEvent::AggregationWindowResetsOnPass' has a wrong offset!");
static_assert(offsetof(FQualifiedSimpleAbilityEvent, ListenDuration) == 0x000028, "Member 'FQualifiedSimpleAbilityEvent::ListenDuration' has a wrong offset!");

// ScriptStruct OrionGame.KeywordBucketEntry
// 0x0010 (0x0010 - 0x0000)
struct FKeywordBucketEntry final
{
public:
	int32                                         EntryWeight;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSimpleAbilityKeywordTag               SimpleAbilityKeyword;                              // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKeywordBucketEntry) == 0x000008, "Wrong alignment on FKeywordBucketEntry");
static_assert(sizeof(FKeywordBucketEntry) == 0x000010, "Wrong size on FKeywordBucketEntry");
static_assert(offsetof(FKeywordBucketEntry, EntryWeight) == 0x000000, "Member 'FKeywordBucketEntry::EntryWeight' has a wrong offset!");
static_assert(offsetof(FKeywordBucketEntry, SimpleAbilityKeyword) == 0x000008, "Member 'FKeywordBucketEntry::SimpleAbilityKeyword' has a wrong offset!");

// ScriptStruct OrionGame.OrionObjectiveItem
// 0x0030 (0x0030 - 0x0000)
struct FOrionObjectiveItem final
{
public:
	struct FGameplayStatTag                       GameplayStat;                                      // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ObjectiveBackendName;                              // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StatName;                                          // 0x0018(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ObjectiveCompletedEventName;                       // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentValue;                                      // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCompleted;                                        // 0x002C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionObjectiveItem) == 0x000008, "Wrong alignment on FOrionObjectiveItem");
static_assert(sizeof(FOrionObjectiveItem) == 0x000030, "Wrong size on FOrionObjectiveItem");
static_assert(offsetof(FOrionObjectiveItem, GameplayStat) == 0x000000, "Member 'FOrionObjectiveItem::GameplayStat' has a wrong offset!");
static_assert(offsetof(FOrionObjectiveItem, ObjectiveBackendName) == 0x000010, "Member 'FOrionObjectiveItem::ObjectiveBackendName' has a wrong offset!");
static_assert(offsetof(FOrionObjectiveItem, StatName) == 0x000018, "Member 'FOrionObjectiveItem::StatName' has a wrong offset!");
static_assert(offsetof(FOrionObjectiveItem, ObjectiveCompletedEventName) == 0x000020, "Member 'FOrionObjectiveItem::ObjectiveCompletedEventName' has a wrong offset!");
static_assert(offsetof(FOrionObjectiveItem, CurrentValue) == 0x000028, "Member 'FOrionObjectiveItem::CurrentValue' has a wrong offset!");
static_assert(offsetof(FOrionObjectiveItem, bCompleted) == 0x00002C, "Member 'FOrionObjectiveItem::bCompleted' has a wrong offset!");

// ScriptStruct OrionGame.OrionMcpQuestObjectiveInfo
// 0x0060 (0x0060 - 0x0000)
struct FOrionMcpQuestObjectiveInfo final
{
public:
	class FName                                   BackendName;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ObjectiveCompletedEventName;                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionQuestObjectiveStatTrackType             ObjectiveStatTrackType;                            // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayStatTag                       GameplayStat;                                      // 0x0018(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0028(0x0018)(Edit, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stage;                                             // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHidden;                                           // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionStatEvaluationType                      ObjectiveEvaluationType;                           // 0x0049(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionStatTrackType                           ObjectiveTrackType;                                // 0x004A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B[0x5];                                       // 0x004B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    ObjectiveStatHandle;                               // 0x0050(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionMcpQuestObjectiveInfo) == 0x000008, "Wrong alignment on FOrionMcpQuestObjectiveInfo");
static_assert(sizeof(FOrionMcpQuestObjectiveInfo) == 0x000060, "Wrong size on FOrionMcpQuestObjectiveInfo");
static_assert(offsetof(FOrionMcpQuestObjectiveInfo, BackendName) == 0x000000, "Member 'FOrionMcpQuestObjectiveInfo::BackendName' has a wrong offset!");
static_assert(offsetof(FOrionMcpQuestObjectiveInfo, ObjectiveCompletedEventName) == 0x000008, "Member 'FOrionMcpQuestObjectiveInfo::ObjectiveCompletedEventName' has a wrong offset!");
static_assert(offsetof(FOrionMcpQuestObjectiveInfo, ObjectiveStatTrackType) == 0x000010, "Member 'FOrionMcpQuestObjectiveInfo::ObjectiveStatTrackType' has a wrong offset!");
static_assert(offsetof(FOrionMcpQuestObjectiveInfo, GameplayStat) == 0x000018, "Member 'FOrionMcpQuestObjectiveInfo::GameplayStat' has a wrong offset!");
static_assert(offsetof(FOrionMcpQuestObjectiveInfo, Description) == 0x000028, "Member 'FOrionMcpQuestObjectiveInfo::Description' has a wrong offset!");
static_assert(offsetof(FOrionMcpQuestObjectiveInfo, Count) == 0x000040, "Member 'FOrionMcpQuestObjectiveInfo::Count' has a wrong offset!");
static_assert(offsetof(FOrionMcpQuestObjectiveInfo, Stage) == 0x000044, "Member 'FOrionMcpQuestObjectiveInfo::Stage' has a wrong offset!");
static_assert(offsetof(FOrionMcpQuestObjectiveInfo, bHidden) == 0x000048, "Member 'FOrionMcpQuestObjectiveInfo::bHidden' has a wrong offset!");
static_assert(offsetof(FOrionMcpQuestObjectiveInfo, ObjectiveEvaluationType) == 0x000049, "Member 'FOrionMcpQuestObjectiveInfo::ObjectiveEvaluationType' has a wrong offset!");
static_assert(offsetof(FOrionMcpQuestObjectiveInfo, ObjectiveTrackType) == 0x00004A, "Member 'FOrionMcpQuestObjectiveInfo::ObjectiveTrackType' has a wrong offset!");
static_assert(offsetof(FOrionMcpQuestObjectiveInfo, ObjectiveStatHandle) == 0x000050, "Member 'FOrionMcpQuestObjectiveInfo::ObjectiveStatHandle' has a wrong offset!");

// ScriptStruct OrionGame.OrionGameQuestReward
// 0x0038 (0x0038 - 0x0000)
struct FOrionGameQuestReward final
{
public:
	class UHUDAlertAsset*                         HudNotification;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionMcpQuestItemDefinition*           NextQuestReward;                                   // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayStatTag                       RewardStat;                                        // 0x0010(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    RewardStatHandle;                                  // 0x0020(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	int32                                         RewardStatCount;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionGameQuestReward) == 0x000008, "Wrong alignment on FOrionGameQuestReward");
static_assert(sizeof(FOrionGameQuestReward) == 0x000038, "Wrong size on FOrionGameQuestReward");
static_assert(offsetof(FOrionGameQuestReward, HudNotification) == 0x000000, "Member 'FOrionGameQuestReward::HudNotification' has a wrong offset!");
static_assert(offsetof(FOrionGameQuestReward, NextQuestReward) == 0x000008, "Member 'FOrionGameQuestReward::NextQuestReward' has a wrong offset!");
static_assert(offsetof(FOrionGameQuestReward, RewardStat) == 0x000010, "Member 'FOrionGameQuestReward::RewardStat' has a wrong offset!");
static_assert(offsetof(FOrionGameQuestReward, RewardStatHandle) == 0x000020, "Member 'FOrionGameQuestReward::RewardStatHandle' has a wrong offset!");
static_assert(offsetof(FOrionGameQuestReward, RewardStatCount) == 0x000030, "Member 'FOrionGameQuestReward::RewardStatCount' has a wrong offset!");

// ScriptStruct OrionGame.OrionQuestPrerequisites
// 0x0028 (0x0028 - 0x0000)
struct FOrionQuestPrerequisites final
{
public:
	struct FDataTableRowHandle                    ObjectiveStatHandle;                               // 0x0000(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayStatTag                       GameplayStat;                                      // 0x0010(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionPrereqOp                                EvaluationOp;                                      // 0x0024(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionQuestPrerequisites) == 0x000008, "Wrong alignment on FOrionQuestPrerequisites");
static_assert(sizeof(FOrionQuestPrerequisites) == 0x000028, "Wrong size on FOrionQuestPrerequisites");
static_assert(offsetof(FOrionQuestPrerequisites, ObjectiveStatHandle) == 0x000000, "Member 'FOrionQuestPrerequisites::ObjectiveStatHandle' has a wrong offset!");
static_assert(offsetof(FOrionQuestPrerequisites, GameplayStat) == 0x000010, "Member 'FOrionQuestPrerequisites::GameplayStat' has a wrong offset!");
static_assert(offsetof(FOrionQuestPrerequisites, Count) == 0x000020, "Member 'FOrionQuestPrerequisites::Count' has a wrong offset!");
static_assert(offsetof(FOrionQuestPrerequisites, EvaluationOp) == 0x000024, "Member 'FOrionQuestPrerequisites::EvaluationOp' has a wrong offset!");

// ScriptStruct OrionGame.HeroHealthRecord
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x04) FHeroHealthRecord final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHeroHealthRecord) == 0x000004, "Wrong alignment on FHeroHealthRecord");
static_assert(sizeof(FHeroHealthRecord) == 0x000020, "Wrong size on FHeroHealthRecord");

// ScriptStruct OrionGame.McpRankUpInfo
// 0x0038 (0x0038 - 0x0000)
struct FMcpRankUpInfo final
{
public:
	struct FInt32Range                            Ranks;                                             // 0x0000(0x0010)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionMcpRecipeCost                    Cost;                                              // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FOrionItemQuantity>             BonusGifts;                                        // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMcpRankUpInfo) == 0x000008, "Wrong alignment on FMcpRankUpInfo");
static_assert(sizeof(FMcpRankUpInfo) == 0x000038, "Wrong size on FMcpRankUpInfo");
static_assert(offsetof(FMcpRankUpInfo, Ranks) == 0x000000, "Member 'FMcpRankUpInfo::Ranks' has a wrong offset!");
static_assert(offsetof(FMcpRankUpInfo, Cost) == 0x000010, "Member 'FMcpRankUpInfo::Cost' has a wrong offset!");
static_assert(offsetof(FMcpRankUpInfo, BonusGifts) == 0x000028, "Member 'FMcpRankUpInfo::BonusGifts' has a wrong offset!");

// ScriptStruct OrionGame.SkinAnimOverride
// 0x0050 (0x0050 - 0x0000)
struct FSkinAnimOverride final
{
public:
	TSoftObjectPtr<class UAnimMontage>            OriginalAnimation;                                 // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            OverrideAnimation;                                 // 0x0028(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkinAnimOverride) == 0x000008, "Wrong alignment on FSkinAnimOverride");
static_assert(sizeof(FSkinAnimOverride) == 0x000050, "Wrong size on FSkinAnimOverride");
static_assert(offsetof(FSkinAnimOverride, OriginalAnimation) == 0x000000, "Member 'FSkinAnimOverride::OriginalAnimation' has a wrong offset!");
static_assert(offsetof(FSkinAnimOverride, OverrideAnimation) == 0x000028, "Member 'FSkinAnimOverride::OverrideAnimation' has a wrong offset!");

// ScriptStruct OrionGame.LevelProgressionDelta
// 0x0028 (0x0028 - 0x0000)
struct FLevelProgressionDelta final
{
public:
	EOrionLevelType                               LevelType;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 OwnerTemplateId;                                   // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OldLevel;                                          // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OldXP;                                             // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewLevel;                                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewXP;                                             // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelProgressionDelta) == 0x000008, "Wrong alignment on FLevelProgressionDelta");
static_assert(sizeof(FLevelProgressionDelta) == 0x000028, "Wrong size on FLevelProgressionDelta");
static_assert(offsetof(FLevelProgressionDelta, LevelType) == 0x000000, "Member 'FLevelProgressionDelta::LevelType' has a wrong offset!");
static_assert(offsetof(FLevelProgressionDelta, OwnerTemplateId) == 0x000008, "Member 'FLevelProgressionDelta::OwnerTemplateId' has a wrong offset!");
static_assert(offsetof(FLevelProgressionDelta, OldLevel) == 0x000018, "Member 'FLevelProgressionDelta::OldLevel' has a wrong offset!");
static_assert(offsetof(FLevelProgressionDelta, OldXP) == 0x00001C, "Member 'FLevelProgressionDelta::OldXP' has a wrong offset!");
static_assert(offsetof(FLevelProgressionDelta, NewLevel) == 0x000020, "Member 'FLevelProgressionDelta::NewLevel' has a wrong offset!");
static_assert(offsetof(FLevelProgressionDelta, NewXP) == 0x000024, "Member 'FLevelProgressionDelta::NewXP' has a wrong offset!");

// ScriptStruct OrionGame.AbilityDisplayValueModifier
// 0x0050 (0x0050 - 0x0000)
struct FAbilityDisplayValueModifier final
{
public:
	EAbilityDisplayValueModifierOperation         Operation;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAttributeLookup;                                // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionAttributeViewItemHandle          LinkedOwnerAttribute;                              // 0x0008(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FScalableFloat                         ModifierValue;                                     // 0x0028(0x0028)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbilityDisplayValueModifier) == 0x000008, "Wrong alignment on FAbilityDisplayValueModifier");
static_assert(sizeof(FAbilityDisplayValueModifier) == 0x000050, "Wrong size on FAbilityDisplayValueModifier");
static_assert(offsetof(FAbilityDisplayValueModifier, Operation) == 0x000000, "Member 'FAbilityDisplayValueModifier::Operation' has a wrong offset!");
static_assert(offsetof(FAbilityDisplayValueModifier, bIsAttributeLookup) == 0x000004, "Member 'FAbilityDisplayValueModifier::bIsAttributeLookup' has a wrong offset!");
static_assert(offsetof(FAbilityDisplayValueModifier, LinkedOwnerAttribute) == 0x000008, "Member 'FAbilityDisplayValueModifier::LinkedOwnerAttribute' has a wrong offset!");
static_assert(offsetof(FAbilityDisplayValueModifier, ModifierValue) == 0x000028, "Member 'FAbilityDisplayValueModifier::ModifierValue' has a wrong offset!");

// ScriptStruct OrionGame.SimpleAbilityDisplayValue
// 0x0088 (0x0088 - 0x0000)
struct FSimpleAbilityDisplayValue
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ValueName;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FScalableFloat                         DisplayValue;                                      // 0x0018(0x0028)(Edit, NativeAccessSpecifierPublic)
	bool                                          bIncreasingIsGood;                                 // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EAbilityDisplayValueFormat                    DisplayFormat;                                     // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     AssociatedAttribute;                               // 0x0048(0x0020)(Deprecated, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionAttributeViewItemHandle          LinkedAttribute;                                   // 0x0068(0x0020)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSimpleAbilityDisplayValue) == 0x000008, "Wrong alignment on FSimpleAbilityDisplayValue");
static_assert(sizeof(FSimpleAbilityDisplayValue) == 0x000088, "Wrong size on FSimpleAbilityDisplayValue");
static_assert(offsetof(FSimpleAbilityDisplayValue, ValueName) == 0x000008, "Member 'FSimpleAbilityDisplayValue::ValueName' has a wrong offset!");
static_assert(offsetof(FSimpleAbilityDisplayValue, DisplayValue) == 0x000018, "Member 'FSimpleAbilityDisplayValue::DisplayValue' has a wrong offset!");
static_assert(offsetof(FSimpleAbilityDisplayValue, bIncreasingIsGood) == 0x000040, "Member 'FSimpleAbilityDisplayValue::bIncreasingIsGood' has a wrong offset!");
static_assert(offsetof(FSimpleAbilityDisplayValue, DisplayFormat) == 0x000044, "Member 'FSimpleAbilityDisplayValue::DisplayFormat' has a wrong offset!");
static_assert(offsetof(FSimpleAbilityDisplayValue, AssociatedAttribute) == 0x000048, "Member 'FSimpleAbilityDisplayValue::AssociatedAttribute' has a wrong offset!");
static_assert(offsetof(FSimpleAbilityDisplayValue, LinkedAttribute) == 0x000068, "Member 'FSimpleAbilityDisplayValue::LinkedAttribute' has a wrong offset!");

// ScriptStruct OrionGame.ModifiableSimpleAbilityDisplayValue
// 0x0010 (0x0098 - 0x0088)
struct FModifiableSimpleAbilityDisplayValue final : public FSimpleAbilityDisplayValue
{
public:
	TArray<struct FAbilityDisplayValueModifier>   ModifierValues;                                    // 0x0088(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModifiableSimpleAbilityDisplayValue) == 0x000008, "Wrong alignment on FModifiableSimpleAbilityDisplayValue");
static_assert(sizeof(FModifiableSimpleAbilityDisplayValue) == 0x000098, "Wrong size on FModifiableSimpleAbilityDisplayValue");
static_assert(offsetof(FModifiableSimpleAbilityDisplayValue, ModifierValues) == 0x000088, "Member 'FModifiableSimpleAbilityDisplayValue::ModifierValues' has a wrong offset!");

// ScriptStruct OrionGame.SimpleAbilityData
// 0x0298 (0x02A0 - 0x0008)
struct FSimpleAbilityData final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0010(0x0018)(Edit, NativeAccessSpecifierPrivate)
	class FText                                   DisplayDescription;                                // 0x0028(0x0018)(Edit, NativeAccessSpecifierPrivate)
	TArray<struct FModifiableSimpleAbilityDisplayValue> CustomDisplayValues;                               // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSimpleAbilityDisplayValue>     EffectParamDisplayValues;                          // 0x0050(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSimpleAbilityDisplayValue>     QualifierParamDisplayValues;                       // 0x0060(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPrivate)
	EItemEffectActivationMethod                   ActivationMethod;                                  // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPersistAfterAbilityDestroyed;                     // 0x0071(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEntersCombat;                                     // 0x0072(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bBreaksShadowplane;                                // 0x0073(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDisplayInWorldOnTrigger;                          // 0x0074(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FQualifiedSimpleAbilityEvent>   ApplicationEventSequence;                          // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FQualifiedSimpleAbilityEvent           RemovalEvent;                                      // 0x0088(0x0050)(Edit, NativeAccessSpecifierPrivate)
	EItemEffectApplicationTarget                  EffectApplicationTarget;                           // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         CooldownDuration;                                  // 0x00E0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         ManaCost;                                          // 0x0108(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FGameplayEffectWithParameters          AppliedGameplayEffect;                             // 0x0130(0x0160)(Edit, NativeAccessSpecifierPrivate)
	struct FGameplayEffectKeywordTag              AppliedEffectKeyword;                              // 0x0290(0x0008)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSimpleAbilityData) == 0x000010, "Wrong alignment on FSimpleAbilityData");
static_assert(sizeof(FSimpleAbilityData) == 0x0002A0, "Wrong size on FSimpleAbilityData");
static_assert(offsetof(FSimpleAbilityData, DisplayName) == 0x000010, "Member 'FSimpleAbilityData::DisplayName' has a wrong offset!");
static_assert(offsetof(FSimpleAbilityData, DisplayDescription) == 0x000028, "Member 'FSimpleAbilityData::DisplayDescription' has a wrong offset!");
static_assert(offsetof(FSimpleAbilityData, CustomDisplayValues) == 0x000040, "Member 'FSimpleAbilityData::CustomDisplayValues' has a wrong offset!");
static_assert(offsetof(FSimpleAbilityData, EffectParamDisplayValues) == 0x000050, "Member 'FSimpleAbilityData::EffectParamDisplayValues' has a wrong offset!");
static_assert(offsetof(FSimpleAbilityData, QualifierParamDisplayValues) == 0x000060, "Member 'FSimpleAbilityData::QualifierParamDisplayValues' has a wrong offset!");
static_assert(offsetof(FSimpleAbilityData, ActivationMethod) == 0x000070, "Member 'FSimpleAbilityData::ActivationMethod' has a wrong offset!");
static_assert(offsetof(FSimpleAbilityData, bPersistAfterAbilityDestroyed) == 0x000071, "Member 'FSimpleAbilityData::bPersistAfterAbilityDestroyed' has a wrong offset!");
static_assert(offsetof(FSimpleAbilityData, bEntersCombat) == 0x000072, "Member 'FSimpleAbilityData::bEntersCombat' has a wrong offset!");
static_assert(offsetof(FSimpleAbilityData, bBreaksShadowplane) == 0x000073, "Member 'FSimpleAbilityData::bBreaksShadowplane' has a wrong offset!");
static_assert(offsetof(FSimpleAbilityData, bDisplayInWorldOnTrigger) == 0x000074, "Member 'FSimpleAbilityData::bDisplayInWorldOnTrigger' has a wrong offset!");
static_assert(offsetof(FSimpleAbilityData, ApplicationEventSequence) == 0x000078, "Member 'FSimpleAbilityData::ApplicationEventSequence' has a wrong offset!");
static_assert(offsetof(FSimpleAbilityData, RemovalEvent) == 0x000088, "Member 'FSimpleAbilityData::RemovalEvent' has a wrong offset!");
static_assert(offsetof(FSimpleAbilityData, EffectApplicationTarget) == 0x0000D8, "Member 'FSimpleAbilityData::EffectApplicationTarget' has a wrong offset!");
static_assert(offsetof(FSimpleAbilityData, CooldownDuration) == 0x0000E0, "Member 'FSimpleAbilityData::CooldownDuration' has a wrong offset!");
static_assert(offsetof(FSimpleAbilityData, ManaCost) == 0x000108, "Member 'FSimpleAbilityData::ManaCost' has a wrong offset!");
static_assert(offsetof(FSimpleAbilityData, AppliedGameplayEffect) == 0x000130, "Member 'FSimpleAbilityData::AppliedGameplayEffect' has a wrong offset!");
static_assert(offsetof(FSimpleAbilityData, AppliedEffectKeyword) == 0x000290, "Member 'FSimpleAbilityData::AppliedEffectKeyword' has a wrong offset!");

// ScriptStruct OrionGame.SkinSpawnOverrideItem
// 0x0050 (0x0050 - 0x0000)
struct FSkinSpawnOverrideItem final
{
public:
	TSoftClassPtr<class UClass>                   OriginalActor;                                     // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   NewActor;                                          // 0x0028(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkinSpawnOverrideItem) == 0x000008, "Wrong alignment on FSkinSpawnOverrideItem");
static_assert(sizeof(FSkinSpawnOverrideItem) == 0x000050, "Wrong size on FSkinSpawnOverrideItem");
static_assert(offsetof(FSkinSpawnOverrideItem, OriginalActor) == 0x000000, "Member 'FSkinSpawnOverrideItem::OriginalActor' has a wrong offset!");
static_assert(offsetof(FSkinSpawnOverrideItem, NewActor) == 0x000028, "Member 'FSkinSpawnOverrideItem::NewActor' has a wrong offset!");

// ScriptStruct OrionGame.CompositeSubtitution
// 0x0010 (0x0010 - 0x0000)
struct FCompositeSubtitution final
{
public:
	TArray<TSoftObjectPtr<class UOrionMcpItemDefinition>> Substitutions;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCompositeSubtitution) == 0x000008, "Wrong alignment on FCompositeSubtitution");
static_assert(sizeof(FCompositeSubtitution) == 0x000010, "Wrong size on FCompositeSubtitution");
static_assert(offsetof(FCompositeSubtitution, Substitutions) == 0x000000, "Member 'FCompositeSubtitution::Substitutions' has a wrong offset!");

// ScriptStruct OrionGame.GameplayShadowPadOverlapTracker
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FGameplayShadowPadOverlapTracker final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayShadowPadOverlapTracker) == 0x000008, "Wrong alignment on FGameplayShadowPadOverlapTracker");
static_assert(sizeof(FGameplayShadowPadOverlapTracker) == 0x000018, "Wrong size on FGameplayShadowPadOverlapTracker");

// ScriptStruct OrionGame.AccountMmr
// 0x0008 (0x0008 - 0x0000)
struct FAccountMmr final
{
public:
	int32                                         Rating;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewPlayerAdjusted;                                // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAccountMmr) == 0x000004, "Wrong alignment on FAccountMmr");
static_assert(sizeof(FAccountMmr) == 0x000008, "Wrong size on FAccountMmr");
static_assert(offsetof(FAccountMmr, Rating) == 0x000000, "Member 'FAccountMmr::Rating' has a wrong offset!");
static_assert(offsetof(FAccountMmr, bNewPlayerAdjusted) == 0x000004, "Member 'FAccountMmr::bNewPlayerAdjusted' has a wrong offset!");

// ScriptStruct OrionGame.LoginRewardData
// 0x0068 (0x0070 - 0x0008)
struct FLoginRewardData final : public FTableRowBase
{
public:
	int32                                         DayIndex;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UOrionMcpItemDefinition> RewardTemplate0;                                   // 0x0010(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardQuantity0;                                   // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UOrionMcpItemDefinition> RewardTemplate1;                                   // 0x0040(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardQuantity1;                                   // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpecial;                                          // 0x006C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoginRewardData) == 0x000008, "Wrong alignment on FLoginRewardData");
static_assert(sizeof(FLoginRewardData) == 0x000070, "Wrong size on FLoginRewardData");
static_assert(offsetof(FLoginRewardData, DayIndex) == 0x000008, "Member 'FLoginRewardData::DayIndex' has a wrong offset!");
static_assert(offsetof(FLoginRewardData, RewardTemplate0) == 0x000010, "Member 'FLoginRewardData::RewardTemplate0' has a wrong offset!");
static_assert(offsetof(FLoginRewardData, RewardQuantity0) == 0x000038, "Member 'FLoginRewardData::RewardQuantity0' has a wrong offset!");
static_assert(offsetof(FLoginRewardData, RewardTemplate1) == 0x000040, "Member 'FLoginRewardData::RewardTemplate1' has a wrong offset!");
static_assert(offsetof(FLoginRewardData, RewardQuantity1) == 0x000068, "Member 'FLoginRewardData::RewardQuantity1' has a wrong offset!");
static_assert(offsetof(FLoginRewardData, bSpecial) == 0x00006C, "Member 'FLoginRewardData::bSpecial' has a wrong offset!");

// ScriptStruct OrionGame.OrionLoginRewardInfo
// 0x0078 (0x0078 - 0x0000)
struct FOrionLoginRewardInfo final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLoginRewardData                       LoginRewardRowData;                                // 0x0008(0x0070)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionLoginRewardInfo) == 0x000008, "Wrong alignment on FOrionLoginRewardInfo");
static_assert(sizeof(FOrionLoginRewardInfo) == 0x000078, "Wrong size on FOrionLoginRewardInfo");
static_assert(offsetof(FOrionLoginRewardInfo, Level) == 0x000000, "Member 'FOrionLoginRewardInfo::Level' has a wrong offset!");
static_assert(offsetof(FOrionLoginRewardInfo, LoginRewardRowData) == 0x000008, "Member 'FOrionLoginRewardInfo::LoginRewardRowData' has a wrong offset!");

// ScriptStruct OrionGame.OrionStatusEffectDisplayInfo
// 0x0038 (0x0038 - 0x0000)
struct FOrionStatusEffectDisplayInfo final
{
public:
	class UTexture2D*                             DisplayIcon;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkupAbbreviation;                                // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTag                           StatusTag;                                         // 0x0028(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBuff;                                           // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsIntense;                                        // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatusEffectTextDisplayRule                  TextDisplayRule;                                   // 0x0032(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33[0x5];                                       // 0x0033(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionStatusEffectDisplayInfo) == 0x000008, "Wrong alignment on FOrionStatusEffectDisplayInfo");
static_assert(sizeof(FOrionStatusEffectDisplayInfo) == 0x000038, "Wrong size on FOrionStatusEffectDisplayInfo");
static_assert(offsetof(FOrionStatusEffectDisplayInfo, DisplayIcon) == 0x000000, "Member 'FOrionStatusEffectDisplayInfo::DisplayIcon' has a wrong offset!");
static_assert(offsetof(FOrionStatusEffectDisplayInfo, MarkupAbbreviation) == 0x000008, "Member 'FOrionStatusEffectDisplayInfo::MarkupAbbreviation' has a wrong offset!");
static_assert(offsetof(FOrionStatusEffectDisplayInfo, DisplayName) == 0x000010, "Member 'FOrionStatusEffectDisplayInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(FOrionStatusEffectDisplayInfo, StatusTag) == 0x000028, "Member 'FOrionStatusEffectDisplayInfo::StatusTag' has a wrong offset!");
static_assert(offsetof(FOrionStatusEffectDisplayInfo, bIsBuff) == 0x000030, "Member 'FOrionStatusEffectDisplayInfo::bIsBuff' has a wrong offset!");
static_assert(offsetof(FOrionStatusEffectDisplayInfo, bIsIntense) == 0x000031, "Member 'FOrionStatusEffectDisplayInfo::bIsIntense' has a wrong offset!");
static_assert(offsetof(FOrionStatusEffectDisplayInfo, TextDisplayRule) == 0x000032, "Member 'FOrionStatusEffectDisplayInfo::TextDisplayRule' has a wrong offset!");

// ScriptStruct OrionGame.ReportWaitTimesParams
// 0x0028 (0x0028 - 0x0000)
struct FReportWaitTimesParams final
{
public:
	class FString                                 BucketId;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SessionId;                                         // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerMatchWaitSecs;                               // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamMatchWaitSecs;                                 // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReportWaitTimesParams) == 0x000008, "Wrong alignment on FReportWaitTimesParams");
static_assert(sizeof(FReportWaitTimesParams) == 0x000028, "Wrong size on FReportWaitTimesParams");
static_assert(offsetof(FReportWaitTimesParams, BucketId) == 0x000000, "Member 'FReportWaitTimesParams::BucketId' has a wrong offset!");
static_assert(offsetof(FReportWaitTimesParams, SessionId) == 0x000010, "Member 'FReportWaitTimesParams::SessionId' has a wrong offset!");
static_assert(offsetof(FReportWaitTimesParams, PlayerMatchWaitSecs) == 0x000020, "Member 'FReportWaitTimesParams::PlayerMatchWaitSecs' has a wrong offset!");
static_assert(offsetof(FReportWaitTimesParams, TeamMatchWaitSecs) == 0x000024, "Member 'FReportWaitTimesParams::TeamMatchWaitSecs' has a wrong offset!");

// ScriptStruct OrionGame.OrionLootTierRewardInfo
// 0x0030 (0x0098 - 0x0068)
struct FOrionLootTierRewardInfo final : public FOrionRewardTypeInfo
{
public:
	class FString                                 LootTierGroupName;                                 // 0x0068(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   LootTypeName;                                      // 0x0078(0x0018)(Edit, NativeAccessSpecifierPublic)
	bool                                          bIsRandomRoll;                                     // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionLootTierRewardInfo) == 0x000008, "Wrong alignment on FOrionLootTierRewardInfo");
static_assert(sizeof(FOrionLootTierRewardInfo) == 0x000098, "Wrong size on FOrionLootTierRewardInfo");
static_assert(offsetof(FOrionLootTierRewardInfo, LootTierGroupName) == 0x000068, "Member 'FOrionLootTierRewardInfo::LootTierGroupName' has a wrong offset!");
static_assert(offsetof(FOrionLootTierRewardInfo, LootTypeName) == 0x000078, "Member 'FOrionLootTierRewardInfo::LootTypeName' has a wrong offset!");
static_assert(offsetof(FOrionLootTierRewardInfo, bIsRandomRoll) == 0x000090, "Member 'FOrionLootTierRewardInfo::bIsRandomRoll' has a wrong offset!");

// ScriptStruct OrionGame.VaultTemplateQuantity
// 0x0030 (0x0030 - 0x0000)
struct FVaultTemplateQuantity final
{
public:
	TSoftObjectPtr<class UOrionMcpItemDefinition> TemplateDefinition;                                // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVaultTemplateQuantity) == 0x000008, "Wrong alignment on FVaultTemplateQuantity");
static_assert(sizeof(FVaultTemplateQuantity) == 0x000030, "Wrong size on FVaultTemplateQuantity");
static_assert(offsetof(FVaultTemplateQuantity, TemplateDefinition) == 0x000000, "Member 'FVaultTemplateQuantity::TemplateDefinition' has a wrong offset!");
static_assert(offsetof(FVaultTemplateQuantity, Quantity) == 0x000028, "Member 'FVaultTemplateQuantity::Quantity' has a wrong offset!");

// ScriptStruct OrionGame.VaultEntry
// 0x0018 (0x0018 - 0x0000)
struct FVaultEntry final
{
public:
	TArray<struct FVaultTemplateQuantity>         Items;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Weight;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRepeatable;                                     // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVaultEntry) == 0x000008, "Wrong alignment on FVaultEntry");
static_assert(sizeof(FVaultEntry) == 0x000018, "Wrong size on FVaultEntry");
static_assert(offsetof(FVaultEntry, Items) == 0x000000, "Member 'FVaultEntry::Items' has a wrong offset!");
static_assert(offsetof(FVaultEntry, Weight) == 0x000010, "Member 'FVaultEntry::Weight' has a wrong offset!");
static_assert(offsetof(FVaultEntry, bIsRepeatable) == 0x000014, "Member 'FVaultEntry::bIsRepeatable' has a wrong offset!");

// ScriptStruct OrionGame.NavFieldHeightTile
// 0x0020 (0x0020 - 0x0000)
struct FNavFieldHeightTile final
{
public:
	int16                                         TileX;                                             // 0x0000(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         TileY;                                             // 0x0002(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinZ;                                              // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxZ;                                              // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 HeightData;                                        // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNavFieldHeightTile) == 0x000008, "Wrong alignment on FNavFieldHeightTile");
static_assert(sizeof(FNavFieldHeightTile) == 0x000020, "Wrong size on FNavFieldHeightTile");
static_assert(offsetof(FNavFieldHeightTile, TileX) == 0x000000, "Member 'FNavFieldHeightTile::TileX' has a wrong offset!");
static_assert(offsetof(FNavFieldHeightTile, TileY) == 0x000002, "Member 'FNavFieldHeightTile::TileY' has a wrong offset!");
static_assert(offsetof(FNavFieldHeightTile, MinZ) == 0x000004, "Member 'FNavFieldHeightTile::MinZ' has a wrong offset!");
static_assert(offsetof(FNavFieldHeightTile, MaxZ) == 0x000008, "Member 'FNavFieldHeightTile::MaxZ' has a wrong offset!");
static_assert(offsetof(FNavFieldHeightTile, HeightData) == 0x000010, "Member 'FNavFieldHeightTile::HeightData' has a wrong offset!");

// ScriptStruct OrionGame.NavFieldDirectionTile
// 0x0018 (0x0018 - 0x0000)
struct FNavFieldDirectionTile final
{
public:
	int16                                         TileX;                                             // 0x0000(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         TileY;                                             // 0x0002(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         RedLaneIdx;                                        // 0x0004(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         BlueLaneIdx;                                       // 0x0006(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint32>                                FieldData;                                         // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNavFieldDirectionTile) == 0x000008, "Wrong alignment on FNavFieldDirectionTile");
static_assert(sizeof(FNavFieldDirectionTile) == 0x000018, "Wrong size on FNavFieldDirectionTile");
static_assert(offsetof(FNavFieldDirectionTile, TileX) == 0x000000, "Member 'FNavFieldDirectionTile::TileX' has a wrong offset!");
static_assert(offsetof(FNavFieldDirectionTile, TileY) == 0x000002, "Member 'FNavFieldDirectionTile::TileY' has a wrong offset!");
static_assert(offsetof(FNavFieldDirectionTile, RedLaneIdx) == 0x000004, "Member 'FNavFieldDirectionTile::RedLaneIdx' has a wrong offset!");
static_assert(offsetof(FNavFieldDirectionTile, BlueLaneIdx) == 0x000006, "Member 'FNavFieldDirectionTile::BlueLaneIdx' has a wrong offset!");
static_assert(offsetof(FNavFieldDirectionTile, FieldData) == 0x000008, "Member 'FNavFieldDirectionTile::FieldData' has a wrong offset!");

// ScriptStruct OrionGame.CraftCompleteNotification
// 0x0018 (0x0018 - 0x0000)
struct FCraftCompleteNotification final
{
public:
	class FString                                 CreatedCardId;                                     // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumInstances;                                      // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCraftCompleteNotification) == 0x000008, "Wrong alignment on FCraftCompleteNotification");
static_assert(sizeof(FCraftCompleteNotification) == 0x000018, "Wrong size on FCraftCompleteNotification");
static_assert(offsetof(FCraftCompleteNotification, CreatedCardId) == 0x000000, "Member 'FCraftCompleteNotification::CreatedCardId' has a wrong offset!");
static_assert(offsetof(FCraftCompleteNotification, NumInstances) == 0x000010, "Member 'FCraftCompleteNotification::NumInstances' has a wrong offset!");

// ScriptStruct OrionGame.DailyRewardsUpdateNotification
// 0x0010 (0x0010 - 0x0000)
struct FDailyRewardsUpdateNotification final
{
public:
	TArray<struct FOrionDailyRewardInfo>          DailyRewards;                                      // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDailyRewardsUpdateNotification) == 0x000008, "Wrong alignment on FDailyRewardsUpdateNotification");
static_assert(sizeof(FDailyRewardsUpdateNotification) == 0x000010, "Wrong size on FDailyRewardsUpdateNotification");
static_assert(offsetof(FDailyRewardsUpdateNotification, DailyRewards) == 0x000000, "Member 'FDailyRewardsUpdateNotification::DailyRewards' has a wrong offset!");

// ScriptStruct OrionGame.HeroLevelUpNotification
// 0x0028 (0x0028 - 0x0000)
struct FHeroLevelUpNotification final
{
public:
	class FString                                 HeroId;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HeroType;                                          // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OldLevel;                                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewLevel;                                          // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHeroLevelUpNotification) == 0x000008, "Wrong alignment on FHeroLevelUpNotification");
static_assert(sizeof(FHeroLevelUpNotification) == 0x000028, "Wrong size on FHeroLevelUpNotification");
static_assert(offsetof(FHeroLevelUpNotification, HeroId) == 0x000000, "Member 'FHeroLevelUpNotification::HeroId' has a wrong offset!");
static_assert(offsetof(FHeroLevelUpNotification, HeroType) == 0x000010, "Member 'FHeroLevelUpNotification::HeroType' has a wrong offset!");
static_assert(offsetof(FHeroLevelUpNotification, OldLevel) == 0x000020, "Member 'FHeroLevelUpNotification::OldLevel' has a wrong offset!");
static_assert(offsetof(FHeroLevelUpNotification, NewLevel) == 0x000024, "Member 'FHeroLevelUpNotification::NewLevel' has a wrong offset!");

// ScriptStruct OrionGame.AccountPrestigeNotification
// 0x0004 (0x0004 - 0x0000)
struct FAccountPrestigeNotification final
{
public:
	int32                                         NewValorRank;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccountPrestigeNotification) == 0x000004, "Wrong alignment on FAccountPrestigeNotification");
static_assert(sizeof(FAccountPrestigeNotification) == 0x000004, "Wrong size on FAccountPrestigeNotification");
static_assert(offsetof(FAccountPrestigeNotification, NewValorRank) == 0x000000, "Member 'FAccountPrestigeNotification::NewValorRank' has a wrong offset!");

// ScriptStruct OrionGame.ObjectiveDelta
// 0x0018 (0x0018 - 0x0000)
struct FObjectiveDelta final
{
public:
	class FString                                 ObjectiveId;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BeforeValue;                                       // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AfterValue;                                        // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObjectiveDelta) == 0x000008, "Wrong alignment on FObjectiveDelta");
static_assert(sizeof(FObjectiveDelta) == 0x000018, "Wrong size on FObjectiveDelta");
static_assert(offsetof(FObjectiveDelta, ObjectiveId) == 0x000000, "Member 'FObjectiveDelta::ObjectiveId' has a wrong offset!");
static_assert(offsetof(FObjectiveDelta, BeforeValue) == 0x000010, "Member 'FObjectiveDelta::BeforeValue' has a wrong offset!");
static_assert(offsetof(FObjectiveDelta, AfterValue) == 0x000014, "Member 'FObjectiveDelta::AfterValue' has a wrong offset!");

// ScriptStruct OrionGame.QuestProgressionDelta
// 0x0038 (0x0038 - 0x0000)
struct FQuestProgressionDelta final
{
public:
	class FString                                 QuestId;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 QuestTemplateId;                                   // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionQuestState                              PreMatchState;                                     // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionQuestState                              PostMatchState;                                    // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FObjectiveDelta>                ObjectiveDeltas;                                   // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestProgressionDelta) == 0x000008, "Wrong alignment on FQuestProgressionDelta");
static_assert(sizeof(FQuestProgressionDelta) == 0x000038, "Wrong size on FQuestProgressionDelta");
static_assert(offsetof(FQuestProgressionDelta, QuestId) == 0x000000, "Member 'FQuestProgressionDelta::QuestId' has a wrong offset!");
static_assert(offsetof(FQuestProgressionDelta, QuestTemplateId) == 0x000010, "Member 'FQuestProgressionDelta::QuestTemplateId' has a wrong offset!");
static_assert(offsetof(FQuestProgressionDelta, PreMatchState) == 0x000020, "Member 'FQuestProgressionDelta::PreMatchState' has a wrong offset!");
static_assert(offsetof(FQuestProgressionDelta, PostMatchState) == 0x000021, "Member 'FQuestProgressionDelta::PostMatchState' has a wrong offset!");
static_assert(offsetof(FQuestProgressionDelta, ObjectiveDeltas) == 0x000028, "Member 'FQuestProgressionDelta::ObjectiveDeltas' has a wrong offset!");

// ScriptStruct OrionGame.MCPKeyValue
// 0x0018 (0x0018 - 0x0000)
struct FMCPKeyValue final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMCPKeyValue) == 0x000008, "Wrong alignment on FMCPKeyValue");
static_assert(sizeof(FMCPKeyValue) == 0x000018, "Wrong size on FMCPKeyValue");
static_assert(offsetof(FMCPKeyValue, Key) == 0x000000, "Member 'FMCPKeyValue::Key' has a wrong offset!");
static_assert(offsetof(FMCPKeyValue, Value) == 0x000010, "Member 'FMCPKeyValue::Value' has a wrong offset!");

// ScriptStruct OrionGame.MatchCompleteNotification
// 0x00C8 (0x00C8 - 0x0000)
struct FMatchCompleteNotification final
{
public:
	class FString                                 MatchSessionId;                                    // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlaylistId;                                        // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GameDurationInMinutes;                             // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAccountProgression                    OldAccountProgression;                             // 0x0018(0x0014)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 HeroName;                                          // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionHeroMasteryProgression           OldHeroMastery;                                    // 0x0040(0x0020)(NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FQuestProgressionDelta>         QuestDeltas;                                       // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMCPKeyValue>                   XPSources;                                         // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTeamOwnershipXPBonus                  TeamOwnershipXPBonus;                              // 0x0080(0x0010)(NativeAccessSpecifierPublic)
	int32                                         XPTotal;                                           // 0x0090(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMCPKeyValue>                   TimeCurrencySources;                               // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         TimeCurrencyTotal;                                 // 0x00A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseStars;                                         // 0x00AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BonusStars;                                        // 0x00B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MasteryStars;                                      // 0x00B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AllyStars;                                         // 0x00B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Dampener;                                          // 0x00BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDidAbandonMatch;                                  // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasBannedForMatchAbandon;                         // 0x00C1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2[0x6];                                       // 0x00C2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMatchCompleteNotification) == 0x000008, "Wrong alignment on FMatchCompleteNotification");
static_assert(sizeof(FMatchCompleteNotification) == 0x0000C8, "Wrong size on FMatchCompleteNotification");
static_assert(offsetof(FMatchCompleteNotification, MatchSessionId) == 0x000000, "Member 'FMatchCompleteNotification::MatchSessionId' has a wrong offset!");
static_assert(offsetof(FMatchCompleteNotification, PlaylistId) == 0x000010, "Member 'FMatchCompleteNotification::PlaylistId' has a wrong offset!");
static_assert(offsetof(FMatchCompleteNotification, GameDurationInMinutes) == 0x000014, "Member 'FMatchCompleteNotification::GameDurationInMinutes' has a wrong offset!");
static_assert(offsetof(FMatchCompleteNotification, OldAccountProgression) == 0x000018, "Member 'FMatchCompleteNotification::OldAccountProgression' has a wrong offset!");
static_assert(offsetof(FMatchCompleteNotification, HeroName) == 0x000030, "Member 'FMatchCompleteNotification::HeroName' has a wrong offset!");
static_assert(offsetof(FMatchCompleteNotification, OldHeroMastery) == 0x000040, "Member 'FMatchCompleteNotification::OldHeroMastery' has a wrong offset!");
static_assert(offsetof(FMatchCompleteNotification, QuestDeltas) == 0x000060, "Member 'FMatchCompleteNotification::QuestDeltas' has a wrong offset!");
static_assert(offsetof(FMatchCompleteNotification, XPSources) == 0x000070, "Member 'FMatchCompleteNotification::XPSources' has a wrong offset!");
static_assert(offsetof(FMatchCompleteNotification, TeamOwnershipXPBonus) == 0x000080, "Member 'FMatchCompleteNotification::TeamOwnershipXPBonus' has a wrong offset!");
static_assert(offsetof(FMatchCompleteNotification, XPTotal) == 0x000090, "Member 'FMatchCompleteNotification::XPTotal' has a wrong offset!");
static_assert(offsetof(FMatchCompleteNotification, TimeCurrencySources) == 0x000098, "Member 'FMatchCompleteNotification::TimeCurrencySources' has a wrong offset!");
static_assert(offsetof(FMatchCompleteNotification, TimeCurrencyTotal) == 0x0000A8, "Member 'FMatchCompleteNotification::TimeCurrencyTotal' has a wrong offset!");
static_assert(offsetof(FMatchCompleteNotification, BaseStars) == 0x0000AC, "Member 'FMatchCompleteNotification::BaseStars' has a wrong offset!");
static_assert(offsetof(FMatchCompleteNotification, BonusStars) == 0x0000B0, "Member 'FMatchCompleteNotification::BonusStars' has a wrong offset!");
static_assert(offsetof(FMatchCompleteNotification, MasteryStars) == 0x0000B4, "Member 'FMatchCompleteNotification::MasteryStars' has a wrong offset!");
static_assert(offsetof(FMatchCompleteNotification, AllyStars) == 0x0000B8, "Member 'FMatchCompleteNotification::AllyStars' has a wrong offset!");
static_assert(offsetof(FMatchCompleteNotification, Dampener) == 0x0000BC, "Member 'FMatchCompleteNotification::Dampener' has a wrong offset!");
static_assert(offsetof(FMatchCompleteNotification, bDidAbandonMatch) == 0x0000C0, "Member 'FMatchCompleteNotification::bDidAbandonMatch' has a wrong offset!");
static_assert(offsetof(FMatchCompleteNotification, bWasBannedForMatchAbandon) == 0x0000C1, "Member 'FMatchCompleteNotification::bWasBannedForMatchAbandon' has a wrong offset!");

// ScriptStruct OrionGame.OrionLockHeroConfirmation
// 0x0030 (0x0030 - 0x0000)
struct FOrionLockHeroConfirmation final
{
public:
	struct FUniqueNetIdRepl                       MemberId;                                          // 0x0000(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HeroName;                                          // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuccess;                                          // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionLockHeroConfirmation) == 0x000008, "Wrong alignment on FOrionLockHeroConfirmation");
static_assert(sizeof(FOrionLockHeroConfirmation) == 0x000030, "Wrong size on FOrionLockHeroConfirmation");
static_assert(offsetof(FOrionLockHeroConfirmation, MemberId) == 0x000000, "Member 'FOrionLockHeroConfirmation::MemberId' has a wrong offset!");
static_assert(offsetof(FOrionLockHeroConfirmation, HeroName) == 0x000018, "Member 'FOrionLockHeroConfirmation::HeroName' has a wrong offset!");
static_assert(offsetof(FOrionLockHeroConfirmation, bSuccess) == 0x000028, "Member 'FOrionLockHeroConfirmation::bSuccess' has a wrong offset!");

// ScriptStruct OrionGame.OrionLockHeroConfirmationWrapper
// 0x0018 (0x0018 - 0x0000)
struct FOrionLockHeroConfirmationWrapper final
{
public:
	int32                                         ResponseId;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOrionLockHeroConfirmation>     Confirmations;                                     // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionLockHeroConfirmationWrapper) == 0x000008, "Wrong alignment on FOrionLockHeroConfirmationWrapper");
static_assert(sizeof(FOrionLockHeroConfirmationWrapper) == 0x000018, "Wrong size on FOrionLockHeroConfirmationWrapper");
static_assert(offsetof(FOrionLockHeroConfirmationWrapper, ResponseId) == 0x000000, "Member 'FOrionLockHeroConfirmationWrapper::ResponseId' has a wrong offset!");
static_assert(offsetof(FOrionLockHeroConfirmationWrapper, Confirmations) == 0x000008, "Member 'FOrionLockHeroConfirmationWrapper::Confirmations' has a wrong offset!");

// ScriptStruct OrionGame.VaultOpenHistory
// 0x0010 (0x0010 - 0x0000)
struct FVaultOpenHistory final
{
public:
	TArray<struct FVaultHistoryEntry>             VaultRecords;                                      // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVaultOpenHistory) == 0x000008, "Wrong alignment on FVaultOpenHistory");
static_assert(sizeof(FVaultOpenHistory) == 0x000010, "Wrong size on FVaultOpenHistory");
static_assert(offsetof(FVaultOpenHistory, VaultRecords) == 0x000000, "Member 'FVaultOpenHistory::VaultRecords' has a wrong offset!");

// ScriptStruct OrionGame.REGSReachRewardRecord
// 0x0020 (0x0020 - 0x0000)
struct FREGSReachRewardRecord final
{
public:
	struct FDateTime                              CompletionTime;                                    // 0x0000(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stars;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CohortTemplateId;                                  // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FREGSReachRewardRecord) == 0x000008, "Wrong alignment on FREGSReachRewardRecord");
static_assert(sizeof(FREGSReachRewardRecord) == 0x000020, "Wrong size on FREGSReachRewardRecord");
static_assert(offsetof(FREGSReachRewardRecord, CompletionTime) == 0x000000, "Member 'FREGSReachRewardRecord::CompletionTime' has a wrong offset!");
static_assert(offsetof(FREGSReachRewardRecord, Stars) == 0x000008, "Member 'FREGSReachRewardRecord::Stars' has a wrong offset!");
static_assert(offsetof(FREGSReachRewardRecord, CohortTemplateId) == 0x000010, "Member 'FREGSReachRewardRecord::CohortTemplateId' has a wrong offset!");

// ScriptStruct OrionGame.REGSLoginRewardRecord
// 0x0010 (0x0010 - 0x0000)
struct FREGSLoginRewardRecord final
{
public:
	struct FDateTime                              NextLoginTime;                                     // 0x0000(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FREGSLoginRewardRecord) == 0x000008, "Wrong alignment on FREGSLoginRewardRecord");
static_assert(sizeof(FREGSLoginRewardRecord) == 0x000010, "Wrong size on FREGSLoginRewardRecord");
static_assert(offsetof(FREGSLoginRewardRecord, NextLoginTime) == 0x000000, "Member 'FREGSLoginRewardRecord::NextLoginTime' has a wrong offset!");
static_assert(offsetof(FREGSLoginRewardRecord, Level) == 0x000008, "Member 'FREGSLoginRewardRecord::Level' has a wrong offset!");

// ScriptStruct OrionGame.OrionRotationalContentState
// 0x00C0 (0x00C0 - 0x0000)
struct FOrionRotationalContentState final
{
public:
	struct FOrionFeaturedHero                     FeaturedHero;                                      // 0x0000(0x0070)(NativeAccessSpecifierPublic)
	struct FOrionMcpEvent                         ActiveEvent;                                       // 0x0070(0x0028)(NativeAccessSpecifierPublic)
	TArray<struct FOrionMcpEvent>                 EventList;                                         // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bEnableDoubleXP;                                   // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDoubleTimeCurrency;                         // 0x00A9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         GameplayTags;                                      // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOrionRotationalContentState) == 0x000008, "Wrong alignment on FOrionRotationalContentState");
static_assert(sizeof(FOrionRotationalContentState) == 0x0000C0, "Wrong size on FOrionRotationalContentState");
static_assert(offsetof(FOrionRotationalContentState, FeaturedHero) == 0x000000, "Member 'FOrionRotationalContentState::FeaturedHero' has a wrong offset!");
static_assert(offsetof(FOrionRotationalContentState, ActiveEvent) == 0x000070, "Member 'FOrionRotationalContentState::ActiveEvent' has a wrong offset!");
static_assert(offsetof(FOrionRotationalContentState, EventList) == 0x000098, "Member 'FOrionRotationalContentState::EventList' has a wrong offset!");
static_assert(offsetof(FOrionRotationalContentState, bEnableDoubleXP) == 0x0000A8, "Member 'FOrionRotationalContentState::bEnableDoubleXP' has a wrong offset!");
static_assert(offsetof(FOrionRotationalContentState, bEnableDoubleTimeCurrency) == 0x0000A9, "Member 'FOrionRotationalContentState::bEnableDoubleTimeCurrency' has a wrong offset!");
static_assert(offsetof(FOrionRotationalContentState, GameplayTags) == 0x0000B0, "Member 'FOrionRotationalContentState::GameplayTags' has a wrong offset!");

// ScriptStruct OrionGame.MigrationRecord42
// 0x0030 (0x0030 - 0x0000)
struct FMigrationRecord42 final
{
public:
	int32                                         DailyLoginLevel;                                   // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ModifiedAccountLevel;                              // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScoreChestsGrantedVeteran;                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FoundersBonusChests;                               // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OldCardCount;                                      // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GamesPlayed;                                       // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MasteryChests;                                     // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMigrationRecord42UpdatedHero>  HeroMasteries;                                     // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMigrationRecord42) == 0x000008, "Wrong alignment on FMigrationRecord42");
static_assert(sizeof(FMigrationRecord42) == 0x000030, "Wrong size on FMigrationRecord42");
static_assert(offsetof(FMigrationRecord42, DailyLoginLevel) == 0x000000, "Member 'FMigrationRecord42::DailyLoginLevel' has a wrong offset!");
static_assert(offsetof(FMigrationRecord42, ModifiedAccountLevel) == 0x000004, "Member 'FMigrationRecord42::ModifiedAccountLevel' has a wrong offset!");
static_assert(offsetof(FMigrationRecord42, ScoreChestsGrantedVeteran) == 0x000008, "Member 'FMigrationRecord42::ScoreChestsGrantedVeteran' has a wrong offset!");
static_assert(offsetof(FMigrationRecord42, FoundersBonusChests) == 0x00000C, "Member 'FMigrationRecord42::FoundersBonusChests' has a wrong offset!");
static_assert(offsetof(FMigrationRecord42, OldCardCount) == 0x000010, "Member 'FMigrationRecord42::OldCardCount' has a wrong offset!");
static_assert(offsetof(FMigrationRecord42, GamesPlayed) == 0x000014, "Member 'FMigrationRecord42::GamesPlayed' has a wrong offset!");
static_assert(offsetof(FMigrationRecord42, MasteryChests) == 0x000018, "Member 'FMigrationRecord42::MasteryChests' has a wrong offset!");
static_assert(offsetof(FMigrationRecord42, HeroMasteries) == 0x000020, "Member 'FMigrationRecord42::HeroMasteries' has a wrong offset!");

// ScriptStruct OrionGame.MigrationRecord
// 0x0030 (0x0030 - 0x0000)
struct FMigrationRecord final
{
public:
	struct FMigrationRecord42                     MigrationRecord42;                                 // 0x0000(0x0030)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FMigrationRecord) == 0x000008, "Wrong alignment on FMigrationRecord");
static_assert(sizeof(FMigrationRecord) == 0x000030, "Wrong size on FMigrationRecord");
static_assert(offsetof(FMigrationRecord, MigrationRecord42) == 0x000000, "Member 'FMigrationRecord::MigrationRecord42' has a wrong offset!");

// ScriptStruct OrionGame.HeroPlayCount
// 0x0018 (0x0018 - 0x0000)
struct FHeroPlayCount final
{
public:
	class FString                                 HeroName;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayCount;                                         // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHeroPlayCount) == 0x000008, "Wrong alignment on FHeroPlayCount");
static_assert(sizeof(FHeroPlayCount) == 0x000018, "Wrong size on FHeroPlayCount");
static_assert(offsetof(FHeroPlayCount, HeroName) == 0x000000, "Member 'FHeroPlayCount::HeroName' has a wrong offset!");
static_assert(offsetof(FHeroPlayCount, PlayCount) == 0x000010, "Member 'FHeroPlayCount::PlayCount' has a wrong offset!");

// ScriptStruct OrionGame.StaticActorReference
// 0x0020 (0x0020 - 0x0000)
struct FStaticActorReference final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFTestActorKey                                SuggestedKey;                                      // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomKey;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStaticActorReference) == 0x000008, "Wrong alignment on FStaticActorReference");
static_assert(sizeof(FStaticActorReference) == 0x000020, "Wrong size on FStaticActorReference");
static_assert(offsetof(FStaticActorReference, Actor) == 0x000000, "Member 'FStaticActorReference::Actor' has a wrong offset!");
static_assert(offsetof(FStaticActorReference, SuggestedKey) == 0x000008, "Member 'FStaticActorReference::SuggestedKey' has a wrong offset!");
static_assert(offsetof(FStaticActorReference, CustomKey) == 0x000010, "Member 'FStaticActorReference::CustomKey' has a wrong offset!");

// ScriptStruct OrionGame.AutomationPawnInfo
// 0x0018 (0x0018 - 0x0000)
struct FAutomationPawnInfo final
{
public:
	class APawn*                                  Pawn;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpawnLocation;                                     // 0x0008(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHealth;                                         // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAutomationPawnInfo) == 0x000008, "Wrong alignment on FAutomationPawnInfo");
static_assert(sizeof(FAutomationPawnInfo) == 0x000018, "Wrong size on FAutomationPawnInfo");
static_assert(offsetof(FAutomationPawnInfo, Pawn) == 0x000000, "Member 'FAutomationPawnInfo::Pawn' has a wrong offset!");
static_assert(offsetof(FAutomationPawnInfo, SpawnLocation) == 0x000008, "Member 'FAutomationPawnInfo::SpawnLocation' has a wrong offset!");
static_assert(offsetof(FAutomationPawnInfo, MaxHealth) == 0x000014, "Member 'FAutomationPawnInfo::MaxHealth' has a wrong offset!");

// ScriptStruct OrionGame.BoundTagDelegate
// 0x0018 (0x0018 - 0x0000)
struct FBoundTagDelegate final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 LockOnActor;                                       // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoundTagDelegate) == 0x000008, "Wrong alignment on FBoundTagDelegate");
static_assert(sizeof(FBoundTagDelegate) == 0x000018, "Wrong size on FBoundTagDelegate");
static_assert(offsetof(FBoundTagDelegate, LockOnActor) == 0x000010, "Member 'FBoundTagDelegate::LockOnActor' has a wrong offset!");

// ScriptStruct OrionGame.PickupSpawnInfo
// 0x0108 (0x0108 - 0x0000)
struct FPickupSpawnInfo final
{
public:
	TSubclassOf<class AOrionPickup>               PickupToSpawn;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionFilterAndEffectsContainer        PickupFilterAndEffectsContainer;                   // 0x0008(0x0020)(RepSkip, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnPointActor;                                  // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 HomingActor;                                       // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 CurrentHolder;                                     // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Owner;                                             // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    OwnerTeam;                                         // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHasReturnPoint : 1;                               // 0x0049(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHoming : 1;                                       // 0x0049(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bJoinInProgress : 1;                               // 0x0049(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCarried : 1;                                      // 0x0049(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  SourceTags;                                        // 0x0050(0x0020)(NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  SourceAssetTags;                                   // 0x0070(0x0020)(NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  HomingCallbackTags;                                // 0x0090(0x0020)(NativeAccessSpecifierPublic)
	struct FVector                                SpawnLocation;                                     // 0x00B0(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DropLocation;                                      // 0x00BC(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TestLocation;                                      // 0x00C8(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        UniquePickupID;                                    // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExpireTime;                                        // 0x00E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KillerCXP;                                         // 0x00E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AssisterCXP;                                       // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AOrionPlayerState_Game*>         CoinAssisters;                                     // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         PickupGELevel;                                     // 0x0100(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPickupSpawnInfo) == 0x000008, "Wrong alignment on FPickupSpawnInfo");
static_assert(sizeof(FPickupSpawnInfo) == 0x000108, "Wrong size on FPickupSpawnInfo");
static_assert(offsetof(FPickupSpawnInfo, PickupToSpawn) == 0x000000, "Member 'FPickupSpawnInfo::PickupToSpawn' has a wrong offset!");
static_assert(offsetof(FPickupSpawnInfo, PickupFilterAndEffectsContainer) == 0x000008, "Member 'FPickupSpawnInfo::PickupFilterAndEffectsContainer' has a wrong offset!");
static_assert(offsetof(FPickupSpawnInfo, ReturnPointActor) == 0x000028, "Member 'FPickupSpawnInfo::ReturnPointActor' has a wrong offset!");
static_assert(offsetof(FPickupSpawnInfo, HomingActor) == 0x000030, "Member 'FPickupSpawnInfo::HomingActor' has a wrong offset!");
static_assert(offsetof(FPickupSpawnInfo, CurrentHolder) == 0x000038, "Member 'FPickupSpawnInfo::CurrentHolder' has a wrong offset!");
static_assert(offsetof(FPickupSpawnInfo, Owner) == 0x000040, "Member 'FPickupSpawnInfo::Owner' has a wrong offset!");
static_assert(offsetof(FPickupSpawnInfo, OwnerTeam) == 0x000048, "Member 'FPickupSpawnInfo::OwnerTeam' has a wrong offset!");
static_assert(offsetof(FPickupSpawnInfo, SourceTags) == 0x000050, "Member 'FPickupSpawnInfo::SourceTags' has a wrong offset!");
static_assert(offsetof(FPickupSpawnInfo, SourceAssetTags) == 0x000070, "Member 'FPickupSpawnInfo::SourceAssetTags' has a wrong offset!");
static_assert(offsetof(FPickupSpawnInfo, HomingCallbackTags) == 0x000090, "Member 'FPickupSpawnInfo::HomingCallbackTags' has a wrong offset!");
static_assert(offsetof(FPickupSpawnInfo, SpawnLocation) == 0x0000B0, "Member 'FPickupSpawnInfo::SpawnLocation' has a wrong offset!");
static_assert(offsetof(FPickupSpawnInfo, DropLocation) == 0x0000BC, "Member 'FPickupSpawnInfo::DropLocation' has a wrong offset!");
static_assert(offsetof(FPickupSpawnInfo, TestLocation) == 0x0000C8, "Member 'FPickupSpawnInfo::TestLocation' has a wrong offset!");
static_assert(offsetof(FPickupSpawnInfo, UniquePickupID) == 0x0000D8, "Member 'FPickupSpawnInfo::UniquePickupID' has a wrong offset!");
static_assert(offsetof(FPickupSpawnInfo, StartTime) == 0x0000E0, "Member 'FPickupSpawnInfo::StartTime' has a wrong offset!");
static_assert(offsetof(FPickupSpawnInfo, ExpireTime) == 0x0000E4, "Member 'FPickupSpawnInfo::ExpireTime' has a wrong offset!");
static_assert(offsetof(FPickupSpawnInfo, KillerCXP) == 0x0000E8, "Member 'FPickupSpawnInfo::KillerCXP' has a wrong offset!");
static_assert(offsetof(FPickupSpawnInfo, AssisterCXP) == 0x0000EC, "Member 'FPickupSpawnInfo::AssisterCXP' has a wrong offset!");
static_assert(offsetof(FPickupSpawnInfo, CoinAssisters) == 0x0000F0, "Member 'FPickupSpawnInfo::CoinAssisters' has a wrong offset!");
static_assert(offsetof(FPickupSpawnInfo, PickupGELevel) == 0x000100, "Member 'FPickupSpawnInfo::PickupGELevel' has a wrong offset!");

// ScriptStruct OrionGame.PickupTicker
// 0x0010 (0x0010 - 0x0000)
struct FPickupTicker final
{
public:
	float                                         StartTime;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExpireTime;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionPickup*                           Pickup;                                            // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPickupTicker) == 0x000008, "Wrong alignment on FPickupTicker");
static_assert(sizeof(FPickupTicker) == 0x000010, "Wrong size on FPickupTicker");
static_assert(offsetof(FPickupTicker, StartTime) == 0x000000, "Member 'FPickupTicker::StartTime' has a wrong offset!");
static_assert(offsetof(FPickupTicker, ExpireTime) == 0x000004, "Member 'FPickupTicker::ExpireTime' has a wrong offset!");
static_assert(offsetof(FPickupTicker, Pickup) == 0x000008, "Member 'FPickupTicker::Pickup' has a wrong offset!");

// ScriptStruct OrionGame.PickupPoolData
// 0x0048 (0x0048 - 0x0000)
struct FPickupPoolData final
{
public:
	TSubclassOf<class AOrionPickup>               PickupActorClass;                                  // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AOrionPickup*>                   PickupActorPool;                                   // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPickupTicker>                  PickupsInUse_Heap;                                 // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPickupTicker>                  InterpolatingPickups_Heap;                         // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPickupTicker>                  NonInterpolatingPickups_Heap;                      // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPickupPoolData) == 0x000008, "Wrong alignment on FPickupPoolData");
static_assert(sizeof(FPickupPoolData) == 0x000048, "Wrong size on FPickupPoolData");
static_assert(offsetof(FPickupPoolData, PickupActorClass) == 0x000000, "Member 'FPickupPoolData::PickupActorClass' has a wrong offset!");
static_assert(offsetof(FPickupPoolData, PickupActorPool) == 0x000008, "Member 'FPickupPoolData::PickupActorPool' has a wrong offset!");
static_assert(offsetof(FPickupPoolData, PickupsInUse_Heap) == 0x000018, "Member 'FPickupPoolData::PickupsInUse_Heap' has a wrong offset!");
static_assert(offsetof(FPickupPoolData, InterpolatingPickups_Heap) == 0x000028, "Member 'FPickupPoolData::InterpolatingPickups_Heap' has a wrong offset!");
static_assert(offsetof(FPickupPoolData, NonInterpolatingPickups_Heap) == 0x000038, "Member 'FPickupPoolData::NonInterpolatingPickups_Heap' has a wrong offset!");

// ScriptStruct OrionGame.GravesiteCamInfo
// 0x0110 (0x0110 - 0x0000)
struct alignas(0x10) FGravesiteCamInfo final
{
public:
	uint8                                         Pad_0[0x108];                                      // 0x0000(0x0108)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 OptKillerActor;                                    // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGravesiteCamInfo) == 0x000010, "Wrong alignment on FGravesiteCamInfo");
static_assert(sizeof(FGravesiteCamInfo) == 0x000110, "Wrong size on FGravesiteCamInfo");
static_assert(offsetof(FGravesiteCamInfo, OptKillerActor) == 0x000108, "Member 'FGravesiteCamInfo::OptKillerActor' has a wrong offset!");

// ScriptStruct OrionGame.OrionPlayerInitialAnalytics
// 0x0008 (0x0008 - 0x0000)
struct FOrionPlayerInitialAnalytics final
{
public:
	int32                                         MatchmakingTimeSec;                                // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PartySize;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionPlayerInitialAnalytics) == 0x000004, "Wrong alignment on FOrionPlayerInitialAnalytics");
static_assert(sizeof(FOrionPlayerInitialAnalytics) == 0x000008, "Wrong size on FOrionPlayerInitialAnalytics");
static_assert(offsetof(FOrionPlayerInitialAnalytics, MatchmakingTimeSec) == 0x000000, "Member 'FOrionPlayerInitialAnalytics::MatchmakingTimeSec' has a wrong offset!");
static_assert(offsetof(FOrionPlayerInitialAnalytics, PartySize) == 0x000004, "Member 'FOrionPlayerInitialAnalytics::PartySize' has a wrong offset!");

// ScriptStruct OrionGame.ExplicitLootTierInfo
// 0x0010 (0x0010 - 0x0000)
struct FExplicitLootTierInfo final
{
public:
	TArray<class UOrionMcpItemDefinition*>        Rewards;                                           // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExplicitLootTierInfo) == 0x000008, "Wrong alignment on FExplicitLootTierInfo");
static_assert(sizeof(FExplicitLootTierInfo) == 0x000010, "Wrong size on FExplicitLootTierInfo");
static_assert(offsetof(FExplicitLootTierInfo, Rewards) == 0x000000, "Member 'FExplicitLootTierInfo::Rewards' has a wrong offset!");

// ScriptStruct OrionGame.OrionTeamCommMessage
// 0x0020 (0x0020 - 0x0000)
struct FOrionTeamCommMessage final
{
public:
	struct FVector                                SenderLocation;                                    // 0x0000(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrionPlayerState_Game*                 SendingPlayer;                                     // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPCTeamCommunicationsData*              TeamCommData;                                      // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionTeamCommMessage) == 0x000008, "Wrong alignment on FOrionTeamCommMessage");
static_assert(sizeof(FOrionTeamCommMessage) == 0x000020, "Wrong size on FOrionTeamCommMessage");
static_assert(offsetof(FOrionTeamCommMessage, SenderLocation) == 0x000000, "Member 'FOrionTeamCommMessage::SenderLocation' has a wrong offset!");
static_assert(offsetof(FOrionTeamCommMessage, SendingPlayer) == 0x000010, "Member 'FOrionTeamCommMessage::SendingPlayer' has a wrong offset!");
static_assert(offsetof(FOrionTeamCommMessage, TeamCommData) == 0x000018, "Member 'FOrionTeamCommMessage::TeamCommData' has a wrong offset!");

// ScriptStruct OrionGame.OrionPlayerInput_AxisMapping
// 0x0020 (0x0020 - 0x0000)
struct FOrionPlayerInput_AxisMapping final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Axis;                                              // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionPlayerInput_AxisMapping) == 0x000008, "Wrong alignment on FOrionPlayerInput_AxisMapping");
static_assert(sizeof(FOrionPlayerInput_AxisMapping) == 0x000020, "Wrong size on FOrionPlayerInput_AxisMapping");
static_assert(offsetof(FOrionPlayerInput_AxisMapping, Key) == 0x000000, "Member 'FOrionPlayerInput_AxisMapping::Key' has a wrong offset!");
static_assert(offsetof(FOrionPlayerInput_AxisMapping, Axis) == 0x000018, "Member 'FOrionPlayerInput_AxisMapping::Axis' has a wrong offset!");

// ScriptStruct OrionGame.ArcadeBuffInfo
// 0x0014 (0x0020 - 0x000C)
struct FArcadeBuffInfo final : public FFastArraySerializerItem
{
public:
	struct FActiveGameplayEffectHandle            EffectHandle;                                      // 0x000C(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            GameplayEffect;                                    // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArcadeBuffInfo) == 0x000008, "Wrong alignment on FArcadeBuffInfo");
static_assert(sizeof(FArcadeBuffInfo) == 0x000020, "Wrong size on FArcadeBuffInfo");
static_assert(offsetof(FArcadeBuffInfo, EffectHandle) == 0x00000C, "Member 'FArcadeBuffInfo::EffectHandle' has a wrong offset!");
static_assert(offsetof(FArcadeBuffInfo, GameplayEffect) == 0x000018, "Member 'FArcadeBuffInfo::GameplayEffect' has a wrong offset!");

// ScriptStruct OrionGame.ArcadeBuffContainer
// 0x0020 (0x00D0 - 0x00B0)
struct FArcadeBuffContainer final : public FFastArraySerializer
{
public:
	TArray<struct FArcadeBuffInfo>                Entries;                                           // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsBuffArray;                                      // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrionPlayerState_Arcade*               Parent;                                            // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArcadeBuffContainer) == 0x000008, "Wrong alignment on FArcadeBuffContainer");
static_assert(sizeof(FArcadeBuffContainer) == 0x0000D0, "Wrong size on FArcadeBuffContainer");
static_assert(offsetof(FArcadeBuffContainer, Entries) == 0x0000B0, "Member 'FArcadeBuffContainer::Entries' has a wrong offset!");
static_assert(offsetof(FArcadeBuffContainer, bIsBuffArray) == 0x0000C0, "Member 'FArcadeBuffContainer::bIsBuffArray' has a wrong offset!");
static_assert(offsetof(FArcadeBuffContainer, Parent) == 0x0000C8, "Member 'FArcadeBuffContainer::Parent' has a wrong offset!");

// ScriptStruct OrionGame.OrionDraftPlayerPreferences
// 0x0002 (0x0002 - 0x0000)
struct FOrionDraftPlayerPreferences final
{
public:
	EOrionRole                                    Role;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionPosition                                Position;                                          // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionDraftPlayerPreferences) == 0x000001, "Wrong alignment on FOrionDraftPlayerPreferences");
static_assert(sizeof(FOrionDraftPlayerPreferences) == 0x000002, "Wrong size on FOrionDraftPlayerPreferences");
static_assert(offsetof(FOrionDraftPlayerPreferences, Role) == 0x000000, "Member 'FOrionDraftPlayerPreferences::Role' has a wrong offset!");
static_assert(offsetof(FOrionDraftPlayerPreferences, Position) == 0x000001, "Member 'FOrionDraftPlayerPreferences::Position' has a wrong offset!");

// ScriptStruct OrionGame.TeamSpecificDraftPlayerInfo
// 0x0038 (0x0038 - 0x0000)
struct FTeamSpecificDraftPlayerInfo final
{
public:
	EOrionTeam                                    TeamIndex;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionDraftPlayerPreferences           Preferences;                                       // 0x0001(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionDraftHeroSelectionInfo           PreviewHeroSelection;                              // 0x0008(0x0030)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FTeamSpecificDraftPlayerInfo) == 0x000008, "Wrong alignment on FTeamSpecificDraftPlayerInfo");
static_assert(sizeof(FTeamSpecificDraftPlayerInfo) == 0x000038, "Wrong size on FTeamSpecificDraftPlayerInfo");
static_assert(offsetof(FTeamSpecificDraftPlayerInfo, TeamIndex) == 0x000000, "Member 'FTeamSpecificDraftPlayerInfo::TeamIndex' has a wrong offset!");
static_assert(offsetof(FTeamSpecificDraftPlayerInfo, Preferences) == 0x000001, "Member 'FTeamSpecificDraftPlayerInfo::Preferences' has a wrong offset!");
static_assert(offsetof(FTeamSpecificDraftPlayerInfo, PreviewHeroSelection) == 0x000008, "Member 'FTeamSpecificDraftPlayerInfo::PreviewHeroSelection' has a wrong offset!");

// ScriptStruct OrionGame.NameplateAndPortrait
// 0x0038 (0x0038 - 0x0000)
struct FNameplateAndPortrait final
{
public:
	struct FVector                                Position;                                          // 0x0000(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   NameString;                                        // 0x0010(0x0018)(NativeAccessSpecifierPublic)
	class UFont*                                  Font;                                              // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionBanner*                           Banner;                                            // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNameplateAndPortrait) == 0x000008, "Wrong alignment on FNameplateAndPortrait");
static_assert(sizeof(FNameplateAndPortrait) == 0x000038, "Wrong size on FNameplateAndPortrait");
static_assert(offsetof(FNameplateAndPortrait, Position) == 0x000000, "Member 'FNameplateAndPortrait::Position' has a wrong offset!");
static_assert(offsetof(FNameplateAndPortrait, Alpha) == 0x00000C, "Member 'FNameplateAndPortrait::Alpha' has a wrong offset!");
static_assert(offsetof(FNameplateAndPortrait, NameString) == 0x000010, "Member 'FNameplateAndPortrait::NameString' has a wrong offset!");
static_assert(offsetof(FNameplateAndPortrait, Font) == 0x000028, "Member 'FNameplateAndPortrait::Font' has a wrong offset!");
static_assert(offsetof(FNameplateAndPortrait, Banner) == 0x000030, "Member 'FNameplateAndPortrait::Banner' has a wrong offset!");

// ScriptStruct OrionGame.BannerSpawnOnKillInfo
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FBannerSpawnOnKillInfo final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TrackedStackCount;                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrackedEndTime;                                    // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBannerSpawnOnKillInfo) == 0x000008, "Wrong alignment on FBannerSpawnOnKillInfo");
static_assert(sizeof(FBannerSpawnOnKillInfo) == 0x000010, "Wrong size on FBannerSpawnOnKillInfo");
static_assert(offsetof(FBannerSpawnOnKillInfo, Name) == 0x000000, "Member 'FBannerSpawnOnKillInfo::Name' has a wrong offset!");
static_assert(offsetof(FBannerSpawnOnKillInfo, TrackedStackCount) == 0x000008, "Member 'FBannerSpawnOnKillInfo::TrackedStackCount' has a wrong offset!");
static_assert(offsetof(FBannerSpawnOnKillInfo, TrackedEndTime) == 0x00000C, "Member 'FBannerSpawnOnKillInfo::TrackedEndTime' has a wrong offset!");

// ScriptStruct OrionGame.OrionIndividualPlayerRating
// 0x0048 (0x0048 - 0x0000)
struct FOrionIndividualPlayerRating final
{
public:
	class FText                                   RatingName;                                        // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                   RatingId;                                          // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   RatingDesc;                                        // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTexture2D*                             DefaultIcon;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerRatingResult                           RatingValue;                                       // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionIndividualPlayerRating) == 0x000008, "Wrong alignment on FOrionIndividualPlayerRating");
static_assert(sizeof(FOrionIndividualPlayerRating) == 0x000048, "Wrong size on FOrionIndividualPlayerRating");
static_assert(offsetof(FOrionIndividualPlayerRating, RatingName) == 0x000000, "Member 'FOrionIndividualPlayerRating::RatingName' has a wrong offset!");
static_assert(offsetof(FOrionIndividualPlayerRating, RatingId) == 0x000018, "Member 'FOrionIndividualPlayerRating::RatingId' has a wrong offset!");
static_assert(offsetof(FOrionIndividualPlayerRating, RatingDesc) == 0x000020, "Member 'FOrionIndividualPlayerRating::RatingDesc' has a wrong offset!");
static_assert(offsetof(FOrionIndividualPlayerRating, DefaultIcon) == 0x000038, "Member 'FOrionIndividualPlayerRating::DefaultIcon' has a wrong offset!");
static_assert(offsetof(FOrionIndividualPlayerRating, RatingValue) == 0x000040, "Member 'FOrionIndividualPlayerRating::RatingValue' has a wrong offset!");

// ScriptStruct OrionGame.MatchSummaryScoreboardGem
// 0x0028 (0x0028 - 0x0000)
struct FMatchSummaryScoreboardGem final
{
public:
	TWeakObjectPtr<class UOrionMcpGemItemDefinition> GemDefinition;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGemAbilityPropertyLevels>      AllAbilityPropertyLevels;                          // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         DisplayLevel;                                      // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OverrideLevel;                                     // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasActive;                                        // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMatchSummaryScoreboardGem) == 0x000008, "Wrong alignment on FMatchSummaryScoreboardGem");
static_assert(sizeof(FMatchSummaryScoreboardGem) == 0x000028, "Wrong size on FMatchSummaryScoreboardGem");
static_assert(offsetof(FMatchSummaryScoreboardGem, GemDefinition) == 0x000000, "Member 'FMatchSummaryScoreboardGem::GemDefinition' has a wrong offset!");
static_assert(offsetof(FMatchSummaryScoreboardGem, AllAbilityPropertyLevels) == 0x000008, "Member 'FMatchSummaryScoreboardGem::AllAbilityPropertyLevels' has a wrong offset!");
static_assert(offsetof(FMatchSummaryScoreboardGem, DisplayLevel) == 0x000018, "Member 'FMatchSummaryScoreboardGem::DisplayLevel' has a wrong offset!");
static_assert(offsetof(FMatchSummaryScoreboardGem, OverrideLevel) == 0x00001C, "Member 'FMatchSummaryScoreboardGem::OverrideLevel' has a wrong offset!");
static_assert(offsetof(FMatchSummaryScoreboardGem, bWasActive) == 0x000020, "Member 'FMatchSummaryScoreboardGem::bWasActive' has a wrong offset!");

// ScriptStruct OrionGame.MatchSummaryScoreboardCard
// 0x0010 (0x0010 - 0x0000)
struct FMatchSummaryScoreboardCard final
{
public:
	TWeakObjectPtr<class UOrionMcpCardItemDefinition> CardDefinition;                                    // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CardLevel;                                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CardAbilityLevel;                                  // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchSummaryScoreboardCard) == 0x000004, "Wrong alignment on FMatchSummaryScoreboardCard");
static_assert(sizeof(FMatchSummaryScoreboardCard) == 0x000010, "Wrong size on FMatchSummaryScoreboardCard");
static_assert(offsetof(FMatchSummaryScoreboardCard, CardDefinition) == 0x000000, "Member 'FMatchSummaryScoreboardCard::CardDefinition' has a wrong offset!");
static_assert(offsetof(FMatchSummaryScoreboardCard, CardLevel) == 0x000008, "Member 'FMatchSummaryScoreboardCard::CardLevel' has a wrong offset!");
static_assert(offsetof(FMatchSummaryScoreboardCard, CardAbilityLevel) == 0x00000C, "Member 'FMatchSummaryScoreboardCard::CardAbilityLevel' has a wrong offset!");

// ScriptStruct OrionGame.MatchSummaryScoreboardRowInfo
// 0x00A8 (0x00A8 - 0x0000)
struct FMatchSummaryScoreboardRowInfo final
{
public:
	bool                                          bIsLocalPlayer;                                    // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayedOnPC;                                       // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlayerName;                                        // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUniqueNetIdRepl                       PlayerNetId;                                       // 0x0018(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UOrionHeroData>          PlayedHero;                                        // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionHeroMasteryProgression           HeroMasteryProgress;                               // 0x0038(0x0020)(NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsBot;                                            // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIBotDifficulty                              BotDifficulty;                                     // 0x0059(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMatchSummaryScoreboardGem>     Gems;                                              // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMatchSummaryScoreboardCard>    EquippedCards;                                     // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         MatchLevel;                                        // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCurrencyBundle                PipTotals;                                         // 0x0084(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	int32                                         NumKills;                                          // 0x0094(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumDeaths;                                         // 0x0098(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumAssists;                                        // 0x009C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumMinionKills;                                    // 0x00A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalGold;                                         // 0x00A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchSummaryScoreboardRowInfo) == 0x000008, "Wrong alignment on FMatchSummaryScoreboardRowInfo");
static_assert(sizeof(FMatchSummaryScoreboardRowInfo) == 0x0000A8, "Wrong size on FMatchSummaryScoreboardRowInfo");
static_assert(offsetof(FMatchSummaryScoreboardRowInfo, bIsLocalPlayer) == 0x000000, "Member 'FMatchSummaryScoreboardRowInfo::bIsLocalPlayer' has a wrong offset!");
static_assert(offsetof(FMatchSummaryScoreboardRowInfo, bPlayedOnPC) == 0x000001, "Member 'FMatchSummaryScoreboardRowInfo::bPlayedOnPC' has a wrong offset!");
static_assert(offsetof(FMatchSummaryScoreboardRowInfo, PlayerName) == 0x000008, "Member 'FMatchSummaryScoreboardRowInfo::PlayerName' has a wrong offset!");
static_assert(offsetof(FMatchSummaryScoreboardRowInfo, PlayerNetId) == 0x000018, "Member 'FMatchSummaryScoreboardRowInfo::PlayerNetId' has a wrong offset!");
static_assert(offsetof(FMatchSummaryScoreboardRowInfo, PlayedHero) == 0x000030, "Member 'FMatchSummaryScoreboardRowInfo::PlayedHero' has a wrong offset!");
static_assert(offsetof(FMatchSummaryScoreboardRowInfo, HeroMasteryProgress) == 0x000038, "Member 'FMatchSummaryScoreboardRowInfo::HeroMasteryProgress' has a wrong offset!");
static_assert(offsetof(FMatchSummaryScoreboardRowInfo, bIsBot) == 0x000058, "Member 'FMatchSummaryScoreboardRowInfo::bIsBot' has a wrong offset!");
static_assert(offsetof(FMatchSummaryScoreboardRowInfo, BotDifficulty) == 0x000059, "Member 'FMatchSummaryScoreboardRowInfo::BotDifficulty' has a wrong offset!");
static_assert(offsetof(FMatchSummaryScoreboardRowInfo, Gems) == 0x000060, "Member 'FMatchSummaryScoreboardRowInfo::Gems' has a wrong offset!");
static_assert(offsetof(FMatchSummaryScoreboardRowInfo, EquippedCards) == 0x000070, "Member 'FMatchSummaryScoreboardRowInfo::EquippedCards' has a wrong offset!");
static_assert(offsetof(FMatchSummaryScoreboardRowInfo, MatchLevel) == 0x000080, "Member 'FMatchSummaryScoreboardRowInfo::MatchLevel' has a wrong offset!");
static_assert(offsetof(FMatchSummaryScoreboardRowInfo, PipTotals) == 0x000084, "Member 'FMatchSummaryScoreboardRowInfo::PipTotals' has a wrong offset!");
static_assert(offsetof(FMatchSummaryScoreboardRowInfo, NumKills) == 0x000094, "Member 'FMatchSummaryScoreboardRowInfo::NumKills' has a wrong offset!");
static_assert(offsetof(FMatchSummaryScoreboardRowInfo, NumDeaths) == 0x000098, "Member 'FMatchSummaryScoreboardRowInfo::NumDeaths' has a wrong offset!");
static_assert(offsetof(FMatchSummaryScoreboardRowInfo, NumAssists) == 0x00009C, "Member 'FMatchSummaryScoreboardRowInfo::NumAssists' has a wrong offset!");
static_assert(offsetof(FMatchSummaryScoreboardRowInfo, NumMinionKills) == 0x0000A0, "Member 'FMatchSummaryScoreboardRowInfo::NumMinionKills' has a wrong offset!");
static_assert(offsetof(FMatchSummaryScoreboardRowInfo, TotalGold) == 0x0000A4, "Member 'FMatchSummaryScoreboardRowInfo::TotalGold' has a wrong offset!");

// ScriptStruct OrionGame.ProfanityData
// 0x0038 (0x0038 - 0x0000)
struct FProfanityData final
{
public:
	class FString                                 CountryCode;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ProfanityList;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WhiteList;                                         // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoAdd;                                          // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProfanityData) == 0x000008, "Wrong alignment on FProfanityData");
static_assert(sizeof(FProfanityData) == 0x000038, "Wrong size on FProfanityData");
static_assert(offsetof(FProfanityData, CountryCode) == 0x000000, "Member 'FProfanityData::CountryCode' has a wrong offset!");
static_assert(offsetof(FProfanityData, ProfanityList) == 0x000010, "Member 'FProfanityData::ProfanityList' has a wrong offset!");
static_assert(offsetof(FProfanityData, WhiteList) == 0x000020, "Member 'FProfanityData::WhiteList' has a wrong offset!");
static_assert(offsetof(FProfanityData, bAutoAdd) == 0x000030, "Member 'FProfanityData::bAutoAdd' has a wrong offset!");

// ScriptStruct OrionGame.ProjectileOverlappedActors
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FProjectileOverlappedActors final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProjectileOverlappedActors) == 0x000004, "Wrong alignment on FProjectileOverlappedActors");
static_assert(sizeof(FProjectileOverlappedActors) == 0x00000C, "Wrong size on FProjectileOverlappedActors");

// ScriptStruct OrionGame.ProjectileTimeDilationChannel
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x04) FProjectileTimeDilationChannel final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProjectileTimeDilationChannel) == 0x000004, "Wrong alignment on FProjectileTimeDilationChannel");
static_assert(sizeof(FProjectileTimeDilationChannel) == 0x000020, "Wrong size on FProjectileTimeDilationChannel");

// ScriptStruct OrionGame.OrionProjectileSpeed
// 0x0008 (0x0008 - 0x0000)
struct FOrionProjectileSpeed final
{
public:
	float                                         Coeffecient;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionProjectileSpeed                         SpeedType;                                         // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionProjectileSpeed) == 0x000004, "Wrong alignment on FOrionProjectileSpeed");
static_assert(sizeof(FOrionProjectileSpeed) == 0x000008, "Wrong size on FOrionProjectileSpeed");
static_assert(offsetof(FOrionProjectileSpeed, Coeffecient) == 0x000000, "Member 'FOrionProjectileSpeed::Coeffecient' has a wrong offset!");
static_assert(offsetof(FOrionProjectileSpeed, SpeedType) == 0x000004, "Member 'FOrionProjectileSpeed::SpeedType' has a wrong offset!");

// ScriptStruct OrionGame.ProjFindFloorResult
// 0x0098 (0x0098 - 0x0000)
struct FProjFindFloorResult final
{
public:
	uint8                                         bBlockingHit : 1;                                  // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bWalkableFloor : 1;                                // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLineTrace : 1;                                    // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FloorDist;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineDist;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             HitResult;                                         // 0x0010(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProjFindFloorResult) == 0x000008, "Wrong alignment on FProjFindFloorResult");
static_assert(sizeof(FProjFindFloorResult) == 0x000098, "Wrong size on FProjFindFloorResult");
static_assert(offsetof(FProjFindFloorResult, FloorDist) == 0x000004, "Member 'FProjFindFloorResult::FloorDist' has a wrong offset!");
static_assert(offsetof(FProjFindFloorResult, LineDist) == 0x000008, "Member 'FProjFindFloorResult::LineDist' has a wrong offset!");
static_assert(offsetof(FProjFindFloorResult, HitResult) == 0x000010, "Member 'FProjFindFloorResult::HitResult' has a wrong offset!");

// ScriptStruct OrionGame.QualiferContext_AuxiliaryActor
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FQualiferContext_AuxiliaryActor final : public FQualifierContextBase
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQualiferContext_AuxiliaryActor) == 0x000008, "Wrong alignment on FQualiferContext_AuxiliaryActor");
static_assert(sizeof(FQualiferContext_AuxiliaryActor) == 0x000028, "Wrong size on FQualiferContext_AuxiliaryActor");

// ScriptStruct OrionGame.QualifierContext_AttributeChangePCT
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FQualifierContext_AttributeChangePCT final : public FQualifierContextBase
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQualifierContext_AttributeChangePCT) == 0x000004, "Wrong alignment on FQualifierContext_AttributeChangePCT");
static_assert(sizeof(FQualifierContext_AttributeChangePCT) == 0x000008, "Wrong size on FQualifierContext_AttributeChangePCT");

// ScriptStruct OrionGame.QualifierContextPlayer
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FQualifierContextPlayer final : public FQualifierContextBase
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQualifierContextPlayer) == 0x000008, "Wrong alignment on FQualifierContextPlayer");
static_assert(sizeof(FQualifierContextPlayer) == 0x000008, "Wrong size on FQualifierContextPlayer");

// ScriptStruct OrionGame.GameplayQualifierGameplayEffectQueryData
// 0x0090 (0x0090 - 0x0000)
struct FGameplayQualifierGameplayEffectQueryData final
{
public:
	struct FGameplayTagQuery                      SourceTagQuery;                                    // 0x0000(0x0048)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      TargetTagQuery;                                    // 0x0048(0x0048)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayQualifierGameplayEffectQueryData) == 0x000008, "Wrong alignment on FGameplayQualifierGameplayEffectQueryData");
static_assert(sizeof(FGameplayQualifierGameplayEffectQueryData) == 0x000090, "Wrong size on FGameplayQualifierGameplayEffectQueryData");
static_assert(offsetof(FGameplayQualifierGameplayEffectQueryData, SourceTagQuery) == 0x000000, "Member 'FGameplayQualifierGameplayEffectQueryData::SourceTagQuery' has a wrong offset!");
static_assert(offsetof(FGameplayQualifierGameplayEffectQueryData, TargetTagQuery) == 0x000048, "Member 'FGameplayQualifierGameplayEffectQueryData::TargetTagQuery' has a wrong offset!");

// ScriptStruct OrionGame.GameplayQualifierKeywordData
// 0x04A8 (0x04B0 - 0x0008)
struct FGameplayQualifierKeywordData final : public FTableRowBase
{
public:
	struct FGameplayTagQuery                      MatchTagQuery;                                     // 0x0008(0x0048)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      PostMatchTagQuery;                                 // 0x0050(0x0048)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayEffectQuery                   PlayerStateQuery;                                  // 0x00A0(0x0170)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayEffectQuery                   AuxiliaryQuery;                                    // 0x0210(0x0170)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      AuxiliaryGrantedTagQuery;                          // 0x0380(0x0048)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayQualifierGameplayEffectQueryData GameplayEffectQuery;                               // 0x03C8(0x0090)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_458[0x58];                                     // 0x0458(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayQualifierKeywordData) == 0x000010, "Wrong alignment on FGameplayQualifierKeywordData");
static_assert(sizeof(FGameplayQualifierKeywordData) == 0x0004B0, "Wrong size on FGameplayQualifierKeywordData");
static_assert(offsetof(FGameplayQualifierKeywordData, MatchTagQuery) == 0x000008, "Member 'FGameplayQualifierKeywordData::MatchTagQuery' has a wrong offset!");
static_assert(offsetof(FGameplayQualifierKeywordData, PostMatchTagQuery) == 0x000050, "Member 'FGameplayQualifierKeywordData::PostMatchTagQuery' has a wrong offset!");
static_assert(offsetof(FGameplayQualifierKeywordData, PlayerStateQuery) == 0x0000A0, "Member 'FGameplayQualifierKeywordData::PlayerStateQuery' has a wrong offset!");
static_assert(offsetof(FGameplayQualifierKeywordData, AuxiliaryQuery) == 0x000210, "Member 'FGameplayQualifierKeywordData::AuxiliaryQuery' has a wrong offset!");
static_assert(offsetof(FGameplayQualifierKeywordData, AuxiliaryGrantedTagQuery) == 0x000380, "Member 'FGameplayQualifierKeywordData::AuxiliaryGrantedTagQuery' has a wrong offset!");
static_assert(offsetof(FGameplayQualifierKeywordData, GameplayEffectQuery) == 0x0003C8, "Member 'FGameplayQualifierKeywordData::GameplayEffectQuery' has a wrong offset!");

// ScriptStruct OrionGame.WatchedActorInfo
// 0x0040 (0x0040 - 0x0000)
struct FWatchedActorInfo final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x38];                                       // 0x0008(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWatchedActorInfo) == 0x000008, "Wrong alignment on FWatchedActorInfo");
static_assert(sizeof(FWatchedActorInfo) == 0x000040, "Wrong size on FWatchedActorInfo");
static_assert(offsetof(FWatchedActorInfo, Actor) == 0x000000, "Member 'FWatchedActorInfo::Actor' has a wrong offset!");

// ScriptStruct OrionGame.OrionBannerSetDefinition
// 0x0020 (0x0020 - 0x0000)
struct FOrionBannerSetDefinition final
{
public:
	class UOrionMcpTokenItemDefinition*           BannerSetToken;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionMcpBannerItemDefinition*          Banner;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UOrionMcpBannerAlterationItemDefinition*> Dyes;                                              // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionBannerSetDefinition) == 0x000008, "Wrong alignment on FOrionBannerSetDefinition");
static_assert(sizeof(FOrionBannerSetDefinition) == 0x000020, "Wrong size on FOrionBannerSetDefinition");
static_assert(offsetof(FOrionBannerSetDefinition, BannerSetToken) == 0x000000, "Member 'FOrionBannerSetDefinition::BannerSetToken' has a wrong offset!");
static_assert(offsetof(FOrionBannerSetDefinition, Banner) == 0x000008, "Member 'FOrionBannerSetDefinition::Banner' has a wrong offset!");
static_assert(offsetof(FOrionBannerSetDefinition, Dyes) == 0x000010, "Member 'FOrionBannerSetDefinition::Dyes' has a wrong offset!");

// ScriptStruct OrionGame.PlayerRatingObj
// 0x0058 (0x0058 - 0x0000)
struct alignas(0x08) FPlayerRatingObj final
{
public:
	uint8                                         Pad_0[0x58];                                       // 0x0000(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerRatingObj) == 0x000008, "Wrong alignment on FPlayerRatingObj");
static_assert(sizeof(FPlayerRatingObj) == 0x000058, "Wrong size on FPlayerRatingObj");

// ScriptStruct OrionGame.OrionBadgeRewardInfo
// 0x0008 (0x0070 - 0x0068)
struct FOrionBadgeRewardInfo final : public FOrionRewardTypeInfo
{
public:
	int32                                         MinLevel;                                          // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionBadgeRewardInfo) == 0x000008, "Wrong alignment on FOrionBadgeRewardInfo");
static_assert(sizeof(FOrionBadgeRewardInfo) == 0x000070, "Wrong size on FOrionBadgeRewardInfo");
static_assert(offsetof(FOrionBadgeRewardInfo, MinLevel) == 0x000068, "Member 'FOrionBadgeRewardInfo::MinLevel' has a wrong offset!");

// ScriptStruct OrionGame.OrionQuickChatTopic
// 0x0098 (0x0098 - 0x0000)
struct FOrionQuickChatTopic final
{
public:
	class FText                                   TopicTitle;                                        // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FOrionQuickChatMessageInfo             MessageFormats[0x4];                               // 0x0018(0x0020)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionQuickChatTopic) == 0x000008, "Wrong alignment on FOrionQuickChatTopic");
static_assert(sizeof(FOrionQuickChatTopic) == 0x000098, "Wrong size on FOrionQuickChatTopic");
static_assert(offsetof(FOrionQuickChatTopic, TopicTitle) == 0x000000, "Member 'FOrionQuickChatTopic::TopicTitle' has a wrong offset!");
static_assert(offsetof(FOrionQuickChatTopic, MessageFormats) == 0x000018, "Member 'FOrionQuickChatTopic::MessageFormats' has a wrong offset!");

// ScriptStruct OrionGame.OrionLootCrateRewardDisplay
// 0x0018 (0x0018 - 0x0000)
struct FOrionLootCrateRewardDisplay final
{
public:
	class FString                                 ReplacementString;                                 // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionMcpItemDefinition*                ReplacementReward;                                 // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionLootCrateRewardDisplay) == 0x000008, "Wrong alignment on FOrionLootCrateRewardDisplay");
static_assert(sizeof(FOrionLootCrateRewardDisplay) == 0x000018, "Wrong size on FOrionLootCrateRewardDisplay");
static_assert(offsetof(FOrionLootCrateRewardDisplay, ReplacementString) == 0x000000, "Member 'FOrionLootCrateRewardDisplay::ReplacementString' has a wrong offset!");
static_assert(offsetof(FOrionLootCrateRewardDisplay, ReplacementReward) == 0x000010, "Member 'FOrionLootCrateRewardDisplay::ReplacementReward' has a wrong offset!");

// ScriptStruct OrionGame.OrionCoinLootCrateRewards
// 0x0040 (0x0040 - 0x0000)
struct FOrionCoinLootCrateRewards final
{
public:
	class FString                                 RealNameForReward;                                 // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReplacementName;                                   // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionMcpItemDefinition*                ReplacementReward;                                 // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionItemRarity                              CoinAmountRarity;                                  // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             RewardIcon;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinRangeInclusive;                                 // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxRangeInclusive;                                 // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionCoinLootCrateRewards) == 0x000008, "Wrong alignment on FOrionCoinLootCrateRewards");
static_assert(sizeof(FOrionCoinLootCrateRewards) == 0x000040, "Wrong size on FOrionCoinLootCrateRewards");
static_assert(offsetof(FOrionCoinLootCrateRewards, RealNameForReward) == 0x000000, "Member 'FOrionCoinLootCrateRewards::RealNameForReward' has a wrong offset!");
static_assert(offsetof(FOrionCoinLootCrateRewards, ReplacementName) == 0x000010, "Member 'FOrionCoinLootCrateRewards::ReplacementName' has a wrong offset!");
static_assert(offsetof(FOrionCoinLootCrateRewards, ReplacementReward) == 0x000020, "Member 'FOrionCoinLootCrateRewards::ReplacementReward' has a wrong offset!");
static_assert(offsetof(FOrionCoinLootCrateRewards, CoinAmountRarity) == 0x000028, "Member 'FOrionCoinLootCrateRewards::CoinAmountRarity' has a wrong offset!");
static_assert(offsetof(FOrionCoinLootCrateRewards, RewardIcon) == 0x000030, "Member 'FOrionCoinLootCrateRewards::RewardIcon' has a wrong offset!");
static_assert(offsetof(FOrionCoinLootCrateRewards, MinRangeInclusive) == 0x000038, "Member 'FOrionCoinLootCrateRewards::MinRangeInclusive' has a wrong offset!");
static_assert(offsetof(FOrionCoinLootCrateRewards, MaxRangeInclusive) == 0x00003C, "Member 'FOrionCoinLootCrateRewards::MaxRangeInclusive' has a wrong offset!");

// ScriptStruct OrionGame.OrionRewardSourceInfo
// 0x0058 (0x0058 - 0x0000)
struct FOrionRewardSourceInfo final
{
public:
	class FName                                   SourceType;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Title;                                             // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   RewardContext;                                     // 0x0038(0x0018)(Edit, NativeAccessSpecifierPublic)
	bool                                          bHidden;                                           // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionRewardSourceInfo) == 0x000008, "Wrong alignment on FOrionRewardSourceInfo");
static_assert(sizeof(FOrionRewardSourceInfo) == 0x000058, "Wrong size on FOrionRewardSourceInfo");
static_assert(offsetof(FOrionRewardSourceInfo, SourceType) == 0x000000, "Member 'FOrionRewardSourceInfo::SourceType' has a wrong offset!");
static_assert(offsetof(FOrionRewardSourceInfo, Title) == 0x000008, "Member 'FOrionRewardSourceInfo::Title' has a wrong offset!");
static_assert(offsetof(FOrionRewardSourceInfo, Description) == 0x000020, "Member 'FOrionRewardSourceInfo::Description' has a wrong offset!");
static_assert(offsetof(FOrionRewardSourceInfo, RewardContext) == 0x000038, "Member 'FOrionRewardSourceInfo::RewardContext' has a wrong offset!");
static_assert(offsetof(FOrionRewardSourceInfo, bHidden) == 0x000050, "Member 'FOrionRewardSourceInfo::bHidden' has a wrong offset!");

// ScriptStruct OrionGame.OrionProgressiveRewardPeriodRowData
// 0x00E8 (0x00F0 - 0x0008)
struct FOrionProgressiveRewardPeriodRowData final : public FTableRowBase
{
public:
	struct FDateTime                              PeriodStartTime;                                   // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              PeriodEndTime;                                     // 0x0010(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PeriodNumber;                                      // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UOrionMcpItemDefinition> RewardTemplate0;                                   // 0x0030(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardQuantity0;                                   // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProgressRequired0;                                 // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UOrionMcpItemDefinition> RewardTemplate1;                                   // 0x0060(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardQuantity1;                                   // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProgressRequired1;                                 // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UOrionMcpItemDefinition> RewardTemplate2;                                   // 0x0090(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardQuantity2;                                   // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProgressRequired2;                                 // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UOrionMcpItemDefinition> RewardTemplate3;                                   // 0x00C0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardQuantity3;                                   // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProgressRequired3;                                 // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionProgressiveRewardPeriodRowData) == 0x000008, "Wrong alignment on FOrionProgressiveRewardPeriodRowData");
static_assert(sizeof(FOrionProgressiveRewardPeriodRowData) == 0x0000F0, "Wrong size on FOrionProgressiveRewardPeriodRowData");
static_assert(offsetof(FOrionProgressiveRewardPeriodRowData, PeriodStartTime) == 0x000008, "Member 'FOrionProgressiveRewardPeriodRowData::PeriodStartTime' has a wrong offset!");
static_assert(offsetof(FOrionProgressiveRewardPeriodRowData, PeriodEndTime) == 0x000010, "Member 'FOrionProgressiveRewardPeriodRowData::PeriodEndTime' has a wrong offset!");
static_assert(offsetof(FOrionProgressiveRewardPeriodRowData, Name) == 0x000018, "Member 'FOrionProgressiveRewardPeriodRowData::Name' has a wrong offset!");
static_assert(offsetof(FOrionProgressiveRewardPeriodRowData, PeriodNumber) == 0x000028, "Member 'FOrionProgressiveRewardPeriodRowData::PeriodNumber' has a wrong offset!");
static_assert(offsetof(FOrionProgressiveRewardPeriodRowData, RewardTemplate0) == 0x000030, "Member 'FOrionProgressiveRewardPeriodRowData::RewardTemplate0' has a wrong offset!");
static_assert(offsetof(FOrionProgressiveRewardPeriodRowData, RewardQuantity0) == 0x000058, "Member 'FOrionProgressiveRewardPeriodRowData::RewardQuantity0' has a wrong offset!");
static_assert(offsetof(FOrionProgressiveRewardPeriodRowData, ProgressRequired0) == 0x00005C, "Member 'FOrionProgressiveRewardPeriodRowData::ProgressRequired0' has a wrong offset!");
static_assert(offsetof(FOrionProgressiveRewardPeriodRowData, RewardTemplate1) == 0x000060, "Member 'FOrionProgressiveRewardPeriodRowData::RewardTemplate1' has a wrong offset!");
static_assert(offsetof(FOrionProgressiveRewardPeriodRowData, RewardQuantity1) == 0x000088, "Member 'FOrionProgressiveRewardPeriodRowData::RewardQuantity1' has a wrong offset!");
static_assert(offsetof(FOrionProgressiveRewardPeriodRowData, ProgressRequired1) == 0x00008C, "Member 'FOrionProgressiveRewardPeriodRowData::ProgressRequired1' has a wrong offset!");
static_assert(offsetof(FOrionProgressiveRewardPeriodRowData, RewardTemplate2) == 0x000090, "Member 'FOrionProgressiveRewardPeriodRowData::RewardTemplate2' has a wrong offset!");
static_assert(offsetof(FOrionProgressiveRewardPeriodRowData, RewardQuantity2) == 0x0000B8, "Member 'FOrionProgressiveRewardPeriodRowData::RewardQuantity2' has a wrong offset!");
static_assert(offsetof(FOrionProgressiveRewardPeriodRowData, ProgressRequired2) == 0x0000BC, "Member 'FOrionProgressiveRewardPeriodRowData::ProgressRequired2' has a wrong offset!");
static_assert(offsetof(FOrionProgressiveRewardPeriodRowData, RewardTemplate3) == 0x0000C0, "Member 'FOrionProgressiveRewardPeriodRowData::RewardTemplate3' has a wrong offset!");
static_assert(offsetof(FOrionProgressiveRewardPeriodRowData, RewardQuantity3) == 0x0000E8, "Member 'FOrionProgressiveRewardPeriodRowData::RewardQuantity3' has a wrong offset!");
static_assert(offsetof(FOrionProgressiveRewardPeriodRowData, ProgressRequired3) == 0x0000EC, "Member 'FOrionProgressiveRewardPeriodRowData::ProgressRequired3' has a wrong offset!");

// ScriptStruct OrionGame.OrionMilestoneRewardPeriod
// 0x00D0 (0x00D8 - 0x0008)
struct FOrionMilestoneRewardPeriod final : public FTableRowBase
{
public:
	struct FDateTime                              PeriodStartTime;                                   // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              PeriodEndTime;                                     // 0x0010(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              KeyPurchaseBeginTime;                              // 0x0018(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WeekNumber;                                        // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UOrionMcpItemDefinition> RewardTemplate0;                                   // 0x0038(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardQuantity0;                                   // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StarCount0;                                        // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UOrionMcpItemDefinition> RewardTemplate1;                                   // 0x0068(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardQuantity1;                                   // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StarCount1;                                        // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UOrionMcpItemDefinition> RewardTemplate2;                                   // 0x0098(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardQuantity2;                                   // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StarCount2;                                        // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Vault;                                             // 0x00C8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionMilestoneRewardPeriod) == 0x000008, "Wrong alignment on FOrionMilestoneRewardPeriod");
static_assert(sizeof(FOrionMilestoneRewardPeriod) == 0x0000D8, "Wrong size on FOrionMilestoneRewardPeriod");
static_assert(offsetof(FOrionMilestoneRewardPeriod, PeriodStartTime) == 0x000008, "Member 'FOrionMilestoneRewardPeriod::PeriodStartTime' has a wrong offset!");
static_assert(offsetof(FOrionMilestoneRewardPeriod, PeriodEndTime) == 0x000010, "Member 'FOrionMilestoneRewardPeriod::PeriodEndTime' has a wrong offset!");
static_assert(offsetof(FOrionMilestoneRewardPeriod, KeyPurchaseBeginTime) == 0x000018, "Member 'FOrionMilestoneRewardPeriod::KeyPurchaseBeginTime' has a wrong offset!");
static_assert(offsetof(FOrionMilestoneRewardPeriod, Name) == 0x000020, "Member 'FOrionMilestoneRewardPeriod::Name' has a wrong offset!");
static_assert(offsetof(FOrionMilestoneRewardPeriod, WeekNumber) == 0x000030, "Member 'FOrionMilestoneRewardPeriod::WeekNumber' has a wrong offset!");
static_assert(offsetof(FOrionMilestoneRewardPeriod, RewardTemplate0) == 0x000038, "Member 'FOrionMilestoneRewardPeriod::RewardTemplate0' has a wrong offset!");
static_assert(offsetof(FOrionMilestoneRewardPeriod, RewardQuantity0) == 0x000060, "Member 'FOrionMilestoneRewardPeriod::RewardQuantity0' has a wrong offset!");
static_assert(offsetof(FOrionMilestoneRewardPeriod, StarCount0) == 0x000064, "Member 'FOrionMilestoneRewardPeriod::StarCount0' has a wrong offset!");
static_assert(offsetof(FOrionMilestoneRewardPeriod, RewardTemplate1) == 0x000068, "Member 'FOrionMilestoneRewardPeriod::RewardTemplate1' has a wrong offset!");
static_assert(offsetof(FOrionMilestoneRewardPeriod, RewardQuantity1) == 0x000090, "Member 'FOrionMilestoneRewardPeriod::RewardQuantity1' has a wrong offset!");
static_assert(offsetof(FOrionMilestoneRewardPeriod, StarCount1) == 0x000094, "Member 'FOrionMilestoneRewardPeriod::StarCount1' has a wrong offset!");
static_assert(offsetof(FOrionMilestoneRewardPeriod, RewardTemplate2) == 0x000098, "Member 'FOrionMilestoneRewardPeriod::RewardTemplate2' has a wrong offset!");
static_assert(offsetof(FOrionMilestoneRewardPeriod, RewardQuantity2) == 0x0000C0, "Member 'FOrionMilestoneRewardPeriod::RewardQuantity2' has a wrong offset!");
static_assert(offsetof(FOrionMilestoneRewardPeriod, StarCount2) == 0x0000C4, "Member 'FOrionMilestoneRewardPeriod::StarCount2' has a wrong offset!");
static_assert(offsetof(FOrionMilestoneRewardPeriod, Vault) == 0x0000C8, "Member 'FOrionMilestoneRewardPeriod::Vault' has a wrong offset!");

// ScriptStruct OrionGame.OrionReachRewardSchedule
// 0x0038 (0x0040 - 0x0008)
struct FOrionReachRewardSchedule final : public FTableRowBase
{
public:
	class FString                                 Name;                                              // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bValid;                                            // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HourCount;                                         // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StarCount0;                                        // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StarCount1;                                        // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StarCount2;                                        // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollOverFactor;                                    // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SeedValueLTG;                                      // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionReachRewardSchedule) == 0x000008, "Wrong alignment on FOrionReachRewardSchedule");
static_assert(sizeof(FOrionReachRewardSchedule) == 0x000040, "Wrong size on FOrionReachRewardSchedule");
static_assert(offsetof(FOrionReachRewardSchedule, Name) == 0x000008, "Member 'FOrionReachRewardSchedule::Name' has a wrong offset!");
static_assert(offsetof(FOrionReachRewardSchedule, bValid) == 0x000018, "Member 'FOrionReachRewardSchedule::bValid' has a wrong offset!");
static_assert(offsetof(FOrionReachRewardSchedule, HourCount) == 0x00001C, "Member 'FOrionReachRewardSchedule::HourCount' has a wrong offset!");
static_assert(offsetof(FOrionReachRewardSchedule, StarCount0) == 0x000020, "Member 'FOrionReachRewardSchedule::StarCount0' has a wrong offset!");
static_assert(offsetof(FOrionReachRewardSchedule, StarCount1) == 0x000024, "Member 'FOrionReachRewardSchedule::StarCount1' has a wrong offset!");
static_assert(offsetof(FOrionReachRewardSchedule, StarCount2) == 0x000028, "Member 'FOrionReachRewardSchedule::StarCount2' has a wrong offset!");
static_assert(offsetof(FOrionReachRewardSchedule, RollOverFactor) == 0x00002C, "Member 'FOrionReachRewardSchedule::RollOverFactor' has a wrong offset!");
static_assert(offsetof(FOrionReachRewardSchedule, SeedValueLTG) == 0x000030, "Member 'FOrionReachRewardSchedule::SeedValueLTG' has a wrong offset!");

// ScriptStruct OrionGame.OrionLevelUpRewardInfo
// 0x00A8 (0x00A8 - 0x0000)
struct FOrionLevelUpRewardInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionLevelUpData                      LevelUpRowData;                                    // 0x0008(0x00A0)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionLevelUpRewardInfo) == 0x000008, "Wrong alignment on FOrionLevelUpRewardInfo");
static_assert(sizeof(FOrionLevelUpRewardInfo) == 0x0000A8, "Wrong size on FOrionLevelUpRewardInfo");
static_assert(offsetof(FOrionLevelUpRewardInfo, LevelUpRowData) == 0x000008, "Member 'FOrionLevelUpRewardInfo::LevelUpRowData' has a wrong offset!");

// ScriptStruct OrionGame.OrionKeywordIcon
// 0x0020 (0x0020 - 0x0000)
struct FOrionKeywordIcon final
{
public:
	class UTexture2D*                             Icon;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x18];                                       // 0x0008(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionKeywordIcon) == 0x000008, "Wrong alignment on FOrionKeywordIcon");
static_assert(sizeof(FOrionKeywordIcon) == 0x000020, "Wrong size on FOrionKeywordIcon");
static_assert(offsetof(FOrionKeywordIcon, Icon) == 0x000000, "Member 'FOrionKeywordIcon::Icon' has a wrong offset!");

// ScriptStruct OrionGame.OrionGenericInlineIcon
// 0x0030 (0x0030 - 0x0000)
struct FOrionGenericInlineIcon final
{
public:
	class FString                                 MarkupSubtag;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	class UTexture2D*                             InlineIcon;                                        // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionGenericInlineIcon) == 0x000008, "Wrong alignment on FOrionGenericInlineIcon");
static_assert(sizeof(FOrionGenericInlineIcon) == 0x000030, "Wrong size on FOrionGenericInlineIcon");
static_assert(offsetof(FOrionGenericInlineIcon, MarkupSubtag) == 0x000000, "Member 'FOrionGenericInlineIcon::MarkupSubtag' has a wrong offset!");
static_assert(offsetof(FOrionGenericInlineIcon, DisplayName) == 0x000010, "Member 'FOrionGenericInlineIcon::DisplayName' has a wrong offset!");
static_assert(offsetof(FOrionGenericInlineIcon, InlineIcon) == 0x000028, "Member 'FOrionGenericInlineIcon::InlineIcon' has a wrong offset!");

// ScriptStruct OrionGame.OrionScoreboardTeamEntryInfo
// 0x0033 (0x0034 - 0x0001)
struct FOrionScoreboardTeamEntryInfo final : public FUIUpdateHelperStruct
{
public:
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumOfPlayers;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamKills;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamDeaths;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamAssists;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamMinionKills;                                   // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamTowerTakedowns;                                // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamInhibitorTakedowns;                            // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlacedRigs;                                        // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DestroyedRigs;                                     // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    TeamNum;                                           // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLocalPlayersTeam;                               // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TotalTeamXP;                                       // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEmpyStruct;                                     // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionScoreboardTeamEntryInfo) == 0x000004, "Wrong alignment on FOrionScoreboardTeamEntryInfo");
static_assert(sizeof(FOrionScoreboardTeamEntryInfo) == 0x000034, "Wrong size on FOrionScoreboardTeamEntryInfo");
static_assert(offsetof(FOrionScoreboardTeamEntryInfo, NumOfPlayers) == 0x000004, "Member 'FOrionScoreboardTeamEntryInfo::NumOfPlayers' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardTeamEntryInfo, TeamKills) == 0x000008, "Member 'FOrionScoreboardTeamEntryInfo::TeamKills' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardTeamEntryInfo, TeamDeaths) == 0x00000C, "Member 'FOrionScoreboardTeamEntryInfo::TeamDeaths' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardTeamEntryInfo, TeamAssists) == 0x000010, "Member 'FOrionScoreboardTeamEntryInfo::TeamAssists' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardTeamEntryInfo, TeamMinionKills) == 0x000014, "Member 'FOrionScoreboardTeamEntryInfo::TeamMinionKills' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardTeamEntryInfo, TeamTowerTakedowns) == 0x000018, "Member 'FOrionScoreboardTeamEntryInfo::TeamTowerTakedowns' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardTeamEntryInfo, TeamInhibitorTakedowns) == 0x00001C, "Member 'FOrionScoreboardTeamEntryInfo::TeamInhibitorTakedowns' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardTeamEntryInfo, PlacedRigs) == 0x000020, "Member 'FOrionScoreboardTeamEntryInfo::PlacedRigs' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardTeamEntryInfo, DestroyedRigs) == 0x000024, "Member 'FOrionScoreboardTeamEntryInfo::DestroyedRigs' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardTeamEntryInfo, TeamNum) == 0x000028, "Member 'FOrionScoreboardTeamEntryInfo::TeamNum' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardTeamEntryInfo, bIsLocalPlayersTeam) == 0x000029, "Member 'FOrionScoreboardTeamEntryInfo::bIsLocalPlayersTeam' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardTeamEntryInfo, TotalTeamXP) == 0x00002C, "Member 'FOrionScoreboardTeamEntryInfo::TotalTeamXP' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardTeamEntryInfo, bIsEmpyStruct) == 0x000030, "Member 'FOrionScoreboardTeamEntryInfo::bIsEmpyStruct' has a wrong offset!");

// ScriptStruct OrionGame.OrionScoreboardPlayerEntryInfo
// 0x00BF (0x00C0 - 0x0001)
struct FOrionScoreboardPlayerEntryInfo final : public FUIUpdateHelperStruct
{
public:
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionPlayerStateUIID                  PlayerStateUIID;                                   // 0x0008(0x0028)(Edit, BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	class FString                                 PlayerName;                                        // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionPlayerPlatform                          PlayerPlatform;                                    // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionPlayerPlatform                          LocalPlayerPlatform;                               // 0x0041(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 HeroId;                                            // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HeroName;                                          // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    TeamNum;                                           // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    LocalPlayerTeamNum;                                // 0x0069(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x6];                                       // 0x006A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             HeroIcon;                                          // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentLevel;                                      // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCurrentlyDead;                                  // 0x007C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RespawnTime;                                       // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLocalPlayer;                                    // 0x0084(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBot;                                            // 0x0085(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIBotDifficulty                              BotDifficulty;                                     // 0x0086(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisconnected;                                     // 0x0087(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMuted;                                            // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCurrentlyTalking;                                 // 0x0089(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVisibleToLocalPlayer;                             // 0x008A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8B[0x1];                                       // 0x008B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Kills;                                             // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Deaths;                                            // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Assists;                                           // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinionKills;                                       // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TowerTakedowns;                                    // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InhibitorTakedowns;                                // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlacedRigs;                                        // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DestroyedRigs;                                     // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeamXPGained;                                      // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CardPointsSpent;                                   // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CardPointsMax;                                     // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEmptyEntry;                                     // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionScoreboardPlayerEntryInfo) == 0x000008, "Wrong alignment on FOrionScoreboardPlayerEntryInfo");
static_assert(sizeof(FOrionScoreboardPlayerEntryInfo) == 0x0000C0, "Wrong size on FOrionScoreboardPlayerEntryInfo");
static_assert(offsetof(FOrionScoreboardPlayerEntryInfo, PlayerStateUIID) == 0x000008, "Member 'FOrionScoreboardPlayerEntryInfo::PlayerStateUIID' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardPlayerEntryInfo, PlayerName) == 0x000030, "Member 'FOrionScoreboardPlayerEntryInfo::PlayerName' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardPlayerEntryInfo, PlayerPlatform) == 0x000040, "Member 'FOrionScoreboardPlayerEntryInfo::PlayerPlatform' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardPlayerEntryInfo, LocalPlayerPlatform) == 0x000041, "Member 'FOrionScoreboardPlayerEntryInfo::LocalPlayerPlatform' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardPlayerEntryInfo, HeroId) == 0x000048, "Member 'FOrionScoreboardPlayerEntryInfo::HeroId' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardPlayerEntryInfo, HeroName) == 0x000058, "Member 'FOrionScoreboardPlayerEntryInfo::HeroName' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardPlayerEntryInfo, TeamNum) == 0x000068, "Member 'FOrionScoreboardPlayerEntryInfo::TeamNum' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardPlayerEntryInfo, LocalPlayerTeamNum) == 0x000069, "Member 'FOrionScoreboardPlayerEntryInfo::LocalPlayerTeamNum' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardPlayerEntryInfo, HeroIcon) == 0x000070, "Member 'FOrionScoreboardPlayerEntryInfo::HeroIcon' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardPlayerEntryInfo, CurrentLevel) == 0x000078, "Member 'FOrionScoreboardPlayerEntryInfo::CurrentLevel' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardPlayerEntryInfo, bIsCurrentlyDead) == 0x00007C, "Member 'FOrionScoreboardPlayerEntryInfo::bIsCurrentlyDead' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardPlayerEntryInfo, RespawnTime) == 0x000080, "Member 'FOrionScoreboardPlayerEntryInfo::RespawnTime' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardPlayerEntryInfo, bIsLocalPlayer) == 0x000084, "Member 'FOrionScoreboardPlayerEntryInfo::bIsLocalPlayer' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardPlayerEntryInfo, bIsBot) == 0x000085, "Member 'FOrionScoreboardPlayerEntryInfo::bIsBot' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardPlayerEntryInfo, BotDifficulty) == 0x000086, "Member 'FOrionScoreboardPlayerEntryInfo::BotDifficulty' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardPlayerEntryInfo, bDisconnected) == 0x000087, "Member 'FOrionScoreboardPlayerEntryInfo::bDisconnected' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardPlayerEntryInfo, bMuted) == 0x000088, "Member 'FOrionScoreboardPlayerEntryInfo::bMuted' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardPlayerEntryInfo, bCurrentlyTalking) == 0x000089, "Member 'FOrionScoreboardPlayerEntryInfo::bCurrentlyTalking' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardPlayerEntryInfo, bVisibleToLocalPlayer) == 0x00008A, "Member 'FOrionScoreboardPlayerEntryInfo::bVisibleToLocalPlayer' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardPlayerEntryInfo, Kills) == 0x00008C, "Member 'FOrionScoreboardPlayerEntryInfo::Kills' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardPlayerEntryInfo, Deaths) == 0x000090, "Member 'FOrionScoreboardPlayerEntryInfo::Deaths' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardPlayerEntryInfo, Assists) == 0x000094, "Member 'FOrionScoreboardPlayerEntryInfo::Assists' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardPlayerEntryInfo, MinionKills) == 0x000098, "Member 'FOrionScoreboardPlayerEntryInfo::MinionKills' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardPlayerEntryInfo, TowerTakedowns) == 0x00009C, "Member 'FOrionScoreboardPlayerEntryInfo::TowerTakedowns' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardPlayerEntryInfo, InhibitorTakedowns) == 0x0000A0, "Member 'FOrionScoreboardPlayerEntryInfo::InhibitorTakedowns' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardPlayerEntryInfo, PlacedRigs) == 0x0000A4, "Member 'FOrionScoreboardPlayerEntryInfo::PlacedRigs' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardPlayerEntryInfo, DestroyedRigs) == 0x0000A8, "Member 'FOrionScoreboardPlayerEntryInfo::DestroyedRigs' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardPlayerEntryInfo, TeamXPGained) == 0x0000AC, "Member 'FOrionScoreboardPlayerEntryInfo::TeamXPGained' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardPlayerEntryInfo, CardPointsSpent) == 0x0000B0, "Member 'FOrionScoreboardPlayerEntryInfo::CardPointsSpent' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardPlayerEntryInfo, CardPointsMax) == 0x0000B4, "Member 'FOrionScoreboardPlayerEntryInfo::CardPointsMax' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardPlayerEntryInfo, bIsEmptyEntry) == 0x0000B8, "Member 'FOrionScoreboardPlayerEntryInfo::bIsEmptyEntry' has a wrong offset!");

// ScriptStruct OrionGame.OrionScoreboardUIInfo
// 0x0088 (0x0088 - 0x0000)
struct FOrionScoreboardUIInfo final
{
public:
	struct FOrionScoreboardTeamEntryInfo          YourTeam;                                          // 0x0000(0x0034)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOrionScoreboardTeamEntryInfo          EnemyTeam;                                         // 0x0034(0x0034)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FOrionScoreboardPlayerEntryInfo> Teammates;                                         // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOrionScoreboardPlayerEntryInfo> Enemies;                                           // 0x0078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionScoreboardUIInfo) == 0x000008, "Wrong alignment on FOrionScoreboardUIInfo");
static_assert(sizeof(FOrionScoreboardUIInfo) == 0x000088, "Wrong size on FOrionScoreboardUIInfo");
static_assert(offsetof(FOrionScoreboardUIInfo, YourTeam) == 0x000000, "Member 'FOrionScoreboardUIInfo::YourTeam' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardUIInfo, EnemyTeam) == 0x000034, "Member 'FOrionScoreboardUIInfo::EnemyTeam' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardUIInfo, Teammates) == 0x000068, "Member 'FOrionScoreboardUIInfo::Teammates' has a wrong offset!");
static_assert(offsetof(FOrionScoreboardUIInfo, Enemies) == 0x000078, "Member 'FOrionScoreboardUIInfo::Enemies' has a wrong offset!");

// ScriptStruct OrionGame.OrionShapeFacetSector
// 0x0028 (0x0038 - 0x0010)
struct FOrionShapeFacetSector final : public FOrionShapeFacet
{
public:
	uint8                                         Pad_10[0x28];                                      // 0x0010(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionShapeFacetSector) == 0x000008, "Wrong alignment on FOrionShapeFacetSector");
static_assert(sizeof(FOrionShapeFacetSector) == 0x000038, "Wrong size on FOrionShapeFacetSector");

// ScriptStruct OrionGame.OrionStyleEntry
// 0x0030 (0x0030 - 0x0000)
struct FOrionStyleEntry final
{
public:
	class FName                                   AssetName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USlateBrushAsset>        Asset;                                             // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionStyleEntry) == 0x000008, "Wrong alignment on FOrionStyleEntry");
static_assert(sizeof(FOrionStyleEntry) == 0x000030, "Wrong size on FOrionStyleEntry");
static_assert(offsetof(FOrionStyleEntry, AssetName) == 0x000000, "Member 'FOrionStyleEntry::AssetName' has a wrong offset!");
static_assert(offsetof(FOrionStyleEntry, Asset) == 0x000008, "Member 'FOrionStyleEntry::Asset' has a wrong offset!");

// ScriptStruct OrionGame.ManagedGameplayTagDataTableItem
// 0x0010 (0x0010 - 0x0000)
struct FManagedGameplayTagDataTableItem final
{
public:
	struct FGameplayTag                           RootTag;                                           // 0x0000(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             DataTable;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FManagedGameplayTagDataTableItem) == 0x000008, "Wrong alignment on FManagedGameplayTagDataTableItem");
static_assert(sizeof(FManagedGameplayTagDataTableItem) == 0x000010, "Wrong size on FManagedGameplayTagDataTableItem");
static_assert(offsetof(FManagedGameplayTagDataTableItem, RootTag) == 0x000000, "Member 'FManagedGameplayTagDataTableItem::RootTag' has a wrong offset!");
static_assert(offsetof(FManagedGameplayTagDataTableItem, DataTable) == 0x000008, "Member 'FManagedGameplayTagDataTableItem::DataTable' has a wrong offset!");

// ScriptStruct OrionGame.OrionTagTableManagerHelper
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FOrionTagTableManagerHelper final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionTagTableManagerHelper) == 0x000008, "Wrong alignment on FOrionTagTableManagerHelper");
static_assert(sizeof(FOrionTagTableManagerHelper) == 0x000050, "Wrong size on FOrionTagTableManagerHelper");

// ScriptStruct OrionGame.OrionTargetData
// 0x0088 (0x0090 - 0x0008)
struct alignas(0x10) FOrionTargetData final : public FGameplayAbilityTargetData
{
public:
	bool                                          bCheckTargetActorSwaps;                            // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x87];                                       // 0x0009(0x0087)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionTargetData) == 0x000010, "Wrong alignment on FOrionTargetData");
static_assert(sizeof(FOrionTargetData) == 0x000090, "Wrong size on FOrionTargetData");
static_assert(offsetof(FOrionTargetData, bCheckTargetActorSwaps) == 0x000008, "Member 'FOrionTargetData::bCheckTargetActorSwaps' has a wrong offset!");

// ScriptStruct OrionGame.OrionTeamCompDebugData
// 0x0018 (0x0018 - 0x0000)
struct FOrionTeamCompDebugData final
{
public:
	float                                         TeamCompScore;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOrionTeamCompDebugSlot>        Members;                                           // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionTeamCompDebugData) == 0x000008, "Wrong alignment on FOrionTeamCompDebugData");
static_assert(sizeof(FOrionTeamCompDebugData) == 0x000018, "Wrong size on FOrionTeamCompDebugData");
static_assert(offsetof(FOrionTeamCompDebugData, TeamCompScore) == 0x000000, "Member 'FOrionTeamCompDebugData::TeamCompScore' has a wrong offset!");
static_assert(offsetof(FOrionTeamCompDebugData, Members) == 0x000008, "Member 'FOrionTeamCompDebugData::Members' has a wrong offset!");

// ScriptStruct OrionGame.SkillRatingTimeRestriction
// 0x0008 (0x0008 - 0x0000)
struct FSkillRatingTimeRestriction final
{
public:
	float                                         Duration;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxRatingDelta;                                    // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillRatingTimeRestriction) == 0x000004, "Wrong alignment on FSkillRatingTimeRestriction");
static_assert(sizeof(FSkillRatingTimeRestriction) == 0x000008, "Wrong size on FSkillRatingTimeRestriction");
static_assert(offsetof(FSkillRatingTimeRestriction, Duration) == 0x000000, "Member 'FSkillRatingTimeRestriction::Duration' has a wrong offset!");
static_assert(offsetof(FSkillRatingTimeRestriction, MaxRatingDelta) == 0x000004, "Member 'FSkillRatingTimeRestriction::MaxRatingDelta' has a wrong offset!");

// ScriptStruct OrionGame.TBSearchPassState
// 0x000C (0x000C - 0x0000)
struct FTBSearchPassState final
{
public:
	bool                                          bWasCanceled;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasFailure;                                       // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasRejected;                                      // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTimerExpired;                                     // 0x0003(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETBSearchState                                SearchState;                                       // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ApprovalTimeRemaining;                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTBSearchPassState) == 0x000004, "Wrong alignment on FTBSearchPassState");
static_assert(sizeof(FTBSearchPassState) == 0x00000C, "Wrong size on FTBSearchPassState");
static_assert(offsetof(FTBSearchPassState, bWasCanceled) == 0x000000, "Member 'FTBSearchPassState::bWasCanceled' has a wrong offset!");
static_assert(offsetof(FTBSearchPassState, bWasFailure) == 0x000001, "Member 'FTBSearchPassState::bWasFailure' has a wrong offset!");
static_assert(offsetof(FTBSearchPassState, bWasRejected) == 0x000002, "Member 'FTBSearchPassState::bWasRejected' has a wrong offset!");
static_assert(offsetof(FTBSearchPassState, bTimerExpired) == 0x000003, "Member 'FTBSearchPassState::bTimerExpired' has a wrong offset!");
static_assert(offsetof(FTBSearchPassState, SearchState) == 0x000004, "Member 'FTBSearchPassState::SearchState' has a wrong offset!");
static_assert(offsetof(FTBSearchPassState, ApprovalTimeRemaining) == 0x000008, "Member 'FTBSearchPassState::ApprovalTimeRemaining' has a wrong offset!");

// ScriptStruct OrionGame.TBSearchParams
// 0x0048 (0x0048 - 0x0000)
struct FTBSearchParams final
{
public:
	int32                                         ControllerId;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SessionName;                                       // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlaylistId;                                        // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MMR;                                               // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CustomKey;                                         // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETBSearchFlags                                Flags;                                             // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x1F];                                      // 0x0029(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTBSearchParams) == 0x000008, "Wrong alignment on FTBSearchParams");
static_assert(sizeof(FTBSearchParams) == 0x000048, "Wrong size on FTBSearchParams");
static_assert(offsetof(FTBSearchParams, ControllerId) == 0x000000, "Member 'FTBSearchParams::ControllerId' has a wrong offset!");
static_assert(offsetof(FTBSearchParams, SessionName) == 0x000008, "Member 'FTBSearchParams::SessionName' has a wrong offset!");
static_assert(offsetof(FTBSearchParams, PlaylistId) == 0x000010, "Member 'FTBSearchParams::PlaylistId' has a wrong offset!");
static_assert(offsetof(FTBSearchParams, MMR) == 0x000014, "Member 'FTBSearchParams::MMR' has a wrong offset!");
static_assert(offsetof(FTBSearchParams, CustomKey) == 0x000018, "Member 'FTBSearchParams::CustomKey' has a wrong offset!");
static_assert(offsetof(FTBSearchParams, Flags) == 0x000028, "Member 'FTBSearchParams::Flags' has a wrong offset!");

// ScriptStruct OrionGame.OrionTBSocialPartyMemberSummary
// 0x0038 (0x0038 - 0x0000)
struct FOrionTBSocialPartyMemberSummary final
{
public:
	bool                                          IsPartyLeader;                                     // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlayerId;                                          // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayName;                                       // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HeroName;                                          // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionTBSocialPartyMemberSummary) == 0x000008, "Wrong alignment on FOrionTBSocialPartyMemberSummary");
static_assert(sizeof(FOrionTBSocialPartyMemberSummary) == 0x000038, "Wrong size on FOrionTBSocialPartyMemberSummary");
static_assert(offsetof(FOrionTBSocialPartyMemberSummary, IsPartyLeader) == 0x000000, "Member 'FOrionTBSocialPartyMemberSummary::IsPartyLeader' has a wrong offset!");
static_assert(offsetof(FOrionTBSocialPartyMemberSummary, PlayerId) == 0x000008, "Member 'FOrionTBSocialPartyMemberSummary::PlayerId' has a wrong offset!");
static_assert(offsetof(FOrionTBSocialPartyMemberSummary, DisplayName) == 0x000018, "Member 'FOrionTBSocialPartyMemberSummary::DisplayName' has a wrong offset!");
static_assert(offsetof(FOrionTBSocialPartyMemberSummary, HeroName) == 0x000028, "Member 'FOrionTBSocialPartyMemberSummary::HeroName' has a wrong offset!");

// ScriptStruct OrionGame.OrionTBParams
// 0x0160 (0x0160 - 0x0000)
struct FOrionTBParams final
{
public:
	struct FUniqueNetIdRepl                       UserID;                                            // 0x0000(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ControllerId;                                      // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlaylistId;                                        // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CustomKey;                                         // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIBotDifficulty                              FriendlyBotDifficulty;                             // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIBotDifficulty                              EnemyBotDifficulty;                                // 0x0031(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FriendlyBotHeroList;                               // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EnemyBotHeroList;                                  // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionTBPlayerChoices                  PlayerChoices;                                     // 0x0058(0x0108)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionTBParams) == 0x000008, "Wrong alignment on FOrionTBParams");
static_assert(sizeof(FOrionTBParams) == 0x000160, "Wrong size on FOrionTBParams");
static_assert(offsetof(FOrionTBParams, UserID) == 0x000000, "Member 'FOrionTBParams::UserID' has a wrong offset!");
static_assert(offsetof(FOrionTBParams, ControllerId) == 0x000018, "Member 'FOrionTBParams::ControllerId' has a wrong offset!");
static_assert(offsetof(FOrionTBParams, PlaylistId) == 0x00001C, "Member 'FOrionTBParams::PlaylistId' has a wrong offset!");
static_assert(offsetof(FOrionTBParams, CustomKey) == 0x000020, "Member 'FOrionTBParams::CustomKey' has a wrong offset!");
static_assert(offsetof(FOrionTBParams, FriendlyBotDifficulty) == 0x000030, "Member 'FOrionTBParams::FriendlyBotDifficulty' has a wrong offset!");
static_assert(offsetof(FOrionTBParams, EnemyBotDifficulty) == 0x000031, "Member 'FOrionTBParams::EnemyBotDifficulty' has a wrong offset!");
static_assert(offsetof(FOrionTBParams, FriendlyBotHeroList) == 0x000038, "Member 'FOrionTBParams::FriendlyBotHeroList' has a wrong offset!");
static_assert(offsetof(FOrionTBParams, EnemyBotHeroList) == 0x000048, "Member 'FOrionTBParams::EnemyBotHeroList' has a wrong offset!");
static_assert(offsetof(FOrionTBParams, PlayerChoices) == 0x000058, "Member 'FOrionTBParams::PlayerChoices' has a wrong offset!");

// ScriptStruct OrionGame.OrionTBSoloRiderSummary
// 0x0130 (0x0130 - 0x0000)
struct FOrionTBSoloRiderSummary final
{
public:
	class FString                                 SoloRiderSessionId;                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerId;                                          // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              FoundTimeStampUtc;                                 // 0x0020(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionTBPlayerChoices                  PlayerChoices;                                     // 0x0028(0x0108)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionTBSoloRiderSummary) == 0x000008, "Wrong alignment on FOrionTBSoloRiderSummary");
static_assert(sizeof(FOrionTBSoloRiderSummary) == 0x000130, "Wrong size on FOrionTBSoloRiderSummary");
static_assert(offsetof(FOrionTBSoloRiderSummary, SoloRiderSessionId) == 0x000000, "Member 'FOrionTBSoloRiderSummary::SoloRiderSessionId' has a wrong offset!");
static_assert(offsetof(FOrionTBSoloRiderSummary, PlayerId) == 0x000010, "Member 'FOrionTBSoloRiderSummary::PlayerId' has a wrong offset!");
static_assert(offsetof(FOrionTBSoloRiderSummary, FoundTimeStampUtc) == 0x000020, "Member 'FOrionTBSoloRiderSummary::FoundTimeStampUtc' has a wrong offset!");
static_assert(offsetof(FOrionTBSoloRiderSummary, PlayerChoices) == 0x000028, "Member 'FOrionTBSoloRiderSummary::PlayerChoices' has a wrong offset!");

// ScriptStruct OrionGame.OrionTBTeamInviteSummary
// 0x0040 (0x0040 - 0x0000)
struct FOrionTBTeamInviteSummary final
{
public:
	class FString                                 TeamBuilderPartyId;                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CaptainId;                                         // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TeamSessionId;                                     // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              InviteTimeStampUtc;                                // 0x0038(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionTBTeamInviteSummary) == 0x000008, "Wrong alignment on FOrionTBTeamInviteSummary");
static_assert(sizeof(FOrionTBTeamInviteSummary) == 0x000040, "Wrong size on FOrionTBTeamInviteSummary");
static_assert(offsetof(FOrionTBTeamInviteSummary, TeamBuilderPartyId) == 0x000000, "Member 'FOrionTBTeamInviteSummary::TeamBuilderPartyId' has a wrong offset!");
static_assert(offsetof(FOrionTBTeamInviteSummary, CaptainId) == 0x000010, "Member 'FOrionTBTeamInviteSummary::CaptainId' has a wrong offset!");
static_assert(offsetof(FOrionTBTeamInviteSummary, TeamSessionId) == 0x000020, "Member 'FOrionTBTeamInviteSummary::TeamSessionId' has a wrong offset!");
static_assert(offsetof(FOrionTBTeamInviteSummary, SlotIndex) == 0x000030, "Member 'FOrionTBTeamInviteSummary::SlotIndex' has a wrong offset!");
static_assert(offsetof(FOrionTBTeamInviteSummary, InviteTimeStampUtc) == 0x000038, "Member 'FOrionTBTeamInviteSummary::InviteTimeStampUtc' has a wrong offset!");

// ScriptStruct OrionGame.OrionRoleSummary
// 0x0028 (0x0028 - 0x0000)
struct FOrionRoleSummary final
{
public:
	class FString                                 Role;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HeroName;                                          // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeroRoleWeight;                                    // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionRoleSummary) == 0x000008, "Wrong alignment on FOrionRoleSummary");
static_assert(sizeof(FOrionRoleSummary) == 0x000028, "Wrong size on FOrionRoleSummary");
static_assert(offsetof(FOrionRoleSummary, Role) == 0x000000, "Member 'FOrionRoleSummary::Role' has a wrong offset!");
static_assert(offsetof(FOrionRoleSummary, HeroName) == 0x000010, "Member 'FOrionRoleSummary::HeroName' has a wrong offset!");
static_assert(offsetof(FOrionRoleSummary, HeroRoleWeight) == 0x000020, "Member 'FOrionRoleSummary::HeroRoleWeight' has a wrong offset!");

// ScriptStruct OrionGame.OrionTBTeamCompSummary
// 0x0028 (0x0028 - 0x0000)
struct FOrionTBTeamCompSummary final
{
public:
	float                                         TeamCompScore;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         TeamLayout;                                        // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOrionRoleSummary>              TeamComp;                                          // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionTBTeamCompSummary) == 0x000008, "Wrong alignment on FOrionTBTeamCompSummary");
static_assert(sizeof(FOrionTBTeamCompSummary) == 0x000028, "Wrong size on FOrionTBTeamCompSummary");
static_assert(offsetof(FOrionTBTeamCompSummary, TeamCompScore) == 0x000000, "Member 'FOrionTBTeamCompSummary::TeamCompScore' has a wrong offset!");
static_assert(offsetof(FOrionTBTeamCompSummary, TeamLayout) == 0x000008, "Member 'FOrionTBTeamCompSummary::TeamLayout' has a wrong offset!");
static_assert(offsetof(FOrionTBTeamCompSummary, TeamComp) == 0x000018, "Member 'FOrionTBTeamCompSummary::TeamComp' has a wrong offset!");

// ScriptStruct OrionGame.OrionTBRunSummary
// 0x0288 (0x0288 - 0x0000)
struct FOrionTBRunSummary final
{
public:
	bool                                          bStarted;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasCanceled;                                      // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsError;                                          // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCaptain;                                        // 0x0003(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ErrorStr;                                          // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              StartTimeUtc;                                      // 0x0018(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              EndTimeUtc;                                        // 0x0020(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Duration;                                          // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UserID;                                            // 0x0030(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamBuilderRole                              InitialRole;                                       // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamBuilderRole                              FinalRole;                                         // 0x0041(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayerMMR;                                         // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamElo;                                           // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlaylistId;                                        // 0x0050(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionTBParams                         TeamBuilderParams;                                 // 0x0058(0x0160)(NativeAccessSpecifierPublic)
	class FString                                 MatchSessionId;                                    // 0x01B8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SoloSessionId;                                     // 0x01C8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TeamPartyId;                                       // 0x01D8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SocialPartyId;                                     // 0x01E8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SocialPartyMemberCount;                            // 0x01F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FC[0x4];                                      // 0x01FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionTBWaitTimes                      PlayerWaitTimes;                                   // 0x0200(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FOrionTBSocialPartyMemberSummary> SocialPartyMembers;                                // 0x0230(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOrionTBSoloRiderSummary>       SoloRiders;                                        // 0x0240(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOrionTBTeamInviteSummary>      TeamInvites;                                       // 0x0250(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FOrionTBTeamCompSummary                TeamCompSummary;                                   // 0x0260(0x0028)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionTBRunSummary) == 0x000008, "Wrong alignment on FOrionTBRunSummary");
static_assert(sizeof(FOrionTBRunSummary) == 0x000288, "Wrong size on FOrionTBRunSummary");
static_assert(offsetof(FOrionTBRunSummary, bStarted) == 0x000000, "Member 'FOrionTBRunSummary::bStarted' has a wrong offset!");
static_assert(offsetof(FOrionTBRunSummary, bWasCanceled) == 0x000001, "Member 'FOrionTBRunSummary::bWasCanceled' has a wrong offset!");
static_assert(offsetof(FOrionTBRunSummary, bIsError) == 0x000002, "Member 'FOrionTBRunSummary::bIsError' has a wrong offset!");
static_assert(offsetof(FOrionTBRunSummary, bIsCaptain) == 0x000003, "Member 'FOrionTBRunSummary::bIsCaptain' has a wrong offset!");
static_assert(offsetof(FOrionTBRunSummary, ErrorStr) == 0x000008, "Member 'FOrionTBRunSummary::ErrorStr' has a wrong offset!");
static_assert(offsetof(FOrionTBRunSummary, StartTimeUtc) == 0x000018, "Member 'FOrionTBRunSummary::StartTimeUtc' has a wrong offset!");
static_assert(offsetof(FOrionTBRunSummary, EndTimeUtc) == 0x000020, "Member 'FOrionTBRunSummary::EndTimeUtc' has a wrong offset!");
static_assert(offsetof(FOrionTBRunSummary, Duration) == 0x000028, "Member 'FOrionTBRunSummary::Duration' has a wrong offset!");
static_assert(offsetof(FOrionTBRunSummary, UserID) == 0x000030, "Member 'FOrionTBRunSummary::UserID' has a wrong offset!");
static_assert(offsetof(FOrionTBRunSummary, InitialRole) == 0x000040, "Member 'FOrionTBRunSummary::InitialRole' has a wrong offset!");
static_assert(offsetof(FOrionTBRunSummary, FinalRole) == 0x000041, "Member 'FOrionTBRunSummary::FinalRole' has a wrong offset!");
static_assert(offsetof(FOrionTBRunSummary, PlayerMMR) == 0x000044, "Member 'FOrionTBRunSummary::PlayerMMR' has a wrong offset!");
static_assert(offsetof(FOrionTBRunSummary, TeamElo) == 0x000048, "Member 'FOrionTBRunSummary::TeamElo' has a wrong offset!");
static_assert(offsetof(FOrionTBRunSummary, PlaylistId) == 0x000050, "Member 'FOrionTBRunSummary::PlaylistId' has a wrong offset!");
static_assert(offsetof(FOrionTBRunSummary, TeamBuilderParams) == 0x000058, "Member 'FOrionTBRunSummary::TeamBuilderParams' has a wrong offset!");
static_assert(offsetof(FOrionTBRunSummary, MatchSessionId) == 0x0001B8, "Member 'FOrionTBRunSummary::MatchSessionId' has a wrong offset!");
static_assert(offsetof(FOrionTBRunSummary, SoloSessionId) == 0x0001C8, "Member 'FOrionTBRunSummary::SoloSessionId' has a wrong offset!");
static_assert(offsetof(FOrionTBRunSummary, TeamPartyId) == 0x0001D8, "Member 'FOrionTBRunSummary::TeamPartyId' has a wrong offset!");
static_assert(offsetof(FOrionTBRunSummary, SocialPartyId) == 0x0001E8, "Member 'FOrionTBRunSummary::SocialPartyId' has a wrong offset!");
static_assert(offsetof(FOrionTBRunSummary, SocialPartyMemberCount) == 0x0001F8, "Member 'FOrionTBRunSummary::SocialPartyMemberCount' has a wrong offset!");
static_assert(offsetof(FOrionTBRunSummary, PlayerWaitTimes) == 0x000200, "Member 'FOrionTBRunSummary::PlayerWaitTimes' has a wrong offset!");
static_assert(offsetof(FOrionTBRunSummary, SocialPartyMembers) == 0x000230, "Member 'FOrionTBRunSummary::SocialPartyMembers' has a wrong offset!");
static_assert(offsetof(FOrionTBRunSummary, SoloRiders) == 0x000240, "Member 'FOrionTBRunSummary::SoloRiders' has a wrong offset!");
static_assert(offsetof(FOrionTBRunSummary, TeamInvites) == 0x000250, "Member 'FOrionTBRunSummary::TeamInvites' has a wrong offset!");
static_assert(offsetof(FOrionTBRunSummary, TeamCompSummary) == 0x000260, "Member 'FOrionTBRunSummary::TeamCompSummary' has a wrong offset!");

// ScriptStruct OrionGame.VisionManagerRuntimeData
// 0x488E0 (0x488E0 - 0x0000)
struct alignas(0x10) FVisionManagerRuntimeData final
{
public:
	uint8                                         Pad_0[0x488C0];                                    // 0x0000(0x488C0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInstanceDynamic*>       InstantiatedMIDs;                                  // 0x488C0(0x0010)(ZeroConstructor, RepSkip, NativeAccessSpecifierPublic)
	uint8                                         Pad_488D0[0x10];                                   // 0x488D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVisionManagerRuntimeData) == 0x000010, "Wrong alignment on FVisionManagerRuntimeData");
static_assert(sizeof(FVisionManagerRuntimeData) == 0x0488E0, "Wrong size on FVisionManagerRuntimeData");
static_assert(offsetof(FVisionManagerRuntimeData, InstantiatedMIDs) == 0x0488C0, "Member 'FVisionManagerRuntimeData::InstantiatedMIDs' has a wrong offset!");

// ScriptStruct OrionGame.TBFilteredPlayer
// 0x0020 (0x0020 - 0x0000)
struct FTBFilteredPlayer final
{
public:
	struct FUniqueNetIdRepl                       PlayerId;                                          // 0x0000(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamBuilderPlayerFilterReason                Reason;                                            // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TimeRemaining;                                     // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTBFilteredPlayer) == 0x000008, "Wrong alignment on FTBFilteredPlayer");
static_assert(sizeof(FTBFilteredPlayer) == 0x000020, "Wrong size on FTBFilteredPlayer");
static_assert(offsetof(FTBFilteredPlayer, PlayerId) == 0x000000, "Member 'FTBFilteredPlayer::PlayerId' has a wrong offset!");
static_assert(offsetof(FTBFilteredPlayer, Reason) == 0x000018, "Member 'FTBFilteredPlayer::Reason' has a wrong offset!");
static_assert(offsetof(FTBFilteredPlayer, TimeRemaining) == 0x00001C, "Member 'FTBFilteredPlayer::TimeRemaining' has a wrong offset!");

// ScriptStruct OrionGame.OrionTeamBuilderRepState
// 0x0070 (0x0090 - 0x0020)
struct FOrionTeamBuilderRepState final : public FOrionPartyRepState
{
public:
	ETeamBuilderProgression                       PartyProgression;                                  // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ChatRoomId;                                        // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReservedSlots;                                     // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PendingMember0;                                    // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PendingMember1;                                    // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PendingMember2;                                    // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PendingMember3;                                    // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PendingMember4;                                    // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionTeamBuilderRepState) == 0x000008, "Wrong alignment on FOrionTeamBuilderRepState");
static_assert(sizeof(FOrionTeamBuilderRepState) == 0x000090, "Wrong size on FOrionTeamBuilderRepState");
static_assert(offsetof(FOrionTeamBuilderRepState, PartyProgression) == 0x000020, "Member 'FOrionTeamBuilderRepState::PartyProgression' has a wrong offset!");
static_assert(offsetof(FOrionTeamBuilderRepState, ChatRoomId) == 0x000028, "Member 'FOrionTeamBuilderRepState::ChatRoomId' has a wrong offset!");
static_assert(offsetof(FOrionTeamBuilderRepState, ReservedSlots) == 0x000038, "Member 'FOrionTeamBuilderRepState::ReservedSlots' has a wrong offset!");
static_assert(offsetof(FOrionTeamBuilderRepState, PendingMember0) == 0x000040, "Member 'FOrionTeamBuilderRepState::PendingMember0' has a wrong offset!");
static_assert(offsetof(FOrionTeamBuilderRepState, PendingMember1) == 0x000050, "Member 'FOrionTeamBuilderRepState::PendingMember1' has a wrong offset!");
static_assert(offsetof(FOrionTeamBuilderRepState, PendingMember2) == 0x000060, "Member 'FOrionTeamBuilderRepState::PendingMember2' has a wrong offset!");
static_assert(offsetof(FOrionTeamBuilderRepState, PendingMember3) == 0x000070, "Member 'FOrionTeamBuilderRepState::PendingMember3' has a wrong offset!");
static_assert(offsetof(FOrionTeamBuilderRepState, PendingMember4) == 0x000080, "Member 'FOrionTeamBuilderRepState::PendingMember4' has a wrong offset!");

// ScriptStruct OrionGame.OrionTeamBuilderPartyMemberRepState
// 0x0058 (0x0070 - 0x0018)
struct FOrionTeamBuilderPartyMemberRepState final : public FOrionPartyMemberRepState
{
public:
	int32                                         SlotIdx;                                           // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 HeroName;                                          // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DeckId;                                            // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionPosition                                Position;                                          // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionRole                                    Role;                                              // 0x0041(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Ready;                                             // 0x0042(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43[0x5];                                       // 0x0043(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BlockedPlayers;                                    // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionPlayerPlatform                          Platform;                                          // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CosmeticString;                                    // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionTeamBuilderPartyMemberRepState) == 0x000008, "Wrong alignment on FOrionTeamBuilderPartyMemberRepState");
static_assert(sizeof(FOrionTeamBuilderPartyMemberRepState) == 0x000070, "Wrong size on FOrionTeamBuilderPartyMemberRepState");
static_assert(offsetof(FOrionTeamBuilderPartyMemberRepState, SlotIdx) == 0x000018, "Member 'FOrionTeamBuilderPartyMemberRepState::SlotIdx' has a wrong offset!");
static_assert(offsetof(FOrionTeamBuilderPartyMemberRepState, HeroName) == 0x000020, "Member 'FOrionTeamBuilderPartyMemberRepState::HeroName' has a wrong offset!");
static_assert(offsetof(FOrionTeamBuilderPartyMemberRepState, DeckId) == 0x000030, "Member 'FOrionTeamBuilderPartyMemberRepState::DeckId' has a wrong offset!");
static_assert(offsetof(FOrionTeamBuilderPartyMemberRepState, Position) == 0x000040, "Member 'FOrionTeamBuilderPartyMemberRepState::Position' has a wrong offset!");
static_assert(offsetof(FOrionTeamBuilderPartyMemberRepState, Role) == 0x000041, "Member 'FOrionTeamBuilderPartyMemberRepState::Role' has a wrong offset!");
static_assert(offsetof(FOrionTeamBuilderPartyMemberRepState, Ready) == 0x000042, "Member 'FOrionTeamBuilderPartyMemberRepState::Ready' has a wrong offset!");
static_assert(offsetof(FOrionTeamBuilderPartyMemberRepState, BlockedPlayers) == 0x000048, "Member 'FOrionTeamBuilderPartyMemberRepState::BlockedPlayers' has a wrong offset!");
static_assert(offsetof(FOrionTeamBuilderPartyMemberRepState, Platform) == 0x000058, "Member 'FOrionTeamBuilderPartyMemberRepState::Platform' has a wrong offset!");
static_assert(offsetof(FOrionTeamBuilderPartyMemberRepState, CosmeticString) == 0x000060, "Member 'FOrionTeamBuilderPartyMemberRepState::CosmeticString' has a wrong offset!");

// ScriptStruct OrionGame.OrionTBState
// 0x0010 (0x0010 - 0x0000)
struct FOrionTBState final
{
public:
	TArray<struct FOrionTBSlotState>              MemberSlots;                                       // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionTBState) == 0x000008, "Wrong alignment on FOrionTBState");
static_assert(sizeof(FOrionTBState) == 0x000010, "Wrong size on FOrionTBState");
static_assert(offsetof(FOrionTBState, MemberSlots) == 0x000000, "Member 'FOrionTBState::MemberSlots' has a wrong offset!");

// ScriptStruct OrionGame.VisionManagerDebugInfoDump
// 0x0018 (0x0018 - 0x0000)
struct FVisionManagerDebugInfoDump final
{
public:
	TArray<struct FVisionManagerDebugItem>        Items;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVisionManagerDebugInfoDump) == 0x000008, "Wrong alignment on FVisionManagerDebugInfoDump");
static_assert(sizeof(FVisionManagerDebugInfoDump) == 0x000018, "Wrong size on FVisionManagerDebugInfoDump");
static_assert(offsetof(FVisionManagerDebugInfoDump, Items) == 0x000000, "Member 'FVisionManagerDebugInfoDump::Items' has a wrong offset!");

// ScriptStruct OrionGame.SurrenderBallot
// 0x0020 (0x0020 - 0x0000)
struct FSurrenderBallot final
{
public:
	struct FUniqueNetIdRepl                       NetID;                                             // 0x0000(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESurrenderVote                                Vote;                                              // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSurrenderBallot) == 0x000008, "Wrong alignment on FSurrenderBallot");
static_assert(sizeof(FSurrenderBallot) == 0x000020, "Wrong size on FSurrenderBallot");
static_assert(offsetof(FSurrenderBallot, NetID) == 0x000000, "Member 'FSurrenderBallot::NetID' has a wrong offset!");
static_assert(offsetof(FSurrenderBallot, Vote) == 0x000018, "Member 'FSurrenderBallot::Vote' has a wrong offset!");

// ScriptStruct OrionGame.CachedToggleableNavLinkData
// 0x0010 (0x0010 - 0x0000)
struct FCachedToggleableNavLinkData final
{
public:
	uint64                                        NodeRef;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavArea>                   AreaClass;                                         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCachedToggleableNavLinkData) == 0x000008, "Wrong alignment on FCachedToggleableNavLinkData");
static_assert(sizeof(FCachedToggleableNavLinkData) == 0x000010, "Wrong size on FCachedToggleableNavLinkData");
static_assert(offsetof(FCachedToggleableNavLinkData, NodeRef) == 0x000000, "Member 'FCachedToggleableNavLinkData::NodeRef' has a wrong offset!");
static_assert(offsetof(FCachedToggleableNavLinkData, AreaClass) == 0x000008, "Member 'FCachedToggleableNavLinkData::AreaClass' has a wrong offset!");

// ScriptStruct OrionGame.EvenlySpacedPoint
// 0x0040 (0x0040 - 0x0000)
struct FEvenlySpacedPoint final
{
public:
	bool                                          bNeedsRecalc;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StartLocation;                                     // 0x0004(0x000C)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DestLocation;                                      // 0x0010(0x000C)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocAlpha;                                          // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Tangent;                                           // 0x0020(0x000C)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrowthAlpha;                                       // 0x002C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrowthAlphaTarget;                                 // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USplineMeshComponent*                   SplineMeshComponent;                               // 0x0038(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEvenlySpacedPoint) == 0x000008, "Wrong alignment on FEvenlySpacedPoint");
static_assert(sizeof(FEvenlySpacedPoint) == 0x000040, "Wrong size on FEvenlySpacedPoint");
static_assert(offsetof(FEvenlySpacedPoint, bNeedsRecalc) == 0x000000, "Member 'FEvenlySpacedPoint::bNeedsRecalc' has a wrong offset!");
static_assert(offsetof(FEvenlySpacedPoint, StartLocation) == 0x000004, "Member 'FEvenlySpacedPoint::StartLocation' has a wrong offset!");
static_assert(offsetof(FEvenlySpacedPoint, DestLocation) == 0x000010, "Member 'FEvenlySpacedPoint::DestLocation' has a wrong offset!");
static_assert(offsetof(FEvenlySpacedPoint, LocAlpha) == 0x00001C, "Member 'FEvenlySpacedPoint::LocAlpha' has a wrong offset!");
static_assert(offsetof(FEvenlySpacedPoint, Tangent) == 0x000020, "Member 'FEvenlySpacedPoint::Tangent' has a wrong offset!");
static_assert(offsetof(FEvenlySpacedPoint, GrowthAlpha) == 0x00002C, "Member 'FEvenlySpacedPoint::GrowthAlpha' has a wrong offset!");
static_assert(offsetof(FEvenlySpacedPoint, GrowthAlphaTarget) == 0x000030, "Member 'FEvenlySpacedPoint::GrowthAlphaTarget' has a wrong offset!");
static_assert(offsetof(FEvenlySpacedPoint, SplineMeshComponent) == 0x000038, "Member 'FEvenlySpacedPoint::SplineMeshComponent' has a wrong offset!");

// ScriptStruct OrionGame.TraversablePathway
// 0x0040 (0x0040 - 0x0000)
struct FTraversablePathway final
{
public:
	TArray<struct FVector>                        PathToDestination;                                 // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         FirstPointAlpha;                                   // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FirstPathwayPoint;                                 // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastPathwayPoint;                                  // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ClosestPosOnPath;                                  // 0x001C(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 BreadCrumbActor;                                   // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionPlayerState_Game*                 PlayerState;                                       // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AbilityLevel;                                      // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTraversablePathway) == 0x000008, "Wrong alignment on FTraversablePathway");
static_assert(sizeof(FTraversablePathway) == 0x000040, "Wrong size on FTraversablePathway");
static_assert(offsetof(FTraversablePathway, PathToDestination) == 0x000000, "Member 'FTraversablePathway::PathToDestination' has a wrong offset!");
static_assert(offsetof(FTraversablePathway, FirstPointAlpha) == 0x000010, "Member 'FTraversablePathway::FirstPointAlpha' has a wrong offset!");
static_assert(offsetof(FTraversablePathway, FirstPathwayPoint) == 0x000014, "Member 'FTraversablePathway::FirstPathwayPoint' has a wrong offset!");
static_assert(offsetof(FTraversablePathway, LastPathwayPoint) == 0x000018, "Member 'FTraversablePathway::LastPathwayPoint' has a wrong offset!");
static_assert(offsetof(FTraversablePathway, ClosestPosOnPath) == 0x00001C, "Member 'FTraversablePathway::ClosestPosOnPath' has a wrong offset!");
static_assert(offsetof(FTraversablePathway, BreadCrumbActor) == 0x000028, "Member 'FTraversablePathway::BreadCrumbActor' has a wrong offset!");
static_assert(offsetof(FTraversablePathway, PlayerState) == 0x000030, "Member 'FTraversablePathway::PlayerState' has a wrong offset!");
static_assert(offsetof(FTraversablePathway, AbilityLevel) == 0x000038, "Member 'FTraversablePathway::AbilityLevel' has a wrong offset!");

// ScriptStruct OrionGame.OrionTutorialStage
// 0x00A0 (0x00A0 - 0x0000)
struct FOrionTutorialStage final
{
public:
	class FName                                   TargetId;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AdvanceId;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Title;                                             // 0x0010(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   MESSAGE;                                           // 0x0028(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   MessageForGamepad;                                 // 0x0040(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   MessageForGamepadWithQuickCast;                    // 0x0058(0x0018)(Edit, NativeAccessSpecifierPublic)
	class UOrionMcpQuestItemDefinition*           RequiredQuest;                                     // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequireInteraction;                               // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowBlackBackground;                              // 0x0079(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideButtons;                                      // 0x007A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideMessage;                                      // 0x007B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionMessageAudio                     MessageAudio;                                      // 0x0080(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           OtherWidgetsToShow;                                // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionTutorialStage) == 0x000008, "Wrong alignment on FOrionTutorialStage");
static_assert(sizeof(FOrionTutorialStage) == 0x0000A0, "Wrong size on FOrionTutorialStage");
static_assert(offsetof(FOrionTutorialStage, TargetId) == 0x000000, "Member 'FOrionTutorialStage::TargetId' has a wrong offset!");
static_assert(offsetof(FOrionTutorialStage, AdvanceId) == 0x000008, "Member 'FOrionTutorialStage::AdvanceId' has a wrong offset!");
static_assert(offsetof(FOrionTutorialStage, Title) == 0x000010, "Member 'FOrionTutorialStage::Title' has a wrong offset!");
static_assert(offsetof(FOrionTutorialStage, MESSAGE) == 0x000028, "Member 'FOrionTutorialStage::MESSAGE' has a wrong offset!");
static_assert(offsetof(FOrionTutorialStage, MessageForGamepad) == 0x000040, "Member 'FOrionTutorialStage::MessageForGamepad' has a wrong offset!");
static_assert(offsetof(FOrionTutorialStage, MessageForGamepadWithQuickCast) == 0x000058, "Member 'FOrionTutorialStage::MessageForGamepadWithQuickCast' has a wrong offset!");
static_assert(offsetof(FOrionTutorialStage, RequiredQuest) == 0x000070, "Member 'FOrionTutorialStage::RequiredQuest' has a wrong offset!");
static_assert(offsetof(FOrionTutorialStage, bRequireInteraction) == 0x000078, "Member 'FOrionTutorialStage::bRequireInteraction' has a wrong offset!");
static_assert(offsetof(FOrionTutorialStage, bShowBlackBackground) == 0x000079, "Member 'FOrionTutorialStage::bShowBlackBackground' has a wrong offset!");
static_assert(offsetof(FOrionTutorialStage, bHideButtons) == 0x00007A, "Member 'FOrionTutorialStage::bHideButtons' has a wrong offset!");
static_assert(offsetof(FOrionTutorialStage, bHideMessage) == 0x00007B, "Member 'FOrionTutorialStage::bHideMessage' has a wrong offset!");
static_assert(offsetof(FOrionTutorialStage, MessageAudio) == 0x000080, "Member 'FOrionTutorialStage::MessageAudio' has a wrong offset!");
static_assert(offsetof(FOrionTutorialStage, OtherWidgetsToShow) == 0x000090, "Member 'FOrionTutorialStage::OtherWidgetsToShow' has a wrong offset!");

// ScriptStruct OrionGame.LerpingPath
// 0x0040 (0x0040 - 0x0000)
struct FLerpingPath final
{
public:
	struct FInterpCurveVector                     PosTrack;                                          // 0x0000(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        StartPath;                                         // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        TargetPath;                                        // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	float                                         StartTime;                                         // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EndTime;                                           // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FLerpingPath) == 0x000008, "Wrong alignment on FLerpingPath");
static_assert(sizeof(FLerpingPath) == 0x000040, "Wrong size on FLerpingPath");
static_assert(offsetof(FLerpingPath, PosTrack) == 0x000000, "Member 'FLerpingPath::PosTrack' has a wrong offset!");
static_assert(offsetof(FLerpingPath, StartPath) == 0x000018, "Member 'FLerpingPath::StartPath' has a wrong offset!");
static_assert(offsetof(FLerpingPath, TargetPath) == 0x000028, "Member 'FLerpingPath::TargetPath' has a wrong offset!");
static_assert(offsetof(FLerpingPath, StartTime) == 0x000038, "Member 'FLerpingPath::StartTime' has a wrong offset!");
static_assert(offsetof(FLerpingPath, EndTime) == 0x00003C, "Member 'FLerpingPath::EndTime' has a wrong offset!");

// ScriptStruct OrionGame.TutorialDecalInfo
// 0x0020 (0x0020 - 0x0000)
struct FTutorialDecalInfo final
{
public:
	class UDecalComponent*                        LineDecalComponent;                                // 0x0000(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               LineDecalMID;                                      // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDecalComponent*                        NodeDecalComponent;                                // 0x0010(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               NodeDecalMID;                                      // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTutorialDecalInfo) == 0x000008, "Wrong alignment on FTutorialDecalInfo");
static_assert(sizeof(FTutorialDecalInfo) == 0x000020, "Wrong size on FTutorialDecalInfo");
static_assert(offsetof(FTutorialDecalInfo, LineDecalComponent) == 0x000000, "Member 'FTutorialDecalInfo::LineDecalComponent' has a wrong offset!");
static_assert(offsetof(FTutorialDecalInfo, LineDecalMID) == 0x000008, "Member 'FTutorialDecalInfo::LineDecalMID' has a wrong offset!");
static_assert(offsetof(FTutorialDecalInfo, NodeDecalComponent) == 0x000010, "Member 'FTutorialDecalInfo::NodeDecalComponent' has a wrong offset!");
static_assert(offsetof(FTutorialDecalInfo, NodeDecalMID) == 0x000018, "Member 'FTutorialDecalInfo::NodeDecalMID' has a wrong offset!");

// ScriptStruct OrionGame.OrionReplicatedCheatFlags
// 0x0003 (0x0003 - 0x0000)
struct FOrionReplicatedCheatFlags final
{
public:
	bool                                          RemoveCosts;                                       // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RemoveRespawnTime;                                 // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RemoveCooldowns;                                   // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionReplicatedCheatFlags) == 0x000001, "Wrong alignment on FOrionReplicatedCheatFlags");
static_assert(sizeof(FOrionReplicatedCheatFlags) == 0x000003, "Wrong size on FOrionReplicatedCheatFlags");
static_assert(offsetof(FOrionReplicatedCheatFlags, RemoveCosts) == 0x000000, "Member 'FOrionReplicatedCheatFlags::RemoveCosts' has a wrong offset!");
static_assert(offsetof(FOrionReplicatedCheatFlags, RemoveRespawnTime) == 0x000001, "Member 'FOrionReplicatedCheatFlags::RemoveRespawnTime' has a wrong offset!");
static_assert(offsetof(FOrionReplicatedCheatFlags, RemoveCooldowns) == 0x000002, "Member 'FOrionReplicatedCheatFlags::RemoveCooldowns' has a wrong offset!");

// ScriptStruct OrionGame.OrionSurveyResponse
// 0x0028 (0x0028 - 0x0000)
struct FOrionSurveyResponse final
{
public:
	class FName                                   QuestionGroupAsked;                                // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MatchSessionId;                                    // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 Responses;                                         // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionSurveyResponse) == 0x000008, "Wrong alignment on FOrionSurveyResponse");
static_assert(sizeof(FOrionSurveyResponse) == 0x000028, "Wrong size on FOrionSurveyResponse");
static_assert(offsetof(FOrionSurveyResponse, QuestionGroupAsked) == 0x000000, "Member 'FOrionSurveyResponse::QuestionGroupAsked' has a wrong offset!");
static_assert(offsetof(FOrionSurveyResponse, MatchSessionId) == 0x000008, "Member 'FOrionSurveyResponse::MatchSessionId' has a wrong offset!");
static_assert(offsetof(FOrionSurveyResponse, Responses) == 0x000018, "Member 'FOrionSurveyResponse::Responses' has a wrong offset!");

// ScriptStruct OrionGame.OrionSurveyInfo
// 0x0020 (0x0020 - 0x0000)
struct FOrionSurveyInfo final
{
public:
	bool                                          bAskSurvey;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   QuestionGroupToAsk;                                // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MatchSessionId;                                    // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionSurveyInfo) == 0x000008, "Wrong alignment on FOrionSurveyInfo");
static_assert(sizeof(FOrionSurveyInfo) == 0x000020, "Wrong size on FOrionSurveyInfo");
static_assert(offsetof(FOrionSurveyInfo, bAskSurvey) == 0x000000, "Member 'FOrionSurveyInfo::bAskSurvey' has a wrong offset!");
static_assert(offsetof(FOrionSurveyInfo, QuestionGroupToAsk) == 0x000008, "Member 'FOrionSurveyInfo::QuestionGroupToAsk' has a wrong offset!");
static_assert(offsetof(FOrionSurveyInfo, MatchSessionId) == 0x000010, "Member 'FOrionSurveyInfo::MatchSessionId' has a wrong offset!");

// ScriptStruct OrionGame.OrionSkinCosmeticChoices
// 0x0010 (0x0010 - 0x0000)
struct FOrionSkinCosmeticChoices final
{
public:
	class FString                                 ActiveSkinVariation;                               // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionSkinCosmeticChoices) == 0x000008, "Wrong alignment on FOrionSkinCosmeticChoices");
static_assert(sizeof(FOrionSkinCosmeticChoices) == 0x000010, "Wrong size on FOrionSkinCosmeticChoices");
static_assert(offsetof(FOrionSkinCosmeticChoices, ActiveSkinVariation) == 0x000000, "Member 'FOrionSkinCosmeticChoices::ActiveSkinVariation' has a wrong offset!");

// ScriptStruct OrionGame.OrionHeroSaveSettings
// 0x0028 (0x0028 - 0x0000)
struct FOrionHeroSaveSettings final
{
public:
	class FString                                 HeroId;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DeckId;                                            // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionRole                                    Role;                                              // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionPosition                                Position;                                          // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionHeroSaveSettings) == 0x000008, "Wrong alignment on FOrionHeroSaveSettings");
static_assert(sizeof(FOrionHeroSaveSettings) == 0x000028, "Wrong size on FOrionHeroSaveSettings");
static_assert(offsetof(FOrionHeroSaveSettings, HeroId) == 0x000000, "Member 'FOrionHeroSaveSettings::HeroId' has a wrong offset!");
static_assert(offsetof(FOrionHeroSaveSettings, DeckId) == 0x000010, "Member 'FOrionHeroSaveSettings::DeckId' has a wrong offset!");
static_assert(offsetof(FOrionHeroSaveSettings, Role) == 0x000020, "Member 'FOrionHeroSaveSettings::Role' has a wrong offset!");
static_assert(offsetof(FOrionHeroSaveSettings, Position) == 0x000021, "Member 'FOrionHeroSaveSettings::Position' has a wrong offset!");

// ScriptStruct OrionGame.OrionLootReward
// 0x0080 (0x0080 - 0x0000)
struct alignas(0x10) FOrionLootReward final
{
public:
	class UOrionMcpItemDefinition*                ItemDefinition;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SourceName;                                        // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LootGroupName;                                     // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMtxReward;                                      // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTimeCurrencyReward;                             // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNegative;                                       // 0x0032(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33[0x4D];                                      // 0x0033(0x004D)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionLootReward) == 0x000010, "Wrong alignment on FOrionLootReward");
static_assert(sizeof(FOrionLootReward) == 0x000080, "Wrong size on FOrionLootReward");
static_assert(offsetof(FOrionLootReward, ItemDefinition) == 0x000000, "Member 'FOrionLootReward::ItemDefinition' has a wrong offset!");
static_assert(offsetof(FOrionLootReward, Quantity) == 0x000008, "Member 'FOrionLootReward::Quantity' has a wrong offset!");
static_assert(offsetof(FOrionLootReward, SourceName) == 0x000010, "Member 'FOrionLootReward::SourceName' has a wrong offset!");
static_assert(offsetof(FOrionLootReward, Level) == 0x000018, "Member 'FOrionLootReward::Level' has a wrong offset!");
static_assert(offsetof(FOrionLootReward, LootGroupName) == 0x000020, "Member 'FOrionLootReward::LootGroupName' has a wrong offset!");
static_assert(offsetof(FOrionLootReward, bIsMtxReward) == 0x000030, "Member 'FOrionLootReward::bIsMtxReward' has a wrong offset!");
static_assert(offsetof(FOrionLootReward, bIsTimeCurrencyReward) == 0x000031, "Member 'FOrionLootReward::bIsTimeCurrencyReward' has a wrong offset!");
static_assert(offsetof(FOrionLootReward, bIsNegative) == 0x000032, "Member 'FOrionLootReward::bIsNegative' has a wrong offset!");

// ScriptStruct OrionGame.OrionHUDLogMessageData
// 0x0028 (0x0028 - 0x0000)
struct FOrionHUDLogMessageData final
{
public:
	TSubclassOf<class UOrionUserWidget_LogMessage> WidgetClass;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon1;                                             // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon2;                                             // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon3;                                             // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    TeamNum1;                                          // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    TeamNum2;                                          // 0x0021(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    MyTeam;                                            // 0x0022(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeam                                    EnemyTeam;                                         // 0x0023(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionHUDLogMessageData) == 0x000008, "Wrong alignment on FOrionHUDLogMessageData");
static_assert(sizeof(FOrionHUDLogMessageData) == 0x000028, "Wrong size on FOrionHUDLogMessageData");
static_assert(offsetof(FOrionHUDLogMessageData, WidgetClass) == 0x000000, "Member 'FOrionHUDLogMessageData::WidgetClass' has a wrong offset!");
static_assert(offsetof(FOrionHUDLogMessageData, Icon1) == 0x000008, "Member 'FOrionHUDLogMessageData::Icon1' has a wrong offset!");
static_assert(offsetof(FOrionHUDLogMessageData, Icon2) == 0x000010, "Member 'FOrionHUDLogMessageData::Icon2' has a wrong offset!");
static_assert(offsetof(FOrionHUDLogMessageData, Icon3) == 0x000018, "Member 'FOrionHUDLogMessageData::Icon3' has a wrong offset!");
static_assert(offsetof(FOrionHUDLogMessageData, TeamNum1) == 0x000020, "Member 'FOrionHUDLogMessageData::TeamNum1' has a wrong offset!");
static_assert(offsetof(FOrionHUDLogMessageData, TeamNum2) == 0x000021, "Member 'FOrionHUDLogMessageData::TeamNum2' has a wrong offset!");
static_assert(offsetof(FOrionHUDLogMessageData, MyTeam) == 0x000022, "Member 'FOrionHUDLogMessageData::MyTeam' has a wrong offset!");
static_assert(offsetof(FOrionHUDLogMessageData, EnemyTeam) == 0x000023, "Member 'FOrionHUDLogMessageData::EnemyTeam' has a wrong offset!");

// ScriptStruct OrionGame.OrionReplicatedVisibleToEnemy
// 0x0004 (0x0004 - 0x0000)
struct FOrionReplicatedVisibleToEnemy final
{
public:
	uint8                                         VisibleToEnemyBitMask;                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         InVisionZoneBitMask;                               // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CanSeeVisionZoneBitMask;                           // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ShadowVisionZoneBitMask;                           // 0x0003(0x0001)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionReplicatedVisibleToEnemy) == 0x000001, "Wrong alignment on FOrionReplicatedVisibleToEnemy");
static_assert(sizeof(FOrionReplicatedVisibleToEnemy) == 0x000004, "Wrong size on FOrionReplicatedVisibleToEnemy");
static_assert(offsetof(FOrionReplicatedVisibleToEnemy, VisibleToEnemyBitMask) == 0x000000, "Member 'FOrionReplicatedVisibleToEnemy::VisibleToEnemyBitMask' has a wrong offset!");
static_assert(offsetof(FOrionReplicatedVisibleToEnemy, InVisionZoneBitMask) == 0x000001, "Member 'FOrionReplicatedVisibleToEnemy::InVisionZoneBitMask' has a wrong offset!");
static_assert(offsetof(FOrionReplicatedVisibleToEnemy, CanSeeVisionZoneBitMask) == 0x000002, "Member 'FOrionReplicatedVisibleToEnemy::CanSeeVisionZoneBitMask' has a wrong offset!");
static_assert(offsetof(FOrionReplicatedVisibleToEnemy, ShadowVisionZoneBitMask) == 0x000003, "Member 'FOrionReplicatedVisibleToEnemy::ShadowVisionZoneBitMask' has a wrong offset!");

// ScriptStruct OrionGame.OrionReplicatedVisionData
// 0x0004 (0x0004 - 0x0000)
struct FOrionReplicatedVisionData final
{
public:
	uint16                                        Index;                                             // 0x0000(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionReplicatedVisionData) == 0x000002, "Wrong alignment on FOrionReplicatedVisionData");
static_assert(sizeof(FOrionReplicatedVisionData) == 0x000004, "Wrong size on FOrionReplicatedVisionData");
static_assert(offsetof(FOrionReplicatedVisionData, Index) == 0x000000, "Member 'FOrionReplicatedVisionData::Index' has a wrong offset!");

// ScriptStruct OrionGame.MinimapPingStyle
// 0x0090 (0x0090 - 0x0000)
struct FMinimapPingStyle final
{
public:
	class UCurveLinearColor*                      CenterImage_ColorOverTimeCurve;                    // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            CenterImage_ScaleOverTimeCurve;                    // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateBrush                            CenterImage;                                       // 0x0010(0x0078)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class USoundCue*                              PingSound;                                         // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FMinimapPingStyle) == 0x000008, "Wrong alignment on FMinimapPingStyle");
static_assert(sizeof(FMinimapPingStyle) == 0x000090, "Wrong size on FMinimapPingStyle");
static_assert(offsetof(FMinimapPingStyle, CenterImage_ColorOverTimeCurve) == 0x000000, "Member 'FMinimapPingStyle::CenterImage_ColorOverTimeCurve' has a wrong offset!");
static_assert(offsetof(FMinimapPingStyle, CenterImage_ScaleOverTimeCurve) == 0x000008, "Member 'FMinimapPingStyle::CenterImage_ScaleOverTimeCurve' has a wrong offset!");
static_assert(offsetof(FMinimapPingStyle, CenterImage) == 0x000010, "Member 'FMinimapPingStyle::CenterImage' has a wrong offset!");
static_assert(offsetof(FMinimapPingStyle, PingSound) == 0x000088, "Member 'FMinimapPingStyle::PingSound' has a wrong offset!");

// ScriptStruct OrionGame.ZoneVisionTimeOut
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FZoneVisionTimeOut final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FZoneVisionTimeOut) == 0x000004, "Wrong alignment on FZoneVisionTimeOut");
static_assert(sizeof(FZoneVisionTimeOut) == 0x000008, "Wrong size on FZoneVisionTimeOut");

// ScriptStruct OrionGame.VisionTestResults
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FVisionTestResults final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVisionTestResults) == 0x000008, "Wrong alignment on FVisionTestResults");
static_assert(sizeof(FVisionTestResults) == 0x000010, "Wrong size on FVisionTestResults");

// ScriptStruct OrionGame.VisionTestData
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x04) FVisionTestData final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVisionTestData) == 0x000004, "Wrong alignment on FVisionTestData");
static_assert(sizeof(FVisionTestData) == 0x000038, "Wrong size on FVisionTestData");

// ScriptStruct OrionGame.VisionTestInfo
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FVisionTestInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVisionTestInfo) == 0x000004, "Wrong alignment on FVisionTestInfo");
static_assert(sizeof(FVisionTestInfo) == 0x000008, "Wrong size on FVisionTestInfo");

// ScriptStruct OrionGame.OrionVisionDefOverride
// 0x0010 (0x0010 - 0x0000)
struct FOrionVisionDefOverride final
{
public:
	class UOrionVisionDef*                        Def;                                               // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        Index;                                             // 0x0008(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionVisionDefOverride) == 0x000008, "Wrong alignment on FOrionVisionDefOverride");
static_assert(sizeof(FOrionVisionDefOverride) == 0x000010, "Wrong size on FOrionVisionDefOverride");
static_assert(offsetof(FOrionVisionDefOverride, Def) == 0x000000, "Member 'FOrionVisionDefOverride::Def' has a wrong offset!");
static_assert(offsetof(FOrionVisionDefOverride, Index) == 0x000008, "Member 'FOrionVisionDefOverride::Index' has a wrong offset!");

// ScriptStruct OrionGame.WardTrackedHeroData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FWardTrackedHeroData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWardTrackedHeroData) == 0x000008, "Wrong alignment on FWardTrackedHeroData");
static_assert(sizeof(FWardTrackedHeroData) == 0x000018, "Wrong size on FWardTrackedHeroData");

// ScriptStruct OrionGame.OrionWellCues
// 0x0038 (0x0038 - 0x0000)
struct FOrionWellCues final
{
public:
	struct FGameplayCueTag                        Geyser;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        Active;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        DeadZone;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        RanDry;                                            // 0x0018(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        RigPlaced;                                         // 0x0020(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        PlacingRig;                                        // 0x0028(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        CollectingFromRig;                                 // 0x0030(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrionWellCues) == 0x000008, "Wrong alignment on FOrionWellCues");
static_assert(sizeof(FOrionWellCues) == 0x000038, "Wrong size on FOrionWellCues");
static_assert(offsetof(FOrionWellCues, Geyser) == 0x000000, "Member 'FOrionWellCues::Geyser' has a wrong offset!");
static_assert(offsetof(FOrionWellCues, Active) == 0x000008, "Member 'FOrionWellCues::Active' has a wrong offset!");
static_assert(offsetof(FOrionWellCues, DeadZone) == 0x000010, "Member 'FOrionWellCues::DeadZone' has a wrong offset!");
static_assert(offsetof(FOrionWellCues, RanDry) == 0x000018, "Member 'FOrionWellCues::RanDry' has a wrong offset!");
static_assert(offsetof(FOrionWellCues, RigPlaced) == 0x000020, "Member 'FOrionWellCues::RigPlaced' has a wrong offset!");
static_assert(offsetof(FOrionWellCues, PlacingRig) == 0x000028, "Member 'FOrionWellCues::PlacingRig' has a wrong offset!");
static_assert(offsetof(FOrionWellCues, CollectingFromRig) == 0x000030, "Member 'FOrionWellCues::CollectingFromRig' has a wrong offset!");

// ScriptStruct OrionGame.WidgetDataEntry
// 0x0010 (0x0010 - 0x0000)
struct FWidgetDataEntry final
{
public:
	class FName                                   WidgetName;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                Widget;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWidgetDataEntry) == 0x000008, "Wrong alignment on FWidgetDataEntry");
static_assert(sizeof(FWidgetDataEntry) == 0x000010, "Wrong size on FWidgetDataEntry");
static_assert(offsetof(FWidgetDataEntry, WidgetName) == 0x000000, "Member 'FWidgetDataEntry::WidgetName' has a wrong offset!");
static_assert(offsetof(FWidgetDataEntry, Widget) == 0x000008, "Member 'FWidgetDataEntry::Widget' has a wrong offset!");

// ScriptStruct OrionGame.NiagaraSystemPoolElem
// 0x0020 (0x0020 - 0x0000)
struct FNiagaraSystemPoolElem final
{
public:
	TArray<class UNiagaraComponent*>              PSComponents;                                      // 0x0000(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNiagaraSystemPoolElem) == 0x000008, "Wrong alignment on FNiagaraSystemPoolElem");
static_assert(sizeof(FNiagaraSystemPoolElem) == 0x000020, "Wrong size on FNiagaraSystemPoolElem");
static_assert(offsetof(FNiagaraSystemPoolElem, PSComponents) == 0x000000, "Member 'FNiagaraSystemPoolElem::PSComponents' has a wrong offset!");

// ScriptStruct OrionGame.OrionWorldGlobals
// 0x09F0 (0x09F0 - 0x0000)
struct alignas(0x10) FOrionWorldGlobals final
{
public:
	uint8                                         Pad_0[0x100];                                      // 0x0000(0x0100)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AOrionArenaCamera*>              ArenaCameras;                                      // 0x0100(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_110[0x700];                                    // 0x0110(0x0700)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrionGameState_Base*                   AvailableGameState;                                // 0x0810(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AOrionPlayerState_Game*                 AvailablePlayerState;                              // 0x0818(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionAbilitySystemComponent*           AvailableAbilitySystemComp;                        // 0x0820(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AOrionVisionManager2*                   VisionManager;                                     // 0x0828(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bGameReady;                                        // 0x0830(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTeamInfoReady;                                    // 0x0831(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bFirstControlledPawn;                              // 0x0832(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bFirstHeroData;                                    // 0x0833(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAbilitySystemCompReady;                           // 0x0834(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bMatchDataLoaded;                                  // 0x0835(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bReadyToStartMatch;                                // 0x0836(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHUDLoaded;                                        // 0x0837(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPlayerControllerHasState;                         // 0x0838(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPlayerControllerMcpProfileQueryComplete;          // 0x0839(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_83A[0x5E];                                     // 0x083A(0x005E)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UParticleSystem*, struct FParticleSystemPoolElem> InUseWorldParticleSystems;                         // 0x0898(0x0050)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class UNiagaraSystem*, struct FNiagaraSystemPoolElem> InUseWorldNiagaraSystems;                          // 0x08E8(0x0050)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_938[0x8];                                      // 0x0938(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UParticleSystem*, struct FParticleSystemPoolElem> WorldParticleSystemPool;                           // 0x0940(0x0050)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class UNiagaraSystem*, struct FNiagaraSystemPoolElem> WorldNiagaraSystemPool;                            // 0x0990(0x0050)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9E0[0x10];                                     // 0x09E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionWorldGlobals) == 0x000010, "Wrong alignment on FOrionWorldGlobals");
static_assert(sizeof(FOrionWorldGlobals) == 0x0009F0, "Wrong size on FOrionWorldGlobals");
static_assert(offsetof(FOrionWorldGlobals, ArenaCameras) == 0x000100, "Member 'FOrionWorldGlobals::ArenaCameras' has a wrong offset!");
static_assert(offsetof(FOrionWorldGlobals, AvailableGameState) == 0x000810, "Member 'FOrionWorldGlobals::AvailableGameState' has a wrong offset!");
static_assert(offsetof(FOrionWorldGlobals, AvailablePlayerState) == 0x000818, "Member 'FOrionWorldGlobals::AvailablePlayerState' has a wrong offset!");
static_assert(offsetof(FOrionWorldGlobals, AvailableAbilitySystemComp) == 0x000820, "Member 'FOrionWorldGlobals::AvailableAbilitySystemComp' has a wrong offset!");
static_assert(offsetof(FOrionWorldGlobals, VisionManager) == 0x000828, "Member 'FOrionWorldGlobals::VisionManager' has a wrong offset!");
static_assert(offsetof(FOrionWorldGlobals, bGameReady) == 0x000830, "Member 'FOrionWorldGlobals::bGameReady' has a wrong offset!");
static_assert(offsetof(FOrionWorldGlobals, bTeamInfoReady) == 0x000831, "Member 'FOrionWorldGlobals::bTeamInfoReady' has a wrong offset!");
static_assert(offsetof(FOrionWorldGlobals, bFirstControlledPawn) == 0x000832, "Member 'FOrionWorldGlobals::bFirstControlledPawn' has a wrong offset!");
static_assert(offsetof(FOrionWorldGlobals, bFirstHeroData) == 0x000833, "Member 'FOrionWorldGlobals::bFirstHeroData' has a wrong offset!");
static_assert(offsetof(FOrionWorldGlobals, bAbilitySystemCompReady) == 0x000834, "Member 'FOrionWorldGlobals::bAbilitySystemCompReady' has a wrong offset!");
static_assert(offsetof(FOrionWorldGlobals, bMatchDataLoaded) == 0x000835, "Member 'FOrionWorldGlobals::bMatchDataLoaded' has a wrong offset!");
static_assert(offsetof(FOrionWorldGlobals, bReadyToStartMatch) == 0x000836, "Member 'FOrionWorldGlobals::bReadyToStartMatch' has a wrong offset!");
static_assert(offsetof(FOrionWorldGlobals, bHUDLoaded) == 0x000837, "Member 'FOrionWorldGlobals::bHUDLoaded' has a wrong offset!");
static_assert(offsetof(FOrionWorldGlobals, bPlayerControllerHasState) == 0x000838, "Member 'FOrionWorldGlobals::bPlayerControllerHasState' has a wrong offset!");
static_assert(offsetof(FOrionWorldGlobals, bPlayerControllerMcpProfileQueryComplete) == 0x000839, "Member 'FOrionWorldGlobals::bPlayerControllerMcpProfileQueryComplete' has a wrong offset!");
static_assert(offsetof(FOrionWorldGlobals, InUseWorldParticleSystems) == 0x000898, "Member 'FOrionWorldGlobals::InUseWorldParticleSystems' has a wrong offset!");
static_assert(offsetof(FOrionWorldGlobals, InUseWorldNiagaraSystems) == 0x0008E8, "Member 'FOrionWorldGlobals::InUseWorldNiagaraSystems' has a wrong offset!");
static_assert(offsetof(FOrionWorldGlobals, WorldParticleSystemPool) == 0x000940, "Member 'FOrionWorldGlobals::WorldParticleSystemPool' has a wrong offset!");
static_assert(offsetof(FOrionWorldGlobals, WorldNiagaraSystemPool) == 0x000990, "Member 'FOrionWorldGlobals::WorldNiagaraSystemPool' has a wrong offset!");

// ScriptStruct OrionGame.TeamHeroRecord
// 0x0020 (0x0020 - 0x0000)
struct FTeamHeroRecord final
{
public:
	TArray<struct FHeroRecord>                    Records;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTeamHeroRecord) == 0x000008, "Wrong alignment on FTeamHeroRecord");
static_assert(sizeof(FTeamHeroRecord) == 0x000020, "Wrong size on FTeamHeroRecord");
static_assert(offsetof(FTeamHeroRecord, Records) == 0x000000, "Member 'FTeamHeroRecord::Records' has a wrong offset!");

// ScriptStruct OrionGame.OrionXPAssisterData
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FOrionXPAssisterData final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrionXPAssisterData) == 0x000004, "Wrong alignment on FOrionXPAssisterData");
static_assert(sizeof(FOrionXPAssisterData) == 0x00000C, "Wrong size on FOrionXPAssisterData");

// ScriptStruct OrionGame.AbilityDisplayValue
// 0x0068 (0x0068 - 0x0000)
struct FAbilityDisplayValue final
{
public:
	class FName                                   ValueName;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncreasingIsGood;                                 // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPercentage;                                     // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAttribute                     AssociatedAttribute;                               // 0x0010(0x0020)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FScalableFloat                         BaseValue;                                         // 0x0030(0x0028)(NativeAccessSpecifierPublic)
	TArray<struct FAbilityDisplayValueModifier>   ModifierValues;                                    // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbilityDisplayValue) == 0x000008, "Wrong alignment on FAbilityDisplayValue");
static_assert(sizeof(FAbilityDisplayValue) == 0x000068, "Wrong size on FAbilityDisplayValue");
static_assert(offsetof(FAbilityDisplayValue, ValueName) == 0x000000, "Member 'FAbilityDisplayValue::ValueName' has a wrong offset!");
static_assert(offsetof(FAbilityDisplayValue, bIncreasingIsGood) == 0x000008, "Member 'FAbilityDisplayValue::bIncreasingIsGood' has a wrong offset!");
static_assert(offsetof(FAbilityDisplayValue, bIsPercentage) == 0x000009, "Member 'FAbilityDisplayValue::bIsPercentage' has a wrong offset!");
static_assert(offsetof(FAbilityDisplayValue, AssociatedAttribute) == 0x000010, "Member 'FAbilityDisplayValue::AssociatedAttribute' has a wrong offset!");
static_assert(offsetof(FAbilityDisplayValue, BaseValue) == 0x000030, "Member 'FAbilityDisplayValue::BaseValue' has a wrong offset!");
static_assert(offsetof(FAbilityDisplayValue, ModifierValues) == 0x000058, "Member 'FAbilityDisplayValue::ModifierValues' has a wrong offset!");

// ScriptStruct OrionGame.TimeAgo
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FTimeAgo final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTimeAgo) == 0x000008, "Wrong alignment on FTimeAgo");
static_assert(sizeof(FTimeAgo) == 0x000038, "Wrong size on FTimeAgo");

}

