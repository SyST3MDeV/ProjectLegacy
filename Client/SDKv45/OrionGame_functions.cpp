#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: OrionGame

#include "Basic.hpp"

#include "OrionGame_classes.hpp"
#include "OrionGame_parameters.hpp"


namespace SDK
{

// Function OrionGame.FunctionalTestPhase.Cleanup
// (Native, Public, BlueprintCallable)

void UFunctionalTestPhase::Cleanup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FunctionalTestPhase", "Cleanup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.FunctionalTestPhase.CleanupHook
// (Event, Public, BlueprintEvent)

void UFunctionalTestPhase::CleanupHook()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FunctionalTestPhase", "CleanupHook");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.FunctionalTestPhase.ClearTimeouts
// (Final, Native, Public, BlueprintCallable)

void UFunctionalTestPhase::ClearTimeouts()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FunctionalTestPhase", "ClearTimeouts");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.FunctionalTestPhase.Execute
// (Native, Public, BlueprintCallable)

void UFunctionalTestPhase::Execute()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FunctionalTestPhase", "Execute");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.FunctionalTestPhase.ExecuteHook
// (Event, Public, BlueprintEvent)

void UFunctionalTestPhase::ExecuteHook()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FunctionalTestPhase", "ExecuteHook");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.FunctionalTestPhase.GetCleanupStatus
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EFunctionalTestResult                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFunctionalTestResult UFunctionalTestPhase::GetCleanupStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FunctionalTestPhase", "GetCleanupStatus");

	Params::FunctionalTestPhase_GetCleanupStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.FunctionalTestPhase.GetExecuteStatus
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EFunctionalTestResult                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFunctionalTestResult UFunctionalTestPhase::GetExecuteStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FunctionalTestPhase", "GetExecuteStatus");

	Params::FunctionalTestPhase_GetExecuteStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.FunctionalTestPhase.GetSetupStatus
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EFunctionalTestResult                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFunctionalTestResult UFunctionalTestPhase::GetSetupStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FunctionalTestPhase", "GetSetupStatus");

	Params::FunctionalTestPhase_GetSetupStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.FunctionalTestPhase.GetTest
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APhasedFunctionalTest*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APhasedFunctionalTest* UFunctionalTestPhase::GetTest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FunctionalTestPhase", "GetTest");

	Params::FunctionalTestPhase_GetTest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.FunctionalTestPhase.HasEncounteredError
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFunctionalTestPhase::HasEncounteredError()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FunctionalTestPhase", "HasEncounteredError");

	Params::FunctionalTestPhase_HasEncounteredError Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.FunctionalTestPhase.HasFailed
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFunctionalTestPhase::HasFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FunctionalTestPhase", "HasFailed");

	Params::FunctionalTestPhase_HasFailed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.FunctionalTestPhase.IsCleanupFinished
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFunctionalTestPhase::IsCleanupFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FunctionalTestPhase", "IsCleanupFinished");

	Params::FunctionalTestPhase_IsCleanupFinished Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.FunctionalTestPhase.IsExecuteFinished
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFunctionalTestPhase::IsExecuteFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FunctionalTestPhase", "IsExecuteFinished");

	Params::FunctionalTestPhase_IsExecuteFinished Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.FunctionalTestPhase.IsPhaseRunningInEditor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFunctionalTestPhase::IsPhaseRunningInEditor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FunctionalTestPhase", "IsPhaseRunningInEditor");

	Params::FunctionalTestPhase_IsPhaseRunningInEditor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.FunctionalTestPhase.IsSetupFinished
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFunctionalTestPhase::IsSetupFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FunctionalTestPhase", "IsSetupFinished");

	Params::FunctionalTestPhase_IsSetupFinished Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.FunctionalTestPhase.LogError
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           MESSAGE                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFunctionalTestPhase::LogError(const class FString& MESSAGE)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FunctionalTestPhase", "LogError");

	Params::FunctionalTestPhase_LogError Parms{};

	Parms.MESSAGE = std::move(MESSAGE);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.FunctionalTestPhase.LogInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           MESSAGE                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFunctionalTestPhase::LogInfo(const class FString& MESSAGE)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FunctionalTestPhase", "LogInfo");

	Params::FunctionalTestPhase_LogInfo Parms{};

	Parms.MESSAGE = std::move(MESSAGE);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.FunctionalTestPhase.LogVerbose
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           MESSAGE                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFunctionalTestPhase::LogVerbose(const class FString& MESSAGE)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FunctionalTestPhase", "LogVerbose");

	Params::FunctionalTestPhase_LogVerbose Parms{};

	Parms.MESSAGE = std::move(MESSAGE);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.FunctionalTestPhase.LogWarning
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           MESSAGE                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFunctionalTestPhase::LogWarning(const class FString& MESSAGE)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FunctionalTestPhase", "LogWarning");

	Params::FunctionalTestPhase_LogWarning Parms{};

	Parms.MESSAGE = std::move(MESSAGE);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.FunctionalTestPhase.OnCleanupTimedOut
// (Native, Event, Public, BlueprintEvent)

void UFunctionalTestPhase::OnCleanupTimedOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FunctionalTestPhase", "OnCleanupTimedOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.FunctionalTestPhase.OnExecuteTimedOut
// (Native, Event, Public, BlueprintEvent)

void UFunctionalTestPhase::OnExecuteTimedOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FunctionalTestPhase", "OnExecuteTimedOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.FunctionalTestPhase.OnSetupTimedOut
// (Native, Event, Public, BlueprintEvent)

void UFunctionalTestPhase::OnSetupTimedOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FunctionalTestPhase", "OnSetupTimedOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.FunctionalTestPhase.Reset
// (Native, Public, BlueprintCallable)

void UFunctionalTestPhase::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FunctionalTestPhase", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.FunctionalTestPhase.ResetHook
// (Event, Public, BlueprintEvent)

void UFunctionalTestPhase::ResetHook()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FunctionalTestPhase", "ResetHook");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.FunctionalTestPhase.SetCleanupStatus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFunctionalTestResult                   Status                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFunctionalTestPhase::SetCleanupStatus(EFunctionalTestResult Status)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FunctionalTestPhase", "SetCleanupStatus");

	Params::FunctionalTestPhase_SetCleanupStatus Parms{};

	Parms.Status = Status;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.FunctionalTestPhase.SetExecuteStatus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFunctionalTestResult                   Status                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFunctionalTestPhase::SetExecuteStatus(EFunctionalTestResult Status)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FunctionalTestPhase", "SetExecuteStatus");

	Params::FunctionalTestPhase_SetExecuteStatus Parms{};

	Parms.Status = Status;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.FunctionalTestPhase.SetSetupStatus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFunctionalTestResult                   Status                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFunctionalTestPhase::SetSetupStatus(EFunctionalTestResult Status)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FunctionalTestPhase", "SetSetupStatus");

	Params::FunctionalTestPhase_SetSetupStatus Parms{};

	Parms.Status = Status;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.FunctionalTestPhase.Setup
// (Native, Public, BlueprintCallable)

void UFunctionalTestPhase::Setup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FunctionalTestPhase", "Setup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.FunctionalTestPhase.SetupHook
// (Event, Public, BlueprintEvent)

void UFunctionalTestPhase::SetupHook()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FunctionalTestPhase", "SetupHook");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.FTS_ExecuteAbility.OnExecuteTimedOut_Implementation
// (Final, Native, Private)

void UFTS_ExecuteAbility::OnExecuteTimedOut_Implementation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FTS_ExecuteAbility", "OnExecuteTimedOut_Implementation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.FTS_ExecuteAbility.SetNextExecutionStep
// (Final, Native, Private)

void UFTS_ExecuteAbility::SetNextExecutionStep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FTS_ExecuteAbility", "SetNextExecutionStep");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.FTS_ExecuteAbility.WaitTimerFinished
// (Final, Native, Private)

void UFTS_ExecuteAbility::WaitTimerFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FTS_ExecuteAbility", "WaitTimerFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.AITeamComm.RequestAITeamComm
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AOrionAIBot*                      BotController                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAITeamCommEvent                        Event                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreTimeouts                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TriggerDelay                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAITeamComm::RequestAITeamComm(const class AOrionAIBot* BotController, const EAITeamCommEvent Event, const bool bIgnoreTimeouts, const float TriggerDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AITeamComm", "RequestAITeamComm");

	Params::AITeamComm_RequestAITeamComm Parms{};

	Parms.BotController = BotController;
	Parms.Event = Event;
	Parms.bIgnoreTimeouts = bIgnoreTimeouts;
	Parms.TriggerDelay = TriggerDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.FunctionalTestCondition.GetTest
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APhasedFunctionalTest*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APhasedFunctionalTest* UFunctionalTestCondition::GetTest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FunctionalTestCondition", "GetTest");

	Params::FunctionalTestCondition_GetTest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.FTC_Test.AllowEvaluate
// (Final, Native, Protected)

void UFTC_Test::AllowEvaluate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FTC_Test", "AllowEvaluate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.FTC_Test.AllowValidate
// (Final, Native, Protected)

void UFTC_Test::AllowValidate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FTC_Test", "AllowValidate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.AIInfluenceSourceComponent.K2_SetInfluenceValues
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InStrength                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIInfluenceSourceComponent::K2_SetInfluenceValues(float Radius, float InStrength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIInfluenceSourceComponent", "K2_SetInfluenceValues");

	Params::AIInfluenceSourceComponent_K2_SetInfluenceValues Parms{};

	Parms.Radius = Radius;
	Parms.InStrength = InStrength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameMode_Base.ChangeTeam
// (Native, Public, BlueprintCallable)
// Parameters:
// class AController*                      InController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionTeam                              TeamIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionGameMode_Base::ChangeTeam(class AController* InController, EOrionTeam TeamIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_Base", "ChangeTeam");

	Params::OrionGameMode_Base_ChangeTeam Parms{};

	Parms.InController = InController;
	Parms.TeamIndex = TeamIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameMode_Base.ExecuteGameplayCue
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     GameplayCueTag                                         (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Parameters                                             (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameMode_Base::ExecuteGameplayCue(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Parameters, class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_Base", "ExecuteGameplayCue");

	Params::OrionGameMode_Base_ExecuteGameplayCue Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.Parameters = std::move(Parameters);
	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameMode_MOBA.ForceMatchWinCondition
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// EOrionTeam                              TeamNum                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameMode_MOBA::ForceMatchWinCondition(EOrionTeam TeamNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_MOBA", "ForceMatchWinCondition");

	Params::OrionGameMode_MOBA_ForceMatchWinCondition Parms{};

	Parms.TeamNum = TeamNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameMode_MOBA.GetWinningTeamNum
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// EOrionTeam                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOrionTeam AOrionGameMode_MOBA::GetWinningTeamNum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_MOBA", "GetWinningTeamNum");

	Params::OrionGameMode_MOBA_GetWinningTeamNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameMode_MOBA.IsMatchObjectiveCompleted
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionGameMode_MOBA::IsMatchObjectiveCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_MOBA", "IsMatchObjectiveCompleted");

	Params::OrionGameMode_MOBA_IsMatchObjectiveCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameMode_MOBA.ReceiveCoreKilled
// (Event, Public, BlueprintEvent)
// Parameters:
// class AController*                      Killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOrionDamageableActor*            KilledCore                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameMode_MOBA::ReceiveCoreKilled(class AController* Killer, class AOrionDamageableActor* KilledCore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_MOBA", "ReceiveCoreKilled");

	Params::OrionGameMode_MOBA_ReceiveCoreKilled Parms{};

	Parms.Killer = Killer;
	Parms.KilledCore = KilledCore;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionGameMode_MOBA.ReceiveInhibitorKilled
// (Event, Public, BlueprintEvent)
// Parameters:
// class AController*                      Killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOrionDamageableActor*            KilledInhibitor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameMode_MOBA::ReceiveInhibitorKilled(class AController* Killer, class AOrionDamageableActor* KilledInhibitor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_MOBA", "ReceiveInhibitorKilled");

	Params::OrionGameMode_MOBA_ReceiveInhibitorKilled Parms{};

	Parms.Killer = Killer;
	Parms.KilledInhibitor = KilledInhibitor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionGameMode_MOBA.ReceiveMinionKilled
// (Event, Public, BlueprintEvent)
// Parameters:
// class AController*                      Killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      KilledMinion                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            KilledPawn                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameMode_MOBA::ReceiveMinionKilled(class AController* Killer, class AController* KilledMinion, class APawn* KilledPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_MOBA", "ReceiveMinionKilled");

	Params::OrionGameMode_MOBA_ReceiveMinionKilled Parms{};

	Parms.Killer = Killer;
	Parms.KilledMinion = KilledMinion;
	Parms.KilledPawn = KilledPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionGameMode_MOBA.ReceiveOtherStructureKilled
// (Event, Public, BlueprintEvent)
// Parameters:
// class AController*                      Killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOrionDamageableActor*            KilledActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameMode_MOBA::ReceiveOtherStructureKilled(class AController* Killer, class AOrionDamageableActor* KilledActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_MOBA", "ReceiveOtherStructureKilled");

	Params::OrionGameMode_MOBA_ReceiveOtherStructureKilled Parms{};

	Parms.Killer = Killer;
	Parms.KilledActor = KilledActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionGameMode_MOBA.ReceivePlayerKilled
// (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)
// Parameters:
// class AController*                      Killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      KilledPlayer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            KilledPawn                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MultiKillCount                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   KillStreakCount                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameMode_MOBA::ReceivePlayerKilled(class AController* Killer, class AController* KilledPlayer, class APawn* KilledPawn, int32 MultiKillCount, int32 KillStreakCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_MOBA", "ReceivePlayerKilled");

	Params::OrionGameMode_MOBA_ReceivePlayerKilled Parms{};

	Parms.Killer = Killer;
	Parms.KilledPlayer = KilledPlayer;
	Parms.KilledPawn = KilledPawn;
	Parms.MultiKillCount = MultiKillCount;
	Parms.KillStreakCount = KillStreakCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionGameMode_MOBA.ReceivePlayerKillStreakShutdown
// (Event, Public, BlueprintEvent)
// Parameters:
// class AController*                      Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      Killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   KillStreakCount                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameMode_MOBA::ReceivePlayerKillStreakShutdown(class AController* Victim, class AController* Killer, int32 KillStreakCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_MOBA", "ReceivePlayerKillStreakShutdown");

	Params::OrionGameMode_MOBA_ReceivePlayerKillStreakShutdown Parms{};

	Parms.Victim = Victim;
	Parms.Killer = Killer;
	Parms.KillStreakCount = KillStreakCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionGameMode_MOBA.ReceivePlayerSpawned
// (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)
// Parameters:
// class AOrionChar*                       SpawnedChar                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionTeam                              Team                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameMode_MOBA::ReceivePlayerSpawned(class AOrionChar* SpawnedChar, EOrionTeam Team)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_MOBA", "ReceivePlayerSpawned");

	Params::OrionGameMode_MOBA_ReceivePlayerSpawned Parms{};

	Parms.SpawnedChar = SpawnedChar;
	Parms.Team = Team;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionGameMode_MOBA.ReceiveTowerKilled
// (Event, Public, BlueprintEvent)
// Parameters:
// class AController*                      Killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOrionDamageableActor*            KilledTower                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameMode_MOBA::ReceiveTowerKilled(class AController* Killer, class AOrionDamageableActor* KilledTower)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_MOBA", "ReceiveTowerKilled");

	Params::OrionGameMode_MOBA_ReceiveTowerKilled Parms{};

	Parms.Killer = Killer;
	Parms.KilledTower = KilledTower;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionGameMode_MOBA.GetBotDifficulty
// (Final, Native, Protected, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAIBotDifficulty                        EnemyBotDifficulty                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAIBotDifficulty                        FriendlyBotDifficulty                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameMode_MOBA::GetBotDifficulty(EAIBotDifficulty* EnemyBotDifficulty, EAIBotDifficulty* FriendlyBotDifficulty) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_MOBA", "GetBotDifficulty");

	Params::OrionGameMode_MOBA_GetBotDifficulty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (EnemyBotDifficulty != nullptr)
		*EnemyBotDifficulty = Parms.EnemyBotDifficulty;

	if (FriendlyBotDifficulty != nullptr)
		*FriendlyBotDifficulty = Parms.FriendlyBotDifficulty;
}


// Function OrionGame.OrionGameMode_MOBA.GetBotTeams
// (Final, Native, Protected, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AOrionPlayerState_Game*>   OutEnemyTeam                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class AOrionPlayerState_Game*>   OutFriendlyTeam                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void AOrionGameMode_MOBA::GetBotTeams(TArray<class AOrionPlayerState_Game*>* OutEnemyTeam, TArray<class AOrionPlayerState_Game*>* OutFriendlyTeam) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_MOBA", "GetBotTeams");

	Params::OrionGameMode_MOBA_GetBotTeams Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutEnemyTeam != nullptr)
		*OutEnemyTeam = std::move(Parms.OutEnemyTeam);

	if (OutFriendlyTeam != nullptr)
		*OutFriendlyTeam = std::move(Parms.OutFriendlyTeam);
}


// Function OrionGame.OrionGameMode_Sandbox.KillAI
// (Final, Native, Protected, BlueprintCallable)

void AOrionGameMode_Sandbox::KillAI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_Sandbox", "KillAI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameMode_Sandbox.KillAllNonPlayerPawns
// (Final, Native, Protected, BlueprintCallable)

void AOrionGameMode_Sandbox::KillAllNonPlayerPawns()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_Sandbox", "KillAllNonPlayerPawns");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameMode_Sandbox.OnEnter_FightPractice
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameMode_Sandbox::OnEnter_FightPractice(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_Sandbox", "OnEnter_FightPractice");

	Params::OrionGameMode_Sandbox_OnEnter_FightPractice Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameMode_Sandbox.OnEnter_FightPractice_LineupSelect
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionPosition                          Enemy_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionPosition                          Enemy_1                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionPosition                          Friendly                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameMode_Sandbox::OnEnter_FightPractice_LineupSelect(class AActor* OverlappedActor, class AActor* OtherActor, EOrionPosition Enemy_0, EOrionPosition Enemy_1, EOrionPosition Friendly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_Sandbox", "OnEnter_FightPractice_LineupSelect");

	Params::OrionGameMode_Sandbox_OnEnter_FightPractice_LineupSelect Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;
	Parms.Enemy_0 = Enemy_0;
	Parms.Enemy_1 = Enemy_1;
	Parms.Friendly = Friendly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameMode_Sandbox.OnEnter_LastHitting
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameMode_Sandbox::OnEnter_LastHitting(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_Sandbox", "OnEnter_LastHitting");

	Params::OrionGameMode_Sandbox_OnEnter_LastHitting Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameMode_Sandbox.OnEnter_LevelUp
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameMode_Sandbox::OnEnter_LevelUp(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_Sandbox", "OnEnter_LevelUp");

	Params::OrionGameMode_Sandbox_OnEnter_LevelUp Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameMode_Sandbox.OnEnter_ShootingRange
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameMode_Sandbox::OnEnter_ShootingRange(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_Sandbox", "OnEnter_ShootingRange");

	Params::OrionGameMode_Sandbox_OnEnter_ShootingRange Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameMode_Sandbox.OnEnter_TowerDefense
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameMode_Sandbox::OnEnter_TowerDefense(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_Sandbox", "OnEnter_TowerDefense");

	Params::OrionGameMode_Sandbox_OnEnter_TowerDefense Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameMode_Sandbox.OnExit_FightPractice
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameMode_Sandbox::OnExit_FightPractice(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_Sandbox", "OnExit_FightPractice");

	Params::OrionGameMode_Sandbox_OnExit_FightPractice Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameMode_Sandbox.OnExit_LastHitting
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameMode_Sandbox::OnExit_LastHitting(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_Sandbox", "OnExit_LastHitting");

	Params::OrionGameMode_Sandbox_OnExit_LastHitting Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameMode_Sandbox.OnExit_LevelUp
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameMode_Sandbox::OnExit_LevelUp(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_Sandbox", "OnExit_LevelUp");

	Params::OrionGameMode_Sandbox_OnExit_LevelUp Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameMode_Sandbox.OnExit_ShootingRange
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameMode_Sandbox::OnExit_ShootingRange(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_Sandbox", "OnExit_ShootingRange");

	Params::OrionGameMode_Sandbox_OnExit_ShootingRange Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameMode_Sandbox.OnExit_TowerDefense
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameMode_Sandbox::OnExit_TowerDefense(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_Sandbox", "OnExit_TowerDefense");

	Params::OrionGameMode_Sandbox_OnExit_TowerDefense Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameMode_Sandbox.OnHeroEnterLevelUp
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class AOrionPlayerState_Game*           PlayerState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameMode_Sandbox::OnHeroEnterLevelUp(class AOrionPlayerState_Game* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_Sandbox", "OnHeroEnterLevelUp");

	Params::OrionGameMode_Sandbox_OnHeroEnterLevelUp Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameMode_Sandbox.OnTowerDeath
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AController*                      Killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameMode_Sandbox::OnTowerDeath(class AController* Killer, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_Sandbox", "OnTowerDeath");

	Params::OrionGameMode_Sandbox_OnTowerDeath Parms{};

	Parms.Killer = Killer;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameMode_Sandbox.InitOrionSandboxPlayerState
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// class AOrionPlayerState_Game*           PlayerState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameMode_Sandbox::InitOrionSandboxPlayerState(class AOrionPlayerState_Game* PlayerState) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_Sandbox", "InitOrionSandboxPlayerState");

	Params::OrionGameMode_Sandbox_InitOrionSandboxPlayerState Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBaseActor.ExecuteGameplayCueLocal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     GameplayCueTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Parameters                                             (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AOrionBaseActor::ExecuteGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Parameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseActor", "ExecuteGameplayCueLocal");

	Params::OrionBaseActor_ExecuteGameplayCueLocal Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.Parameters = std::move(Parameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBaseActor.NotifyTeamChanged
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionTeam                              NewTeamIdx                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionBaseActor::NotifyTeamChanged(EOrionTeam NewTeamIdx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseActor", "NotifyTeamChanged");

	Params::OrionBaseActor_NotifyTeamChanged Parms{};

	Parms.NewTeamIdx = NewTeamIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBaseActor.OnCustomHit
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FHitResult                       Hit                                                    (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// EProjectileCustomHitResponseType        ProjectileCustomHitResponseType_0                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Magnitude                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionBaseActor::OnCustomHit(const struct FHitResult& Hit, EProjectileCustomHitResponseType ProjectileCustomHitResponseType_0, float Magnitude)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseActor", "OnCustomHit");

	Params::OrionBaseActor_OnCustomHit Parms{};

	Parms.Hit = std::move(Hit);
	Parms.ProjectileCustomHitResponseType_0 = ProjectileCustomHitResponseType_0;
	Parms.Magnitude = Magnitude;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionBaseActor.OnRemovedTracked
// (Event, Public, BlueprintEvent)
// Parameters:
// class UOrionAbilitySystemComponent*     AbilityComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionBaseActor::OnRemovedTracked(class UOrionAbilitySystemComponent* AbilityComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseActor", "OnRemovedTracked");

	Params::OrionBaseActor_OnRemovedTracked Parms{};

	Parms.AbilityComponent = AbilityComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionBaseActor.OnRep_ReplicatedVisionData
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FOrionReplicatedVisionData       OldData                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AOrionBaseActor::OnRep_ReplicatedVisionData(const struct FOrionReplicatedVisionData& OldData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseActor", "OnRep_ReplicatedVisionData");

	Params::OrionBaseActor_OnRep_ReplicatedVisionData Parms{};

	Parms.OldData = std::move(OldData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBaseActor.OnRep_TeamNum
// (Native, Protected)
// Parameters:
// EOrionTeam                              OldTeamNum                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionBaseActor::OnRep_TeamNum(EOrionTeam OldTeamNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseActor", "OnRep_TeamNum");

	Params::OrionBaseActor_OnRep_TeamNum Parms{};

	Parms.OldTeamNum = OldTeamNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBaseActor.OnRep_VisibleToEnemy
// (Final, Native, Public)
// Parameters:
// struct FOrionReplicatedVisibleToEnemy   OldValue                                               (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AOrionBaseActor::OnRep_VisibleToEnemy(const struct FOrionReplicatedVisibleToEnemy& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseActor", "OnRep_VisibleToEnemy");

	Params::OrionBaseActor_OnRep_VisibleToEnemy Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBaseActor.OnSpawnAbilityCacheReset
// (Native, Event, Public, BlueprintEvent)

void AOrionBaseActor::OnSpawnAbilityCacheReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseActor", "OnSpawnAbilityCacheReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBaseActor.PlaySoundTeamAdjustedForSelf
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USoundBase*                       SoundToPlay                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Attached                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopWhenAttachedToDestroyed                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* AOrionBaseActor::PlaySoundTeamAdjustedForSelf(class USoundBase* SoundToPlay, bool Attached, bool bStopWhenAttachedToDestroyed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseActor", "PlaySoundTeamAdjustedForSelf");

	Params::OrionBaseActor_PlaySoundTeamAdjustedForSelf Parms{};

	Parms.SoundToPlay = SoundToPlay;
	Parms.Attached = Attached;
	Parms.bStopWhenAttachedToDestroyed = bStopWhenAttachedToDestroyed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionBaseActor.SetTargetingTagRequirements
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTagRequirements         InTargetingTagRequirements                             (Parm, NativeAccessSpecifierPublic)

void AOrionBaseActor::SetTargetingTagRequirements(const struct FGameplayTagRequirements& InTargetingTagRequirements)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseActor", "SetTargetingTagRequirements");

	Params::OrionBaseActor_SetTargetingTagRequirements Parms{};

	Parms.InTargetingTagRequirements = std::move(InTargetingTagRequirements);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBaseActor.SetupTeamColors
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bIsDead                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionBaseActor::SetupTeamColors(bool bIsDead)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseActor", "SetupTeamColors");

	Params::OrionBaseActor_SetupTeamColors Parms{};

	Parms.bIsDead = bIsDead;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBaseActor.SetVisionRules
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionVisionIndividualRules             NewType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionBaseActor::SetVisionRules(EOrionVisionIndividualRules NewType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseActor", "SetVisionRules");

	Params::OrionBaseActor_SetVisionRules Parms{};

	Parms.NewType = NewType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBaseActor.GetTeamNum
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// EOrionTeam                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOrionTeam AOrionBaseActor::GetTeamNum() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseActor", "GetTeamNum");

	Params::OrionBaseActor_GetTeamNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.AIScriptedBehavior.BehaviorFinished
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AOrionAIController*               AIController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIScriptedBehavior::BehaviorFinished(class AOrionAIController* AIController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIScriptedBehavior", "BehaviorFinished");

	Params::AIScriptedBehavior_BehaviorFinished Parms{};

	Parms.AIController = AIController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.AIScriptedBehavior.FinishBehavior
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AOrionAIController*               AIController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIScriptedBehavior::FinishBehavior(class AOrionAIController* AIController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIScriptedBehavior", "FinishBehavior");

	Params::AIScriptedBehavior_FinishBehavior Parms{};

	Parms.AIController = AIController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.AIScriptedBehavior.K2_StopAllMovementTasks
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AOrionAIController*               AIController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIScriptedBehavior::K2_StopAllMovementTasks(class AOrionAIController* AIController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIScriptedBehavior", "K2_StopAllMovementTasks");

	Params::AIScriptedBehavior_K2_StopAllMovementTasks Parms{};

	Parms.AIController = AIController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.AIScriptedBehavior.RunBehavior
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AOrionAIController*               AIController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAIScriptedBehavior::RunBehavior(class AOrionAIController* AIController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIScriptedBehavior", "RunBehavior");

	Params::AIScriptedBehavior_RunBehavior Parms{};

	Parms.AIController = AIController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.AIScriptedBehavior.K2_IsFinished
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAIScriptedBehavior::K2_IsFinished() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIScriptedBehavior", "K2_IsFinished");

	Params::AIScriptedBehavior_K2_IsFinished Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.AIWardPlacement.CapsuleTouched
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AAIWardPlacement::CapsuleTouched(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIWardPlacement", "CapsuleTouched");

	Params::AIWardPlacement_CapsuleTouched Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.AIWardPlacement.GetScriptedRoleForTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EOrionTeam                              Team                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELaneRoleSlot                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELaneRoleSlot AAIWardPlacement::GetScriptedRoleForTeam(EOrionTeam Team)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIWardPlacement", "GetScriptedRoleForTeam");

	Params::AIWardPlacement_GetScriptedRoleForTeam Parms{};

	Parms.Team = Team;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.FTS_ApplyGameplayEffects.SetStatusToSucceeded
// (Final, Native, Private)

void UFTS_ApplyGameplayEffects::SetStatusToSucceeded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FTS_ApplyGameplayEffects", "SetStatusToSucceeded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.FTS_ExecCommonCommands.SetStatusToSucceeded
// (Final, Native, Private)

void UFTS_ExecCommonCommands::SetStatusToSucceeded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FTS_ExecCommonCommands", "SetStatusToSucceeded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCraftingDevice.OnActiveActionCancelled
// (Event, Protected, BlueprintEvent)

void AOrionCraftingDevice::OnActiveActionCancelled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCraftingDevice", "OnActiveActionCancelled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionCraftingDevice.OnActiveActionSelected
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   NumCards                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCraftingDevice::OnActiveActionSelected(int32 NumCards)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCraftingDevice", "OnActiveActionSelected");

	Params::OrionCraftingDevice_OnActiveActionSelected Parms{};

	Parms.NumCards = NumCards;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionCraftingDevice.OnActiveCraftingActionChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// EOrionCraftingAction                    ActionType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCraftingDevice::OnActiveCraftingActionChanged(EOrionCraftingAction ActionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCraftingDevice", "OnActiveCraftingActionChanged");

	Params::OrionCraftingDevice_OnActiveCraftingActionChanged Parms{};

	Parms.ActionType = ActionType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionCraftingDevice.OnConstellationComplete
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<class UParticleSystemComponent*> ActiveEdgeBeams                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AOrionCraftingDevice::OnConstellationComplete(const TArray<class UParticleSystemComponent*>& ActiveEdgeBeams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCraftingDevice", "OnConstellationComplete");

	Params::OrionCraftingDevice_OnConstellationComplete Parms{};

	Parms.ActiveEdgeBeams = std::move(ActiveEdgeBeams);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionCraftingDevice.OnConstellationEdgeCreated
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UParticleSystemComponent*         EdgeBeamParticle                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOrionCraftingDeviceNode*         SourceNode                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOrionCraftingDeviceNode*         DestinationNode                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCraftingDevice::OnConstellationEdgeCreated(class UParticleSystemComponent* EdgeBeamParticle, class AOrionCraftingDeviceNode* SourceNode, class AOrionCraftingDeviceNode* DestinationNode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCraftingDevice", "OnConstellationEdgeCreated");

	Params::OrionCraftingDevice_OnConstellationEdgeCreated Parms{};

	Parms.EdgeBeamParticle = EdgeBeamParticle;
	Parms.SourceNode = SourceNode;
	Parms.DestinationNode = DestinationNode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionCraftingDevice.OnConstellationStarted
// (Event, Protected, BlueprintEvent)

void AOrionCraftingDevice::OnConstellationStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCraftingDevice", "OnConstellationStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionCraftingDevice.OnCurrentCardDataChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UOrionLegacyCardItemDefinition*   NewCardData                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCraftingDevice::OnCurrentCardDataChanged(class UOrionLegacyCardItemDefinition* NewCardData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCraftingDevice", "OnCurrentCardDataChanged");

	Params::OrionCraftingDevice_OnCurrentCardDataChanged Parms{};

	Parms.NewCardData = NewCardData;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionCraftingDevice.OnExecuteAction
// (Event, Protected, BlueprintEvent)

void AOrionCraftingDevice::OnExecuteAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCraftingDevice", "OnExecuteAction");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionCraftingDevice.OnResetToIdle
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bPostFanfare                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCraftingDevice::OnResetToIdle(bool bPostFanfare)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCraftingDevice", "OnResetToIdle");

	Params::OrionCraftingDevice_OnResetToIdle Parms{};

	Parms.bPostFanfare = bPostFanfare;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.ARHUD.OnAbilityStatusChanged
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// EOrionAbilityBinding                    BindingId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FOrionAbilityUIData              Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AARHUD::OnAbilityStatusChanged(EOrionAbilityBinding BindingId, const struct FOrionAbilityUIData& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ARHUD", "OnAbilityStatusChanged");

	Params::ARHUD_OnAbilityStatusChanged Parms{};

	Parms.BindingId = BindingId;
	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.ARHUD.OnEnergyChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   EnergyValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AARHUD::OnEnergyChanged(float EnergyValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ARHUD", "OnEnergyChanged");

	Params::ARHUD_OnEnergyChanged Parms{};

	Parms.EnergyValue = EnergyValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.ARHUD.OnHealthChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   HealthValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AARHUD::OnHealthChanged(float HealthValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ARHUD", "OnHealthChanged");

	Params::ARHUD_OnHealthChanged Parms{};

	Parms.HealthValue = HealthValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionPickup.CleanUpAppliedGameplayEffects
// (Final, Native, Protected)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPickup::CleanUpAppliedGameplayEffects(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPickup", "CleanUpAppliedGameplayEffects");

	Params::OrionPickup_CleanUpAppliedGameplayEffects Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPickup.FinishInterpolation
// (Final, Native, Public)

void AOrionPickup::FinishInterpolation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPickup", "FinishInterpolation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPickup.GetCurrentMaxLifeSpan
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionPickup::GetCurrentMaxLifeSpan()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPickup", "GetCurrentMaxLifeSpan");

	Params::OrionPickup_GetCurrentMaxLifeSpan Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPickup.GetInterpolationEndLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AOrionPickup::GetInterpolationEndLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPickup", "GetInterpolationEndLocation");

	Params::OrionPickup_GetInterpolationEndLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPickup.HandleHomingDeath
// (Native, Protected)
// Parameters:
// class AOrionChar*                       DeadChar                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPickup::HandleHomingDeath(class AOrionChar* DeadChar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPickup", "HandleHomingDeath");

	Params::OrionPickup_HandleHomingDeath Parms{};

	Parms.DeadChar = DeadChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPickup.HandleHomingEnterPhaseShift
// (Native, Protected)
// Parameters:
// class AOrionChar*                       PhaseShifedChar                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPickup::HandleHomingEnterPhaseShift(class AOrionChar* PhaseShifedChar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPickup", "HandleHomingEnterPhaseShift");

	Params::OrionPickup_HandleHomingEnterPhaseShift Parms{};

	Parms.PhaseShifedChar = PhaseShifedChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPickup.OnLockOnTagretTagAdded
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPickup::OnLockOnTagretTagAdded(const struct FGameplayTag& Tag, int32 NewCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPickup", "OnLockOnTagretTagAdded");

	Params::OrionPickup_OnLockOnTagretTagAdded Parms{};

	Parms.Tag = std::move(Tag);
	Parms.NewCount = NewCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionPickup.OnLockOnTagretTagRemoved
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPickup::OnLockOnTagretTagRemoved(const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPickup", "OnLockOnTagretTagRemoved");

	Params::OrionPickup_OnLockOnTagretTagRemoved Parms{};

	Parms.Tag = std::move(Tag);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionPickup.OnOverlapBegin
// (Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AOrionPickup::OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPickup", "OnOverlapBegin");

	Params::OrionPickup_OnOverlapBegin Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPickup.OnPickedUp
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AOrionChar*                       Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPickup::OnPickedUp(class AOrionChar* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPickup", "OnPickedUp");

	Params::OrionPickup_OnPickedUp Parms{};

	Parms.Pawn = Pawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionPickup.OnPickupActivated
// (Event, Protected, BlueprintEvent)

void AOrionPickup::OnPickupActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPickup", "OnPickupActivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionPickup.OnPickupDeactivated
// (Event, Protected, BlueprintEvent)

void AOrionPickup::OnPickupDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPickup", "OnPickupDeactivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionPickup.OnRep_InterpolationFinishedGameTime
// (Final, Native, Protected)

void AOrionPickup::OnRep_InterpolationFinishedGameTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPickup", "OnRep_InterpolationFinishedGameTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPickup.SetLockOnActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InNewLockOnActor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPickup::SetLockOnActor(class AActor* InNewLockOnActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPickup", "SetLockOnActor");

	Params::OrionPickup_SetLockOnActor Parms{};

	Parms.InNewLockOnActor = InNewLockOnActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPickup.TryToApplyGameplayEffectSpecToTarget
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FGameplayEffectSpecHandle        EffectSpecHandle                                       (ConstParm, Parm, NativeAccessSpecifierPublic)
// class AActor*                           Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPickup::TryToApplyGameplayEffectSpecToTarget(const struct FGameplayEffectSpecHandle& EffectSpecHandle, class AActor* Source, class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPickup", "TryToApplyGameplayEffectSpecToTarget");

	Params::OrionPickup_TryToApplyGameplayEffectSpecToTarget Parms{};

	Parms.EffectSpecHandle = std::move(EffectSpecHandle);
	Parms.Source = Source;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPickup.UpdateInterpolation
// (Final, Native, Public)
// Parameters:
// float                                   InElapsedTime                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPickup::UpdateInterpolation(float InElapsedTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPickup", "UpdateInterpolation");

	Params::OrionPickup_UpdateInterpolation Parms{};

	Parms.InElapsedTime = InElapsedTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPickup.GetMaxLifeSpan
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionPickup::GetMaxLifeSpan() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPickup", "GetMaxLifeSpan");

	Params::OrionPickup_GetMaxLifeSpan Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCoin.HandleHomingDeath
// (Native, Public)
// Parameters:
// class AOrionChar*                       DeadChar                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCoin::HandleHomingDeath(class AOrionChar* DeadChar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCoin", "HandleHomingDeath");

	Params::OrionCoin_HandleHomingDeath Parms{};

	Parms.DeadChar = DeadChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCoin.HandleHomingEnterPhaseShift
// (Native, Public)
// Parameters:
// class AOrionChar*                       PhaseShifedChar                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCoin::HandleHomingEnterPhaseShift(class AOrionChar* PhaseShifedChar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCoin", "HandleHomingEnterPhaseShift");

	Params::OrionCoin_HandleHomingEnterPhaseShift Parms{};

	Parms.PhaseShifedChar = PhaseShifedChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCoin.OnCoinVisualScalar
// (Event, Public, BlueprintEvent)
// Parameters:
// EOrionCoinSize                          Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstanceDynamic*         CoinMID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCoin::OnCoinVisualScalar(EOrionCoinSize Size, class UMaterialInstanceDynamic* CoinMID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCoin", "OnCoinVisualScalar");

	Params::OrionCoin_OnCoinVisualScalar Parms{};

	Parms.Size = Size;
	Parms.CoinMID = CoinMID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.AutomationPerfMontiorManager.GetPerfMonitorInstance
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAutomationPerfMontiorManager*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAutomationPerfMontiorManager* UAutomationPerfMontiorManager::GetPerfMonitorInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AutomationPerfMontiorManager", "GetPerfMonitorInstance");

	Params::AutomationPerfMontiorManager_GetPerfMonitorInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.AutomationPerfMontiorManager.CleanUpPerfFileHandles
// (Final, Native, Public, BlueprintCallable)

void UAutomationPerfMontiorManager::CleanUpPerfFileHandles()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutomationPerfMontiorManager", "CleanUpPerfFileHandles");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.AutomationPerfMontiorManager.FinalizeFTestPerfReport
// (Final, Native, Public, BlueprintCallable)

void UAutomationPerfMontiorManager::FinalizeFTestPerfReport()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutomationPerfMontiorManager", "FinalizeFTestPerfReport");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.AutomationPerfMontiorManager.IsRecordingFTestPerf
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAutomationPerfMontiorManager::IsRecordingFTestPerf()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutomationPerfMontiorManager", "IsRecordingFTestPerf");

	Params::AutomationPerfMontiorManager_IsRecordingFTestPerf Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.AutomationPerfMontiorManager.StartRecordingFTestPerf
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Filename                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           TestName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   StatsToRecord                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAutomationPerfMontiorManager::StartRecordingFTestPerf(const class FString& Filename, const class FString& TestName, const TArray<class FString>& StatsToRecord)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutomationPerfMontiorManager", "StartRecordingFTestPerf");

	Params::AutomationPerfMontiorManager_StartRecordingFTestPerf Parms{};

	Parms.Filename = std::move(Filename);
	Parms.TestName = std::move(TestName);
	Parms.StatsToRecord = std::move(StatsToRecord);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.AutomationPerfMontiorManager.StopRecordingFTestPerf
// (Final, Native, Public, BlueprintCallable)

void UAutomationPerfMontiorManager::StopRecordingFTestPerf()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutomationPerfMontiorManager", "StopRecordingFTestPerf");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameplayCueNotify_Actor.OnEnterShadowplane
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           MyTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bVisibleToMe                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionGameplayCueNotify_Actor::OnEnterShadowplane(class AActor* MyTarget, bool bVisibleToMe)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayCueNotify_Actor", "OnEnterShadowplane");

	Params::OrionGameplayCueNotify_Actor_OnEnterShadowplane Parms{};

	Parms.MyTarget = MyTarget;
	Parms.bVisibleToMe = bVisibleToMe;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameplayCueNotify_Actor.OnExitShadowplane
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           MyTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionGameplayCueNotify_Actor::OnExitShadowplane(class AActor* MyTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayCueNotify_Actor", "OnExitShadowplane");

	Params::OrionGameplayCueNotify_Actor_OnExitShadowplane Parms{};

	Parms.MyTarget = MyTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameplayCueNotify_Actor.SetShadowplaneVisibility
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           MyTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELocalVisiblityState                    ShadowPlaneVisibility                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameplayCueNotify_Actor::SetShadowplaneVisibility(class AActor* MyTarget, ELocalVisiblityState ShadowPlaneVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayCueNotify_Actor", "SetShadowplaneVisibility");

	Params::OrionGameplayCueNotify_Actor_SetShadowplaneVisibility Parms{};

	Parms.MyTarget = MyTarget;
	Parms.ShadowPlaneVisibility = ShadowPlaneVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameplayCueNotify_Actor.SpawnBurstGameplayCueNiagaraParticleInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayCueNiagaraParticleInfo  ParticleEffect                                         (Parm, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Parameters                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class USceneComponent*                  OptionalAttachToComponent                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UNiagaraComponent*>        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UNiagaraComponent*> AOrionGameplayCueNotify_Actor::SpawnBurstGameplayCueNiagaraParticleInfo(const struct FGameplayCueNiagaraParticleInfo& ParticleEffect, class AActor* TargetActor, const struct FGameplayCueParameters& Parameters, class USceneComponent* OptionalAttachToComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayCueNotify_Actor", "SpawnBurstGameplayCueNiagaraParticleInfo");

	Params::OrionGameplayCueNotify_Actor_SpawnBurstGameplayCueNiagaraParticleInfo Parms{};

	Parms.ParticleEffect = std::move(ParticleEffect);
	Parms.TargetActor = TargetActor;
	Parms.Parameters = std::move(Parameters);
	Parms.OptionalAttachToComponent = OptionalAttachToComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameplayCueNotify_Actor.SpawnBurstGameplayCueParticleInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayCueParticleInfo         ParticleEffect                                         (Parm, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Parameters                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class USceneComponent*                  OptionalAttachToComponent                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UParticleSystemComponent*> ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UParticleSystemComponent*> AOrionGameplayCueNotify_Actor::SpawnBurstGameplayCueParticleInfo(const struct FGameplayCueParticleInfo& ParticleEffect, class AActor* TargetActor, const struct FGameplayCueParameters& Parameters, class USceneComponent* OptionalAttachToComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayCueNotify_Actor", "SpawnBurstGameplayCueParticleInfo");

	Params::OrionGameplayCueNotify_Actor_SpawnBurstGameplayCueParticleInfo Parms{};

	Parms.ParticleEffect = std::move(ParticleEffect);
	Parms.TargetActor = TargetActor;
	Parms.Parameters = std::move(Parameters);
	Parms.OptionalAttachToComponent = OptionalAttachToComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameplayCueNotify_Actor.UpdateGameplayCueVisuals_Hidden
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           MyTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsHidden                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameplayCueNotify_Actor::UpdateGameplayCueVisuals_Hidden(class AActor* MyTarget, const bool bIsHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayCueNotify_Actor", "UpdateGameplayCueVisuals_Hidden");

	Params::OrionGameplayCueNotify_Actor_UpdateGameplayCueVisuals_Hidden Parms{};

	Parms.MyTarget = MyTarget;
	Parms.bIsHidden = bIsHidden;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionGameplayCueNotify_Actor.UpdateGameplayCueVisuals_Shadowplane
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           MyTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInShadowplane                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameplayCueNotify_Actor::UpdateGameplayCueVisuals_Shadowplane(class AActor* MyTarget, const bool bInShadowplane)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayCueNotify_Actor", "UpdateGameplayCueVisuals_Shadowplane");

	Params::OrionGameplayCueNotify_Actor_UpdateGameplayCueVisuals_Shadowplane Parms{};

	Parms.MyTarget = MyTarget;
	Parms.bInShadowplane = bInShadowplane;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.BotObjective_WholeLane.AttackTower
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UBotPlaybook*                     Playbook                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAITowerClassification                  Tower                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAIGenericLocation                      Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBotObjective_WholeLane::AttackTower(class UBotPlaybook* Playbook, EAITowerClassification Tower, EAIGenericLocation Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BotObjective_WholeLane", "AttackTower");

	Params::BotObjective_WholeLane_AttackTower Parms{};

	Parms.Playbook = Playbook;
	Parms.Tower = Tower;
	Parms.Location = Location;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.BotObjective_WholeLane.DefendTower
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UBotPlaybook*                     Playbook                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAITowerClassification                  Tower                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAIGenericLocation                      Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBotObjective_WholeLane::DefendTower(class UBotPlaybook* Playbook, EAITowerClassification Tower, EAIGenericLocation Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BotObjective_WholeLane", "DefendTower");

	Params::BotObjective_WholeLane_DefendTower Parms{};

	Parms.Playbook = Playbook;
	Parms.Tower = Tower;
	Parms.Location = Location;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.BotObjective_WholeLane.PushLane
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UBotPlaybook*                     Playbook                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAIGenericLocation                      Lane                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ToLaneProgress                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBotObjective_WholeLane::PushLane(class UBotPlaybook* Playbook, EAIGenericLocation Lane, float ToLaneProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BotObjective_WholeLane", "PushLane");

	Params::BotObjective_WholeLane_PushLane Parms{};

	Parms.Playbook = Playbook;
	Parms.Lane = Lane;
	Parms.ToLaneProgress = ToLaneProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.BotObjective_WholeLane.TowerObjective
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UBotPlaybook*                     Playbook                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAITowerClassification                  Tower                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAIOwnership                            Ownership                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAIGenericLocation                      Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBotObjective_WholeLane::TowerObjective(class UBotPlaybook* Playbook, EAITowerClassification Tower, EAIOwnership Ownership, EAIGenericLocation Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BotObjective_WholeLane", "TowerObjective");

	Params::BotObjective_WholeLane_TowerObjective Parms{};

	Parms.Playbook = Playbook;
	Parms.Tower = Tower;
	Parms.Ownership = Ownership;
	Parms.Location = Location;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.BotObjective_AttackJungleCamp.ClearCamp
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UBotPlaybook*                     Playbook                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAICampType                             Camp                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAIGenericLocation                      Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAIOwnership                            Ownership                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   MinCreeps                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCanBeAbandonedForSameType                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFinishClearing                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBotObjective_AttackJungleCamp::ClearCamp(class UBotPlaybook* Playbook, EAICampType Camp, EAIGenericLocation Location, EAIOwnership Ownership, uint8 MinCreeps, bool bCanBeAbandonedForSameType, float MaxDistance, bool bFinishClearing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BotObjective_AttackJungleCamp", "ClearCamp");

	Params::BotObjective_AttackJungleCamp_ClearCamp Parms{};

	Parms.Playbook = Playbook;
	Parms.Camp = Camp;
	Parms.Location = Location;
	Parms.Ownership = Ownership;
	Parms.MinCreeps = MinCreeps;
	Parms.bCanBeAbandonedForSameType = bCanBeAbandonedForSameType;
	Parms.MaxDistance = MaxDistance;
	Parms.bFinishClearing = bFinishClearing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.BotObjective_AttackJungleCamp.GroupAttackCamp
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UBotPlaybook*                     Playbook                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAICampType                             Camp                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinAgents                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFinishClearing                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBotObjective_AttackJungleCamp::GroupAttackCamp(class UBotPlaybook* Playbook, EAICampType Camp, int32 MinAgents, bool bFinishClearing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BotObjective_AttackJungleCamp", "GroupAttackCamp");

	Params::BotObjective_AttackJungleCamp_GroupAttackCamp Parms{};

	Parms.Playbook = Playbook;
	Parms.Camp = Camp;
	Parms.MinAgents = MinAgents;
	Parms.bFinishClearing = bFinishClearing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.BotObjective_AttackJungleCamp.OnCampFinishedSpawning
// (Final, Native, Protected)
// Parameters:
// class AOrionCharAISpawner*              AISpawner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBotObjective_AttackJungleCamp::OnCampFinishedSpawning(class AOrionCharAISpawner* AISpawner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BotObjective_AttackJungleCamp", "OnCampFinishedSpawning");

	Params::BotObjective_AttackJungleCamp_OnCampFinishedSpawning Parms{};

	Parms.AISpawner = AISpawner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.BotObjective_AttackJungleCamp.OnCampKilled
// (Final, Native, Protected)
// Parameters:
// class AOrionCharAISpawner*              AISpawner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      Killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBotObjective_AttackJungleCamp::OnCampKilled(class AOrionCharAISpawner* AISpawner, class AController* Killer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BotObjective_AttackJungleCamp", "OnCampKilled");

	Params::BotObjective_AttackJungleCamp_OnCampKilled Parms{};

	Parms.AISpawner = AISpawner;
	Parms.Killer = Killer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.BotObjective_PlaceWard.PlaceWard
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UBotPlaybook*                     Playbook                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAIMapSide                              MapSide                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAIWardLocation                         Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBotObjective_PlaceWard::PlaceWard(class UBotPlaybook* Playbook, EAIMapSide MapSide, EAIWardLocation Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BotObjective_PlaceWard", "PlaceWard");

	Params::BotObjective_PlaceWard_PlaceWard Parms{};

	Parms.Playbook = Playbook;
	Parms.MapSide = MapSide;
	Parms.Location = Location;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameplayCueNotify_Burst_Latent.K2_OnExecute
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class AActor*                           MyTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Parameters                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UParticleSystemComponent*         BurstParticleSystems                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UParticleSystemComponent*> AdditionalParticleSystems                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UNiagaraComponent*                BurstNiagaraParticleSystems                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UNiagaraComponent*>        AdditionalNiagaraParticleSystems                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AOrionGameplayCueNotify_Burst_Latent::K2_OnExecute(class AActor* MyTarget, const struct FGameplayCueParameters& Parameters, class UParticleSystemComponent* BurstParticleSystems, const TArray<class UParticleSystemComponent*>& AdditionalParticleSystems, class UNiagaraComponent* BurstNiagaraParticleSystems, const TArray<class UNiagaraComponent*>& AdditionalNiagaraParticleSystems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayCueNotify_Burst_Latent", "K2_OnExecute");

	Params::OrionGameplayCueNotify_Burst_Latent_K2_OnExecute Parms{};

	Parms.MyTarget = MyTarget;
	Parms.Parameters = std::move(Parameters);
	Parms.BurstParticleSystems = BurstParticleSystems;
	Parms.AdditionalParticleSystems = std::move(AdditionalParticleSystems);
	Parms.BurstNiagaraParticleSystems = BurstNiagaraParticleSystems;
	Parms.AdditionalNiagaraParticleSystems = std::move(AdditionalNiagaraParticleSystems);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.BotObjective_Patrol.Patrol
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UBotPlaybook*                     Playbook                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBotObjective_Patrol::Patrol(class UBotPlaybook* Playbook)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BotObjective_Patrol", "Patrol");

	Params::BotObjective_Patrol_Patrol Parms{};

	Parms.Playbook = Playbook;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.BotObjective_GroupPushLane.GroupPushLane
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UBotPlaybook*                     Playbook                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAIGenericLocation                      Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ToLaneProgress                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinAgents                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBotObjective_GroupPushLane::GroupPushLane(class UBotPlaybook* Playbook, EAIGenericLocation Location, float ToLaneProgress, int32 MinAgents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BotObjective_GroupPushLane", "GroupPushLane");

	Params::BotObjective_GroupPushLane_GroupPushLane Parms{};

	Parms.Playbook = Playbook;
	Parms.Location = Location;
	Parms.ToLaneProgress = ToLaneProgress;
	Parms.MinAgents = MinAgents;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.BotObjective_Gank.Gank
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UBotPlaybook*                     Playbook                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBotObjective_Gank::Gank(class UBotPlaybook* Playbook, float MaxDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BotObjective_Gank", "Gank");

	Params::BotObjective_Gank_Gank Parms{};

	Parms.Playbook = Playbook;
	Parms.MaxDistance = MaxDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDamageableActor.CustomMatch_RemoveOnDeath
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FActiveGameplayEffect            Effect                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionDamageableActor::CustomMatch_RemoveOnDeath(const struct FActiveGameplayEffect& Effect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableActor", "CustomMatch_RemoveOnDeath");

	Params::OrionDamageableActor_CustomMatch_RemoveOnDeath Parms{};

	Parms.Effect = std::move(Effect);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionDamageableActor.GetHighlightableMeshes
// (Event, Public, BlueprintEvent)
// Parameters:
// TArray<class UMeshComponent*>           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UMeshComponent*> AOrionDamageableActor::GetHighlightableMeshes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableActor", "GetHighlightableMeshes");

	Params::OrionDamageableActor_GetHighlightableMeshes Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function OrionGame.OrionDamageableActor.K2_AddGameplayCue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     GameplayCueTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionDamageableActor::K2_AddGameplayCue(const struct FGameplayTag& GameplayCueTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableActor", "K2_AddGameplayCue");

	Params::OrionDamageableActor_K2_AddGameplayCue Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDamageableActor.K2_ExecuteGameplayCue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     GameplayCueTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Parameters                                             (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AOrionDamageableActor::K2_ExecuteGameplayCue(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Parameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableActor", "K2_ExecuteGameplayCue");

	Params::OrionDamageableActor_K2_ExecuteGameplayCue Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.Parameters = std::move(Parameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDamageableActor.K2_ExecuteGameplayCueOnTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AController*                      Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     GameplayCueTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Parameters                                             (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AOrionDamageableActor::K2_ExecuteGameplayCueOnTarget(class AController* Target, const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Parameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableActor", "K2_ExecuteGameplayCueOnTarget");

	Params::OrionDamageableActor_K2_ExecuteGameplayCueOnTarget Parms{};

	Parms.Target = Target;
	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.Parameters = std::move(Parameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDamageableActor.K2_RemoveGameplayCue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     GameplayCueTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionDamageableActor::K2_RemoveGameplayCue(const struct FGameplayTag& GameplayCueTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableActor", "K2_RemoveGameplayCue");

	Params::OrionDamageableActor_K2_RemoveGameplayCue Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDamageableActor.OnDamageTaken
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageInstigator                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionDamageableActor::OnDamageTaken(float Damage, class AActor* DamageInstigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableActor", "OnDamageTaken");

	Params::OrionDamageableActor_OnDamageTaken Parms{};

	Parms.Damage = Damage;
	Parms.DamageInstigator = DamageInstigator;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionDamageableActor.OnDeath
// (Native, Event, Protected, BlueprintEvent)

void AOrionDamageableActor::OnDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableActor", "OnDeath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDamageableActor.OnHealthReceived
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   HealthReceived                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           HealthReceivedInstigator                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionDamageableActor::OnHealthReceived(float HealthReceived, class AActor* HealthReceivedInstigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableActor", "OnHealthReceived");

	Params::OrionDamageableActor_OnHealthReceived Parms{};

	Parms.HealthReceived = HealthReceived;
	Parms.HealthReceivedInstigator = HealthReceivedInstigator;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionDamageableActor.OnRep_Dying
// (Native, Protected)

void AOrionDamageableActor::OnRep_Dying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableActor", "OnRep_Dying");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDamageableActor.OnShieldDamageTaken
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageInstigator                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionDamageableActor::OnShieldDamageTaken(float Damage, class AActor* DamageInstigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableActor", "OnShieldDamageTaken");

	Params::OrionDamageableActor_OnShieldDamageTaken Parms{};

	Parms.Damage = Damage;
	Parms.DamageInstigator = DamageInstigator;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionDamageableActor.OnShieldReceived
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   ShieldReceived                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ShieldReceivedInstigator                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionDamageableActor::OnShieldReceived(float ShieldReceived, class AActor* ShieldReceivedInstigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableActor", "OnShieldReceived");

	Params::OrionDamageableActor_OnShieldReceived Parms{};

	Parms.ShieldReceived = ShieldReceived;
	Parms.ShieldReceivedInstigator = ShieldReceivedInstigator;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionDamageableActor.SetVisionRadius
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionDamageableActor::SetVisionRadius(float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableActor", "SetVisionRadius");

	Params::OrionDamageableActor_SetVisionRadius Parms{};

	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDamageableActor.GetHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionDamageableActor::GetHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableActor", "GetHealth");

	Params::OrionDamageableActor_GetHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionDamageableActor.GetHealthPercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionDamageableActor::GetHealthPercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableActor", "GetHealthPercent");

	Params::OrionDamageableActor_GetHealthPercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionDamageableActor.GetKiller
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AController*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AController* AOrionDamageableActor::GetKiller() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableActor", "GetKiller");

	Params::OrionDamageableActor_GetKiller Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionDamageableActor.GetMaxHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionDamageableActor::GetMaxHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableActor", "GetMaxHealth");

	Params::OrionDamageableActor_GetMaxHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionDamageableActor.GetMaxShield
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionDamageableActor::GetMaxShield() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableActor", "GetMaxShield");

	Params::OrionDamageableActor_GetMaxShield Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionDamageableActor.GetShield
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionDamageableActor::GetShield() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableActor", "GetShield");

	Params::OrionDamageableActor_GetShield Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionDamageableActor.GetShieldPercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionDamageableActor::GetShieldPercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableActor", "GetShieldPercent");

	Params::OrionDamageableActor_GetShieldPercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionDamageableActor.MakeGameplayCueParameters
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayCueParameters           ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FGameplayCueParameters AOrionDamageableActor::MakeGameplayCueParameters() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableActor", "MakeGameplayCueParameters");

	Params::OrionDamageableActor_MakeGameplayCueParameters Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionDamageableObjective_Base.ApplyBackDoorProtection
// (Final, Native, Protected)

void AOrionDamageableObjective_Base::ApplyBackDoorProtection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjective_Base", "ApplyBackDoorProtection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDamageableObjective_Base.CanTargetActor
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInIgnoreHeight                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionDamageableObjective_Base::CanTargetActor(class AActor* InTarget, bool bInIgnoreHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjective_Base", "CanTargetActor");

	Params::OrionDamageableObjective_Base_CanTargetActor Parms{};

	Parms.InTarget = InTarget;
	Parms.bInIgnoreHeight = bInIgnoreHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionDamageableObjective_Base.GetAllValidTargets
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   OutTargetArray                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bInIgnoreHeight                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionDamageableObjective_Base::GetAllValidTargets(TArray<class AActor*>* OutTargetArray, bool bInIgnoreHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjective_Base", "GetAllValidTargets");

	Params::OrionDamageableObjective_Base_GetAllValidTargets Parms{};

	Parms.bInIgnoreHeight = bInIgnoreHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTargetArray != nullptr)
		*OutTargetArray = std::move(Parms.OutTargetArray);
}


// Function OrionGame.OrionDamageableObjective_Base.GetBaseAttackingMesh
// (Event, Public, BlueprintEvent)
// Parameters:
// class UMeshComponent*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMeshComponent* AOrionDamageableObjective_Base::GetBaseAttackingMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjective_Base", "GetBaseAttackingMesh");

	Params::OrionDamageableObjective_Base_GetBaseAttackingMesh Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function OrionGame.OrionDamageableObjective_Base.GetBaseAttackingSocketName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName AOrionDamageableObjective_Base::GetBaseAttackingSocketName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjective_Base", "GetBaseAttackingSocketName");

	Params::OrionDamageableObjective_Base_GetBaseAttackingSocketName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionDamageableObjective_Base.GetNumberOfTargetsToAttack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AOrionDamageableObjective_Base::GetNumberOfTargetsToAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjective_Base", "GetNumberOfTargetsToAttack");

	Params::OrionDamageableObjective_Base_GetNumberOfTargetsToAttack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionDamageableObjective_Base.GetTargetsToAttack
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   OutTargetArray                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void AOrionDamageableObjective_Base::GetTargetsToAttack(TArray<class AActor*>* OutTargetArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjective_Base", "GetTargetsToAttack");

	Params::OrionDamageableObjective_Base_GetTargetsToAttack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTargetArray != nullptr)
		*OutTargetArray = std::move(Parms.OutTargetArray);
}


// Function OrionGame.OrionDamageableObjective_Base.HandleCallForHelp
// (Final, Native, Public, HasOutParams)
// Parameters:
// class AActor*                           DamagedActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AttackingActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectSpec              EffectSpec                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AOrionDamageableObjective_Base::HandleCallForHelp(class AActor* DamagedActor, class AActor* AttackingActor, const struct FGameplayEffectSpec& EffectSpec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjective_Base", "HandleCallForHelp");

	Params::OrionDamageableObjective_Base_HandleCallForHelp Parms{};

	Parms.DamagedActor = DamagedActor;
	Parms.AttackingActor = AttackingActor;
	Parms.EffectSpec = std::move(EffectSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDamageableObjective_Base.HandleMatchEnded
// (Final, Native, Public)

void AOrionDamageableObjective_Base::HandleMatchEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjective_Base", "HandleMatchEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDamageableObjective_Base.HandleMatchStarted
// (Final, Native, Public)

void AOrionDamageableObjective_Base::HandleMatchStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjective_Base", "HandleMatchStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDamageableObjective_Base.HandleTargetActorTeamChanged
// (Final, Native, Private)
// Parameters:
// class AOrionChar*                       TeamChangeChar                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionTeam                              NewTeamNum                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionDamageableObjective_Base::HandleTargetActorTeamChanged(class AOrionChar* TeamChangeChar, EOrionTeam NewTeamNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjective_Base", "HandleTargetActorTeamChanged");

	Params::OrionDamageableObjective_Base_HandleTargetActorTeamChanged Parms{};

	Parms.TeamChangeChar = TeamChangeChar;
	Parms.NewTeamNum = NewTeamNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDamageableObjective_Base.LostCurrentTarget
// (Event, Public, BlueprintEvent)

void AOrionDamageableObjective_Base::LostCurrentTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjective_Base", "LostCurrentTarget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionDamageableObjective_Base.ObjectiveStartUp
// (Event, Protected, BlueprintEvent)

void AOrionDamageableObjective_Base::ObjectiveStartUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjective_Base", "ObjectiveStartUp");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionDamageableObjective_Base.OnBackdoorProtectionChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bOn                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionDamageableObjective_Base::OnBackdoorProtectionChanged(bool bOn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjective_Base", "OnBackdoorProtectionChanged");

	Params::OrionDamageableObjective_Base_OnBackdoorProtectionChanged Parms{};

	Parms.bOn = bOn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionDamageableObjective_Base.OnRep_Dying
// (Native, Protected)

void AOrionDamageableObjective_Base::OnRep_Dying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjective_Base", "OnRep_Dying");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDamageableObjective_Base.OnRep_MatchHasStarted
// (Native, Protected)

void AOrionDamageableObjective_Base::OnRep_MatchHasStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjective_Base", "OnRep_MatchHasStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDamageableObjective_Base.OnRep_ObjectiveVulnerable
// (Native, Protected)

void AOrionDamageableObjective_Base::OnRep_ObjectiveVulnerable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjective_Base", "OnRep_ObjectiveVulnerable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDamageableObjective_Base.OnRep_TargetingVolume
// (Native, Protected)
// Parameters:
// class AVolume*                          OldTargetingVolume                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionDamageableObjective_Base::OnRep_TargetingVolume(class AVolume* OldTargetingVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjective_Base", "OnRep_TargetingVolume");

	Params::OrionDamageableObjective_Base_OnRep_TargetingVolume Parms{};

	Parms.OldTargetingVolume = OldTargetingVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDamageableObjective_Base.OnSelfRevive
// (Event, Protected, BlueprintEvent)

void AOrionDamageableObjective_Base::OnSelfRevive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjective_Base", "OnSelfRevive");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionDamageableObjective_Base.ReviveSelf
// (Final, Native, Public, BlueprintCallable)

void AOrionDamageableObjective_Base::ReviveSelf()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjective_Base", "ReviveSelf");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDamageableObjective_Base.SetCurrentTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InNewTarget                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionDamageableObjective_Base::SetCurrentTarget(class AActor* InNewTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjective_Base", "SetCurrentTarget");

	Params::OrionDamageableObjective_Base_SetCurrentTarget Parms{};

	Parms.InNewTarget = InNewTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDamageableObjective_Base.SetTargetingBeamComp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UParticleSystemComponent*         InTargetingBeam                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionDamageableObjective_Base::SetTargetingBeamComp(class UParticleSystemComponent* InTargetingBeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjective_Base", "SetTargetingBeamComp");

	Params::OrionDamageableObjective_Base_SetTargetingBeamComp Parms{};

	Parms.InTargetingBeam = InTargetingBeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDamageableObjective_Base.TargetAcquired
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           NewTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionDamageableObjective_Base::TargetAcquired(class AActor* NewTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjective_Base", "TargetAcquired");

	Params::OrionDamageableObjective_Base_TargetAcquired Parms{};

	Parms.NewTarget = NewTarget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionDamageableObjective_Base.TargetEndOverlap
// (Final, Native, Public)
// Parameters:
// class AActor*                           SelfActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionDamageableObjective_Base::TargetEndOverlap(class AActor* SelfActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjective_Base", "TargetEndOverlap");

	Params::OrionDamageableObjective_Base_TargetEndOverlap Parms{};

	Parms.SelfActor = SelfActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDamageableObjective_Base.TargetStartOverlap
// (Final, Native, Public)
// Parameters:
// class AActor*                           SelfActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionDamageableObjective_Base::TargetStartOverlap(class AActor* SelfActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjective_Base", "TargetStartOverlap");

	Params::OrionDamageableObjective_Base_TargetStartOverlap Parms{};

	Parms.SelfActor = SelfActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDamageableObjective_Base.UpdateTargeting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInIgnoreHeight                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionDamageableObjective_Base::UpdateTargeting(bool bInIgnoreHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjective_Base", "UpdateTargeting");

	Params::OrionDamageableObjective_Base_UpdateTargeting Parms{};

	Parms.bInIgnoreHeight = bInIgnoreHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDamageableObjective_Base.GetAttackHeight
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionDamageableObjective_Base::GetAttackHeight() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjective_Base", "GetAttackHeight");

	Params::OrionDamageableObjective_Base_GetAttackHeight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionDamageableObjective_Base.GetAttackRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionDamageableObjective_Base::GetAttackRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjective_Base", "GetAttackRadius");

	Params::OrionDamageableObjective_Base_GetAttackRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionDamageableObjective_Base.GetAttackSpeed
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionDamageableObjective_Base::GetAttackSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjective_Base", "GetAttackSpeed");

	Params::OrionDamageableObjective_Base_GetAttackSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionDamageableObjective_Base.GetCollisionCapsuleComponent
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class UCapsuleComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCapsuleComponent* AOrionDamageableObjective_Base::GetCollisionCapsuleComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjective_Base", "GetCollisionCapsuleComponent");

	Params::OrionDamageableObjective_Base_GetCollisionCapsuleComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function OrionGame.OrionDamageableObjective_Base.GetCurrentTarget
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AOrionDamageableObjective_Base::GetCurrentTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjective_Base", "GetCurrentTarget");

	Params::OrionDamageableObjective_Base_GetCurrentTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionDamageableObjective_Base.GetDisplayName
// (RequiredAPI, Event, Public, BlueprintEvent, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText AOrionDamageableObjective_Base::GetDisplayName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjective_Base", "GetDisplayName");

	Params::OrionDamageableObjective_Base_GetDisplayName Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function OrionGame.OrionDamageableObjective_Base.GetEffectiveAttackRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionDamageableObjective_Base::GetEffectiveAttackRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjective_Base", "GetEffectiveAttackRange");

	Params::OrionDamageableObjective_Base_GetEffectiveAttackRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionDamageableObjective_Base.GetIcon
// (RequiredAPI, Event, Public, BlueprintEvent, Const)
// Parameters:
// TSoftObjectPtr<class UObject>           ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UObject> AOrionDamageableObjective_Base::GetIcon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjective_Base", "GetIcon");

	Params::OrionDamageableObjective_Base_GetIcon Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function OrionGame.OrionDamageableObjective_Base.GetNumberOfTargetedMinions
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AOrionDamageableObjective_Base::GetNumberOfTargetedMinions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjective_Base", "GetNumberOfTargetedMinions");

	Params::OrionDamageableObjective_Base_GetNumberOfTargetedMinions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionDamageableObjective_Base.GetReviveSelfTimer
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionDamageableObjective_Base::GetReviveSelfTimer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjective_Base", "GetReviveSelfTimer");

	Params::OrionDamageableObjective_Base_GetReviveSelfTimer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionDamageableObjective_Base.GetTargetingTime
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionDamageableObjective_Base::GetTargetingTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjective_Base", "GetTargetingTime");

	Params::OrionDamageableObjective_Base_GetTargetingTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionDamageableObjectiveTurret.SetSkeletalMesh
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           InMesh                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionDamageableObjectiveTurret::SetSkeletalMesh(class USkeletalMeshComponent* InMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageableObjectiveTurret", "SetSkeletalMesh");

	Params::OrionDamageableObjectiveTurret_SetSkeletalMesh Parms{};

	Parms.InMesh = InMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.BotObjective_Recall.CardRecall
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UBotPlaybook*                     Playbook                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBotObjective_Recall::CardRecall(class UBotPlaybook* Playbook)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BotObjective_Recall", "CardRecall");

	Params::BotObjective_Recall_CardRecall Parms{};

	Parms.Playbook = Playbook;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.BotObjective_Recall.CXPRecall
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UBotPlaybook*                     Playbook                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   MinCardPointsToRecall                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBotObjective_Recall::CXPRecall(class UBotPlaybook* Playbook, uint8 MinCardPointsToRecall)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BotObjective_Recall", "CXPRecall");

	Params::BotObjective_Recall_CXPRecall Parms{};

	Parms.Playbook = Playbook;
	Parms.MinCardPointsToRecall = MinCardPointsToRecall;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.BotObjective_Recall.GoldRecall
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UBotPlaybook*                     Playbook                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinGoldToRecall                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBotObjective_Recall::GoldRecall(class UBotPlaybook* Playbook, float MinGoldToRecall)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BotObjective_Recall", "GoldRecall");

	Params::BotObjective_Recall_GoldRecall Parms{};

	Parms.Playbook = Playbook;
	Parms.MinGoldToRecall = MinGoldToRecall;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.BotObjective_Bodyguard.BodyGuard
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UBotPlaybook*                     Playbook                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELaneRoleSlot                           Role                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TetherDistance                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBotObjective_Bodyguard::BodyGuard(class UBotPlaybook* Playbook, const ELaneRoleSlot Role, const float TetherDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BotObjective_Bodyguard", "BodyGuard");

	Params::BotObjective_Bodyguard_BodyGuard Parms{};

	Parms.Playbook = Playbook;
	Parms.Role = Role;
	Parms.TetherDistance = TetherDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionTargetingMode_Base.GetTargets
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class AActor*>             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class AActor*> AOrionTargetingMode_Base::GetTargets() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTargetingMode_Base", "GetTargets");

	Params::OrionTargetingMode_Base_GetTargets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.PhasedFunctionalTest.AddCondition
// (Final, Native, Public)
// Parameters:
// class UFunctionalTestCondition*         Condition                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APhasedFunctionalTest::AddCondition(class UFunctionalTestCondition* Condition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhasedFunctionalTest", "AddCondition");

	Params::PhasedFunctionalTest_AddCondition Parms{};

	Parms.Condition = Condition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.PhasedFunctionalTest.BeginPlayHook
// (Event, Public, BlueprintEvent)

void APhasedFunctionalTest::BeginPlayHook()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhasedFunctionalTest", "BeginPlayHook");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.PhasedFunctionalTest.CheckConditions
// (Final, Native, Public)
// Parameters:
// bool                                    FinalCheck                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APhasedFunctionalTest::CheckConditions(bool FinalCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhasedFunctionalTest", "CheckConditions");

	Params::PhasedFunctionalTest_CheckConditions Parms{};

	Parms.FinalCheck = FinalCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.PhasedFunctionalTest.CleanUpPhaseLooping
// (Final, Native, Public)

void APhasedFunctionalTest::CleanUpPhaseLooping()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhasedFunctionalTest", "CleanUpPhaseLooping");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.PhasedFunctionalTest.CompleteTest
// (Native, Event, Public, BlueprintEvent)

void APhasedFunctionalTest::CompleteTest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhasedFunctionalTest", "CompleteTest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.PhasedFunctionalTest.CustomBeginPlay
// (Native, Public)

void APhasedFunctionalTest::CustomBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhasedFunctionalTest", "CustomBeginPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.PhasedFunctionalTest.CustomPhaseCleanup
// (Native, Public)

void APhasedFunctionalTest::CustomPhaseCleanup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhasedFunctionalTest", "CustomPhaseCleanup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.PhasedFunctionalTest.CustomPhaseSetup
// (Native, Public)

void APhasedFunctionalTest::CustomPhaseSetup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhasedFunctionalTest", "CustomPhaseSetup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.PhasedFunctionalTest.CustomPostTest
// (Native, Public)

void APhasedFunctionalTest::CustomPostTest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhasedFunctionalTest", "CustomPostTest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.PhasedFunctionalTest.CustomPreTest
// (Native, Public)

void APhasedFunctionalTest::CustomPreTest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhasedFunctionalTest", "CustomPreTest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.PhasedFunctionalTest.CustomTick
// (Native, Public)

void APhasedFunctionalTest::CustomTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhasedFunctionalTest", "CustomTick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.PhasedFunctionalTest.GetNextPhaseIndex
// (Final, Native, Public)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 APhasedFunctionalTest::GetNextPhaseIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhasedFunctionalTest", "GetNextPhaseIndex");

	Params::PhasedFunctionalTest_GetNextPhaseIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.PhasedFunctionalTest.GetPhaseLoopEnd
// (Final, Native, Public)
// Parameters:
// int32                                   StartIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 APhasedFunctionalTest::GetPhaseLoopEnd(int32 StartIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhasedFunctionalTest", "GetPhaseLoopEnd");

	Params::PhasedFunctionalTest_GetPhaseLoopEnd Parms{};

	Parms.StartIndex = StartIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.PhasedFunctionalTest.GetPhaseLoopStart
// (Final, Native, Public)
// Parameters:
// int32                                   EndIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 APhasedFunctionalTest::GetPhaseLoopStart(int32 EndIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhasedFunctionalTest", "GetPhaseLoopStart");

	Params::PhasedFunctionalTest_GetPhaseLoopStart Parms{};

	Parms.EndIndex = EndIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.PhasedFunctionalTest.LogError
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           MESSAGE                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APhasedFunctionalTest::LogError(const class FString& MESSAGE)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhasedFunctionalTest", "LogError");

	Params::PhasedFunctionalTest_LogError Parms{};

	Parms.MESSAGE = std::move(MESSAGE);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.PhasedFunctionalTest.LogInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           MESSAGE                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APhasedFunctionalTest::LogInfo(const class FString& MESSAGE)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhasedFunctionalTest", "LogInfo");

	Params::PhasedFunctionalTest_LogInfo Parms{};

	Parms.MESSAGE = std::move(MESSAGE);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.PhasedFunctionalTest.LogVerbose
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           MESSAGE                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APhasedFunctionalTest::LogVerbose(const class FString& MESSAGE)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhasedFunctionalTest", "LogVerbose");

	Params::PhasedFunctionalTest_LogVerbose Parms{};

	Parms.MESSAGE = std::move(MESSAGE);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.PhasedFunctionalTest.LogWarning
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           MESSAGE                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APhasedFunctionalTest::LogWarning(const class FString& MESSAGE)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhasedFunctionalTest", "LogWarning");

	Params::PhasedFunctionalTest_LogWarning Parms{};

	Parms.MESSAGE = std::move(MESSAGE);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.PhasedFunctionalTest.OnPhaseLoopTimerExpired
// (Final, Native, Public)

void APhasedFunctionalTest::OnPhaseLoopTimerExpired()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhasedFunctionalTest", "OnPhaseLoopTimerExpired");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.PhasedFunctionalTest.PhaseCleanupHook
// (Event, Public, BlueprintEvent)

void APhasedFunctionalTest::PhaseCleanupHook()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhasedFunctionalTest", "PhaseCleanupHook");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.PhasedFunctionalTest.PhaseSetupHook
// (Event, Public, BlueprintEvent)

void APhasedFunctionalTest::PhaseSetupHook()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhasedFunctionalTest", "PhaseSetupHook");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.PhasedFunctionalTest.PostTestHook
// (Event, Public, BlueprintEvent)

void APhasedFunctionalTest::PostTestHook()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhasedFunctionalTest", "PostTestHook");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.PhasedFunctionalTest.PreTestHook
// (Event, Public, BlueprintEvent)

void APhasedFunctionalTest::PreTestHook()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhasedFunctionalTest", "PreTestHook");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.PhasedFunctionalTest.ResetNextPhase
// (Native, Event, Public, BlueprintEvent)

void APhasedFunctionalTest::ResetNextPhase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhasedFunctionalTest", "ResetNextPhase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.PhasedFunctionalTest.SetUpPhaseLooping
// (Final, Native, Public)
// Parameters:
// class UPhaseLoopStart*                  StartPhase                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APhasedFunctionalTest::SetUpPhaseLooping(class UPhaseLoopStart* StartPhase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhasedFunctionalTest", "SetUpPhaseLooping");

	Params::PhasedFunctionalTest_SetUpPhaseLooping Parms{};

	Parms.StartPhase = StartPhase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.PhasedFunctionalTest.TickHook
// (Event, Public, BlueprintEvent)

void APhasedFunctionalTest::TickHook()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PhasedFunctionalTest", "TickHook");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionPhasedFunctionalTest.CacheFloat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPhasedFunctionalTest::CacheFloat(const class FString& Key, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPhasedFunctionalTest", "CacheFloat");

	Params::OrionPhasedFunctionalTest_CacheFloat Parms{};

	Parms.Key = std::move(Key);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPhasedFunctionalTest.ExecuteCommonCommands
// (Final, Native, Public)

void AOrionPhasedFunctionalTest::ExecuteCommonCommands()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPhasedFunctionalTest", "ExecuteCommonCommands");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPhasedFunctionalTest.ExecuteHeroCommands
// (Final, Native, Public, BlueprintCallable)

void AOrionPhasedFunctionalTest::ExecuteHeroCommands()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPhasedFunctionalTest", "ExecuteHeroCommands");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPhasedFunctionalTest.FindCachedFloat
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionPhasedFunctionalTest::FindCachedFloat(const class FString& Key, float* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPhasedFunctionalTest", "FindCachedFloat");

	Params::OrionPhasedFunctionalTest_FindCachedFloat Parms{};

	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPhasedFunctionalTest.GatherStaticActorReferences
// (Final, Native, Public)

void AOrionPhasedFunctionalTest::GatherStaticActorReferences()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPhasedFunctionalTest", "GatherStaticActorReferences");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPhasedFunctionalTest.GatherStaticBPActorReferences
// (Event, Public, BlueprintEvent)

void AOrionPhasedFunctionalTest::GatherStaticBPActorReferences()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPhasedFunctionalTest", "GatherStaticBPActorReferences");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionPhasedFunctionalTest.GetAutomationContext
// (Final, Native, Protected)
// Parameters:
// class UAutomationContext*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAutomationContext* AOrionPhasedFunctionalTest::GetAutomationContext()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPhasedFunctionalTest", "GetAutomationContext");

	Params::OrionPhasedFunctionalTest_GetAutomationContext Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPhasedFunctionalTest.GetMapObjective
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOrionDamageableActor*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOrionDamageableActor* AOrionPhasedFunctionalTest::GetMapObjective(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPhasedFunctionalTest", "GetMapObjective");

	Params::OrionPhasedFunctionalTest_GetMapObjective Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPhasedFunctionalTest.GetPawnInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAutomationPawnInfo              ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FAutomationPawnInfo AOrionPhasedFunctionalTest::GetPawnInfo(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPhasedFunctionalTest", "GetPawnInfo");

	Params::OrionPhasedFunctionalTest_GetPawnInfo Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPhasedFunctionalTest.GetSharedConfig
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UOrionFunctionalTestConfig*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionFunctionalTestConfig* AOrionPhasedFunctionalTest::GetSharedConfig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPhasedFunctionalTest", "GetSharedConfig");

	Params::OrionPhasedFunctionalTest_GetSharedConfig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPhasedFunctionalTest.GetSublevelViewTargetCollector_Internal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AOrionPhasedFunctionalTest::GetSublevelViewTargetCollector_Internal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPhasedFunctionalTest", "GetSublevelViewTargetCollector_Internal");

	Params::OrionPhasedFunctionalTest_GetSublevelViewTargetCollector_Internal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPhasedFunctionalTest.GetTestActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AOrionPhasedFunctionalTest::GetTestActor(const class FString& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPhasedFunctionalTest", "GetTestActor");

	Params::OrionPhasedFunctionalTest_GetTestActor Parms{};

	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPhasedFunctionalTest.ListenToGameplayCueRoutedEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    EnableGameplayCueLogging                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPhasedFunctionalTest::ListenToGameplayCueRoutedEvent(bool EnableGameplayCueLogging)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPhasedFunctionalTest", "ListenToGameplayCueRoutedEvent");

	Params::OrionPhasedFunctionalTest_ListenToGameplayCueRoutedEvent Parms{};

	Parms.EnableGameplayCueLogging = EnableGameplayCueLogging;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPhasedFunctionalTest.RecordGameplayCueDebugString
// (Final, Native, Public, HasOutParams)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     GameplayCueTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayCueEvent                       EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Parameters                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AOrionPhasedFunctionalTest::RecordGameplayCueDebugString(class AActor* TargetActor, const struct FGameplayTag& GameplayCueTag, EGameplayCueEvent EventType, const struct FGameplayCueParameters& Parameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPhasedFunctionalTest", "RecordGameplayCueDebugString");

	Params::OrionPhasedFunctionalTest_RecordGameplayCueDebugString Parms{};

	Parms.TargetActor = TargetActor;
	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.EventType = EventType;
	Parms.Parameters = std::move(Parameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPhasedFunctionalTest.ResetAFKTimer
// (Final, Native, Public)

void AOrionPhasedFunctionalTest::ResetAFKTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPhasedFunctionalTest", "ResetAFKTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPhasedFunctionalTest.SetPawnInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOrionChar*                       OrionChar                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPhasedFunctionalTest::SetPawnInfo(int32 Index_0, class AOrionChar* OrionChar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPhasedFunctionalTest", "SetPawnInfo");

	Params::OrionPhasedFunctionalTest_SetPawnInfo Parms{};

	Parms.Index_0 = Index_0;
	Parms.OrionChar = OrionChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPhasedFunctionalTest.SetSublevelViewTargetCollector
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           NewCollector                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPhasedFunctionalTest::SetSublevelViewTargetCollector(class AActor* NewCollector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPhasedFunctionalTest", "SetSublevelViewTargetCollector");

	Params::OrionPhasedFunctionalTest_SetSublevelViewTargetCollector Parms{};

	Parms.NewCollector = NewCollector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPhasedFunctionalTest.SetTestActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPhasedFunctionalTest::SetTestActor(const class FString& Key, class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPhasedFunctionalTest", "SetTestActor");

	Params::OrionPhasedFunctionalTest_SetTestActor Parms{};

	Parms.Key = std::move(Key);
	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDynamicWall.ConstructWall
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   InAbilityLevel                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SegmentCountClamp                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionDynamicWall::ConstructWall(const struct FVector& Location, const struct FRotator& Rotation, int32 InAbilityLevel, int32 SegmentCountClamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDynamicWall", "ConstructWall");

	Params::OrionDynamicWall_ConstructWall Parms{};

	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.InAbilityLevel = InAbilityLevel;
	Parms.SegmentCountClamp = SegmentCountClamp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionDynamicWall.ConstructWallWithTargetData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayAbilityTargetDataHandle TargetData                                             (Parm, NativeAccessSpecifierPublic)
// int32                                   InAbilityLevel                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SegmentCountClamp                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionDynamicWall::ConstructWallWithTargetData(const struct FGameplayAbilityTargetDataHandle& TargetData, int32 InAbilityLevel, int32 SegmentCountClamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDynamicWall", "ConstructWallWithTargetData");

	Params::OrionDynamicWall_ConstructWallWithTargetData Parms{};

	Parms.TargetData = std::move(TargetData);
	Parms.InAbilityLevel = InAbilityLevel;
	Parms.SegmentCountClamp = SegmentCountClamp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionDynamicWall.DeconstructWall
// (Final, Native, Public, BlueprintCallable)

void AOrionDynamicWall::DeconstructWall()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDynamicWall", "DeconstructWall");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDynamicWall.OnRep_ConstructionSegmentCount
// (Final, Native, Protected)

void AOrionDynamicWall::OnRep_ConstructionSegmentCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDynamicWall", "OnRep_ConstructionSegmentCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDynamicWall.OnRep_ConstructionToggle
// (Final, Native, Protected)
// Parameters:
// bool                                    OldConstructionToggle                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionDynamicWall::OnRep_ConstructionToggle(bool OldConstructionToggle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDynamicWall", "OnRep_ConstructionToggle");

	Params::OrionDynamicWall_OnRep_ConstructionToggle Parms{};

	Parms.OldConstructionToggle = OldConstructionToggle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDynamicWall.OnRep_SegmentActors
// (Final, Native, Protected)

void AOrionDynamicWall::OnRep_SegmentActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDynamicWall", "OnRep_SegmentActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.BotObjectiveGraph.EditorBuild
// (Final, Native, Public)

void ABotObjectiveGraph::EditorBuild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BotObjectiveGraph", "EditorBuild");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDamageNumberManager.GetDamageNumberOffset
// (Native, Event, Protected, HasOutParams, HasDefaults, BlueprintEvent, Const)
// Parameters:
// struct FOrionDamageNumberInfo           DamageNumberInfo                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AOrionDamageNumberManager::GetDamageNumberOffset(const struct FOrionDamageNumberInfo& DamageNumberInfo) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageNumberManager", "GetDamageNumberOffset");

	Params::OrionDamageNumberManager_GetDamageNumberOffset Parms{};

	Parms.DamageNumberInfo = std::move(DamageNumberInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionDamageNumberManager.GetDamageNumberStartLocation
// (Native, Event, Protected, HasOutParams, HasDefaults, BlueprintEvent, Const)
// Parameters:
// struct FOrionDamageNumberInfo           DamageNumberInfo                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AOrionDamageNumberManager::GetDamageNumberStartLocation(const struct FOrionDamageNumberInfo& DamageNumberInfo) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDamageNumberManager", "GetDamageNumberStartLocation");

	Params::OrionDamageNumberManager_GetDamageNumberStartLocation Parms{};

	Parms.DamageNumberInfo = std::move(DamageNumberInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTeamActorInterface.OnTeamChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// EOrionTeam                              NewTeamIdx                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IOrionTeamActorInterface::OnTeamChanged(EOrionTeam NewTeamIdx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamActorInterface", "OnTeamChanged");

	Params::OrionTeamActorInterface_OnTeamChanged Parms{};

	Parms.NewTeamIdx = NewTeamIdx;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionTeamActorInterface.GetTeamNum
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// EOrionTeam                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOrionTeam IOrionTeamActorInterface::GetTeamNum() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamActorInterface", "GetTeamNum");

	Params::OrionTeamActorInterface_GetTeamNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.BotPlaybook.AdditionalCondition
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOrionGenericAITest              Condition                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UBotPlaybook::AdditionalCondition(const struct FOrionGenericAITest& Condition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BotPlaybook", "AdditionalCondition");

	Params::BotPlaybook_AdditionalCondition Parms{};

	Parms.Condition = std::move(Condition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.BotPlaybook.AdditionalConditions
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FOrionGenericAITest>      Conditions                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UBotPlaybook::AdditionalConditions(const TArray<struct FOrionGenericAITest>& Conditions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BotPlaybook", "AdditionalConditions");

	Params::BotPlaybook_AdditionalConditions Parms{};

	Parms.Conditions = std::move(Conditions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.BotPlaybook.AddTeamCommAssignOverride
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EAITeamCommEvent                        AssignCommOverride                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBotPlaybook::AddTeamCommAssignOverride(const EAITeamCommEvent AssignCommOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BotPlaybook", "AddTeamCommAssignOverride");

	Params::BotPlaybook_AddTeamCommAssignOverride Parms{};

	Parms.AssignCommOverride = AssignCommOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.BotPlaybook.AddTeamCommConfirmOverride
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EAITeamCommEvent                        ConfirmCommOverride                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBotPlaybook::AddTeamCommConfirmOverride(const EAITeamCommEvent ConfirmCommOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BotPlaybook", "AddTeamCommConfirmOverride");

	Params::BotPlaybook_AddTeamCommConfirmOverride Parms{};

	Parms.ConfirmCommOverride = ConfirmCommOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.BotPlaybook.OnGenerateObjectiveList
// (Native, Event, Protected, BlueprintEvent)

void UBotPlaybook::OnGenerateObjectiveList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BotPlaybook", "OnGenerateObjectiveList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.BotPlaybook.GetAgentDifficulty
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAIBotDifficulty                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAIBotDifficulty UBotPlaybook::GetAgentDifficulty() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BotPlaybook", "GetAgentDifficulty");

	Params::BotPlaybook_GetAgentDifficulty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.BotPlaybook.GetMatchPhase
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAIMatchProgress                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAIMatchProgress UBotPlaybook::GetMatchPhase() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BotPlaybook", "GetMatchPhase");

	Params::BotPlaybook_GetMatchPhase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.BotPlaybook.IsRole
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELaneRoleSlot                           Role                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBotPlaybook::IsRole(ELaneRoleSlot Role) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BotPlaybook", "IsRole");

	Params::BotPlaybook_IsRole Parms{};

	Parms.Role = Role;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionDummySpawner.KillAI
// (Final, Native, Public, BlueprintCallable)

void AOrionDummySpawner::KillAI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDummySpawner", "KillAI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDummySpawner.OnDeath
// (Final, Native, Protected)
// Parameters:
// class AOrionChar*                       DeadChar                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      Killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionDummySpawner::OnDeath(class AOrionChar* DeadChar, class AController* Killer, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDummySpawner", "OnDeath");

	Params::OrionDummySpawner_OnDeath Parms{};

	Parms.DeadChar = DeadChar;
	Parms.Killer = Killer;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDummySpawner.Spawn
// (Final, Native, Public, BlueprintCallable)

void AOrionDummySpawner::Spawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDummySpawner", "Spawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionEnergySet.OnRep_CooldownReductionPercentage
// (Final, Native, Public)

void UOrionEnergySet::OnRep_CooldownReductionPercentage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionEnergySet", "OnRep_CooldownReductionPercentage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionEnergySet.OnRep_CooldownReductionValue
// (Final, Native, Public)

void UOrionEnergySet::OnRep_CooldownReductionValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionEnergySet", "OnRep_CooldownReductionValue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionEnergySet.OnRep_Energy
// (Final, Native, Public)

void UOrionEnergySet::OnRep_Energy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionEnergySet", "OnRep_Energy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionEnergySet.OnRep_EnergyReduction
// (Final, Native, Public)

void UOrionEnergySet::OnRep_EnergyReduction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionEnergySet", "OnRep_EnergyReduction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionEnergySet.OnRep_EnergyReductionPercentage
// (Final, Native, Public)

void UOrionEnergySet::OnRep_EnergyReductionPercentage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionEnergySet", "OnRep_EnergyReductionPercentage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionEnergySet.OnRep_EnergyRegenRate
// (Final, Native, Public)

void UOrionEnergySet::OnRep_EnergyRegenRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionEnergySet", "OnRep_EnergyRegenRate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionEnergySet.OnRep_MaxEnergy
// (Final, Native, Public)

void UOrionEnergySet::OnRep_MaxEnergy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionEnergySet", "OnRep_MaxEnergy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.ClientSettingsRecord.ResetToDefaultControlSettings
// (Native, Public, BlueprintCallable)

void UClientSettingsRecord::ResetToDefaultControlSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientSettingsRecord", "ResetToDefaultControlSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.ClientSettingsRecord.ResetToDefaultGameplaySettings
// (Native, Public, BlueprintCallable)

void UClientSettingsRecord::ResetToDefaultGameplaySettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientSettingsRecord", "ResetToDefaultGameplaySettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.ClientSettingsRecord.SetGamepadAbilityConfirmOnRelease
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClientSettingsRecord::SetGamepadAbilityConfirmOnRelease(int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientSettingsRecord", "SetGamepadAbilityConfirmOnRelease");

	Params::ClientSettingsRecord_SetGamepadAbilityConfirmOnRelease Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.ClientSettingsRecord.SetGamepadInvertPitch
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClientSettingsRecord::SetGamepadInvertPitch(int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientSettingsRecord", "SetGamepadInvertPitch");

	Params::ClientSettingsRecord_SetGamepadInvertPitch Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.ClientSettingsRecord.SetGamepadInvertYaw
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClientSettingsRecord::SetGamepadInvertYaw(int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientSettingsRecord", "SetGamepadInvertYaw");

	Params::ClientSettingsRecord_SetGamepadInvertYaw Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.ClientSettingsRecord.SetGamepadPitchSensitivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClientSettingsRecord::SetGamepadPitchSensitivity(int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientSettingsRecord", "SetGamepadPitchSensitivity");

	Params::ClientSettingsRecord_SetGamepadPitchSensitivity Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.ClientSettingsRecord.SetGamepadRadialSelectEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClientSettingsRecord::SetGamepadRadialSelectEnabled(int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientSettingsRecord", "SetGamepadRadialSelectEnabled");

	Params::ClientSettingsRecord_SetGamepadRadialSelectEnabled Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.ClientSettingsRecord.SetGamepadYawSensitivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClientSettingsRecord::SetGamepadYawSensitivity(int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientSettingsRecord", "SetGamepadYawSensitivity");

	Params::ClientSettingsRecord_SetGamepadYawSensitivity Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.ClientSettingsRecord.SetInvertedMouse
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInvert                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClientSettingsRecord::SetInvertedMouse(bool bInvert)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientSettingsRecord", "SetInvertedMouse");

	Params::ClientSettingsRecord_SetInvertedMouse Parms{};

	Parms.bInvert = bInvert;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.ClientSettingsRecord.SetMouseLookSensitivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClientSettingsRecord::SetMouseLookSensitivity(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientSettingsRecord", "SetMouseLookSensitivity");

	Params::ClientSettingsRecord_SetMouseLookSensitivity Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.ClientSettingsRecord.SetShowPingAndFPS
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClientSettingsRecord::SetShowPingAndFPS(int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientSettingsRecord", "SetShowPingAndFPS");

	Params::ClientSettingsRecord_SetShowPingAndFPS Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.ClientSettingsRecord.SetShowXPPerMinute
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClientSettingsRecord::SetShowXPPerMinute(int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientSettingsRecord", "SetShowXPPerMinute");

	Params::ClientSettingsRecord_SetShowXPPerMinute Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.ClientSettingsRecord.GetGamepadAbilityConfirmOnRelease
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UClientSettingsRecord::GetGamepadAbilityConfirmOnRelease() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientSettingsRecord", "GetGamepadAbilityConfirmOnRelease");

	Params::ClientSettingsRecord_GetGamepadAbilityConfirmOnRelease Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.ClientSettingsRecord.GetGamepadInvertPitch
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UClientSettingsRecord::GetGamepadInvertPitch() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientSettingsRecord", "GetGamepadInvertPitch");

	Params::ClientSettingsRecord_GetGamepadInvertPitch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.ClientSettingsRecord.GetGamepadInvertYaw
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UClientSettingsRecord::GetGamepadInvertYaw() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientSettingsRecord", "GetGamepadInvertYaw");

	Params::ClientSettingsRecord_GetGamepadInvertYaw Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.ClientSettingsRecord.GetGamepadPitchSensitivity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UClientSettingsRecord::GetGamepadPitchSensitivity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientSettingsRecord", "GetGamepadPitchSensitivity");

	Params::ClientSettingsRecord_GetGamepadPitchSensitivity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.ClientSettingsRecord.GetGamepadRadialSelectEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UClientSettingsRecord::GetGamepadRadialSelectEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientSettingsRecord", "GetGamepadRadialSelectEnabled");

	Params::ClientSettingsRecord_GetGamepadRadialSelectEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.ClientSettingsRecord.GetGamepadYawSensitivity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UClientSettingsRecord::GetGamepadYawSensitivity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientSettingsRecord", "GetGamepadYawSensitivity");

	Params::ClientSettingsRecord_GetGamepadYawSensitivity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.ClientSettingsRecord.GetInvertedMouse
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UClientSettingsRecord::GetInvertedMouse() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientSettingsRecord", "GetInvertedMouse");

	Params::ClientSettingsRecord_GetInvertedMouse Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.ClientSettingsRecord.GetMouseLookSensitivity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UClientSettingsRecord::GetMouseLookSensitivity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientSettingsRecord", "GetMouseLookSensitivity");

	Params::ClientSettingsRecord_GetMouseLookSensitivity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.ClientSettingsRecord.GetShowPingAndFPS
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UClientSettingsRecord::GetShowPingAndFPS() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientSettingsRecord", "GetShowPingAndFPS");

	Params::ClientSettingsRecord_GetShowPingAndFPS Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.ClientSettingsRecord.GetShowXPPerMinute
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UClientSettingsRecord::GetShowXPPerMinute() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientSettingsRecord", "GetShowXPPerMinute");

	Params::ClientSettingsRecord_GetShowXPPerMinute Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAnimInstance.ShouldRateLimitBlueprintTicks
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    bIsHero                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Amount                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionAnimInstance::ShouldRateLimitBlueprintTicks(bool bIsHero, float* Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAnimInstance", "ShouldRateLimitBlueprintTicks");

	Params::OrionAnimInstance_ShouldRateLimitBlueprintTicks Parms{};

	Parms.bIsHero = bIsHero;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Amount != nullptr)
		*Amount = Parms.Amount;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAnimInstance.AnimNotify_LeftFootStep
// (Final, Native, Public)
// Parameters:
// class UAnimNotify*                      Notify                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAnimInstance::AnimNotify_LeftFootStep(const class UAnimNotify* Notify)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAnimInstance", "AnimNotify_LeftFootStep");

	Params::OrionAnimInstance_AnimNotify_LeftFootStep Parms{};

	Parms.Notify = Notify;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAnimInstance.AnimNotify_RightFootStep
// (Final, Native, Public)
// Parameters:
// class UAnimNotify*                      Notify                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAnimInstance::AnimNotify_RightFootStep(const class UAnimNotify* Notify)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAnimInstance", "AnimNotify_RightFootStep");

	Params::OrionAnimInstance_AnimNotify_RightFootStep Parms{};

	Parms.Notify = Notify;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAnimInstance.OnHit
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTagContainer            TargetTags                                             (Parm, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           GameplayCueParameters                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UOrionAnimInstance::OnHit(const struct FGameplayTagContainer& TargetTags, const struct FGameplayCueParameters& GameplayCueParameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAnimInstance", "OnHit");

	Params::OrionAnimInstance_OnHit Parms{};

	Parms.TargetTags = std::move(TargetTags);
	Parms.GameplayCueParameters = std::move(GameplayCueParameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAnimInstance.IsGameplayCueActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     GameplayCueTag                                         (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionAnimInstance::IsGameplayCueActive(const struct FGameplayTag& GameplayCueTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAnimInstance", "IsGameplayCueActive");

	Params::OrionAnimInstance_IsGameplayCueActive Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAnimInstance.IsSlotNodePlayingAMontage
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             SlotNodeName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionAnimInstance::IsSlotNodePlayingAMontage(const class FName& SlotNodeName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAnimInstance", "IsSlotNodePlayingAMontage");

	Params::OrionAnimInstance_IsSlotNodePlayingAMontage Parms{};

	Parms.SlotNodeName = SlotNodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAnimInstance.OwnerHasMatchingGameplayTag
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     TagToCheck                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionAnimInstance::OwnerHasMatchingGameplayTag(const struct FGameplayTag& TagToCheck) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAnimInstance", "OwnerHasMatchingGameplayTag");

	Params::OrionAnimInstance_OwnerHasMatchingGameplayTag Parms{};

	Parms.TagToCheck = std::move(TagToCheck);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAnimInstance.TryGetOrionChar
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AOrionChar*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOrionChar* UOrionAnimInstance::TryGetOrionChar() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAnimInstance", "TryGetOrionChar");

	Params::OrionAnimInstance_TryGetOrionChar Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.FrontEndManager.GetScene
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             SceneName                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AFrontEndManager::GetScene(const class FName SceneName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FrontEndManager", "GetScene");

	Params::FrontEndManager_GetScene Parms{};

	Parms.SceneName = SceneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionEQSTestingPawn.GetTeamNum
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// EOrionTeam                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOrionTeam AOrionEQSTestingPawn::GetTeamNum() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionEQSTestingPawn", "GetTeamNum");

	Params::OrionEQSTestingPawn_GetTeamNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlayerState_Base.ClientAutomationKeepActive
// (Net, NetReliable, Native, Event, Public, NetClient, NetValidate)

void AOrionPlayerState_Base::ClientAutomationKeepActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Base", "ClientAutomationKeepActive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerState_Base.ClientFailedToPickHero
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// struct FOrionHeroDataSpec               InHeroDataSpec                                         (Parm, NativeAccessSpecifierPublic)

void AOrionPlayerState_Base::ClientFailedToPickHero(const struct FOrionHeroDataSpec& InHeroDataSpec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Base", "ClientFailedToPickHero");

	Params::OrionPlayerState_Base_ClientFailedToPickHero Parms{};

	Parms.InHeroDataSpec = std::move(InHeroDataSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerState_Base.OnRep_bInitializedFromMatchmakingData
// (Final, Native, Protected)

void AOrionPlayerState_Base::OnRep_bInitializedFromMatchmakingData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Base", "OnRep_bInitializedFromMatchmakingData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerState_Base.OnRep_bIsPlayerDisconnected
// (Final, Native, Protected)

void AOrionPlayerState_Base::OnRep_bIsPlayerDisconnected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Base", "OnRep_bIsPlayerDisconnected");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerState_Base.OnRep_bReadyToStartMatch
// (Native, Protected)

void AOrionPlayerState_Base::OnRep_bReadyToStartMatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Base", "OnRep_bReadyToStartMatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerState_Base.OnRep_HeroDataSpec
// (Final, Native, Protected)

void AOrionPlayerState_Base::OnRep_HeroDataSpec()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Base", "OnRep_HeroDataSpec");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerState_Base.OnRep_PartyOwner
// (Final, Native, Protected)

void AOrionPlayerState_Base::OnRep_PartyOwner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Base", "OnRep_PartyOwner");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerState_Base.OnRep_Team
// (Final, Native, Protected)
// Parameters:
// class AOrionTeamInfo*                   OldTeamInfo                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerState_Base::OnRep_Team(const class AOrionTeamInfo* OldTeamInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Base", "OnRep_Team");

	Params::OrionPlayerState_Base_OnRep_Team Parms{};

	Parms.OldTeamInfo = OldTeamInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerState_Base.ServerAutomationKeepActive
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void AOrionPlayerState_Base::ServerAutomationKeepActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Base", "ServerAutomationKeepActive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerState_Base.ServerClearPlayerHeroData
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void AOrionPlayerState_Base::ServerClearPlayerHeroData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Base", "ServerClearPlayerHeroData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerState_Base.ServerNotifySlateActivity
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void AOrionPlayerState_Base::ServerNotifySlateActivity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Base", "ServerNotifySlateActivity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerState_Base.ServerSetPlayerHeroDataSpec
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// struct FOrionHeroDataSpec               InHeroDataSpec                                         (Parm, NativeAccessSpecifierPublic)

void AOrionPlayerState_Base::ServerSetPlayerHeroDataSpec(const struct FOrionHeroDataSpec& InHeroDataSpec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Base", "ServerSetPlayerHeroDataSpec");

	Params::OrionPlayerState_Base_ServerSetPlayerHeroDataSpec Parms{};

	Parms.InHeroDataSpec = std::move(InHeroDataSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerState_Base._BPGetHeroData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UOrionHeroData*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionHeroData* AOrionPlayerState_Base::_BPGetHeroData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Base", "_BPGetHeroData");

	Params::OrionPlayerState_Base__BPGetHeroData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlayerState_Base.GetPlayerPosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionPosition                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOrionPosition AOrionPlayerState_Base::GetPlayerPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Base", "GetPlayerPosition");

	Params::OrionPlayerState_Base_GetPlayerPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlayerState_Base.GetTeamNum
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// EOrionTeam                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOrionTeam AOrionPlayerState_Base::GetTeamNum() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Base", "GetTeamNum");

	Params::OrionPlayerState_Base_GetTeamNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.FTS_AimAtTarget.WaitTimerFinished
// (Final, Native, Private)

void UFTS_AimAtTarget::WaitTimerFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FTS_AimAtTarget", "WaitTimerFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.FTS_ExecCommand.SetStatusToSucceeded
// (Final, Native, Private)

void UFTS_ExecCommand::SetStatusToSucceeded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FTS_ExecCommand", "SetStatusToSucceeded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.FTS_MoveCharacter.WaitTimerFinished
// (Final, Native, Private)

void UFTS_MoveCharacter::WaitTimerFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FTS_MoveCharacter", "WaitTimerFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameplayItem.OnRep_CurrentItemState
// (Final, Native, Private)

void UOrionGameplayItem::OnRep_CurrentItemState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayItem", "OnRep_CurrentItemState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameplayItem.OnRep_ItemAbilityHandles
// (Final, Native, Private)

void UOrionGameplayItem::OnRep_ItemAbilityHandles()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayItem", "OnRep_ItemAbilityHandles");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameplayItem.OnRep_StackCostCount
// (Final, Native, Private)

void UOrionGameplayItem::OnRep_StackCostCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayItem", "OnRep_StackCostCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.FTS_RemoveGameplayEffects.WaitTimerFinished
// (Final, Native, Private)

void UFTS_RemoveGameplayEffects::WaitTimerFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FTS_RemoveGameplayEffects", "WaitTimerFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.FTS_SetHealth.SetExecuteStatusSuccess
// (Final, Native, Private)

void UFTS_SetHealth::SetExecuteStatusSuccess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FTS_SetHealth", "SetExecuteStatusSuccess");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameMode_MOBA_Tutorial.TutorialPause
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                Pauser                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPause                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameMode_MOBA_Tutorial::TutorialPause(class APlayerController* Pauser, bool bPause)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_MOBA_Tutorial", "TutorialPause");

	Params::OrionGameMode_MOBA_Tutorial_TutorialPause Parms{};

	Parms.Pauser = Pauser;
	Parms.bPause = bPause;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameplayCueNotify_Looping.K2_OnActive
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class AActor*                           MyTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Parameters                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UParticleSystemComponent*         ApplicationParticleSystem                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UParticleSystemComponent*> AdditionalParticleSystems                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UCameraShake*                     ApplicationCameraShakeInstance                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraComponent*                ApplicationNiagaraParticleSystem                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UNiagaraComponent*>        AdditionalNiagaraParticleSystems                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AOrionGameplayCueNotify_Looping::K2_OnActive(class AActor* MyTarget, const struct FGameplayCueParameters& Parameters, class UParticleSystemComponent* ApplicationParticleSystem, const TArray<class UParticleSystemComponent*>& AdditionalParticleSystems, class UCameraShake* ApplicationCameraShakeInstance, class UNiagaraComponent* ApplicationNiagaraParticleSystem, const TArray<class UNiagaraComponent*>& AdditionalNiagaraParticleSystems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayCueNotify_Looping", "K2_OnActive");

	Params::OrionGameplayCueNotify_Looping_K2_OnActive Parms{};

	Parms.MyTarget = MyTarget;
	Parms.Parameters = std::move(Parameters);
	Parms.ApplicationParticleSystem = ApplicationParticleSystem;
	Parms.AdditionalParticleSystems = std::move(AdditionalParticleSystems);
	Parms.ApplicationCameraShakeInstance = ApplicationCameraShakeInstance;
	Parms.ApplicationNiagaraParticleSystem = ApplicationNiagaraParticleSystem;
	Parms.AdditionalNiagaraParticleSystems = std::move(AdditionalNiagaraParticleSystems);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionGameplayCueNotify_Looping.K2_OnExecute
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class AActor*                           MyTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Parameters                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UParticleSystemComponent*         RecurringParticleSystem                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UParticleSystemComponent*> AdditionalParticleSystems                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UNiagaraComponent*                RecurringNiagaraParticleSystem                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UNiagaraComponent*>        AdditionalNiagaraParticleSystems                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AOrionGameplayCueNotify_Looping::K2_OnExecute(class AActor* MyTarget, const struct FGameplayCueParameters& Parameters, class UParticleSystemComponent* RecurringParticleSystem, const TArray<class UParticleSystemComponent*>& AdditionalParticleSystems, class UNiagaraComponent* RecurringNiagaraParticleSystem, const TArray<class UNiagaraComponent*>& AdditionalNiagaraParticleSystems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayCueNotify_Looping", "K2_OnExecute");

	Params::OrionGameplayCueNotify_Looping_K2_OnExecute Parms{};

	Parms.MyTarget = MyTarget;
	Parms.Parameters = std::move(Parameters);
	Parms.RecurringParticleSystem = RecurringParticleSystem;
	Parms.AdditionalParticleSystems = std::move(AdditionalParticleSystems);
	Parms.RecurringNiagaraParticleSystem = RecurringNiagaraParticleSystem;
	Parms.AdditionalNiagaraParticleSystems = std::move(AdditionalNiagaraParticleSystems);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionGameplayCueNotify_Looping.K2_OnRemove
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class AActor*                           MyTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Parameters                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UParticleSystemComponent*         RemovalParticleSystem                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UParticleSystemComponent*> AdditionalParticleSystems                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UNiagaraComponent*                RemovalNiagaraParticleSystem                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UNiagaraComponent*>        AdditionalNiagaraParticleSystems                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AOrionGameplayCueNotify_Looping::K2_OnRemove(class AActor* MyTarget, const struct FGameplayCueParameters& Parameters, class UParticleSystemComponent* RemovalParticleSystem, const TArray<class UParticleSystemComponent*>& AdditionalParticleSystems, class UNiagaraComponent* RemovalNiagaraParticleSystem, const TArray<class UNiagaraComponent*>& AdditionalNiagaraParticleSystems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayCueNotify_Looping", "K2_OnRemove");

	Params::OrionGameplayCueNotify_Looping_K2_OnRemove Parms{};

	Parms.MyTarget = MyTarget;
	Parms.Parameters = std::move(Parameters);
	Parms.RemovalParticleSystem = RemovalParticleSystem;
	Parms.AdditionalParticleSystems = std::move(AdditionalParticleSystems);
	Parms.RemovalNiagaraParticleSystem = RemovalNiagaraParticleSystem;
	Parms.AdditionalNiagaraParticleSystems = std::move(AdditionalNiagaraParticleSystems);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionGameplayCueNotify_Looping.K2_WhileActive
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class AActor*                           MyTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Parameters                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UParticleSystemComponent*         LoopingParticleSystem                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UParticleSystemComponent*> AdditionalParticleSystem                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UNiagaraComponent*                LoopingNiagaraParticleSystem                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UNiagaraComponent*>        AdditionalNiagaraParticleSystems                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AOrionGameplayCueNotify_Looping::K2_WhileActive(class AActor* MyTarget, const struct FGameplayCueParameters& Parameters, class UParticleSystemComponent* LoopingParticleSystem, const TArray<class UParticleSystemComponent*>& AdditionalParticleSystem, class UNiagaraComponent* LoopingNiagaraParticleSystem, const TArray<class UNiagaraComponent*>& AdditionalNiagaraParticleSystems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayCueNotify_Looping", "K2_WhileActive");

	Params::OrionGameplayCueNotify_Looping_K2_WhileActive Parms{};

	Parms.MyTarget = MyTarget;
	Parms.Parameters = std::move(Parameters);
	Parms.LoopingParticleSystem = LoopingParticleSystem;
	Parms.AdditionalParticleSystem = std::move(AdditionalParticleSystem);
	Parms.LoopingNiagaraParticleSystem = LoopingNiagaraParticleSystem;
	Parms.AdditionalNiagaraParticleSystems = std::move(AdditionalNiagaraParticleSystems);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionGameplayCueNotify_Looping.ReceiveTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameplayCueNotify_Looping::ReceiveTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayCueNotify_Looping", "ReceiveTick");

	Params::OrionGameplayCueNotify_Looping_ReceiveTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionGameplayCueNotify_Looping.GetGameplayCueLoopingAnimationDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionGameplayCueNotify_Looping::GetGameplayCueLoopingAnimationDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayCueNotify_Looping", "GetGameplayCueLoopingAnimationDuration");

	Params::OrionGameplayCueNotify_Looping_GetGameplayCueLoopingAnimationDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameplayCueNotify_Looping.GetTrailParticleSystem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UParticleSystemComponent*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UParticleSystemComponent* AOrionGameplayCueNotify_Looping::GetTrailParticleSystem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayCueNotify_Looping", "GetTrailParticleSystem");

	Params::OrionGameplayCueNotify_Looping_GetTrailParticleSystem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.FTS_Wait.WaitTimerFinished
// (Final, Native, Private)

void UFTS_Wait::WaitTimerFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FTS_Wait", "WaitTimerFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionRichTextInlineWidget.OnApplyMetaData
// (Event, Protected, BlueprintEvent)
// Parameters:
// class FString                           Tag                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionRichTextInlineWidget::OnApplyMetaData(const class FString& Tag, const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionRichTextInlineWidget", "OnApplyMetaData");

	Params::OrionRichTextInlineWidget_OnApplyMetaData Parms{};

	Parms.Tag = std::move(Tag);
	Parms.Value = std::move(Value);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionGameplayStatsLibrary.GetCoreTakedowns
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayStats                   GameplayStats                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bUseTrackedStat                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOrionGameplayStatsLibrary::GetCoreTakedowns(const struct FGameplayStats& GameplayStats, bool bUseTrackedStat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionGameplayStatsLibrary", "GetCoreTakedowns");

	Params::OrionGameplayStatsLibrary_GetCoreTakedowns Parms{};

	Parms.GameplayStats = std::move(GameplayStats);
	Parms.bUseTrackedStat = bUseTrackedStat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameplayStatsLibrary.GetHarvesterTakedowns
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayStats                   GameplayStats                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bUseTrackedStat                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOrionGameplayStatsLibrary::GetHarvesterTakedowns(const struct FGameplayStats& GameplayStats, bool bUseTrackedStat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionGameplayStatsLibrary", "GetHarvesterTakedowns");

	Params::OrionGameplayStatsLibrary_GetHarvesterTakedowns Parms{};

	Parms.GameplayStats = std::move(GameplayStats);
	Parms.bUseTrackedStat = bUseTrackedStat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameplayStatsLibrary.GetHeroTakedowns
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayStats                   GameplayStats                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bUseTrackedStat                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOrionGameplayStatsLibrary::GetHeroTakedowns(const struct FGameplayStats& GameplayStats, bool bUseTrackedStat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionGameplayStatsLibrary", "GetHeroTakedowns");

	Params::OrionGameplayStatsLibrary_GetHeroTakedowns Parms{};

	Parms.GameplayStats = std::move(GameplayStats);
	Parms.bUseTrackedStat = bUseTrackedStat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameplayStatsLibrary.GetInhibitorTakedowns
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayStats                   GameplayStats                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bUseTrackedStat                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOrionGameplayStatsLibrary::GetInhibitorTakedowns(const struct FGameplayStats& GameplayStats, bool bUseTrackedStat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionGameplayStatsLibrary", "GetInhibitorTakedowns");

	Params::OrionGameplayStatsLibrary_GetInhibitorTakedowns Parms{};

	Parms.GameplayStats = std::move(GameplayStats);
	Parms.bUseTrackedStat = bUseTrackedStat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameplayStatsLibrary.GetMatchStatValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayStats                   GameplayStats                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayStatTag                 Stat                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionStatTrackType                     TrackType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOrionGameplayStatsLibrary::GetMatchStatValue(const struct FGameplayStats& GameplayStats, const struct FGameplayStatTag& Stat, EOrionStatTrackType TrackType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionGameplayStatsLibrary", "GetMatchStatValue");

	Params::OrionGameplayStatsLibrary_GetMatchStatValue Parms{};

	Parms.GameplayStats = std::move(GameplayStats);
	Parms.Stat = std::move(Stat);
	Parms.TrackType = TrackType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameplayStatsLibrary.GetPersistentStatValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayStats                   GameplayStats                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayStatTag                 Stat                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOrionGameplayStatsLibrary::GetPersistentStatValue(const struct FGameplayStats& GameplayStats, const struct FGameplayStatTag& Stat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionGameplayStatsLibrary", "GetPersistentStatValue");

	Params::OrionGameplayStatsLibrary_GetPersistentStatValue Parms{};

	Parms.GameplayStats = std::move(GameplayStats);
	Parms.Stat = std::move(Stat);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameplayStatsLibrary.GetTotalAssists
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayStats                   GameplayStats                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bUseTrackedStat                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOrionGameplayStatsLibrary::GetTotalAssists(const struct FGameplayStats& GameplayStats, bool bUseTrackedStat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionGameplayStatsLibrary", "GetTotalAssists");

	Params::OrionGameplayStatsLibrary_GetTotalAssists Parms{};

	Parms.GameplayStats = std::move(GameplayStats);
	Parms.bUseTrackedStat = bUseTrackedStat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameplayStatsLibrary.GetTotalDeaths
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayStats                   GameplayStats                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bUseTrackedStat                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOrionGameplayStatsLibrary::GetTotalDeaths(const struct FGameplayStats& GameplayStats, bool bUseTrackedStat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionGameplayStatsLibrary", "GetTotalDeaths");

	Params::OrionGameplayStatsLibrary_GetTotalDeaths Parms{};

	Parms.GameplayStats = std::move(GameplayStats);
	Parms.bUseTrackedStat = bUseTrackedStat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameplayStatsLibrary.GetTotalKills
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayStats                   GameplayStats                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bUseTrackedStat                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOrionGameplayStatsLibrary::GetTotalKills(const struct FGameplayStats& GameplayStats, bool bUseTrackedStat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionGameplayStatsLibrary", "GetTotalKills");

	Params::OrionGameplayStatsLibrary_GetTotalKills Parms{};

	Parms.GameplayStats = std::move(GameplayStats);
	Parms.bUseTrackedStat = bUseTrackedStat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameplayStatsLibrary.GetTowerTakedowns
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayStats                   GameplayStats                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bUseTrackedStat                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOrionGameplayStatsLibrary::GetTowerTakedowns(const struct FGameplayStats& GameplayStats, bool bUseTrackedStat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionGameplayStatsLibrary", "GetTowerTakedowns");

	Params::OrionGameplayStatsLibrary_GetTowerTakedowns Parms{};

	Parms.GameplayStats = std::move(GameplayStats);
	Parms.bUseTrackedStat = bUseTrackedStat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionXPSet.OnRep_CurrentLevel
// (Final, Native, Public)

void UOrionXPSet::OnRep_CurrentLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionXPSet", "OnRep_CurrentLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionXPSet.OnRep_CurrentTotalCardXP
// (Final, Native, Public)

void UOrionXPSet::OnRep_CurrentTotalCardXP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionXPSet", "OnRep_CurrentTotalCardXP");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameplayVolumeComponent.ApplyEffects
// (Native, Public, BlueprintCallable)

void UOrionGameplayVolumeComponent::ApplyEffects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayVolumeComponent", "ApplyEffects");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameplayVolumeComponent.CanStillApplyEffectsToTargets
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionGameplayVolumeComponent::CanStillApplyEffectsToTargets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayVolumeComponent", "CanStillApplyEffectsToTargets");

	Params::OrionGameplayVolumeComponent_CanStillApplyEffectsToTargets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameplayVolumeComponent.DisableGameplayVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ResetInternalState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionGameplayVolumeComponent::DisableGameplayVolume(bool ResetInternalState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayVolumeComponent", "DisableGameplayVolume");

	Params::OrionGameplayVolumeComponent_DisableGameplayVolume Parms{};

	Parms.ResetInternalState = ResetInternalState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameplayVolumeComponent.EnableGameplayVolume
// (Final, Native, Public, BlueprintCallable)

void UOrionGameplayVolumeComponent::EnableGameplayVolume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayVolumeComponent", "EnableGameplayVolume");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameplayVolumeComponent.EnableLinkedCollisionViaPrimitive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UPrimitiveComponent*>      LinkedPrimitives                                       (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bEnablePrimitiveOverlap                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionGameplayVolumeComponent::EnableLinkedCollisionViaPrimitive(const TArray<class UPrimitiveComponent*>& LinkedPrimitives, bool bEnablePrimitiveOverlap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayVolumeComponent", "EnableLinkedCollisionViaPrimitive");

	Params::OrionGameplayVolumeComponent_EnableLinkedCollisionViaPrimitive Parms{};

	Parms.LinkedPrimitives = std::move(LinkedPrimitives);
	Parms.bEnablePrimitiveOverlap = bEnablePrimitiveOverlap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameplayVolumeComponent.EnableLinkedCollisionViaTags
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            LinkedVolumeTag                                        (Parm, NativeAccessSpecifierPublic)
// bool                                    bEnablePrimitiveOverlap                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionGameplayVolumeComponent::EnableLinkedCollisionViaTags(const struct FGameplayTagContainer& LinkedVolumeTag, bool bEnablePrimitiveOverlap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayVolumeComponent", "EnableLinkedCollisionViaTags");

	Params::OrionGameplayVolumeComponent_EnableLinkedCollisionViaTags Parms{};

	Parms.LinkedVolumeTag = std::move(LinkedVolumeTag);
	Parms.bEnablePrimitiveOverlap = bEnablePrimitiveOverlap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameplayVolumeComponent.GetNumAppliedEffectsLeftToApply
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOrionGameplayVolumeComponent::GetNumAppliedEffectsLeftToApply()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayVolumeComponent", "GetNumAppliedEffectsLeftToApply");

	Params::OrionGameplayVolumeComponent_GetNumAppliedEffectsLeftToApply Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameplayVolumeComponent.HandleMatchStarted
// (Final, Native, Public)

void UOrionGameplayVolumeComponent::HandleMatchStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayVolumeComponent", "HandleMatchStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameplayVolumeComponent.IsValidTarget
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionGameplayVolumeComponent::IsValidTarget(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayVolumeComponent", "IsValidTarget");

	Params::OrionGameplayVolumeComponent_IsValidTarget Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameplayVolumeComponent.OnBeginOverlapCallback
// (Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UOrionGameplayVolumeComponent::OnBeginOverlapCallback(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayVolumeComponent", "OnBeginOverlapCallback");

	Params::OrionGameplayVolumeComponent_OnBeginOverlapCallback Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameplayVolumeComponent.OnEndOverlapCallback
// (Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionGameplayVolumeComponent::OnEndOverlapCallback(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayVolumeComponent", "OnEndOverlapCallback");

	Params::OrionGameplayVolumeComponent_OnEndOverlapCallback Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameplayVolumeComponent.OnOwnerChangedDimension
// (Final, Native, Public)
// Parameters:
// class AOrionChar*                       CharInChangedDimension                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionGameplayVolumeComponent::OnOwnerChangedDimension(class AOrionChar* CharInChangedDimension)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayVolumeComponent", "OnOwnerChangedDimension");

	Params::OrionGameplayVolumeComponent_OnOwnerChangedDimension Parms{};

	Parms.CharInChangedDimension = CharInChangedDimension;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameplayVolumeComponent.OnRep_NumGameplayEffectsApplied
// (Final, Native, Public)

void UOrionGameplayVolumeComponent::OnRep_NumGameplayEffectsApplied()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayVolumeComponent", "OnRep_NumGameplayEffectsApplied");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameplayVolumeComponent.ProcessLinkedBeginOverlapCallback
// (Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UOrionGameplayVolumeComponent::ProcessLinkedBeginOverlapCallback(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayVolumeComponent", "ProcessLinkedBeginOverlapCallback");

	Params::OrionGameplayVolumeComponent_ProcessLinkedBeginOverlapCallback Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameplayVolumeComponent.ProcessLinkedEndOverlapCallback
// (Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionGameplayVolumeComponent::ProcessLinkedEndOverlapCallback(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayVolumeComponent", "ProcessLinkedEndOverlapCallback");

	Params::OrionGameplayVolumeComponent_ProcessLinkedEndOverlapCallback Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.HoverDronePawn.GetAltitude
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AHoverDronePawn::GetAltitude() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HoverDronePawn", "GetAltitude");

	Params::HoverDronePawn_GetAltitude Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.HoverDronePawn.IsMaintainingConstantAltitude
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHoverDronePawn::IsMaintainingConstantAltitude() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HoverDronePawn", "IsMaintainingConstantAltitude");

	Params::HoverDronePawn_IsMaintainingConstantAltitude Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.HUDAlertAsset.GetAlertText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UHUDAlertAsset::GetAlertText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HUDAlertAsset", "GetAlertText");

	Params::HUDAlertAsset_GetAlertText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameState_Base.AnnouncerSay
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           SoundInstigator                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Ident                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameState_Base::AnnouncerSay(class AActor* SoundInstigator, const class FString& Ident)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_Base", "AnnouncerSay");

	Params::OrionGameState_Base_AnnouncerSay Parms{};

	Parms.SoundInstigator = SoundInstigator;
	Parms.Ident = std::move(Ident);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_Base.ExecuteGameplayCue
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// struct FGameplayTag                     GameplayCueTag                                         (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           CueParameters                                          (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameState_Base::ExecuteGameplayCue(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& CueParameters, class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_Base", "ExecuteGameplayCue");

	Params::OrionGameState_Base_ExecuteGameplayCue Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.CueParameters = std::move(CueParameters);
	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_Base.OnRep_CheatFlags
// (Final, Native, Public)

void AOrionGameState_Base::OnRep_CheatFlags()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_Base", "OnRep_CheatFlags");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_Base.OnRep_EnableRootMotionSources
// (Final, Native, Private)

void AOrionGameState_Base::OnRep_EnableRootMotionSources()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_Base", "OnRep_EnableRootMotionSources");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_Base.OnRep_GameSessionID
// (Native, Protected)

void AOrionGameState_Base::OnRep_GameSessionID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_Base", "OnRep_GameSessionID");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_Base.OnRep_PlaylistId
// (Native, Protected)

void AOrionGameState_Base::OnRep_PlaylistId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_Base", "OnRep_PlaylistId");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_Base.OnRep_SecondsUntilMatchBegins
// (Native, Protected)

void AOrionGameState_Base::OnRep_SecondsUntilMatchBegins()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_Base", "OnRep_SecondsUntilMatchBegins");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_Base.OnRep_SecondsUntilPlayerTimeout
// (Native, Protected)

void AOrionGameState_Base::OnRep_SecondsUntilPlayerTimeout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_Base", "OnRep_SecondsUntilPlayerTimeout");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_Base.OnRep_SessionRegistrationLocked
// (Native, Protected)

void AOrionGameState_Base::OnRep_SessionRegistrationLocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_Base", "OnRep_SessionRegistrationLocked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_Base.OnRep_Teams
// (Native, Protected)

void AOrionGameState_Base::OnRep_Teams()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_Base", "OnRep_Teams");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_Base.AreRootMotionSourcesEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionGameState_Base::AreRootMotionSourcesEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_Base", "AreRootMotionSourcesEnabled");

	Params::OrionGameState_Base_AreRootMotionSourcesEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameState_Base.GetTeamByIndex
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionTeam                              TeamIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOrionTeamInfo*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOrionTeamInfo* AOrionGameState_Base::GetTeamByIndex(EOrionTeam TeamIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_Base", "GetTeamByIndex");

	Params::OrionGameState_Base_GetTeamByIndex Parms{};

	Parms.TeamIndex = TeamIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCPPHeroBaseAnimInstance.AnimNotify_EnteredDefaultIdle
// (Final, Native, Public)
// Parameters:
// class UAnimNotify*                      Notify                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCPPHeroBaseAnimInstance::AnimNotify_EnteredDefaultIdle(const class UAnimNotify* Notify)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCPPHeroBaseAnimInstance", "AnimNotify_EnteredDefaultIdle");

	Params::OrionCPPHeroBaseAnimInstance_AnimNotify_EnteredDefaultIdle Parms{};

	Parms.Notify = Notify;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBaseHeroAnimInstance.AnimNotify_EnteredIdle
// (Final, Native, Public)
// Parameters:
// class UAnimNotify*                      Notify                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionBaseHeroAnimInstance::AnimNotify_EnteredIdle(const class UAnimNotify* Notify)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseHeroAnimInstance", "AnimNotify_EnteredIdle");

	Params::OrionBaseHeroAnimInstance_AnimNotify_EnteredIdle Parms{};

	Parms.Notify = Notify;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBaseHeroAnimInstance.AnimNotify_EnteredTurnInPlace
// (Final, Native, Public)
// Parameters:
// class UAnimNotify*                      Notify                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionBaseHeroAnimInstance::AnimNotify_EnteredTurnInPlace(const class UAnimNotify* Notify)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseHeroAnimInstance", "AnimNotify_EnteredTurnInPlace");

	Params::OrionBaseHeroAnimInstance_AnimNotify_EnteredTurnInPlace Parms{};

	Parms.Notify = Notify;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBaseHeroAnimInstance.AnimNotify_ExitedIdle
// (Final, Native, Public)
// Parameters:
// class UAnimNotify*                      Notify                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionBaseHeroAnimInstance::AnimNotify_ExitedIdle(const class UAnimNotify* Notify)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseHeroAnimInstance", "AnimNotify_ExitedIdle");

	Params::OrionBaseHeroAnimInstance_AnimNotify_ExitedIdle Parms{};

	Parms.Notify = Notify;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBaseHeroAnimInstance.AnimNotify_ExitedTurnInPlace
// (Final, Native, Public)
// Parameters:
// class UAnimNotify*                      Notify                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionBaseHeroAnimInstance::AnimNotify_ExitedTurnInPlace(const class UAnimNotify* Notify)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseHeroAnimInstance", "AnimNotify_ExitedTurnInPlace");

	Params::OrionBaseHeroAnimInstance_AnimNotify_ExitedTurnInPlace Parms{};

	Parms.Notify = Notify;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBaseHeroAnimInstance.AnimNotify_HitReactEnd
// (Final, Native, Public)
// Parameters:
// class UAnimNotify*                      Notify                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionBaseHeroAnimInstance::AnimNotify_HitReactEnd(const class UAnimNotify* Notify)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseHeroAnimInstance", "AnimNotify_HitReactEnd");

	Params::OrionBaseHeroAnimInstance_AnimNotify_HitReactEnd Parms{};

	Parms.Notify = Notify;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBaseHeroAnimInstance.AnimNotify_IdleToJog
// (Final, Native, Public)
// Parameters:
// class UAnimNotify*                      Notify                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionBaseHeroAnimInstance::AnimNotify_IdleToJog(const class UAnimNotify* Notify)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseHeroAnimInstance", "AnimNotify_IdleToJog");

	Params::OrionBaseHeroAnimInstance_AnimNotify_IdleToJog Parms{};

	Parms.Notify = Notify;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBaseHeroAnimInstance.AnimNotify_JogToIdle
// (Final, Native, Public)
// Parameters:
// class UAnimNotify*                      Notify                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionBaseHeroAnimInstance::AnimNotify_JogToIdle(const class UAnimNotify* Notify)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseHeroAnimInstance", "AnimNotify_JogToIdle");

	Params::OrionBaseHeroAnimInstance_AnimNotify_JogToIdle Parms{};

	Parms.Notify = Notify;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBaseHeroAnimInstance.AnimNotify_JumpExit
// (Final, Native, Public)
// Parameters:
// class UAnimNotify*                      Notify                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionBaseHeroAnimInstance::AnimNotify_JumpExit(const class UAnimNotify* Notify)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseHeroAnimInstance", "AnimNotify_JumpExit");

	Params::OrionBaseHeroAnimInstance_AnimNotify_JumpExit Parms{};

	Parms.Notify = Notify;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBaseHeroAnimInstance.AnimNotify_JumpLandingExit
// (Final, Native, Public)
// Parameters:
// class UAnimNotify*                      Notify                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionBaseHeroAnimInstance::AnimNotify_JumpLandingExit(const class UAnimNotify* Notify)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseHeroAnimInstance", "AnimNotify_JumpLandingExit");

	Params::OrionBaseHeroAnimInstance_AnimNotify_JumpLandingExit Parms{};

	Parms.Notify = Notify;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBaseHeroAnimInstance.AnimNotify_MeleeFullBody
// (Final, Native, Public)
// Parameters:
// class UAnimNotify*                      Notify                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionBaseHeroAnimInstance::AnimNotify_MeleeFullBody(const class UAnimNotify* Notify)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseHeroAnimInstance", "AnimNotify_MeleeFullBody");

	Params::OrionBaseHeroAnimInstance_AnimNotify_MeleeFullBody Parms{};

	Parms.Notify = Notify;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBaseHeroAnimInstance.AnimNotify_MeleeUpperBody
// (Final, Native, Public)
// Parameters:
// class UAnimNotify*                      Notify                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionBaseHeroAnimInstance::AnimNotify_MeleeUpperBody(const class UAnimNotify* Notify)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseHeroAnimInstance", "AnimNotify_MeleeUpperBody");

	Params::OrionBaseHeroAnimInstance_AnimNotify_MeleeUpperBody Parms{};

	Parms.Notify = Notify;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionInputHandlerWidget.HandleRequestedInput
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputEvent                             EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IOrionInputHandlerWidget::HandleRequestedInput(const struct FKey& Key, EInputEvent EventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionInputHandlerWidget", "HandleRequestedInput");

	Params::OrionInputHandlerWidget_HandleRequestedInput Parms{};

	Parms.Key = std::move(Key);
	Parms.EventType = EventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionProjectile.AddGameplayCueLocal
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     GameplayCueTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Parameters                                             (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AOrionProjectile::AddGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Parameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "AddGameplayCueLocal");

	Params::OrionProjectile_AddGameplayCueLocal Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.Parameters = std::move(Parameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionProjectile.DestroyActorReplicated
// (Net, Native, Event, NetMulticast, Protected)

void AOrionProjectile::DestroyActorReplicated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "DestroyActorReplicated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionProjectile.EndTimeDilation
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   WhichDilationChannel                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LerpOutSeconds                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Delay                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionProjectile::EndTimeDilation(const int32 WhichDilationChannel, const float LerpOutSeconds, const float Delay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "EndTimeDilation");

	Params::OrionProjectile_EndTimeDilation Parms{};

	Parms.WhichDilationChannel = WhichDilationChannel;
	Parms.LerpOutSeconds = LerpOutSeconds;
	Parms.Delay = Delay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionProjectile.ExecuteGameplayCueLocal
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     GameplayCueTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Parameters                                             (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AOrionProjectile::ExecuteGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Parameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "ExecuteGameplayCueLocal");

	Params::OrionProjectile_ExecuteGameplayCueLocal Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.Parameters = std::move(Parameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionProjectile.Explode
// (Native, Protected, BlueprintCallable)

void AOrionProjectile::Explode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "Explode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionProjectile.HandleHomingEnterPhaseShift
// (Final, Native, Protected)
// Parameters:
// class AOrionChar*                       PhaseShifedChar                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionProjectile::HandleHomingEnterPhaseShift(class AOrionChar* PhaseShifedChar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "HandleHomingEnterPhaseShift");

	Params::OrionProjectile_HandleHomingEnterPhaseShift Parms{};

	Parms.PhaseShifedChar = PhaseShifedChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionProjectile.K2_InitProjectileFilters
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           InInstigator                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InSource                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayAbility*                 InAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionProjectile::K2_InitProjectileFilters(class AActor* InInstigator, class AActor* InSource, float InLevel, class UGameplayAbility* InAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "K2_InitProjectileFilters");

	Params::OrionProjectile_K2_InitProjectileFilters Parms{};

	Parms.InInstigator = InInstigator;
	Parms.InSource = InSource;
	Parms.InLevel = InLevel;
	Parms.InAbility = InAbility;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function OrionGame.OrionProjectile.NetSync_HitActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FHitResult                       Hit                                                    (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// int32                                   UserStateID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSyncClientToServerPosAndVel                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionProjectile::NetSync_HitActor(const struct FHitResult& Hit, int32 UserStateID, bool bSyncClientToServerPosAndVel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "NetSync_HitActor");

	Params::OrionProjectile_NetSync_HitActor Parms{};

	Parms.Hit = std::move(Hit);
	Parms.UserStateID = UserStateID;
	Parms.bSyncClientToServerPosAndVel = bSyncClientToServerPosAndVel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionProjectile.NetSync_SetNewTarget
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           NewTargetActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewSourceLocation                                      (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewTargetLocation                                      (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UserStateID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSyncClientToServerPosAndVel                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionProjectile::NetSync_SetNewTarget(class AActor* NewTargetActor, const struct FVector& NewSourceLocation, const struct FVector& NewTargetLocation, int32 UserStateID, bool bSyncClientToServerPosAndVel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "NetSync_SetNewTarget");

	Params::OrionProjectile_NetSync_SetNewTarget Parms{};

	Parms.NewTargetActor = NewTargetActor;
	Parms.NewSourceLocation = std::move(NewSourceLocation);
	Parms.NewTargetLocation = std::move(NewTargetLocation);
	Parms.UserStateID = UserStateID;
	Parms.bSyncClientToServerPosAndVel = bSyncClientToServerPosAndVel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionProjectile.NetSync_WorldCollision
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          ImpactVelocity                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InWorldCollisionCount                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSyncClientToServerPosAndVel                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionProjectile::NetSync_WorldCollision(const struct FHitResult& Hit, const struct FVector& ImpactVelocity, const int32 InWorldCollisionCount, bool bSyncClientToServerPosAndVel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "NetSync_WorldCollision");

	Params::OrionProjectile_NetSync_WorldCollision Parms{};

	Parms.Hit = std::move(Hit);
	Parms.ImpactVelocity = std::move(ImpactVelocity);
	Parms.InWorldCollisionCount = InWorldCollisionCount;
	Parms.bSyncClientToServerPosAndVel = bSyncClientToServerPosAndVel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionProjectile.OnActorDestroy
// (Final, Native, Protected)
// Parameters:
// class AActor*                           DestroyedActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionProjectile::OnActorDestroy(class AActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "OnActorDestroy");

	Params::OrionProjectile_OnActorDestroy Parms{};

	Parms.DestroyedActor = DestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionProjectile.OnAutoDestroy
// (Event, Protected, BlueprintEvent)

void AOrionProjectile::OnAutoDestroy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "OnAutoDestroy");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionProjectile.OnBounce
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AOrionProjectile::OnBounce(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "OnBounce");

	Params::OrionProjectile_OnBounce Parms{};

	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionProjectile.OnBounceCallback
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          ImpactVelocity                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionProjectile::OnBounceCallback(const struct FHitResult& Hit, const struct FVector& ImpactVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "OnBounceCallback");

	Params::OrionProjectile_OnBounceCallback Parms{};

	Parms.Hit = std::move(Hit);
	Parms.ImpactVelocity = std::move(ImpactVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionProjectile.OnBounceCallbackInternal
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          ImpactVelocity                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InNewWorldCollisionCount                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionProjectile::OnBounceCallbackInternal(const struct FHitResult& Hit, const struct FVector& ImpactVelocity, const int32 InNewWorldCollisionCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "OnBounceCallbackInternal");

	Params::OrionProjectile_OnBounceCallbackInternal Parms{};

	Parms.Hit = std::move(Hit);
	Parms.ImpactVelocity = std::move(ImpactVelocity);
	Parms.InNewWorldCollisionCount = InNewWorldCollisionCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionProjectile.OnCloned
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           InNewInstigator                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InNewSourceActor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOrionProjectile*                 SourceProjectile                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionProjectileMovementComponent*SourceMovementComponent                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionProjectile::OnCloned(class AActor* InNewInstigator, class AActor* InNewSourceActor, class AOrionProjectile* SourceProjectile, class UOrionProjectileMovementComponent* SourceMovementComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "OnCloned");

	Params::OrionProjectile_OnCloned Parms{};

	Parms.InNewInstigator = InNewInstigator;
	Parms.InNewSourceActor = InNewSourceActor;
	Parms.SourceProjectile = SourceProjectile;
	Parms.SourceMovementComponent = SourceMovementComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionProjectile.OnCustomHit
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// EProjectileCustomHitResponseType        ProjectileCustomHitResponseType                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConsumeEvent                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConsumeDestroy                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionProjectile::OnCustomHit(const struct FHitResult& Hit, EProjectileCustomHitResponseType ProjectileCustomHitResponseType, bool* bConsumeEvent, bool* bConsumeDestroy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "OnCustomHit");

	Params::OrionProjectile_OnCustomHit Parms{};

	Parms.Hit = std::move(Hit);
	Parms.ProjectileCustomHitResponseType = ProjectileCustomHitResponseType;

	UObject::ProcessEvent(Func, &Parms);

	if (bConsumeEvent != nullptr)
		*bConsumeEvent = Parms.bConsumeEvent;

	if (bConsumeDestroy != nullptr)
		*bConsumeDestroy = Parms.bConsumeDestroy;
}


// Function OrionGame.OrionProjectile.OnExplode
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<class AActor*>                   EffectedActors                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AOrionProjectile::OnExplode(const TArray<class AActor*>& EffectedActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "OnExplode");

	Params::OrionProjectile_OnExplode Parms{};

	Parms.EffectedActors = std::move(EffectedActors);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionProjectile.OnHitActor
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AOrionProjectile::OnHitActor(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "OnHitActor");

	Params::OrionProjectile_OnHitActor Parms{};

	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionProjectile.OnMaxRangeCallback
// (Final, Native, Protected)

void AOrionProjectile::OnMaxRangeCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "OnMaxRangeCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionProjectile.OnNetSync_HitActor
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FHitResult                       Hit                                                    (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// int32                                   UserStateID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionProjectile::OnNetSync_HitActor(const struct FHitResult& Hit, int32 UserStateID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "OnNetSync_HitActor");

	Params::OrionProjectile_OnNetSync_HitActor Parms{};

	Parms.Hit = std::move(Hit);
	Parms.UserStateID = UserStateID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionProjectile.OnNetSync_SetNewTarget
// (Event, Protected, HasDefaults, BlueprintEvent)
// Parameters:
// class AActor*                           NewTargetActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewSourceLocation                                      (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewTargetLocation                                      (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UserStateID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionProjectile::OnNetSync_SetNewTarget(class AActor* NewTargetActor, const struct FVector& NewSourceLocation, const struct FVector& NewTargetLocation, int32 UserStateID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "OnNetSync_SetNewTarget");

	Params::OrionProjectile_OnNetSync_SetNewTarget Parms{};

	Parms.NewTargetActor = NewTargetActor;
	Parms.NewSourceLocation = std::move(NewSourceLocation);
	Parms.NewTargetLocation = std::move(NewTargetLocation);
	Parms.UserStateID = UserStateID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionProjectile.OnNetSync_WorldCollision
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// int32                                   InWorldCollisionCount                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          ImpactVelocity                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionProjectile::OnNetSync_WorldCollision(const int32 InWorldCollisionCount, const struct FHitResult& Hit, const struct FVector& ImpactVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "OnNetSync_WorldCollision");

	Params::OrionProjectile_OnNetSync_WorldCollision Parms{};

	Parms.InWorldCollisionCount = InWorldCollisionCount;
	Parms.Hit = std::move(Hit);
	Parms.ImpactVelocity = std::move(ImpactVelocity);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionProjectile.OnNotifyRange
// (Event, Protected, BlueprintEvent)

void AOrionProjectile::OnNotifyRange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "OnNotifyRange");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionProjectile.OnNotifyTime
// (Event, Protected, BlueprintEvent)

void AOrionProjectile::OnNotifyTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "OnNotifyTime");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionProjectile.OnOverlapCallback
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AOrionProjectile::OnOverlapCallback(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "OnOverlapCallback");

	Params::OrionProjectile_OnOverlapCallback Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionProjectile.OnOverlappedLockOnActor
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           PreviousLockOnActor                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionProjectile::OnOverlappedLockOnActor(class AActor* PreviousLockOnActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "OnOverlappedLockOnActor");

	Params::OrionProjectile_OnOverlappedLockOnActor Parms{};

	Parms.PreviousLockOnActor = PreviousLockOnActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionProjectile.OnRep_LockOnActor
// (Final, Native, Protected)

void AOrionProjectile::OnRep_LockOnActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "OnRep_LockOnActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionProjectile.OnRep_Shooter
// (Final, Native, Protected)

void AOrionProjectile::OnRep_Shooter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "OnRep_Shooter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionProjectile.OnShutdown
// (Event, Protected, BlueprintEvent)

void AOrionProjectile::OnShutdown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "OnShutdown");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionProjectile.OnStop
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AOrionProjectile::OnStop(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "OnStop");

	Params::OrionProjectile_OnStop Parms{};

	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionProjectile.OnStopCallback
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AOrionProjectile::OnStopCallback(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "OnStopCallback");

	Params::OrionProjectile_OnStopCallback Parms{};

	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionProjectile.OnVelocityReversed
// (Event, Protected, BlueprintEvent)

void AOrionProjectile::OnVelocityReversed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "OnVelocityReversed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionProjectile.OnVelocityReversedCallback
// (Final, Native, Protected)

void AOrionProjectile::OnVelocityReversedCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "OnVelocityReversedCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction OrionGame.OrionProjectile.ProjectileHitDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AOrionProjectile::ProjectileHitDelegate__DelegateSignature(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "ProjectileHitDelegate__DelegateSignature");

	Params::OrionProjectile_ProjectileHitDelegate__DelegateSignature Parms{};

	Parms.HitResult = std::move(HitResult);

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction OrionGame.OrionProjectile.ProjectileShutdownDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void AOrionProjectile::ProjectileShutdownDelegate__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "ProjectileShutdownDelegate__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionProjectile.RemoveGameplayCueLocal
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     GameplayCueTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Parameters                                             (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AOrionProjectile::RemoveGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Parameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "RemoveGameplayCueLocal");

	Params::OrionProjectile_RemoveGameplayCueLocal Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.Parameters = std::move(Parameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionProjectile.SetAutoDestroyTime
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionProjectile::SetAutoDestroyTime(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "SetAutoDestroyTime");

	Params::OrionProjectile_SetAutoDestroyTime Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionProjectile.SetExplosionFilterAndEffectsContainer
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOrionFilterAndEffectsContainer  NewFilterContainer                                     (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AOrionProjectile::SetExplosionFilterAndEffectsContainer(struct FOrionFilterAndEffectsContainer& NewFilterContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "SetExplosionFilterAndEffectsContainer");

	Params::OrionProjectile_SetExplosionFilterAndEffectsContainer Parms{};

	Parms.NewFilterContainer = std::move(NewFilterContainer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	NewFilterContainer = std::move(Parms.NewFilterContainer);
}


// Function OrionGame.OrionProjectile.SetHitFilterAndEffectsContainter
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOrionFilterAndEffectsContainer  NewFilterContainer                                     (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AOrionProjectile::SetHitFilterAndEffectsContainter(struct FOrionFilterAndEffectsContainer& NewFilterContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "SetHitFilterAndEffectsContainter");

	Params::OrionProjectile_SetHitFilterAndEffectsContainter Parms{};

	Parms.NewFilterContainer = std::move(NewFilterContainer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	NewFilterContainer = std::move(Parms.NewFilterContainer);
}


// Function OrionGame.OrionProjectile.SetLockOnActor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InHomingOffset                                         (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionProjectile::SetLockOnActor(class AActor* Actor, const struct FVector& InHomingOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "SetLockOnActor");

	Params::OrionProjectile_SetLockOnActor Parms{};

	Parms.Actor = Actor;
	Parms.InHomingOffset = std::move(InHomingOffset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionProjectile.SetNotifyRange
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   Range_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionProjectile::SetNotifyRange(float Range_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "SetNotifyRange");

	Params::OrionProjectile_SetNotifyRange Parms{};

	Parms.Range_0 = Range_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionProjectile.SetNotifyTime
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionProjectile::SetNotifyTime(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "SetNotifyTime");

	Params::OrionProjectile_SetNotifyTime Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionProjectile.SetTargetingTagRequirements
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTagRequirements         InTargetingTagRequirements                             (Parm, NativeAccessSpecifierPublic)

void AOrionProjectile::SetTargetingTagRequirements(const struct FGameplayTagRequirements& InTargetingTagRequirements)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "SetTargetingTagRequirements");

	Params::OrionProjectile_SetTargetingTagRequirements Parms{};

	Parms.InTargetingTagRequirements = std::move(InTargetingTagRequirements);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionProjectile.StartTimeDilation
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   WhichDilationChannel                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TargetDilation                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LerpInSeconds                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LerpOutSeconds                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Opt_StartDilation                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionProjectile::StartTimeDilation(const int32 WhichDilationChannel, const float TargetDilation, const float LerpInSeconds, const float Duration, const float LerpOutSeconds, const float Opt_StartDilation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "StartTimeDilation");

	Params::OrionProjectile_StartTimeDilation Parms{};

	Parms.WhichDilationChannel = WhichDilationChannel;
	Parms.TargetDilation = TargetDilation;
	Parms.LerpInSeconds = LerpInSeconds;
	Parms.Duration = Duration;
	Parms.LerpOutSeconds = LerpOutSeconds;
	Parms.Opt_StartDilation = Opt_StartDilation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionProjectile.SyncHitActor
// (Final, Net, Native, Event, NetMulticast, Private, HasDefaults)
// Parameters:
// struct FHitResult                       Hit                                                    (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// int32                                   UserStateID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ServerPosition                                         (ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ServerVelocity                                         (ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionProjectile::SyncHitActor(const struct FHitResult& Hit, int32 UserStateID, const struct FVector& ServerPosition, const struct FVector& ServerVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "SyncHitActor");

	Params::OrionProjectile_SyncHitActor Parms{};

	Parms.Hit = std::move(Hit);
	Parms.UserStateID = UserStateID;
	Parms.ServerPosition = std::move(ServerPosition);
	Parms.ServerVelocity = std::move(ServerVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionProjectile.SyncSetNewTarget
// (Final, Net, Native, Event, NetMulticast, Private, HasDefaults)
// Parameters:
// class AActor*                           NewTargetActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewSourceLocation                                      (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewTargetLocation                                      (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UserStateID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ServerPosition                                         (ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ServerVelocity                                         (ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionProjectile::SyncSetNewTarget(class AActor* NewTargetActor, const struct FVector& NewSourceLocation, const struct FVector& NewTargetLocation, int32 UserStateID, const struct FVector& ServerPosition, const struct FVector& ServerVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "SyncSetNewTarget");

	Params::OrionProjectile_SyncSetNewTarget Parms{};

	Parms.NewTargetActor = NewTargetActor;
	Parms.NewSourceLocation = std::move(NewSourceLocation);
	Parms.NewTargetLocation = std::move(NewTargetLocation);
	Parms.UserStateID = UserStateID;
	Parms.ServerPosition = std::move(ServerPosition);
	Parms.ServerVelocity = std::move(ServerVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionProjectile.SyncStartTimeDilation
// (Final, Net, Native, Event, NetMulticast, Private, HasDefaults)
// Parameters:
// struct FVector                          ServerPosition                                         (ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ServerVelocity                                         (ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   WhichDilationChannel                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TargetDilation                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LerpInSeconds                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LerpOutSeconds                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Opt_StartDilation                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionProjectile::SyncStartTimeDilation(const struct FVector& ServerPosition, const struct FVector& ServerVelocity, const int32 WhichDilationChannel, const float TargetDilation, const float LerpInSeconds, const float Duration, const float LerpOutSeconds, const float Opt_StartDilation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "SyncStartTimeDilation");

	Params::OrionProjectile_SyncStartTimeDilation Parms{};

	Parms.ServerPosition = std::move(ServerPosition);
	Parms.ServerVelocity = std::move(ServerVelocity);
	Parms.WhichDilationChannel = WhichDilationChannel;
	Parms.TargetDilation = TargetDilation;
	Parms.LerpInSeconds = LerpInSeconds;
	Parms.Duration = Duration;
	Parms.LerpOutSeconds = LerpOutSeconds;
	Parms.Opt_StartDilation = Opt_StartDilation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionProjectile.SyncTimeDilationArrivedAtTarget
// (Final, Net, Native, Event, NetMulticast, Private, HasDefaults)
// Parameters:
// int32                                   WhichDilationChannel                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ServerPosition                                         (ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ServerVelocity                                         (ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionProjectile::SyncTimeDilationArrivedAtTarget(const int32 WhichDilationChannel, const struct FVector& ServerPosition, const struct FVector& ServerVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "SyncTimeDilationArrivedAtTarget");

	Params::OrionProjectile_SyncTimeDilationArrivedAtTarget Parms{};

	Parms.WhichDilationChannel = WhichDilationChannel;
	Parms.ServerPosition = std::move(ServerPosition);
	Parms.ServerVelocity = std::move(ServerVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionProjectile.SyncWorldCollision
// (Final, Net, Native, Event, NetMulticast, Private, HasDefaults)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          ImpactVelocity                                         (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InWorldCollisionCount                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ServerPosition                                         (ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ServerVelocity                                         (ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionProjectile::SyncWorldCollision(const struct FHitResult& Hit, const struct FVector& ImpactVelocity, const int32 InWorldCollisionCount, const struct FVector& ServerPosition, const struct FVector& ServerVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "SyncWorldCollision");

	Params::OrionProjectile_SyncWorldCollision Parms{};

	Parms.Hit = std::move(Hit);
	Parms.ImpactVelocity = std::move(ImpactVelocity);
	Parms.InWorldCollisionCount = InWorldCollisionCount;
	Parms.ServerPosition = std::move(ServerPosition);
	Parms.ServerVelocity = std::move(ServerVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionProjectile.GetNotifyRange
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionProjectile::GetNotifyRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "GetNotifyRange");

	Params::OrionProjectile_GetNotifyRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionProjectile.GetTeamNum
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// EOrionTeam                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOrionTeam AOrionProjectile::GetTeamNum() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectile", "GetTeamNum");

	Params::OrionProjectile_GetTeamNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.MessageOfTheDay.GetMessageOfTheDay
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UMessageOfTheDay*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMessageOfTheDay* UMessageOfTheDay::GetMessageOfTheDay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageOfTheDay", "GetMessageOfTheDay");

	Params::MessageOfTheDay_GetMessageOfTheDay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.MessageOfTheDay.ShouldShowMOTD
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMessageOfTheDay::ShouldShowMOTD() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MessageOfTheDay", "ShouldShowMOTD");

	Params::MessageOfTheDay_ShouldShowMOTD Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbility.BeginAura
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FOrionFilterAndEffectsContainer  FilterAndEffectsContainers                             (Parm, NativeAccessSpecifierPublic)
// struct FOrionFilterAndEffectsContainer  PeriodicFilterAndEffectsContainers                     (Parm, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FScalableFloat                   Period                                                 (Parm, NativeAccessSpecifierPublic)
// bool                                    ReapplyEffectOnRemoval                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    EndWhenAbilityEnds                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FOrionAuraHandle                 ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FOrionAuraHandle UOrionAbility::BeginAura(const struct FOrionFilterAndEffectsContainer& FilterAndEffectsContainers, const struct FOrionFilterAndEffectsContainer& PeriodicFilterAndEffectsContainers, float Radius, const struct FScalableFloat& Period, bool ReapplyEffectOnRemoval, bool EndWhenAbilityEnds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "BeginAura");

	Params::OrionAbility_BeginAura Parms{};

	Parms.FilterAndEffectsContainers = std::move(FilterAndEffectsContainers);
	Parms.PeriodicFilterAndEffectsContainers = std::move(PeriodicFilterAndEffectsContainers);
	Parms.Radius = Radius;
	Parms.Period = std::move(Period);
	Parms.ReapplyEffectOnRemoval = ReapplyEffectOnRemoval;
	Parms.EndWhenAbilityEnds = EndWhenAbilityEnds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbility.BlockMovementInput
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bResetOnDeath                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAbility::BlockMovementInput(bool bResetOnDeath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "BlockMovementInput");

	Params::OrionAbility_BlockMovementInput Parms{};

	Parms.bResetOnDeath = bResetOnDeath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility.BP_ApplyGameplayEffectToOwner_Cached
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UGameplayEffect>      GameplayEffectClass                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActiveGameplayEffectHandle      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FActiveGameplayEffectHandle UOrionAbility::BP_ApplyGameplayEffectToOwner_Cached(TSubclassOf<class UGameplayEffect> GameplayEffectClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "BP_ApplyGameplayEffectToOwner_Cached");

	Params::OrionAbility_BP_ApplyGameplayEffectToOwner_Cached Parms{};

	Parms.GameplayEffectClass = GameplayEffectClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbility.BP_CommitConsumableStack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    BroadcastCommitEvent                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAbility::BP_CommitConsumableStack(bool BroadcastCommitEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "BP_CommitConsumableStack");

	Params::OrionAbility_BP_CommitConsumableStack Parms{};

	Parms.BroadcastCommitEvent = BroadcastCommitEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility.BP_GetCachedGameplayEffeectSpec
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UGameplayEffect>      GameplayEffectClass                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectSpecHandle        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayEffectSpecHandle UOrionAbility::BP_GetCachedGameplayEffeectSpec(TSubclassOf<class UGameplayEffect> GameplayEffectClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "BP_GetCachedGameplayEffeectSpec");

	Params::OrionAbility_BP_GetCachedGameplayEffeectSpec Parms{};

	Parms.GameplayEffectClass = GameplayEffectClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbility.CancelCombo
// (Final, Native, Public, BlueprintCallable)

void UOrionAbility::CancelCombo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "CancelCombo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility.ChangeActivationGroup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionAbilityActivationGroup            NewGroup                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAbility::ChangeActivationGroup(EOrionAbilityActivationGroup NewGroup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "ChangeActivationGroup");

	Params::OrionAbility_ChangeActivationGroup Parms{};

	Parms.NewGroup = NewGroup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility.ClearCameraMode
// (Final, Native, Public, BlueprintCallable)

void UOrionAbility::ClearCameraMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "ClearCameraMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility.ClearLookAtActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionAbility::ClearLookAtActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "ClearLookAtActor");

	Params::OrionAbility_ClearLookAtActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbility.DisableAbilityQueuing
// (Final, Native, Public, BlueprintCallable)

void UOrionAbility::DisableAbilityQueuing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "DisableAbilityQueuing");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility.EnableAbilityQueuing
// (Final, Native, Public, BlueprintCallable)

void UOrionAbility::EnableAbilityQueuing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "EnableAbilityQueuing");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility.EndAura
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FOrionAuraHandle                 Handle                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAbility::EndAura(const struct FOrionAuraHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "EndAura");

	Params::OrionAbility_EndAura Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility.GetExternalAbilityLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     AbilityTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOrionAbility::GetExternalAbilityLevel(const struct FGameplayTag& AbilityTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "GetExternalAbilityLevel");

	Params::OrionAbility_GetExternalAbilityLevel Parms{};

	Parms.AbilityTag = std::move(AbilityTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbility.GetTargets
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayAbilityTargetDataHandle ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayAbilityTargetDataHandle UOrionAbility::GetTargets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "GetTargets");

	Params::OrionAbility_GetTargets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbility.InitAndApplyFilterContainerToTargetData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOrionFilterAndEffectsContainer  FilterContainer                                        (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle TargetData                                             (Parm, NativeAccessSpecifierPublic)
// TArray<struct FActiveGameplayEffectHandle>AppliedEffectHandles                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FOrionFilterAndEffectsContainer  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FOrionFilterAndEffectsContainer UOrionAbility::InitAndApplyFilterContainerToTargetData(struct FOrionFilterAndEffectsContainer& FilterContainer, const struct FGameplayAbilityTargetDataHandle& TargetData, TArray<struct FActiveGameplayEffectHandle>* AppliedEffectHandles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "InitAndApplyFilterContainerToTargetData");

	Params::OrionAbility_InitAndApplyFilterContainerToTargetData Parms{};

	Parms.FilterContainer = std::move(FilterContainer);
	Parms.TargetData = std::move(TargetData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	FilterContainer = std::move(Parms.FilterContainer);

	if (AppliedEffectHandles != nullptr)
		*AppliedEffectHandles = std::move(Parms.AppliedEffectHandles);

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbility.InitFilterAndEffectsContainer
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOrionFilterAndEffectsContainer  FilterContainer                                        (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FOrionFilterAndEffectsContainer  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FOrionFilterAndEffectsContainer UOrionAbility::InitFilterAndEffectsContainer(struct FOrionFilterAndEffectsContainer& FilterContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "InitFilterAndEffectsContainer");

	Params::OrionAbility_InitFilterAndEffectsContainer Parms{};

	Parms.FilterContainer = std::move(FilterContainer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	FilterContainer = std::move(Parms.FilterContainer);

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbility.K2_OrionAddGameplayCue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     GameplayCueTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectContextHandle     Context                                                (Parm, NativeAccessSpecifierPublic)
// bool                                    bRemoveOnAbilityEnd                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAbility::K2_OrionAddGameplayCue(const struct FGameplayTag& GameplayCueTag, const struct FGameplayEffectContextHandle& Context, bool bRemoveOnAbilityEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "K2_OrionAddGameplayCue");

	Params::OrionAbility_K2_OrionAddGameplayCue Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.Context = std::move(Context);
	Parms.bRemoveOnAbilityEnd = bRemoveOnAbilityEnd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility.K2_OrionApplyIgnorePawnCollision
// (Final, Native, Public, BlueprintCallable)

void UOrionAbility::K2_OrionApplyIgnorePawnCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "K2_OrionApplyIgnorePawnCollision");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility.K2_OrionApplyInterruptionImmunity
// (Final, Native, Public, BlueprintCallable)

void UOrionAbility::K2_OrionApplyInterruptionImmunity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "K2_OrionApplyInterruptionImmunity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility.K2_OrionApplyLimboStatus
// (Final, Native, Public, BlueprintCallable)

void UOrionAbility::K2_OrionApplyLimboStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "K2_OrionApplyLimboStatus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility.K2_OrionApplyUnselectableStatus
// (Final, Native, Public, BlueprintCallable)

void UOrionAbility::K2_OrionApplyUnselectableStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "K2_OrionApplyUnselectableStatus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility.K2_OrionExecuteGameplayCue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     GameplayCueTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectContextHandle     Context                                                (Parm, NativeAccessSpecifierPublic)

void UOrionAbility::K2_OrionExecuteGameplayCue(const struct FGameplayTag& GameplayCueTag, const struct FGameplayEffectContextHandle& Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "K2_OrionExecuteGameplayCue");

	Params::OrionAbility_K2_OrionExecuteGameplayCue Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.Context = std::move(Context);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility.K2_OrionExecuteGameplayCueWithParams
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     GameplayCueTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           GameplayCueParameters                                  (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UOrionAbility::K2_OrionExecuteGameplayCueWithParams(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "K2_OrionExecuteGameplayCueWithParams");

	Params::OrionAbility_K2_OrionExecuteGameplayCueWithParams Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.GameplayCueParameters = std::move(GameplayCueParameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility.K2_OrionRemoveGameplayCue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     GameplayCueTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAbility::K2_OrionRemoveGameplayCue(const struct FGameplayTag& GameplayCueTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "K2_OrionRemoveGameplayCue");

	Params::OrionAbility_K2_OrionRemoveGameplayCue Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility.K2_OrionRemoveIgnorePawnCollision
// (Final, Native, Public, BlueprintCallable)

void UOrionAbility::K2_OrionRemoveIgnorePawnCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "K2_OrionRemoveIgnorePawnCollision");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility.K2_OrionRemoveInterruptionImmunity
// (Final, Native, Public, BlueprintCallable)

void UOrionAbility::K2_OrionRemoveInterruptionImmunity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "K2_OrionRemoveInterruptionImmunity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility.K2_OrionRemoveLimboStatus
// (Final, Native, Public, BlueprintCallable)

void UOrionAbility::K2_OrionRemoveLimboStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "K2_OrionRemoveLimboStatus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility.K2_OrionRemoveUnselectableStatus
// (Final, Native, Public, BlueprintCallable)

void UOrionAbility::K2_OrionRemoveUnselectableStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "K2_OrionRemoveUnselectableStatus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility.K2_SetUseFixedSkeletalBounds
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    UseFixedSkeletalBounds                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAbility::K2_SetUseFixedSkeletalBounds(bool UseFixedSkeletalBounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "K2_SetUseFixedSkeletalBounds");

	Params::OrionAbility_K2_SetUseFixedSkeletalBounds Parms{};

	Parms.UseFixedSkeletalBounds = UseFixedSkeletalBounds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility.LockCameraRotation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bResetOnDeath                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAbility::LockCameraRotation(bool bResetOnDeath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "LockCameraRotation");

	Params::OrionAbility_LockCameraRotation Parms{};

	Parms.bResetOnDeath = bResetOnDeath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility.LockCharacterRotation
// (Final, Native, Public, BlueprintCallable)

void UOrionAbility::LockCharacterRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "LockCharacterRotation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility.SetCameraMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UOrionCameraMode>     CameraModeClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAbility::SetCameraMode(TSubclassOf<class UOrionCameraMode> CameraModeClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "SetCameraMode");

	Params::OrionAbility_SetCameraMode Parms{};

	Parms.CameraModeClass = CameraModeClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility.SetLookAtActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           LookTarget                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             LookSocket                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LookLerp                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LookAccel                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionAbility::SetLookAtActor(const class AActor* LookTarget, class FName LookSocket, float LookLerp, float LookAccel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "SetLookAtActor");

	Params::OrionAbility_SetLookAtActor Parms{};

	Parms.LookTarget = LookTarget;
	Parms.LookSocket = LookSocket;
	Parms.LookLerp = LookLerp;
	Parms.LookAccel = LookAccel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbility.SetPassiveTargetingMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   TargetingModeIndex                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAbility::SetPassiveTargetingMode(int32 TargetingModeIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "SetPassiveTargetingMode");

	Params::OrionAbility_SetPassiveTargetingMode Parms{};

	Parms.TargetingModeIndex = TargetingModeIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility.SetReticleVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EReticleVisibility                      Visibility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAbility::SetReticleVisibility(EReticleVisibility Visibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "SetReticleVisibility");

	Params::OrionAbility_SetReticleVisibility Parms{};

	Parms.Visibility = Visibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility.SnapCharacterRotationToCamera
// (Final, Native, Public, BlueprintCallable)

void UOrionAbility::SnapCharacterRotationToCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "SnapCharacterRotationToCamera");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility.SpawnCharHeroDecoy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AController*                      Controller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AOrionCharHero_Decoy> OrionCharHeroDecoyClass                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UOrionVisionDef>      VisionData                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOrionChar*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOrionChar* UOrionAbility::SpawnCharHeroDecoy(class AController* Controller, TSubclassOf<class AOrionCharHero_Decoy> OrionCharHeroDecoyClass, TSubclassOf<class UOrionVisionDef> VisionData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "SpawnCharHeroDecoy");

	Params::OrionAbility_SpawnCharHeroDecoy Parms{};

	Parms.Controller = Controller;
	Parms.OrionCharHeroDecoyClass = OrionCharHeroDecoyClass;
	Parms.VisionData = VisionData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbility.TrackActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ActorToTrack                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAbility::TrackActor(class AActor* ActorToTrack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "TrackActor");

	Params::OrionAbility_TrackActor Parms{};

	Parms.ActorToTrack = ActorToTrack;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility.TrackGroupedActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ActorToTrack                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     GroupingTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAbility::TrackGroupedActor(class AActor* ActorToTrack, const struct FGameplayTag& GroupingTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "TrackGroupedActor");

	Params::OrionAbility_TrackGroupedActor Parms{};

	Parms.ActorToTrack = ActorToTrack;
	Parms.GroupingTag = std::move(GroupingTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility.TravelModeBlockAbilities
// (Final, Native, Public, BlueprintCallable)

void UOrionAbility::TravelModeBlockAbilities()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "TravelModeBlockAbilities");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility.TravelModeUnblockAbilities
// (Final, Native, Public, BlueprintCallable)

void UOrionAbility::TravelModeUnblockAbilities()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "TravelModeUnblockAbilities");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility.TryCombo
// (Final, Native, Public, BlueprintCallable)

void UOrionAbility::TryCombo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "TryCombo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility.UnBlockMovementInput
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bResetOnDeath                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAbility::UnBlockMovementInput(bool bResetOnDeath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "UnBlockMovementInput");

	Params::OrionAbility_UnBlockMovementInput Parms{};

	Parms.bResetOnDeath = bResetOnDeath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility.UnlockCameraRotation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bResetOnDeath                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAbility::UnlockCameraRotation(bool bResetOnDeath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "UnlockCameraRotation");

	Params::OrionAbility_UnlockCameraRotation Parms{};

	Parms.bResetOnDeath = bResetOnDeath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility.UnlockCharacterRotation
// (Final, Native, Public, BlueprintCallable)

void UOrionAbility::UnlockCharacterRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "UnlockCharacterRotation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility.AbilityHasTag
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     TagToCheck                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionAbility::AbilityHasTag(const struct FGameplayTag& TagToCheck) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "AbilityHasTag");

	Params::OrionAbility_AbilityHasTag Parms{};

	Parms.TagToCheck = std::move(TagToCheck);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbility.GetAbilitiesByTag
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTagContainer            TagContainer                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FGameplayAbilitySpecHandle>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FGameplayAbilitySpecHandle> UOrionAbility::GetAbilitiesByTag(const struct FGameplayTagContainer& TagContainer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "GetAbilitiesByTag");

	Params::OrionAbility_GetAbilitiesByTag Parms{};

	Parms.TagContainer = std::move(TagContainer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbility.GetMontageForEmoteByInputID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UOrionAbility::GetMontageForEmoteByInputID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "GetMontageForEmoteByInputID");

	Params::OrionAbility_GetMontageForEmoteByInputID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbility.GetMontageForEmoteType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionEmoteType                         EmoteType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UOrionAbility::GetMontageForEmoteType(EOrionEmoteType EmoteType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "GetMontageForEmoteType");

	Params::OrionAbility_GetMontageForEmoteType Parms{};

	Parms.EmoteType = EmoteType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbility.GetOrionCharAIFromActorInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AOrionCharAI*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOrionCharAI* UOrionAbility::GetOrionCharAIFromActorInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "GetOrionCharAIFromActorInfo");

	Params::OrionAbility_GetOrionCharAIFromActorInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbility.GetOrionCharFromActorInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AOrionChar*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOrionChar* UOrionAbility::GetOrionCharFromActorInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "GetOrionCharFromActorInfo");

	Params::OrionAbility_GetOrionCharFromActorInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbility.GetOrionCharHeroFromActorInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AOrionCharHero*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOrionCharHero* UOrionAbility::GetOrionCharHeroFromActorInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "GetOrionCharHeroFromActorInfo");

	Params::OrionAbility_GetOrionCharHeroFromActorInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbility.IsCharacterFalling
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionAbility::IsCharacterFalling() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "IsCharacterFalling");

	Params::OrionAbility_IsCharacterFalling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbility.K2_GetAttackSpeedMultiplier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOrionAbility::K2_GetAttackSpeedMultiplier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "K2_GetAttackSpeedMultiplier");

	Params::OrionAbility_K2_GetAttackSpeedMultiplier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbility.K2_GetBestMontageForAttackSpeed
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FOrionAbilityMontageContainer    MontageContainer                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   OutPlayRate                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UOrionAbility::K2_GetBestMontageForAttackSpeed(const struct FOrionAbilityMontageContainer& MontageContainer, float* OutPlayRate) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "K2_GetBestMontageForAttackSpeed");

	Params::OrionAbility_K2_GetBestMontageForAttackSpeed Parms{};

	Parms.MontageContainer = std::move(MontageContainer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPlayRate != nullptr)
		*OutPlayRate = Parms.OutPlayRate;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbility.K2_GetRateForAttackSpeedMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     Montage                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SectionName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    FillEntireAttackTime                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOrionAbility::K2_GetRateForAttackSpeedMontage(const class UAnimMontage* Montage, class FName SectionName, bool FillEntireAttackTime) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "K2_GetRateForAttackSpeedMontage");

	Params::OrionAbility_K2_GetRateForAttackSpeedMontage Parms{};

	Parms.Montage = Montage;
	Parms.SectionName = SectionName;
	Parms.FillEntireAttackTime = FillEntireAttackTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbility.K2_GetTotalAttackTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOrionAbility::K2_GetTotalAttackTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "K2_GetTotalAttackTime");

	Params::OrionAbility_K2_GetTotalAttackTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbility.K2_ScaleTimeByAttackSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   BaseTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOrionAbility::K2_ScaleTimeByAttackSpeed(float BaseTime) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "K2_ScaleTimeByAttackSpeed");

	Params::OrionAbility_K2_ScaleTimeByAttackSpeed Parms{};

	Parms.BaseTime = BaseTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbility.MakeGameplayCueParameters
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayAbilityTargetDataHandle TargetData                                             (Parm, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FGameplayCueParameters UOrionAbility::MakeGameplayCueParameters(const struct FGameplayAbilityTargetDataHandle& TargetData) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility", "MakeGameplayCueParameters");

	Params::OrionAbility_MakeGameplayCueParameters Parms{};

	Parms.TargetData = std::move(TargetData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbility_EventEvaluator.BroadcastEventComplete
// (Final, Native, Public, BlueprintCallable)

void UOrionAbility_EventEvaluator::BroadcastEventComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility_EventEvaluator", "BroadcastEventComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility_EventEvaluator.OnAbilityActivatedOrCommitCallback
// (Final, Native, Protected)
// Parameters:
// class UGameplayAbility*                 AbilityThatActivated                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAbility_EventEvaluator::OnAbilityActivatedOrCommitCallback(class UGameplayAbility* AbilityThatActivated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility_EventEvaluator", "OnAbilityActivatedOrCommitCallback");

	Params::OrionAbility_EventEvaluator_OnAbilityActivatedOrCommitCallback Parms{};

	Parms.AbilityThatActivated = AbilityThatActivated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility_EventEvaluator.OnEventkeywordCallback
// (Final, Native, Protected)

void UOrionAbility_EventEvaluator::OnEventkeywordCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility_EventEvaluator", "OnEventkeywordCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility_EventEvaluator.OnGameplayEffectAppliedSelf
// (Final, Native, Protected)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectSpecHandle        SpecHandle                                             (Parm, NativeAccessSpecifierPublic)
// struct FActiveGameplayEffectHandle      ActiveHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAbility_EventEvaluator::OnGameplayEffectAppliedSelf(class AActor* Target, const struct FGameplayEffectSpecHandle& SpecHandle, const struct FActiveGameplayEffectHandle& ActiveHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility_EventEvaluator", "OnGameplayEffectAppliedSelf");

	Params::OrionAbility_EventEvaluator_OnGameplayEffectAppliedSelf Parms{};

	Parms.Target = Target;
	Parms.SpecHandle = std::move(SpecHandle);
	Parms.ActiveHandle = std::move(ActiveHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility_EventEvaluator.OnGameplayEffectAppliedTarget
// (Final, Native, Protected)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectSpecHandle        SpecHandle                                             (Parm, NativeAccessSpecifierPublic)
// struct FActiveGameplayEffectHandle      ActiveHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAbility_EventEvaluator::OnGameplayEffectAppliedTarget(class AActor* Target, const struct FGameplayEffectSpecHandle& SpecHandle, const struct FActiveGameplayEffectHandle& ActiveHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility_EventEvaluator", "OnGameplayEffectAppliedTarget");

	Params::OrionAbility_EventEvaluator_OnGameplayEffectAppliedTarget Parms{};

	Parms.Target = Target;
	Parms.SpecHandle = std::move(SpecHandle);
	Parms.ActiveHandle = std::move(ActiveHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility_EventEvaluator.OnGameplayEventCallback
// (Final, Native, Protected)
// Parameters:
// struct FGameplayEventData               Payload                                                (Parm, NativeAccessSpecifierPublic)

void UOrionAbility_EventEvaluator::OnGameplayEventCallback(const struct FGameplayEventData& Payload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility_EventEvaluator", "OnGameplayEventCallback");

	Params::OrionAbility_EventEvaluator_OnGameplayEventCallback Parms{};

	Parms.Payload = std::move(Payload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility_EventEvaluator.OnTagAddedCallback
// (Final, Native, Protected)

void UOrionAbility_EventEvaluator::OnTagAddedCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility_EventEvaluator", "OnTagAddedCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility_EventEvaluator.OnTagRemovedCallback
// (Final, Native, Protected)

void UOrionAbility_EventEvaluator::OnTagRemovedCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility_EventEvaluator", "OnTagRemovedCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility_EventEvaluator.TagTableLoaded
// (Final, Native, Protected)

void UOrionAbility_EventEvaluator::TagTableLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility_EventEvaluator", "TagTableLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility_MeleeAttack.OnMeleeTouch
// (Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UOrionAbility_MeleeAttack::OnMeleeTouch(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility_MeleeAttack", "OnMeleeTouch");

	Params::OrionAbility_MeleeAttack_OnMeleeTouch Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility_MeleeAttack.OnMontageEnded
// (Final, Native, Private)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAbility_MeleeAttack::OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility_MeleeAttack", "OnMontageEnded");

	Params::OrionAbility_MeleeAttack_OnMontageEnded Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbility_MeleeAttack.ServerMeleeTouch
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// class AActor*                           MeleeTarget                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UOrionAbility_MeleeAttack::ServerMeleeTouch(class AActor* MeleeTarget, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbility_MeleeAttack", "ServerMeleeTouch");

	Params::OrionAbility_MeleeAttack_ServerMeleeTouch Parms{};

	Parms.MeleeTarget = MeleeTarget;
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilityTask_StartTargeting.StartTargeting
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TaskInstanceName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayTargetingConfirmation          ConfirmationType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_StartTargeting* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_StartTargeting* UOrionAbilityTask_StartTargeting::StartTargeting(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, EGameplayTargetingConfirmation ConfirmationType, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_StartTargeting", "StartTargeting");

	Params::OrionAbilityTask_StartTargeting_StartTargeting Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TaskInstanceName = TaskInstanceName;
	Parms.ConfirmationType = ConfirmationType;
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_StartTargeting.CancelImpl
// (Final, Native, Public)

void UOrionAbilityTask_StartTargeting::CancelImpl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilityTask_StartTargeting", "CancelImpl");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilityTask_StartTargeting.ConfirmOrCancel
// (Native, Public)

void UOrionAbilityTask_StartTargeting::ConfirmOrCancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilityTask_StartTargeting", "ConfirmOrCancel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilityTask_StartTargeting.ConfirmOrWait
// (Final, Native, Public)

void UOrionAbilityTask_StartTargeting::ConfirmOrWait()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilityTask_StartTargeting", "ConfirmOrWait");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilityTask_StartTargeting.ServerForceClientTargetData
// (Final, Native, Public)

void UOrionAbilityTask_StartTargeting::ServerForceClientTargetData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilityTask_StartTargeting", "ServerForceClientTargetData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilityAITask_ExecuteGameplayAbility.AIExecuteAvailableGameplayAbility
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AAIController*                    AIController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWaitForAbilityEnd_0                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityAITask_ExecuteGameplayAbility*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityAITask_ExecuteGameplayAbility* UOrionAbilityAITask_ExecuteGameplayAbility::AIExecuteAvailableGameplayAbility(class AAIController* AIController, bool bWaitForAbilityEnd_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityAITask_ExecuteGameplayAbility", "AIExecuteAvailableGameplayAbility");

	Params::OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteAvailableGameplayAbility Parms{};

	Parms.AIController = AIController;
	Parms.bWaitForAbilityEnd_0 = bWaitForAbilityEnd_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityAITask_ExecuteGameplayAbility.AIExecuteGameplayAbilityByClass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AAIController*                    AIController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UOrionAbility>        AbilityClass                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWaitForAbilityEnd_0                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityAITask_ExecuteGameplayAbility*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityAITask_ExecuteGameplayAbility* UOrionAbilityAITask_ExecuteGameplayAbility::AIExecuteGameplayAbilityByClass(class AAIController* AIController, TSubclassOf<class UOrionAbility> AbilityClass, bool bWaitForAbilityEnd_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityAITask_ExecuteGameplayAbility", "AIExecuteGameplayAbilityByClass");

	Params::OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByClass Parms{};

	Parms.AIController = AIController;
	Parms.AbilityClass = AbilityClass;
	Parms.bWaitForAbilityEnd_0 = bWaitForAbilityEnd_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityAITask_ExecuteGameplayAbility.AIExecuteGameplayAbilityByHandle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AAIController*                    AIController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilitySpecHandle       Handle                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWaitForAbilityEnd_0                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityAITask_ExecuteGameplayAbility*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityAITask_ExecuteGameplayAbility* UOrionAbilityAITask_ExecuteGameplayAbility::AIExecuteGameplayAbilityByHandle(class AAIController* AIController, const struct FGameplayAbilitySpecHandle& Handle, bool bWaitForAbilityEnd_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityAITask_ExecuteGameplayAbility", "AIExecuteGameplayAbilityByHandle");

	Params::OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByHandle Parms{};

	Parms.AIController = AIController;
	Parms.Handle = std::move(Handle);
	Parms.bWaitForAbilityEnd_0 = bWaitForAbilityEnd_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityAITask_ExecuteGameplayAbility.AIExecuteGameplayAbilityByTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AAIController*                    AIController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            InGameplayTagContainerOfAbilityTags                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bWaitForAbilityEnd_0                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityAITask_ExecuteGameplayAbility*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityAITask_ExecuteGameplayAbility* UOrionAbilityAITask_ExecuteGameplayAbility::AIExecuteGameplayAbilityByTag(class AAIController* AIController, const struct FGameplayTagContainer& InGameplayTagContainerOfAbilityTags, bool bWaitForAbilityEnd_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityAITask_ExecuteGameplayAbility", "AIExecuteGameplayAbilityByTag");

	Params::OrionAbilityAITask_ExecuteGameplayAbility_AIExecuteGameplayAbilityByTag Parms{};

	Parms.AIController = AIController;
	Parms.InGameplayTagContainerOfAbilityTags = std::move(InGameplayTagContainerOfAbilityTags);
	Parms.bWaitForAbilityEnd_0 = bWaitForAbilityEnd_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityAITask_ExecuteGameplayAbility.K2_SetUp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AAIController*                    AIController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAbilityAITask_ExecuteGameplayAbility::K2_SetUp(class AAIController* AIController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilityAITask_ExecuteGameplayAbility", "K2_SetUp");

	Params::OrionAbilityAITask_ExecuteGameplayAbility_K2_SetUp Parms{};

	Parms.AIController = AIController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilitySystemComponent.BP_CopyGameplayEffectToSpecForReapply
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// struct FActiveGameplayEffectHandle      GameplayEffectHandle                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectSpecHandle        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayEffectSpecHandle UOrionAbilitySystemComponent::BP_CopyGameplayEffectToSpecForReapply(const struct FActiveGameplayEffectHandle& GameplayEffectHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilitySystemComponent", "BP_CopyGameplayEffectToSpecForReapply");

	Params::OrionAbilitySystemComponent_BP_CopyGameplayEffectToSpecForReapply Parms{};

	Parms.GameplayEffectHandle = std::move(GameplayEffectHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilitySystemComponent.BP_GetGameplayEffectDurationRemaining
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// struct FActiveGameplayEffectHandle      GameplayEffectHandle                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOrionAbilitySystemComponent::BP_GetGameplayEffectDurationRemaining(const struct FActiveGameplayEffectHandle& GameplayEffectHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilitySystemComponent", "BP_GetGameplayEffectDurationRemaining");

	Params::OrionAbilitySystemComponent_BP_GetGameplayEffectDurationRemaining Parms{};

	Parms.GameplayEffectHandle = std::move(GameplayEffectHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilitySystemComponent.BP_ReapplyGameplayEffectSpecToSelf
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayEffectSpecHandle        SpecHandle                                             (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   DurationRemaning                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActiveGameplayEffectHandle      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FActiveGameplayEffectHandle UOrionAbilitySystemComponent::BP_ReapplyGameplayEffectSpecToSelf(struct FGameplayEffectSpecHandle& SpecHandle, float DurationRemaning)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilitySystemComponent", "BP_ReapplyGameplayEffectSpecToSelf");

	Params::OrionAbilitySystemComponent_BP_ReapplyGameplayEffectSpecToSelf Parms{};

	Parms.SpecHandle = std::move(SpecHandle);
	Parms.DurationRemaning = DurationRemaning;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	SpecHandle = std::move(Parms.SpecHandle);

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilitySystemComponent.BP_ReapplyGameplayEffectSpecToTarget
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayEffectSpecHandle        SpecHandle                                             (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UAbilitySystemComponent*          Target                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DurationRemaning                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActiveGameplayEffectHandle      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FActiveGameplayEffectHandle UOrionAbilitySystemComponent::BP_ReapplyGameplayEffectSpecToTarget(struct FGameplayEffectSpecHandle& SpecHandle, class UAbilitySystemComponent* Target, float DurationRemaning)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilitySystemComponent", "BP_ReapplyGameplayEffectSpecToTarget");

	Params::OrionAbilitySystemComponent_BP_ReapplyGameplayEffectSpecToTarget Parms{};

	Parms.SpecHandle = std::move(SpecHandle);
	Parms.Target = Target;
	Parms.DurationRemaning = DurationRemaning;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	SpecHandle = std::move(Parms.SpecHandle);

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilitySystemComponent.ClientBatchedGoldXP
// (Net, Native, Event, Public, NetClient)
// Parameters:
// struct FOrionGoldXPGameplayCueBatch     Data                                                   (Parm, NativeAccessSpecifierPublic)

void UOrionAbilitySystemComponent::ClientBatchedGoldXP(const struct FOrionGoldXPGameplayCueBatch& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilitySystemComponent", "ClientBatchedGoldXP");

	Params::OrionAbilitySystemComponent_ClientBatchedGoldXP Parms{};

	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilitySystemComponent.ClientNotifyPostAbilityLevelUp
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// struct FGameplayAbilitySpecHandle       AbilitySpecHandle                                      (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAbilitySystemComponent::ClientNotifyPostAbilityLevelUp(const struct FGameplayAbilitySpecHandle& AbilitySpecHandle, int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilitySystemComponent", "ClientNotifyPostAbilityLevelUp");

	Params::OrionAbilitySystemComponent_ClientNotifyPostAbilityLevelUp Parms{};

	Parms.AbilitySpecHandle = std::move(AbilitySpecHandle);
	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilitySystemComponent.NetMulticast_OrionGameplayCueExecutedBatch
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// struct FOrionGameplayCueBatch           Data                                                   (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UOrionAbilitySystemComponent::NetMulticast_OrionGameplayCueExecutedBatch(const struct FOrionGameplayCueBatch& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilitySystemComponent", "NetMulticast_OrionGameplayCueExecutedBatch");

	Params::OrionAbilitySystemComponent_NetMulticast_OrionGameplayCueExecutedBatch Parms{};

	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilitySystemComponent.OnRep_CooldownReductionCount
// (Final, Native, Public)

void UOrionAbilitySystemComponent::OnRep_CooldownReductionCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilitySystemComponent", "OnRep_CooldownReductionCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilitySystemComponent.OnRep_ReplicatedDynamicCooldownTags
// (Final, Native, Protected)

void UOrionAbilitySystemComponent::OnRep_ReplicatedDynamicCooldownTags()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilitySystemComponent", "OnRep_ReplicatedDynamicCooldownTags");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilitySystemComponent.TrackActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ActorToTrack                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilitySpecHandle       Handle                                                 (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxTracked                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RemovalTime                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAbilitySystemComponent::TrackActor(class AActor* ActorToTrack, const struct FGameplayAbilitySpecHandle& Handle, const int32 MaxTracked, const float RemovalTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilitySystemComponent", "TrackActor");

	Params::OrionAbilitySystemComponent_TrackActor Parms{};

	Parms.ActorToTrack = ActorToTrack;
	Parms.Handle = std::move(Handle);
	Parms.MaxTracked = MaxTracked;
	Parms.RemovalTime = RemovalTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilitySystemComponent.TrackGroupedActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ActorToTrack                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     GroupingTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxTracked                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RemovalTime                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAbilitySystemComponent::TrackGroupedActor(class AActor* ActorToTrack, const struct FGameplayTag& GroupingTag, const int32 MaxTracked, const float RemovalTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilitySystemComponent", "TrackGroupedActor");

	Params::OrionAbilitySystemComponent_TrackGroupedActor Parms{};

	Parms.ActorToTrack = ActorToTrack;
	Parms.GroupingTag = std::move(GroupingTag);
	Parms.MaxTracked = MaxTracked;
	Parms.RemovalTime = RemovalTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilitySystemComponent.BP_GetActiveGameplayEffects
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayEffectQuery             Query                                                  (ConstParm, Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<struct FActiveGameplayEffectHandle>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FActiveGameplayEffectHandle> UOrionAbilitySystemComponent::BP_GetActiveGameplayEffects(const struct FGameplayEffectQuery& Query) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilitySystemComponent", "BP_GetActiveGameplayEffects");

	Params::OrionAbilitySystemComponent_BP_GetActiveGameplayEffects Parms{};

	Parms.Query = std::move(Query);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilitySystemComponent.DidActiveTargetsChange
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionAbilitySystemComponent::DidActiveTargetsChange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilitySystemComponent", "DidActiveTargetsChange");

	Params::OrionAbilitySystemComponent_DidActiveTargetsChange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilitySystemComponent.GetExternalAbilityLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     AbilityTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOrionAbilitySystemComponent::GetExternalAbilityLevel(const struct FGameplayTag& AbilityTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilitySystemComponent", "GetExternalAbilityLevel");

	Params::OrionAbilitySystemComponent_GetExternalAbilityLevel Parms{};

	Parms.AbilityTag = std::move(AbilityTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilitySystemComponent.IsActivelyTargetingAnyActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionAbilitySystemComponent::IsActivelyTargetingAnyActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilitySystemComponent", "IsActivelyTargetingAnyActor");

	Params::OrionAbilitySystemComponent_IsActivelyTargetingAnyActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilitySystemComponent.K2_GetActivatableAbilities
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FGameplayAbilitySpec>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FGameplayAbilitySpec> UOrionAbilitySystemComponent::K2_GetActivatableAbilities() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilitySystemComponent", "K2_GetActivatableAbilities");

	Params::OrionAbilitySystemComponent_K2_GetActivatableAbilities Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionArcBladeAnimInstance.EnterBladeState00
// (Final, Native, Public, BlueprintCallable)

void UOrionArcBladeAnimInstance::EnterBladeState00()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionArcBladeAnimInstance", "EnterBladeState00");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionArcBladeAnimInstance.EnterBladeState01
// (Final, Native, Public, BlueprintCallable)

void UOrionArcBladeAnimInstance::EnterBladeState01()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionArcBladeAnimInstance", "EnterBladeState01");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionArcBladeAnimInstance.EnterBladeState02
// (Final, Native, Public, BlueprintCallable)

void UOrionArcBladeAnimInstance::EnterBladeState02()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionArcBladeAnimInstance", "EnterBladeState02");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionArcBladeAnimInstance.EnterBladeState03
// (Final, Native, Public, BlueprintCallable)

void UOrionArcBladeAnimInstance::EnterBladeState03()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionArcBladeAnimInstance", "EnterBladeState03");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilityTask_AddPlayerScoreListener.CreateAddPlayerScoreListenerTask
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ListenerName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FOrionActorFilter                TargetFilter                                           (Parm, NativeAccessSpecifierPublic)
// struct FGameplayTagRequirements         SourceTagRequirements                                  (Parm, NativeAccessSpecifierPublic)
// struct FGameplayTagRequirements         TargetTagRequirements                                  (Parm, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_AddPlayerScoreListener*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_AddPlayerScoreListener* UOrionAbilityTask_AddPlayerScoreListener::CreateAddPlayerScoreListenerTask(class UGameplayAbility* OwningAbility, class FName ListenerName, const struct FOrionActorFilter& TargetFilter, const struct FGameplayTagRequirements& SourceTagRequirements, const struct FGameplayTagRequirements& TargetTagRequirements)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_AddPlayerScoreListener", "CreateAddPlayerScoreListenerTask");

	Params::OrionAbilityTask_AddPlayerScoreListener_CreateAddPlayerScoreListenerTask Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.ListenerName = ListenerName;
	Parms.TargetFilter = std::move(TargetFilter);
	Parms.SourceTagRequirements = std::move(SourceTagRequirements);
	Parms.TargetTagRequirements = std::move(TargetTagRequirements);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_DirectedMovement.DirectedMovement
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          MovementDirection                                      (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionDirectedMovementSpace             MovementSpaceType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MovementDistance_0                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MovementDuration                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   IdealDistance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ModifyZ                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_DirectedMovement*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_DirectedMovement* UOrionAbilityTask_DirectedMovement::DirectedMovement(class UGameplayAbility* OwningAbility, const struct FVector& MovementDirection, EOrionDirectedMovementSpace MovementSpaceType, float MovementDistance_0, float MovementDuration, float IdealDistance, bool ModifyZ)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_DirectedMovement", "DirectedMovement");

	Params::OrionAbilityTask_DirectedMovement_DirectedMovement Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.MovementDirection = std::move(MovementDirection);
	Parms.MovementSpaceType = MovementSpaceType;
	Parms.MovementDistance_0 = MovementDistance_0;
	Parms.MovementDuration = MovementDuration;
	Parms.IdealDistance = IdealDistance;
	Parms.ModifyZ = ModifyZ;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_DirectedMovement.DirectedMovementToActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxMovementDistance                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MovementDuration                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   IdealDistance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ModifyZ                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_DirectedMovement*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_DirectedMovement* UOrionAbilityTask_DirectedMovement::DirectedMovementToActor(class UGameplayAbility* OwningAbility, class AActor* TargetActor, float MaxMovementDistance, float MovementDuration, float IdealDistance, bool ModifyZ)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_DirectedMovement", "DirectedMovementToActor");

	Params::OrionAbilityTask_DirectedMovement_DirectedMovementToActor Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TargetActor = TargetActor;
	Parms.MaxMovementDistance = MaxMovementDistance;
	Parms.MovementDuration = MovementDuration;
	Parms.IdealDistance = IdealDistance;
	Parms.ModifyZ = ModifyZ;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_DirectedMovement.DirectedMovementToComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  TargetComponent_0                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxMovementDistance                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MovementDuration                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   IdealDistance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ModifyZ                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_DirectedMovement*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_DirectedMovement* UOrionAbilityTask_DirectedMovement::DirectedMovementToComponent(class UGameplayAbility* OwningAbility, class USceneComponent* TargetComponent_0, float MaxMovementDistance, float MovementDuration, float IdealDistance, bool ModifyZ)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_DirectedMovement", "DirectedMovementToComponent");

	Params::OrionAbilityTask_DirectedMovement_DirectedMovementToComponent Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TargetComponent_0 = TargetComponent_0;
	Parms.MaxMovementDistance = MaxMovementDistance;
	Parms.MovementDuration = MovementDuration;
	Parms.IdealDistance = IdealDistance;
	Parms.ModifyZ = ModifyZ;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_DirectedMovement.DirectedMovementToLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          MovementTargetLocation                                 (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionDirectedMovementSpace             MovementSpaceType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MovementDuration                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CloseEnoughDistance                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ModifyZ                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_DirectedMovement*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_DirectedMovement* UOrionAbilityTask_DirectedMovement::DirectedMovementToLocation(class UGameplayAbility* OwningAbility, const struct FVector& MovementTargetLocation, EOrionDirectedMovementSpace MovementSpaceType, float MovementDuration, float CloseEnoughDistance, bool ModifyZ)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_DirectedMovement", "DirectedMovementToLocation");

	Params::OrionAbilityTask_DirectedMovement_DirectedMovementToLocation Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.MovementTargetLocation = std::move(MovementTargetLocation);
	Parms.MovementSpaceType = MovementSpaceType;
	Parms.MovementDuration = MovementDuration;
	Parms.CloseEnoughDistance = CloseEnoughDistance;
	Parms.ModifyZ = ModifyZ;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_InstantTargetData.HitScanTube
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetingLocationInfoStartLocation                                          (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   Range                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlockingRadius                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OverlapRadius                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCollisionProfileName            CollisionProfile                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FGameplayTargetDataFilterHandle  Filter                                                 (Parm, NativeAccessSpecifierPublic)
// bool                                    bMultiHit                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDebug                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_InstantTargetData*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_InstantTargetData* UOrionAbilityTask_InstantTargetData::HitScanTube(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetingLocationInfo& StartLocation, float Range, float BlockingRadius, float OverlapRadius, const struct FCollisionProfileName& CollisionProfile, const struct FGameplayTargetDataFilterHandle& Filter, bool bMultiHit, bool bDebug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_InstantTargetData", "HitScanTube");

	Params::OrionAbilityTask_InstantTargetData_HitScanTube Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.StartLocation = std::move(StartLocation);
	Parms.Range = Range;
	Parms.BlockingRadius = BlockingRadius;
	Parms.OverlapRadius = OverlapRadius;
	Parms.CollisionProfile = std::move(CollisionProfile);
	Parms.Filter = std::move(Filter);
	Parms.bMultiHit = bMultiHit;
	Parms.bDebug = bDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_PlayMontageAndWaitNotifyName.CreatePlayMontageAndWaitProxy
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TaskInstanceName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     MontageToPlay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             StartSection                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopWhenAbilityEnds                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_PlayMontageAndWaitNotifyName*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_PlayMontageAndWaitNotifyName* UOrionAbilityTask_PlayMontageAndWaitNotifyName::CreatePlayMontageAndWaitProxy(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class UAnimMontage* MontageToPlay, float Rate, class FName StartSection, bool bStopWhenAbilityEnds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_PlayMontageAndWaitNotifyName", "CreatePlayMontageAndWaitProxy");

	Params::OrionAbilityTask_PlayMontageAndWaitNotifyName_CreatePlayMontageAndWaitProxy Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TaskInstanceName = TaskInstanceName;
	Parms.MontageToPlay = MontageToPlay;
	Parms.Rate = Rate;
	Parms.StartSection = StartSection;
	Parms.bStopWhenAbilityEnds = bStopWhenAbilityEnds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_PlayMontageAndWaitNotifyName.PlayMontageAndWaitNotifyName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TaskInstanceName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     MontageToPlay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             StartSection                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopWhenAbilityEnds                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_PlayMontageAndWaitNotifyName*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_PlayMontageAndWaitNotifyName* UOrionAbilityTask_PlayMontageAndWaitNotifyName::PlayMontageAndWaitNotifyName(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class UAnimMontage* MontageToPlay, float Rate, class FName StartSection, bool bStopWhenAbilityEnds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_PlayMontageAndWaitNotifyName", "PlayMontageAndWaitNotifyName");

	Params::OrionAbilityTask_PlayMontageAndWaitNotifyName_PlayMontageAndWaitNotifyName Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TaskInstanceName = TaskInstanceName;
	Parms.MontageToPlay = MontageToPlay;
	Parms.Rate = Rate;
	Parms.StartSection = StartSection;
	Parms.bStopWhenAbilityEnds = bStopWhenAbilityEnds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_PlayMontageAndWaitNotifyName.OnMontageBlendingOut
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAbilityTask_PlayMontageAndWaitNotifyName::OnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilityTask_PlayMontageAndWaitNotifyName", "OnMontageBlendingOut");

	Params::OrionAbilityTask_PlayMontageAndWaitNotifyName_OnMontageBlendingOut Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilityTask_PlayMontageAndWaitNotifyName.OnMontageEnded
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAbilityTask_PlayMontageAndWaitNotifyName::OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilityTask_PlayMontageAndWaitNotifyName", "OnMontageEnded");

	Params::OrionAbilityTask_PlayMontageAndWaitNotifyName_OnMontageEnded Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilityTask_PlayMontageAndWaitNotifyName.OnMontageInterrupted
// (Final, Native, Protected)

void UOrionAbilityTask_PlayMontageAndWaitNotifyName::OnMontageInterrupted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilityTask_PlayMontageAndWaitNotifyName", "OnMontageInterrupted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilityTask_PlayMontageAndWaitNotifyName.OnNotifyBeginReceived
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class FName                             NotifyName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBranchingPointNotifyPayload     BranchingPointNotifyPayload                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UOrionAbilityTask_PlayMontageAndWaitNotifyName::OnNotifyBeginReceived(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilityTask_PlayMontageAndWaitNotifyName", "OnNotifyBeginReceived");

	Params::OrionAbilityTask_PlayMontageAndWaitNotifyName_OnNotifyBeginReceived Parms{};

	Parms.NotifyName = NotifyName;
	Parms.BranchingPointNotifyPayload = std::move(BranchingPointNotifyPayload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilityTask_PlayMontageAndWaitNotifyName.OnNotifyEndReceived
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class FName                             NotifyName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBranchingPointNotifyPayload     BranchingPointNotifyPayload                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UOrionAbilityTask_PlayMontageAndWaitNotifyName::OnNotifyEndReceived(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilityTask_PlayMontageAndWaitNotifyName", "OnNotifyEndReceived");

	Params::OrionAbilityTask_PlayMontageAndWaitNotifyName_OnNotifyEndReceived Parms{};

	Parms.NotifyName = NotifyName;
	Parms.BranchingPointNotifyPayload = std::move(BranchingPointNotifyPayload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilityTask_RepeatedAction.PerformRepeatedAction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeBetweenActions                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TotalActionCount                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_RepeatedAction* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_RepeatedAction* UOrionAbilityTask_RepeatedAction::PerformRepeatedAction(class UGameplayAbility* OwningAbility, float TimeBetweenActions, int32 TotalActionCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_RepeatedAction", "PerformRepeatedAction");

	Params::OrionAbilityTask_RepeatedAction_PerformRepeatedAction Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TimeBetweenActions = TimeBetweenActions;
	Parms.TotalActionCount = TotalActionCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_SpawnOrionActor.SpawnOrionActor
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       SpawnTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle TargetData                                             (Parm, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_SpawnOrionActor*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_SpawnOrionActor* UOrionAbilityTask_SpawnOrionActor::SpawnOrionActor(class UGameplayAbility* OwningAbility, TSubclassOf<class AActor> Class_0, const struct FTransform& SpawnTransform, const struct FGameplayAbilityTargetDataHandle& TargetData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_SpawnOrionActor", "SpawnOrionActor");

	Params::OrionAbilityTask_SpawnOrionActor_SpawnOrionActor Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.Class_0 = Class_0;
	Parms.SpawnTransform = std::move(SpawnTransform);
	Parms.TargetData = std::move(TargetData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_SpawnOrionActor.SpawnOrionActorTargetData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle TargetData                                             (Parm, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_SpawnOrionActor*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_SpawnOrionActor* UOrionAbilityTask_SpawnOrionActor::SpawnOrionActorTargetData(class UGameplayAbility* OwningAbility, TSubclassOf<class AActor> Class_0, const struct FGameplayAbilityTargetDataHandle& TargetData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_SpawnOrionActor", "SpawnOrionActorTargetData");

	Params::OrionAbilityTask_SpawnOrionActor_SpawnOrionActorTargetData Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.Class_0 = Class_0;
	Parms.TargetData = std::move(TargetData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_SpawnOrionActor.SpawnOrionActorTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       SpawnTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_SpawnOrionActor*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_SpawnOrionActor* UOrionAbilityTask_SpawnOrionActor::SpawnOrionActorTransform(class UGameplayAbility* OwningAbility, TSubclassOf<class AActor> Class_0, const struct FTransform& SpawnTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_SpawnOrionActor", "SpawnOrionActorTransform");

	Params::OrionAbilityTask_SpawnOrionActor_SpawnOrionActorTransform Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.Class_0 = Class_0;
	Parms.SpawnTransform = std::move(SpawnTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_SpawnOrionActor.BeginSpawningActor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SpawnedActor                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionAbilityTask_SpawnOrionActor::BeginSpawningActor(class UGameplayAbility* OwningAbility, TSubclassOf<class AActor> Class_0, class AActor** SpawnedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilityTask_SpawnOrionActor", "BeginSpawningActor");

	Params::OrionAbilityTask_SpawnOrionActor_BeginSpawningActor Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SpawnedActor != nullptr)
		*SpawnedActor = Parms.SpawnedActor;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_SpawnOrionActor.FinishSpawningActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SpawnedActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAbilityTask_SpawnOrionActor::FinishSpawningActor(class UGameplayAbility* OwningAbility, class AActor* SpawnedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilityTask_SpawnOrionActor", "FinishSpawningActor");

	Params::OrionAbilityTask_SpawnOrionActor_FinishSpawningActor Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.SpawnedActor = SpawnedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilityTask_SpawnProjectile.CloneProjectile
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOrionProjectile*                 SourceProjectile                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle TargetData                                             (Parm, NativeAccessSpecifierPublic)
// float                                   PitchOffset                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   YawOffset                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AOrionProjectile>     Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_SpawnProjectile*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_SpawnProjectile* UOrionAbilityTask_SpawnProjectile::CloneProjectile(class UGameplayAbility* OwningAbility, class AOrionProjectile* SourceProjectile, const struct FGameplayAbilityTargetDataHandle& TargetData, float PitchOffset, float YawOffset, TSubclassOf<class AOrionProjectile> Class_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_SpawnProjectile", "CloneProjectile");

	Params::OrionAbilityTask_SpawnProjectile_CloneProjectile Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.SourceProjectile = SourceProjectile;
	Parms.TargetData = std::move(TargetData);
	Parms.PitchOffset = PitchOffset;
	Parms.YawOffset = YawOffset;
	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_SpawnProjectile.SpawnProjectile
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle TargetData                                             (Parm, NativeAccessSpecifierPublic)
// float                                   PitchOffset                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   YawOffset                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AOrionProjectile>     Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_SpawnProjectile*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_SpawnProjectile* UOrionAbilityTask_SpawnProjectile::SpawnProjectile(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetData, float PitchOffset, float YawOffset, TSubclassOf<class AOrionProjectile> Class_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_SpawnProjectile", "SpawnProjectile");

	Params::OrionAbilityTask_SpawnProjectile_SpawnProjectile Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TargetData = std::move(TargetData);
	Parms.PitchOffset = PitchOffset;
	Parms.YawOffset = YawOffset;
	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_SpawnProjectile.BeginSpawningActor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle TargetData                                             (Parm, NativeAccessSpecifierPublic)
// TSubclassOf<class AOrionProjectile>     Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOrionProjectile*                 SpawnedActor                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionAbilityTask_SpawnProjectile::BeginSpawningActor(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetData, TSubclassOf<class AOrionProjectile> Class_0, class AOrionProjectile** SpawnedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilityTask_SpawnProjectile", "BeginSpawningActor");

	Params::OrionAbilityTask_SpawnProjectile_BeginSpawningActor Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TargetData = std::move(TargetData);
	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SpawnedActor != nullptr)
		*SpawnedActor = Parms.SpawnedActor;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_SpawnProjectile.FinishSpawningActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle TargetData                                             (Parm, NativeAccessSpecifierPublic)
// class AOrionProjectile*                 SpawnedActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAbilityTask_SpawnProjectile::FinishSpawningActor(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetData, class AOrionProjectile* SpawnedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilityTask_SpawnProjectile", "FinishSpawningActor");

	Params::OrionAbilityTask_SpawnProjectile_FinishSpawningActor Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TargetData = std::move(TargetData);
	Parms.SpawnedActor = SpawnedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilityTask_SpawnProjectileMulti.SpawnProjectileMulti
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle TargetDataArray                                        (Parm, NativeAccessSpecifierPublic)
// TSubclassOf<class AOrionProjectile>     Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_SpawnProjectileMulti*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_SpawnProjectileMulti* UOrionAbilityTask_SpawnProjectileMulti::SpawnProjectileMulti(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetDataArray, TSubclassOf<class AOrionProjectile> Class_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_SpawnProjectileMulti", "SpawnProjectileMulti");

	Params::OrionAbilityTask_SpawnProjectileMulti_SpawnProjectileMulti Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TargetDataArray = std::move(TargetDataArray);
	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_SpawnProjectileMulti.BeginSpawningActorArray
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle TargetDataArray                                        (Parm, NativeAccessSpecifierPublic)
// TSubclassOf<class AOrionProjectile>     Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AOrionProjectile*>         SpawnedActor                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// class AOrionProjectile*                 SpawnedProjectile                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionAbilityTask_SpawnProjectileMulti::BeginSpawningActorArray(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetDataArray, TSubclassOf<class AOrionProjectile> Class_0, TArray<class AOrionProjectile*>* SpawnedActor, class AOrionProjectile** SpawnedProjectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilityTask_SpawnProjectileMulti", "BeginSpawningActorArray");

	Params::OrionAbilityTask_SpawnProjectileMulti_BeginSpawningActorArray Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TargetDataArray = std::move(TargetDataArray);
	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SpawnedActor != nullptr)
		*SpawnedActor = std::move(Parms.SpawnedActor);

	if (SpawnedProjectile != nullptr)
		*SpawnedProjectile = Parms.SpawnedProjectile;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_SpawnProjectileMulti.FinishSpawningActorArray
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle TargetDataArray                                        (Parm, NativeAccessSpecifierPublic)
// TArray<class AOrionProjectile*>         SpawnedActor                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UOrionAbilityTask_SpawnProjectileMulti::FinishSpawningActorArray(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetDataArray, const TArray<class AOrionProjectile*>& SpawnedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilityTask_SpawnProjectileMulti", "FinishSpawningActorArray");

	Params::OrionAbilityTask_SpawnProjectileMulti_FinishSpawningActorArray Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TargetDataArray = std::move(TargetDataArray);
	Parms.SpawnedActor = std::move(SpawnedActor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire.SpawnProjectileMulti_HorizontalSpread
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle TargetData                                             (Parm, NativeAccessSpecifierPublic)
// int32                                   ProjectileCount                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchRandom                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchOffset                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   YawRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   YawOffset                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AOrionProjectile>     Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire* UOrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire::SpawnProjectileMulti_HorizontalSpread(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetData, int32 ProjectileCount, float PitchRandom, float PitchOffset, float YawRange, float YawOffset, TSubclassOf<class AOrionProjectile> Class_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire", "SpawnProjectileMulti_HorizontalSpread");

	Params::OrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire_SpawnProjectileMulti_HorizontalSpread Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TargetData = std::move(TargetData);
	Parms.ProjectileCount = ProjectileCount;
	Parms.PitchRandom = PitchRandom;
	Parms.PitchOffset = PitchOffset;
	Parms.YawRange = YawRange;
	Parms.YawOffset = YawOffset;
	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_SpawnProjectileMulti_Cone.SpawnProjectileMulti_Cone
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle TargetData                                             (Parm, NativeAccessSpecifierPublic)
// int32                                   ProjectileCount                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchRandom                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchOffset                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   YawRandom                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   YawOffset                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AOrionProjectile>     Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_SpawnProjectileMulti_Cone*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_SpawnProjectileMulti_Cone* UOrionAbilityTask_SpawnProjectileMulti_Cone::SpawnProjectileMulti_Cone(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetData, int32 ProjectileCount, float PitchRandom, float PitchOffset, float YawRandom, float YawOffset, TSubclassOf<class AOrionProjectile> Class_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_SpawnProjectileMulti_Cone", "SpawnProjectileMulti_Cone");

	Params::OrionAbilityTask_SpawnProjectileMulti_Cone_SpawnProjectileMulti_Cone Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TargetData = std::move(TargetData);
	Parms.ProjectileCount = ProjectileCount;
	Parms.PitchRandom = PitchRandom;
	Parms.PitchOffset = PitchOffset;
	Parms.YawRandom = YawRandom;
	Parms.YawOffset = YawOffset;
	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_SpawnRig.SpawnRig
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle TargetData                                             (Parm, NativeAccessSpecifierPublic)
// EOrionTeam                              RigTeamNum                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AOrionRigs>           Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_SpawnRig*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_SpawnRig* UOrionAbilityTask_SpawnRig::SpawnRig(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetData, EOrionTeam RigTeamNum, TSubclassOf<class AOrionRigs> Class_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_SpawnRig", "SpawnRig");

	Params::OrionAbilityTask_SpawnRig_SpawnRig Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TargetData = std::move(TargetData);
	Parms.RigTeamNum = RigTeamNum;
	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_SpawnRig.BeginSpawningActor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle TargetData                                             (Parm, NativeAccessSpecifierPublic)
// TSubclassOf<class AOrionRigs>           Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOrionRigs*                       SpawnedActor                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionAbilityTask_SpawnRig::BeginSpawningActor(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetData, TSubclassOf<class AOrionRigs> Class_0, class AOrionRigs** SpawnedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilityTask_SpawnRig", "BeginSpawningActor");

	Params::OrionAbilityTask_SpawnRig_BeginSpawningActor Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TargetData = std::move(TargetData);
	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SpawnedActor != nullptr)
		*SpawnedActor = Parms.SpawnedActor;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_SpawnRig.FinishSpawningActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle TargetData                                             (Parm, NativeAccessSpecifierPublic)
// class AOrionRigs*                       SpawnedActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAbilityTask_SpawnRig::FinishSpawningActor(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetData, class AOrionRigs* SpawnedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilityTask_SpawnRig", "FinishSpawningActor");

	Params::OrionAbilityTask_SpawnRig_FinishSpawningActor Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TargetData = std::move(TargetData);
	Parms.SpawnedActor = SpawnedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilityTask_SpawnWard.SpawnWard
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle TargetData                                             (Parm, NativeAccessSpecifierPublic)
// EOrionTeam                              TeamNum                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AOrionVisionWard>     Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_SpawnWard*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_SpawnWard* UOrionAbilityTask_SpawnWard::SpawnWard(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetData, EOrionTeam TeamNum, TSubclassOf<class AOrionVisionWard> Class_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_SpawnWard", "SpawnWard");

	Params::OrionAbilityTask_SpawnWard_SpawnWard Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TargetData = std::move(TargetData);
	Parms.TeamNum = TeamNum;
	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_SpawnWard.BeginSpawningActor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle TargetData                                             (Parm, NativeAccessSpecifierPublic)
// TSubclassOf<class AOrionVisionWard>     Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOrionVisionWard*                 SpawnedActor                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionAbilityTask_SpawnWard::BeginSpawningActor(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetData, TSubclassOf<class AOrionVisionWard> Class_0, class AOrionVisionWard** SpawnedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilityTask_SpawnWard", "BeginSpawningActor");

	Params::OrionAbilityTask_SpawnWard_BeginSpawningActor Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TargetData = std::move(TargetData);
	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SpawnedActor != nullptr)
		*SpawnedActor = Parms.SpawnedActor;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_SpawnWard.FinishSpawningActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle TargetData                                             (Parm, NativeAccessSpecifierPublic)
// class AOrionVisionWard*                 SpawnedActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAbilityTask_SpawnWard::FinishSpawningActor(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetData, class AOrionVisionWard* SpawnedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilityTask_SpawnWard", "FinishSpawningActor");

	Params::OrionAbilityTask_SpawnWard_FinishSpawningActor Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TargetData = std::move(TargetData);
	Parms.SpawnedActor = SpawnedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilityTask_WaitAbilityLevelUp.WaitAbilityLevelUp
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     AbilityTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OnlyTriggerOnce                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_WaitAbilityLevelUp*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_WaitAbilityLevelUp* UOrionAbilityTask_WaitAbilityLevelUp::WaitAbilityLevelUp(class UGameplayAbility* OwningAbility, const struct FGameplayTag& AbilityTag, bool OnlyTriggerOnce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_WaitAbilityLevelUp", "WaitAbilityLevelUp");

	Params::OrionAbilityTask_WaitAbilityLevelUp_WaitAbilityLevelUp Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.AbilityTag = std::move(AbilityTag);
	Parms.OnlyTriggerOnce = OnlyTriggerOnce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_WaitAbilityLevelUp.WaitThisAbilityLevelUp
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OnlyTriggerOnce                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_WaitAbilityLevelUp*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_WaitAbilityLevelUp* UOrionAbilityTask_WaitAbilityLevelUp::WaitThisAbilityLevelUp(class UGameplayAbility* OwningAbility, bool OnlyTriggerOnce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_WaitAbilityLevelUp", "WaitThisAbilityLevelUp");

	Params::OrionAbilityTask_WaitAbilityLevelUp_WaitThisAbilityLevelUp Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.OnlyTriggerOnce = OnlyTriggerOnce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_WaitReactivate.WaitAbilityReactivate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionAbilityActivationGroup            NewActivationGroup                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagRequirements         AdditionalAbilityInputToListenFor                      (Parm, NativeAccessSpecifierPublic)
// bool                                    TriggerOnlyOnce                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_WaitReactivate* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_WaitReactivate* UOrionAbilityTask_WaitReactivate::WaitAbilityReactivate(class UGameplayAbility* OwningAbility, EOrionAbilityActivationGroup NewActivationGroup, const struct FGameplayTagRequirements& AdditionalAbilityInputToListenFor, bool TriggerOnlyOnce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_WaitReactivate", "WaitAbilityReactivate");

	Params::OrionAbilityTask_WaitReactivate_WaitAbilityReactivate Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.NewActivationGroup = NewActivationGroup;
	Parms.AdditionalAbilityInputToListenFor = std::move(AdditionalAbilityInputToListenFor);
	Parms.TriggerOnlyOnce = TriggerOnlyOnce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_WaitAnyAbilityInput.WaitAnyAbilityInput
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagRequirements         TagRequirements                                        (Parm, NativeAccessSpecifierPublic)
// bool                                    bConsumeInput                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_WaitAnyAbilityInput*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_WaitAnyAbilityInput* UOrionAbilityTask_WaitAnyAbilityInput::WaitAnyAbilityInput(class UGameplayAbility* OwningAbility, const struct FGameplayTagRequirements& TagRequirements, bool bConsumeInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_WaitAnyAbilityInput", "WaitAnyAbilityInput");

	Params::OrionAbilityTask_WaitAnyAbilityInput_WaitAnyAbilityInput Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TagRequirements = std::move(TagRequirements);
	Parms.bConsumeInput = bConsumeInput;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_WaitAnyAbilityInput.OnAnyAbilityInput
// (Final, Native, Protected)

void UOrionAbilityTask_WaitAnyAbilityInput::OnAnyAbilityInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilityTask_WaitAnyAbilityInput", "OnAnyAbilityInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilityTask_WaitEventKeywordBase.OnEventCallback
// (Native, Public)

void UOrionAbilityTask_WaitEventKeywordBase::OnEventCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilityTask_WaitEventKeywordBase", "OnEventCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilityTask_WaitDamage.WaitDamageDealt
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDamageQualifierKeywordsWithContextAdditionalQualifiers                                   (Parm, NativeAccessSpecifierPublic)
// bool                                    TriggerOnce                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_WaitDamage*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_WaitDamage* UOrionAbilityTask_WaitDamage::WaitDamageDealt(class UGameplayAbility* OwningAbility, const struct FDamageQualifierKeywordsWithContext& AdditionalQualifiers, bool TriggerOnce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_WaitDamage", "WaitDamageDealt");

	Params::OrionAbilityTask_WaitDamage_WaitDamageDealt Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.AdditionalQualifiers = std::move(AdditionalQualifiers);
	Parms.TriggerOnce = TriggerOnce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_WaitDamage.WaitDamageTaken
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDamageQualifierKeywordsWithContextAdditionalQualifiers                                   (Parm, NativeAccessSpecifierPublic)
// bool                                    TriggerOnce                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_WaitDamage*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_WaitDamage* UOrionAbilityTask_WaitDamage::WaitDamageTaken(class UGameplayAbility* OwningAbility, const struct FDamageQualifierKeywordsWithContext& AdditionalQualifiers, bool TriggerOnce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_WaitDamage", "WaitDamageTaken");

	Params::OrionAbilityTask_WaitDamage_WaitDamageTaken Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.AdditionalQualifiers = std::move(AdditionalQualifiers);
	Parms.TriggerOnce = TriggerOnce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_WaitEventKeyword.WaitEventKeyword
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEventKeywordWithQualifiers      EventInfo                                              (Parm, NativeAccessSpecifierPublic)
// bool                                    TriggerOnce                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_WaitEventKeyword*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_WaitEventKeyword* UOrionAbilityTask_WaitEventKeyword::WaitEventKeyword(class UGameplayAbility* OwningAbility, const struct FEventKeywordWithQualifiers& EventInfo, bool TriggerOnce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_WaitEventKeyword", "WaitEventKeyword");

	Params::OrionAbilityTask_WaitEventKeyword_WaitEventKeyword Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.EventInfo = std::move(EventInfo);
	Parms.TriggerOnce = TriggerOnce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_WaitForCombo.WaitForCombo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_WaitForCombo*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_WaitForCombo* UOrionAbilityTask_WaitForCombo::WaitForCombo(class UGameplayAbility* OwningAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_WaitForCombo", "WaitForCombo");

	Params::OrionAbilityTask_WaitForCombo_WaitForCombo Parms{};

	Parms.OwningAbility = OwningAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_WaitForCombo.FailEventCallback
// (Final, Native, Protected)

void UOrionAbilityTask_WaitForCombo::FailEventCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilityTask_WaitForCombo", "FailEventCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilityTask_WaitForCombo.SuccessEventCallback
// (Final, Native, Protected)

void UOrionAbilityTask_WaitForCombo::SuccessEventCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilityTask_WaitForCombo", "SuccessEventCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionButtonStyle.GetButtonPadding
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionWidgetStyleSize                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMargin                          OutButtonPadding                                       (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UOrionButtonStyle::GetButtonPadding(EOrionWidgetStyleSize Size, struct FMargin* OutButtonPadding) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionButtonStyle", "GetButtonPadding");

	Params::OrionButtonStyle_GetButtonPadding Parms{};

	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutButtonPadding != nullptr)
		*OutButtonPadding = std::move(Parms.OutButtonPadding);
}


// Function OrionGame.OrionButtonStyle.GetCustomPadding
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionWidgetStyleSize                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMargin                          OutCustomPadding                                       (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UOrionButtonStyle::GetCustomPadding(EOrionWidgetStyleSize Size, struct FMargin* OutCustomPadding) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionButtonStyle", "GetCustomPadding");

	Params::OrionButtonStyle_GetCustomPadding Parms{};

	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCustomPadding != nullptr)
		*OutCustomPadding = std::move(Parms.OutCustomPadding);
}


// Function OrionGame.OrionButtonStyle.GetDisabledBrush
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionWidgetStyleSize                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSlateBrush                      Brush                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UOrionButtonStyle::GetDisabledBrush(EOrionWidgetStyleSize Size, struct FSlateBrush* Brush) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionButtonStyle", "GetDisabledBrush");

	Params::OrionButtonStyle_GetDisabledBrush Parms{};

	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Brush != nullptr)
		*Brush = std::move(Parms.Brush);
}


// Function OrionGame.OrionButtonStyle.GetDisabledTextStyle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UOrionTextStyle*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionTextStyle* UOrionButtonStyle::GetDisabledTextStyle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionButtonStyle", "GetDisabledTextStyle");

	Params::OrionButtonStyle_GetDisabledTextStyle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionButtonStyle.GetNormalBaseBrush
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionWidgetStyleSize                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSlateBrush                      Brush                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UOrionButtonStyle::GetNormalBaseBrush(EOrionWidgetStyleSize Size, struct FSlateBrush* Brush) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionButtonStyle", "GetNormalBaseBrush");

	Params::OrionButtonStyle_GetNormalBaseBrush Parms{};

	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Brush != nullptr)
		*Brush = std::move(Parms.Brush);
}


// Function OrionGame.OrionButtonStyle.GetNormalHoveredBrush
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionWidgetStyleSize                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSlateBrush                      Brush                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UOrionButtonStyle::GetNormalHoveredBrush(EOrionWidgetStyleSize Size, struct FSlateBrush* Brush) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionButtonStyle", "GetNormalHoveredBrush");

	Params::OrionButtonStyle_GetNormalHoveredBrush Parms{};

	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Brush != nullptr)
		*Brush = std::move(Parms.Brush);
}


// Function OrionGame.OrionButtonStyle.GetNormalPressedBrush
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionWidgetStyleSize                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSlateBrush                      Brush                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UOrionButtonStyle::GetNormalPressedBrush(EOrionWidgetStyleSize Size, struct FSlateBrush* Brush) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionButtonStyle", "GetNormalPressedBrush");

	Params::OrionButtonStyle_GetNormalPressedBrush Parms{};

	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Brush != nullptr)
		*Brush = std::move(Parms.Brush);
}


// Function OrionGame.OrionButtonStyle.GetNormalTextStyle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UOrionTextStyle*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionTextStyle* UOrionButtonStyle::GetNormalTextStyle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionButtonStyle", "GetNormalTextStyle");

	Params::OrionButtonStyle_GetNormalTextStyle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionButtonStyle.GetSelectedBaseBrush
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionWidgetStyleSize                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSlateBrush                      Brush                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UOrionButtonStyle::GetSelectedBaseBrush(EOrionWidgetStyleSize Size, struct FSlateBrush* Brush) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionButtonStyle", "GetSelectedBaseBrush");

	Params::OrionButtonStyle_GetSelectedBaseBrush Parms{};

	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Brush != nullptr)
		*Brush = std::move(Parms.Brush);
}


// Function OrionGame.OrionButtonStyle.GetSelectedHoveredBrush
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionWidgetStyleSize                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSlateBrush                      Brush                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UOrionButtonStyle::GetSelectedHoveredBrush(EOrionWidgetStyleSize Size, struct FSlateBrush* Brush) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionButtonStyle", "GetSelectedHoveredBrush");

	Params::OrionButtonStyle_GetSelectedHoveredBrush Parms{};

	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Brush != nullptr)
		*Brush = std::move(Parms.Brush);
}


// Function OrionGame.OrionButtonStyle.GetSelectedPressedBrush
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionWidgetStyleSize                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSlateBrush                      Brush                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UOrionButtonStyle::GetSelectedPressedBrush(EOrionWidgetStyleSize Size, struct FSlateBrush* Brush) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionButtonStyle", "GetSelectedPressedBrush");

	Params::OrionButtonStyle_GetSelectedPressedBrush Parms{};

	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Brush != nullptr)
		*Brush = std::move(Parms.Brush);
}


// Function OrionGame.OrionButtonStyle.GetSelectedTextStyle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UOrionTextStyle*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionTextStyle* UOrionButtonStyle::GetSelectedTextStyle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionButtonStyle", "GetSelectedTextStyle");

	Params::OrionButtonStyle_GetSelectedTextStyle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_WaitForMovementInput.WaitForMovementInput
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_WaitForMovementInput*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_WaitForMovementInput* UOrionAbilityTask_WaitForMovementInput::WaitForMovementInput(class UGameplayAbility* OwningAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_WaitForMovementInput", "WaitForMovementInput");

	Params::OrionAbilityTask_WaitForMovementInput_WaitForMovementInput Parms{};

	Parms.OwningAbility = OwningAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_WaitForMovementInput.OnMovementInputCallback
// (Final, Native, Protected)

void UOrionAbilityTask_WaitForMovementInput::OnMovementInputCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilityTask_WaitForMovementInput", "OnMovementInputCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilityTask_WaitForSpecialAttackRotation.WaitForSpecialAttackRotation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionJungleTarget                      Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_WaitForSpecialAttackRotation*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_WaitForSpecialAttackRotation* UOrionAbilityTask_WaitForSpecialAttackRotation::WaitForSpecialAttackRotation(class UGameplayAbility* OwningAbility, EOrionJungleTarget Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_WaitForSpecialAttackRotation", "WaitForSpecialAttackRotation");

	Params::OrionAbilityTask_WaitForSpecialAttackRotation_WaitForSpecialAttackRotation Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_WaitHeroGameplayTag.WaitHeroGameplayTagAdd
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAllies                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnemies                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOnlyTriggerOnce                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_WaitHeroGameplayTag*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_WaitHeroGameplayTag* UOrionAbilityTask_WaitHeroGameplayTag::WaitHeroGameplayTagAdd(class UGameplayAbility* OwningAbility, const struct FGameplayTag& Tag, bool bAllies, bool bEnemies, bool bOnlyTriggerOnce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_WaitHeroGameplayTag", "WaitHeroGameplayTagAdd");

	Params::OrionAbilityTask_WaitHeroGameplayTag_WaitHeroGameplayTagAdd Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.Tag = std::move(Tag);
	Parms.bAllies = bAllies;
	Parms.bEnemies = bEnemies;
	Parms.bOnlyTriggerOnce = bOnlyTriggerOnce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_WaitHeroGameplayTag.WaitHeroGameplayTagRemove
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAllies                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnemies                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOnlyTriggerOnce                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_WaitHeroGameplayTag*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_WaitHeroGameplayTag* UOrionAbilityTask_WaitHeroGameplayTag::WaitHeroGameplayTagRemove(class UGameplayAbility* OwningAbility, const struct FGameplayTag& Tag, bool bAllies, bool bEnemies, bool bOnlyTriggerOnce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_WaitHeroGameplayTag", "WaitHeroGameplayTagRemove");

	Params::OrionAbilityTask_WaitHeroGameplayTag_WaitHeroGameplayTagRemove Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.Tag = std::move(Tag);
	Parms.bAllies = bAllies;
	Parms.bEnemies = bEnemies;
	Parms.bOnlyTriggerOnce = bOnlyTriggerOnce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_WaitInputPress_WithState.WaitInputPress_WithState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTestAlreadyPressed                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceAlreadyPressed                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_WaitInputPress_WithState*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_WaitInputPress_WithState* UOrionAbilityTask_WaitInputPress_WithState::WaitInputPress_WithState(class UGameplayAbility* OwningAbility, bool bTestAlreadyPressed, bool bForceAlreadyPressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_WaitInputPress_WithState", "WaitInputPress_WithState");

	Params::OrionAbilityTask_WaitInputPress_WithState_WaitInputPress_WithState Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.bTestAlreadyPressed = bTestAlreadyPressed;
	Parms.bForceAlreadyPressed = bForceAlreadyPressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_WaitInputPress_WithState.OnPressCallback
// (Final, Native, Public)

void UOrionAbilityTask_WaitInputPress_WithState::OnPressCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilityTask_WaitInputPress_WithState", "OnPressCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilityTask_WaitKilled.WaitActorKilled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagRequirements         SourceTagRequirements                                  (Parm, NativeAccessSpecifierPublic)
// struct FGameplayTagRequirements         TargetTagRequirements                                  (Parm, NativeAccessSpecifierPublic)
// bool                                    TriggerOnce                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_WaitKilled*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_WaitKilled* UOrionAbilityTask_WaitKilled::WaitActorKilled(class UGameplayAbility* OwningAbility, class AActor* Actor, const struct FGameplayTagRequirements& SourceTagRequirements, const struct FGameplayTagRequirements& TargetTagRequirements, bool TriggerOnce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_WaitKilled", "WaitActorKilled");

	Params::OrionAbilityTask_WaitKilled_WaitActorKilled Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.Actor = Actor;
	Parms.SourceTagRequirements = std::move(SourceTagRequirements);
	Parms.TargetTagRequirements = std::move(TargetTagRequirements);
	Parms.TriggerOnce = TriggerOnce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_WaitKilled.WaitOwnerKilled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagRequirements         SourceTagRequirements                                  (Parm, NativeAccessSpecifierPublic)
// struct FGameplayTagRequirements         TargetTagRequirements                                  (Parm, NativeAccessSpecifierPublic)
// bool                                    TriggerOnce                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_WaitKilled*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_WaitKilled* UOrionAbilityTask_WaitKilled::WaitOwnerKilled(class UGameplayAbility* OwningAbility, const struct FGameplayTagRequirements& SourceTagRequirements, const struct FGameplayTagRequirements& TargetTagRequirements, bool TriggerOnce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_WaitKilled", "WaitOwnerKilled");

	Params::OrionAbilityTask_WaitKilled_WaitOwnerKilled Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.SourceTagRequirements = std::move(SourceTagRequirements);
	Parms.TargetTagRequirements = std::move(TargetTagRequirements);
	Parms.TriggerOnce = TriggerOnce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_WaitKilled.OnKilledCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayEffectSpec              Spec                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOrionAbilityTask_WaitKilled::OnKilledCallback(const struct FGameplayEffectSpec& Spec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilityTask_WaitKilled", "OnKilledCallback");

	Params::OrionAbilityTask_WaitKilled_OnKilledCallback Parms{};

	Parms.Spec = std::move(Spec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilityTask_WaitLanded.WaitLanded
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_WaitLanded*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_WaitLanded* UOrionAbilityTask_WaitLanded::WaitLanded(class UGameplayAbility* OwningAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_WaitLanded", "WaitLanded");

	Params::OrionAbilityTask_WaitLanded_WaitLanded Parms{};

	Parms.OwningAbility = OwningAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_WaitLanded.OnLandedCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UOrionAbilityTask_WaitLanded::OnLandedCallback(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilityTask_WaitLanded", "OnLandedCallback");

	Params::OrionAbilityTask_WaitLanded_OnLandedCallback Parms{};

	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilityTask_WaitMeleeImpact.CreateWaitMovementModeChange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_WaitMeleeImpact*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_WaitMeleeImpact* UOrionAbilityTask_WaitMeleeImpact::CreateWaitMovementModeChange(class UGameplayAbility* OwningAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_WaitMeleeImpact", "CreateWaitMovementModeChange");

	Params::OrionAbilityTask_WaitMeleeImpact_CreateWaitMovementModeChange Parms{};

	Parms.OwningAbility = OwningAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_WaitMeleeImpact.OnMeleeImpact
// (Final, Native, Public, HasOutParams)
// Parameters:
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UOrionAbilityTask_WaitMeleeImpact::OnMeleeImpact(class AActor* OtherActor, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilityTask_WaitMeleeImpact", "OnMeleeImpact");

	Params::OrionAbilityTask_WaitMeleeImpact_OnMeleeImpact Parms{};

	Parms.OtherActor = OtherActor;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilityTask_WaitProjectileShutdown.WaitProjectileShutdown
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOrionProjectile*                 Projectile_0                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_WaitProjectileShutdown*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_WaitProjectileShutdown* UOrionAbilityTask_WaitProjectileShutdown::WaitProjectileShutdown(class UGameplayAbility* OwningAbility, class AOrionProjectile* Projectile_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_WaitProjectileShutdown", "WaitProjectileShutdown");

	Params::OrionAbilityTask_WaitProjectileShutdown_WaitProjectileShutdown Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.Projectile_0 = Projectile_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_WaitProjectileShutdown.OnShutdownCallback
// (Final, Native, Protected)

void UOrionAbilityTask_WaitProjectileShutdown::OnShutdownCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilityTask_WaitProjectileShutdown", "OnShutdownCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilityTask_WaitProjectileHitActor.WaitProjectileHitActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOrionProjectile*                 Projectile_0                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_WaitProjectileHitActor*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_WaitProjectileHitActor* UOrionAbilityTask_WaitProjectileHitActor::WaitProjectileHitActor(class UGameplayAbility* OwningAbility, class AOrionProjectile* Projectile_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_WaitProjectileHitActor", "WaitProjectileHitActor");

	Params::OrionAbilityTask_WaitProjectileHitActor_WaitProjectileHitActor Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.Projectile_0 = Projectile_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_WaitProjectileHitActor.OnHitActorCallback
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UOrionAbilityTask_WaitProjectileHitActor::OnHitActorCallback(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilityTask_WaitProjectileHitActor", "OnHitActorCallback");

	Params::OrionAbilityTask_WaitProjectileHitActor_OnHitActorCallback Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilityTask_WaitProjectileHitActor.OnShutdownCallback
// (Final, Native, Protected)

void UOrionAbilityTask_WaitProjectileHitActor::OnShutdownCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilityTask_WaitProjectileHitActor", "OnShutdownCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilityTask_WaitProjectileStop.WaitProjectileStop
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOrionProjectile*                 Projectile_0                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_WaitProjectileStop*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_WaitProjectileStop* UOrionAbilityTask_WaitProjectileStop::WaitProjectileStop(class UGameplayAbility* OwningAbility, class AOrionProjectile* Projectile_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_WaitProjectileStop", "WaitProjectileStop");

	Params::OrionAbilityTask_WaitProjectileStop_WaitProjectileStop Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.Projectile_0 = Projectile_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_WaitProjectileStop.OnShutdownCallback
// (Final, Native, Protected)

void UOrionAbilityTask_WaitProjectileStop::OnShutdownCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilityTask_WaitProjectileStop", "OnShutdownCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilityTask_WaitProjectileStop.OnStopCallback
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UOrionAbilityTask_WaitProjectileStop::OnStopCallback(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilityTask_WaitProjectileStop", "OnStopCallback");

	Params::OrionAbilityTask_WaitProjectileStop_OnStopCallback Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilityTask_WaitSprintCancel.WaitSprintCancel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_WaitSprintCancel*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_WaitSprintCancel* UOrionAbilityTask_WaitSprintCancel::WaitSprintCancel(class UGameplayAbility* OwningAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_WaitSprintCancel", "WaitSprintCancel");

	Params::OrionAbilityTask_WaitSprintCancel_WaitSprintCancel Parms{};

	Parms.OwningAbility = OwningAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAbilityTask_WaitSprintCancel.HandleReplicatedEvent
// (Final, Native, Protected)

void UOrionAbilityTask_WaitSprintCancel::HandleReplicatedEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilityTask_WaitSprintCancel", "HandleReplicatedEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilityTask_WaitSprintCancel.OnSprintDirectionChanged
// (Final, Native, Protected)

void UOrionAbilityTask_WaitSprintCancel::OnSprintDirectionChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAbilityTask_WaitSprintCancel", "OnSprintDirectionChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAbilityTask_WaitTowerTargetAcquired.WaitTowerTargetAcquired
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAbilityTask_WaitTowerTargetAcquired*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAbilityTask_WaitTowerTargetAcquired* UOrionAbilityTask_WaitTowerTargetAcquired::WaitTowerTargetAcquired(class UGameplayAbility* OwningAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAbilityTask_WaitTowerTargetAcquired", "WaitTowerTargetAcquired");

	Params::OrionAbilityTask_WaitTowerTargetAcquired_WaitTowerTargetAcquired Parms{};

	Parms.OwningAbility = OwningAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCheatManagerBase.AddTestNotification
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::AddTestNotification(int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "AddTestNotification");

	Params::OrionCheatManagerBase_AddTestNotification Parms{};

	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.CalculateMaxMMRDelta
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   SecondsInQueue                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   YourMMR                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::CalculateMaxMMRDelta(int32 SecondsInQueue, int32 YourMMR)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "CalculateMaxMMRDelta");

	Params::OrionCheatManagerBase_CalculateMaxMMRDelta Parms{};

	Parms.SecondsInQueue = SecondsInQueue;
	Parms.YourMMR = YourMMR;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.ClearCardOnboardingClientRecord
// (Final, Exec, Native, Public)

void UOrionCheatManagerBase::ClearCardOnboardingClientRecord()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "ClearCardOnboardingClientRecord");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.ClearDeckBuilderOnboardingSeenClientRecord
// (Final, Exec, Native, Public)

void UOrionCheatManagerBase::ClearDeckBuilderOnboardingSeenClientRecord()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "ClearDeckBuilderOnboardingSeenClientRecord");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.ClearNewCardsUpdateSeenClientRecord
// (Final, Exec, Native, Public)

void UOrionCheatManagerBase::ClearNewCardsUpdateSeenClientRecord()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "ClearNewCardsUpdateSeenClientRecord");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.DraftPick
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           HeroName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::DraftPick(const class FString& HeroName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "DraftPick");

	Params::OrionCheatManagerBase_DraftPick Parms{};

	Parms.HeroName = std::move(HeroName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.DumpPlaylistInfos
// (Final, Exec, Native, Public)

void UOrionCheatManagerBase::DumpPlaylistInfos()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "DumpPlaylistInfos");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.DumpPlaylistInfosVerbose
// (Final, Exec, Native, Public)

void UOrionCheatManagerBase::DumpPlaylistInfosVerbose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "DumpPlaylistInfosVerbose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.DumpReservations
// (Final, Exec, Native, Public)

void UOrionCheatManagerBase::DumpReservations()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "DumpReservations");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.DumpTeamInfo
// (Final, Exec, Native, Public)

void UOrionCheatManagerBase::DumpTeamInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "DumpTeamInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.EComListCatalogOffers
// (Final, Exec, Native, Public)

void UOrionCheatManagerBase::EComListCatalogOffers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "EComListCatalogOffers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.EComPurchaseOffer
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           StorefrontName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OfferIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Quantity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::EComPurchaseOffer(const class FString& StorefrontName, int32 OfferIndex, int32 Quantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "EComPurchaseOffer");

	Params::OrionCheatManagerBase_EComPurchaseOffer Parms{};

	Parms.StorefrontName = std::move(StorefrontName);
	Parms.OfferIndex = OfferIndex;
	Parms.Quantity = Quantity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.ForceHideMouseCursor
// (Final, Exec, Native, Public)

void UOrionCheatManagerBase::ForceHideMouseCursor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "ForceHideMouseCursor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.ForceMouseCursor
// (Final, Exec, Native, Public)

void UOrionCheatManagerBase::ForceMouseCursor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "ForceMouseCursor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.ForceRotationalContent
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Msg                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::ForceRotationalContent(const class FString& Msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "ForceRotationalContent");

	Params::OrionCheatManagerBase_ForceRotationalContent Parms{};

	Parms.Msg = std::move(Msg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.GenerateBotMatchup
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           DifficultyName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::GenerateBotMatchup(const class FString& DifficultyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "GenerateBotMatchup");

	Params::OrionCheatManagerBase_GenerateBotMatchup Parms{};

	Parms.DifficultyName = std::move(DifficultyName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.GetAccountMMR
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           RatingType                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::GetAccountMMR(const class FString& RatingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "GetAccountMMR");

	Params::OrionCheatManagerBase_GetAccountMMR Parms{};

	Parms.RatingType = std::move(RatingType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.HideLoadingScreen
// (Final, Exec, Native, Public)

void UOrionCheatManagerBase::HideLoadingScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "HideLoadingScreen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.HideTowerTargetingBeams
// (Final, Exec, Native, Public)

void UOrionCheatManagerBase::HideTowerTargetingBeams()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "HideTowerTargetingBeams");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.IcmpPingAddr
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Target                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::IcmpPingAddr(const class FString& Target, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "IcmpPingAddr");

	Params::OrionCheatManagerBase_IcmpPingAddr Parms{};

	Parms.Target = std::move(Target);
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.LBBugIt
// (Final, Exec, Native, Public)

void UOrionCheatManagerBase::LBBugIt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "LBBugIt");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.McpCheat
// (Final, Exec, Native, Public)

void UOrionCheatManagerBase::McpCheat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "McpCheat");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.McpGetUnredeemedCodes
// (Final, Exec, Native, Public)

void UOrionCheatManagerBase::McpGetUnredeemedCodes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "McpGetUnredeemedCodes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.McpGetVersion
// (Final, Exec, Native, Public)

void UOrionCheatManagerBase::McpGetVersion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "McpGetVersion");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.McpIssueCodeToken
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           TokenId                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::McpIssueCodeToken(const class FString& TokenId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "McpIssueCodeToken");

	Params::OrionCheatManagerBase_McpIssueCodeToken Parms{};

	Parms.TokenId = std::move(TokenId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.McpLogin
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           User                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Password                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::McpLogin(const class FString& User, const class FString& Password)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "McpLogin");

	Params::OrionCheatManagerBase_McpLogin Parms{};

	Parms.User = std::move(User);
	Parms.Password = std::move(Password);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.McpLogout
// (Final, Exec, Native, Public)

void UOrionCheatManagerBase::McpLogout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "McpLogout");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.McpOpenGiftBox
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           GiftBoxItemID                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::McpOpenGiftBox(const class FString& GiftBoxItemID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "McpOpenGiftBox");

	Params::OrionCheatManagerBase_McpOpenGiftBox Parms{};

	Parms.GiftBoxItemID = std::move(GiftBoxItemID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.McpRedeemPurchases
// (Final, Exec, Native, Public)

void UOrionCheatManagerBase::McpRedeemPurchases()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "McpRedeemPurchases");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.McpRefreshProfile
// (Final, Exec, Native, Public)

void UOrionCheatManagerBase::McpRefreshProfile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "McpRefreshProfile");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.McpSimulateMatchComplete
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bVictory                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           HeroName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::McpSimulateMatchComplete(bool bVictory, const class FString& HeroName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "McpSimulateMatchComplete");

	Params::OrionCheatManagerBase_McpSimulateMatchComplete Parms{};

	Parms.bVictory = bVictory;
	Parms.HeroName = std::move(HeroName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.McpSimulateMatchCompleteAbandon
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bVictory                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           HeroName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::McpSimulateMatchCompleteAbandon(bool bVictory, const class FString& HeroName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "McpSimulateMatchCompleteAbandon");

	Params::OrionCheatManagerBase_McpSimulateMatchCompleteAbandon Parms{};

	Parms.bVictory = bVictory;
	Parms.HeroName = std::move(HeroName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.McpTestSubmitLogs
// (Final, Exec, Native, Public)

void UOrionCheatManagerBase::McpTestSubmitLogs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "McpTestSubmitLogs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.McpTestTeamBuilderGetMatchTimes
// (Final, Exec, Native, Public)

void UOrionCheatManagerBase::McpTestTeamBuilderGetMatchTimes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "McpTestTeamBuilderGetMatchTimes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.McpTestTeamBuilderTeamSlots
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           MatchmakingBucket                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SlotCount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::McpTestTeamBuilderTeamSlots(const class FString& MatchmakingBucket, int32 SlotCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "McpTestTeamBuilderTeamSlots");

	Params::OrionCheatManagerBase_McpTestTeamBuilderTeamSlots Parms{};

	Parms.MatchmakingBucket = std::move(MatchmakingBucket);
	Parms.SlotCount = SlotCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.OrionDemoMode
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bDemoMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::OrionDemoMode(bool bDemoMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "OrionDemoMode");

	Params::OrionCheatManagerBase_OrionDemoMode Parms{};

	Parms.bDemoMode = bDemoMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.OrionForceCharLOD
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   LOD                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::OrionForceCharLOD(int32 LOD)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "OrionForceCharLOD");

	Params::OrionCheatManagerBase_OrionForceCharLOD Parms{};

	Parms.LOD = LOD;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.OrionWatermark
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::OrionWatermark(int32 Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "OrionWatermark");

	Params::OrionCheatManagerBase_OrionWatermark Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.PingStress
// (Final, Exec, Native, Public)

void UOrionCheatManagerBase::PingStress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "PingStress");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.PlayVideo
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           VideoID                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::PlayVideo(const class FString& VideoID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "PlayVideo");

	Params::OrionCheatManagerBase_PlayVideo Parms{};

	Parms.VideoID = std::move(VideoID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.ReplaySetAperture
// (Final, Exec, Native, Public)
// Parameters:
// float                                   FStop                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::ReplaySetAperture(float FStop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "ReplaySetAperture");

	Params::OrionCheatManagerBase_ReplaySetAperture Parms{};

	Parms.FStop = FStop;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.ReplaySetAutoExposure
// (Final, Exec, Native, Public)

void UOrionCheatManagerBase::ReplaySetAutoExposure()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "ReplaySetAutoExposure");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.ReplaySetAutoFocus
// (Final, Exec, Native, Public)

void UOrionCheatManagerBase::ReplaySetAutoFocus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "ReplaySetAutoFocus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.ReplaySetDroneCollision
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bCollides                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::ReplaySetDroneCollision(bool bCollides)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "ReplaySetDroneCollision");

	Params::OrionCheatManagerBase_ReplaySetDroneCollision Parms{};

	Parms.bCollides = bCollides;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.ReplaySetManualExposure
// (Final, Exec, Native, Public)
// Parameters:
// float                                   ExposureBias                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::ReplaySetManualExposure(float ExposureBias)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "ReplaySetManualExposure");

	Params::OrionCheatManagerBase_ReplaySetManualExposure Parms{};

	Parms.ExposureBias = ExposureBias;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.ReplaySetManualFocus
// (Final, Exec, Native, Public)
// Parameters:
// float                                   NewFocusDistance                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::ReplaySetManualFocus(float NewFocusDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "ReplaySetManualFocus");

	Params::OrionCheatManagerBase_ReplaySetManualFocus Parms{};

	Parms.NewFocusDistance = NewFocusDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.ReplayShowFocusPlane
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bShowFocusPlane                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::ReplayShowFocusPlane(bool bShowFocusPlane)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "ReplayShowFocusPlane");

	Params::OrionCheatManagerBase_ReplayShowFocusPlane Parms{};

	Parms.bShowFocusPlane = bShowFocusPlane;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.ResetDraft
// (Final, Exec, Native, Public)

void UOrionCheatManagerBase::ResetDraft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "ResetDraft");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.ResetNewDawnVideo
// (Final, Exec, Native, Public)

void UOrionCheatManagerBase::ResetNewDawnVideo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "ResetNewDawnVideo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.SetGamepadConfig
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   ConfigIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::SetGamepadConfig(int32 ConfigIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "SetGamepadConfig");

	Params::OrionCheatManagerBase_SetGamepadConfig Parms{};

	Parms.ConfigIndex = ConfigIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.SetGamepadSensitivity
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   YawIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PitchIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::SetGamepadSensitivity(int32 YawIndex, int32 PitchIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "SetGamepadSensitivity");

	Params::OrionCheatManagerBase_SetGamepadSensitivity Parms{};

	Parms.YawIndex = YawIndex;
	Parms.PitchIndex = PitchIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.SetHomeScreenHero
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           HeroName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Skin                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SkinVariation                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::SetHomeScreenHero(const class FString& HeroName, const class FString& Skin, const class FString& SkinVariation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "SetHomeScreenHero");

	Params::OrionCheatManagerBase_SetHomeScreenHero Parms{};

	Parms.HeroName = std::move(HeroName);
	Parms.Skin = std::move(Skin);
	Parms.SkinVariation = std::move(SkinVariation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.SetInputMode
// (Final, Exec, Native, Public)
// Parameters:
// EOrionInputType                         Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::SetInputMode(EOrionInputType Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "SetInputMode");

	Params::OrionCheatManagerBase_SetInputMode Parms{};

	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.SetNumLobbyPlayers
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   NumLobbyPlayers                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::SetNumLobbyPlayers(int32 NumLobbyPlayers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "SetNumLobbyPlayers");

	Params::OrionCheatManagerBase_SetNumLobbyPlayers Parms{};

	Parms.NumLobbyPlayers = NumLobbyPlayers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.SetParallaxLerpSpeed
// (Final, Exec, Native, Public)
// Parameters:
// float                                   LerpSpeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::SetParallaxLerpSpeed(float LerpSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "SetParallaxLerpSpeed");

	Params::OrionCheatManagerBase_SetParallaxLerpSpeed Parms{};

	Parms.LerpSpeed = LerpSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.SetParallaxScaleFactor
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Factor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::SetParallaxScaleFactor(float Factor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "SetParallaxScaleFactor");

	Params::OrionCheatManagerBase_SetParallaxScaleFactor Parms{};

	Parms.Factor = Factor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.SetPerfBots
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           HeroList                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::SetPerfBots(const class FString& HeroList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "SetPerfBots");

	Params::OrionCheatManagerBase_SetPerfBots Parms{};

	Parms.HeroList = std::move(HeroList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.ShowLoadingScreen
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::ShowLoadingScreen(int32 Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "ShowLoadingScreen");

	Params::OrionCheatManagerBase_ShowLoadingScreen Parms{};

	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.ShowLoadingScreenByName
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           ModeName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::ShowLoadingScreenByName(const class FString& ModeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "ShowLoadingScreenByName");

	Params::OrionCheatManagerBase_ShowLoadingScreenByName Parms{};

	Parms.ModeName = std::move(ModeName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.TBAcceptSocialInvite
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bAccept                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::TBAcceptSocialInvite(bool bAccept)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "TBAcceptSocialInvite");

	Params::OrionCheatManagerBase_TBAcceptSocialInvite Parms{};

	Parms.bAccept = bAccept;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.TBCancelMatchmaking
// (Final, Exec, Native, Public)

void UOrionCheatManagerBase::TBCancelMatchmaking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "TBCancelMatchmaking");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.TBCancelSlot
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   SlotIdx                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::TBCancelSlot(int32 SlotIdx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "TBCancelSlot");

	Params::OrionCheatManagerBase_TBCancelSlot Parms{};

	Parms.SlotIdx = SlotIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.TBCaptain
// (Final, Exec, Native, Public)

void UOrionCheatManagerBase::TBCaptain()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "TBCaptain");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.TBCaptainAcceptSlot
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   SlotIdx                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAccept                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::TBCaptainAcceptSlot(int32 SlotIdx, bool bAccept)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "TBCaptainAcceptSlot");

	Params::OrionCheatManagerBase_TBCaptainAcceptSlot Parms{};

	Parms.SlotIdx = SlotIdx;
	Parms.bAccept = bAccept;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.TBClearDebugState
// (Final, Exec, Native, Public)

void UOrionCheatManagerBase::TBClearDebugState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "TBClearDebugState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.TBDebugState
// (Final, Exec, Native, Public)

void UOrionCheatManagerBase::TBDebugState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "TBDebugState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.TBLeaveTeam
// (Final, Exec, Native, Public)

void UOrionCheatManagerBase::TBLeaveTeam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "TBLeaveTeam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.TBMultiSoloRider
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   NumRiders                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::TBMultiSoloRider(int32 NumRiders)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "TBMultiSoloRider");

	Params::OrionCheatManagerBase_TBMultiSoloRider Parms{};

	Parms.NumRiders = NumRiders;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.TBQuickmatch
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bCoopVsAI                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           HeroName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::TBQuickmatch(bool bCoopVsAI, const class FString& HeroName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "TBQuickmatch");

	Params::OrionCheatManagerBase_TBQuickmatch Parms{};

	Parms.bCoopVsAI = bCoopVsAI;
	Parms.HeroName = std::move(HeroName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.TBSetReady
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bReady                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::TBSetReady(bool bReady)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "TBSetReady");

	Params::OrionCheatManagerBase_TBSetReady Parms{};

	Parms.bReady = bReady;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.TBSetSlotChoice
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   SlotIdx                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Role                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::TBSetSlotChoice(int32 SlotIdx, int32 Position, int32 Role)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "TBSetSlotChoice");

	Params::OrionCheatManagerBase_TBSetSlotChoice Parms{};

	Parms.SlotIdx = SlotIdx;
	Parms.Position = Position;
	Parms.Role = Role;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.TBStartTeamMatchmaking
// (Final, Exec, Native, Public)

void UOrionCheatManagerBase::TBStartTeamMatchmaking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "TBStartTeamMatchmaking");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.TBUnlockSoloRider
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           SoloriderUserId                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::TBUnlockSoloRider(const class FString& SoloriderUserId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "TBUnlockSoloRider");

	Params::OrionCheatManagerBase_TBUnlockSoloRider Parms{};

	Parms.SoloriderUserId = std::move(SoloriderUserId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.TestChangePartyPrivacy
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bPrivate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLeaderFriendsOnly                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLeaderInvitesOnly                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::TestChangePartyPrivacy(bool bPrivate, bool bLeaderFriendsOnly, bool bLeaderInvitesOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "TestChangePartyPrivacy");

	Params::OrionCheatManagerBase_TestChangePartyPrivacy Parms{};

	Parms.bPrivate = bPrivate;
	Parms.bLeaderFriendsOnly = bLeaderFriendsOnly;
	Parms.bLeaderInvitesOnly = bLeaderInvitesOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.TestChangePartySize
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   NewSize                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::TestChangePartySize(int32 NewSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "TestChangePartySize");

	Params::OrionCheatManagerBase_TestChangePartySize Parms{};

	Parms.NewSize = NewSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.TestComputeBestTeamComp
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           HeroListName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::TestComputeBestTeamComp(const class FString& HeroListName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "TestComputeBestTeamComp");

	Params::OrionCheatManagerBase_TestComputeBestTeamComp Parms{};

	Parms.HeroListName = std::move(HeroListName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.TestGracefulShutdownServer
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   ExitCode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::TestGracefulShutdownServer(int32 ExitCode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "TestGracefulShutdownServer");

	Params::OrionCheatManagerBase_TestGracefulShutdownServer Parms{};

	Parms.ExitCode = ExitCode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.TestLobbyBuilderAcceptMatch
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bAcceptMatch                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::TestLobbyBuilderAcceptMatch(bool bAcceptMatch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "TestLobbyBuilderAcceptMatch");

	Params::OrionCheatManagerBase_TestLobbyBuilderAcceptMatch Parms{};

	Parms.bAcceptMatch = bAcceptMatch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.TestLobbyBuilderCancel
// (Final, Exec, Native, Public)

void UOrionCheatManagerBase::TestLobbyBuilderCancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "TestLobbyBuilderCancel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.TestLobbyBuilderMatchmake
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   PlaylistId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::TestLobbyBuilderMatchmake(int32 PlaylistId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "TestLobbyBuilderMatchmake");

	Params::OrionCheatManagerBase_TestLobbyBuilderMatchmake Parms{};

	Parms.PlaylistId = PlaylistId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.TestSoloRiderAcceptOrRejectInvite
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bAccept                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RiderIdx                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::TestSoloRiderAcceptOrRejectInvite(bool bAccept, int32 RiderIdx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "TestSoloRiderAcceptOrRejectInvite");

	Params::OrionCheatManagerBase_TestSoloRiderAcceptOrRejectInvite Parms{};

	Parms.bAccept = bAccept;
	Parms.RiderIdx = RiderIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.TestSoloRiderCancelAdvertising
// (Final, Exec, Native, Public)

void UOrionCheatManagerBase::TestSoloRiderCancelAdvertising()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "TestSoloRiderCancelAdvertising");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.TestSoloRiderStartAdvertising
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           HeroName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Role                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::TestSoloRiderStartAdvertising(const class FString& HeroName, int32 Position, int32 Role)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "TestSoloRiderStartAdvertising");

	Params::OrionCheatManagerBase_TestSoloRiderStartAdvertising Parms{};

	Parms.HeroName = std::move(HeroName);
	Parms.Position = Position;
	Parms.Role = Role;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.ToggleUI
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::ToggleUI(int32 Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "ToggleUI");

	Params::OrionCheatManagerBase_ToggleUI Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.TriggerAfk
// (Final, Exec, Native, Public)

void UOrionCheatManagerBase::TriggerAfk()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "TriggerAfk");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.TriggerReturnFromAfk
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   NewAfkPeriod                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::TriggerReturnFromAfk(int32 NewAfkPeriod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "TriggerReturnFromAfk");

	Params::OrionCheatManagerBase_TriggerReturnFromAfk Parms{};

	Parms.NewAfkPeriod = NewAfkPeriod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerBase.UdpPingAddr
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Target                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerBase::UdpPingAddr(const class FString& Target, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerBase", "UdpPingAddr");

	Params::OrionCheatManagerBase_UdpPingAddr Parms{};

	Parms.Target = std::move(Target);
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUserWidgetBase.FireAnalyticsEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionUIAnalyticsTrackingLevel          EventTrackingLevel                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           WidgetType                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           EventName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionUserWidgetBase::FireAnalyticsEvent(EOrionUIAnalyticsTrackingLevel EventTrackingLevel, const class FString& WidgetType, const class FString& EventName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUserWidgetBase", "FireAnalyticsEvent");

	Params::OrionUserWidgetBase_FireAnalyticsEvent Parms{};

	Parms.EventTrackingLevel = EventTrackingLevel;
	Parms.WidgetType = std::move(WidgetType);
	Parms.EventName = std::move(EventName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUserWidgetBase.FireAnalyticsEventWithParam
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionUIAnalyticsTrackingLevel          EventTrackingLevel                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           WidgetType                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           EventName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ParamName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ParamValue                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionUserWidgetBase::FireAnalyticsEventWithParam(EOrionUIAnalyticsTrackingLevel EventTrackingLevel, const class FString& WidgetType, const class FString& EventName, const class FString& ParamName, const class FString& ParamValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUserWidgetBase", "FireAnalyticsEventWithParam");

	Params::OrionUserWidgetBase_FireAnalyticsEventWithParam Parms{};

	Parms.EventTrackingLevel = EventTrackingLevel;
	Parms.WidgetType = std::move(WidgetType);
	Parms.EventName = std::move(EventName);
	Parms.ParamName = std::move(ParamName);
	Parms.ParamValue = std::move(ParamValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUserWidgetBase.InitTooltipAnchor
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionUserWidgetBase::InitTooltipAnchor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUserWidgetBase", "InitTooltipAnchor");

	Params::OrionUserWidgetBase_InitTooltipAnchor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUserWidgetBase.RequestHideTooltip
// (Final, Native, Public, BlueprintCallable)

void UOrionUserWidgetBase::RequestHideTooltip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUserWidgetBase", "RequestHideTooltip");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUserWidgetBase.RequestShowTooltip
// (Final, Native, Public, BlueprintCallable)

void UOrionUserWidgetBase::RequestShowTooltip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUserWidgetBase", "RequestShowTooltip");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUserWidgetBase.SetBasicTooltipInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             NewTooltipTitle                                        (Parm, NativeAccessSpecifierPublic)
// class FText                             NewTooltipText                                         (Parm, NativeAccessSpecifierPublic)

void UOrionUserWidgetBase::SetBasicTooltipInfo(const class FText& NewTooltipTitle, const class FText& NewTooltipText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUserWidgetBase", "SetBasicTooltipInfo");

	Params::OrionUserWidgetBase_SetBasicTooltipInfo Parms{};

	Parms.NewTooltipTitle = std::move(NewTooltipTitle);
	Parms.NewTooltipText = std::move(NewTooltipText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUserWidgetBase.SetBasicTooltipText
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             NewTooltipText                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOrionUserWidgetBase::SetBasicTooltipText(const class FText& NewTooltipText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUserWidgetBase", "SetBasicTooltipText");

	Params::OrionUserWidgetBase_SetBasicTooltipText Parms{};

	Parms.NewTooltipText = std::move(NewTooltipText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUserWidgetBase.SetBasicTooltipTitle
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             NewTooltipTitle                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOrionUserWidgetBase::SetBasicTooltipTitle(const class FText& NewTooltipTitle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUserWidgetBase", "SetBasicTooltipTitle");

	Params::OrionUserWidgetBase_SetBasicTooltipTitle Parms{};

	Parms.NewTooltipTitle = std::move(NewTooltipTitle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUserWidgetBase.SetTooltipAnchorPlacement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMenuPlacement                          TooltipPlacement                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionUserWidgetBase::SetTooltipAnchorPlacement(EMenuPlacement TooltipPlacement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUserWidgetBase", "SetTooltipAnchorPlacement");

	Params::OrionUserWidgetBase_SetTooltipAnchorPlacement Parms{};

	Parms.TooltipPlacement = TooltipPlacement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUserWidgetBase.BP_OnGetTooltipWidget
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UOrionUserWidgetBase::BP_OnGetTooltipWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUserWidgetBase", "BP_OnGetTooltipWidget");

	Params::OrionUserWidgetBase_BP_OnGetTooltipWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUserWidgetBase.GetBasicTooltipText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FText                       ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const class FText UOrionUserWidgetBase::GetBasicTooltipText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUserWidgetBase", "GetBasicTooltipText");

	Params::OrionUserWidgetBase_GetBasicTooltipText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUserWidgetBase.GetClientSettings
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UOrionClientSettingsRecord*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionClientSettingsRecord* UOrionUserWidgetBase::GetClientSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUserWidgetBase", "GetClientSettings");

	Params::OrionUserWidgetBase_GetClientSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionActivatableWidget.ActivateWidget
// (Final, Native, Public, BlueprintCallable)

void UOrionActivatableWidget::ActivateWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionActivatableWidget", "ActivateWidget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionActivatableWidget.AddDeactivateAnalyticsParam
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ParamName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ParamValue                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionActivatableWidget::AddDeactivateAnalyticsParam(const class FString& ParamName, const class FString& ParamValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionActivatableWidget", "AddDeactivateAnalyticsParam");

	Params::OrionActivatableWidget_AddDeactivateAnalyticsParam Parms{};

	Parms.ParamName = std::move(ParamName);
	Parms.ParamValue = std::move(ParamValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionActivatableWidget.DeactivateWidget
// (Final, Native, Public, BlueprintCallable)

void UOrionActivatableWidget::DeactivateWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionActivatableWidget", "DeactivateWidget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionActivatableWidget.OnActivated
// (Event, Protected, BlueprintEvent)

void UOrionActivatableWidget::OnActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionActivatableWidget", "OnActivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionActivatableWidget.OnDeactivated
// (Event, Protected, BlueprintEvent)

void UOrionActivatableWidget::OnDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionActivatableWidget", "OnDeactivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionActivatableWidget.OnHandleBackAction
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionActivatableWidget::OnHandleBackAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionActivatableWidget", "OnHandleBackAction");

	Params::OrionActivatableWidget_OnHandleBackAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTargetingMode_FacetShape.OnConfirmAllowedChange
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ConfirmAllowed                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionTargetingMode_FacetShape::OnConfirmAllowedChange(bool ConfirmAllowed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTargetingMode_FacetShape", "OnConfirmAllowedChange");

	Params::OrionTargetingMode_FacetShape_OnConfirmAllowedChange Parms{};

	Parms.ConfirmAllowed = ConfirmAllowed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionTargetingMode_FacetShape.OnFacetBeamBuilt
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          Start                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionTargetingMode_FacetShape::OnFacetBeamBuilt(const struct FVector& Start, const struct FVector& End, float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTargetingMode_FacetShape", "OnFacetBeamBuilt");

	Params::OrionTargetingMode_FacetShape_OnFacetBeamBuilt Parms{};

	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Radius = Radius;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionTargetingMode_FacetShape.OnFacetBoxBuilt
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          MinBounds                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          MaxBounds                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionTargetingMode_FacetShape::OnFacetBoxBuilt(const struct FVector& MinBounds, const struct FVector& MaxBounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTargetingMode_FacetShape", "OnFacetBoxBuilt");

	Params::OrionTargetingMode_FacetShape_OnFacetBoxBuilt Parms{};

	Parms.MinBounds = std::move(MinBounds);
	Parms.MaxBounds = std::move(MaxBounds);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionTargetingMode_FacetShape.OnFacetCharacterBuilt
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionTargetingMode_FacetShape::OnFacetCharacterBuilt(float Radius, float HalfHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTargetingMode_FacetShape", "OnFacetCharacterBuilt");

	Params::OrionTargetingMode_FacetShape_OnFacetCharacterBuilt Parms{};

	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionTargetingMode_FacetShape.OnFacetCylinderBuilt
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HeightMin                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HeightMax                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionTargetingMode_FacetShape::OnFacetCylinderBuilt(float Radius, float HeightMin, float HeightMax)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTargetingMode_FacetShape", "OnFacetCylinderBuilt");

	Params::OrionTargetingMode_FacetShape_OnFacetCylinderBuilt Parms{};

	Parms.Radius = Radius;
	Parms.HeightMin = HeightMin;
	Parms.HeightMax = HeightMax;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionTargetingMode_FacetShape.OnFacetSectorBuilt
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   AngleHorizontal                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RadiusMin                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RadiusMax                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HeightMin                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HeightMax                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionTargetingMode_FacetShape::OnFacetSectorBuilt(float AngleHorizontal, float RadiusMin, float RadiusMax, float HeightMin, float HeightMax)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTargetingMode_FacetShape", "OnFacetSectorBuilt");

	Params::OrionTargetingMode_FacetShape_OnFacetSectorBuilt Parms{};

	Parms.AngleHorizontal = AngleHorizontal;
	Parms.RadiusMin = RadiusMin;
	Parms.RadiusMax = RadiusMax;
	Parms.HeightMin = HeightMin;
	Parms.HeightMax = HeightMax;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionTargetingMode_FacetShape.OnFacetSphereBuilt
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionTargetingMode_FacetShape::OnFacetSphereBuilt(float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTargetingMode_FacetShape", "OnFacetSphereBuilt");

	Params::OrionTargetingMode_FacetShape_OnFacetSphereBuilt Parms{};

	Parms.Radius = Radius;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionTargetingMode_FacetShape.OnStartBuildingFacets
// (Event, Public, BlueprintEvent)

void AOrionTargetingMode_FacetShape::OnStartBuildingFacets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTargetingMode_FacetShape", "OnStartBuildingFacets");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionTargetingMode_FacetShape.OnTargetingModeActivate
// (Event, Public, BlueprintEvent)

void AOrionTargetingMode_FacetShape::OnTargetingModeActivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTargetingMode_FacetShape", "OnTargetingModeActivate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionTargetingMode_FacetShape.OnTargetingModeCancel
// (Event, Public, BlueprintEvent)

void AOrionTargetingMode_FacetShape::OnTargetingModeCancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTargetingMode_FacetShape", "OnTargetingModeCancel");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionTargetingMode_FacetShape.OnTargetingModeConfirm
// (Event, Public, BlueprintEvent)

void AOrionTargetingMode_FacetShape::OnTargetingModeConfirm()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTargetingMode_FacetShape", "OnTargetingModeConfirm");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionTargetingMode_FacetShape.SetPrototypeMeshVisibility
// (Final, Native, Public)
// Parameters:
// bool                                    In_bSetVisible                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionTargetingMode_FacetShape::SetPrototypeMeshVisibility(const bool In_bSetVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTargetingMode_FacetShape", "SetPrototypeMeshVisibility");

	Params::OrionTargetingMode_FacetShape_SetPrototypeMeshVisibility Parms{};

	Parms.In_bSetVisible = In_bSetVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.PlayerControllerCommon.ClientSetInviteFlags
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// struct FJoinabilitySettings             Settings                                               (ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerCommon::ClientSetInviteFlags(const struct FJoinabilitySettings& Settings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerCommon", "ClientSetInviteFlags");

	Params::PlayerControllerCommon_ClientSetInviteFlags Parms{};

	Parms.Settings = std::move(Settings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.PlayerControllerCommon.ClientUpdateRichPresence
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// ERichPresenceStateChange                RichPresenceChange                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bImportant                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerCommon::ClientUpdateRichPresence(ERichPresenceStateChange RichPresenceChange, bool bImportant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerCommon", "ClientUpdateRichPresence");

	Params::PlayerControllerCommon_ClientUpdateRichPresence Parms{};

	Parms.RichPresenceChange = RichPresenceChange;
	Parms.bImportant = bImportant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.PlayerControllerCommon.ServerReturnToMainMenu
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)

void APlayerControllerCommon::ServerReturnToMainMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerCommon", "ServerReturnToMainMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Base.Cheat
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Msg                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Base::Cheat(const class FString& Msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Base", "Cheat");

	Params::OrionPlayerController_Base_Cheat Parms{};

	Parms.Msg = std::move(Msg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Base.CheatAll
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Msg                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Base::CheatAll(const class FString& Msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Base", "CheatAll");

	Params::OrionPlayerController_Base_CheatAll Parms{};

	Parms.Msg = std::move(Msg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Base.ClientDisplayCheatDetectedMessage
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FString                           CheatMessage                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Base::ClientDisplayCheatDetectedMessage(const class FString& CheatMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Base", "ClientDisplayCheatDetectedMessage");

	Params::OrionPlayerController_Base_ClientDisplayCheatDetectedMessage Parms{};

	Parms.CheatMessage = std::move(CheatMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Base.ClientExecCheatAll
// (RequiredAPI, Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FString                           Msg                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Base::ClientExecCheatAll(const class FString& Msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Base", "ClientExecCheatAll");

	Params::OrionPlayerController_Base_ClientExecCheatAll Parms{};

	Parms.Msg = std::move(Msg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Base.ClientFollowTarget
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// class AActor*                           InTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Base::ClientFollowTarget(class AActor* InTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Base", "ClientFollowTarget");

	Params::OrionPlayerController_Base_ClientFollowTarget Parms{};

	Parms.InTarget = InTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Base.ClientReceiveLoot
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// struct FOrionLootNotification           LootNotification                                       (Parm, NativeAccessSpecifierPublic)

void AOrionPlayerController_Base::ClientReceiveLoot(const struct FOrionLootNotification& LootNotification)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Base", "ClientReceiveLoot");

	Params::OrionPlayerController_Base_ClientReceiveLoot Parms{};

	Parms.LootNotification = std::move(LootNotification);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Base.ClientRegisterInitialAnalytics
// (Net, NetReliable, Native, Event, Public, NetClient)

void AOrionPlayerController_Base::ClientRegisterInitialAnalytics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Base", "ClientRegisterInitialAnalytics");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Base.ClientRegisterWithParty
// (Net, NetReliable, Native, Event, Public, NetClient)

void AOrionPlayerController_Base::ClientRegisterWithParty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Base", "ClientRegisterWithParty");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Base.ClientReturnToMainMenuReason
// (RequiredAPI, Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// EReturnToMainMenuReason                 Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Base::ClientReturnToMainMenuReason(EReturnToMainMenuReason Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Base", "ClientReturnToMainMenuReason");

	Params::OrionPlayerController_Base_ClientReturnToMainMenuReason Parms{};

	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Base.ClientSendPartyJoinInfoToPlayer
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// class FString                           JoinInfoStr                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Base::ClientSendPartyJoinInfoToPlayer(const class FString& JoinInfoStr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Base", "ClientSendPartyJoinInfoToPlayer");

	Params::OrionPlayerController_Base_ClientSendPartyJoinInfoToPlayer Parms{};

	Parms.JoinInfoStr = std::move(JoinInfoStr);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Base.ClientStayWithParty
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                                    bStayWithSocialParty                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStayWithTeamParty                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Base::ClientStayWithParty(bool bStayWithSocialParty, bool bStayWithTeamParty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Base", "ClientStayWithParty");

	Params::OrionPlayerController_Base_ClientStayWithParty Parms{};

	Parms.bStayWithSocialParty = bStayWithSocialParty;
	Parms.bStayWithTeamParty = bStayWithTeamParty;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Base.FollowedPlayerDestroyed
// (Final, Native, Private)
// Parameters:
// class AActor*                           DestroyedActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Base::FollowedPlayerDestroyed(class AActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Base", "FollowedPlayerDestroyed");

	Params::OrionPlayerController_Base_FollowedPlayerDestroyed Parms{};

	Parms.DestroyedActor = DestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Base.FollowedPlayerDied
// (Final, Native, Private)
// Parameters:
// class AOrionChar*                       DeadChar                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Base::FollowedPlayerDied(class AOrionChar* DeadChar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Base", "FollowedPlayerDied");

	Params::OrionPlayerController_Base_FollowedPlayerDied Parms{};

	Parms.DeadChar = DeadChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Base.FollowedPlayerKilled
// (Final, Native, Private)
// Parameters:
// class AOrionChar*                       DeadChar                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      Killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Base::FollowedPlayerKilled(class AOrionChar* DeadChar, class AController* Killer, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Base", "FollowedPlayerKilled");

	Params::OrionPlayerController_Base_FollowedPlayerKilled Parms{};

	Parms.DeadChar = DeadChar;
	Parms.Killer = Killer;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Base.LocalUserRequestingReturnToMainMenu
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// EReturnToMainMenuReason                 Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Base::LocalUserRequestingReturnToMainMenu(EReturnToMainMenuReason Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Base", "LocalUserRequestingReturnToMainMenu");

	Params::OrionPlayerController_Base_LocalUserRequestingReturnToMainMenu Parms{};

	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Base.OnMenuEntered
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           MenuName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Base::OnMenuEntered(const class FString& MenuName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Base", "OnMenuEntered");

	Params::OrionPlayerController_Base_OnMenuEntered Parms{};

	Parms.MenuName = std::move(MenuName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Base.OnMenuExited
// (Final, RequiredAPI, Native, Public, BlueprintCallable)

void AOrionPlayerController_Base::OnMenuExited()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Base", "OnMenuExited");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Base.ServerChangeNextViewTarget
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void AOrionPlayerController_Base::ServerChangeNextViewTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Base", "ServerChangeNextViewTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Base.ServerChangePreviousViewTarget
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void AOrionPlayerController_Base::ServerChangePreviousViewTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Base", "ServerChangePreviousViewTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Base.ServerChangeTeam
// (RequiredAPI, Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// EOrionTeam                              TeamIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Base::ServerChangeTeam(EOrionTeam TeamIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Base", "ServerChangeTeam");

	Params::OrionPlayerController_Base_ServerChangeTeam Parms{};

	Parms.TeamIndex = TeamIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Base.ServerChangeViewMode
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void AOrionPlayerController_Base::ServerChangeViewMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Base", "ServerChangeViewMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Base.ServerExecCheat
// (RequiredAPI, Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FString                           Msg                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Base::ServerExecCheat(const class FString& Msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Base", "ServerExecCheat");

	Params::OrionPlayerController_Base_ServerExecCheat Parms{};

	Parms.Msg = std::move(Msg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Base.ServerExecCheatAll
// (RequiredAPI, Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FString                           Msg                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Base::ServerExecCheatAll(const class FString& Msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Base", "ServerExecCheatAll");

	Params::OrionPlayerController_Base_ServerExecCheatAll Parms{};

	Parms.Msg = std::move(Msg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Base.ServerRegisterInitialAnalytics
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FOrionPlayerInitialAnalytics     InInitialAnalytics                                     (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AOrionPlayerController_Base::ServerRegisterInitialAnalytics(const struct FOrionPlayerInitialAnalytics& InInitialAnalytics)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Base", "ServerRegisterInitialAnalytics");

	Params::OrionPlayerController_Base_ServerRegisterInitialAnalytics Parms{};

	Parms.InInitialAnalytics = std::move(InInitialAnalytics);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Base.ServerSendPartyJoinInfoToPlayer
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// struct FUniqueNetIdRepl                 RecipientId                                            (ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           JoinInfoStr                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Base::ServerSendPartyJoinInfoToPlayer(const struct FUniqueNetIdRepl& RecipientId, const class FString& JoinInfoStr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Base", "ServerSendPartyJoinInfoToPlayer");

	Params::OrionPlayerController_Base_ServerSendPartyJoinInfoToPlayer Parms{};

	Parms.RecipientId = std::move(RecipientId);
	Parms.JoinInfoStr = std::move(JoinInfoStr);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Base.ServerSetPartyOwner
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// struct FUniqueNetIdRepl                 PartyOwnerUniqueId                                     (ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Base::ServerSetPartyOwner(const struct FUniqueNetIdRepl& PartyOwnerUniqueId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Base", "ServerSetPartyOwner");

	Params::OrionPlayerController_Base_ServerSetPartyOwner Parms{};

	Parms.PartyOwnerUniqueId = std::move(PartyOwnerUniqueId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Base.ServerSetReadyToStartMatch
// (RequiredAPI, Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    bReady                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Base::ServerSetReadyToStartMatch(bool bReady)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Base", "ServerSetReadyToStartMatch");

	Params::OrionPlayerController_Base_ServerSetReadyToStartMatch Parms{};

	Parms.bReady = bReady;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Base.ServerTeamChatRoomReady
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FString                           ChatRoomId                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Base::ServerTeamChatRoomReady(const class FString& ChatRoomId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Base", "ServerTeamChatRoomReady");

	Params::OrionPlayerController_Base_ServerTeamChatRoomReady Parms{};

	Parms.ChatRoomId = std::move(ChatRoomId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Base.GetOrionClientSettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UOrionClientSettingsRecord*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionClientSettingsRecord* AOrionPlayerController_Base::GetOrionClientSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Base", "GetOrionClientSettings");

	Params::OrionPlayerController_Base_GetOrionClientSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlayerController_Base.GetTeamNum
// (RequiredAPI, Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// EOrionTeam                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOrionTeam AOrionPlayerController_Base::GetTeamNum() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Base", "GetTeamNum");

	Params::OrionPlayerController_Base_GetTeamNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIController.GetAIFormation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UOrionAIFormation*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAIFormation* AOrionAIController::GetAIFormation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAIController", "GetAIFormation");

	Params::OrionAIController_GetAIFormation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIController.GetOrionChar
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AOrionChar*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOrionChar* AOrionAIController::GetOrionChar() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAIController", "GetOrionChar");

	Params::OrionAIController_GetOrionChar Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIController.GetTeamNum
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// EOrionTeam                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOrionTeam AOrionAIController::GetTeamNum() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAIController", "GetTeamNum");

	Params::OrionAIController_GetTeamNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIBot.K2_SetAbilityToUse
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayAbilitySpec             AbilitySpec                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AOrionAIBot::K2_SetAbilityToUse(const struct FGameplayAbilitySpec& AbilitySpec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAIBot", "K2_SetAbilityToUse");

	Params::OrionAIBot_K2_SetAbilityToUse Parms{};

	Parms.AbilitySpec = std::move(AbilitySpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAIBot.K2_SetDifficultySettings
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAIBotDifficultySettings         Settings                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AOrionAIBot::K2_SetDifficultySettings(const struct FAIBotDifficultySettings& Settings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAIBot", "K2_SetDifficultySettings");

	Params::OrionAIBot_K2_SetDifficultySettings Parms{};

	Parms.Settings = std::move(Settings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAIBot.K2_SetEnemy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AOrionChar*                       NewEnemy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionAIBot::K2_SetEnemy(class AOrionChar* NewEnemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAIBot", "K2_SetEnemy");

	Params::OrionAIBot_K2_SetEnemy Parms{};

	Parms.NewEnemy = NewEnemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAIBot.K2_SetIgnoreEnemies
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewIgnoreEnemies                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionAIBot::K2_SetIgnoreEnemies(const bool bNewIgnoreEnemies)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAIBot", "K2_SetIgnoreEnemies");

	Params::OrionAIBot_K2_SetIgnoreEnemies Parms{};

	Parms.bNewIgnoreEnemies = bNewIgnoreEnemies;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAIBot.OnCharacterDied
// (Final, Native, Protected)
// Parameters:
// class AOrionChar*                       DeadChar                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      Killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionAIBot::OnCharacterDied(class AOrionChar* DeadChar, class AController* Killer, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAIBot", "OnCharacterDied");

	Params::OrionAIBot_OnCharacterDied Parms{};

	Parms.DeadChar = DeadChar;
	Parms.Killer = Killer;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAIBot.PlaceWard
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionAIBot::PlaceWard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAIBot", "PlaceWard");

	Params::OrionAIBot_PlaceWard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIBot.Recall
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bFailIfUnsafeToRecall                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionAIBot::Recall(const bool bFailIfUnsafeToRecall)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAIBot", "Recall");

	Params::OrionAIBot_Recall Parms{};

	Parms.bFailIfUnsafeToRecall = bFailIfUnsafeToRecall;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIBot.CanActivateAbility
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTagContainer            AbilityTags                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bRequirePerfectMatch                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionAIBot::CanActivateAbility(const struct FGameplayTagContainer& AbilityTags, bool bRequirePerfectMatch) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAIBot", "CanActivateAbility");

	Params::OrionAIBot_CanActivateAbility Parms{};

	Parms.AbilityTags = std::move(AbilityTags);
	Parms.bRequirePerfectMatch = bRequirePerfectMatch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIBot.GetAvatarLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AOrionAIBot::GetAvatarLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAIBot", "GetAvatarLocation");

	Params::OrionAIBot_GetAvatarLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIBot.GetCurrentLaneFrontWaveTeamProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionAIBot::GetCurrentLaneFrontWaveTeamProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAIBot", "GetCurrentLaneFrontWaveTeamProgress");

	Params::OrionAIBot_GetCurrentLaneFrontWaveTeamProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIBot.GetCurrentObjectiveTeamCommEvent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAITeamCommEvent                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAITeamCommEvent AOrionAIBot::GetCurrentObjectiveTeamCommEvent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAIBot", "GetCurrentObjectiveTeamCommEvent");

	Params::OrionAIBot_GetCurrentObjectiveTeamCommEvent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIBot.GetCurrentScriptedBehavior
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAIScriptedBehavior*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAIScriptedBehavior* AOrionAIBot::GetCurrentScriptedBehavior() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAIBot", "GetCurrentScriptedBehavior");

	Params::OrionAIBot_GetCurrentScriptedBehavior Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIBot.GetLaneProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionAIBot::GetLaneProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAIBot", "GetLaneProgress");

	Params::OrionAIBot_GetLaneProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIBot.GetSpawnLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AOrionAIBot::GetSpawnLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAIBot", "GetSpawnLocation");

	Params::OrionAIBot_GetSpawnLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIBot.HasUsableAbilityAgainstCurrentEnemy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionAIBot::HasUsableAbilityAgainstCurrentEnemy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAIBot", "HasUsableAbilityAgainstCurrentEnemy");

	Params::OrionAIBot_HasUsableAbilityAgainstCurrentEnemy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIBot.IsAbilityInRage
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          WorldLocation                                          (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UOrionAbility>        AbilityClass                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionAIBot::IsAbilityInRage(const struct FVector& WorldLocation, TSubclassOf<class UOrionAbility> AbilityClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAIBot", "IsAbilityInRage");

	Params::OrionAIBot_IsAbilityInRage Parms{};

	Parms.WorldLocation = std::move(WorldLocation);
	Parms.AbilityClass = AbilityClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIBot.IsSafeToRecall
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionAIBot::IsSafeToRecall() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAIBot", "IsSafeToRecall");

	Params::OrionAIBot_IsSafeToRecall Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIBot.K2_GetAssignedRole
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELaneRoleSlot                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELaneRoleSlot AOrionAIBot::K2_GetAssignedRole() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAIBot", "K2_GetAssignedRole");

	Params::OrionAIBot_K2_GetAssignedRole Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIBot.K2_GetDifficultySettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FAIBotDifficultySettings         ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAIBotDifficultySettings AOrionAIBot::K2_GetDifficultySettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAIBot", "K2_GetDifficultySettings");

	Params::OrionAIBot_K2_GetDifficultySettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIBot.K2_GetEnemyCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AOrionAIBot::K2_GetEnemyCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAIBot", "K2_GetEnemyCharacter");

	Params::OrionAIBot_K2_GetEnemyCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIBot.K2_GetEnemySelectionQuery
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEnvQuery*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEnvQuery* AOrionAIBot::K2_GetEnemySelectionQuery() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAIBot", "K2_GetEnemySelectionQuery");

	Params::OrionAIBot_K2_GetEnemySelectionQuery Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIBot.K2_GetLaneID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AOrionAIBot::K2_GetLaneID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAIBot", "K2_GetLaneID");

	Params::OrionAIBot_K2_GetLaneID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIBot.K2_GetObjectiveActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AOrionAIBot::K2_GetObjectiveActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAIBot", "K2_GetObjectiveActor");

	Params::OrionAIBot_K2_GetObjectiveActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIBot.K2_GetPrimaryAttackHandle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayAbilitySpecHandle       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayAbilitySpecHandle AOrionAIBot::K2_GetPrimaryAttackHandle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAIBot", "K2_GetPrimaryAttackHandle");

	Params::OrionAIBot_K2_GetPrimaryAttackHandle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIBot.K2_IsInsideTurret
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionAIBot::K2_IsInsideTurret() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAIBot", "K2_IsInsideTurret");

	Params::OrionAIBot_K2_IsInsideTurret Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIBot.K2_IsSafeToApproachOffensiveLaneGoal
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionAIBot::K2_IsSafeToApproachOffensiveLaneGoal() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAIBot", "K2_IsSafeToApproachOffensiveLaneGoal");

	Params::OrionAIBot_K2_IsSafeToApproachOffensiveLaneGoal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIPerceptionComponent.GetCallForHelpRating
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOrionAIPerceptionComponent::GetCallForHelpRating(class AActor* Actor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAIPerceptionComponent", "GetCallForHelpRating");

	Params::OrionAIPerceptionComponent_GetCallForHelpRating Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIPerceptionComponent.GetRecentDamageTakenFromActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOrionAIPerceptionComponent::GetRecentDamageTakenFromActor(class AActor* Actor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAIPerceptionComponent", "GetRecentDamageTakenFromActor");

	Params::OrionAIPerceptionComponent_GetRecentDamageTakenFromActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAICommander.MinionWaveSpawned
// (Final, Native, Protected)
// Parameters:
// class AOrionCharAISpawner*              Spawner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAICommander::MinionWaveSpawned(class AOrionCharAISpawner* Spawner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAICommander", "MinionWaveSpawned");

	Params::OrionAICommander_MinionWaveSpawned Parms{};

	Parms.Spawner = Spawner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionTerminusAnimInstance.AnimNotify_StartLooping
// (Final, Native, Public)
// Parameters:
// class UAnimNotify*                      Notify                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionTerminusAnimInstance::AnimNotify_StartLooping(const class UAnimNotify* Notify)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTerminusAnimInstance", "AnimNotify_StartLooping");

	Params::OrionTerminusAnimInstance_AnimNotify_StartLooping Parms{};

	Parms.Notify = Notify;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAIController_MinionBaseAdvanced.SetTether
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          TetherLocation                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         TetherRotation                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AOrionAIController_MinionBaseAdvanced::SetTether(const struct FVector& TetherLocation, const struct FRotator& TetherRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAIController_MinionBaseAdvanced", "SetTether");

	Params::OrionAIController_MinionBaseAdvanced_SetTether Parms{};

	Parms.TetherLocation = std::move(TetherLocation);
	Parms.TetherRotation = std::move(TetherRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAIController_MinionBaseAdvanced.GetSpawner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AOrionCharAISpawner*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOrionCharAISpawner* AOrionAIController_MinionBaseAdvanced::GetSpawner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAIController_MinionBaseAdvanced", "GetSpawner");

	Params::OrionAIController_MinionBaseAdvanced_GetSpawner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlacementActor.OnLoadingChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bIsLoading                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlacementActor::OnLoadingChanged(bool bIsLoading)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlacementActor", "OnLoadingChanged");

	Params::OrionPlacementActor_OnLoadingChanged Parms{};

	Parms.bIsLoading = bIsLoading;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionHeroAnimInstance.OnAllMontageInstancesEndedCallback
// (Final, Native, Protected)

void UOrionHeroAnimInstance::OnAllMontageInstancesEndedCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionHeroAnimInstance", "OnAllMontageInstancesEndedCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionHeroAnimInstance.OnMontageBlendingOutDelegate
// (Final, Native, Public)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionHeroAnimInstance::OnMontageBlendingOutDelegate(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionHeroAnimInstance", "OnMontageBlendingOutDelegate");

	Params::OrionHeroAnimInstance_OnMontageBlendingOutDelegate Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionHeroAnimInstance.OnMontageStartedDelegate
// (Native, Protected)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionHeroAnimInstance::OnMontageStartedDelegate(class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionHeroAnimInstance", "OnMontageStartedDelegate");

	Params::OrionHeroAnimInstance_OnMontageStartedDelegate Parms{};

	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionMcpItemDefinition.GetCustomStoreContentWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UOrionCustomStoreContentWidget>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UOrionCustomStoreContentWidget> UOrionMcpItemDefinition::GetCustomStoreContentWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpItemDefinition", "GetCustomStoreContentWidget");

	Params::OrionMcpItemDefinition_GetCustomStoreContentWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionMcpItemDefinition.GetIcon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UOrionMcpItemDefinition::GetIcon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpItemDefinition", "GetIcon");

	Params::OrionMcpItemDefinition_GetIcon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionMcpItemDefinition.GetIconAsset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TSoftObjectPtr<class UObject>     ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const TSoftObjectPtr<class UObject> UOrionMcpItemDefinition::GetIconAsset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpItemDefinition", "GetIconAsset");

	Params::OrionMcpItemDefinition_GetIconAsset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionMcpItemDefinition.GetIconMaterial
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMaterialInterface*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInterface* UOrionMcpItemDefinition::GetIconMaterial() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpItemDefinition", "GetIconMaterial");

	Params::OrionMcpItemDefinition_GetIconMaterial Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionMcpItemDefinition.GetPersistentName
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UOrionMcpItemDefinition::GetPersistentName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpItemDefinition", "GetPersistentName");

	Params::OrionMcpItemDefinition_GetPersistentName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction OrionGame.OrionCharacterData.OnAbilityDataLoaded__DelegateSignature
// (Public, Delegate, HasOutParams)
// Parameters:
// TArray<class UOrionAbilitySet*>         Abilities                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UOrionCharacterData::OnAbilityDataLoaded__DelegateSignature(const TArray<class UOrionAbilitySet*>& Abilities)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharacterData", "OnAbilityDataLoaded__DelegateSignature");

	Params::OrionCharacterData_OnAbilityDataLoaded__DelegateSignature Parms{};

	Parms.Abilities = std::move(Abilities);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionCharacterData.LoadAbilityData
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TDelegate<void(TArray<class UOrionAbilitySet*>& Abilities)>Callback                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionCharacterData::LoadAbilityData(TDelegate<void(TArray<class UOrionAbilitySet*>& Abilities)> Callback) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharacterData", "LoadAbilityData");

	Params::OrionCharacterData_LoadAbilityData Parms{};

	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIFormation.HandleFormationMemberDeath
// (Final, Native, Public)
// Parameters:
// class AOrionChar*                       DeadChar                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      Killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAIFormation::HandleFormationMemberDeath(class AOrionChar* DeadChar, class AController* Killer, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAIFormation", "HandleFormationMemberDeath");

	Params::OrionAIFormation_HandleFormationMemberDeath Parms{};

	Parms.DeadChar = DeadChar;
	Parms.Killer = Killer;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionToggleableNavLinkProxy.ServerSetEnabled
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// bool                                    bNewEnabled                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionToggleableNavLinkProxy::ServerSetEnabled(bool bNewEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionToggleableNavLinkProxy", "ServerSetEnabled");

	Params::OrionToggleableNavLinkProxy_ServerSetEnabled Parms{};

	Parms.bNewEnabled = bNewEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAIGenerigWorldQuerying.CompareToFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EOrionAISymbolicItem                    LHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGenericAICheck                         Op                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FOrionGenericAITest              ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FOrionGenericAITest UOrionAIGenerigWorldQuerying::CompareToFloat(EOrionAISymbolicItem LHS, EGenericAICheck Op, float RHS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAIGenerigWorldQuerying", "CompareToFloat");

	Params::OrionAIGenerigWorldQuerying_CompareToFloat Parms{};

	Parms.LHS = LHS;
	Parms.Op = Op;
	Parms.RHS = RHS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIGenerigWorldQuerying.CompareToNumber
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EOrionAISymbolicItem                    LHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGenericAICheck                         Op                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FOrionGenericAITest              ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FOrionGenericAITest UOrionAIGenerigWorldQuerying::CompareToNumber(EOrionAISymbolicItem LHS, EGenericAICheck Op, int32 RHS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAIGenerigWorldQuerying", "CompareToNumber");

	Params::OrionAIGenerigWorldQuerying_CompareToNumber Parms{};

	Parms.LHS = LHS;
	Parms.Op = Op;
	Parms.RHS = RHS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIGenerigWorldQuerying.CompareToSymbol
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EOrionAISymbolicItem                    LHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGenericAICheck                         Op                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionAISymbolicItem                    RHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FOrionGenericAITest              ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FOrionGenericAITest UOrionAIGenerigWorldQuerying::CompareToSymbol(EOrionAISymbolicItem LHS, EGenericAICheck Op, EOrionAISymbolicItem RHS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAIGenerigWorldQuerying", "CompareToSymbol");

	Params::OrionAIGenerigWorldQuerying_CompareToSymbol Parms{};

	Parms.LHS = LHS;
	Parms.Op = Op;
	Parms.RHS = RHS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIGenerigWorldQuerying.Evaluate
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FOrionGenericAITest              Condition                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionAIGenerigWorldQuerying::Evaluate(class UObject* WorldContextObject, const struct FOrionGenericAITest& Condition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAIGenerigWorldQuerying", "Evaluate");

	Params::OrionAIGenerigWorldQuerying_Evaluate Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Condition = std::move(Condition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIGenerigWorldQuerying.FactCheck
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EOrionAISymbolicItem                    LHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsTrue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FOrionGenericAITest              ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FOrionGenericAITest UOrionAIGenerigWorldQuerying::FactCheck(EOrionAISymbolicItem LHS, bool bIsTrue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAIGenerigWorldQuerying", "FactCheck");

	Params::OrionAIGenerigWorldQuerying_FactCheck Parms{};

	Parms.LHS = LHS;
	Parms.bIsTrue = bIsTrue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIGenerigWorldQuerying.IsDead
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EOrionAISymbolicItem                    LHS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsTrue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FOrionGenericAITest              ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FOrionGenericAITest UOrionAIGenerigWorldQuerying::IsDead(EOrionAISymbolicItem LHS, bool bIsTrue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAIGenerigWorldQuerying", "IsDead");

	Params::OrionAIGenerigWorldQuerying_IsDead Parms{};

	Parms.LHS = LHS;
	Parms.bIsTrue = bIsTrue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIGenerigWorldQuerying.IsTowerDead
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EAITowerClassification                  Tower                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAIOwnership                            Ownership                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAIGenericLocation                      Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsTrue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FOrionGenericAITest              ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FOrionGenericAITest UOrionAIGenerigWorldQuerying::IsTowerDead(EAITowerClassification Tower, EAIOwnership Ownership, EAIGenericLocation Location, bool bIsTrue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAIGenerigWorldQuerying", "IsTowerDead");

	Params::OrionAIGenerigWorldQuerying_IsTowerDead Parms{};

	Parms.Tower = Tower;
	Parms.Ownership = Ownership;
	Parms.Location = Location;
	Parms.bIsTrue = bIsTrue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIGenerigWorldQuerying.LongestDistanceTo
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EOrionAISymbolicItem                    From                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionAISymbolicItem                    To                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGenericAICheck                         Op                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FOrionGenericAITest              ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FOrionGenericAITest UOrionAIGenerigWorldQuerying::LongestDistanceTo(EOrionAISymbolicItem From, EOrionAISymbolicItem To, EGenericAICheck Op, float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAIGenerigWorldQuerying", "LongestDistanceTo");

	Params::OrionAIGenerigWorldQuerying_LongestDistanceTo Parms{};

	Parms.From = From;
	Parms.To = To;
	Parms.Op = Op;
	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIGenerigWorldQuerying.ShortestDistanceTo
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EOrionAISymbolicItem                    From                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionAISymbolicItem                    To                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGenericAICheck                         Op                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FOrionGenericAITest              ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FOrionGenericAITest UOrionAIGenerigWorldQuerying::ShortestDistanceTo(EOrionAISymbolicItem From, EOrionAISymbolicItem To, EGenericAICheck Op, float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAIGenerigWorldQuerying", "ShortestDistanceTo");

	Params::OrionAIGenerigWorldQuerying_ShortestDistanceTo Parms{};

	Parms.From = From;
	Parms.To = To;
	Parms.Op = Op;
	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIInfluenceMapManager.OnNavDataGenerationFinished
// (Final, Native, Protected)
// Parameters:
// class ANavigationData*                  NavData                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionAIInfluenceMapManager::OnNavDataGenerationFinished(class ANavigationData* NavData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAIInfluenceMapManager", "OnNavDataGenerationFinished");

	Params::OrionAIInfluenceMapManager_OnNavDataGenerationFinished Parms{};

	Parms.NavData = NavData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAIKismetLibrary.GetBlackboardValueAsAbilitySpecHandle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UBTNode*                          NodeOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBlackboardKeySelector           Key                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAbilitySpecHandle       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayAbilitySpecHandle UOrionAIKismetLibrary::GetBlackboardValueAsAbilitySpecHandle(class UBTNode* NodeOwner, const struct FBlackboardKeySelector& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAIKismetLibrary", "GetBlackboardValueAsAbilitySpecHandle");

	Params::OrionAIKismetLibrary_GetBlackboardValueAsAbilitySpecHandle Parms{};

	Parms.NodeOwner = NodeOwner;
	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIKismetLibrary.GetClosestJungleCamp
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AOrionAIBot*                      Bot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAICampType                             Camp                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinCreepsAlive                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOrionCharAISpawner_Jungle*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOrionCharAISpawner_Jungle* UOrionAIKismetLibrary::GetClosestJungleCamp(class AOrionAIBot* Bot, EAICampType Camp, int32 MinCreepsAlive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAIKismetLibrary", "GetClosestJungleCamp");

	Params::OrionAIKismetLibrary_GetClosestJungleCamp Parms{};

	Parms.Bot = Bot;
	Parms.Camp = Camp;
	Parms.MinCreepsAlive = MinCreepsAlive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIKismetLibrary.GetInfluenceValueAt
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldLocation                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionTeam                              QuerierTeam                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOrionAIKismetLibrary::GetInfluenceValueAt(class UObject* WorldContextObject, const struct FVector& WorldLocation, EOrionTeam QuerierTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAIKismetLibrary", "GetInfluenceValueAt");

	Params::OrionAIKismetLibrary_GetInfluenceValueAt Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WorldLocation = std::move(WorldLocation);
	Parms.QuerierTeam = QuerierTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIKismetLibrary.GetOwnTower
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LaneID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionTeam                              TeamNum                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TowerIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOrionDamageableObjective_Base*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOrionDamageableObjective_Base* UOrionAIKismetLibrary::GetOwnTower(class UObject* WorldContextObject, int32 LaneID, EOrionTeam TeamNum, int32 TowerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAIKismetLibrary", "GetOwnTower");

	Params::OrionAIKismetLibrary_GetOwnTower Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LaneID = LaneID;
	Parms.TeamNum = TeamNum;
	Parms.TowerIndex = TowerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIKismetLibrary.K2_ClearTimerByHandle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FTimerHandle                     TimerHandle                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAIKismetLibrary::K2_ClearTimerByHandle(const struct FTimerHandle& TimerHandle, class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAIKismetLibrary", "K2_ClearTimerByHandle");

	Params::OrionAIKismetLibrary_K2_ClearTimerByHandle Parms{};

	Parms.TimerHandle = std::move(TimerHandle);
	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAIKismetLibrary.K2_FillWithBots
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   BotsToAddToEachTeam                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           HeroListName                                           (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAIKismetLibrary::K2_FillWithBots(class UObject* WorldContextObject, int32 BotsToAddToEachTeam, const class FString& HeroListName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAIKismetLibrary", "K2_FillWithBots");

	Params::OrionAIKismetLibrary_K2_FillWithBots Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.BotsToAddToEachTeam = BotsToAddToEachTeam;
	Parms.HeroListName = std::move(HeroListName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAIKismetLibrary.K2_GetAIMarkup
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           WorldContext                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOrionAILevelMarkup*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOrionAILevelMarkup* UOrionAIKismetLibrary::K2_GetAIMarkup(class AActor* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAIKismetLibrary", "K2_GetAIMarkup");

	Params::OrionAIKismetLibrary_K2_GetAIMarkup Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIKismetLibrary.K2_GetTeamBots
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionTeam                              TeamNum                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AOrionAIBot*>              OutBots                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UOrionAIKismetLibrary::K2_GetTeamBots(class UObject* WorldContextObject, const EOrionTeam TeamNum, TArray<class AOrionAIBot*>* OutBots)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAIKismetLibrary", "K2_GetTeamBots");

	Params::OrionAIKismetLibrary_K2_GetTeamBots Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TeamNum = TeamNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBots != nullptr)
		*OutBots = std::move(Parms.OutBots);
}


// Function OrionGame.OrionAIKismetLibrary.K2_SetTimerDelegate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TDelegate<void()>                       Delegate                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLooping                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimerHandle                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FTimerHandle UOrionAIKismetLibrary::K2_SetTimerDelegate(TDelegate<void()> Delegate, float Time, bool bLooping, class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAIKismetLibrary", "K2_SetTimerDelegate");

	Params::OrionAIKismetLibrary_K2_SetTimerDelegate Parms{};

	Parms.Delegate = Delegate;
	Parms.Time = Time;
	Parms.bLooping = bLooping;
	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIKismetLibrary.RemoveInfluenceSource
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TScriptInterface<class IOrionTeamActorInterface>InfluenceSource                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// bool                                    bForceUpdate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAIKismetLibrary::RemoveInfluenceSource(class UObject* WorldContextObject, TScriptInterface<class IOrionTeamActorInterface> InfluenceSource, bool bForceUpdate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAIKismetLibrary", "RemoveInfluenceSource");

	Params::OrionAIKismetLibrary_RemoveInfluenceSource Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InfluenceSource = InfluenceSource;
	Parms.bForceUpdate = bForceUpdate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAIKismetLibrary.UpdateInfluenceSurce
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TScriptInterface<class IOrionTeamActorInterface>InfluenceSource                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// EAIActorClassification                  SourceType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceUpdate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAIKismetLibrary::UpdateInfluenceSurce(class UObject* WorldContextObject, TScriptInterface<class IOrionTeamActorInterface> InfluenceSource, EAIActorClassification SourceType, float Radius, float Strength, bool bForceUpdate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAIKismetLibrary", "UpdateInfluenceSurce");

	Params::OrionAIKismetLibrary_UpdateInfluenceSurce Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InfluenceSource = InfluenceSource;
	Parms.SourceType = SourceType;
	Parms.Radius = Radius;
	Parms.Strength = Strength;
	Parms.bForceUpdate = bForceUpdate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionTutorialPath.PlayPoof
// (Native, Event, Protected, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionTutorialPath::PlayPoof(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTutorialPath", "PlayPoof");

	Params::OrionTutorialPath_PlayPoof Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionTutorialPath.UpdateLineDecalComponent
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UDecalComponent*                  Decal                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstanceDynamic*         Mid                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SourceVec                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetVec                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionTutorialPath::UpdateLineDecalComponent(class UDecalComponent* Decal, class UMaterialInstanceDynamic* Mid, const struct FVector& SourceVec, const struct FVector& TargetVec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTutorialPath", "UpdateLineDecalComponent");

	Params::OrionTutorialPath_UpdateLineDecalComponent Parms{};

	Parms.Decal = Decal;
	Parms.Mid = Mid;
	Parms.SourceVec = std::move(SourceVec);
	Parms.TargetVec = std::move(TargetVec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionTutorialPath.UpdateNodeDecalComponent
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UDecalComponent*                  Decal                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstanceDynamic*         Mid                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionTutorialPath::UpdateNodeDecalComponent(class UDecalComponent* Decal, class UMaterialInstanceDynamic* Mid, const struct FVector& Location, const int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTutorialPath", "UpdateNodeDecalComponent");

	Params::OrionTutorialPath_UpdateNodeDecalComponent Parms{};

	Parms.Decal = Decal;
	Parms.Mid = Mid;
	Parms.Location = std::move(Location);
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionTutorialPath.UpdateVisuals
// (Final, Native, Protected, BlueprintCallable)

void AOrionTutorialPath::UpdateVisuals()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTutorialPath", "UpdateVisuals");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionTutorialPath.GetNumOfPoints
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AOrionTutorialPath::GetNumOfPoints() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTutorialPath", "GetNumOfPoints");

	Params::OrionTutorialPath_GetNumOfPoints Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCarriedObjective.DropObjective
// (Final, Native, Public, BlueprintCallable)

void AOrionCarriedObjective::DropObjective()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCarriedObjective", "DropObjective");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCarriedObjective.HandleCurrentHoldersDeath
// (Final, Native, Public)
// Parameters:
// class AOrionChar*                       DeadChar                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCarriedObjective::HandleCurrentHoldersDeath(class AOrionChar* DeadChar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCarriedObjective", "HandleCurrentHoldersDeath");

	Params::OrionCarriedObjective_HandleCurrentHoldersDeath Parms{};

	Parms.DeadChar = DeadChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCarriedObjective.HandleCurrentHoldersDestroyed
// (Final, Native, Public)
// Parameters:
// class AActor*                           DestroyedActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCarriedObjective::HandleCurrentHoldersDestroyed(class AActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCarriedObjective", "HandleCurrentHoldersDestroyed");

	Params::OrionCarriedObjective_HandleCurrentHoldersDestroyed Parms{};

	Parms.DestroyedActor = DestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCarriedObjective.HandleHomingDeath
// (Native, Public)
// Parameters:
// class AOrionChar*                       DeadChar                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCarriedObjective::HandleHomingDeath(class AOrionChar* DeadChar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCarriedObjective", "HandleHomingDeath");

	Params::OrionCarriedObjective_HandleHomingDeath Parms{};

	Parms.DeadChar = DeadChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCarriedObjective.HandleHomingEnterPhaseShift
// (Native, Public)
// Parameters:
// class AOrionChar*                       PhaseShifedChar                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCarriedObjective::HandleHomingEnterPhaseShift(class AOrionChar* PhaseShifedChar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCarriedObjective", "HandleHomingEnterPhaseShift");

	Params::OrionCarriedObjective_HandleHomingEnterPhaseShift Parms{};

	Parms.PhaseShifedChar = PhaseShifedChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCarriedObjective.IsHeld
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionCarriedObjective::IsHeld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCarriedObjective", "IsHeld");

	Params::OrionCarriedObjective_IsHeld Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCarriedObjective.OnObjectiveDropped
// (Event, Protected, BlueprintEvent)

void AOrionCarriedObjective::OnObjectiveDropped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCarriedObjective", "OnObjectiveDropped");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionCarriedObjective.OnScoredObjective
// (Event, Protected, BlueprintEvent)

void AOrionCarriedObjective::OnScoredObjective()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCarriedObjective", "OnScoredObjective");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionCarriedObjective.SetCurrentHolder
// (Final, Native, Protected)
// Parameters:
// class AOrionPlayerState_Game*           InHolder                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCarriedObjective::SetCurrentHolder(class AOrionPlayerState_Game* InHolder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCarriedObjective", "SetCurrentHolder");

	Params::OrionCarriedObjective_SetCurrentHolder Parms{};

	Parms.InHolder = InHolder;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCarriedObjective.TryToReturnToBase
// (Final, Native, Protected)

void AOrionCarriedObjective::TryToReturnToBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCarriedObjective", "TryToReturnToBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAimTargetInterface.AddedToHiddennActorArray
// (Event, Public, BlueprintEvent)

void IOrionAimTargetInterface::AddedToHiddennActorArray()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAimTargetInterface", "AddedToHiddennActorArray");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionAimTargetInterface.ApplyShadowPlaneMaterials
// (Event, Public, BlueprintEvent)

void IOrionAimTargetInterface::ApplyShadowPlaneMaterials()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAimTargetInterface", "ApplyShadowPlaneMaterials");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionAimTargetInterface.GetAimTargetExtent
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Center                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Width                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Height                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IOrionAimTargetInterface::GetAimTargetExtent(struct FVector* Center, float* Width, float* Height)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAimTargetInterface", "GetAimTargetExtent");

	Params::OrionAimTargetInterface_GetAimTargetExtent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Center != nullptr)
		*Center = std::move(Parms.Center);

	if (Width != nullptr)
		*Width = Parms.Width;

	if (Height != nullptr)
		*Height = Parms.Height;
}


// Function OrionGame.OrionAimTargetInterface.GetAimTargetSensingLocation
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          AimPosition                                            (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IOrionAimTargetInterface::GetAimTargetSensingLocation(struct FVector* AimPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAimTargetInterface", "GetAimTargetSensingLocation");

	Params::OrionAimTargetInterface_GetAimTargetSensingLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AimPosition != nullptr)
		*AimPosition = std::move(Parms.AimPosition);
}


// Function OrionGame.OrionAimTargetInterface.GetMyTargetType
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EOrionTargetType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOrionTargetType IOrionAimTargetInterface::GetMyTargetType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAimTargetInterface", "GetMyTargetType");

	Params::OrionAimTargetInterface_GetMyTargetType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAimTargetInterface.GetNumberPopLocation
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          HitLocation                                            (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector IOrionAimTargetInterface::GetNumberPopLocation(const struct FVector& HitLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAimTargetInterface", "GetNumberPopLocation");

	Params::OrionAimTargetInterface_GetNumberPopLocation Parms{};

	Parms.HitLocation = std::move(HitLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAimTargetInterface.GetTargetingLocation
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          OutPosition                                            (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IOrionAimTargetInterface::GetTargetingLocation(struct FVector* OutPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAimTargetInterface", "GetTargetingLocation");

	Params::OrionAimTargetInterface_GetTargetingLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPosition != nullptr)
		*OutPosition = std::move(Parms.OutPosition);
}


// Function OrionGame.OrionAimTargetInterface.IsValidDirectHit
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IOrionAimTargetInterface::IsValidDirectHit(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAimTargetInterface", "IsValidDirectHit");

	Params::OrionAimTargetInterface_IsValidDirectHit Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAimTargetInterface.RemovedFromHiddenActorArray
// (Event, Public, BlueprintEvent)

void IOrionAimTargetInterface::RemovedFromHiddenActorArray()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAimTargetInterface", "RemovedFromHiddenActorArray");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionAimTargetInterface.RemoveShadowPlaneMaterials
// (Event, Public, BlueprintEvent)

void IOrionAimTargetInterface::RemoveShadowPlaneMaterials()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAimTargetInterface", "RemoveShadowPlaneMaterials");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionAimTargetInterface.ShouldIgnoreCollisionWithTeam
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EOrionTeam                              Team                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPassedFilter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IOrionAimTargetInterface::ShouldIgnoreCollisionWithTeam(EOrionTeam Team, bool bPassedFilter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAimTargetInterface", "ShouldIgnoreCollisionWithTeam");

	Params::OrionAimTargetInterface_ShouldIgnoreCollisionWithTeam Parms{};

	Parms.Team = Team;
	Parms.bPassedFilter = bPassedFilter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAimTargetInterface.UpdateOccludedVision
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bShouldShowWhenOccluded                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IOrionAimTargetInterface::UpdateOccludedVision(bool bShouldShowWhenOccluded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAimTargetInterface", "UpdateOccludedVision");

	Params::OrionAimTargetInterface_UpdateOccludedVision Parms{};

	Parms.bShouldShowWhenOccluded = bShouldShowWhenOccluded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAimTargetInterface.CanBeHitWhileInShadowPlane
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IOrionAimTargetInterface::CanBeHitWhileInShadowPlane() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAimTargetInterface", "CanBeHitWhileInShadowPlane");

	Params::OrionAimTargetInterface_CanBeHitWhileInShadowPlane Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAimTargetInterface.CanSee
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class AActor*                           TargetActor                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionVisionType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOrionVisionType IOrionAimTargetInterface::CanSee(const class AActor* TargetActor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAimTargetInterface", "CanSee");

	Params::OrionAimTargetInterface_CanSee Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAimTargetInterface.IsTargetable
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IOrionAimTargetInterface::IsTargetable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAimTargetInterface", "IsTargetable");

	Params::OrionAimTargetInterface_IsTargetable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharAISpawner.AddAIToNextWave
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UOrionAIData*                     InAIData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharAISpawner::AddAIToNextWave(class UOrionAIData* InAIData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "AddAIToNextWave");

	Params::OrionCharAISpawner_AddAIToNextWave Parms{};

	Parms.InAIData = InAIData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAISpawner.ApplyAggroEffectForHero
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Hero                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      AggroEffect                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharAISpawner::ApplyAggroEffectForHero(class AActor* Hero, TSubclassOf<class UGameplayEffect> AggroEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "ApplyAggroEffectForHero");

	Params::OrionCharAISpawner_ApplyAggroEffectForHero Parms{};

	Parms.Hero = Hero;
	Parms.AggroEffect = AggroEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAISpawner.ChangeTeamOldVisionManagerOnly
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EOrionTeam                              NewTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharAISpawner::ChangeTeamOldVisionManagerOnly(EOrionTeam NewTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "ChangeTeamOldVisionManagerOnly");

	Params::OrionCharAISpawner_ChangeTeamOldVisionManagerOnly Parms{};

	Parms.NewTeam = NewTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAISpawner.DisableSpawner
// (Final, Native, Public, BlueprintCallable)

void AOrionCharAISpawner::DisableSpawner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "DisableSpawner");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAISpawner.EnableSpawner
// (Final, Native, Public, BlueprintCallable)

void AOrionCharAISpawner::EnableSpawner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "EnableSpawner");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAISpawner.FinishSpawningNextAIFormation
// (Final, Native, Public)

void AOrionCharAISpawner::FinishSpawningNextAIFormation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "FinishSpawningNextAIFormation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAISpawner.ForceRestartSpawner
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionCharAISpawnerType                 InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharAISpawner::ForceRestartSpawner(EOrionCharAISpawnerType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "ForceRestartSpawner");

	Params::OrionCharAISpawner_ForceRestartSpawner Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAISpawner.GetSpawnerAICount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AOrionCharAISpawner::GetSpawnerAICount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "GetSpawnerAICount");

	Params::OrionCharAISpawner_GetSpawnerAICount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharAISpawner.HandleMatchEnded
// (Final, Native, Protected)

void AOrionCharAISpawner::HandleMatchEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "HandleMatchEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAISpawner.HandleMatchStarted
// (Final, Native, Protected)

void AOrionCharAISpawner::HandleMatchStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "HandleMatchStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAISpawner.HandleSpawnedAIDeath
// (Final, Native, Public)
// Parameters:
// class AOrionChar*                       DeadChar                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      Killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharAISpawner::HandleSpawnedAIDeath(class AOrionChar* DeadChar, class AController* Killer, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "HandleSpawnedAIDeath");

	Params::OrionCharAISpawner_HandleSpawnedAIDeath Parms{};

	Parms.DeadChar = DeadChar;
	Parms.Killer = Killer;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAISpawner.HandleSpawnedAIDestroyed
// (Final, Native, Public)
// Parameters:
// class AActor*                           DestroyedActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharAISpawner::HandleSpawnedAIDestroyed(class AActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "HandleSpawnedAIDestroyed");

	Params::OrionCharAISpawner_HandleSpawnedAIDestroyed Parms{};

	Parms.DestroyedActor = DestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAISpawner.IsSpawningAnAIFormation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionCharAISpawner::IsSpawningAnAIFormation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "IsSpawningAnAIFormation");

	Params::OrionCharAISpawner_IsSpawningAnAIFormation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharAISpawner.NotifyPendingAIFormation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UOrionAIFormationData*            InFormationData                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharAISpawner::NotifyPendingAIFormation(const class UOrionAIFormationData* InFormationData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "NotifyPendingAIFormation");

	Params::OrionCharAISpawner_NotifyPendingAIFormation Parms{};

	Parms.InFormationData = InFormationData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAISpawner.OnAggroResetFinished
// (Event, Public, BlueprintEvent)

void AOrionCharAISpawner::OnAggroResetFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "OnAggroResetFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionCharAISpawner.OnAggroResetStarted
// (Event, Public, BlueprintEvent)

void AOrionCharAISpawner::OnAggroResetStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "OnAggroResetStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionCharAISpawner.OnAIFormationPending
// (Event, Public, BlueprintEvent)

void AOrionCharAISpawner::OnAIFormationPending()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "OnAIFormationPending");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionCharAISpawner.OnAIFormationSpawned
// (Event, Public, BlueprintEvent)
// Parameters:
// class UOrionAIFormation*                NewFormation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharAISpawner::OnAIFormationSpawned(class UOrionAIFormation* NewFormation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "OnAIFormationSpawned");

	Params::OrionCharAISpawner_OnAIFormationSpawned Parms{};

	Parms.NewFormation = NewFormation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionCharAISpawner.OnHandleMatchStart
// (Event, Protected, BlueprintEvent)

void AOrionCharAISpawner::OnHandleMatchStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "OnHandleMatchStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionCharAISpawner.OnIntroSpawnForAI
// (Event, Public, BlueprintEvent)
// Parameters:
// class AOrionCharAI*                     SpawnedAI                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharAISpawner::OnIntroSpawnForAI(class AOrionCharAI* SpawnedAI)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "OnIntroSpawnForAI");

	Params::OrionCharAISpawner_OnIntroSpawnForAI Parms{};

	Parms.SpawnedAI = SpawnedAI;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionCharAISpawner.OnPostRemovedAI
// (Event, Public, BlueprintEvent)
// Parameters:
// class AOrionCharAI*                     RemovedAI                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharAISpawner::OnPostRemovedAI(class AOrionCharAI* RemovedAI)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "OnPostRemovedAI");

	Params::OrionCharAISpawner_OnPostRemovedAI Parms{};

	Parms.RemovedAI = RemovedAI;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionCharAISpawner.OnPostSpawnedAI
// (Event, Public, BlueprintEvent)
// Parameters:
// class AOrionCharAI*                     SpawnedAI                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharAISpawner::OnPostSpawnedAI(class AOrionCharAI* SpawnedAI)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "OnPostSpawnedAI");

	Params::OrionCharAISpawner_OnPostSpawnedAI Parms{};

	Parms.SpawnedAI = SpawnedAI;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionCharAISpawner.OnPreSpawnAI
// (Event, Public, BlueprintEvent)
// Parameters:
// class UOrionAIData*                     InAIData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharAISpawner::OnPreSpawnAI(class UOrionAIData* InAIData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "OnPreSpawnAI");

	Params::OrionCharAISpawner_OnPreSpawnAI Parms{};

	Parms.InAIData = InAIData;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionCharAISpawner.OnRep_CurrentBuffTypeTag
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     OldColor                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharAISpawner::OnRep_CurrentBuffTypeTag(const struct FGameplayTag& OldColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "OnRep_CurrentBuffTypeTag");

	Params::OrionCharAISpawner_OnRep_CurrentBuffTypeTag Parms{};

	Parms.OldColor = std::move(OldColor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAISpawner.OnRep_ReplicatedSpawnTime
// (Final, Native, Protected)

void AOrionCharAISpawner::OnRep_ReplicatedSpawnTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "OnRep_ReplicatedSpawnTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAISpawner.OnRep_SpawnedAICount
// (Final, Native, Protected)

void AOrionCharAISpawner::OnRep_SpawnedAICount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "OnRep_SpawnedAICount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAISpawner.OnReplenishWaveTimerStart
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   InReplenishDelayTimer                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      Killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharAISpawner::OnReplenishWaveTimerStart(float InReplenishDelayTimer, class AController* Killer, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "OnReplenishWaveTimerStart");

	Params::OrionCharAISpawner_OnReplenishWaveTimerStart Parms{};

	Parms.InReplenishDelayTimer = InReplenishDelayTimer;
	Parms.Killer = Killer;
	Parms.DamageCauser = DamageCauser;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionCharAISpawner.OnSpawnerBuffTypeChanged
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// struct FGameplayTag                     NewColorTag                                            (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionTeam                              TeamChanged                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharAISpawner::OnSpawnerBuffTypeChanged(const struct FGameplayTag& NewColorTag, const EOrionTeam TeamChanged)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "OnSpawnerBuffTypeChanged");

	Params::OrionCharAISpawner_OnSpawnerBuffTypeChanged Parms{};

	Parms.NewColorTag = std::move(NewColorTag);
	Parms.TeamChanged = TeamChanged;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAISpawner.OnStartSpawningAIFormation
// (Event, Public, BlueprintEvent)

void AOrionCharAISpawner::OnStartSpawningAIFormation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "OnStartSpawningAIFormation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionCharAISpawner.OnWishesToStartSpawningAIFormation
// (Event, Public, BlueprintEvent)

void AOrionCharAISpawner::OnWishesToStartSpawningAIFormation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "OnWishesToStartSpawningAIFormation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionCharAISpawner.RemoveAggroEffectForHero
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Hero                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharAISpawner::RemoveAggroEffectForHero(class AActor* Hero)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "RemoveAggroEffectForHero");

	Params::OrionCharAISpawner_RemoveAggroEffectForHero Parms{};

	Parms.Hero = Hero;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAISpawner.SelectSpawnLocation
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          OutLocation                                            (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         OutRotation                                            (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AOrionCharAISpawner::SelectSpawnLocation(struct FVector* OutLocation, struct FRotator* OutRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "SelectSpawnLocation");

	Params::OrionCharAISpawner_SelectSpawnLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocation != nullptr)
		*OutLocation = std::move(Parms.OutLocation);

	if (OutRotation != nullptr)
		*OutRotation = std::move(Parms.OutRotation);
}


// Function OrionGame.OrionCharAISpawner.SendAggroManagerMessage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAIMessageFromSpawner                   MESSAGE                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           MessageInstigator                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharAISpawner::SendAggroManagerMessage(EAIMessageFromSpawner MESSAGE, class AActor* MessageInstigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "SendAggroManagerMessage");

	Params::OrionCharAISpawner_SendAggroManagerMessage Parms{};

	Parms.MESSAGE = MESSAGE;
	Parms.MessageInstigator = MessageInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAISpawner.SetSpawnerType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionCharAISpawnerType                 InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharAISpawner::SetSpawnerType(EOrionCharAISpawnerType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "SetSpawnerType");

	Params::OrionCharAISpawner_SetSpawnerType Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAISpawner.SpawnAI
// (Final, Native, Public)
// Parameters:
// class UOrionAIData*                     InAIData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOrionCharAI*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOrionCharAI* AOrionCharAISpawner::SpawnAI(class UOrionAIData* InAIData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "SpawnAI");

	Params::OrionCharAISpawner_SpawnAI Parms{};

	Parms.InAIData = InAIData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharAISpawner.SpawnNextAIFromPool
// (Final, Native, Public)

void AOrionCharAISpawner::SpawnNextAIFromPool()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "SpawnNextAIFromPool");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAISpawner.StartSpawningNextAIFormation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UOrionAIFormationData*            InFormationData                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharAISpawner::StartSpawningNextAIFormation(const class UOrionAIFormationData* InFormationData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "StartSpawningNextAIFormation");

	Params::OrionCharAISpawner_StartSpawningNextAIFormation Parms{};

	Parms.InFormationData = InFormationData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAISpawner.WaveSpawnManager
// (Final, Native, Public)

void AOrionCharAISpawner::WaveSpawnManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "WaveSpawnManager");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAISpawner.WaveSpawnPending
// (Final, Native, Public)

void AOrionCharAISpawner::WaveSpawnPending()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "WaveSpawnPending");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAISpawner.GetAggroManagerHeroesInRange
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AOrionChar*>               HeroesInRange                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void AOrionCharAISpawner::GetAggroManagerHeroesInRange(TArray<class AOrionChar*>* HeroesInRange) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "GetAggroManagerHeroesInRange");

	Params::OrionCharAISpawner_GetAggroManagerHeroesInRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (HeroesInRange != nullptr)
		*HeroesInRange = std::move(Parms.HeroesInRange);
}


// Function OrionGame.OrionCharAISpawner.GetAggroManagerHeroesWithAggro
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AOrionChar*>               HeroesWithAggro                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void AOrionCharAISpawner::GetAggroManagerHeroesWithAggro(TArray<class AOrionChar*>* HeroesWithAggro) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "GetAggroManagerHeroesWithAggro");

	Params::OrionCharAISpawner_GetAggroManagerHeroesWithAggro Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (HeroesWithAggro != nullptr)
		*HeroesWithAggro = std::move(Parms.HeroesWithAggro);
}


// Function OrionGame.OrionCharAISpawner.GetAggroManagerSpawnedList
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AOrionCharAI*>             SpawnedPawns                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void AOrionCharAISpawner::GetAggroManagerSpawnedList(TArray<class AOrionCharAI*>* SpawnedPawns) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "GetAggroManagerSpawnedList");

	Params::OrionCharAISpawner_GetAggroManagerSpawnedList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SpawnedPawns != nullptr)
		*SpawnedPawns = std::move(Parms.SpawnedPawns);
}


// Function OrionGame.OrionCharAISpawner.IsAggroManagerStateInCombat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionCharAISpawner::IsAggroManagerStateInCombat() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "IsAggroManagerStateInCombat");

	Params::OrionCharAISpawner_IsAggroManagerStateInCombat Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharAISpawner.IsAggroManagerStateResetting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionCharAISpawner::IsAggroManagerStateResetting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "IsAggroManagerStateResetting");

	Params::OrionCharAISpawner_IsAggroManagerStateResetting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharAISpawner.IsAggroManagerStateRespawning
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionCharAISpawner::IsAggroManagerStateRespawning() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAISpawner", "IsAggroManagerStateRespawning");

	Params::OrionCharAISpawner_IsAggroManagerStateRespawning Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionAIPerceptionSystem.HandleCallForHelp
// (Final, Native, Public, HasOutParams)
// Parameters:
// class AActor*                           DamagedActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AttackingActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectSpec              EffectSpec                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOrionAIPerceptionSystem::HandleCallForHelp(class AActor* DamagedActor, class AActor* AttackingActor, const struct FGameplayEffectSpec& EffectSpec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAIPerceptionSystem", "HandleCallForHelp");

	Params::OrionAIPerceptionSystem_HandleCallForHelp Parms{};

	Parms.DamagedActor = DamagedActor;
	Parms.AttackingActor = AttackingActor;
	Parms.EffectSpec = std::move(EffectSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionChar.ApplyAlternateAppearance
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               Material                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDisableShadowCasting                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionChar::ApplyAlternateAppearance(class UMaterialInterface* Material, bool bDisableShadowCasting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "ApplyAlternateAppearance");

	Params::OrionChar_ApplyAlternateAppearance Parms{};

	Parms.Material = Material;
	Parms.bDisableShadowCasting = bDisableShadowCasting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionChar.ChangeLocalStatus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionCharLocalStatusTypes              OrionCharLocalStatusType                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSetTo                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionChar::ChangeLocalStatus(EOrionCharLocalStatusTypes OrionCharLocalStatusType, bool bSetTo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "ChangeLocalStatus");

	Params::OrionChar_ChangeLocalStatus Parms{};

	Parms.OrionCharLocalStatusType = OrionCharLocalStatusType;
	Parms.bSetTo = bSetTo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionChar.CustomMatch_RemoveOnDeath
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FActiveGameplayEffect            Effect                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionChar::CustomMatch_RemoveOnDeath(const struct FActiveGameplayEffect& Effect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "CustomMatch_RemoveOnDeath");

	Params::OrionChar_CustomMatch_RemoveOnDeath Parms{};

	Parms.Effect = std::move(Effect);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionChar.DimensionChangeTimeOut
// (Final, Native, Public)

void AOrionChar::DimensionChangeTimeOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "DimensionChangeTimeOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionChar.ForceNextZoneChangeImmediate
// (Final, Native, Public, BlueprintCallable)

void AOrionChar::ForceNextZoneChangeImmediate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "ForceNextZoneChangeImmediate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionChar.GetCurrentTargetIsLocalHero
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionChar::GetCurrentTargetIsLocalHero()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "GetCurrentTargetIsLocalHero");

	Params::OrionChar_GetCurrentTargetIsLocalHero Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionChar.GetEstimatedCXPBounty
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const float AOrionChar::GetEstimatedCXPBounty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "GetEstimatedCXPBounty");

	Params::OrionChar_GetEstimatedCXPBounty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionChar.GetLocalStatus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionCharLocalStatusTypes              OrionCharLocalStatusType                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionChar::GetLocalStatus(EOrionCharLocalStatusTypes OrionCharLocalStatusType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "GetLocalStatus");

	Params::OrionChar_GetLocalStatus Parms{};

	Parms.OrionCharLocalStatusType = OrionCharLocalStatusType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionChar.ImmediateZoneChangeTimeOut
// (Final, Native, Public)

void AOrionChar::ImmediateZoneChangeTimeOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "ImmediateZoneChangeTimeOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionChar.IsInShadowPlane
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionChar::IsInShadowPlane()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "IsInShadowPlane");

	Params::OrionChar_IsInShadowPlane Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionChar.IsSuspended
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionChar::IsSuspended()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "IsSuspended");

	Params::OrionChar_IsSuspended Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionChar.IsWorldDirectionABackPedalAnimation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          InWorldDirectionVector                                 (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionChar::IsWorldDirectionABackPedalAnimation(const struct FVector& InWorldDirectionVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "IsWorldDirectionABackPedalAnimation");

	Params::OrionChar_IsWorldDirectionABackPedalAnimation Parms{};

	Parms.InWorldDirectionVector = std::move(InWorldDirectionVector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionChar.OnAllMontageInstancesEnded
// (Final, Native, Protected)

void AOrionChar::OnAllMontageInstancesEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "OnAllMontageInstancesEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionChar.OnCustomHit
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FHitResult                       Hit                                                    (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// EProjectileCustomHitResponseType        ProjectileCustomHitResponseType_0                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Magnitude                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionChar::OnCustomHit(const struct FHitResult& Hit, EProjectileCustomHitResponseType ProjectileCustomHitResponseType_0, float Magnitude)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "OnCustomHit");

	Params::OrionChar_OnCustomHit Parms{};

	Parms.Hit = std::move(Hit);
	Parms.ProjectileCustomHitResponseType_0 = ProjectileCustomHitResponseType_0;
	Parms.Magnitude = Magnitude;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionChar.OnFinishedDying
// (Event, Public, BlueprintEvent)

void AOrionChar::OnFinishedDying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "OnFinishedDying");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionChar.OnMontageStarted
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionChar::OnMontageStarted(class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "OnMontageStarted");

	Params::OrionChar_OnMontageStarted Parms{};

	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionChar.OnRep_DisabledMovementCollisionPawns
// (Final, Native, Protected)

void AOrionChar::OnRep_DisabledMovementCollisionPawns()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "OnRep_DisabledMovementCollisionPawns");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionChar.OnRep_ReplicatedVisionData
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FOrionReplicatedVisionData       OldData                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AOrionChar::OnRep_ReplicatedVisionData(const struct FOrionReplicatedVisionData& OldData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "OnRep_ReplicatedVisionData");

	Params::OrionChar_OnRep_ReplicatedVisionData Parms{};

	Parms.OldData = std::move(OldData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionChar.OnRep_TeamNum
// (Native, Protected)

void AOrionChar::OnRep_TeamNum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "OnRep_TeamNum");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionChar.OnRep_VisibleToEnemy
// (Final, Native, Public)
// Parameters:
// struct FOrionReplicatedVisibleToEnemy   OldValue                                               (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AOrionChar::OnRep_VisibleToEnemy(const struct FOrionReplicatedVisibleToEnemy& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "OnRep_VisibleToEnemy");

	Params::OrionChar_OnRep_VisibleToEnemy Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionChar.PlayDying
// (Native, Public)

void AOrionChar::PlayDying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "PlayDying");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionChar.PlaySoundOnActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USoundBase*                       SoundToPlay                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAttached                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopWhenAttachedToDestroyed                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* AOrionChar::PlaySoundOnActor(class USoundBase* SoundToPlay, bool bAttached, bool bStopWhenAttachedToDestroyed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "PlaySoundOnActor");

	Params::OrionChar_PlaySoundOnActor Parms{};

	Parms.SoundToPlay = SoundToPlay;
	Parms.bAttached = bAttached;
	Parms.bStopWhenAttachedToDestroyed = bStopWhenAttachedToDestroyed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionChar.PlaySoundTeamAdjustedForSelf
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USoundBase*                       SoundToPlay                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Attached                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopWhenAttachedToDestroyed                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* AOrionChar::PlaySoundTeamAdjustedForSelf(class USoundBase* SoundToPlay, bool Attached, bool bStopWhenAttachedToDestroyed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "PlaySoundTeamAdjustedForSelf");

	Params::OrionChar_PlaySoundTeamAdjustedForSelf Parms{};

	Parms.SoundToPlay = SoundToPlay;
	Parms.Attached = Attached;
	Parms.bStopWhenAttachedToDestroyed = bStopWhenAttachedToDestroyed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionChar.RemoveAlternateAppearance
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)

void AOrionChar::RemoveAlternateAppearance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "RemoveAlternateAppearance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionChar.SetTargetingTagRequirements
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTagRequirements         InTargetingTagRequirements                             (Parm, NativeAccessSpecifierPublic)

void AOrionChar::SetTargetingTagRequirements(const struct FGameplayTagRequirements& InTargetingTagRequirements)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "SetTargetingTagRequirements");

	Params::OrionChar_SetTargetingTagRequirements Parms{};

	Parms.InTargetingTagRequirements = std::move(InTargetingTagRequirements);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionChar.UpdateMultipleScalarParametersOnMaterials
// (Final, BlueprintCosmetic, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ParameterValue                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ParameterNames                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AOrionChar::UpdateMultipleScalarParametersOnMaterials(class USkeletalMeshComponent* Component, float ParameterValue, const TArray<class FName>& ParameterNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "UpdateMultipleScalarParametersOnMaterials");

	Params::OrionChar_UpdateMultipleScalarParametersOnMaterials Parms{};

	Parms.Component = Component;
	Parms.ParameterValue = ParameterValue;
	Parms.ParameterNames = std::move(ParameterNames);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionChar.UpdateMultipleVectorParametersOnMaterials
// (Final, BlueprintCosmetic, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ParameterValue                                         (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ParameterNames                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AOrionChar::UpdateMultipleVectorParametersOnMaterials(class USkeletalMeshComponent* Component, const struct FLinearColor& ParameterValue, const TArray<class FName>& ParameterNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "UpdateMultipleVectorParametersOnMaterials");

	Params::OrionChar_UpdateMultipleVectorParametersOnMaterials Parms{};

	Parms.Component = Component;
	Parms.ParameterValue = std::move(ParameterValue);
	Parms.ParameterNames = std::move(ParameterNames);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionChar.UpdateScalarParameterValueOnMaterials
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ParameterValue                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionChar::UpdateScalarParameterValueOnMaterials(class USkeletalMeshComponent* Component, class FName ParameterName, float ParameterValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "UpdateScalarParameterValueOnMaterials");

	Params::OrionChar_UpdateScalarParameterValueOnMaterials Parms{};

	Parms.Component = Component;
	Parms.ParameterName = ParameterName;
	Parms.ParameterValue = ParameterValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionChar.UpdateVectorParameterValueOnMaterials
// (Final, BlueprintCosmetic, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ParameterValue                                         (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionChar::UpdateVectorParameterValueOnMaterials(class USkeletalMeshComponent* Component, class FName ParameterName, const struct FLinearColor& ParameterValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "UpdateVectorParameterValueOnMaterials");

	Params::OrionChar_UpdateVectorParameterValueOnMaterials Parms{};

	Parms.Component = Component;
	Parms.ParameterName = ParameterName;
	Parms.ParameterValue = std::move(ParameterValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionChar.GetHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionChar::GetHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "GetHealth");

	Params::OrionChar_GetHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionChar.GetHealthPercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionChar::GetHealthPercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "GetHealthPercent");

	Params::OrionChar_GetHealthPercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionChar.GetHealthRegen
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionChar::GetHealthRegen() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "GetHealthRegen");

	Params::OrionChar_GetHealthRegen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionChar.GetMaxHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionChar::GetMaxHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "GetMaxHealth");

	Params::OrionChar_GetMaxHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionChar.GetTeamNum
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// EOrionTeam                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOrionTeam AOrionChar::GetTeamNum() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "GetTeamNum");

	Params::OrionChar_GetTeamNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionChar.GetTotalTimeToAttack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionChar::GetTotalTimeToAttack() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "GetTotalTimeToAttack");

	Params::OrionChar_GetTotalTimeToAttack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionChar.IsAbilityUseDisabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionChar::IsAbilityUseDisabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "IsAbilityUseDisabled");

	Params::OrionChar_IsAbilityUseDisabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionChar.IsBasicAttackDisabled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionChar::IsBasicAttackDisabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "IsBasicAttackDisabled");

	Params::OrionChar_IsBasicAttackDisabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionChar.IsJumpProvidingForce
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionChar::IsJumpProvidingForce() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "IsJumpProvidingForce");

	Params::OrionChar_IsJumpProvidingForce Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionChar.IsMovementDisabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionChar::IsMovementDisabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "IsMovementDisabled");

	Params::OrionChar_IsMovementDisabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionChar.IsSilenced
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionChar::IsSilenced() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionChar", "IsSilenced");

	Params::OrionChar_IsSilenced Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharAI.ApplyGameplayEffectToSelf
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameplayEffect*                  GameplayEffect                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   GameplayEffectLevel                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActiveGameplayEffectHandle      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FActiveGameplayEffectHandle AOrionCharAI::ApplyGameplayEffectToSelf(class UGameplayEffect* GameplayEffect, float GameplayEffectLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAI", "ApplyGameplayEffectToSelf");

	Params::OrionCharAI_ApplyGameplayEffectToSelf Parms{};

	Parms.GameplayEffect = GameplayEffect;
	Parms.GameplayEffectLevel = GameplayEffectLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharAI.CancelAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionMinionPrioritizedBehavior         Behavior                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharAI::CancelAnimation(EOrionMinionPrioritizedBehavior Behavior)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAI", "CancelAnimation");

	Params::OrionCharAI_CancelAnimation Parms{};

	Parms.Behavior = Behavior;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAI.GameplayCue_Damage
// (Final, Native, Public)
// Parameters:
// EGameplayCueEvent                       EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Parameters                                             (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AOrionCharAI::GameplayCue_Damage(EGameplayCueEvent EventType, const struct FGameplayCueParameters& Parameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAI", "GameplayCue_Damage");

	Params::OrionCharAI_GameplayCue_Damage Parms{};

	Parms.EventType = EventType;
	Parms.Parameters = std::move(Parameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAI.GetCurrentTargetIsLocalHero
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionCharAI::GetCurrentTargetIsLocalHero()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAI", "GetCurrentTargetIsLocalHero");

	Params::OrionCharAI_GetCurrentTargetIsLocalHero Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharAI.OnNewTargetAcquired
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           NewTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharAI::OnNewTargetAcquired(class AActor* NewTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAI", "OnNewTargetAcquired");

	Params::OrionCharAI_OnNewTargetAcquired Parms{};

	Parms.NewTarget = NewTarget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionCharAI.OnRep_AIData
// (Final, Native, Private)
// Parameters:
// class UOrionAIData*                     OldAIData                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharAI::OnRep_AIData(const class UOrionAIData* OldAIData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAI", "OnRep_AIData");

	Params::OrionCharAI_OnRep_AIData Parms{};

	Parms.OldAIData = OldAIData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAI.OnRep_DeathData
// (Final, Native, Private)

void AOrionCharAI::OnRep_DeathData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAI", "OnRep_DeathData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAI.PlayHeroAggroAlert
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// class AOrionCharHero*                   HeroTarget                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharAI::PlayHeroAggroAlert(class AOrionCharHero* HeroTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAI", "PlayHeroAggroAlert");

	Params::OrionCharAI_PlayHeroAggroAlert Parms{};

	Parms.HeroTarget = HeroTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAI.RequestAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionMinionPrioritizedBehavior         Behavior                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLooping                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharAI::RequestAnimation(EOrionMinionPrioritizedBehavior Behavior, int32 PlayIndex, bool bLooping)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAI", "RequestAnimation");

	Params::OrionCharAI_RequestAnimation Parms{};

	Parms.Behavior = Behavior;
	Parms.PlayIndex = PlayIndex;
	Parms.bLooping = bLooping;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAI.SetUpMeshShadows
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           SkeletalMeshComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharAI::SetUpMeshShadows(class USkeletalMeshComponent* SkeletalMeshComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAI", "SetUpMeshShadows");

	Params::OrionCharAI_SetUpMeshShadows Parms{};

	Parms.SkeletalMeshComponent = SkeletalMeshComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAI.GetExecuteHealthThreshold
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UOrionAbilitySystemComponent*     DamagerASC                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionCharAI::GetExecuteHealthThreshold(class UOrionAbilitySystemComponent* DamagerASC) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAI", "GetExecuteHealthThreshold");

	Params::OrionCharAI_GetExecuteHealthThreshold Parms{};

	Parms.DamagerASC = DamagerASC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharAI_Minion.Debug_OverrideTeamVisuals
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// EOrionTeam                              NewTeamVisuals                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharAI_Minion::Debug_OverrideTeamVisuals(EOrionTeam NewTeamVisuals)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAI_Minion", "Debug_OverrideTeamVisuals");

	Params::OrionCharAI_Minion_Debug_OverrideTeamVisuals Parms{};

	Parms.NewTeamVisuals = NewTeamVisuals;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAI_Minion.MinionBeginOverlap
// (Final, Native, Public)
// Parameters:
// class AActor*                           SelfActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharAI_Minion::MinionBeginOverlap(class AActor* SelfActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAI_Minion", "MinionBeginOverlap");

	Params::OrionCharAI_Minion_MinionBeginOverlap Parms{};

	Parms.SelfActor = SelfActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAI_Minion.Native_DoMeleeAttack
// (Net, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharAI_Minion::Native_DoMeleeAttack(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAI_Minion", "Native_DoMeleeAttack");

	Params::OrionCharAI_Minion_Native_DoMeleeAttack Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAI_Minion.Native_DoRangedAttack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharAI_Minion::Native_DoRangedAttack(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAI_Minion", "Native_DoRangedAttack");

	Params::OrionCharAI_Minion_Native_DoRangedAttack Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAI_Minion.Native_MulticastDoRangedAttack
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// struct FOrionMinionAttackInfo           RangedAttackInfo                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)

void AOrionCharAI_Minion::Native_MulticastDoRangedAttack(const struct FOrionMinionAttackInfo& RangedAttackInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAI_Minion", "Native_MulticastDoRangedAttack");

	Params::OrionCharAI_Minion_Native_MulticastDoRangedAttack Parms{};

	Parms.RangedAttackInfo = std::move(RangedAttackInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAI_Minion.OnPlayDeathAnim
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   PlaybackTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAllowedToRagdoll                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharAI_Minion::OnPlayDeathAnim(float PlaybackTime, bool bAllowedToRagdoll)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAI_Minion", "OnPlayDeathAnim");

	Params::OrionCharAI_Minion_OnPlayDeathAnim Parms{};

	Parms.PlaybackTime = PlaybackTime;
	Parms.bAllowedToRagdoll = bAllowedToRagdoll;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionCharAI_Minion.PlaySpawning
// (Net, Native, Event, NetMulticast, Public)

void AOrionCharAI_Minion::PlaySpawning()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAI_Minion", "PlaySpawning");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAI_Minion.RequestSelfDestruct
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Delay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharAI_Minion::RequestSelfDestruct(float Delay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAI_Minion", "RequestSelfDestruct");

	Params::OrionCharAI_Minion_RequestSelfDestruct Parms{};

	Parms.Delay = Delay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAISystem.ConfigureAsBotOnlyGame
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAISystem::ConfigureAsBotOnlyGame(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAISystem", "ConfigureAsBotOnlyGame");

	Params::OrionAISystem_ConfigureAsBotOnlyGame Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAISystem.OnMatchEnded
// (Final, Native, Public)

void UOrionAISystem::OnMatchEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAISystem", "OnMatchEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAISystem.OnMatchStarted
// (Final, Native, Public)

void UOrionAISystem::OnMatchStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAISystem", "OnMatchStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAITask_FlowFieldMove.FlowFieldMove
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AOrionAIController*               Controller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLockAILogic                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionAITask_FlowFieldMove*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionAITask_FlowFieldMove* UOrionAITask_FlowFieldMove::FlowFieldMove(class AOrionAIController* Controller, bool bLockAILogic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAITask_FlowFieldMove", "FlowFieldMove");

	Params::OrionAITask_FlowFieldMove_FlowFieldMove Parms{};

	Parms.Controller = Controller;
	Parms.bLockAILogic = bLockAILogic;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction OrionGame.OrionAITask_FlowFieldMove.MoveTaskCompletedSignature__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// EPathFollowingResult                    Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAITask_FlowFieldMove::MoveTaskCompletedSignature__DelegateSignature(EPathFollowingResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAITask_FlowFieldMove", "MoveTaskCompletedSignature__DelegateSignature");

	Params::OrionAITask_FlowFieldMove_MoveTaskCompletedSignature__DelegateSignature Parms{};

	Parms.Result = Result;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionAITask_MoveTo.OrionGraphAIMoveTo
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AAIController*                    Controller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          GoalLocation                                           (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           GoalActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AcceptanceRadius                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAIOptionFlag                           StopOnOverlap                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAIOptionFlag                           AcceptPartialPath                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAITask_MoveTo*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAITask_MoveTo* UOrionAITask_MoveTo::OrionGraphAIMoveTo(class AAIController* Controller, const struct FVector& GoalLocation, class AActor* GoalActor, float AcceptanceRadius, EAIOptionFlag StopOnOverlap, EAIOptionFlag AcceptPartialPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAITask_MoveTo", "OrionGraphAIMoveTo");

	Params::OrionAITask_MoveTo_OrionGraphAIMoveTo Parms{};

	Parms.Controller = Controller;
	Parms.GoalLocation = std::move(GoalLocation);
	Parms.GoalActor = GoalActor;
	Parms.AcceptanceRadius = AcceptanceRadius;
	Parms.StopOnOverlap = StopOnOverlap;
	Parms.AcceptPartialPath = AcceptPartialPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionStoreDisplayLibrary.GetStorefrontDisplayInfo
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EOrionStoreFront                        Storefront                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FOrionStorefrontInfo             StorefrontInfo                                         (Parm, OutParm, NativeAccessSpecifierPublic)

void UOrionStoreDisplayLibrary::GetStorefrontDisplayInfo(EOrionStoreFront Storefront, struct FOrionStorefrontInfo* StorefrontInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionStoreDisplayLibrary", "GetStorefrontDisplayInfo");

	Params::OrionStoreDisplayLibrary_GetStorefrontDisplayInfo Parms{};

	Parms.Storefront = Storefront;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (StorefrontInfo != nullptr)
		*StorefrontInfo = std::move(Parms.StorefrontInfo);
}


// Function OrionGame.OrionCheatManagerGame.AddAfkPeriod
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   NewAfkPeriod                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::AddAfkPeriod(int32 NewAfkPeriod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "AddAfkPeriod");

	Params::OrionCheatManagerGame_AddAfkPeriod Parms{};

	Parms.NewAfkPeriod = NewAfkPeriod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.AddBotEnemy
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           DataAssetName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::AddBotEnemy(const class FString& DataAssetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "AddBotEnemy");

	Params::OrionCheatManagerGame_AddBotEnemy Parms{};

	Parms.DataAssetName = std::move(DataAssetName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.AddBotFriend
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           DataAssetName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::AddBotFriend(const class FString& DataAssetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "AddBotFriend");

	Params::OrionCheatManagerGame_AddBotFriend Parms{};

	Parms.DataAssetName = std::move(DataAssetName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.AddTag
// (Exec, Native, Public)
// Parameters:
// class FString                           TagName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::AddTag(const class FString& TagName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "AddTag");

	Params::OrionCheatManagerGame_AddTag Parms{};

	Parms.TagName = std::move(TagName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.AI_AttackNow
// (Final, Exec, Native, Public)

void UOrionCheatManagerGame::AI_AttackNow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "AI_AttackNow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.AllowCardMenuAnywhere
// (Exec, Native, Public)
// Parameters:
// int32                                   Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::AllowCardMenuAnywhere(int32 Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "AllowCardMenuAnywhere");

	Params::OrionCheatManagerGame_AllowCardMenuAnywhere Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ApplyGameplayEffectToCharacter
// (Exec, Native, Public)
// Parameters:
// class FString                           CharacterObjectName                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           GameplayEffectName                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::ApplyGameplayEffectToCharacter(const class FString& CharacterObjectName, const class FString& GameplayEffectName, float Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ApplyGameplayEffectToCharacter");

	Params::OrionCheatManagerGame_ApplyGameplayEffectToCharacter Parms{};

	Parms.CharacterObjectName = std::move(CharacterObjectName);
	Parms.GameplayEffectName = std::move(GameplayEffectName);
	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ApplyGameplayEffectToSelf
// (Exec, Native, Public)
// Parameters:
// class FString                           GameplayEffectName                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::ApplyGameplayEffectToSelf(const class FString& GameplayEffectName, float Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ApplyGameplayEffectToSelf");

	Params::OrionCheatManagerGame_ApplyGameplayEffectToSelf Parms{};

	Parms.GameplayEffectName = std::move(GameplayEffectName);
	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.BadAss
// (Exec, Native, Public)
// Parameters:
// int32                                   State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::BadAss(int32 State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "BadAss");

	Params::OrionCheatManagerGame_BadAss Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.CoreUnlimitedHealth
// (Exec, Native, Public)
// Parameters:
// int32                                   State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::CoreUnlimitedHealth(int32 State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "CoreUnlimitedHealth");

	Params::OrionCheatManagerGame_CoreUnlimitedHealth Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.DamageSelf
// (Exec, Native, Public)
// Parameters:
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::DamageSelf(float DamageAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "DamageSelf");

	Params::OrionCheatManagerGame_DamageSelf Parms{};

	Parms.DamageAmount = DamageAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.DestroyAllNonPlayerPawns
// (Exec, Native, Public)

void UOrionCheatManagerGame::DestroyAllNonPlayerPawns()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "DestroyAllNonPlayerPawns");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.DestroyAllPlaceableObjects
// (Exec, Native, Public)

void UOrionCheatManagerGame::DestroyAllPlaceableObjects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "DestroyAllPlaceableObjects");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.DisableRework
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           HeroName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::DisableRework(const class FString& HeroName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "DisableRework");

	Params::OrionCheatManagerGame_DisableRework Parms{};

	Parms.HeroName = std::move(HeroName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.DisplayFacialPreview
// (Final, Exec, Native, Public)

void UOrionCheatManagerGame::DisplayFacialPreview()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "DisplayFacialPreview");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.DrawDamageNumbers
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bDrawNumbers                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::DrawDamageNumbers(bool bDrawNumbers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "DrawDamageNumbers");

	Params::OrionCheatManagerGame_DrawDamageNumbers Parms{};

	Parms.bDrawNumbers = bDrawNumbers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.DumpGameStats
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           FilterName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::DumpGameStats(const class FString& FilterName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "DumpGameStats");

	Params::OrionCheatManagerGame_DumpGameStats Parms{};

	Parms.FilterName = std::move(FilterName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.EnableFixedTimeStep
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   AsIfItWasFPS                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::EnableFixedTimeStep(int32 AsIfItWasFPS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "EnableFixedTimeStep");

	Params::OrionCheatManagerGame_EnableFixedTimeStep Parms{};

	Parms.AsIfItWasFPS = AsIfItWasFPS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.EnableRework
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           HeroName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::EnableRework(const class FString& HeroName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "EnableRework");

	Params::OrionCheatManagerGame_EnableRework Parms{};

	Parms.HeroName = std::move(HeroName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.EndSurrenderVoteTimer
// (Exec, Native, Public)
// Parameters:
// uint8                                   TeamNum                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::EndSurrenderVoteTimer(uint8 TeamNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "EndSurrenderVoteTimer");

	Params::OrionCheatManagerGame_EndSurrenderVoteTimer Parms{};

	Parms.TeamNum = TeamNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ExecuteOrionDevMenuHistory
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Idx                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::ExecuteOrionDevMenuHistory(int32 Idx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ExecuteOrionDevMenuHistory");

	Params::OrionCheatManagerGame_ExecuteOrionDevMenuHistory Parms{};

	Parms.Idx = Idx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.FillWithBots
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   BotsToAddToEachTeam                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           HeroList                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::FillWithBots(int32 BotsToAddToEachTeam, const class FString& HeroList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "FillWithBots");

	Params::OrionCheatManagerGame_FillWithBots Parms{};

	Parms.BotsToAddToEachTeam = BotsToAddToEachTeam;
	Parms.HeroList = std::move(HeroList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ForceAISpawnerStartingLevelTo
// (Exec, Native, Public)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::ForceAISpawnerStartingLevelTo(int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ForceAISpawnerStartingLevelTo");

	Params::OrionCheatManagerGame_ForceAISpawnerStartingLevelTo Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ForceAllPlayersToLevel
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::ForceAllPlayersToLevel(int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ForceAllPlayersToLevel");

	Params::OrionCheatManagerGame_ForceAllPlayersToLevel Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ForceAllPlayersToMaxLevel
// (Final, Exec, Native, Public)

void UOrionCheatManagerGame::ForceAllPlayersToMaxLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ForceAllPlayersToMaxLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ForceBotDifficulty
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           DifficultyName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::ForceBotDifficulty(const class FString& DifficultyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ForceBotDifficulty");

	Params::OrionCheatManagerGame_ForceBotDifficulty Parms{};

	Parms.DifficultyName = std::move(DifficultyName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ForceBotLane
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   LaneIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::ForceBotLane(int32 LaneIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ForceBotLane");

	Params::OrionCheatManagerGame_ForceBotLane Parms{};

	Parms.LaneIndex = LaneIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ForceEndgame
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   TeamNumber                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MoveDoomedTeamSpawnPoints                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::ForceEndgame(int32 TeamNumber, int32 MoveDoomedTeamSpawnPoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ForceEndgame");

	Params::OrionCheatManagerGame_ForceEndgame Parms{};

	Parms.TeamNumber = TeamNumber;
	Parms.MoveDoomedTeamSpawnPoints = MoveDoomedTeamSpawnPoints;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ForceEquipCard
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           CardName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CardLevel                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::ForceEquipCard(int32 Slot, const class FString& CardName, int32 CardLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ForceEquipCard");

	Params::OrionCheatManagerGame_ForceEquipCard Parms{};

	Parms.Slot = Slot;
	Parms.CardName = std::move(CardName);
	Parms.CardLevel = CardLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ForceEquipCardForAll
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           CardName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CardLevel                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::ForceEquipCardForAll(int32 Slot, const class FString& CardName, int32 CardLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ForceEquipCardForAll");

	Params::OrionCheatManagerGame_ForceEquipCardForAll Parms{};

	Parms.Slot = Slot;
	Parms.CardName = std::move(CardName);
	Parms.CardLevel = CardLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ForceLossScreen
// (Final, Exec, Native, Public)

void UOrionCheatManagerGame::ForceLossScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ForceLossScreen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ForcePlayerMaxLevel
// (Final, Exec, Native, Public)

void UOrionCheatManagerGame::ForcePlayerMaxLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ForcePlayerMaxLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ForcePlayerToMaxStats
// (Exec, Native, Public)

void UOrionCheatManagerGame::ForcePlayerToMaxStats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ForcePlayerToMaxStats");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ForcePlayerToMinStats
// (Exec, Native, Public)

void UOrionCheatManagerGame::ForcePlayerToMinStats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ForcePlayerToMinStats");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ForceRefineryFill
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::ForceRefineryFill(int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ForceRefineryFill");

	Params::OrionCheatManagerGame_ForceRefineryFill Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ForceRefineryFillForTeam
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   TeamNumber                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::ForceRefineryFillForTeam(int32 TeamNumber, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ForceRefineryFillForTeam");

	Params::OrionCheatManagerGame_ForceRefineryFillForTeam Parms{};

	Parms.TeamNumber = TeamNumber;
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ForceRoundStart
// (Final, Exec, Native, Public)

void UOrionCheatManagerGame::ForceRoundStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ForceRoundStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ForceSpawnPrimeHelix
// (Exec, Native, Public)

void UOrionCheatManagerGame::ForceSpawnPrimeHelix()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ForceSpawnPrimeHelix");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ForceVictoryScreen
// (Final, Exec, Native, Public)

void UOrionCheatManagerGame::ForceVictoryScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ForceVictoryScreen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ForceWinMatch
// (Exec, Native, Public)
// Parameters:
// uint8                                   WinningTeamNum                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumSeconds                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::ForceWinMatch(uint8 WinningTeamNum, int32 NumSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ForceWinMatch");

	Params::OrionCheatManagerGame_ForceWinMatch Parms{};

	Parms.WinningTeamNum = WinningTeamNum;
	Parms.NumSeconds = NumSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.GiveGold
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Gold                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::GiveGold(int32 Gold)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "GiveGold");

	Params::OrionCheatManagerGame_GiveGold Parms{};

	Parms.Gold = Gold;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.GiveTeamXP
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   TeamIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   XP                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::GiveTeamXP(int32 TeamIndex, int32 XP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "GiveTeamXP");

	Params::OrionCheatManagerGame_GiveTeamXP Parms{};

	Parms.TeamIndex = TeamIndex;
	Parms.XP = XP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.GiveXP
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   XP                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::GiveXP(int32 XP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "GiveXP");

	Params::OrionCheatManagerGame_GiveXP Parms{};

	Parms.XP = XP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.God
// (Exec, Native, Public)

void UOrionCheatManagerGame::God()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "God");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.HealSelf
// (Exec, Native, Public)
// Parameters:
// float                                   HealAmount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::HealSelf(float HealAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "HealSelf");

	Params::OrionCheatManagerGame_HealSelf Parms{};

	Parms.HealAmount = HealAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.HideAFKWarning
// (Final, Exec, Native, Public)

void UOrionCheatManagerGame::HideAFKWarning()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "HideAFKWarning");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.HideHeroSelect
// (Exec, Native, Public)

void UOrionCheatManagerGame::HideHeroSelect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "HideHeroSelect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.HideMatchInfoText
// (Final, Exec, Native, Public)

void UOrionCheatManagerGame::HideMatchInfoText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "HideMatchInfoText");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.HideVictoryScreen
// (Final, Exec, Native, Public)

void UOrionCheatManagerGame::HideVictoryScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "HideVictoryScreen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.InterruptCurrentAbility
// (Exec, Native, Public)

void UOrionCheatManagerGame::InterruptCurrentAbility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "InterruptCurrentAbility");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.InvertMouse
// (Final, Exec, Native, Public)

void UOrionCheatManagerGame::InvertMouse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "InvertMouse");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.KillAI
// (Exec, Native, Public)
// Parameters:
// int32                                   DisableAISpawning                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::KillAI(int32 DisableAISpawning)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "KillAI");

	Params::OrionCheatManagerGame_KillAI Parms{};

	Parms.DisableAISpawning = DisableAISpawning;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.KillAllNonPlayerPawns
// (Exec, Native, Public)

void UOrionCheatManagerGame::KillAllNonPlayerPawns()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "KillAllNonPlayerPawns");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.KillJungleAI
// (Exec, Native, Public)

void UOrionCheatManagerGame::KillJungleAI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "KillJungleAI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.KillMinionAI
// (Exec, Native, Public)

void UOrionCheatManagerGame::KillMinionAI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "KillMinionAI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.KillTeamBots
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   TeamIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::KillTeamBots(int32 TeamIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "KillTeamBots");

	Params::OrionCheatManagerGame_KillTeamBots Parms{};

	Parms.TeamIndex = TeamIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.KnockbackSelf
// (Exec, Native, Public)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::KnockbackSelf(float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "KnockbackSelf");

	Params::OrionCheatManagerGame_KnockbackSelf Parms{};

	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.KnockupSelf
// (Exec, Native, Public)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::KnockupSelf(float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "KnockupSelf");

	Params::OrionCheatManagerGame_KnockupSelf Parms{};

	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ListAvailableHeroes
// (Final, Exec, Native, Public)

void UOrionCheatManagerGame::ListAvailableHeroes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ListAvailableHeroes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ModifyMaxMoveSpeed
// (Exec, Native, Public)
// Parameters:
// float                                   MoveAmount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::ModifyMaxMoveSpeed(float MoveAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ModifyMaxMoveSpeed");

	Params::OrionCheatManagerGame_ModifyMaxMoveSpeed Parms{};

	Parms.MoveAmount = MoveAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.NextHero
// (Final, Exec, Native, Public)

void UOrionCheatManagerGame::NextHero()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "NextHero");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.OrionDevMenu
// (Final, Exec, Native, Public)

void UOrionCheatManagerGame::OrionDevMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "OrionDevMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.PauseAI
// (Final, Exec, Native, Public)

void UOrionCheatManagerGame::PauseAI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "PauseAI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.PlayAmbientEventWithId
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           EventID                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::PlayAmbientEventWithId(const class FString& EventID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "PlayAmbientEventWithId");

	Params::OrionCheatManagerGame_PlayAmbientEventWithId Parms{};

	Parms.EventID = std::move(EventID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.PrintAbilitySystemComponent
// (Final, Exec, Native, Public)

void UOrionCheatManagerGame::PrintAbilitySystemComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "PrintAbilitySystemComponent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.PrintBotDifficulty
// (Final, Exec, Native, Public)

void UOrionCheatManagerGame::PrintBotDifficulty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "PrintBotDifficulty");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.RemoveCooldowns
// (Exec, Native, Public)
// Parameters:
// int32                                   State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::RemoveCooldowns(int32 State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "RemoveCooldowns");

	Params::OrionCheatManagerGame_RemoveCooldowns Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.RemoveCosts
// (Exec, Native, Public)
// Parameters:
// int32                                   State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::RemoveCosts(int32 State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "RemoveCosts");

	Params::OrionCheatManagerGame_RemoveCosts Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.RemoveGameplayEffectFromCharacter
// (Exec, Native, Public)
// Parameters:
// class FString                           CharacterObjectName                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           GameplayEffectName                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::RemoveGameplayEffectFromCharacter(const class FString& CharacterObjectName, const class FString& GameplayEffectName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "RemoveGameplayEffectFromCharacter");

	Params::OrionCheatManagerGame_RemoveGameplayEffectFromCharacter Parms{};

	Parms.CharacterObjectName = std::move(CharacterObjectName);
	Parms.GameplayEffectName = std::move(GameplayEffectName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.RemoveGameplayEffectFromSelf
// (Exec, Native, Public)
// Parameters:
// class FString                           GameplayEffectName                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::RemoveGameplayEffectFromSelf(const class FString& GameplayEffectName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "RemoveGameplayEffectFromSelf");

	Params::OrionCheatManagerGame_RemoveGameplayEffectFromSelf Parms{};

	Parms.GameplayEffectName = std::move(GameplayEffectName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.RemoveGameplayEffectLastApplied
// (Exec, Native, Public)

void UOrionCheatManagerGame::RemoveGameplayEffectLastApplied()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "RemoveGameplayEffectLastApplied");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.RemoveRespawnTime
// (Exec, Native, Public)
// Parameters:
// int32                                   State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::RemoveRespawnTime(int32 State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "RemoveRespawnTime");

	Params::OrionCheatManagerGame_RemoveRespawnTime Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.RemoveRespawnTimeAll
// (Exec, Native, Public)
// Parameters:
// int32                                   State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::RemoveRespawnTimeAll(int32 State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "RemoveRespawnTimeAll");

	Params::OrionCheatManagerGame_RemoveRespawnTimeAll Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.RemoveTag
// (Exec, Native, Public)
// Parameters:
// class FString                           TagName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::RemoveTag(const class FString& TagName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "RemoveTag");

	Params::OrionCheatManagerGame_RemoveTag Parms{};

	Parms.TagName = std::move(TagName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ReselectHero
// (Exec, Native, Public)

void UOrionCheatManagerGame::ReselectHero()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ReselectHero");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ResetCards
// (Final, Exec, Native, Public)

void UOrionCheatManagerGame::ResetCards()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ResetCards");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ResetCooldowns
// (Exec, Native, Public)

void UOrionCheatManagerGame::ResetCooldowns()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ResetCooldowns");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ResetSurrenderVoteCooldown
// (Exec, Native, Public)
// Parameters:
// uint8                                   TeamNum                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::ResetSurrenderVoteCooldown(uint8 TeamNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ResetSurrenderVoteCooldown");

	Params::OrionCheatManagerGame_ResetSurrenderVoteCooldown Parms{};

	Parms.TeamNum = TeamNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ResumeAI
// (Final, Exec, Native, Public)

void UOrionCheatManagerGame::ResumeAI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ResumeAI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SetAllAbilityLevels
// (Exec, Native, Public)
// Parameters:
// int32                                   NewLevel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SetAllAbilityLevels(int32 NewLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SetAllAbilityLevels");

	Params::OrionCheatManagerGame_SetAllAbilityLevels Parms{};

	Parms.NewLevel = NewLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SetAllMinionWaveData
// (Exec, Native, Public)
// Parameters:
// class FString                           DataAssetName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SetAllMinionWaveData(const class FString& DataAssetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SetAllMinionWaveData");

	Params::OrionCheatManagerGame_SetAllMinionWaveData Parms{};

	Parms.DataAssetName = std::move(DataAssetName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SetEnemyMinionWaveData
// (Exec, Native, Public)
// Parameters:
// class FString                           DataAssetName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SetEnemyMinionWaveData(const class FString& DataAssetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SetEnemyMinionWaveData");

	Params::OrionCheatManagerGame_SetEnemyMinionWaveData Parms{};

	Parms.DataAssetName = std::move(DataAssetName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SetEnergyPercent
// (Exec, Native, Public)
// Parameters:
// float                                   NewPercent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SetEnergyPercent(float NewPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SetEnergyPercent");

	Params::OrionCheatManagerGame_SetEnergyPercent Parms{};

	Parms.NewPercent = NewPercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SetFriendlyMinionWaveData
// (Exec, Native, Public)
// Parameters:
// class FString                           DataAssetName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SetFriendlyMinionWaveData(const class FString& DataAssetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SetFriendlyMinionWaveData");

	Params::OrionCheatManagerGame_SetFriendlyMinionWaveData Parms{};

	Parms.DataAssetName = std::move(DataAssetName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SetHealthPercent
// (Exec, Native, Public)
// Parameters:
// float                                   NewPercent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SetHealthPercent(float NewPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SetHealthPercent");

	Params::OrionCheatManagerGame_SetHealthPercent Parms{};

	Parms.NewPercent = NewPercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SetHero
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           HeroName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SetHero(const class FString& HeroName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SetHero");

	Params::OrionCheatManagerGame_SetHero Parms{};

	Parms.HeroName = std::move(HeroName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SetHeroStat
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           HeroName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           StatName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SetHeroStat(const class FString& HeroName, const class FString& StatName, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SetHeroStat");

	Params::OrionCheatManagerGame_SetHeroStat Parms{};

	Parms.HeroName = std::move(HeroName);
	Parms.StatName = std::move(StatName);
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SetMinionTeamDifficulty
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   TeamIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           DifficultyName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SetMinionTeamDifficulty(int32 TeamIndex, const class FString& DifficultyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SetMinionTeamDifficulty");

	Params::OrionCheatManagerGame_SetMinionTeamDifficulty Parms{};

	Parms.TeamIndex = TeamIndex;
	Parms.DifficultyName = std::move(DifficultyName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SetMouseSensitivityToDefault
// (Final, Exec, Native, Public)

void UOrionCheatManagerGame::SetMouseSensitivityToDefault()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SetMouseSensitivityToDefault");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SetMyAbilityLevels
// (Exec, Native, Public)
// Parameters:
// int32                                   NewLevel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SetMyAbilityLevels(int32 NewLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SetMyAbilityLevels");

	Params::OrionCheatManagerGame_SetMyAbilityLevels Parms{};

	Parms.NewLevel = NewLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SetPlayerDeckInstance
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           DeckName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SetPlayerDeckInstance(const class FString& DeckName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SetPlayerDeckInstance");

	Params::OrionCheatManagerGame_SetPlayerDeckInstance Parms{};

	Parms.DeckName = std::move(DeckName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SetPlayerPosition
// (Final, Exec, Native, Public)
// Parameters:
// EOrionPosition                          Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SetPlayerPosition(EOrionPosition Position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SetPlayerPosition");

	Params::OrionCheatManagerGame_SetPlayerPosition Parms{};

	Parms.Position = Position;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SetPlayerStat
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           StatName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SetPlayerStat(const class FString& StatName, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SetPlayerStat");

	Params::OrionCheatManagerGame_SetPlayerStat Parms{};

	Parms.StatName = std::move(StatName);
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SetShouldAbortMatchStartWhenPlayersMissing
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bShouldAbort                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldPenalize                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SetShouldAbortMatchStartWhenPlayersMissing(bool bShouldAbort, bool bShouldPenalize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SetShouldAbortMatchStartWhenPlayersMissing");

	Params::OrionCheatManagerGame_SetShouldAbortMatchStartWhenPlayersMissing Parms{};

	Parms.bShouldAbort = bShouldAbort;
	Parms.bShouldPenalize = bShouldPenalize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SetTeamNum
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   TeamIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SetTeamNum(int32 TeamIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SetTeamNum");

	Params::OrionCheatManagerGame_SetTeamNum Parms{};

	Parms.TeamIndex = TeamIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SetVisionManagerDebug
// (Final, Exec, Native, Public)
// Parameters:
// uint8                                   DebugMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Filter                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   FilterIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SingleFilterType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SetVisionManagerDebug(uint8 DebugMode, uint8 Filter, int32 FilterIndex, int32 SingleFilterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SetVisionManagerDebug");

	Params::OrionCheatManagerGame_SetVisionManagerDebug Parms{};

	Parms.DebugMode = DebugMode;
	Parms.Filter = Filter;
	Parms.FilterIndex = FilterIndex;
	Parms.SingleFilterType = SingleFilterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ShieldSelf
// (Exec, Native, Public)
// Parameters:
// float                                   ShieldAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::ShieldSelf(float ShieldAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ShieldSelf");

	Params::OrionCheatManagerGame_ShieldSelf Parms{};

	Parms.ShieldAmount = ShieldAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ShowAFKWarning
// (Final, Exec, Native, Public)

void UOrionCheatManagerGame::ShowAFKWarning()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ShowAFKWarning");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ShowMatchInfoText
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Text                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::ShowMatchInfoText(const class FString& Text)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ShowMatchInfoText");

	Params::OrionCheatManagerGame_ShowMatchInfoText Parms{};

	Parms.Text = std::move(Text);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SimulateCheatDetected
// (Exec, Native, Public)
// Parameters:
// bool                                    bRevokeAuthToken                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bKickFromMatch                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReasonStr                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SimulateCheatDetected(bool bRevokeAuthToken, bool bKickFromMatch, const class FString& ReasonStr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SimulateCheatDetected");

	Params::OrionCheatManagerGame_SimulateCheatDetected Parms{};

	Parms.bRevokeAuthToken = bRevokeAuthToken;
	Parms.bKickFromMatch = bKickFromMatch;
	Parms.ReasonStr = std::move(ReasonStr);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SkipMatinee
// (Final, Exec, Native, Public)

void UOrionCheatManagerGame::SkipMatinee()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SkipMatinee");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SpawnCreepMinion
// (Exec, Native, Public)
// Parameters:
// class FString                           DataAssetName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SpawnCreepMinion(const class FString& DataAssetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SpawnCreepMinion");

	Params::OrionCheatManagerGame_SpawnCreepMinion Parms{};

	Parms.DataAssetName = std::move(DataAssetName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SpawnCreepMinionAtPos
// (Exec, Native, Public)
// Parameters:
// class FString                           DataAssetName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SpawnCreepMinionAtPos(const class FString& DataAssetName, float X, float Y, float Z)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SpawnCreepMinionAtPos");

	Params::OrionCheatManagerGame_SpawnCreepMinionAtPos Parms{};

	Parms.DataAssetName = std::move(DataAssetName);
	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SpawnCreepMinionAtPosAndRotation
// (Exec, Native, Public)
// Parameters:
// class FString                           DataAssetName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InVerticalRotation                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SpawnCreepMinionAtPosAndRotation(const class FString& DataAssetName, float X, float Y, float Z, float InVerticalRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SpawnCreepMinionAtPosAndRotation");

	Params::OrionCheatManagerGame_SpawnCreepMinionAtPosAndRotation Parms{};

	Parms.DataAssetName = std::move(DataAssetName);
	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;
	Parms.InVerticalRotation = InVerticalRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SpawnEnemyHero
// (Exec, Native, Public)
// Parameters:
// class FString                           DataAssetName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SpawnEnemyHero(const class FString& DataAssetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SpawnEnemyHero");

	Params::OrionCheatManagerGame_SpawnEnemyHero Parms{};

	Parms.DataAssetName = std::move(DataAssetName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SpawnEnemyHeroAtPos
// (Exec, Native, Public)
// Parameters:
// class FString                           DataAssetName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SpawnEnemyHeroAtPos(const class FString& DataAssetName, float X, float Y, float Z)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SpawnEnemyHeroAtPos");

	Params::OrionCheatManagerGame_SpawnEnemyHeroAtPos Parms{};

	Parms.DataAssetName = std::move(DataAssetName);
	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SpawnEnemyHeroAtPosAndRotation
// (Exec, Native, Public)
// Parameters:
// class FString                           DataAssetName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InVerticalRotation                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWithBotController                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SpawnEnemyHeroAtPosAndRotation(const class FString& DataAssetName, float X, float Y, float Z, float InVerticalRotation, bool bWithBotController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SpawnEnemyHeroAtPosAndRotation");

	Params::OrionCheatManagerGame_SpawnEnemyHeroAtPosAndRotation Parms{};

	Parms.DataAssetName = std::move(DataAssetName);
	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;
	Parms.InVerticalRotation = InVerticalRotation;
	Parms.bWithBotController = bWithBotController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SpawnEnemyHeroWithSkinAtPosAndRotation
// (Exec, Native, Public)
// Parameters:
// class FString                           DataAssetName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SkinName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InVerticalRotation                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWithBotController                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SpawnEnemyHeroWithSkinAtPosAndRotation(const class FString& DataAssetName, const class FString& SkinName, float X, float Y, float Z, float InVerticalRotation, bool bWithBotController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SpawnEnemyHeroWithSkinAtPosAndRotation");

	Params::OrionCheatManagerGame_SpawnEnemyHeroWithSkinAtPosAndRotation Parms{};

	Parms.DataAssetName = std::move(DataAssetName);
	Parms.SkinName = std::move(SkinName);
	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;
	Parms.InVerticalRotation = InVerticalRotation;
	Parms.bWithBotController = bWithBotController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SpawnEnemyMinion
// (Exec, Native, Public)
// Parameters:
// class FString                           DataAssetName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SpawnEnemyMinion(const class FString& DataAssetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SpawnEnemyMinion");

	Params::OrionCheatManagerGame_SpawnEnemyMinion Parms{};

	Parms.DataAssetName = std::move(DataAssetName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SpawnEnemyMinionAtPos
// (Exec, Native, Public)
// Parameters:
// class FString                           DataAssetName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SpawnEnemyMinionAtPos(const class FString& DataAssetName, float X, float Y, float Z)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SpawnEnemyMinionAtPos");

	Params::OrionCheatManagerGame_SpawnEnemyMinionAtPos Parms{};

	Parms.DataAssetName = std::move(DataAssetName);
	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SpawnEnemyMinionAtPosAndRotation
// (Exec, Native, Public)
// Parameters:
// class FString                           DataAssetName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InVerticalRotation                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SpawnEnemyMinionAtPosAndRotation(const class FString& DataAssetName, float X, float Y, float Z, float InVerticalRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SpawnEnemyMinionAtPosAndRotation");

	Params::OrionCheatManagerGame_SpawnEnemyMinionAtPosAndRotation Parms{};

	Parms.DataAssetName = std::move(DataAssetName);
	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;
	Parms.InVerticalRotation = InVerticalRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SpawnFriendlyHero
// (Exec, Native, Public)
// Parameters:
// class FString                           DataAssetName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SpawnFriendlyHero(const class FString& DataAssetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SpawnFriendlyHero");

	Params::OrionCheatManagerGame_SpawnFriendlyHero Parms{};

	Parms.DataAssetName = std::move(DataAssetName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SpawnFriendlyHeroAtPos
// (Exec, Native, Public)
// Parameters:
// class FString                           DataAssetName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SpawnFriendlyHeroAtPos(const class FString& DataAssetName, float X, float Y, float Z)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SpawnFriendlyHeroAtPos");

	Params::OrionCheatManagerGame_SpawnFriendlyHeroAtPos Parms{};

	Parms.DataAssetName = std::move(DataAssetName);
	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SpawnFriendlyHeroAtPosAndRotation
// (Exec, Native, Public)
// Parameters:
// class FString                           DataAssetName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InVerticalRotation                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SpawnFriendlyHeroAtPosAndRotation(const class FString& DataAssetName, float X, float Y, float Z, float InVerticalRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SpawnFriendlyHeroAtPosAndRotation");

	Params::OrionCheatManagerGame_SpawnFriendlyHeroAtPosAndRotation Parms{};

	Parms.DataAssetName = std::move(DataAssetName);
	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;
	Parms.InVerticalRotation = InVerticalRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SpawnFriendlyHeroWithSkinAtPosAndRotation
// (Exec, Native, Public)
// Parameters:
// class FString                           DataAssetName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SkinName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InVerticalRotation                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SpawnFriendlyHeroWithSkinAtPosAndRotation(const class FString& DataAssetName, const class FString& SkinName, float X, float Y, float Z, float InVerticalRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SpawnFriendlyHeroWithSkinAtPosAndRotation");

	Params::OrionCheatManagerGame_SpawnFriendlyHeroWithSkinAtPosAndRotation Parms{};

	Parms.DataAssetName = std::move(DataAssetName);
	Parms.SkinName = std::move(SkinName);
	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;
	Parms.InVerticalRotation = InVerticalRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SpawnFriendlyMinion
// (Exec, Native, Public)
// Parameters:
// class FString                           DataAssetName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SpawnFriendlyMinion(const class FString& DataAssetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SpawnFriendlyMinion");

	Params::OrionCheatManagerGame_SpawnFriendlyMinion Parms{};

	Parms.DataAssetName = std::move(DataAssetName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SpawnFriendlyMinionAtPos
// (Exec, Native, Public)
// Parameters:
// class FString                           DataAssetName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SpawnFriendlyMinionAtPos(const class FString& DataAssetName, float X, float Y, float Z)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SpawnFriendlyMinionAtPos");

	Params::OrionCheatManagerGame_SpawnFriendlyMinionAtPos Parms{};

	Parms.DataAssetName = std::move(DataAssetName);
	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SpawnFriendlyMinionAtPosAndRotation
// (Exec, Native, Public)
// Parameters:
// class FString                           DataAssetName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InVerticalRotation                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SpawnFriendlyMinionAtPosAndRotation(const class FString& DataAssetName, float X, float Y, float Z, float InVerticalRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SpawnFriendlyMinionAtPosAndRotation");

	Params::OrionCheatManagerGame_SpawnFriendlyMinionAtPosAndRotation Parms{};

	Parms.DataAssetName = std::move(DataAssetName);
	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;
	Parms.InVerticalRotation = InVerticalRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SpawnTargetDummyHero
// (Exec, Native, Public)
// Parameters:
// class FString                           DataAssetName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SpawnTargetDummyHero(const class FString& DataAssetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SpawnTargetDummyHero");

	Params::OrionCheatManagerGame_SpawnTargetDummyHero Parms{};

	Parms.DataAssetName = std::move(DataAssetName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SpawnTargetDummyHeroAtPos
// (Exec, Native, Public)
// Parameters:
// class FString                           DataAssetName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SpawnTargetDummyHeroAtPos(const class FString& DataAssetName, float X, float Y, float Z)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SpawnTargetDummyHeroAtPos");

	Params::OrionCheatManagerGame_SpawnTargetDummyHeroAtPos Parms{};

	Parms.DataAssetName = std::move(DataAssetName);
	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SpawnTargetDummyHeroAtPosAndRotation
// (Exec, Native, Public)
// Parameters:
// class FString                           DataAssetName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InVerticalRotation                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SpawnTargetDummyHeroAtPosAndRotation(const class FString& DataAssetName, float X, float Y, float Z, float InVerticalRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SpawnTargetDummyHeroAtPosAndRotation");

	Params::OrionCheatManagerGame_SpawnTargetDummyHeroAtPosAndRotation Parms{};

	Parms.DataAssetName = std::move(DataAssetName);
	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;
	Parms.InVerticalRotation = InVerticalRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.StopCoinSpawning
// (Exec, Native, Public)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::StopCoinSpawning(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "StopCoinSpawning");

	Params::OrionCheatManagerGame_StopCoinSpawning Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.SurrenderVote
// (Exec, Native, Public)
// Parameters:
// bool                                    bVoteYes                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::SurrenderVote(bool bVoteYes, int32 Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "SurrenderVote");

	Params::OrionCheatManagerGame_SurrenderVote Parms{};

	Parms.bVoteYes = bVoteYes;
	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ToggleAbilityLevelEnforcement
// (Final, Exec, Native, Public)

void UOrionCheatManagerGame::ToggleAbilityLevelEnforcement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ToggleAbilityLevelEnforcement");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ToggleAbilityWidgets
// (Final, Exec, Native, Public)

void UOrionCheatManagerGame::ToggleAbilityWidgets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ToggleAbilityWidgets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ToggleAIAttack
// (Exec, Native, Public)

void UOrionCheatManagerGame::ToggleAIAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ToggleAIAttack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ToggleAIWaveSpawning
// (Exec, Native, Public)

void UOrionCheatManagerGame::ToggleAIWaveSpawning()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ToggleAIWaveSpawning");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ToggleBotsGod
// (Final, Exec, Native, Public)

void UOrionCheatManagerGame::ToggleBotsGod()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ToggleBotsGod");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ToggleDamageLog
// (Exec, Native, Public)

void UOrionCheatManagerGame::ToggleDamageLog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ToggleDamageLog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ToggleDebugXP
// (Final, Exec, Native, Public)

void UOrionCheatManagerGame::ToggleDebugXP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ToggleDebugXP");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ToggleEnableRootMotionSources
// (Final, Exec, Native, Public)

void UOrionCheatManagerGame::ToggleEnableRootMotionSources()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ToggleEnableRootMotionSources");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ToggleEnemyInfoWidget
// (Final, Exec, Native, Public)

void UOrionCheatManagerGame::ToggleEnemyInfoWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ToggleEnemyInfoWidget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ToggleFixedCamera
// (Exec, Native, Public)

void UOrionCheatManagerGame::ToggleFixedCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ToggleFixedCamera");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ToggleHealthAndStatusWidget
// (Final, Exec, Native, Public)

void UOrionCheatManagerGame::ToggleHealthAndStatusWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ToggleHealthAndStatusWidget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ToggleIndicatorWidgets
// (Final, Exec, Native, Public)

void UOrionCheatManagerGame::ToggleIndicatorWidgets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ToggleIndicatorWidgets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ToggleIsUsingGamepad
// (Final, Exec, Native, Public)

void UOrionCheatManagerGame::ToggleIsUsingGamepad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ToggleIsUsingGamepad");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ToggleJuggernaut
// (Exec, Native, Public)

void UOrionCheatManagerGame::ToggleJuggernaut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ToggleJuggernaut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ToggleLimbo
// (Exec, Native, Public)

void UOrionCheatManagerGame::ToggleLimbo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ToggleLimbo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ToggleMiniMapWidget
// (Final, Exec, Native, Public)

void UOrionCheatManagerGame::ToggleMiniMapWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ToggleMiniMapWidget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ToggleOverheadHealth
// (Exec, Native, Public)

void UOrionCheatManagerGame::ToggleOverheadHealth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ToggleOverheadHealth");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ToggleRoot
// (Exec, Native, Public)

void UOrionCheatManagerGame::ToggleRoot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ToggleRoot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ToggleScoreboardUpdating
// (Final, Exec, Native, Public)

void UOrionCheatManagerGame::ToggleScoreboardUpdating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ToggleScoreboardUpdating");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ToggleSilence
// (Exec, Native, Public)

void UOrionCheatManagerGame::ToggleSilence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ToggleSilence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ToggleStun
// (Exec, Native, Public)

void UOrionCheatManagerGame::ToggleStun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ToggleStun");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ToggleStunStressTest
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::ToggleStunStressTest(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ToggleStunStressTest");

	Params::OrionCheatManagerGame_ToggleStunStressTest Parms{};

	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ToggleTeamInfoWidget
// (Final, Exec, Native, Public)

void UOrionCheatManagerGame::ToggleTeamInfoWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ToggleTeamInfoWidget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.ToggleUnselectable
// (Exec, Native, Public)

void UOrionCheatManagerGame::ToggleUnselectable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "ToggleUnselectable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.TowerGod
// (Exec, Native, Public)
// Parameters:
// bool                                    bTowerGod                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::TowerGod(bool bTowerGod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "TowerGod");

	Params::OrionCheatManagerGame_TowerGod Parms{};

	Parms.bTowerGod = bTowerGod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.TravelModeMode
// (Exec, Native, Public)
// Parameters:
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::TravelModeMode(int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "TravelModeMode");

	Params::OrionCheatManagerGame_TravelModeMode Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.UnlimitedHealth
// (Exec, Native, Public)
// Parameters:
// int32                                   State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::UnlimitedHealth(int32 State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "UnlimitedHealth");

	Params::OrionCheatManagerGame_UnlimitedHealth Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.VisionManagerDebugLog
// (Final, Exec, Native, Public)

void UOrionCheatManagerGame::VisionManagerDebugLog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "VisionManagerDebugLog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.VLogAIEvent
// (Exec, Native, Public)
// Parameters:
// class FString                           EventLabel                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::VLogAIEvent(const class FString& EventLabel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "VLogAIEvent");

	Params::OrionCheatManagerGame_VLogAIEvent Parms{};

	Parms.EventLabel = std::move(EventLabel);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.WhyItemsBroke
// (Final, Exec, Native, Public)

void UOrionCheatManagerGame::WhyItemsBroke()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "WhyItemsBroke");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.WhyStuck
// (Final, Exec, Native, Public)

void UOrionCheatManagerGame::WhyStuck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "WhyStuck");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.WhyTargetingBroken
// (Final, Exec, Native, Public)
// Parameters:
// float                                   DebugDuration                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::WhyTargetingBroken(float DebugDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "WhyTargetingBroken");

	Params::OrionCheatManagerGame_WhyTargetingBroken Parms{};

	Parms.DebugDuration = DebugDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCheatManagerGame.WTF
// (Exec, Native, Public)
// Parameters:
// int32                                   Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCheatManagerGame::WTF(int32 Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCheatManagerGame", "WTF");

	Params::OrionCheatManagerGame_WTF Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAmbientEventScheduler_MOBA.FireIntroEventCues
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AOrionCharHero*                   LocalHero                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionAmbientEventScheduler_MOBA::FireIntroEventCues(class AOrionCharHero* LocalHero)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionAmbientEventScheduler_MOBA", "FireIntroEventCues");

	Params::OrionAmbientEventScheduler_MOBA_FireIntroEventCues Parms{};

	Parms.LocalHero = LocalHero;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAnalytics.FireEvent_InitialLoadComplete
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      UserContext                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAnalytics::FireEvent_InitialLoadComplete(class UUserWidget* UserContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAnalytics", "FireEvent_InitialLoadComplete");

	Params::OrionAnalytics_FireEvent_InitialLoadComplete Parms{};

	Parms.UserContext = UserContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionAnalytics.FireEvent_ModifiedSettings
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      UserContext                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionGameUserSettings*           UserSettings                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionAnalytics::FireEvent_ModifiedSettings(class UUserWidget* UserContext, const class UOrionGameUserSettings* UserSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionAnalytics", "FireEvent_ModifiedSettings");

	Params::OrionAnalytics_FireEvent_ModifiedSettings Parms{};

	Parms.UserContext = UserContext;
	Parms.UserSettings = UserSettings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharHero.ApplySkinToMesh
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           MeshToApplySkinTo                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionSkinVariationItemDefinition*SkinVariation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharHero::ApplySkinToMesh(class USkeletalMeshComponent* MeshToApplySkinTo, const class UOrionSkinVariationItemDefinition* SkinVariation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "ApplySkinToMesh");

	Params::OrionCharHero_ApplySkinToMesh Parms{};

	Parms.MeshToApplySkinTo = MeshToApplySkinTo;
	Parms.SkinVariation = SkinVariation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharHero.DrawReticle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FOrion2DReticle                  ReticleMaterial                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)

void AOrionCharHero::DrawReticle(const struct FOrion2DReticle& ReticleMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "DrawReticle");

	Params::OrionCharHero_DrawReticle Parms{};

	Parms.ReticleMaterial = std::move(ReticleMaterial);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharHero.DrawReticle_Setup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCanvas*                          Canvas                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOrionUI_Base*                    CallingUI                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharHero::DrawReticle_Setup(class UCanvas* Canvas, class AOrionUI_Base* CallingUI)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "DrawReticle_Setup");

	Params::OrionCharHero_DrawReticle_Setup Parms{};

	Parms.Canvas = Canvas;
	Parms.CallingUI = CallingUI;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharHero.DrawReticleByIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReticleIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharHero::DrawReticleByIndex(int32 ReticleIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "DrawReticleByIndex");

	Params::OrionCharHero_DrawReticleByIndex Parms{};

	Parms.ReticleIndex = ReticleIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharHero.GameplayCue_Damage
// (Final, Native, Public)
// Parameters:
// EGameplayCueEvent                       EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Parameters                                             (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AOrionCharHero::GameplayCue_Damage(EGameplayCueEvent EventType, const struct FGameplayCueParameters& Parameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "GameplayCue_Damage");

	Params::OrionCharHero_GameplayCue_Damage Parms{};

	Parms.EventType = EventType;
	Parms.Parameters = std::move(Parameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharHero.GetCurrentCrown
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UOrionMcpCrownItemDefinition*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionMcpCrownItemDefinition* AOrionCharHero::GetCurrentCrown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "GetCurrentCrown");

	Params::OrionCharHero_GetCurrentCrown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharHero.GetCurrentSkin
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UOrionSkinItemDefinition*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionSkinItemDefinition* AOrionCharHero::GetCurrentSkin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "GetCurrentSkin");

	Params::OrionCharHero_GetCurrentSkin Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharHero.GetCurrentSkinVariation
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UOrionSkinVariationItemDefinition*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionSkinVariationItemDefinition* AOrionCharHero::GetCurrentSkinVariation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "GetCurrentSkinVariation");

	Params::OrionCharHero_GetCurrentSkinVariation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharHero.GetDecalAttachmentBone
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FName                             DecalName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Out_AttachmentBoneName                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharHero::GetDecalAttachmentBone(class FName DecalName, class FName* Out_AttachmentBoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "GetDecalAttachmentBone");

	Params::OrionCharHero_GetDecalAttachmentBone Parms{};

	Parms.DecalName = DecalName;

	UObject::ProcessEvent(Func, &Parms);

	if (Out_AttachmentBoneName != nullptr)
		*Out_AttachmentBoneName = Parms.Out_AttachmentBoneName;
}


// Function OrionGame.OrionCharHero.GetDecalFudgeFactor
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class FName                             DecalName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Out_FudgeFactorScaleVec                                (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharHero::GetDecalFudgeFactor(class FName DecalName, struct FVector* Out_FudgeFactorScaleVec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "GetDecalFudgeFactor");

	Params::OrionCharHero_GetDecalFudgeFactor Parms{};

	Parms.DecalName = DecalName;

	UObject::ProcessEvent(Func, &Parms);

	if (Out_FudgeFactorScaleVec != nullptr)
		*Out_FudgeFactorScaleVec = std::move(Parms.Out_FudgeFactorScaleVec);
}


// Function OrionGame.OrionCharHero.GetLerpedRewindData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   AlphaFactor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TotalSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGetTweenedValueOnInitialTime                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutTotalAmountMoved                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRecordedIntervalsData           ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FRecordedIntervalsData AOrionCharHero::GetLerpedRewindData(float AlphaFactor, float TotalSeconds, bool bGetTweenedValueOnInitialTime, float* OutTotalAmountMoved)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "GetLerpedRewindData");

	Params::OrionCharHero_GetLerpedRewindData Parms{};

	Parms.AlphaFactor = AlphaFactor;
	Parms.TotalSeconds = TotalSeconds;
	Parms.bGetTweenedValueOnInitialTime = bGetTweenedValueOnInitialTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTotalAmountMoved != nullptr)
		*OutTotalAmountMoved = Parms.OutTotalAmountMoved;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharHero.GetRewindData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NumSeconds                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGetTweenedValues                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRecordedIntervalsData           ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FRecordedIntervalsData AOrionCharHero::GetRewindData(float NumSeconds, bool bGetTweenedValues)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "GetRewindData");

	Params::OrionCharHero_GetRewindData Parms{};

	Parms.NumSeconds = NumSeconds;
	Parms.bGetTweenedValues = bGetTweenedValues;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharHero.GetRewindPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   NumSeconds                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGetTweenedValues                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AOrionCharHero::GetRewindPosition(float NumSeconds, bool bGetTweenedValues)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "GetRewindPosition");

	Params::OrionCharHero_GetRewindPosition Parms{};

	Parms.NumSeconds = NumSeconds;
	Parms.bGetTweenedValues = bGetTweenedValues;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharHero.HeroMovementUpdated
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OldLocation                                            (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OldVelocity                                            (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharHero::HeroMovementUpdated(float DeltaSeconds, const struct FVector& OldLocation, const struct FVector& OldVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "HeroMovementUpdated");

	Params::OrionCharHero_HeroMovementUpdated Parms{};

	Parms.DeltaSeconds = DeltaSeconds;
	Parms.OldLocation = std::move(OldLocation);
	Parms.OldVelocity = std::move(OldVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharHero.HideReticle
// (Final, Native, Public, BlueprintCallable)

void AOrionCharHero::HideReticle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "HideReticle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharHero.OnCrownReady
// (Event, Public, BlueprintEvent)

void AOrionCharHero::OnCrownReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "OnCrownReady");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionCharHero.OnDeathAnimFinished
// (Final, Native, Private)

void AOrionCharHero::OnDeathAnimFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "OnDeathAnimFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharHero.OnDeathMaterialFadeTick
// (Final, Native, Private)

void AOrionCharHero::OnDeathMaterialFadeTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "OnDeathMaterialFadeTick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharHero.OnMeshReady
// (Event, Public, BlueprintEvent)

void AOrionCharHero::OnMeshReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "OnMeshReady");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionCharHero.OnRep_CurrentSkinChoices
// (Final, Native, Protected)

void AOrionCharHero::OnRep_CurrentSkinChoices()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "OnRep_CurrentSkinChoices");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharHero.OnRep_DeathData
// (Final, Native, Private)

void AOrionCharHero::OnRep_DeathData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "OnRep_DeathData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharHero.OnRep_OrionReplicatedAcceleration
// (Final, Native, Public)

void AOrionCharHero::OnRep_OrionReplicatedAcceleration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "OnRep_OrionReplicatedAcceleration");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharHero.OnRep_StatusInfo
// (Native, Public)

void AOrionCharHero::OnRep_StatusInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "OnRep_StatusInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharHero.OnRep_UseFixedSkeletalBounds
// (Final, Native, Public)

void AOrionCharHero::OnRep_UseFixedSkeletalBounds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "OnRep_UseFixedSkeletalBounds");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharHero.RequestServerRewind
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                                   NumSeconds                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharHero::RequestServerRewind(float NumSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "RequestServerRewind");

	Params::OrionCharHero_RequestServerRewind Parms{};

	Parms.NumSeconds = NumSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharHero.ReticleMaterialTick
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UCanvas*                          Canvas                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOrionUI_Base*                    CallingUI                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharHero::ReticleMaterialTick(class UCanvas* Canvas, class AOrionUI_Base* CallingUI)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "ReticleMaterialTick");

	Params::OrionCharHero_ReticleMaterialTick Parms{};

	Parms.Canvas = Canvas;
	Parms.CallingUI = CallingUI;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharHero.SetSkipNextLandingGC
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSkip                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharHero::SetSkipNextLandingGC(bool bSkip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "SetSkipNextLandingGC");

	Params::OrionCharHero_SetSkipNextLandingGC Parms{};

	Parms.bSkip = bSkip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharHero.ShowReticle
// (Final, Native, Public, BlueprintCallable)

void AOrionCharHero::ShowReticle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "ShowReticle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharHero.SpawnDefaultTargetActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AGameplayAbilityTargetActor*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGameplayAbilityTargetActor* AOrionCharHero::SpawnDefaultTargetActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "SpawnDefaultTargetActor");

	Params::OrionCharHero_SpawnDefaultTargetActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharHero.TestActivateBanner
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bUseRandomProto                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseDefaultProto                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionCharHero::TestActivateBanner(bool bUseRandomProto, bool bUseDefaultProto)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "TestActivateBanner");

	Params::OrionCharHero_TestActivateBanner Parms{};

	Parms.bUseRandomProto = bUseRandomProto;
	Parms.bUseDefaultProto = bUseDefaultProto;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharHero.TestActivateGraveMarker
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bForEnemy                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionCharHero::TestActivateGraveMarker(bool bForEnemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "TestActivateGraveMarker");

	Params::OrionCharHero_TestActivateGraveMarker Parms{};

	Parms.bForEnemy = bForEnemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharHero.UpdateDamageInstigatedTime
// (Net, Native, Event, Public, NetClient)

void AOrionCharHero::UpdateDamageInstigatedTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "UpdateDamageInstigatedTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharHero.GetBaseAimLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AOrionCharHero::GetBaseAimLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "GetBaseAimLocation");

	Params::OrionCharHero_GetBaseAimLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharHero.GetEnergy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionCharHero::GetEnergy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "GetEnergy");

	Params::OrionCharHero_GetEnergy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharHero.GetEnergyPercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionCharHero::GetEnergyPercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "GetEnergyPercent");

	Params::OrionCharHero_GetEnergyPercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharHero.GetEnergyRegen
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionCharHero::GetEnergyRegen() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "GetEnergyRegen");

	Params::OrionCharHero_GetEnergyRegen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharHero.GetMaxEnergy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionCharHero::GetMaxEnergy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "GetMaxEnergy");

	Params::OrionCharHero_GetMaxEnergy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharHero.IsDecoy
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionCharHero::IsDecoy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero", "IsDecoy");

	Params::OrionCharHero_IsDecoy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharHero_Decoy.GetHighlightableMeshes
// (Event, Public, BlueprintEvent)
// Parameters:
// TArray<class UMeshComponent*>           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UMeshComponent*> AOrionCharHero_Decoy::GetHighlightableMeshes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero_Decoy", "GetHighlightableMeshes");

	Params::OrionCharHero_Decoy_GetHighlightableMeshes Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharHero_Decoy.OnRep_OrionCharHeroSpawner
// (Native, Public)

void AOrionCharHero_Decoy::OnRep_OrionCharHeroSpawner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero_Decoy", "OnRep_OrionCharHeroSpawner");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharHero_Decoy.OnRep_StatusInfo
// (Native, Public)

void AOrionCharHero_Decoy::OnRep_StatusInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero_Decoy", "OnRep_StatusInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharHero_Decoy.IsDecoy
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionCharHero_Decoy::IsDecoy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharHero_Decoy", "IsDecoy");

	Params::OrionCharHero_Decoy_IsDecoy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionObjectiveCapturePoint.OnCaptureHandle
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FOrionObjectivesToCapture        CapturedObjectiveData                                  (Parm, NativeAccessSpecifierPublic)

void AOrionObjectiveCapturePoint::OnCaptureHandle(const struct FOrionObjectivesToCapture& CapturedObjectiveData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionObjectiveCapturePoint", "OnCaptureHandle");

	Params::OrionObjectiveCapturePoint_OnCaptureHandle Parms{};

	Parms.CapturedObjectiveData = std::move(CapturedObjectiveData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionObjectiveCapturePoint.OnManuallyHandleCapture
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionTeam                              OtherActorTeamNum                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FOrionObjectivesToCapture        CapturedObjectiveData                                  (Parm, NativeAccessSpecifierPublic)

void AOrionObjectiveCapturePoint::OnManuallyHandleCapture(class AActor* OtherActor, EOrionTeam OtherActorTeamNum, const struct FOrionObjectivesToCapture& CapturedObjectiveData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionObjectiveCapturePoint", "OnManuallyHandleCapture");

	Params::OrionObjectiveCapturePoint_OnManuallyHandleCapture Parms{};

	Parms.OtherActor = OtherActor;
	Parms.OtherActorTeamNum = OtherActorTeamNum;
	Parms.CapturedObjectiveData = std::move(CapturedObjectiveData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionObjectiveCapturePoint.OnObjectiveCaptured
// (Event, Protected, BlueprintEvent)

void AOrionObjectiveCapturePoint::OnObjectiveCaptured()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionObjectiveCapturePoint", "OnObjectiveCaptured");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionObjectiveCapturePoint.OnOverlapBegin
// (Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AOrionObjectiveCapturePoint::OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionObjectiveCapturePoint", "OnOverlapBegin");

	Params::OrionObjectiveCapturePoint_OnOverlapBegin Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction OrionGame.OrionMcpItem.OnOrionMcpItemAttributeChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UOrionMcpItem::OnOrionMcpItemAttributeChanged__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpItem", "OnOrionMcpItemAttributeChanged__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionMcpItem.GetDescription
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UOrionMcpItem::GetDescription() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpItem", "GetDescription");

	Params::OrionMcpItem_GetDescription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionMcpItem.GetDisplayName
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UOrionMcpItem::GetDisplayName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpItem", "GetDisplayName");

	Params::OrionMcpItem_GetDisplayName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionMcpItem.GetNumInStack
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOrionMcpItem::GetNumInStack() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpItem", "GetNumInStack");

	Params::OrionMcpItem_GetNumInStack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionMcpItem.GetType
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionItemType                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOrionItemType UOrionMcpItem::GetType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpItem", "GetType");

	Params::OrionMcpItem_GetType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionMcpSkinVariationItem.GetInternalData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UOrionSkinVariationItemDefinition*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionSkinVariationItemDefinition* UOrionMcpSkinVariationItem::GetInternalData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpSkinVariationItem", "GetInternalData");

	Params::OrionMcpSkinVariationItem_GetInternalData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionArcadeLadderSetupData.GetHeroIcon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UOrionArcadeLadderSetupData::GetHeroIcon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionArcadeLadderSetupData", "GetHeroIcon");

	Params::OrionArcadeLadderSetupData_GetHeroIcon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionArcadeLadderSetupData.GetHeroName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UOrionArcadeLadderSetupData::GetHeroName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionArcadeLadderSetupData", "GetHeroName");

	Params::OrionArcadeLadderSetupData_GetHeroName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionBanner.ActivateBanner
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          EndPos                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         TargetRot                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBannerEntrance                         BannerEntranceType                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionBanner::ActivateBanner(const struct FVector& EndPos, const struct FRotator& TargetRot, const float& Scale, const EBannerEntrance& BannerEntranceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBanner", "ActivateBanner");

	Params::OrionBanner_ActivateBanner Parms{};

	Parms.EndPos = std::move(EndPos);
	Parms.TargetRot = std::move(TargetRot);
	Parms.Scale = Scale;
	Parms.BannerEntranceType = BannerEntranceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionBanner.ActivateTestBanner
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          InSpawnLocation                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         InSpawnRotation                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InSpawnScale                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionBanner::ActivateTestBanner(const struct FVector& InSpawnLocation, const struct FRotator& InSpawnRotation, const float& InSpawnScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBanner", "ActivateTestBanner");

	Params::OrionBanner_ActivateTestBanner Parms{};

	Parms.InSpawnLocation = std::move(InSpawnLocation);
	Parms.InSpawnRotation = std::move(InSpawnRotation);
	Parms.InSpawnScale = InSpawnScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionBanner.AddGameplayCueLocal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     GameplayCueTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Parameters                                             (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AOrionBanner::AddGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Parameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBanner", "AddGameplayCueLocal");

	Params::OrionBanner_AddGameplayCueLocal Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.Parameters = std::move(Parameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBanner.BannerLanded
// (Event, Public, BlueprintEvent)

void AOrionBanner::BannerLanded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBanner", "BannerLanded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionBanner.ExecuteGameplayCueLocal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     GameplayCueTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Parameters                                             (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AOrionBanner::ExecuteGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Parameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBanner", "ExecuteGameplayCueLocal");

	Params::OrionBanner_ExecuteGameplayCueLocal Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.Parameters = std::move(Parameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBanner.OnBannerLanded
// (Final, Native, Protected)

void AOrionBanner::OnBannerLanded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBanner", "OnBannerLanded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBanner.OnRep_BannerActivation
// (Final, Native, Protected)

void AOrionBanner::OnRep_BannerActivation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBanner", "OnRep_BannerActivation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBanner.RemoveAndFadeBannerNow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InFadeTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionBanner::RemoveAndFadeBannerNow(float InFadeTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBanner", "RemoveAndFadeBannerNow");

	Params::OrionBanner_RemoveAndFadeBannerNow Parms{};

	Parms.InFadeTime = InFadeTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBanner.RemoveGameplayCueLocal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     GameplayCueTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Parameters                                             (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AOrionBanner::RemoveGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Parameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBanner", "RemoveGameplayCueLocal");

	Params::OrionBanner_RemoveGameplayCueLocal Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.Parameters = std::move(Parameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBaseButton.BP_OnClicked
// (Event, Protected, BlueprintEvent)

void UOrionBaseButton::BP_OnClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseButton", "BP_OnClicked");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionBaseButton.BP_OnDeselected
// (Event, Protected, BlueprintEvent)

void UOrionBaseButton::BP_OnDeselected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseButton", "BP_OnDeselected");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionBaseButton.BP_OnDisabled
// (Event, Protected, BlueprintEvent)

void UOrionBaseButton::BP_OnDisabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseButton", "BP_OnDisabled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionBaseButton.BP_OnEnabled
// (Event, Protected, BlueprintEvent)

void UOrionBaseButton::BP_OnEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseButton", "BP_OnEnabled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionBaseButton.BP_OnHovered
// (Event, Protected, BlueprintEvent)

void UOrionBaseButton::BP_OnHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseButton", "BP_OnHovered");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionBaseButton.BP_OnSelected
// (Event, Protected, BlueprintEvent)

void UOrionBaseButton::BP_OnSelected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseButton", "BP_OnSelected");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionBaseButton.BP_OnUnhovered
// (Event, Protected, BlueprintEvent)

void UOrionBaseButton::BP_OnUnhovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseButton", "BP_OnUnhovered");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionBaseButton.ClearSelection
// (Final, Native, Public, BlueprintCallable)

void UOrionBaseButton::ClearSelection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseButton", "ClearSelection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBaseButton.DisableButton
// (Final, Native, Public, BlueprintCallable)

void UOrionBaseButton::DisableButton()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseButton", "DisableButton");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBaseButton.DisableButtonWithReason
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             DisabledReason                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOrionBaseButton::DisableButtonWithReason(const class FText& DisabledReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseButton", "DisableButtonWithReason");

	Params::OrionBaseButton_DisableButtonWithReason Parms{};

	Parms.DisabledReason = std::move(DisabledReason);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBaseButton.EnableButton
// (Final, Native, Public, BlueprintCallable)

void UOrionBaseButton::EnableButton()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseButton", "EnableButton");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBaseButton.HandleButtonClicked
// (Final, Native, Protected)

void UOrionBaseButton::HandleButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseButton", "HandleButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBaseButton.OnStyleSizeChanged
// (Event, Protected, BlueprintEvent)

void UOrionBaseButton::OnStyleSizeChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseButton", "OnStyleSizeChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionBaseButton.SetIsSelectable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInIsSelectable                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionBaseButton::SetIsSelectable(bool bInIsSelectable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseButton", "SetIsSelectable");

	Params::OrionBaseButton_SetIsSelectable Parms{};

	Parms.bInIsSelectable = bInIsSelectable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBaseButton.SetIsSelected
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InSelected                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromClick                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionBaseButton::SetIsSelected(bool InSelected, bool bFromClick)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseButton", "SetIsSelected");

	Params::OrionBaseButton_SetIsSelected Parms{};

	Parms.InSelected = InSelected;
	Parms.bFromClick = bFromClick;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBaseButton.SetMinDimensions
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InMinWidth                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InMinHeight                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionBaseButton::SetMinDimensions(int32 InMinWidth, int32 InMinHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseButton", "SetMinDimensions");

	Params::OrionBaseButton_SetMinDimensions Parms{};

	Parms.InMinWidth = InMinWidth;
	Parms.InMinHeight = InMinHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBaseButton.SetSelectedInternal
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bInSelected                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAllowSound                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBroadcast                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionBaseButton::SetSelectedInternal(bool bInSelected, bool bAllowSound, bool bBroadcast)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseButton", "SetSelectedInternal");

	Params::OrionBaseButton_SetSelectedInternal Parms{};

	Parms.bInSelected = bInSelected;
	Parms.bAllowSound = bAllowSound;
	Parms.bBroadcast = bBroadcast;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBaseButton.SetStyle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UOrionButtonStyle>    InStyle                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionBaseButton::SetStyle(TSubclassOf<class UOrionButtonStyle> InStyle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseButton", "SetStyle");

	Params::OrionBaseButton_SetStyle Parms{};

	Parms.InStyle = InStyle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBaseButton.SetStyleSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionWidgetStyleSize                   InSize                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionBaseButton::SetStyleSize(EOrionWidgetStyleSize InSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseButton", "SetStyleSize");

	Params::OrionBaseButton_SetStyleSize Parms{};

	Parms.InSize = InSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBaseButton.GetCurrentButtonPadding
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FMargin                          OutButtonPadding                                       (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UOrionBaseButton::GetCurrentButtonPadding(struct FMargin* OutButtonPadding) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseButton", "GetCurrentButtonPadding");

	Params::OrionBaseButton_GetCurrentButtonPadding Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutButtonPadding != nullptr)
		*OutButtonPadding = std::move(Parms.OutButtonPadding);
}


// Function OrionGame.OrionBaseButton.GetCurrentCustomPadding
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FMargin                          OutCustomPadding                                       (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UOrionBaseButton::GetCurrentCustomPadding(struct FMargin* OutCustomPadding) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseButton", "GetCurrentCustomPadding");

	Params::OrionBaseButton_GetCurrentCustomPadding Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCustomPadding != nullptr)
		*OutCustomPadding = std::move(Parms.OutCustomPadding);
}


// Function OrionGame.OrionBaseButton.GetCurrentTextStyle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UOrionTextStyle*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionTextStyle* UOrionBaseButton::GetCurrentTextStyle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseButton", "GetCurrentTextStyle");

	Params::OrionBaseButton_GetCurrentTextStyle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionBaseButton.GetCurrentTextStyleClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UOrionTextStyle>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UOrionTextStyle> UOrionBaseButton::GetCurrentTextStyleClass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseButton", "GetCurrentTextStyleClass");

	Params::OrionBaseButton_GetCurrentTextStyleClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionBaseButton.GetSelected
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionBaseButton::GetSelected() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseButton", "GetSelected");

	Params::OrionBaseButton_GetSelected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionBaseButton.GetStyle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UOrionButtonStyle*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionButtonStyle* UOrionBaseButton::GetStyle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseButton", "GetStyle");

	Params::OrionBaseButton_GetStyle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionBaseButton.IsHovered
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionBaseButton::IsHovered() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseButton", "IsHovered");

	Params::OrionBaseButton_IsHovered Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionBaseButton.IsInteractionEnabled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionBaseButton::IsInteractionEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseButton", "IsInteractionEnabled");

	Params::OrionBaseButton_IsInteractionEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionBaseButton.IsPressed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionBaseButton::IsPressed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBaseButton", "IsPressed");

	Params::OrionBaseButton_IsPressed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTooltipBase.Hide
// (Final, Native, Public, BlueprintCallable)

void UOrionTooltipBase::Hide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTooltipBase", "Hide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionTooltipBase.OnHide
// (Event, Protected, BlueprintEvent)

void UOrionTooltipBase::OnHide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTooltipBase", "OnHide");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionTooltipBase.OnShow
// (Event, Protected, BlueprintEvent)

void UOrionTooltipBase::OnShow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTooltipBase", "OnShow");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionTooltipBase.Show
// (Final, Native, Public, BlueprintCallable)

void UOrionTooltipBase::Show()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTooltipBase", "Show");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBotAbilityPicker.PickAbilityAgainstActor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AOrionAIBot*                      BotAI                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilitySpec             AbilitySpec                                            (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionBotAbilityPicker::PickAbilityAgainstActor(class AOrionAIBot* BotAI, class AActor* TargetActor, struct FGameplayAbilitySpec* AbilitySpec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionBotAbilityPicker", "PickAbilityAgainstActor");

	Params::OrionBotAbilityPicker_PickAbilityAgainstActor Parms{};

	Parms.BotAI = BotAI;
	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AbilitySpec != nullptr)
		*AbilitySpec = std::move(Parms.AbilitySpec);

	return Parms.ReturnValue;
}


// Function OrionGame.OrionBotAISpawner.HandleSpawnedAIDeath
// (Final, Native, Protected)
// Parameters:
// class AOrionChar*                       DeadChar                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      Killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionBotAISpawner::HandleSpawnedAIDeath(class AOrionChar* DeadChar, class AController* Killer, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBotAISpawner", "HandleSpawnedAIDeath");

	Params::OrionBotAISpawner_HandleSpawnedAIDeath Parms{};

	Parms.DeadChar = DeadChar;
	Parms.Killer = Killer;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerState_Game.CreatePlayerPathway
// (Final, BlueprintAuthorityOnly, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class AOrionTraversablePathway>OrionTraversablePathwayClass                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          StartingLocation                                       (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          EndingLocation                                         (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOrionCharHero*                   OptBreadCrumbActor                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOrionTraversablePathway*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOrionTraversablePathway* AOrionPlayerState_Game::CreatePlayerPathway(TSubclassOf<class AOrionTraversablePathway> OrionTraversablePathwayClass, const struct FVector& StartingLocation, const struct FVector& EndingLocation, class AOrionCharHero* OptBreadCrumbActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Game", "CreatePlayerPathway");

	Params::OrionPlayerState_Game_CreatePlayerPathway Parms{};

	Parms.OrionTraversablePathwayClass = OrionTraversablePathwayClass;
	Parms.StartingLocation = std::move(StartingLocation);
	Parms.EndingLocation = std::move(EndingLocation);
	Parms.OptBreadCrumbActor = OptBreadCrumbActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlayerState_Game.GetAttachedBuffs
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class AOrionCarriedObjective*>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AOrionCarriedObjective*> AOrionPlayerState_Game::GetAttachedBuffs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Game", "GetAttachedBuffs");

	Params::OrionPlayerState_Game_GetAttachedBuffs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlayerState_Game.GivePlayerCardActivationPoints
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   PointsEarned                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerState_Game::GivePlayerCardActivationPoints(int32 PointsEarned)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Game", "GivePlayerCardActivationPoints");

	Params::OrionPlayerState_Game_GivePlayerCardActivationPoints Parms{};

	Parms.PointsEarned = PointsEarned;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerState_Game.OnRep_AbilityPointsUnspent
// (Final, Native, Protected)

void AOrionPlayerState_Game::OnRep_AbilityPointsUnspent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Game", "OnRep_AbilityPointsUnspent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerState_Game.OnRep_CardActivationPointsMax
// (Final, Native, Protected)

void AOrionPlayerState_Game::OnRep_CardActivationPointsMax()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Game", "OnRep_CardActivationPointsMax");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerState_Game.OnRep_CardActivationPointsSpent
// (Final, Native, Protected)

void AOrionPlayerState_Game::OnRep_CardActivationPointsSpent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Game", "OnRep_CardActivationPointsSpent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerState_Game.OnRep_ClientDamageLog
// (Final, Native, Private)

void AOrionPlayerState_Game::OnRep_ClientDamageLog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Game", "OnRep_ClientDamageLog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerState_Game.OnRep_DidRejoin
// (Final, Native, Protected)

void AOrionPlayerState_Game::OnRep_DidRejoin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Game", "OnRep_DidRejoin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerState_Game.OnRep_IsUltimateReady
// (Final, Native, Protected)

void AOrionPlayerState_Game::OnRep_IsUltimateReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Game", "OnRep_IsUltimateReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerState_Game.OnRep_MultiKillTargets
// (Final, Native, Private)

void AOrionPlayerState_Game::OnRep_MultiKillTargets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Game", "OnRep_MultiKillTargets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerState_Game.OnRep_SurrenderVote
// (Final, Native, Protected)
// Parameters:
// ESurrenderVote                          OldVote                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerState_Game::OnRep_SurrenderVote(ESurrenderVote OldVote)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Game", "OnRep_SurrenderVote");

	Params::OrionPlayerState_Game_OnRep_SurrenderVote Parms{};

	Parms.OldVote = OldVote;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerState_Game.RequestServerPathWay
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults, NetValidate)
// Parameters:
// struct FVector                          SpawnLocation                                          (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         SpawnRotation                                          (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AOrionPlayerState_Game::RequestServerPathWay(const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Game", "RequestServerPathWay");

	Params::OrionPlayerState_Game_RequestServerPathWay Parms{};

	Parms.SpawnLocation = std::move(SpawnLocation);
	Parms.SpawnRotation = std::move(SpawnRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerState_Game.ServerAbilityLevelUp
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   InputID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerState_Game::ServerAbilityLevelUp(int32 InputID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Game", "ServerAbilityLevelUp");

	Params::OrionPlayerState_Game_ServerAbilityLevelUp Parms{};

	Parms.InputID = InputID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerState_Game.ServerTryToSetPlayerHeroDataSpecFromTeamSelection
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FOrionHeroDataSpec               InHeroDataSpec                                         (Parm, NativeAccessSpecifierPublic)

void AOrionPlayerState_Game::ServerTryToSetPlayerHeroDataSpecFromTeamSelection(const struct FOrionHeroDataSpec& InHeroDataSpec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Game", "ServerTryToSetPlayerHeroDataSpecFromTeamSelection");

	Params::OrionPlayerState_Game_ServerTryToSetPlayerHeroDataSpecFromTeamSelection Parms{};

	Parms.InHeroDataSpec = std::move(InHeroDataSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerState_Game.SetCardActivationPointsMax
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewMaxTotal                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerState_Game::SetCardActivationPointsMax(int32 NewMaxTotal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Game", "SetCardActivationPointsMax");

	Params::OrionPlayerState_Game_SetCardActivationPointsMax Parms{};

	Parms.NewMaxTotal = NewMaxTotal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerState_Game.TickRecorder
// (Final, Native, Public)

void AOrionPlayerState_Game::TickRecorder()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Game", "TickRecorder");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerState_Game.UpdateIsUltimateReady
// (Final, Native, Protected)

void AOrionPlayerState_Game::UpdateIsUltimateReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Game", "UpdateIsUltimateReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerState_Game.GetBotDifficultyLevelIndication
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAIBotDifficulty                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAIBotDifficulty AOrionPlayerState_Game::GetBotDifficultyLevelIndication() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Game", "GetBotDifficultyLevelIndication");

	Params::OrionPlayerState_Game_GetBotDifficultyLevelIndication Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlayerState_Game.GetCardActivationPointsLeft
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AOrionPlayerState_Game::GetCardActivationPointsLeft() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Game", "GetCardActivationPointsLeft");

	Params::OrionPlayerState_Game_GetCardActivationPointsLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlayerState_Game.GetCardActivationPointsMax
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AOrionPlayerState_Game::GetCardActivationPointsMax() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Game", "GetCardActivationPointsMax");

	Params::OrionPlayerState_Game_GetCardActivationPointsMax Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlayerState_Game.GetCardActivationPointsSpent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AOrionPlayerState_Game::GetCardActivationPointsSpent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Game", "GetCardActivationPointsSpent");

	Params::OrionPlayerState_Game_GetCardActivationPointsSpent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlayerState_Game.GetCurrentPawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AOrionChar*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOrionChar* AOrionPlayerState_Game::GetCurrentPawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Game", "GetCurrentPawn");

	Params::OrionPlayerState_Game_GetCurrentPawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlayerState_Game.GetSurrenderVote
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESurrenderVote                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESurrenderVote AOrionPlayerState_Game::GetSurrenderVote() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Game", "GetSurrenderVote");

	Params::OrionPlayerState_Game_GetSurrenderVote Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlayerState_Game.GetTimeLeftToRespawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionPlayerState_Game::GetTimeLeftToRespawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Game", "GetTimeLeftToRespawn");

	Params::OrionPlayerState_Game_GetTimeLeftToRespawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlayerState_Arcade.OnRoundState_PostRound
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)

void AOrionPlayerState_Arcade::OnRoundState_PostRound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Arcade", "OnRoundState_PostRound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionBTService_GetEnemy.ReceiveTick
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           OwnerActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionBTService_GetEnemy::ReceiveTick(class AActor* OwnerActor, float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBTService_GetEnemy", "ReceiveTick");

	Params::OrionBTService_GetEnemy_ReceiveTick Parms{};

	Parms.OwnerActor = OwnerActor;
	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionBTService_GetEnemy.ScoreTargetEnemy
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class AOrionAIController*               OwnerAIController                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Enemy                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOrionBTService_GetEnemy::ScoreTargetEnemy(class AOrionAIController* OwnerAIController, class AActor* Enemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionBTService_GetEnemy", "ScoreTargetEnemy");

	Params::OrionBTService_GetEnemy_ScoreTargetEnemy Parms{};

	Parms.OwnerAIController = OwnerAIController;
	Parms.Enemy = Enemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCameraComponent_DeathCam.SetAutoFollow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewAutoFollow                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCameraComponent_DeathCam::SetAutoFollow(bool bNewAutoFollow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCameraComponent_DeathCam", "SetAutoFollow");

	Params::OrionCameraComponent_DeathCam_SetAutoFollow Parms{};

	Parms.bNewAutoFollow = bNewAutoFollow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCameraComponent_DeathCam.SetLazyAutoFollow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewLazyAutoFollow                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCameraComponent_DeathCam::SetLazyAutoFollow(bool bNewLazyAutoFollow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCameraComponent_DeathCam", "SetLazyAutoFollow");

	Params::OrionCameraComponent_DeathCam_SetLazyAutoFollow Parms{};

	Parms.bNewLazyAutoFollow = bNewLazyAutoFollow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCardAbility.GetCardTargets
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayAbilityTargetDataHandleReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FGameplayAbilityTargetDataHandle UOrionCardAbility::GetCardTargets() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCardAbility", "GetCardTargets");

	Params::OrionCardAbility_GetCardTargets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCardAbility.WasTriggeredFromEvent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionCardAbility::WasTriggeredFromEvent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCardAbility", "WasTriggeredFromEvent");

	Params::OrionCardAbility_WasTriggeredFromEvent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCarriedObjectiveInterface.ObjectiveScored
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ScoringActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IOrionCarriedObjectiveInterface::ObjectiveScored(class AActor* ScoringActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCarriedObjectiveInterface", "ObjectiveScored");

	Params::OrionCarriedObjectiveInterface_ObjectiveScored Parms{};

	Parms.ScoringActor = ScoringActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionMinionAnimInstance.CancelBehavior
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionMinionPrioritizedBehavior         Behavior                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionMinionAnimInstance::CancelBehavior(EOrionMinionPrioritizedBehavior Behavior)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMinionAnimInstance", "CancelBehavior");

	Params::OrionMinionAnimInstance_CancelBehavior Parms{};

	Parms.Behavior = Behavior;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionMinionAnimInstance.RequestBehavior
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionMinionPrioritizedBehavior         Behavior                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLooping                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionMinionAnimInstance::RequestBehavior(EOrionMinionPrioritizedBehavior Behavior, int32 PlayIndex, bool bLooping)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMinionAnimInstance", "RequestBehavior");

	Params::OrionMinionAnimInstance_RequestBehavior Parms{};

	Parms.Behavior = Behavior;
	Parms.PlayIndex = PlayIndex;
	Parms.bLooping = bLooping;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAI_JungleBoss.EnableIndicators
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void AOrionCharAI_JungleBoss::EnableIndicators()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAI_JungleBoss", "EnableIndicators");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAI_JungleBoss.HandleCallForHelp
// (Final, Native, Private, HasOutParams)
// Parameters:
// class AActor*                           DamagedActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AttackingActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectSpec              EffectSpec                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AOrionCharAI_JungleBoss::HandleCallForHelp(class AActor* DamagedActor, class AActor* AttackingActor, const struct FGameplayEffectSpec& EffectSpec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAI_JungleBoss", "HandleCallForHelp");

	Params::OrionCharAI_JungleBoss_HandleCallForHelp Parms{};

	Parms.DamagedActor = DamagedActor;
	Parms.AttackingActor = AttackingActor;
	Parms.EffectSpec = std::move(EffectSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAI_JungleBoss.MarkFailedAttackAttempt
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void AOrionCharAI_JungleBoss::MarkFailedAttackAttempt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAI_JungleBoss", "MarkFailedAttackAttempt");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAI_JungleBoss.OnRep_PackedAnimRequest
// (Final, Native, Protected)

void AOrionCharAI_JungleBoss::OnRep_PackedAnimRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAI_JungleBoss", "OnRep_PackedAnimRequest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAI_JungleBoss.PlayExpandingKnockback
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UGameplayEffect>      AppliedEffect                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RadiusStart                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RadiusEnd                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ExpansionTime                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharAI_JungleBoss::PlayExpandingKnockback(TSubclassOf<class UGameplayEffect> AppliedEffect, float RadiusStart, float RadiusEnd, float ExpansionTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAI_JungleBoss", "PlayExpandingKnockback");

	Params::OrionCharAI_JungleBoss_PlayExpandingKnockback Parms{};

	Parms.AppliedEffect = AppliedEffect;
	Parms.RadiusStart = RadiusStart;
	Parms.RadiusEnd = RadiusEnd;
	Parms.ExpansionTime = ExpansionTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAI_JungleBoss.PlaySpawningAbility
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void AOrionCharAI_JungleBoss::PlaySpawningAbility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAI_JungleBoss", "PlaySpawningAbility");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAI_JungleBoss.RequestReplicatedAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionMinionPrioritizedBehavior         Animation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AttackId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharAI_JungleBoss::RequestReplicatedAnimation(EOrionMinionPrioritizedBehavior Animation, int32 AttackId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAI_JungleBoss", "RequestReplicatedAnimation");

	Params::OrionCharAI_JungleBoss_RequestReplicatedAnimation Parms{};

	Parms.Animation = Animation;
	Parms.AttackId = AttackId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAI_JungleBoss.SetDependency
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FObjectiveDependency             Dependecy                                              (Parm, NativeAccessSpecifierPublic)

void AOrionCharAI_JungleBoss::SetDependency(const struct FObjectiveDependency& Dependecy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAI_JungleBoss", "SetDependency");

	Params::OrionCharAI_JungleBoss_SetDependency Parms{};

	Parms.Dependecy = std::move(Dependecy);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAI_JungleBoss.GetBestTarget
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionJungleTarget                      Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOrionChar*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOrionChar* AOrionCharAI_JungleBoss::GetBestTarget(EOrionJungleTarget Mode) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAI_JungleBoss", "GetBestTarget");

	Params::OrionCharAI_JungleBoss_GetBestTarget Parms{};

	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharAI_JungleBoss.GetCurrentTarget
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AOrionChar*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOrionChar* AOrionCharAI_JungleBoss::GetCurrentTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAI_JungleBoss", "GetCurrentTarget");

	Params::OrionCharAI_JungleBoss_GetCurrentTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharAI_JungleBoss.HasFinishedSpawning
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionCharAI_JungleBoss::HasFinishedSpawning() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAI_JungleBoss", "HasFinishedSpawning");

	Params::OrionCharAI_JungleBoss_HasFinishedSpawning Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharAI_PrimeHelixOld.OnRep_AttackAnimRequest
// (Final, Native, Protected)

void AOrionCharAI_PrimeHelixOld::OnRep_AttackAnimRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAI_PrimeHelixOld", "OnRep_AttackAnimRequest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAI_PrimeHelixOld.PlayExpandingKnockback
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void AOrionCharAI_PrimeHelixOld::PlayExpandingKnockback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAI_PrimeHelixOld", "PlayExpandingKnockback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAI_PrimeHelixOld.RequestReplicatedAttackAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SpecialAttackId                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCharAI_PrimeHelixOld::RequestReplicatedAttackAnimation(int32 SpecialAttackId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAI_PrimeHelixOld", "RequestReplicatedAttackAnimation");

	Params::OrionCharAI_PrimeHelixOld_RequestReplicatedAttackAnimation Parms{};

	Parms.SpecialAttackId = SpecialAttackId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAI_PrimeHelixOld.SpawnPrimeBuff
// (Final, Native, Public)

void AOrionCharAI_PrimeHelixOld::SpawnPrimeBuff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAI_PrimeHelixOld", "SpawnPrimeBuff");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharAI_PrimeHelixOld.GetConeAttackLocations
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FVector>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVector> AOrionCharAI_PrimeHelixOld::GetConeAttackLocations() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharAI_PrimeHelixOld", "GetConeAttackLocations");

	Params::OrionCharAI_PrimeHelixOld_GetConeAttackLocations Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharMovementComponent.ApplyKnockback
// (Final, BlueprintAuthorityOnly, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Direction                                              (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceXY                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCharMovementComponent::ApplyKnockback(const struct FVector& Direction, float DistanceXY)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharMovementComponent", "ApplyKnockback");

	Params::OrionCharMovementComponent_ApplyKnockback Parms{};

	Parms.Direction = std::move(Direction);
	Parms.DistanceXY = DistanceXY;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharMovementComponent.ApplyKnockup
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCharMovementComponent::ApplyKnockup(float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharMovementComponent", "ApplyKnockup");

	Params::OrionCharMovementComponent_ApplyKnockup Parms{};

	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharMovementComponent.BeginHover
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECharHoverMovement                      InHoverMovementType                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDesiredHeightOffFloor                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InInitialZOffsetMinimum                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InUpwardStrength                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InUpwardMaxSpeed                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDownwardStrength                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDownwardMaxSpeed                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InHoverTraceDistance                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTraceResultNormalZThreshold                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInDisplayDebug                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCharMovementComponent::BeginHover(ECharHoverMovement InHoverMovementType, float InDesiredHeightOffFloor, float InInitialZOffsetMinimum, float InUpwardStrength, float InUpwardMaxSpeed, float InDownwardStrength, float InDownwardMaxSpeed, float InHoverTraceDistance, float InTraceResultNormalZThreshold, bool bInDisplayDebug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharMovementComponent", "BeginHover");

	Params::OrionCharMovementComponent_BeginHover Parms{};

	Parms.InHoverMovementType = InHoverMovementType;
	Parms.InDesiredHeightOffFloor = InDesiredHeightOffFloor;
	Parms.InInitialZOffsetMinimum = InInitialZOffsetMinimum;
	Parms.InUpwardStrength = InUpwardStrength;
	Parms.InUpwardMaxSpeed = InUpwardMaxSpeed;
	Parms.InDownwardStrength = InDownwardStrength;
	Parms.InDownwardMaxSpeed = InDownwardMaxSpeed;
	Parms.InHoverTraceDistance = InHoverTraceDistance;
	Parms.InTraceResultNormalZThreshold = InTraceResultNormalZThreshold;
	Parms.bInDisplayDebug = bInDisplayDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharMovementComponent.EndHover
// (Final, Native, Public, BlueprintCallable)

void UOrionCharMovementComponent::EndHover()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharMovementComponent", "EndHover");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharMovementComponent.GetHover_bDisplayDebug
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionCharMovementComponent::GetHover_bDisplayDebug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharMovementComponent", "GetHover_bDisplayDebug");

	Params::OrionCharMovementComponent_GetHover_bDisplayDebug Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharMovementComponent.GetHover_DesiredHeightOffFloor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOrionCharMovementComponent::GetHover_DesiredHeightOffFloor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharMovementComponent", "GetHover_DesiredHeightOffFloor");

	Params::OrionCharMovementComponent_GetHover_DesiredHeightOffFloor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharMovementComponent.GetHover_DownwardMaxSpeed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOrionCharMovementComponent::GetHover_DownwardMaxSpeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharMovementComponent", "GetHover_DownwardMaxSpeed");

	Params::OrionCharMovementComponent_GetHover_DownwardMaxSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharMovementComponent.GetHover_DownwardStrength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOrionCharMovementComponent::GetHover_DownwardStrength()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharMovementComponent", "GetHover_DownwardStrength");

	Params::OrionCharMovementComponent_GetHover_DownwardStrength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharMovementComponent.GetHover_HoverTraceDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOrionCharMovementComponent::GetHover_HoverTraceDistance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharMovementComponent", "GetHover_HoverTraceDistance");

	Params::OrionCharMovementComponent_GetHover_HoverTraceDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharMovementComponent.GetHover_MovementType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECharHoverMovement                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECharHoverMovement UOrionCharMovementComponent::GetHover_MovementType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharMovementComponent", "GetHover_MovementType");

	Params::OrionCharMovementComponent_GetHover_MovementType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharMovementComponent.GetHover_TraceResultNormalZThreshold
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOrionCharMovementComponent::GetHover_TraceResultNormalZThreshold()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharMovementComponent", "GetHover_TraceResultNormalZThreshold");

	Params::OrionCharMovementComponent_GetHover_TraceResultNormalZThreshold Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharMovementComponent.GetHover_UpwardMaxSpeed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOrionCharMovementComponent::GetHover_UpwardMaxSpeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharMovementComponent", "GetHover_UpwardMaxSpeed");

	Params::OrionCharMovementComponent_GetHover_UpwardMaxSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharMovementComponent.GetHover_UpwardStrength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOrionCharMovementComponent::GetHover_UpwardStrength()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharMovementComponent", "GetHover_UpwardStrength");

	Params::OrionCharMovementComponent_GetHover_UpwardStrength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharMovementComponent.GetHover_VelocityLeadTimeStepMult
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOrionCharMovementComponent::GetHover_VelocityLeadTimeStepMult()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharMovementComponent", "GetHover_VelocityLeadTimeStepMult");

	Params::OrionCharMovementComponent_GetHover_VelocityLeadTimeStepMult Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCharMovementComponent.LaunchInDirection
// (Final, BlueprintAuthorityOnly, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Direction                                              (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LaunchVelocity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLockAirControl                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCharMovementComponent::LaunchInDirection(const struct FVector& Direction, float LaunchVelocity, bool bLockAirControl)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharMovementComponent", "LaunchInDirection");

	Params::OrionCharMovementComponent_LaunchInDirection Parms{};

	Parms.Direction = std::move(Direction);
	Parms.LaunchVelocity = LaunchVelocity;
	Parms.bLockAirControl = bLockAirControl;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharMovementComponent.LaunchInDirectionFromTargetData
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayAbilityTargetDataHandle TargetDataHandle                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   LaunchVelocity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLockAirControl                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCharMovementComponent::LaunchInDirectionFromTargetData(const struct FGameplayAbilityTargetDataHandle& TargetDataHandle, float LaunchVelocity, bool bLockAirControl)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharMovementComponent", "LaunchInDirectionFromTargetData");

	Params::OrionCharMovementComponent_LaunchInDirectionFromTargetData Parms{};

	Parms.TargetDataHandle = std::move(TargetDataHandle);
	Parms.LaunchVelocity = LaunchVelocity;
	Parms.bLockAirControl = bLockAirControl;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharMovementComponent.LaunchToPoint
// (Final, BlueprintAuthorityOnly, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          EndPoint                                               (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LaunchVelocityXY                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLockAirControl                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCharMovementComponent::LaunchToPoint(const struct FVector& EndPoint, float LaunchVelocityXY, bool bLockAirControl)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharMovementComponent", "LaunchToPoint");

	Params::OrionCharMovementComponent_LaunchToPoint Parms{};

	Parms.EndPoint = std::move(EndPoint);
	Parms.LaunchVelocityXY = LaunchVelocityXY;
	Parms.bLockAirControl = bLockAirControl;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharMovementComponent.LaunchToPointFromTargetData
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayAbilityTargetDataHandle TargetDataHandle                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   LaunchVelocityXY                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLockAirControl                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCharMovementComponent::LaunchToPointFromTargetData(const struct FGameplayAbilityTargetDataHandle& TargetDataHandle, float LaunchVelocityXY, bool bLockAirControl)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharMovementComponent", "LaunchToPointFromTargetData");

	Params::OrionCharMovementComponent_LaunchToPointFromTargetData Parms{};

	Parms.TargetDataHandle = std::move(TargetDataHandle);
	Parms.LaunchVelocityXY = LaunchVelocityXY;
	Parms.bLockAirControl = bLockAirControl;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharMovementComponent.NudgeMovement
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ImpulseToAdd                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCharMovementComponent::NudgeMovement(const struct FVector& ImpulseToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharMovementComponent", "NudgeMovement");

	Params::OrionCharMovementComponent_NudgeMovement Parms{};

	Parms.ImpulseToAdd = std::move(ImpulseToAdd);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharMovementComponent.OrionServerMove
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                                   Timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize10            InAccel                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize100           ClientLoc                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// uint8                                   CompressedMoveFlags                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ClientRoll                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  View                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              ClientMovementBase                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ClientBaseBoneName                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ClientMovementMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMovementAbilitySyncKey          MovementAbilitySyncKey                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UOrionCharMovementComponent::OrionServerMove(float Timestamp, const struct FVector_NetQuantize10& InAccel, const struct FVector_NetQuantize100& ClientLoc, uint8 CompressedMoveFlags, uint8 ClientRoll, uint32 View, class UPrimitiveComponent* ClientMovementBase, class FName ClientBaseBoneName, uint8 ClientMovementMode, const struct FMovementAbilitySyncKey& MovementAbilitySyncKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharMovementComponent", "OrionServerMove");

	Params::OrionCharMovementComponent_OrionServerMove Parms{};

	Parms.Timestamp = Timestamp;
	Parms.InAccel = std::move(InAccel);
	Parms.ClientLoc = std::move(ClientLoc);
	Parms.CompressedMoveFlags = CompressedMoveFlags;
	Parms.ClientRoll = ClientRoll;
	Parms.View = View;
	Parms.ClientMovementBase = ClientMovementBase;
	Parms.ClientBaseBoneName = ClientBaseBoneName;
	Parms.ClientMovementMode = ClientMovementMode;
	Parms.MovementAbilitySyncKey = std::move(MovementAbilitySyncKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharMovementComponent.OrionServerMoveDual
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                                   TimeStamp0                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize10            InAccel0                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// uint8                                   PendingFlags                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  View0                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize10            InAccel                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize100           ClientLoc                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// uint8                                   NewFlags                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ClientRoll                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  View                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              ClientMovementBase                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ClientBaseBoneName                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ClientMovementMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMovementAbilitySyncKey          MovementAbilitySyncKey                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UOrionCharMovementComponent::OrionServerMoveDual(float TimeStamp0, const struct FVector_NetQuantize10& InAccel0, uint8 PendingFlags, uint32 View0, float Timestamp, const struct FVector_NetQuantize10& InAccel, const struct FVector_NetQuantize100& ClientLoc, uint8 NewFlags, uint8 ClientRoll, uint32 View, class UPrimitiveComponent* ClientMovementBase, class FName ClientBaseBoneName, uint8 ClientMovementMode, const struct FMovementAbilitySyncKey& MovementAbilitySyncKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharMovementComponent", "OrionServerMoveDual");

	Params::OrionCharMovementComponent_OrionServerMoveDual Parms{};

	Parms.TimeStamp0 = TimeStamp0;
	Parms.InAccel0 = std::move(InAccel0);
	Parms.PendingFlags = PendingFlags;
	Parms.View0 = View0;
	Parms.Timestamp = Timestamp;
	Parms.InAccel = std::move(InAccel);
	Parms.ClientLoc = std::move(ClientLoc);
	Parms.NewFlags = NewFlags;
	Parms.ClientRoll = ClientRoll;
	Parms.View = View;
	Parms.ClientMovementBase = ClientMovementBase;
	Parms.ClientBaseBoneName = ClientBaseBoneName;
	Parms.ClientMovementMode = ClientMovementMode;
	Parms.MovementAbilitySyncKey = std::move(MovementAbilitySyncKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharMovementComponent.OrionServerMoveDualHybridRootMotion
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                                   TimeStamp0                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize10            InAccel0                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// uint8                                   PendingFlags                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  View0                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize10            InAccel                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize100           ClientLoc                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// uint8                                   NewFlags                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ClientRoll                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  View                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              ClientMovementBase                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ClientBaseBoneName                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ClientMovementMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMovementAbilitySyncKey          MovementAbilitySyncKey                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UOrionCharMovementComponent::OrionServerMoveDualHybridRootMotion(float TimeStamp0, const struct FVector_NetQuantize10& InAccel0, uint8 PendingFlags, uint32 View0, float Timestamp, const struct FVector_NetQuantize10& InAccel, const struct FVector_NetQuantize100& ClientLoc, uint8 NewFlags, uint8 ClientRoll, uint32 View, class UPrimitiveComponent* ClientMovementBase, class FName ClientBaseBoneName, uint8 ClientMovementMode, const struct FMovementAbilitySyncKey& MovementAbilitySyncKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharMovementComponent", "OrionServerMoveDualHybridRootMotion");

	Params::OrionCharMovementComponent_OrionServerMoveDualHybridRootMotion Parms{};

	Parms.TimeStamp0 = TimeStamp0;
	Parms.InAccel0 = std::move(InAccel0);
	Parms.PendingFlags = PendingFlags;
	Parms.View0 = View0;
	Parms.Timestamp = Timestamp;
	Parms.InAccel = std::move(InAccel);
	Parms.ClientLoc = std::move(ClientLoc);
	Parms.NewFlags = NewFlags;
	Parms.ClientRoll = ClientRoll;
	Parms.View = View;
	Parms.ClientMovementBase = ClientMovementBase;
	Parms.ClientBaseBoneName = ClientBaseBoneName;
	Parms.ClientMovementMode = ClientMovementMode;
	Parms.MovementAbilitySyncKey = std::move(MovementAbilitySyncKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharMovementComponent.OrionServerMoveOld
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                                   OldTimeStamp                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize10            OldAccel                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// uint8                                   OldMoveFlags                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMovementAbilitySyncKey          MovementAbilitySyncKey                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UOrionCharMovementComponent::OrionServerMoveOld(float OldTimeStamp, const struct FVector_NetQuantize10& OldAccel, uint8 OldMoveFlags, const struct FMovementAbilitySyncKey& MovementAbilitySyncKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharMovementComponent", "OrionServerMoveOld");

	Params::OrionCharMovementComponent_OrionServerMoveOld Parms{};

	Parms.OldTimeStamp = OldTimeStamp;
	Parms.OldAccel = std::move(OldAccel);
	Parms.OldMoveFlags = OldMoveFlags;
	Parms.MovementAbilitySyncKey = std::move(MovementAbilitySyncKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharMovementComponent.SetHover_bDisplayDebug
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCharMovementComponent::SetHover_bDisplayDebug(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharMovementComponent", "SetHover_bDisplayDebug");

	Params::OrionCharMovementComponent_SetHover_bDisplayDebug Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharMovementComponent.SetHover_DesiredHeightOffFloor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   FValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCharMovementComponent::SetHover_DesiredHeightOffFloor(float FValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharMovementComponent", "SetHover_DesiredHeightOffFloor");

	Params::OrionCharMovementComponent_SetHover_DesiredHeightOffFloor Parms{};

	Parms.FValue = FValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharMovementComponent.SetHover_DownwardMaxSpeed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   FValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCharMovementComponent::SetHover_DownwardMaxSpeed(float FValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharMovementComponent", "SetHover_DownwardMaxSpeed");

	Params::OrionCharMovementComponent_SetHover_DownwardMaxSpeed Parms{};

	Parms.FValue = FValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharMovementComponent.SetHover_DownwardStrength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   FValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCharMovementComponent::SetHover_DownwardStrength(float FValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharMovementComponent", "SetHover_DownwardStrength");

	Params::OrionCharMovementComponent_SetHover_DownwardStrength Parms{};

	Parms.FValue = FValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharMovementComponent.SetHover_HoverTraceDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   FValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCharMovementComponent::SetHover_HoverTraceDistance(float FValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharMovementComponent", "SetHover_HoverTraceDistance");

	Params::OrionCharMovementComponent_SetHover_HoverTraceDistance Parms{};

	Parms.FValue = FValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharMovementComponent.SetHover_MovementType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECharHoverMovement                      Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCharMovementComponent::SetHover_MovementType(ECharHoverMovement Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharMovementComponent", "SetHover_MovementType");

	Params::OrionCharMovementComponent_SetHover_MovementType Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharMovementComponent.SetHover_TraceResultNormalZThreshold
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   FValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCharMovementComponent::SetHover_TraceResultNormalZThreshold(float FValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharMovementComponent", "SetHover_TraceResultNormalZThreshold");

	Params::OrionCharMovementComponent_SetHover_TraceResultNormalZThreshold Parms{};

	Parms.FValue = FValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharMovementComponent.SetHover_UpwardMaxSpeed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   FValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCharMovementComponent::SetHover_UpwardMaxSpeed(float FValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharMovementComponent", "SetHover_UpwardMaxSpeed");

	Params::OrionCharMovementComponent_SetHover_UpwardMaxSpeed Parms{};

	Parms.FValue = FValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharMovementComponent.SetHover_UpwardStrength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   FValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCharMovementComponent::SetHover_UpwardStrength(float FValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharMovementComponent", "SetHover_UpwardStrength");

	Params::OrionCharMovementComponent_SetHover_UpwardStrength Parms{};

	Parms.FValue = FValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharMovementComponent.SetHover_VelocityLeadTimeStepMult
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   FValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionCharMovementComponent::SetHover_VelocityLeadTimeStepMult(float FValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharMovementComponent", "SetHover_VelocityLeadTimeStepMult");

	Params::OrionCharMovementComponent_SetHover_VelocityLeadTimeStepMult Parms{};

	Parms.FValue = FValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCharMovementComponent.SimulateBasicFlight
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          StartPoint                                             (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Distance                                               (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxDistancePerIncrement                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxIncrements                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UOrionCharMovementComponent::SimulateBasicFlight(const struct FVector& StartPoint, const struct FVector& Distance, float MaxDistancePerIncrement, int32 MaxIncrements)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCharMovementComponent", "SimulateBasicFlight");

	Params::OrionCharMovementComponent_SimulateBasicFlight Parms{};

	Parms.StartPoint = std::move(StartPoint);
	Parms.Distance = std::move(Distance);
	Parms.MaxDistancePerIncrement = MaxDistancePerIncrement;
	Parms.MaxIncrements = MaxIncrements;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlayerController_Game.GetLocationRotationForSpawnActor
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AOrionPlayerController_Game*      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutLocation                                            (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         OutRotation                                            (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AOrionPlayerController_Game::GetLocationRotationForSpawnActor(class AOrionPlayerController_Game* PlayerController, struct FVector* OutLocation, struct FRotator* OutRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionPlayerController_Game", "GetLocationRotationForSpawnActor");

	Params::OrionPlayerController_Game_GetLocationRotationForSpawnActor Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocation != nullptr)
		*OutLocation = std::move(Parms.OutLocation);

	if (OutRotation != nullptr)
		*OutRotation = std::move(Parms.OutRotation);
}


// Function OrionGame.OrionPlayerController_Game.AbilityCancelPress
// (Final, RequiredAPI, Native, Public)

void AOrionPlayerController_Game::AbilityCancelPress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "AbilityCancelPress");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ActivateAbilityForPawnCheat
// (RequiredAPI, Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class AOrionChar*                       InChar                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionAbilityBinding                    InputID                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPressed                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Game::ActivateAbilityForPawnCheat(class AOrionChar* InChar, const EOrionAbilityBinding InputID, const bool bPressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ActivateAbilityForPawnCheat");

	Params::OrionPlayerController_Game_ActivateAbilityForPawnCheat Parms{};

	Parms.InChar = InChar;
	Parms.InputID = InputID;
	Parms.bPressed = bPressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ActivateAIAbility
// (RequiredAPI, Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class AOrionChar*                       InChar                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionAbilityBinding                    InputID                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Game::ActivateAIAbility(class AOrionChar* InChar, const EOrionAbilityBinding InputID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ActivateAIAbility");

	Params::OrionPlayerController_Game_ActivateAIAbility Parms{};

	Parms.InChar = InChar;
	Parms.InputID = InputID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.AddPawnMovementInput
// (RequiredAPI, Net, NetReliable, Native, Event, Public, NetServer, HasDefaults, NetValidate)
// Parameters:
// class AOrionChar*                       InChar                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldDirection                                         (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScaleValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForce                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Game::AddPawnMovementInput(class AOrionChar* InChar, const struct FVector& WorldDirection, float ScaleValue, bool bForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "AddPawnMovementInput");

	Params::OrionPlayerController_Game_AddPawnMovementInput Parms{};

	Parms.InChar = InChar;
	Parms.WorldDirection = std::move(WorldDirection);
	Parms.ScaleValue = ScaleValue;
	Parms.bForce = bForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.CancelAbilityForPawnCheat
// (RequiredAPI, Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class AOrionChar*                       InChar                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Game::CancelAbilityForPawnCheat(class AOrionChar* InChar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "CancelAbilityForPawnCheat");

	Params::OrionPlayerController_Game_CancelAbilityForPawnCheat Parms{};

	Parms.InChar = InChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.CancelAllAbilitiesCheat
// (RequiredAPI, Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class AOrionChar*                       InChar                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Game::CancelAllAbilitiesCheat(class AOrionChar* InChar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "CancelAllAbilitiesCheat");

	Params::OrionPlayerController_Game_CancelAllAbilitiesCheat Parms{};

	Parms.InChar = InChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ClientAddMinimapPing
// (Final, Net, Native, Event, Private, HasDefaults, NetClient)
// Parameters:
// struct FVector                          PingWorldPosition                                      (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Game::ClientAddMinimapPing(const struct FVector& PingWorldPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ClientAddMinimapPing");

	Params::OrionPlayerController_Game_ClientAddMinimapPing Parms{};

	Parms.PingWorldPosition = std::move(PingWorldPosition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ClientDisableKillcam
// (Net, NetReliable, Native, Event, Public, NetClient)

void AOrionPlayerController_Game::ClientDisableKillcam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ClientDisableKillcam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ClientHandleMatchIsWaitingToStart
// (Net, NetReliable, Native, Event, Public, NetClient)

void AOrionPlayerController_Game::ClientHandleMatchIsWaitingToStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ClientHandleMatchIsWaitingToStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ClientHandlePostLogin
// (Net, NetReliable, Native, Event, Public, NetClient)

void AOrionPlayerController_Game::ClientHandlePostLogin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ClientHandlePostLogin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ClientKilledBy
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class AOrionPlayerState_Game*           Killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           KilledActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Game::ClientKilledBy(class AOrionPlayerState_Game* Killer, class AActor* DamageCauser, class AActor* KilledActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ClientKilledBy");

	Params::OrionPlayerController_Game_ClientKilledBy Parms{};

	Parms.Killer = Killer;
	Parms.DamageCauser = DamageCauser;
	Parms.KilledActor = KilledActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ClientMatchComplete
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// struct FMatchCompleteNotification       MatchCompleteNotification                              (Parm, NativeAccessSpecifierPublic)
// class FName                             SurveyQuestionGroupName                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Game::ClientMatchComplete(const struct FMatchCompleteNotification& MatchCompleteNotification, class FName SurveyQuestionGroupName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ClientMatchComplete");

	Params::OrionPlayerController_Game_ClientMatchComplete Parms{};

	Parms.MatchCompleteNotification = std::move(MatchCompleteNotification);
	Parms.SurveyQuestionGroupName = SurveyQuestionGroupName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ClientMatchHasEnded
// (Net, NetReliable, Native, Event, Public, NetClient)

void AOrionPlayerController_Game::ClientMatchHasEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ClientMatchHasEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ClientPlayKillcam
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class APawn*                            PawnToFocus                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Game::ClientPlayKillcam(class APawn* PawnToFocus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ClientPlayKillcam");

	Params::OrionPlayerController_Game_ClientPlayKillcam Parms{};

	Parms.PawnToFocus = PawnToFocus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ClientReceiveTeamCommMessage
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// struct FOrionTeamCommMessage            MESSAGE                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)

void AOrionPlayerController_Game::ClientReceiveTeamCommMessage(const struct FOrionTeamCommMessage& MESSAGE)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ClientReceiveTeamCommMessage");

	Params::OrionPlayerController_Game_ClientReceiveTeamCommMessage Parms{};

	Parms.MESSAGE = std::move(MESSAGE);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ClientSetGravesiteCameraState
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// EGravesiteCameraState                   GravesiteCameraState                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PositionOfKiller                                       (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PositionOfDeath                                        (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          FacingDir                                              (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OptKillerActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Game::ClientSetGravesiteCameraState(EGravesiteCameraState GravesiteCameraState, const struct FVector& PositionOfKiller, const struct FVector& PositionOfDeath, const struct FVector& FacingDir, class AActor* OptKillerActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ClientSetGravesiteCameraState");

	Params::OrionPlayerController_Game_ClientSetGravesiteCameraState Parms{};

	Parms.GravesiteCameraState = GravesiteCameraState;
	Parms.PositionOfKiller = std::move(PositionOfKiller);
	Parms.PositionOfDeath = std::move(PositionOfDeath);
	Parms.FacingDir = std::move(FacingDir);
	Parms.OptKillerActor = OptKillerActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ClientSurrender
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                                    bSurrender                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSuccess                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Game::ClientSurrender(bool bSurrender, bool bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ClientSurrender");

	Params::OrionPlayerController_Game_ClientSurrender Parms{};

	Parms.bSurrender = bSurrender;
	Parms.bSuccess = bSuccess;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ClientTransitionToSpectating
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// struct FVector                          PositionOfKiller                                       (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PositionOfDeath                                        (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ViewerDir                                              (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OptKillerActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Game::ClientTransitionToSpectating(const struct FVector& PositionOfKiller, const struct FVector& PositionOfDeath, const struct FVector& ViewerDir, class AActor* OptKillerActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ClientTransitionToSpectating");

	Params::OrionPlayerController_Game_ClientTransitionToSpectating Parms{};

	Parms.PositionOfKiller = std::move(PositionOfKiller);
	Parms.PositionOfDeath = std::move(PositionOfDeath);
	Parms.ViewerDir = std::move(ViewerDir);
	Parms.OptKillerActor = OptKillerActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ClientTriggerHighlight
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FName                             HighlightEvent                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Game::ClientTriggerHighlight(class FName HighlightEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ClientTriggerHighlight");

	Params::OrionPlayerController_Game_ClientTriggerHighlight Parms{};

	Parms.HighlightEvent = HighlightEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ClientWardPing
// (Net, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// struct FVector                          PingLocation                                           (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Game::ClientWardPing(const struct FVector& PingLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ClientWardPing");

	Params::OrionPlayerController_Game_ClientWardPing Parms{};

	Parms.PingLocation = std::move(PingLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.CloseScoreboard
// (Final, RequiredAPI, Native, Public)

void AOrionPlayerController_Game::CloseScoreboard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "CloseScoreboard");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.CloseTeamCommsMenu
// (Final, RequiredAPI, Native, Public)

void AOrionPlayerController_Game::CloseTeamCommsMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "CloseTeamCommsMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.CloseUpgradePanel
// (Final, RequiredAPI, Native, Public)

void AOrionPlayerController_Game::CloseUpgradePanel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "CloseUpgradePanel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ConfirmAbilityForPawnCheat
// (RequiredAPI, Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class AOrionChar*                       InChar                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Game::ConfirmAbilityForPawnCheat(class AOrionChar* InChar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ConfirmAbilityForPawnCheat");

	Params::OrionPlayerController_Game_ConfirmAbilityForPawnCheat Parms{};

	Parms.InChar = InChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.DestroyTeamCommsActor
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class ATeamCommunicationsActor*         TeamCommsActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Game::DestroyTeamCommsActor(class ATeamCommunicationsActor* TeamCommsActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "DestroyTeamCommsActor");

	Params::OrionPlayerController_Game_DestroyTeamCommsActor Parms{};

	Parms.TeamCommsActor = TeamCommsActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.EndFreeLookCameraRestrictions
// (Final, RequiredAPI, Native, Public)

void AOrionPlayerController_Game::EndFreeLookCameraRestrictions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "EndFreeLookCameraRestrictions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.OnFreeCameraModePressed
// (Final, RequiredAPI, Native, Public)

void AOrionPlayerController_Game::OnFreeCameraModePressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "OnFreeCameraModePressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.OnFreeCameraModeReleased
// (Final, RequiredAPI, Native, Public)

void AOrionPlayerController_Game::OnFreeCameraModeReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "OnFreeCameraModeReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.OnFreeCursorModePressed
// (Final, RequiredAPI, Native, Public)

void AOrionPlayerController_Game::OnFreeCursorModePressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "OnFreeCursorModePressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.OnFreeCursorModeReleased
// (Final, RequiredAPI, Native, Public)

void AOrionPlayerController_Game::OnFreeCursorModeReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "OnFreeCursorModeReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.OnHUDCursorModePress
// (Final, RequiredAPI, Native, Public)

void AOrionPlayerController_Game::OnHUDCursorModePress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "OnHUDCursorModePress");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.OnHUDCursorModeRelease
// (Final, RequiredAPI, Native, Public)

void AOrionPlayerController_Game::OnHUDCursorModeRelease()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "OnHUDCursorModeRelease");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.OnHUDCursorModeToggle
// (Final, RequiredAPI, Native, Public)

void AOrionPlayerController_Game::OnHUDCursorModeToggle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "OnHUDCursorModeToggle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.OpenScoreboard
// (Final, RequiredAPI, Native, Public)

void AOrionPlayerController_Game::OpenScoreboard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "OpenScoreboard");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.OpenUpgradePanel
// (Final, RequiredAPI, Native, Public)

void AOrionPlayerController_Game::OpenUpgradePanel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "OpenUpgradePanel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.OrionPause
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)

void AOrionPlayerController_Game::OrionPause()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "OrionPause");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ReportClientHitch
// (Net, Native, Event, Public, NetServer, HasDefaults, NetValidate)
// Parameters:
// struct FVector                          CameraLocation                                         (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                            CameraRotation                                         (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Game::ReportClientHitch(const struct FVector& CameraLocation, const struct FQuat& CameraRotation, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ReportClientHitch");

	Params::OrionPlayerController_Game_ReportClientHitch Parms{};

	Parms.CameraLocation = std::move(CameraLocation);
	Parms.CameraRotation = std::move(CameraRotation);
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ScriptAIBehaviorCheat
// (RequiredAPI, Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class AOrionChar*                       InChar                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ScriptedBehaviorName                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Game::ScriptAIBehaviorCheat(class AOrionChar* InChar, class FName ScriptedBehaviorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ScriptAIBehaviorCheat");

	Params::OrionPlayerController_Game_ScriptAIBehaviorCheat Parms{};

	Parms.InChar = InChar;
	Parms.ScriptedBehaviorName = ScriptedBehaviorName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ServerActivateCardInSlot
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// int32                                   EquipSlotIdx                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Game::ServerActivateCardInSlot(int32 EquipSlotIdx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ServerActivateCardInSlot");

	Params::OrionPlayerController_Game_ServerActivateCardInSlot Parms{};

	Parms.EquipSlotIdx = EquipSlotIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ServerApplyGameplayEffect
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayEffect*                  GameplayEffect                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EffectsLevel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Game::ServerApplyGameplayEffect(class AActor* Target, class UGameplayEffect* GameplayEffect, float EffectsLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ServerApplyGameplayEffect");

	Params::OrionPlayerController_Game_ServerApplyGameplayEffect Parms{};

	Parms.Target = Target;
	Parms.GameplayEffect = GameplayEffect;
	Parms.EffectsLevel = EffectsLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ServerBroadcastTeamComm
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// class UPCTeamCommunicationsData*        TeamCommData                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Game::ServerBroadcastTeamComm(const class UPCTeamCommunicationsData* TeamCommData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ServerBroadcastTeamComm");

	Params::OrionPlayerController_Game_ServerBroadcastTeamComm Parms{};

	Parms.TeamCommData = TeamCommData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ServerEquipCard
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// int32                                   HandIdx                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EquipSlotIdx                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Game::ServerEquipCard(int32 HandIdx, int32 EquipSlotIdx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ServerEquipCard");

	Params::OrionPlayerController_Game_ServerEquipCard Parms{};

	Parms.HandIdx = HandIdx;
	Parms.EquipSlotIdx = EquipSlotIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ServerForceStartCountdown
// (RequiredAPI, Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)

void AOrionPlayerController_Game::ServerForceStartCountdown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ServerForceStartCountdown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ServerForceStartGame
// (RequiredAPI, Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)

void AOrionPlayerController_Game::ServerForceStartGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ServerForceStartGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ServerNotifyDeathCamEnded
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)

void AOrionPlayerController_Game::ServerNotifyDeathCamEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ServerNotifyDeathCamEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ServerNotifyDeathCamStarted
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)

void AOrionPlayerController_Game::ServerNotifyDeathCamStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ServerNotifyDeathCamStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ServerResetDeck
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)

void AOrionPlayerController_Game::ServerResetDeck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ServerResetDeck");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ServerSendMinimapPing
// (Final, Net, NetReliable, Native, Event, Private, NetServer, HasDefaults, NetValidate)
// Parameters:
// struct FVector                          WorldPosition                                          (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Game::ServerSendMinimapPing(const struct FVector& WorldPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ServerSendMinimapPing");

	Params::OrionPlayerController_Game_ServerSendMinimapPing Parms{};

	Parms.WorldPosition = std::move(WorldPosition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ServerSetIsUsingGamepad
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// bool                                    bNewIsUsingGamepad                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Game::ServerSetIsUsingGamepad(bool bNewIsUsingGamepad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ServerSetIsUsingGamepad");

	Params::OrionPlayerController_Game_ServerSetIsUsingGamepad Parms{};

	Parms.bNewIsUsingGamepad = bNewIsUsingGamepad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ServerSetSelectedDeckItem
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// class FString                           DeckInstanceId                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Game::ServerSetSelectedDeckItem(const class FString& DeckInstanceId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ServerSetSelectedDeckItem");

	Params::OrionPlayerController_Game_ServerSetSelectedDeckItem Parms{};

	Parms.DeckInstanceId = std::move(DeckInstanceId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ServerSuicide
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void AOrionPlayerController_Game::ServerSuicide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ServerSuicide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ServerSurrender
// (RequiredAPI, Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// bool                                    bSurrender                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Game::ServerSurrender(bool bSurrender, int32 Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ServerSurrender");

	Params::OrionPlayerController_Game_ServerSurrender Parms{};

	Parms.bSurrender = bSurrender;
	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ServerSwapCards
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// int32                                   EquipSlotIdxOne                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EquipSlotIdxTwo                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Game::ServerSwapCards(int32 EquipSlotIdxOne, int32 EquipSlotIdxTwo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ServerSwapCards");

	Params::OrionPlayerController_Game_ServerSwapCards Parms{};

	Parms.EquipSlotIdxOne = EquipSlotIdxOne;
	Parms.EquipSlotIdxTwo = EquipSlotIdxTwo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ServerTransitionToSpectating
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void AOrionPlayerController_Game::ServerTransitionToSpectating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ServerTransitionToSpectating");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ServerUnequipCard
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// int32                                   EquipSlotIdx                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Game::ServerUnequipCard(int32 EquipSlotIdx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ServerUnequipCard");

	Params::OrionPlayerController_Game_ServerUnequipCard Parms{};

	Parms.EquipSlotIdx = EquipSlotIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ServerUnlockGemTreePip
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// EOrionGemBranchType                     Branch                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Game::ServerUnlockGemTreePip(EOrionGemBranchType Branch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ServerUnlockGemTreePip");

	Params::OrionPlayerController_Game_ServerUnlockGemTreePip Parms{};

	Parms.Branch = Branch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ServerUpdateCameraFreeLook
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    bStartFreeLook                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Game::ServerUpdateCameraFreeLook(bool bStartFreeLook)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ServerUpdateCameraFreeLook");

	Params::OrionPlayerController_Game_ServerUpdateCameraFreeLook Parms{};

	Parms.bStartFreeLook = bStartFreeLook;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.SetHealthCheat
// (RequiredAPI, Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class AOrionChar*                       InChar                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InPercent                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Game::SetHealthCheat(class AOrionChar* InChar, const float InPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "SetHealthCheat");

	Params::OrionPlayerController_Game_SetHealthCheat Parms{};

	Parms.InChar = InChar;
	Parms.InPercent = InPercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.SetLastZoneVisionMask
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// uint8                                   In_InMask                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   In_CanSeeMask                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Game::SetLastZoneVisionMask(uint8 In_InMask, uint8 In_CanSeeMask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "SetLastZoneVisionMask");

	Params::OrionPlayerController_Game_SetLastZoneVisionMask Parms{};

	Parms.In_InMask = In_InMask;
	Parms.In_CanSeeMask = In_CanSeeMask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ShouldDisplayCardOverLocalPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionPlayerController_Game::ShouldDisplayCardOverLocalPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ShouldDisplayCardOverLocalPlayer");

	Params::OrionPlayerController_Game_ShouldDisplayCardOverLocalPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlayerController_Game.StartUpgradePanelTimer
// (Final, RequiredAPI, Native, Public)

void AOrionPlayerController_Game::StartUpgradePanelTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "StartUpgradePanelTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.Suicide
// (Exec, Native, Public)

void AOrionPlayerController_Game::Suicide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "Suicide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.TeleportCharTo
// (RequiredAPI, Net, NetReliable, Native, Event, Public, NetServer, HasDefaults, NetValidate)
// Parameters:
// class AOrionChar*                       InChar                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldDirection                                         (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         DestRotation                                           (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AOrionPlayerController_Game::TeleportCharTo(class AOrionChar* InChar, const struct FVector& WorldDirection, const struct FRotator& DestRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "TeleportCharTo");

	Params::OrionPlayerController_Game_TeleportCharTo Parms{};

	Parms.InChar = InChar;
	Parms.WorldDirection = std::move(WorldDirection);
	Parms.DestRotation = std::move(DestRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ToggleCardMenu
// (Final, RequiredAPI, Native, Public)

void AOrionPlayerController_Game::ToggleCardMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ToggleCardMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ToggleEmoteMenu
// (Final, RequiredAPI, Native, Public)

void AOrionPlayerController_Game::ToggleEmoteMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ToggleEmoteMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ToggleEscapeMenu
// (Final, RequiredAPI, Native, Public)

void AOrionPlayerController_Game::ToggleEscapeMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ToggleEscapeMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ToggleLargeMinimap
// (Final, RequiredAPI, Native, Public)

void AOrionPlayerController_Game::ToggleLargeMinimap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ToggleLargeMinimap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ToggleScoreboard
// (Final, RequiredAPI, Native, Public)

void AOrionPlayerController_Game::ToggleScoreboard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ToggleScoreboard");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.ToggleTeamCommsMenu
// (Final, RequiredAPI, Native, Public)

void AOrionPlayerController_Game::ToggleTeamCommsMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "ToggleTeamCommsMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.UpgradeAbilityModeRelease
// (Final, RequiredAPI, Native, Public)

void AOrionPlayerController_Game::UpgradeAbilityModeRelease()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "UpgradeAbilityModeRelease");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Game.IsUpgradePanelOpen
// (Final, RequiredAPI, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionPlayerController_Game::IsUpgradePanelOpen() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "IsUpgradePanelOpen");

	Params::OrionPlayerController_Game_IsUpgradePanelOpen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlayerController_Game.OrionIsPaused
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionPlayerController_Game::OrionIsPaused() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Game", "OrionIsPaused");

	Params::OrionPlayerController_Game_OrionIsPaused Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlayerController_Arcade.ServerForceStartGame
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)

void AOrionPlayerController_Arcade::ServerForceStartGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Arcade", "ServerForceStartGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Arcade.ServerPlayerHasConfirmed
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void AOrionPlayerController_Arcade::ServerPlayerHasConfirmed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Arcade", "ServerPlayerHasConfirmed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Arcade.ServerRestartRounds
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    bWithBuff                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Arcade::ServerRestartRounds(bool bWithBuff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Arcade", "ServerRestartRounds");

	Params::OrionPlayerController_Arcade_ServerRestartRounds Parms{};

	Parms.bWithBuff = bWithBuff;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientBotManager_Smoke.OnBuffGained
// (Final, Native, Public)
// Parameters:
// struct FOrionJungleBuffInfo             BuffInfo                                               (Parm, NativeAccessSpecifierPublic)

void UOrionClientBotManager_Smoke::OnBuffGained(const struct FOrionJungleBuffInfo& BuffInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientBotManager_Smoke", "OnBuffGained");

	Params::OrionClientBotManager_Smoke_OnBuffGained Parms{};

	Parms.BuffInfo = std::move(BuffInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_DraftLobby.ClientBeginDraftTutorial
// (Final, Net, NetReliable, Native, Event, Private, NetClient)

void AOrionPlayerController_DraftLobby::ClientBeginDraftTutorial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_DraftLobby", "ClientBeginDraftTutorial");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_DraftLobby.ClientCreateTeamChatRoom
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FString                           ChatRoomId                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_DraftLobby::ClientCreateTeamChatRoom(const class FString& ChatRoomId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_DraftLobby", "ClientCreateTeamChatRoom");

	Params::OrionPlayerController_DraftLobby_ClientCreateTeamChatRoom Parms{};

	Parms.ChatRoomId = std::move(ChatRoomId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_DraftLobby.ClientHeroSelectionStatus
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_DraftLobby::ClientHeroSelectionStatus(bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_DraftLobby", "ClientHeroSelectionStatus");

	Params::OrionPlayerController_DraftLobby_ClientHeroSelectionStatus Parms{};

	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_DraftLobby.ClientJoinTeamChatRoom
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FString                           ChatRoomId                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_DraftLobby::ClientJoinTeamChatRoom(const class FString& ChatRoomId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_DraftLobby", "ClientJoinTeamChatRoom");

	Params::OrionPlayerController_DraftLobby_ClientJoinTeamChatRoom Parms{};

	Parms.ChatRoomId = std::move(ChatRoomId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_DraftLobby.ClientPickNotification
// (Net, NetReliable, Native, Event, Public, NetClient)

void AOrionPlayerController_DraftLobby::ClientPickNotification()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_DraftLobby", "ClientPickNotification");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_DraftLobby.ClientReceiveQuickChatMessage
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// struct FUniqueNetIdRepl                 SenderId                                               (ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FOrionQuickChatPayload           MessagePayload                                         (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void AOrionPlayerController_DraftLobby::ClientReceiveQuickChatMessage(const struct FUniqueNetIdRepl& SenderId, const struct FOrionQuickChatPayload& MessagePayload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_DraftLobby", "ClientReceiveQuickChatMessage");

	Params::OrionPlayerController_DraftLobby_ClientReceiveQuickChatMessage Parms{};

	Parms.SenderId = std::move(SenderId);
	Parms.MessagePayload = std::move(MessagePayload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_DraftLobby.ClientUpNextNotification
// (Net, NetReliable, Native, Event, Public, NetClient)

void AOrionPlayerController_DraftLobby::ClientUpNextNotification()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_DraftLobby", "ClientUpNextNotification");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_DraftLobby.ServerAttemptLockInHeroChoice
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FString                           HeroName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_DraftLobby::ServerAttemptLockInHeroChoice(const class FString& HeroName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_DraftLobby", "ServerAttemptLockInHeroChoice");

	Params::OrionPlayerController_DraftLobby_ServerAttemptLockInHeroChoice Parms{};

	Parms.HeroName = std::move(HeroName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_DraftLobby.ServerNotifyTutorialComplete
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)

void AOrionPlayerController_DraftLobby::ServerNotifyTutorialComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_DraftLobby", "ServerNotifyTutorialComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_DraftLobby.ServerRequestDraftTutorial
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)

void AOrionPlayerController_DraftLobby::ServerRequestDraftTutorial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_DraftLobby", "ServerRequestDraftTutorial");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_DraftLobby.ServerSendQuickChatMessage
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// struct FOrionQuickChatPayload           QuickChatPayload                                       (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void AOrionPlayerController_DraftLobby::ServerSendQuickChatMessage(const struct FOrionQuickChatPayload& QuickChatPayload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_DraftLobby", "ServerSendQuickChatMessage");

	Params::OrionPlayerController_DraftLobby_ServerSendQuickChatMessage Parms{};

	Parms.QuickChatPayload = std::move(QuickChatPayload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_DraftLobby.ServerSetDesiredPosition
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// EOrionPosition                          Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_DraftLobby::ServerSetDesiredPosition(EOrionPosition Position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_DraftLobby", "ServerSetDesiredPosition");

	Params::OrionPlayerController_DraftLobby_ServerSetDesiredPosition Parms{};

	Parms.Position = Position;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_DraftLobby.ServerSetDesiredRole
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// EOrionRole                              DesiredRole                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_DraftLobby::ServerSetDesiredRole(EOrionRole DesiredRole)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_DraftLobby", "ServerSetDesiredRole");

	Params::OrionPlayerController_DraftLobby_ServerSetDesiredRole Parms{};

	Parms.DesiredRole = DesiredRole;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_DraftLobby.ServerSetMapOverride
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// class FString                           InMapURL                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_DraftLobby::ServerSetMapOverride(const class FString& InMapURL)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_DraftLobby", "ServerSetMapOverride");

	Params::OrionPlayerController_DraftLobby_ServerSetMapOverride Parms{};

	Parms.InMapURL = std::move(InMapURL);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_DraftLobby.ServerSetSelectedHero
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// class UOrionHeroData*                   HeroData                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_DraftLobby::ServerSetSelectedHero(const class UOrionHeroData* HeroData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_DraftLobby", "ServerSetSelectedHero");

	Params::OrionPlayerController_DraftLobby_ServerSetSelectedHero Parms{};

	Parms.HeroData = HeroData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameUserSettings.GetOrionGameUserSettings
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UOrionGameUserSettings*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionGameUserSettings* UOrionGameUserSettings::GetOrionGameUserSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionGameUserSettings", "GetOrionGameUserSettings");

	Params::OrionGameUserSettings_GetOrionGameUserSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameUserSettings.IsRunningOnUnsupportedGraphicsCard
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionGameUserSettings::IsRunningOnUnsupportedGraphicsCard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionGameUserSettings", "IsRunningOnUnsupportedGraphicsCard");

	Params::OrionGameUserSettings_IsRunningOnUnsupportedGraphicsCard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameUserSettings.GetForceAutomaticSettingsAtStartup
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionGameUserSettings::GetForceAutomaticSettingsAtStartup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameUserSettings", "GetForceAutomaticSettingsAtStartup");

	Params::OrionGameUserSettings_GetForceAutomaticSettingsAtStartup Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameUserSettings.SetCompetitiveMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInCompMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionGameUserSettings::SetCompetitiveMode(bool bInCompMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameUserSettings", "SetCompetitiveMode");

	Params::OrionGameUserSettings_SetCompetitiveMode Parms{};

	Parms.bInCompMode = bInCompMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameUserSettings.SetForceAutomaticSettingsAtStartup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShouldForceSettings                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionGameUserSettings::SetForceAutomaticSettingsAtStartup(bool bShouldForceSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameUserSettings", "SetForceAutomaticSettingsAtStartup");

	Params::OrionGameUserSettings_SetForceAutomaticSettingsAtStartup Parms{};

	Parms.bShouldForceSettings = bShouldForceSettings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameUserSettings.SetMenuFrameRateLimit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewLimit                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionGameUserSettings::SetMenuFrameRateLimit(float NewLimit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameUserSettings", "SetMenuFrameRateLimit");

	Params::OrionGameUserSettings_SetMenuFrameRateLimit Parms{};

	Parms.NewLimit = NewLimit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameUserSettings.SetOrionGameplayQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionGameUserSettings::SetOrionGameplayQuality(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameUserSettings", "SetOrionGameplayQuality");

	Params::OrionGameUserSettings_SetOrionGameplayQuality Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameUserSettings.TriggerRenderingBenchmark
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionGameUserSettings::TriggerRenderingBenchmark(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameUserSettings", "TriggerRenderingBenchmark");

	Params::OrionGameUserSettings_TriggerRenderingBenchmark Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameUserSettings.GetCompetitiveMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionGameUserSettings::GetCompetitiveMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameUserSettings", "GetCompetitiveMode");

	Params::OrionGameUserSettings_GetCompetitiveMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameUserSettings.GetGPUDisplayString
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UOrionGameUserSettings::GetGPUDisplayString() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameUserSettings", "GetGPUDisplayString");

	Params::OrionGameUserSettings_GetGPUDisplayString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameUserSettings.GetInitialBenchmarkState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOrionGameUserSettings::GetInitialBenchmarkState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameUserSettings", "GetInitialBenchmarkState");

	Params::OrionGameUserSettings_GetInitialBenchmarkState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameUserSettings.GetMenuFrameRateLimit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOrionGameUserSettings::GetMenuFrameRateLimit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameUserSettings", "GetMenuFrameRateLimit");

	Params::OrionGameUserSettings_GetMenuFrameRateLimit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameUserSettings.GetOrionGameplayQuality
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOrionGameUserSettings::GetOrionGameplayQuality() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameUserSettings", "GetOrionGameplayQuality");

	Params::OrionGameUserSettings_GetOrionGameplayQuality Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameUserSettings.GetSupportedHDRNitLevels
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> UOrionGameUserSettings::GetSupportedHDRNitLevels() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameUserSettings", "GetSupportedHDRNitLevels");

	Params::OrionGameUserSettings_GetSupportedHDRNitLevels Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientPilotComponent_GameSmoke.OnBuffGained
// (Final, Native, Public)
// Parameters:
// struct FOrionJungleBuffInfo             BuffInfo                                               (Parm, NativeAccessSpecifierPublic)

void UOrionClientPilotComponent_GameSmoke::OnBuffGained(const struct FOrionJungleBuffInfo& BuffInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientPilotComponent_GameSmoke", "OnBuffGained");

	Params::OrionClientPilotComponent_GameSmoke_OnBuffGained Parms{};

	Parms.BuffInfo = std::move(BuffInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionMcpBannerAlterationItemDefinition.GetBannerMaterialDesc
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FBannerMaterialDesc              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FBannerMaterialDesc UOrionMcpBannerAlterationItemDefinition::GetBannerMaterialDesc() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpBannerAlterationItemDefinition", "GetBannerMaterialDesc");

	Params::OrionMcpBannerAlterationItemDefinition_GetBannerMaterialDesc Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionMcpBannerAlterationItemDefinition.GetDiffuse
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTexture*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture* UOrionMcpBannerAlterationItemDefinition::GetDiffuse() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpBannerAlterationItemDefinition", "GetDiffuse");

	Params::OrionMcpBannerAlterationItemDefinition_GetDiffuse Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionMcpBannerAlterationItemDefinition.GetNormal
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTexture*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture* UOrionMcpBannerAlterationItemDefinition::GetNormal() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpBannerAlterationItemDefinition", "GetNormal");

	Params::OrionMcpBannerAlterationItemDefinition_GetNormal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionMcpBannerAlterationItemDefinition.GetTexture
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTexture*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture* UOrionMcpBannerAlterationItemDefinition::GetTexture() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpBannerAlterationItemDefinition", "GetTexture");

	Params::OrionMcpBannerAlterationItemDefinition_GetTexture Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.SetAbilities
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetAbilities(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetAbilities");

	Params::OrionClientSettingsRecord_SetAbilities Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetAbilityHotkeys
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetAbilityHotkeys(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetAbilityHotkeys");

	Params::OrionClientSettingsRecord_SetAbilityHotkeys Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetAnnouncements
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetAnnouncements(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetAnnouncements");

	Params::OrionClientSettingsRecord_SetAnnouncements Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetAutoOpenCardShop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetAutoOpenCardShop(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetAutoOpenCardShop");

	Params::OrionClientSettingsRecord_SetAutoOpenCardShop Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetAutoPlayInstantReplay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetAutoPlayInstantReplay(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetAutoPlayInstantReplay");

	Params::OrionClientSettingsRecord_SetAutoPlayInstantReplay Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetBuffs
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetBuffs(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetBuffs");

	Params::OrionClientSettingsRecord_SetBuffs Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetCardHotKeys
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetCardHotKeys(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetCardHotKeys");

	Params::OrionClientSettingsRecord_SetCardHotKeys Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetCardOnboardShown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InCardOnboardLastShownGame                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetCardOnboardShown(bool InCardOnboardLastShownGame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetCardOnboardShown");

	Params::OrionClientSettingsRecord_SetCardOnboardShown Parms{};

	Parms.InCardOnboardLastShownGame = InCardOnboardLastShownGame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetCardsAndGems
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetCardsAndGems(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetCardsAndGems");

	Params::OrionClientSettingsRecord_SetCardsAndGems Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetChat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetChat(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetChat");

	Params::OrionClientSettingsRecord_SetChat Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetDeckBuilderDialogShown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInDeckBuilderDialogShow                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetDeckBuilderDialogShown(bool bInDeckBuilderDialogShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetDeckBuilderDialogShown");

	Params::OrionClientSettingsRecord_SetDeckBuilderDialogShown Parms{};

	Parms.bInDeckBuilderDialogShow = bInDeckBuilderDialogShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetDetailedStatsPanelPortrait
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetDetailedStatsPanelPortrait(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetDetailedStatsPanelPortrait");

	Params::OrionClientSettingsRecord_SetDetailedStatsPanelPortrait Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetDisplayDetailedStatsPanel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetDisplayDetailedStatsPanel(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetDisplayDetailedStatsPanel");

	Params::OrionClientSettingsRecord_SetDisplayDetailedStatsPanel Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetDisplayMeleeHeroReticle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetDisplayMeleeHeroReticle(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetDisplayMeleeHeroReticle");

	Params::OrionClientSettingsRecord_SetDisplayMeleeHeroReticle Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetDisplayNumericalValues
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetDisplayNumericalValues(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetDisplayNumericalValues");

	Params::OrionClientSettingsRecord_SetDisplayNumericalValues Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetEnableCardOverLocalPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetEnableCardOverLocalPlayer(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetEnableCardOverLocalPlayer");

	Params::OrionClientSettingsRecord_SetEnableCardOverLocalPlayer Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetEnableDeathcam
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetEnableDeathcam(int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetEnableDeathcam");

	Params::OrionClientSettingsRecord_SetEnableDeathcam Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetEnemyHeroIndicatorRule
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHealthIndicatorVisibility              NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetEnemyHeroIndicatorRule(EHealthIndicatorVisibility NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetEnemyHeroIndicatorRule");

	Params::OrionClientSettingsRecord_SetEnemyHeroIndicatorRule Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetEnemyMinionIndicatorRule
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHealthIndicatorVisibility              NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetEnemyMinionIndicatorRule(EHealthIndicatorVisibility NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetEnemyMinionIndicatorRule");

	Params::OrionClientSettingsRecord_SetEnemyMinionIndicatorRule Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetFadeHealthBarWhenOutOfCombat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetFadeHealthBarWhenOutOfCombat(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetFadeHealthBarWhenOutOfCombat");

	Params::OrionClientSettingsRecord_SetFadeHealthBarWhenOutOfCombat Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetFloatingCombatText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetFloatingCombatText(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetFloatingCombatText");

	Params::OrionClientSettingsRecord_SetFloatingCombatText Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetFriendlyHeroIndicatorRule
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHealthIndicatorVisibility              NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetFriendlyHeroIndicatorRule(EHealthIndicatorVisibility NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetFriendlyHeroIndicatorRule");

	Params::OrionClientSettingsRecord_SetFriendlyHeroIndicatorRule Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetFriendlyMinionIndicatorRule
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHealthIndicatorVisibility              NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetFriendlyMinionIndicatorRule(EHealthIndicatorVisibility NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetFriendlyMinionIndicatorRule");

	Params::OrionClientSettingsRecord_SetFriendlyMinionIndicatorRule Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetFrontEndPvpMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetFrontEndPvpMode(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetFrontEndPvpMode");

	Params::OrionClientSettingsRecord_SetFrontEndPvpMode Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetHotkeys
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetHotkeys(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetHotkeys");

	Params::OrionClientSettingsRecord_SetHotkeys Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetHUDUIScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InHUDUIScale                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetHUDUIScale(float InHUDUIScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetHUDUIScale");

	Params::OrionClientSettingsRecord_SetHUDUIScale Parms{};

	Parms.InHUDUIScale = InHUDUIScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetKillFeed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetKillFeed(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetKillFeed");

	Params::OrionClientSettingsRecord_SetKillFeed Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetLowHPRecallWarning
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetLowHPRecallWarning(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetLowHPRecallWarning");

	Params::OrionClientSettingsRecord_SetLowHPRecallWarning Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetMeleeHeroHealthBarPosition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPlayerOverheadHealthBarPosition        NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetMeleeHeroHealthBarPosition(EPlayerOverheadHealthBarPosition NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetMeleeHeroHealthBarPosition");

	Params::OrionClientSettingsRecord_SetMeleeHeroHealthBarPosition Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetMiniMap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetMiniMap(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetMiniMap");

	Params::OrionClientSettingsRecord_SetMiniMap Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetOffScreenIndicatorHealthBars
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetOffScreenIndicatorHealthBars(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetOffScreenIndicatorHealthBars");

	Params::OrionClientSettingsRecord_SetOffScreenIndicatorHealthBars Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetOffScreenIndicatorPortraits
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetOffScreenIndicatorPortraits(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetOffScreenIndicatorPortraits");

	Params::OrionClientSettingsRecord_SetOffScreenIndicatorPortraits Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetOffScreenIndicatorVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOffScreenIndicatorVisibility           NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetOffScreenIndicatorVisibility(EOffScreenIndicatorVisibility NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetOffScreenIndicatorVisibility");

	Params::OrionClientSettingsRecord_SetOffScreenIndicatorVisibility Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetRangeHeroHealthBarPosition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPlayerOverheadHealthBarPosition        NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetRangeHeroHealthBarPosition(EPlayerOverheadHealthBarPosition NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetRangeHeroHealthBarPosition");

	Params::OrionClientSettingsRecord_SetRangeHeroHealthBarPosition Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetReticle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetReticle(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetReticle");

	Params::OrionClientSettingsRecord_SetReticle Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetReverseEnemyHealthBarDirection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetReverseEnemyHealthBarDirection(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetReverseEnemyHealthBarDirection");

	Params::OrionClientSettingsRecord_SetReverseEnemyHealthBarDirection Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetShowAbilityConfirmWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetShowAbilityConfirmWidget(int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetShowAbilityConfirmWidget");

	Params::OrionClientSettingsRecord_SetShowAbilityConfirmWidget Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetShowAddedItemsInChat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetShowAddedItemsInChat(int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetShowAddedItemsInChat");

	Params::OrionClientSettingsRecord_SetShowAddedItemsInChat Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetShowBasicAttackRangeIndicator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetShowBasicAttackRangeIndicator(int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetShowBasicAttackRangeIndicator");

	Params::OrionClientSettingsRecord_SetShowBasicAttackRangeIndicator Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetShowCompletedItemsInChat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetShowCompletedItemsInChat(int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetShowCompletedItemsInChat");

	Params::OrionClientSettingsRecord_SetShowCompletedItemsInChat Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetShowDiscardedItemsInChat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetShowDiscardedItemsInChat(int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetShowDiscardedItemsInChat");

	Params::OrionClientSettingsRecord_SetShowDiscardedItemsInChat Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetShowHUDHotkeys
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetShowHUDHotkeys(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetShowHUDHotkeys");

	Params::OrionClientSettingsRecord_SetShowHUDHotkeys Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetShowLaneGuides
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetShowLaneGuides(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetShowLaneGuides");

	Params::OrionClientSettingsRecord_SetShowLaneGuides Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetStaticHealthBarPosition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EStaticHealthBarPosition                NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetStaticHealthBarPosition(EStaticHealthBarPosition NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetStaticHealthBarPosition");

	Params::OrionClientSettingsRecord_SetStaticHealthBarPosition Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetStatsPanel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetStatsPanel(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetStatsPanel");

	Params::OrionClientSettingsRecord_SetStatsPanel Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetStatusAreaDisplayType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EStatusAreaDisplayType                  NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetStatusAreaDisplayType(EStatusAreaDisplayType NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetStatusAreaDisplayType");

	Params::OrionClientSettingsRecord_SetStatusAreaDisplayType Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetTeamComms
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetTeamComms(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetTeamComms");

	Params::OrionClientSettingsRecord_SetTeamComms Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetTeamCoreHP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetTeamCoreHP(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetTeamCoreHP");

	Params::OrionClientSettingsRecord_SetTeamCoreHP Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.SetTeamFrames
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionClientSettingsRecord::SetTeamFrames(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "SetTeamFrames");

	Params::OrionClientSettingsRecord_SetTeamFrames Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionClientSettingsRecord.GetAbilities
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionClientSettingsRecord::GetAbilities() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetAbilities");

	Params::OrionClientSettingsRecord_GetAbilities Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetAbilityHotkeys
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionClientSettingsRecord::GetAbilityHotkeys() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetAbilityHotkeys");

	Params::OrionClientSettingsRecord_GetAbilityHotkeys Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetAnnouncements
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionClientSettingsRecord::GetAnnouncements() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetAnnouncements");

	Params::OrionClientSettingsRecord_GetAnnouncements Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetAutoOpenCardShop
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionClientSettingsRecord::GetAutoOpenCardShop() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetAutoOpenCardShop");

	Params::OrionClientSettingsRecord_GetAutoOpenCardShop Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetAutoPlayInstantReplay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionClientSettingsRecord::GetAutoPlayInstantReplay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetAutoPlayInstantReplay");

	Params::OrionClientSettingsRecord_GetAutoPlayInstantReplay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetBuffs
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionClientSettingsRecord::GetBuffs() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetBuffs");

	Params::OrionClientSettingsRecord_GetBuffs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetCardHotkeys
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionClientSettingsRecord::GetCardHotkeys() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetCardHotkeys");

	Params::OrionClientSettingsRecord_GetCardHotkeys Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetCardsAndGems
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionClientSettingsRecord::GetCardsAndGems() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetCardsAndGems");

	Params::OrionClientSettingsRecord_GetCardsAndGems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetChat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionClientSettingsRecord::GetChat() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetChat");

	Params::OrionClientSettingsRecord_GetChat Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetDetailedStatsPanelPortrait
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionClientSettingsRecord::GetDetailedStatsPanelPortrait() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetDetailedStatsPanelPortrait");

	Params::OrionClientSettingsRecord_GetDetailedStatsPanelPortrait Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetDisplayDetailedStatsPanel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionClientSettingsRecord::GetDisplayDetailedStatsPanel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetDisplayDetailedStatsPanel");

	Params::OrionClientSettingsRecord_GetDisplayDetailedStatsPanel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetDisplayMeleeHeroReticle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionClientSettingsRecord::GetDisplayMeleeHeroReticle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetDisplayMeleeHeroReticle");

	Params::OrionClientSettingsRecord_GetDisplayMeleeHeroReticle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetDisplayNumericalValues
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionClientSettingsRecord::GetDisplayNumericalValues() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetDisplayNumericalValues");

	Params::OrionClientSettingsRecord_GetDisplayNumericalValues Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetEnableCardOverLocalPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionClientSettingsRecord::GetEnableCardOverLocalPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetEnableCardOverLocalPlayer");

	Params::OrionClientSettingsRecord_GetEnableCardOverLocalPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetEnableDeathcam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOrionClientSettingsRecord::GetEnableDeathcam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetEnableDeathcam");

	Params::OrionClientSettingsRecord_GetEnableDeathcam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetEnemyHeroIndicatorRule
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EHealthIndicatorVisibility              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EHealthIndicatorVisibility UOrionClientSettingsRecord::GetEnemyHeroIndicatorRule() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetEnemyHeroIndicatorRule");

	Params::OrionClientSettingsRecord_GetEnemyHeroIndicatorRule Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetEnemyMinionIndicatorRule
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EHealthIndicatorVisibility              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EHealthIndicatorVisibility UOrionClientSettingsRecord::GetEnemyMinionIndicatorRule() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetEnemyMinionIndicatorRule");

	Params::OrionClientSettingsRecord_GetEnemyMinionIndicatorRule Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetFadeHealthBarWhenOutOfCombat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionClientSettingsRecord::GetFadeHealthBarWhenOutOfCombat() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetFadeHealthBarWhenOutOfCombat");

	Params::OrionClientSettingsRecord_GetFadeHealthBarWhenOutOfCombat Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetFloatingCombatText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionClientSettingsRecord::GetFloatingCombatText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetFloatingCombatText");

	Params::OrionClientSettingsRecord_GetFloatingCombatText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetFriendlyHeroIndicatorRule
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EHealthIndicatorVisibility              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EHealthIndicatorVisibility UOrionClientSettingsRecord::GetFriendlyHeroIndicatorRule() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetFriendlyHeroIndicatorRule");

	Params::OrionClientSettingsRecord_GetFriendlyHeroIndicatorRule Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetFriendlyMinionIndicatorRule
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EHealthIndicatorVisibility              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EHealthIndicatorVisibility UOrionClientSettingsRecord::GetFriendlyMinionIndicatorRule() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetFriendlyMinionIndicatorRule");

	Params::OrionClientSettingsRecord_GetFriendlyMinionIndicatorRule Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetFrontEndPvpMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionClientSettingsRecord::GetFrontEndPvpMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetFrontEndPvpMode");

	Params::OrionClientSettingsRecord_GetFrontEndPvpMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetHotkeys
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionClientSettingsRecord::GetHotkeys() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetHotkeys");

	Params::OrionClientSettingsRecord_GetHotkeys Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetHUDUIScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOrionClientSettingsRecord::GetHUDUIScale() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetHUDUIScale");

	Params::OrionClientSettingsRecord_GetHUDUIScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetKillFeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionClientSettingsRecord::GetKillFeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetKillFeed");

	Params::OrionClientSettingsRecord_GetKillFeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetLowHPRecallWarning
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionClientSettingsRecord::GetLowHPRecallWarning() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetLowHPRecallWarning");

	Params::OrionClientSettingsRecord_GetLowHPRecallWarning Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetMeleeHeroHealthBarPosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerOverheadHealthBarPosition        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerOverheadHealthBarPosition UOrionClientSettingsRecord::GetMeleeHeroHealthBarPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetMeleeHeroHealthBarPosition");

	Params::OrionClientSettingsRecord_GetMeleeHeroHealthBarPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetMiniMap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionClientSettingsRecord::GetMiniMap() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetMiniMap");

	Params::OrionClientSettingsRecord_GetMiniMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetOffScreenIndicatorHealthBars
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionClientSettingsRecord::GetOffScreenIndicatorHealthBars() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetOffScreenIndicatorHealthBars");

	Params::OrionClientSettingsRecord_GetOffScreenIndicatorHealthBars Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetOffScreenIndicatorPortraits
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionClientSettingsRecord::GetOffScreenIndicatorPortraits() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetOffScreenIndicatorPortraits");

	Params::OrionClientSettingsRecord_GetOffScreenIndicatorPortraits Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetOffScreenIndicatorVisibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOffScreenIndicatorVisibility           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOffScreenIndicatorVisibility UOrionClientSettingsRecord::GetOffScreenIndicatorVisibility() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetOffScreenIndicatorVisibility");

	Params::OrionClientSettingsRecord_GetOffScreenIndicatorVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetRangeHeroHealthBarPosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerOverheadHealthBarPosition        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerOverheadHealthBarPosition UOrionClientSettingsRecord::GetRangeHeroHealthBarPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetRangeHeroHealthBarPosition");

	Params::OrionClientSettingsRecord_GetRangeHeroHealthBarPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetReticle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionClientSettingsRecord::GetReticle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetReticle");

	Params::OrionClientSettingsRecord_GetReticle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetReverseEnemyHealthBarDirection
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionClientSettingsRecord::GetReverseEnemyHealthBarDirection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetReverseEnemyHealthBarDirection");

	Params::OrionClientSettingsRecord_GetReverseEnemyHealthBarDirection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetShowAbilityConfirmWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOrionClientSettingsRecord::GetShowAbilityConfirmWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetShowAbilityConfirmWidget");

	Params::OrionClientSettingsRecord_GetShowAbilityConfirmWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetShowAddedItemsInChat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOrionClientSettingsRecord::GetShowAddedItemsInChat() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetShowAddedItemsInChat");

	Params::OrionClientSettingsRecord_GetShowAddedItemsInChat Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetShowBasicAttackRangeIndicator
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOrionClientSettingsRecord::GetShowBasicAttackRangeIndicator() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetShowBasicAttackRangeIndicator");

	Params::OrionClientSettingsRecord_GetShowBasicAttackRangeIndicator Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetShowCompletedItemsInChat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOrionClientSettingsRecord::GetShowCompletedItemsInChat() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetShowCompletedItemsInChat");

	Params::OrionClientSettingsRecord_GetShowCompletedItemsInChat Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetShowDiscardedItemsInChat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOrionClientSettingsRecord::GetShowDiscardedItemsInChat() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetShowDiscardedItemsInChat");

	Params::OrionClientSettingsRecord_GetShowDiscardedItemsInChat Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetShowHUDHotkeys
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionClientSettingsRecord::GetShowHUDHotkeys() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetShowHUDHotkeys");

	Params::OrionClientSettingsRecord_GetShowHUDHotkeys Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetShowLaneGuides
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionClientSettingsRecord::GetShowLaneGuides() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetShowLaneGuides");

	Params::OrionClientSettingsRecord_GetShowLaneGuides Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetStaticHealthBarPosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EStaticHealthBarPosition                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EStaticHealthBarPosition UOrionClientSettingsRecord::GetStaticHealthBarPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetStaticHealthBarPosition");

	Params::OrionClientSettingsRecord_GetStaticHealthBarPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetStatsPanel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionClientSettingsRecord::GetStatsPanel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetStatsPanel");

	Params::OrionClientSettingsRecord_GetStatsPanel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetStatusAreaDisplayType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EStatusAreaDisplayType                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EStatusAreaDisplayType UOrionClientSettingsRecord::GetStatusAreaDisplayType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetStatusAreaDisplayType");

	Params::OrionClientSettingsRecord_GetStatusAreaDisplayType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetTeamComms
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionClientSettingsRecord::GetTeamComms() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetTeamComms");

	Params::OrionClientSettingsRecord_GetTeamComms Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetTeamCoreHP
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionClientSettingsRecord::GetTeamCoreHP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetTeamCoreHP");

	Params::OrionClientSettingsRecord_GetTeamCoreHP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.GetTeamFrames
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionClientSettingsRecord::GetTeamFrames() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "GetTeamFrames");

	Params::OrionClientSettingsRecord_GetTeamFrames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.HasShownCardOnboard
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionClientSettingsRecord::HasShownCardOnboard() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "HasShownCardOnboard");

	Params::OrionClientSettingsRecord_HasShownCardOnboard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionClientSettingsRecord.HasShownDeckBuilderDialog
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionClientSettingsRecord::HasShownDeckBuilderDialog() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionClientSettingsRecord", "HasShownDeckBuilderDialog");

	Params::OrionClientSettingsRecord_HasShownDeckBuilderDialog Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction OrionGame.OrionHeroData.OnSimpleActorLoaded__DelegateSignature
// (Public, Delegate)
// Parameters:
// class UClass*                           Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionHeroData::OnSimpleActorLoaded__DelegateSignature(class UClass* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionHeroData", "OnSimpleActorLoaded__DelegateSignature");

	Params::OrionHeroData_OnSimpleActorLoaded__DelegateSignature Parms{};

	Parms.Result = Result;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction OrionGame.OrionHeroData.OnSimpleActorLoadedMulti__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class UClass*                           Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionHeroData::OnSimpleActorLoadedMulti__DelegateSignature(class UClass* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionHeroData", "OnSimpleActorLoadedMulti__DelegateSignature");

	Params::OrionHeroData_OnSimpleActorLoadedMulti__DelegateSignature Parms{};

	Parms.Result = Result;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionHeroData.IsHeroRecommended
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionHeroData::IsHeroRecommended() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionHeroData", "IsHeroRecommended");

	Params::OrionHeroData_IsHeroRecommended Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCombatSet.OnRep_AbilityPenetrationPCT
// (Final, Native, Public)

void UOrionCombatSet::OnRep_AbilityPenetrationPCT()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCombatSet", "OnRep_AbilityPenetrationPCT");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCombatSet.OnRep_AbilityPenetrationRating
// (Final, Native, Public)

void UOrionCombatSet::OnRep_AbilityPenetrationRating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCombatSet", "OnRep_AbilityPenetrationRating");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCombatSet.OnRep_AoERating
// (Final, Native, Public)

void UOrionCombatSet::OnRep_AoERating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCombatSet", "OnRep_AoERating");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCombatSet.OnRep_AttackRating
// (Final, Native, Public)

void UOrionCombatSet::OnRep_AttackRating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCombatSet", "OnRep_AttackRating");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCombatSet.OnRep_AttackRatingCoeffecient
// (Final, Native, Public)

void UOrionCombatSet::OnRep_AttackRatingCoeffecient()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCombatSet", "OnRep_AttackRatingCoeffecient");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCombatSet.OnRep_AttackSpeedRating
// (Final, Native, Public)

void UOrionCombatSet::OnRep_AttackSpeedRating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCombatSet", "OnRep_AttackSpeedRating");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCombatSet.OnRep_BaseAttackTime
// (Final, Native, Public)

void UOrionCombatSet::OnRep_BaseAttackTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCombatSet", "OnRep_BaseAttackTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCombatSet.OnRep_BasePower
// (Final, Native, Public)

void UOrionCombatSet::OnRep_BasePower()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCombatSet", "OnRep_BasePower");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCombatSet.OnRep_BasicPenetrationPCT
// (Final, Native, Public)

void UOrionCombatSet::OnRep_BasicPenetrationPCT()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCombatSet", "OnRep_BasicPenetrationPCT");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCombatSet.OnRep_BasicPenetrationRating
// (Final, Native, Public)

void UOrionCombatSet::OnRep_BasicPenetrationRating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCombatSet", "OnRep_BasicPenetrationRating");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCombatSet.OnRep_CleaveRating
// (Final, Native, Public)

void UOrionCombatSet::OnRep_CleaveRating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCombatSet", "OnRep_CleaveRating");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCombatSet.OnRep_CriticalDamageBonus
// (Final, Native, Public)

void UOrionCombatSet::OnRep_CriticalDamageBonus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCombatSet", "OnRep_CriticalDamageBonus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCombatSet.OnRep_CriticalDamageChance
// (Final, Native, Public)

void UOrionCombatSet::OnRep_CriticalDamageChance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCombatSet", "OnRep_CriticalDamageChance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCombatSet.OnRep_DamageBonusSource
// (Final, Native, Public)

void UOrionCombatSet::OnRep_DamageBonusSource()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCombatSet", "OnRep_DamageBonusSource");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCombatSet.OnRep_DamageToEnergyConversionRating
// (Final, Native, Public)

void UOrionCombatSet::OnRep_DamageToEnergyConversionRating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCombatSet", "OnRep_DamageToEnergyConversionRating");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCombatSet.OnRep_FlatDamageBonus
// (Final, Native, Public)

void UOrionCombatSet::OnRep_FlatDamageBonus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCombatSet", "OnRep_FlatDamageBonus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCombatSet.OnRep_HealingBonusSource
// (Final, Native, Public)

void UOrionCombatSet::OnRep_HealingBonusSource()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCombatSet", "OnRep_HealingBonusSource");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCombatSet.OnRep_LeftClickARC
// (Final, Native, Public)

void UOrionCombatSet::OnRep_LeftClickARC()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCombatSet", "OnRep_LeftClickARC");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCombatSet.OnRep_LeftClickBasePower
// (Final, Native, Public)

void UOrionCombatSet::OnRep_LeftClickBasePower()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCombatSet", "OnRep_LeftClickBasePower");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCombatSet.OnRep_LifeGrantRating
// (Final, Native, Public)

void UOrionCombatSet::OnRep_LifeGrantRating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCombatSet", "OnRep_LifeGrantRating");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCombatSet.OnRep_LifeStealRating
// (Final, Native, Public)

void UOrionCombatSet::OnRep_LifeStealRating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCombatSet", "OnRep_LifeStealRating");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCombatSet.OnRep_PerseveranceRating
// (Final, Native, Public)

void UOrionCombatSet::OnRep_PerseveranceRating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCombatSet", "OnRep_PerseveranceRating");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionCombatSet.OnRep_ShieldPenetration
// (Final, Native, Public)

void UOrionCombatSet::OnRep_ShieldPenetration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCombatSet", "OnRep_ShieldPenetration");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionMcpCardPackItemDefinition.GetExplicitCards
// (Final, Native, Public, HasOutParams, BlueprintCallable, Const)
// Parameters:
// TArray<class UOrionLegacyCardItemDefinition*>Cards                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionMcpCardPackItemDefinition::GetExplicitCards(TArray<class UOrionLegacyCardItemDefinition*>* Cards) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpCardPackItemDefinition", "GetExplicitCards");

	Params::OrionMcpCardPackItemDefinition_GetExplicitCards Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Cards != nullptr)
		*Cards = std::move(Parms.Cards);

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCraftingDeviceGlyph.OnActivationChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bActivated                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCraftingDeviceGlyph::OnActivationChanged(bool bActivated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCraftingDeviceGlyph", "OnActivationChanged");

	Params::OrionCraftingDeviceGlyph_OnActivationChanged Parms{};

	Parms.bActivated = bActivated;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionCraftingDeviceNode.GetSlotComponentTimelineDirectly
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UTimelineComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTimelineComponent* AOrionCraftingDeviceNode::GetSlotComponentTimelineDirectly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCraftingDeviceNode", "GetSlotComponentTimelineDirectly");

	Params::OrionCraftingDeviceNode_GetSlotComponentTimelineDirectly Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCraftingDeviceNode.OnActivationChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bActivated                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCraftingDeviceNode::OnActivationChanged(bool bActivated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCraftingDeviceNode", "OnActivationChanged");

	Params::OrionCraftingDeviceNode_OnActivationChanged Parms{};

	Parms.bActivated = bActivated;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionCraftingDeviceNode.OnComponentSlotted
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UOrionComponentItemDefinition*    SlottedComponent                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               ComponentIconMaterial                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Weight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionCraftingDeviceNode::OnComponentSlotted(class UOrionComponentItemDefinition* SlottedComponent, class UMaterialInterface* ComponentIconMaterial, int32 Weight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCraftingDeviceNode", "OnComponentSlotted");

	Params::OrionCraftingDeviceNode_OnComponentSlotted Parms{};

	Parms.SlottedComponent = SlottedComponent;
	Parms.ComponentIconMaterial = ComponentIconMaterial;
	Parms.Weight = Weight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionMcpComponentItem.GetInternalData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UOrionComponentItemDefinition*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionComponentItemDefinition* UOrionMcpComponentItem::GetInternalData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpComponentItem", "GetInternalData");

	Params::OrionMcpComponentItem_GetInternalData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionCustomStoreContentWidget.OnOfferSet
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FStoreOfferBP                    InOffer                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOrionCustomStoreContentWidget::OnOfferSet(const struct FStoreOfferBP& InOffer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCustomStoreContentWidget", "OnOfferSet");

	Params::OrionCustomStoreContentWidget_OnOfferSet Parms{};

	Parms.InOffer = std::move(InOffer);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionCustomStoreContentWidget.SetOffer
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FStoreOfferBP                    InOffer                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOrionCustomStoreContentWidget::SetOffer(const struct FStoreOfferBP& InOffer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionCustomStoreContentWidget", "SetOffer");

	Params::OrionCustomStoreContentWidget_SetOffer Parms{};

	Parms.InOffer = std::move(InOffer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionHeroTwinblastAnimInstance.OpenArmVent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   OpenTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionHeroTwinblastAnimInstance::OpenArmVent(float OpenTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionHeroTwinblastAnimInstance", "OpenArmVent");

	Params::OrionHeroTwinblastAnimInstance_OpenArmVent Parms{};

	Parms.OpenTime = OpenTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPedestalHero.OnPedestalActorTypeSet
// (Event, Protected, BlueprintEvent)
// Parameters:
// EPedestalActorType                      PedestalActorType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPedestalHero::OnPedestalActorTypeSet(EPedestalActorType PedestalActorType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPedestalHero", "OnPedestalActorTypeSet");

	Params::OrionPedestalHero_OnPedestalActorTypeSet Parms{};

	Parms.PedestalActorType = PedestalActorType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionPedestalHero.OnSkinChanged
// (Event, Protected, BlueprintEvent)

void AOrionPedestalHero::OnSkinChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPedestalHero", "OnSkinChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionDecorBanner.ActivateNow
// (Final, Native, Public, BlueprintCallable)

void AOrionDecorBanner::ActivateNow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDecorBanner", "ActivateNow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDecorBanner.CreateDecorBanner
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AOrionPlayerState_Game*           InPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBannerSpec                      BannerSpec                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    bShowPortrait                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecreateIfExists                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRemoveAtOnce                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionDecorBanner::CreateDecorBanner(class AOrionPlayerState_Game* InPlayerState, struct FBannerSpec* BannerSpec, bool bShowPortrait, bool bRecreateIfExists, bool bRemoveAtOnce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDecorBanner", "CreateDecorBanner");

	Params::OrionDecorBanner_CreateDecorBanner Parms{};

	Parms.InPlayerState = InPlayerState;
	Parms.bShowPortrait = bShowPortrait;
	Parms.bRecreateIfExists = bRecreateIfExists;
	Parms.bRemoveAtOnce = bRemoveAtOnce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (BannerSpec != nullptr)
		*BannerSpec = std::move(Parms.BannerSpec);

	return Parms.ReturnValue;
}


// Function OrionGame.OrionDecorBanner.DisableDecorBanner
// (Final, Native, Public, BlueprintCallable)

void AOrionDecorBanner::DisableDecorBanner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDecorBanner", "DisableDecorBanner");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDecorBanner.EnableDecorBanner
// (Final, Native, Public, BlueprintCallable)

void AOrionDecorBanner::EnableDecorBanner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDecorBanner", "EnableDecorBanner");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDecorBanner.RemoveDecorBanner
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bRemoveAtOnce                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionDecorBanner::RemoveDecorBanner(bool bRemoveAtOnce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDecorBanner", "RemoveDecorBanner");

	Params::OrionDecorBanner_RemoveDecorBanner Parms{};

	Parms.bRemoveAtOnce = bRemoveAtOnce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDecorBanner.SetBannerVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsVisible                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionDecorBanner::SetBannerVisibility(const bool bIsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDecorBanner", "SetBannerVisibility");

	Params::OrionDecorBanner_SetBannerVisibility Parms{};

	Parms.bIsVisible = bIsVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDecorBanner.GetSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AOrionDecorBanner::GetSlot() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDecorBanner", "GetSlot");

	Params::OrionDecorBanner_GetSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionDecorBanner.GetTeamNum
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionTeam                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOrionTeam AOrionDecorBanner::GetTeamNum() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDecorBanner", "GetTeamNum");

	Params::OrionDecorBanner_GetTeamNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionDecorBanner.IsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionDecorBanner::IsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDecorBanner", "IsEnabled");

	Params::OrionDecorBanner_IsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionDialogWidget.KillDialog
// (Final, Native, Public, BlueprintCallable)

void UOrionDialogWidget::KillDialog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDialogWidget", "KillDialog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDialogWidget.OnKill
// (Event, Protected, BlueprintEvent)

void UOrionDialogWidget::OnKill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDialogWidget", "OnKill");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionDialogWidget.OnShow
// (Event, Protected, BlueprintEvent)

void UOrionDialogWidget::OnShow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDialogWidget", "OnShow");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionDialogWidget.ProcessResult
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EOrionDialogResult                      DialogResult                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionDialogWidget::ProcessResult(EOrionDialogResult DialogResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDialogWidget", "ProcessResult");

	Params::OrionDialogWidget_ProcessResult Parms{};

	Parms.DialogResult = DialogResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDialogWidget.ShowDialog
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOrionDialogDescription          Description                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOrionDialogWidget::ShowDialog(const struct FOrionDialogDescription& Description)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDialogWidget", "ShowDialog");

	Params::OrionDialogWidget_ShowDialog Parms{};

	Parms.Description = std::move(Description);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDynamicWall_Segment.EndOverlapCallback
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionDynamicWall_Segment::EndOverlapCallback(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDynamicWall_Segment", "EndOverlapCallback");

	Params::OrionDynamicWall_Segment_EndOverlapCallback Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionDynamicWall_Segment.OnSegmentConstruction
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   ConstructionTime                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseMinHeight                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseMaxHeight                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionDynamicWall_Segment::OnSegmentConstruction(float ConstructionTime, float BaseMinHeight, float BaseMaxHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDynamicWall_Segment", "OnSegmentConstruction");

	Params::OrionDynamicWall_Segment_OnSegmentConstruction Parms{};

	Parms.ConstructionTime = ConstructionTime;
	Parms.BaseMinHeight = BaseMinHeight;
	Parms.BaseMaxHeight = BaseMaxHeight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionDynamicWall_Segment.OnSegmentDeconstruction
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   DeconstructionTime                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionDynamicWall_Segment::OnSegmentDeconstruction(float DeconstructionTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDynamicWall_Segment", "OnSegmentDeconstruction");

	Params::OrionDynamicWall_Segment_OnSegmentDeconstruction Parms{};

	Parms.DeconstructionTime = DeconstructionTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionDynamicWall_Segment.OnSegmentOverlapCharacter
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class AOrionChar*                       Character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PushDirection                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PushDistance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionDynamicWall_Segment::OnSegmentOverlapCharacter(const class AOrionChar* Character, const struct FVector& PushDirection, float PushDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionDynamicWall_Segment", "OnSegmentOverlapCharacter");

	Params::OrionDynamicWall_Segment_OnSegmentOverlapCharacter Parms{};

	Parms.Character = Character;
	Parms.PushDirection = std::move(PushDirection);
	Parms.PushDistance = PushDistance;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionGlobals.ReclaimWorldNiagaraSystem
// (Final, Native, Public)
// Parameters:
// class UNiagaraComponent*                PSC                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionGlobals::ReclaimWorldNiagaraSystem(class UNiagaraComponent* PSC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGlobals", "ReclaimWorldNiagaraSystem");

	Params::OrionGlobals_ReclaimWorldNiagaraSystem Parms{};

	Parms.PSC = PSC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGlobals.ReclaimWorldParticleSystem
// (Final, Native, Public)
// Parameters:
// class UParticleSystemComponent*         PSC                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionGlobals::ReclaimWorldParticleSystem(class UParticleSystemComponent* PSC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGlobals", "ReclaimWorldParticleSystem");

	Params::OrionGlobals_ReclaimWorldParticleSystem Parms{};

	Parms.PSC = PSC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionMcpGlyphItemDefinition.GetMaterial
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMaterialInterface*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInterface* UOrionMcpGlyphItemDefinition::GetMaterial() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpGlyphItemDefinition", "GetMaterial");

	Params::OrionMcpGlyphItemDefinition_GetMaterial Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionMcpGlyphItemDefinition.GetMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UStaticMesh*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMesh* UOrionMcpGlyphItemDefinition::GetMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpGlyphItemDefinition", "GetMesh");

	Params::OrionMcpGlyphItemDefinition_GetMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionFriendItem.GetDisplayName
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             FriendName                                             (Parm, OutParm, NativeAccessSpecifierPublic)

void UOrionFriendItem::GetDisplayName(class FText* FriendName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionFriendItem", "GetDisplayName");

	Params::OrionFriendItem_GetDisplayName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FriendName != nullptr)
		*FriendName = std::move(Parms.FriendName);
}


// Function OrionGame.OrionFriendItem.GetUniqueNetID
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FUniqueNetIdRepl                 FriendNetID                                            (Parm, OutParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionFriendItem::GetUniqueNetID(struct FUniqueNetIdRepl* FriendNetID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionFriendItem", "GetUniqueNetID");

	Params::OrionFriendItem_GetUniqueNetID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FriendNetID != nullptr)
		*FriendNetID = std::move(Parms.FriendNetID);
}


// Function OrionGame.OrionLightBox.EstablishActivatableContent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UOrionActivatableWidget*          NewContent                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionLightBox::EstablishActivatableContent(class UOrionActivatableWidget* NewContent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionLightBox", "EstablishActivatableContent");

	Params::OrionLightBox_EstablishActivatableContent Parms{};

	Parms.NewContent = NewContent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionLightBox.OnContentActivationChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bActivated                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionLightBox::OnContentActivationChanged(bool bActivated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionLightBox", "OnContentActivationChanged");

	Params::OrionLightBox_OnContentActivationChanged Parms{};

	Parms.bActivated = bActivated;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionLightBox.OverrideContentActivation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bActivate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionLightBox::OverrideContentActivation(bool bActivate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionLightBox", "OverrideContentActivation");

	Params::OrionLightBox_OverrideContentActivation Parms{};

	Parms.bActivate = bActivate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionLightBox.IsContentActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionLightBox::IsContentActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionLightBox", "IsContentActive");

	Params::OrionLightBox_IsContentActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameMode_Arcade_Base.BP_InitArcadePlayerState
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AOrionPlayerState_Arcade*         PlayerState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsBot                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsFriendly                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameMode_Arcade_Base::BP_InitArcadePlayerState(class AOrionPlayerState_Arcade* PlayerState, bool bIsBot, bool bIsFriendly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_Arcade_Base", "BP_InitArcadePlayerState");

	Params::OrionGameMode_Arcade_Base_BP_InitArcadePlayerState Parms{};

	Parms.PlayerState = PlayerState;
	Parms.bIsBot = bIsBot;
	Parms.bIsFriendly = bIsFriendly;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionGameMode_Arcade_Base.OnRoundState_InRound
// (Native, Event, Protected, BlueprintEvent)

void AOrionGameMode_Arcade_Base::OnRoundState_InRound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_Arcade_Base", "OnRoundState_InRound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameMode_Arcade_Base.OnRoundState_Overtime
// (Native, Event, Protected, BlueprintEvent)

void AOrionGameMode_Arcade_Base::OnRoundState_Overtime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_Arcade_Base", "OnRoundState_Overtime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameMode_Arcade_Base.OnRoundState_PostRound
// (Native, Event, Protected, BlueprintEvent)

void AOrionGameMode_Arcade_Base::OnRoundState_PostRound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_Arcade_Base", "OnRoundState_PostRound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameMode_Arcade_Base.OnRoundState_PreMatch
// (Native, Event, Protected, BlueprintEvent)

void AOrionGameMode_Arcade_Base::OnRoundState_PreMatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_Arcade_Base", "OnRoundState_PreMatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameMode_Arcade_Base.OnRoundState_PreRound
// (Native, Event, Protected, BlueprintEvent)

void AOrionGameMode_Arcade_Base::OnRoundState_PreRound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_Arcade_Base", "OnRoundState_PreRound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameMode_Arcade_Base.OnRoundState_Restarting
// (Native, Event, Protected, BlueprintEvent)

void AOrionGameMode_Arcade_Base::OnRoundState_Restarting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_Arcade_Base", "OnRoundState_Restarting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameMode_Arcade_Base.OnRoundState_RoundsOver
// (Native, Event, Protected, BlueprintEvent)

void AOrionGameMode_Arcade_Base::OnRoundState_RoundsOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_Arcade_Base", "OnRoundState_RoundsOver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameMode_Arcade_Base.OnRoundState_WaitingForRecall
// (Native, Event, Protected, BlueprintEvent)

void AOrionGameMode_Arcade_Base::OnRoundState_WaitingForRecall()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_Arcade_Base", "OnRoundState_WaitingForRecall");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameMode_Arcade_Base.OnRoundStateChange
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// EArcadeRoundPhase                       NewRoundState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameMode_Arcade_Base::OnRoundStateChange(EArcadeRoundPhase NewRoundState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_Arcade_Base", "OnRoundStateChange");

	Params::OrionGameMode_Arcade_Base_OnRoundStateChange Parms{};

	Parms.NewRoundState = NewRoundState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameMode_Arcade_Base.PausePlayer
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class AOrionPlayerState_Arcade*         PlayerState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldPause                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameMode_Arcade_Base::PausePlayer(class AOrionPlayerState_Arcade* PlayerState, bool bShouldPause)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_Arcade_Base", "PausePlayer");

	Params::OrionGameMode_Arcade_Base_PausePlayer Parms{};

	Parms.PlayerState = PlayerState;
	Parms.bShouldPause = bShouldPause;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameMode_Arcade_Base.GetGameStateArcade
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AOrionGameState_Arcade*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOrionGameState_Arcade* AOrionGameMode_Arcade_Base::GetGameStateArcade() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameMode_Arcade_Base", "GetGameStateArcade");

	Params::OrionGameMode_Arcade_Base_GetGameStateArcade Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionMatchDataLoader.TimerCallback
// (Final, Native, Public)

void UOrionMatchDataLoader::TimerCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMatchDataLoader", "TimerCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameplayCard.OnRep_AdjustedCardCost
// (Final, Native, Private)

void UOrionGameplayCard::OnRep_AdjustedCardCost()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayCard", "OnRep_AdjustedCardCost");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionLobbyBuilder.OnEnterState_CancelSearchPass
// (Final, Native, Private)

void UOrionLobbyBuilder::OnEnterState_CancelSearchPass()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionLobbyBuilder", "OnEnterState_CancelSearchPass");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionLobbyBuilder.OnEnterState_Finished
// (Final, Native, Private)

void UOrionLobbyBuilder::OnEnterState_Finished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionLobbyBuilder", "OnEnterState_Finished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionLobbyBuilder.OnEnterState_HandlingError
// (Final, Native, Private)

void UOrionLobbyBuilder::OnEnterState_HandlingError()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionLobbyBuilder", "OnEnterState_HandlingError");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionLobbyBuilder.OnEnterState_LeavingLobby
// (Final, Native, Private)

void UOrionLobbyBuilder::OnEnterState_LeavingLobby()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionLobbyBuilder", "OnEnterState_LeavingLobby");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionLobbyBuilder.OnEnterState_PatchCheck
// (Final, Native, Private)

void UOrionLobbyBuilder::OnEnterState_PatchCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionLobbyBuilder", "OnEnterState_PatchCheck");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionLobbyBuilder.OnEnterState_ReadyingUp
// (Final, Native, Private)

void UOrionLobbyBuilder::OnEnterState_ReadyingUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionLobbyBuilder", "OnEnterState_ReadyingUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionLobbyBuilder.OnEnterState_ReconnectToBeacon
// (Final, Native, Private)

void UOrionLobbyBuilder::OnEnterState_ReconnectToBeacon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionLobbyBuilder", "OnEnterState_ReconnectToBeacon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionLobbyBuilder.OnEnterState_RetrySearch
// (Final, Native, Private)

void UOrionLobbyBuilder::OnEnterState_RetrySearch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionLobbyBuilder", "OnEnterState_RetrySearch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionLobbyBuilder.OnEnterState_Searching
// (Final, Native, Private)

void UOrionLobbyBuilder::OnEnterState_Searching()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionLobbyBuilder", "OnEnterState_Searching");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionLobbyBuilder.OnEnterState_Starting
// (Final, Native, Private)

void UOrionLobbyBuilder::OnEnterState_Starting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionLobbyBuilder", "OnEnterState_Starting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionLobbyBuilder.OnEnterState_TravellingToMatch
// (Final, Native, Private)

void UOrionLobbyBuilder::OnEnterState_TravellingToMatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionLobbyBuilder", "OnEnterState_TravellingToMatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionLobbyBuilder.OnEnterState_WaitingForPlayers
// (Final, Native, Private)

void UOrionLobbyBuilder::OnEnterState_WaitingForPlayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionLobbyBuilder", "OnEnterState_WaitingForPlayers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionLobbyBuilder.OnExitState_CancelSearchPass
// (Final, Native, Private)

void UOrionLobbyBuilder::OnExitState_CancelSearchPass()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionLobbyBuilder", "OnExitState_CancelSearchPass");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionLobbyBuilder.OnExitState_Finished
// (Final, Native, Private)

void UOrionLobbyBuilder::OnExitState_Finished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionLobbyBuilder", "OnExitState_Finished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionLobbyBuilder.OnExitState_HandlingError
// (Final, Native, Private)

void UOrionLobbyBuilder::OnExitState_HandlingError()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionLobbyBuilder", "OnExitState_HandlingError");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionLobbyBuilder.OnExitState_LeavingLobby
// (Final, Native, Private)

void UOrionLobbyBuilder::OnExitState_LeavingLobby()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionLobbyBuilder", "OnExitState_LeavingLobby");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionLobbyBuilder.OnExitState_PatchCheck
// (Final, Native, Private)

void UOrionLobbyBuilder::OnExitState_PatchCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionLobbyBuilder", "OnExitState_PatchCheck");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionLobbyBuilder.OnExitState_ReadyingUp
// (Final, Native, Private)

void UOrionLobbyBuilder::OnExitState_ReadyingUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionLobbyBuilder", "OnExitState_ReadyingUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionLobbyBuilder.OnExitState_ReconnectToBeacon
// (Final, Native, Private)

void UOrionLobbyBuilder::OnExitState_ReconnectToBeacon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionLobbyBuilder", "OnExitState_ReconnectToBeacon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionLobbyBuilder.OnExitState_RetrySearch
// (Final, Native, Private)

void UOrionLobbyBuilder::OnExitState_RetrySearch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionLobbyBuilder", "OnExitState_RetrySearch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionLobbyBuilder.OnExitState_Searching
// (Final, Native, Private)

void UOrionLobbyBuilder::OnExitState_Searching()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionLobbyBuilder", "OnExitState_Searching");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionLobbyBuilder.OnExitState_Starting
// (Final, Native, Private)

void UOrionLobbyBuilder::OnExitState_Starting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionLobbyBuilder", "OnExitState_Starting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionLobbyBuilder.OnExitState_TravellingToMatch
// (Final, Native, Private)

void UOrionLobbyBuilder::OnExitState_TravellingToMatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionLobbyBuilder", "OnExitState_TravellingToMatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionLobbyBuilder.OnExitState_WaitingForPlayers
// (Final, Native, Private)

void UOrionLobbyBuilder::OnExitState_WaitingForPlayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionLobbyBuilder", "OnExitState_WaitingForPlayers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameplayCue_ItemizationOverHead.GetSequencerForCardInteraction
// (Event, Public, BlueprintEvent)
// Parameters:
// EOrionItemState                         SequencerType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorSequencePlayer*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActorSequencePlayer* AOrionGameplayCue_ItemizationOverHead::GetSequencerForCardInteraction(EOrionItemState SequencerType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayCue_ItemizationOverHead", "GetSequencerForCardInteraction");

	Params::OrionGameplayCue_ItemizationOverHead_GetSequencerForCardInteraction Parms{};

	Parms.SequencerType = SequencerType;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameplayCue_ItemizationOverHead.HandleSequencerEnded
// (Final, Native, Protected)

void AOrionGameplayCue_ItemizationOverHead::HandleSequencerEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayCue_ItemizationOverHead", "HandleSequencerEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameplayCueNotify_Burst.OnBurst
// (Native, Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class AActor*                           MyTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Parameters                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UParticleSystemComponent*         BurstParticleSystem                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UParticleSystemComponent*> AdditionalParticleSystems                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UCameraShake*                     BurstCameraShakeInstance                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADecalActor*                      BurstDecalInstance                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraComponent*                BurstNiagaraParticleSystem                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UNiagaraComponent*>        AdditionalNiagaraParticleSystems                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UOrionGameplayCueNotify_Burst::OnBurst(class AActor* MyTarget, const struct FGameplayCueParameters& Parameters, class UParticleSystemComponent* BurstParticleSystem, const TArray<class UParticleSystemComponent*>& AdditionalParticleSystems, class UCameraShake* BurstCameraShakeInstance, class ADecalActor* BurstDecalInstance, class UNiagaraComponent* BurstNiagaraParticleSystem, const TArray<class UNiagaraComponent*>& AdditionalNiagaraParticleSystems) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayCueNotify_Burst", "OnBurst");

	Params::OrionGameplayCueNotify_Burst_OnBurst Parms{};

	Parms.MyTarget = MyTarget;
	Parms.Parameters = std::move(Parameters);
	Parms.BurstParticleSystem = BurstParticleSystem;
	Parms.AdditionalParticleSystems = std::move(AdditionalParticleSystems);
	Parms.BurstCameraShakeInstance = BurstCameraShakeInstance;
	Parms.BurstDecalInstance = BurstDecalInstance;
	Parms.BurstNiagaraParticleSystem = BurstNiagaraParticleSystem;
	Parms.AdditionalNiagaraParticleSystems = std::move(AdditionalNiagaraParticleSystems);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionMcpBannerItemDefinition.GetAttachToParent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionMcpBannerItemDefinition::GetAttachToParent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpBannerItemDefinition", "GetAttachToParent");

	Params::OrionMcpBannerItemDefinition_GetAttachToParent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionMcpBannerItemDefinition.GetBannerType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const EOrionBannerType                  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const EOrionBannerType UOrionMcpBannerItemDefinition::GetBannerType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpBannerItemDefinition", "GetBannerType");

	Params::OrionMcpBannerItemDefinition_GetBannerType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionMcpBannerItemDefinition.GetDecalSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector                    ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FVector UOrionMcpBannerItemDefinition::GetDecalSize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpBannerItemDefinition", "GetDecalSize");

	Params::OrionMcpBannerItemDefinition_GetDecalSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionMcpBannerItemDefinition.GetFXMaterial
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMaterialInterface*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInterface* UOrionMcpBannerItemDefinition::GetFXMaterial() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpBannerItemDefinition", "GetFXMaterial");

	Params::OrionMcpBannerItemDefinition_GetFXMaterial Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionMcpBannerItemDefinition.GetFXParticle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UParticleSystem*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UParticleSystem* UOrionMcpBannerItemDefinition::GetFXParticle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpBannerItemDefinition", "GetFXParticle");

	Params::OrionMcpBannerItemDefinition_GetFXParticle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionMcpBannerItemDefinition.GetFXSound
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USoundBase*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USoundBase* UOrionMcpBannerItemDefinition::GetFXSound() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpBannerItemDefinition", "GetFXSound");

	Params::OrionMcpBannerItemDefinition_GetFXSound Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionMcpBannerItemDefinition.GetSockets
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FBannerSocketEntry> ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FBannerSocketEntry> UOrionMcpBannerItemDefinition::GetSockets() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpBannerItemDefinition", "GetSockets");

	Params::OrionMcpBannerItemDefinition_GetSockets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionMcpBannerItemDefinition.GetStaticMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UStaticMesh*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMesh* UOrionMcpBannerItemDefinition::GetStaticMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpBannerItemDefinition", "GetStaticMesh");

	Params::OrionMcpBannerItemDefinition_GetStaticMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameplaySet.OnRep_DexterityPips
// (Final, Native, Private)

void UOrionGameplaySet::OnRep_DexterityPips()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplaySet", "OnRep_DexterityPips");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameplaySet.OnRep_IntellectPips
// (Final, Native, Private)

void UOrionGameplaySet::OnRep_IntellectPips()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplaySet", "OnRep_IntellectPips");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameplaySet.OnRep_ReservedDexterityPips
// (Final, Native, Private)

void UOrionGameplaySet::OnRep_ReservedDexterityPips()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplaySet", "OnRep_ReservedDexterityPips");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameplaySet.OnRep_ReservedIntellectPips
// (Final, Native, Private)

void UOrionGameplaySet::OnRep_ReservedIntellectPips()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplaySet", "OnRep_ReservedIntellectPips");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameplaySet.OnRep_ReservedVitalityPips
// (Final, Native, Private)

void UOrionGameplaySet::OnRep_ReservedVitalityPips()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplaySet", "OnRep_ReservedVitalityPips");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameplaySet.OnRep_VitalityPips
// (Final, Native, Private)

void UOrionGameplaySet::OnRep_VitalityPips()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplaySet", "OnRep_VitalityPips");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.BlueprintGameplayStatsLibrary.EqualEqual_GameplayStatTagGameplayStatTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayStatTag                 A                                                      (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayStatTag                 B                                                      (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintGameplayStatsLibrary::EqualEqual_GameplayStatTagGameplayStatTag(const struct FGameplayStatTag& A, const struct FGameplayStatTag& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintGameplayStatsLibrary", "EqualEqual_GameplayStatTagGameplayStatTag");

	Params::BlueprintGameplayStatsLibrary_EqualEqual_GameplayStatTagGameplayStatTag Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.BlueprintGameplayStatsLibrary.NotEqual_GameplayStatTagGameplayStatTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayStatTag                 A                                                      (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayStatTag                 B                                                      (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintGameplayStatsLibrary::NotEqual_GameplayStatTagGameplayStatTag(const struct FGameplayStatTag& A, const struct FGameplayStatTag& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintGameplayStatsLibrary", "NotEqual_GameplayStatTagGameplayStatTag");

	Params::BlueprintGameplayStatsLibrary_NotEqual_GameplayStatTagGameplayStatTag Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameplayVolume.ApplyEffects
// (Native, Public, BlueprintCallable)

void AOrionGameplayVolume::ApplyEffects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayVolume", "ApplyEffects");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameplayVolume.CanStillApplyEffectsToTargets
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionGameplayVolume::CanStillApplyEffectsToTargets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayVolume", "CanStillApplyEffectsToTargets");

	Params::OrionGameplayVolume_CanStillApplyEffectsToTargets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameplayVolume.GetNumAppliedEffectsLeftToApply
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AOrionGameplayVolume::GetNumAppliedEffectsLeftToApply()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayVolume", "GetNumAppliedEffectsLeftToApply");

	Params::OrionGameplayVolume_GetNumAppliedEffectsLeftToApply Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameplayVolume.HandleMatchStarted
// (Final, Native, Public)

void AOrionGameplayVolume::HandleMatchStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayVolume", "HandleMatchStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameplayVolume.K2_OnBeginOverlapCallback
// (BlueprintAuthorityOnly, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AOrionGameplayVolume::K2_OnBeginOverlapCallback(class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayVolume", "K2_OnBeginOverlapCallback");

	Params::OrionGameplayVolume_K2_OnBeginOverlapCallback Parms{};

	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionGameplayVolume.K2_OnEndOverlapCallback
// (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameplayVolume::K2_OnEndOverlapCallback(class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayVolume", "K2_OnEndOverlapCallback");

	Params::OrionGameplayVolume_K2_OnEndOverlapCallback Parms{};

	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionGameplayVolume.OnBeginOverlapCallback
// (Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AOrionGameplayVolume::OnBeginOverlapCallback(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayVolume", "OnBeginOverlapCallback");

	Params::OrionGameplayVolume_OnBeginOverlapCallback Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameplayVolume.OnEndOverlapCallback
// (Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameplayVolume::OnEndOverlapCallback(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayVolume", "OnEndOverlapCallback");

	Params::OrionGameplayVolume_OnEndOverlapCallback Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameplayVolume.OnRep_Scale
// (Final, Native, Public)

void AOrionGameplayVolume::OnRep_Scale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameplayVolume", "OnRep_Scale");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionInputVisualizer.SetSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionWidgetStyleSize                   InSize                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionInputVisualizer::SetSize(EOrionWidgetStyleSize InSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionInputVisualizer", "SetSize");

	Params::OrionInputVisualizer_SetSize Parms{};

	Parms.InSize = InSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionInputVisualizer.ShowAbilityBinding
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionAbilityBinding                    AbilityBinding                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionInputVisualizer::ShowAbilityBinding(EOrionAbilityBinding AbilityBinding)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionInputVisualizer", "ShowAbilityBinding");

	Params::OrionInputVisualizer_ShowAbilityBinding Parms{};

	Parms.AbilityBinding = AbilityBinding;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionInputVisualizer.ShowInputAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InActionName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionInputVisualizer::ShowInputAction(class FName InActionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionInputVisualizer", "ShowInputAction");

	Params::OrionInputVisualizer_ShowInputAction Parms{};

	Parms.InActionName = InActionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionInputVisualizer.ShowInputAxis
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InAxisName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionInputVisualizer::ShowInputAxis(class FName InAxisName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionInputVisualizer", "ShowInputAxis");

	Params::OrionInputVisualizer_ShowInputAxis Parms{};

	Parms.InAxisName = InAxisName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionInputVisualizer.ShowSpecificKey
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionInputVisualizer::ShowSpecificKey(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionInputVisualizer", "ShowSpecificKey");

	Params::OrionInputVisualizer_ShowSpecificKey Parms{};

	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionJungleRefinery.GatherResources
// (Final, Native, Public)
// Parameters:
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionJungleRefinery::GatherResources(int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionJungleRefinery", "GatherResources");

	Params::OrionJungleRefinery_GatherResources Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionJungleRefinery.GetCurrentCachedResources
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionJungleRefinery::GetCurrentCachedResources()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionJungleRefinery", "GetCurrentCachedResources");

	Params::OrionJungleRefinery_GetCurrentCachedResources Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionJungleRefinery.GetCurrentResources
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionJungleRefinery::GetCurrentResources()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionJungleRefinery", "GetCurrentResources");

	Params::OrionJungleRefinery_GetCurrentResources Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionJungleRefinery.GetNextRefinmentTimeLeft
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionJungleRefinery::GetNextRefinmentTimeLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionJungleRefinery", "GetNextRefinmentTimeLeft");

	Params::OrionJungleRefinery_GetNextRefinmentTimeLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionJungleRefinery.HandleJungleCampDeath
// (Final, Native, Protected)
// Parameters:
// class AOrionChar*                       DeadChar                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      Killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionJungleRefinery::HandleJungleCampDeath(class AOrionChar* DeadChar, class AController* Killer, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionJungleRefinery", "HandleJungleCampDeath");

	Params::OrionJungleRefinery_HandleJungleCampDeath Parms{};

	Parms.DeadChar = DeadChar;
	Parms.Killer = Killer;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionJungleRefinery.HandleMatchEnded
// (Final, Native, Protected)

void AOrionJungleRefinery::HandleMatchEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionJungleRefinery", "HandleMatchEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionJungleRefinery.HandleMatchStarted
// (Final, Native, Protected)

void AOrionJungleRefinery::HandleMatchStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionJungleRefinery", "HandleMatchStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_MOBA.DebugCapsuleSendToAll
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// struct FVector                          Center                                                 (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                            Rotation                                               (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FColor                           Color                                                  (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPersistentLines                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LifeTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   DepthPriority                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thickness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameState_MOBA::DebugCapsuleSendToAll(const struct FVector& Center, float HalfHeight, float Radius, const struct FQuat& Rotation, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "DebugCapsuleSendToAll");

	Params::OrionGameState_MOBA_DebugCapsuleSendToAll Parms{};

	Parms.Center = std::move(Center);
	Parms.HalfHeight = HalfHeight;
	Parms.Radius = Radius;
	Parms.Rotation = std::move(Rotation);
	Parms.Color = std::move(Color);
	Parms.bPersistentLines = bPersistentLines;
	Parms.LifeTime = LifeTime;
	Parms.DepthPriority = DepthPriority;
	Parms.Thickness = Thickness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_MOBA.DebugLineSendToAll
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// struct FVector                          LineStart                                              (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LineEnd                                                (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           Color                                                  (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPersistentLines                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LifeTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   DepthPriority                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thickness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameState_MOBA::DebugLineSendToAll(const struct FVector& LineStart, const struct FVector& LineEnd, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "DebugLineSendToAll");

	Params::OrionGameState_MOBA_DebugLineSendToAll Parms{};

	Parms.LineStart = std::move(LineStart);
	Parms.LineEnd = std::move(LineEnd);
	Parms.Color = std::move(Color);
	Parms.bPersistentLines = bPersistentLines;
	Parms.LifeTime = LifeTime;
	Parms.DepthPriority = DepthPriority;
	Parms.Thickness = Thickness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_MOBA.DebugSphereSendToAll
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// struct FVector                          Center                                                 (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Segments                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           Color                                                  (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPersistentLines                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LifeTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   DepthPriority                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thickness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameState_MOBA::DebugSphereSendToAll(const struct FVector& Center, float Radius, int32 Segments, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "DebugSphereSendToAll");

	Params::OrionGameState_MOBA_DebugSphereSendToAll Parms{};

	Parms.Center = std::move(Center);
	Parms.Radius = Radius;
	Parms.Segments = Segments;
	Parms.Color = std::move(Color);
	Parms.bPersistentLines = bPersistentLines;
	Parms.LifeTime = LifeTime;
	Parms.DepthPriority = DepthPriority;
	Parms.Thickness = Thickness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_MOBA.DecrementMatchTeamScore
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionTeam                              TeamNum                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameState_MOBA::DecrementMatchTeamScore(EOrionTeam TeamNum, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "DecrementMatchTeamScore");

	Params::OrionGameState_MOBA_DecrementMatchTeamScore Parms{};

	Parms.TeamNum = TeamNum;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_MOBA.DoesMatchDisplayScore
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionGameState_MOBA::DoesMatchDisplayScore()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "DoesMatchDisplayScore");

	Params::OrionGameState_MOBA_DoesMatchDisplayScore Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameState_MOBA.DoesMatchDisplayTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionGameState_MOBA::DoesMatchDisplayTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "DoesMatchDisplayTime");

	Params::OrionGameState_MOBA_DoesMatchDisplayTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameState_MOBA.EndMatchClearPlaySpace
// (Final, Native, Public, BlueprintCallable)

void AOrionGameState_MOBA::EndMatchClearPlaySpace()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "EndMatchClearPlaySpace");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_MOBA.GetGameModeRecallTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionGameState_MOBA::GetGameModeRecallTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "GetGameModeRecallTime");

	Params::OrionGameState_MOBA_GetGameModeRecallTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameState_MOBA.GetGameModeType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EGameModeType                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGameModeType AOrionGameState_MOBA::GetGameModeType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "GetGameModeType");

	Params::OrionGameState_MOBA_GetGameModeType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameState_MOBA.GetIsMatchScoreBased
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionGameState_MOBA::GetIsMatchScoreBased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "GetIsMatchScoreBased");

	Params::OrionGameState_MOBA_GetIsMatchScoreBased Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameState_MOBA.GetIsMatchTimeBased
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionGameState_MOBA::GetIsMatchTimeBased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "GetIsMatchTimeBased");

	Params::OrionGameState_MOBA_GetIsMatchTimeBased Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameState_MOBA.GetMatchScoreLimit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AOrionGameState_MOBA::GetMatchScoreLimit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "GetMatchScoreLimit");

	Params::OrionGameState_MOBA_GetMatchScoreLimit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameState_MOBA.GetMatchScoreUpdateTick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionGameState_MOBA::GetMatchScoreUpdateTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "GetMatchScoreUpdateTick");

	Params::OrionGameState_MOBA_GetMatchScoreUpdateTick Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameState_MOBA.GetMatchStartingScore
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AOrionGameState_MOBA::GetMatchStartingScore()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "GetMatchStartingScore");

	Params::OrionGameState_MOBA_GetMatchStartingScore Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameState_MOBA.GetMatchTeamScore
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionTeam                              TeamNum                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AOrionGameState_MOBA::GetMatchTeamScore(EOrionTeam TeamNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "GetMatchTeamScore");

	Params::OrionGameState_MOBA_GetMatchTeamScore Parms{};

	Parms.TeamNum = TeamNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameState_MOBA.GetMatchTimeLimit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionGameState_MOBA::GetMatchTimeLimit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "GetMatchTimeLimit");

	Params::OrionGameState_MOBA_GetMatchTimeLimit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameState_MOBA.GetMatchUpdateScoreOnTickValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AOrionGameState_MOBA::GetMatchUpdateScoreOnTickValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "GetMatchUpdateScoreOnTickValue");

	Params::OrionGameState_MOBA_GetMatchUpdateScoreOnTickValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameState_MOBA.GetTeamWithHighestScore
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionTeam                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOrionTeam AOrionGameState_MOBA::GetTeamWithHighestScore()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "GetTeamWithHighestScore");

	Params::OrionGameState_MOBA_GetTeamWithHighestScore Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameState_MOBA.GetVictoryAbilitySystemFor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMatchEndTeamPlacement                  VictoryPlayerIndex                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilitySystemComponent*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilitySystemComponent* AOrionGameState_MOBA::GetVictoryAbilitySystemFor(EMatchEndTeamPlacement VictoryPlayerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "GetVictoryAbilitySystemFor");

	Params::OrionGameState_MOBA_GetVictoryAbilitySystemFor Parms{};

	Parms.VictoryPlayerIndex = VictoryPlayerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameState_MOBA.GetVictoryPawnFor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMatchEndTeamPlacement                  VictoryPlayerIndex                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* AOrionGameState_MOBA::GetVictoryPawnFor(EMatchEndTeamPlacement VictoryPlayerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "GetVictoryPawnFor");

	Params::OrionGameState_MOBA_GetVictoryPawnFor Parms{};

	Parms.VictoryPlayerIndex = VictoryPlayerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameState_MOBA.GiveTeamCardXP
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EOrionTeam                              InTeam                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   XP                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOrionPlayerState_Game*           Earner                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            GrantedTags                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AOrionGameState_MOBA::GiveTeamCardXP(EOrionTeam InTeam, float XP, class AOrionPlayerState_Game* Earner, const struct FGameplayTagContainer& GrantedTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "GiveTeamCardXP");

	Params::OrionGameState_MOBA_GiveTeamCardXP Parms{};

	Parms.InTeam = InTeam;
	Parms.XP = XP;
	Parms.Earner = Earner;
	Parms.GrantedTags = std::move(GrantedTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_MOBA.HideVictoryActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMatchEndTeamPlacement                  VictoryPlayerIndex                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameState_MOBA::HideVictoryActor(EMatchEndTeamPlacement VictoryPlayerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "HideVictoryActor");

	Params::OrionGameState_MOBA_HideVictoryActor Parms{};

	Parms.VictoryPlayerIndex = VictoryPlayerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_MOBA.HideVictoryBanner
// (Final, Native, Public, BlueprintCallable)

void AOrionGameState_MOBA::HideVictoryBanner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "HideVictoryBanner");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_MOBA.IncrementMatchTeamScore
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionTeam                              TeamNum                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameState_MOBA::IncrementMatchTeamScore(EOrionTeam TeamNum, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "IncrementMatchTeamScore");

	Params::OrionGameState_MOBA_IncrementMatchTeamScore Parms{};

	Parms.TeamNum = TeamNum;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_MOBA.MatchEndSequenceStopped
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ViewTarget                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameState_MOBA::MatchEndSequenceStopped(class AActor* ViewTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "MatchEndSequenceStopped");

	Params::OrionGameState_MOBA_MatchEndSequenceStopped Parms{};

	Parms.ViewTarget = ViewTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_MOBA.MatchVictoryEventHasEnded
// (Final, Native, Public, BlueprintCallable)

void AOrionGameState_MOBA::MatchVictoryEventHasEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "MatchVictoryEventHasEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_MOBA.MulticastNotifyAIKilled
// (Final, Net, Native, Event, NetMulticast, Private)
// Parameters:
// class AOrionCharAI*                     KilledAI                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOrionPlayerState_Game*           KillerPlayer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameState_MOBA::MulticastNotifyAIKilled(class AOrionCharAI* KilledAI, class AOrionPlayerState_Game* KillerPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "MulticastNotifyAIKilled");

	Params::OrionGameState_MOBA_MulticastNotifyAIKilled Parms{};

	Parms.KilledAI = KilledAI;
	Parms.KillerPlayer = KillerPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_MOBA.MulticastNotifyPlayerKilled
// (Final, Net, Native, Event, NetMulticast, Private)
// Parameters:
// class AOrionPlayerState_Game*           KilledPlayer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           KillerActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameState_MOBA::MulticastNotifyPlayerKilled(class AOrionPlayerState_Game* KilledPlayer, class AActor* KillerActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "MulticastNotifyPlayerKilled");

	Params::OrionGameState_MOBA_MulticastNotifyPlayerKilled Parms{};

	Parms.KilledPlayer = KilledPlayer;
	Parms.KillerActor = KillerActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_MOBA.OnGameReady
// (Native, Event, Public, BlueprintEvent)

void AOrionGameState_MOBA::OnGameReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "OnGameReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_MOBA.OnRep_MatchTeamScore
// (Net, NetReliable, Native, Event, Protected, NetClient)

void AOrionGameState_MOBA::OnRep_MatchTeamScore()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "OnRep_MatchTeamScore");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_MOBA.OnRep_Slomo
// (Final, Native, Protected)

void AOrionGameState_MOBA::OnRep_Slomo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "OnRep_Slomo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_MOBA.OnRep_VisionManger
// (Final, Native, Private)

void AOrionGameState_MOBA::OnRep_VisionManger()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "OnRep_VisionManger");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_MOBA.OnRep_WinningTeam
// (Final, Native, Protected)

void AOrionGameState_MOBA::OnRep_WinningTeam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "OnRep_WinningTeam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_MOBA.PlaceWinningActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           PlacementSpot                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMatchEndTeamPlacement                  VictoryPlayerIndex                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameState_MOBA::PlaceWinningActor(class AActor* PlacementSpot, EMatchEndTeamPlacement VictoryPlayerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "PlaceWinningActor");

	Params::OrionGameState_MOBA_PlaceWinningActor Parms{};

	Parms.PlacementSpot = PlacementSpot;
	Parms.VictoryPlayerIndex = VictoryPlayerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_MOBA.PlayVictoryAnimOn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMatchEndTeamPlacement                  VictoryPlayerIndex                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameState_MOBA::PlayVictoryAnimOn(EMatchEndTeamPlacement VictoryPlayerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "PlayVictoryAnimOn");

	Params::OrionGameState_MOBA_PlayVictoryAnimOn Parms{};

	Parms.VictoryPlayerIndex = VictoryPlayerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_MOBA.SetEndMatchSequence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULevelSequencePlayer*             InSequence                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameState_MOBA::SetEndMatchSequence(class ULevelSequencePlayer* InSequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "SetEndMatchSequence");

	Params::OrionGameState_MOBA_SetEndMatchSequence Parms{};

	Parms.InSequence = InSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_MOBA.SetMatchTeamScore
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionTeam                              TeamNum                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewScore                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameState_MOBA::SetMatchTeamScore(EOrionTeam TeamNum, int32 NewScore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "SetMatchTeamScore");

	Params::OrionGameState_MOBA_SetMatchTeamScore Parms{};

	Parms.TeamNum = TeamNum;
	Parms.NewScore = NewScore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_MOBA.StopVictoryAnimOn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMatchEndTeamPlacement                  VictoryPlayerIndex                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameState_MOBA::StopVictoryAnimOn(EMatchEndTeamPlacement VictoryPlayerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "StopVictoryAnimOn");

	Params::OrionGameState_MOBA_StopVictoryAnimOn Parms{};

	Parms.VictoryPlayerIndex = VictoryPlayerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_MOBA.UpdatePlayerRecorder
// (Final, Native, Public)

void AOrionGameState_MOBA::UpdatePlayerRecorder()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "UpdatePlayerRecorder");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_MOBA.GetWinningTeam
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionTeam                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOrionTeam AOrionGameState_MOBA::GetWinningTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA", "GetWinningTeam");

	Params::OrionGameState_MOBA_GetWinningTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameState_Arcade.OnRep_RoundState
// (Final, Native, Protected)
// Parameters:
// struct FArcadeRoundState                OldStateRoundState                                     (Parm, NoDestructor, NativeAccessSpecifierPublic)

void AOrionGameState_Arcade::OnRep_RoundState(const struct FArcadeRoundState& OldStateRoundState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_Arcade", "OnRep_RoundState");

	Params::OrionGameState_Arcade_OnRep_RoundState Parms{};

	Parms.OldStateRoundState = std::move(OldStateRoundState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_Arcade.OnRep_StageIndex
// (Final, Native, Protected)

void AOrionGameState_Arcade::OnRep_StageIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_Arcade", "OnRep_StageIndex");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_Arcade.OnRoundState_InRound
// (Native, Event, Protected, BlueprintEvent)

void AOrionGameState_Arcade::OnRoundState_InRound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_Arcade", "OnRoundState_InRound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_Arcade.OnRoundState_Overtime
// (Native, Event, Protected, BlueprintEvent)

void AOrionGameState_Arcade::OnRoundState_Overtime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_Arcade", "OnRoundState_Overtime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_Arcade.OnRoundState_PostRound
// (Native, Event, Protected, BlueprintEvent)

void AOrionGameState_Arcade::OnRoundState_PostRound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_Arcade", "OnRoundState_PostRound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_Arcade.OnRoundState_PreMatch
// (Native, Event, Protected, BlueprintEvent)

void AOrionGameState_Arcade::OnRoundState_PreMatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_Arcade", "OnRoundState_PreMatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_Arcade.OnRoundState_PreRound
// (Native, Event, Protected, BlueprintEvent)

void AOrionGameState_Arcade::OnRoundState_PreRound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_Arcade", "OnRoundState_PreRound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_Arcade.OnRoundState_Restarting
// (Native, Event, Protected, BlueprintEvent)

void AOrionGameState_Arcade::OnRoundState_Restarting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_Arcade", "OnRoundState_Restarting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_Arcade.OnRoundState_RoundsOver
// (Native, Event, Protected, BlueprintEvent)

void AOrionGameState_Arcade::OnRoundState_RoundsOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_Arcade", "OnRoundState_RoundsOver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_Arcade.OnRoundState_WaitingForRecall
// (Native, Event, Protected, BlueprintEvent)

void AOrionGameState_Arcade::OnRoundState_WaitingForRecall()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_Arcade", "OnRoundState_WaitingForRecall");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_Arcade.OnRoundStateChange
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// EArcadeRoundPhase                       NewRoundState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGameState_Arcade::OnRoundStateChange(EArcadeRoundPhase NewRoundState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_Arcade", "OnRoundStateChange");

	Params::OrionGameState_Arcade_OnRoundStateChange Parms{};

	Parms.NewRoundState = NewRoundState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_DraftLobby.OnRep_AbortReason
// (Final, Native, Private)

void AOrionGameState_DraftLobby::OnRep_AbortReason()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_DraftLobby", "OnRep_AbortReason");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_DraftLobby.OnRep_CurrentPhaseIdx
// (Final, Native, Private)

void AOrionGameState_DraftLobby::OnRep_CurrentPhaseIdx()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_DraftLobby", "OnRep_CurrentPhaseIdx");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_DraftLobby.OnRep_CurrentPhaseState
// (Final, Native, Private)

void AOrionGameState_DraftLobby::OnRep_CurrentPhaseState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_DraftLobby", "OnRep_CurrentPhaseState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_DraftLobby.OnRep_LockedInHeroes
// (Final, Native, Private)

void AOrionGameState_DraftLobby::OnRep_LockedInHeroes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_DraftLobby", "OnRep_LockedInHeroes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameState_DraftLobby.OnRep_Phases
// (Final, Native, Private)

void AOrionGameState_DraftLobby::OnRep_Phases()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_DraftLobby", "OnRep_Phases");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionMcpEmoteItem.GetInternalData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UOrionEmoteItemDefinition*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionEmoteItemDefinition* UOrionMcpEmoteItem::GetInternalData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpEmoteItem", "GetInternalData");

	Params::OrionMcpEmoteItem_GetInternalData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameState_MOBA_Tutorial.BP_GetTutorialPlayerController
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AOrionPlayerController_Tutorial*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOrionPlayerController_Tutorial* AOrionGameState_MOBA_Tutorial::BP_GetTutorialPlayerController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA_Tutorial", "BP_GetTutorialPlayerController");

	Params::OrionGameState_MOBA_Tutorial_BP_GetTutorialPlayerController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameState_MOBA_Tutorial.BP_GetTutorialPlayerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AOrionPlayerState_Tutorial*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOrionPlayerState_Tutorial* AOrionGameState_MOBA_Tutorial::BP_GetTutorialPlayerState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameState_MOBA_Tutorial", "BP_GetTutorialPlayerState");

	Params::OrionGameState_MOBA_Tutorial_BP_GetTutorialPlayerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameViewportClient.OnAnalogCursorEnabledToggle
// (Final, Native, Private)
// Parameters:
// bool                                    bIsEnabled                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionGameViewportClient::OnAnalogCursorEnabledToggle(bool bIsEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameViewportClient", "OnAnalogCursorEnabledToggle");

	Params::OrionGameViewportClient_OnAnalogCursorEnabledToggle Parms{};

	Parms.bIsEnabled = bIsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGameViewportClient.UpdateMenusOnFocusLost
// (Final, Native, Private)

void UOrionGameViewportClient::UpdateMenusOnFocusLost()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameViewportClient", "UpdateMenusOnFocusLost");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGestureData.GetMatchingGestureEntry
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionGestureDirection                  Direction1                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionGestureDirection                  Direction2                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FOrionGestureEntry               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FOrionGestureEntry UOrionGestureData::GetMatchingGestureEntry(EOrionGestureDirection Direction1, EOrionGestureDirection Direction2) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGestureData", "GetMatchingGestureEntry");

	Params::OrionGestureData_GetMatchingGestureEntry Parms{};

	Parms.Direction1 = Direction1;
	Parms.Direction2 = Direction2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGravesite.ActivateGravesite
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Pos                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TriggerPos                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionGravesite::ActivateGravesite(const struct FVector& Pos, const struct FVector& TriggerPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGravesite", "ActivateGravesite");

	Params::OrionGravesite_ActivateGravesite Parms{};

	Parms.Pos = std::move(Pos);
	Parms.TriggerPos = std::move(TriggerPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGravesite.AddGameplayCueLocal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     GameplayCueTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Parameters                                             (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AOrionGravesite::AddGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Parameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGravesite", "AddGameplayCueLocal");

	Params::OrionGravesite_AddGameplayCueLocal Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.Parameters = std::move(Parameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGravesite.ExecuteGameplayCueLocal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     GameplayCueTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Parameters                                             (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AOrionGravesite::ExecuteGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Parameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGravesite", "ExecuteGameplayCueLocal");

	Params::OrionGravesite_ExecuteGameplayCueLocal Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.Parameters = std::move(Parameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGravesite.FadeOut
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// bool                                    bBrightenFirst                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionGravesite::FadeOut(bool bBrightenFirst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGravesite", "FadeOut");

	Params::OrionGravesite_FadeOut Parms{};

	Parms.bBrightenFirst = bBrightenFirst;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGravesite.OnRep_bPlayerInRange
// (Final, Native, Public)

void AOrionGravesite::OnRep_bPlayerInRange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGravesite", "OnRep_bPlayerInRange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGravesite.OnRep_GravesiteActivation
// (Final, Native, Protected)

void AOrionGravesite::OnRep_GravesiteActivation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGravesite", "OnRep_GravesiteActivation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionGravesite.RemoveGameplayCueLocal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     GameplayCueTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Parameters                                             (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AOrionGravesite::RemoveGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Parameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGravesite", "RemoveGameplayCueLocal");

	Params::OrionGravesite_RemoveGameplayCueLocal Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.Parameters = std::move(Parameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionHealthSet.OnRep_AbilityResistanceRating
// (Final, Native, Public)

void UOrionHealthSet::OnRep_AbilityResistanceRating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionHealthSet", "OnRep_AbilityResistanceRating");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionHealthSet.OnRep_BasicResistanceRating
// (Final, Native, Public)

void UOrionHealthSet::OnRep_BasicResistanceRating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionHealthSet", "OnRep_BasicResistanceRating");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionHealthSet.OnRep_DamageBonusTarget
// (Final, Native, Public)

void UOrionHealthSet::OnRep_DamageBonusTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionHealthSet", "OnRep_DamageBonusTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionHealthSet.OnRep_DamageResistance
// (Final, Native, Public)

void UOrionHealthSet::OnRep_DamageResistance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionHealthSet", "OnRep_DamageResistance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionHealthSet.OnRep_FlatDamageBlock
// (Final, Native, Public)

void UOrionHealthSet::OnRep_FlatDamageBlock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionHealthSet", "OnRep_FlatDamageBlock");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionHealthSet.OnRep_HealingBonusTarget
// (Final, Native, Public)

void UOrionHealthSet::OnRep_HealingBonusTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionHealthSet", "OnRep_HealingBonusTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionHealthSet.OnRep_Health
// (Final, Native, Public)

void UOrionHealthSet::OnRep_Health()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionHealthSet", "OnRep_Health");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionHealthSet.OnRep_HealthRegenRate
// (Final, Native, Public)

void UOrionHealthSet::OnRep_HealthRegenRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionHealthSet", "OnRep_HealthRegenRate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionHealthSet.OnRep_MaxHealth
// (Final, Native, Public)

void UOrionHealthSet::OnRep_MaxHealth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionHealthSet", "OnRep_MaxHealth");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionHealthSet.OnRep_MaxShield
// (Final, Native, Public)

void UOrionHealthSet::OnRep_MaxShield()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionHealthSet", "OnRep_MaxShield");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionHealthSet.OnRep_MinHealth
// (Final, Native, Public)

void UOrionHealthSet::OnRep_MinHealth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionHealthSet", "OnRep_MinHealth");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionHealthSet.OnRep_Shield
// (Final, Native, Public)

void UOrionHealthSet::OnRep_Shield()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionHealthSet", "OnRep_Shield");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionHealthSet.OnRep_TargetMaxDamage
// (Final, Native, Public)

void UOrionHealthSet::OnRep_TargetMaxDamage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionHealthSet", "OnRep_TargetMaxDamage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionHeroChainsAnimInstance.SetUpBellyChainOrientation
// (Final, Native, Public, BlueprintCallable)

void UOrionHeroChainsAnimInstance::SetUpBellyChainOrientation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionHeroChainsAnimInstance", "SetUpBellyChainOrientation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionHeroDisplayLibrary.GetHeroLockedMessage
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// EOrionHeroTier                          Tier                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             MESSAGE                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UOrionHeroDisplayLibrary::GetHeroLockedMessage(EOrionHeroTier Tier, class FText* MESSAGE)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionHeroDisplayLibrary", "GetHeroLockedMessage");

	Params::OrionHeroDisplayLibrary_GetHeroLockedMessage Parms{};

	Parms.Tier = Tier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (MESSAGE != nullptr)
		*MESSAGE = std::move(Parms.MESSAGE);
}


// Function OrionGame.OrionHeroPriceAnimInstance.AnimNotify_IK_HndShotGun_Off
// (Final, Native, Public)
// Parameters:
// class UAnimNotify*                      AnimNotify                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionHeroPriceAnimInstance::AnimNotify_IK_HndShotGun_Off(const class UAnimNotify* AnimNotify)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionHeroPriceAnimInstance", "AnimNotify_IK_HndShotGun_Off");

	Params::OrionHeroPriceAnimInstance_AnimNotify_IK_HndShotGun_Off Parms{};

	Parms.AnimNotify = AnimNotify;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionHeroPriceAnimInstance.AnimNotify_IK_HndShotGun_On
// (Final, Native, Public)
// Parameters:
// class UAnimNotify*                      AnimNotify                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionHeroPriceAnimInstance::AnimNotify_IK_HndShotGun_On(const class UAnimNotify* AnimNotify)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionHeroPriceAnimInstance", "AnimNotify_IK_HndShotGun_On");

	Params::OrionHeroPriceAnimInstance_AnimNotify_IK_HndShotGun_On Parms{};

	Parms.AnimNotify = AnimNotify;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionHighlightsLibrary.GetNumHighlights
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(int32 NumHighlights)>    Callback                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UOrionHighlightsLibrary::GetNumHighlights(TDelegate<void(int32 NumHighlights)> Callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionHighlightsLibrary", "GetNumHighlights");

	Params::OrionHighlightsLibrary_GetNumHighlights Parms{};

	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionHighlightsLibrary.OpenHighlightSummary
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Context                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionHighlightsLibrary::OpenHighlightSummary(class UObject* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionHighlightsLibrary", "OpenHighlightSummary");

	Params::OrionHighlightsLibrary_OpenHighlightSummary Parms{};

	Parms.Context = Context;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionHighlightsLibrary.TriggerHighlight
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             HighlightTag                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionHighlightsLibrary::TriggerHighlight(class FName HighlightTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionHighlightsLibrary", "TriggerHighlight");

	Params::OrionHighlightsLibrary_TriggerHighlight Parms{};

	Parms.HighlightTag = HighlightTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.GetNumHighlightsUICallbackProxy.GetNumHighlights
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGetNumHighlightsUICallbackProxy* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGetNumHighlightsUICallbackProxy* UGetNumHighlightsUICallbackProxy::GetNumHighlights()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GetNumHighlightsUICallbackProxy", "GetNumHighlights");

	Params::GetNumHighlightsUICallbackProxy_GetNumHighlights Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.GetNumHighlightsUICallbackProxy.OnGetNumHighlightsComplete
// (Final, Native, Private)
// Parameters:
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGetNumHighlightsUICallbackProxy::OnGetNumHighlightsComplete(int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GetNumHighlightsUICallbackProxy", "OnGetNumHighlightsComplete");

	Params::GetNumHighlightsUICallbackProxy_OnGetNumHighlightsComplete Parms{};

	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionHUDVictoryScreen.ShowDefeat
// (Native, Event, Protected, BlueprintEvent)

void UOrionHUDVictoryScreen::ShowDefeat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionHUDVictoryScreen", "ShowDefeat");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionHUDVictoryScreen.ShowVictory
// (Native, Event, Protected, BlueprintEvent)

void UOrionHUDVictoryScreen::ShowVictory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionHUDVictoryScreen", "ShowVictory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionInputKeySelector.SetOrionButtonStyle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UOrionButtonStyle>    InButtonStyleClass                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionInputKeySelector::SetOrionButtonStyle(TSubclassOf<class UOrionButtonStyle> InButtonStyleClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionInputKeySelector", "SetOrionButtonStyle");

	Params::OrionInputKeySelector_SetOrionButtonStyle Parms{};

	Parms.InButtonStyleClass = InButtonStyleClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionInputKeySelector.SetStyleSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionWidgetStyleSize                   InStyleSize                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionInputKeySelector::SetStyleSize(EOrionWidgetStyleSize InStyleSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionInputKeySelector", "SetStyleSize");

	Params::OrionInputKeySelector_SetStyleSize Parms{};

	Parms.InStyleSize = InStyleSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionInputKeySelector.SetTextColorType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionTextColor                         InColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionInputKeySelector::SetTextColorType(EOrionTextColor InColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionInputKeySelector", "SetTextColorType");

	Params::OrionInputKeySelector_SetTextColorType Parms{};

	Parms.InColor = InColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionItemizationComponent.OnRep_ActiveGems
// (Final, Native, Private)

void UOrionItemizationComponent::OnRep_ActiveGems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionItemizationComponent", "OnRep_ActiveGems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionItemizationComponent.OnRep_EligibleForReset
// (Final, Native, Private)

void UOrionItemizationComponent::OnRep_EligibleForReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionItemizationComponent", "OnRep_EligibleForReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionItemizationComponent.OnRep_EquippedCards
// (Final, Native, Private)

void UOrionItemizationComponent::OnRep_EquippedCards()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionItemizationComponent", "OnRep_EquippedCards");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionItemizationComponent.OnRep_HasEstablishedDeck
// (Final, Native, Private)

void UOrionItemizationComponent::OnRep_HasEstablishedDeck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionItemizationComponent", "OnRep_HasEstablishedDeck");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionItemizationComponent.ServerPrintDebug_WithClientStrings
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// TArray<class FString>                   Strings                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UOrionItemizationComponent::ServerPrintDebug_WithClientStrings(const TArray<class FString>& Strings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionItemizationComponent", "ServerPrintDebug_WithClientStrings");

	Params::OrionItemizationComponent_ServerPrintDebug_WithClientStrings Parms{};

	Parms.Strings = std::move(Strings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionKismetLibrary.AbilityTeleportActor
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          DestLocation                                           (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         DestRotation                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    IsGroundLocation                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionKismetLibrary::AbilityTeleportActor(class AActor* TargetActor, const struct FVector& DestLocation, const struct FRotator& DestRotation, bool IsGroundLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "AbilityTeleportActor");

	Params::OrionKismetLibrary_AbilityTeleportActor Parms{};

	Parms.TargetActor = TargetActor;
	Parms.DestLocation = std::move(DestLocation);
	Parms.DestRotation = std::move(DestRotation);
	Parms.IsGroundLocation = IsGroundLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.AngleBetweenInDegrees
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          V0                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          V1                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOrionKismetLibrary::AngleBetweenInDegrees(const struct FVector& V0, const struct FVector& V1)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "AngleBetweenInDegrees");

	Params::OrionKismetLibrary_AngleBetweenInDegrees Parms{};

	Parms.V0 = std::move(V0);
	Parms.V1 = std::move(V1);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.AngleBetweenInRadians
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          V0                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          V1                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOrionKismetLibrary::AngleBetweenInRadians(const struct FVector& V0, const struct FVector& V1)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "AngleBetweenInRadians");

	Params::OrionKismetLibrary_AngleBetweenInRadians Parms{};

	Parms.V0 = std::move(V0);
	Parms.V1 = std::move(V1);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.AnnouncerSayDialog
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SoundInstigator                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Ident                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::AnnouncerSayDialog(class UObject* WorldContextObject, class AActor* SoundInstigator, const class FString& Ident)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "AnnouncerSayDialog");

	Params::OrionKismetLibrary_AnnouncerSayDialog Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SoundInstigator = SoundInstigator;
	Parms.Ident = std::move(Ident);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionKismetLibrary.ApplyAbilityTagsToSpecFilterContainer
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOrionFilterAndEffectsContainer  FilterContainer                                        (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UGameplayAbility*                 Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::ApplyAbilityTagsToSpecFilterContainer(struct FOrionFilterAndEffectsContainer& FilterContainer, class UGameplayAbility* Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "ApplyAbilityTagsToSpecFilterContainer");

	Params::OrionKismetLibrary_ApplyAbilityTagsToSpecFilterContainer Parms{};

	Parms.FilterContainer = std::move(FilterContainer);
	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	FilterContainer = std::move(Parms.FilterContainer);
}


// Function OrionGame.OrionKismetLibrary.ApplyGameplayEffectsToTarget
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGameplayEffectSpecHandle>EffectSpecHandlesToApply                               (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FActiveGameplayEffectHandle>AppliedEffectHandles                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionKismetLibrary::ApplyGameplayEffectsToTarget(class AActor* TargetActor, TArray<struct FGameplayEffectSpecHandle>& EffectSpecHandlesToApply, TArray<struct FActiveGameplayEffectHandle>* AppliedEffectHandles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "ApplyGameplayEffectsToTarget");

	Params::OrionKismetLibrary_ApplyGameplayEffectsToTarget Parms{};

	Parms.TargetActor = TargetActor;
	Parms.EffectSpecHandlesToApply = std::move(EffectSpecHandlesToApply);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	EffectSpecHandlesToApply = std::move(Parms.EffectSpecHandlesToApply);

	if (AppliedEffectHandles != nullptr)
		*AppliedEffectHandles = std::move(Parms.AppliedEffectHandles);

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.ApplyGameplayEffectsToTargetData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOrionFilterAndEffectsContainer  FilterContainer                                        (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle TargetData                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FActiveGameplayEffectHandle>AppliedEffectHandles                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::ApplyGameplayEffectsToTargetData(struct FOrionFilterAndEffectsContainer& FilterContainer, const struct FGameplayAbilityTargetDataHandle& TargetData, TArray<struct FActiveGameplayEffectHandle>* AppliedEffectHandles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "ApplyGameplayEffectsToTargetData");

	Params::OrionKismetLibrary_ApplyGameplayEffectsToTargetData Parms{};

	Parms.FilterContainer = std::move(FilterContainer);
	Parms.TargetData = std::move(TargetData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	FilterContainer = std::move(Parms.FilterContainer);

	if (AppliedEffectHandles != nullptr)
		*AppliedEffectHandles = std::move(Parms.AppliedEffectHandles);
}


// Function OrionGame.OrionKismetLibrary.CanActorSeeTargetInShadowPlane
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Source                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionKismetLibrary::CanActorSeeTargetInShadowPlane(const class AActor* Source, const class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "CanActorSeeTargetInShadowPlane");

	Params::OrionKismetLibrary_CanActorSeeTargetInShadowPlane Parms{};

	Parms.Source = Source;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.CanPerformRendering
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionKismetLibrary::CanPerformRendering()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "CanPerformRendering");

	Params::OrionKismetLibrary_CanPerformRendering Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.CanSeeInZoneVisionMask
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   CanSeeZoneVisionMask                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionKismetLibrary::CanSeeInZoneVisionMask(uint8 CanSeeZoneVisionMask, class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "CanSeeInZoneVisionMask");

	Params::OrionKismetLibrary_CanSeeInZoneVisionMask Parms{};

	Parms.CanSeeZoneVisionMask = CanSeeZoneVisionMask;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.ChangeTeamChar
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AOrionChar*                       OrionChar                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionTeam                              NewTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::ChangeTeamChar(class AOrionChar* OrionChar, EOrionTeam NewTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "ChangeTeamChar");

	Params::OrionKismetLibrary_ChangeTeamChar Parms{};

	Parms.OrionChar = OrionChar;
	Parms.NewTeam = NewTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionKismetLibrary.ChangeTeamController
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AController*                      Controller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionTeam                              NewTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::ChangeTeamController(class AController* Controller, EOrionTeam NewTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "ChangeTeamController");

	Params::OrionKismetLibrary_ChangeTeamController Parms{};

	Parms.Controller = Controller;
	Parms.NewTeam = NewTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionKismetLibrary.CheckCVarInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           CVarString                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOrionKismetLibrary::CheckCVarInt(const class FString& CVarString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "CheckCVarInt");

	Params::OrionKismetLibrary_CheckCVarInt Parms{};

	Parms.CVarString = std::move(CVarString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.CloneEffectSpecsForFilters
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FOrionFilterAndEffectsContainer  FilterContainer                                        (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           InNewInstigator                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InNewSourceActor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FOrionFilterAndEffectsContainer  FilterToClone                                          (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionKismetLibrary::CloneEffectSpecsForFilters(struct FOrionFilterAndEffectsContainer& FilterContainer, class AActor* InNewInstigator, class AActor* InNewSourceActor, struct FOrionFilterAndEffectsContainer* FilterToClone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "CloneEffectSpecsForFilters");

	Params::OrionKismetLibrary_CloneEffectSpecsForFilters Parms{};

	Parms.FilterContainer = std::move(FilterContainer);
	Parms.InNewInstigator = InNewInstigator;
	Parms.InNewSourceActor = InNewSourceActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	FilterContainer = std::move(Parms.FilterContainer);

	if (FilterToClone != nullptr)
		*FilterToClone = std::move(Parms.FilterToClone);

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.ClosestPointOnLineToLine
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A0                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          A1                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          B0                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          B1                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UOrionKismetLibrary::ClosestPointOnLineToLine(const struct FVector& A0, const struct FVector& A1, const struct FVector& B0, const struct FVector& B1)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "ClosestPointOnLineToLine");

	Params::OrionKismetLibrary_ClosestPointOnLineToLine Parms{};

	Parms.A0 = std::move(A0);
	Parms.A1 = std::move(A1);
	Parms.B0 = std::move(B0);
	Parms.B1 = std::move(B1);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.ClosestPointOnSegmentToLine
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          SegmentP0                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SegmentP1                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LineP0                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LineP1                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UOrionKismetLibrary::ClosestPointOnSegmentToLine(const struct FVector& SegmentP0, const struct FVector& SegmentP1, const struct FVector& LineP0, const struct FVector& LineP1)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "ClosestPointOnSegmentToLine");

	Params::OrionKismetLibrary_ClosestPointOnSegmentToLine Parms{};

	Parms.SegmentP0 = std::move(SegmentP0);
	Parms.SegmentP1 = std::move(SegmentP1);
	Parms.LineP0 = std::move(LineP0);
	Parms.LineP1 = std::move(LineP1);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.ClosestPointOnSegmentToPlane
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          SegmentP0                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SegmentP1                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPlane                           Plane                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UOrionKismetLibrary::ClosestPointOnSegmentToPlane(const struct FVector& SegmentP0, const struct FVector& SegmentP1, const struct FPlane& Plane)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "ClosestPointOnSegmentToPlane");

	Params::OrionKismetLibrary_ClosestPointOnSegmentToPlane Parms{};

	Parms.SegmentP0 = std::move(SegmentP0);
	Parms.SegmentP1 = std::move(SegmentP1);
	Parms.Plane = std::move(Plane);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.ClosestPointsOnSegmentToSegment
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A0                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          A1                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          B0                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          B1                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutA                                                   (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutB                                                   (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::ClosestPointsOnSegmentToSegment(const struct FVector& A0, const struct FVector& A1, const struct FVector& B0, const struct FVector& B1, struct FVector* OutA, struct FVector* OutB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "ClosestPointsOnSegmentToSegment");

	Params::OrionKismetLibrary_ClosestPointsOnSegmentToSegment Parms{};

	Parms.A0 = std::move(A0);
	Parms.A1 = std::move(A1);
	Parms.B0 = std::move(B0);
	Parms.B1 = std::move(B1);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutA != nullptr)
		*OutA = std::move(Parms.OutA);

	if (OutB != nullptr)
		*OutB = std::move(Parms.OutB);
}


// Function OrionGame.OrionKismetLibrary.CompareActorTeams
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           A                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           B                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionTeamCompare                       CompareType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionKismetLibrary::CompareActorTeams(const class AActor* A, const class AActor* B, EOrionTeamCompare CompareType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "CompareActorTeams");

	Params::OrionKismetLibrary_CompareActorTeams Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.CompareType = CompareType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.CompareTeams
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EOrionTeam                              TeamA                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionTeam                              TeamB                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionTeamCompare                       CompareType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionKismetLibrary::CompareTeams(EOrionTeam TeamA, EOrionTeam TeamB, EOrionTeamCompare CompareType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "CompareTeams");

	Params::OrionKismetLibrary_CompareTeams Parms{};

	Parms.TeamA = TeamA;
	Parms.TeamB = TeamB;
	Parms.CompareType = CompareType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.DebugCapsuleSendToAll
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Center                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                            Rotation                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FColor                           Color                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPersistentLines                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LifeTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   DepthPriority                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thickness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::DebugCapsuleSendToAll(class UObject* WorldContextObject, const struct FVector& Center, float HalfHeight, float Radius, const struct FQuat& Rotation, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "DebugCapsuleSendToAll");

	Params::OrionKismetLibrary_DebugCapsuleSendToAll Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Center = std::move(Center);
	Parms.HalfHeight = HalfHeight;
	Parms.Radius = Radius;
	Parms.Rotation = std::move(Rotation);
	Parms.Color = std::move(Color);
	Parms.bPersistentLines = bPersistentLines;
	Parms.LifeTime = LifeTime;
	Parms.DepthPriority = DepthPriority;
	Parms.Thickness = Thickness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionKismetLibrary.DebugLineSendToAll
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LineStart                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LineEnd                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           Color                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPersistentLines                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LifeTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   DepthPriority                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thickness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::DebugLineSendToAll(class UObject* WorldContextObject, const struct FVector& LineStart, const struct FVector& LineEnd, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "DebugLineSendToAll");

	Params::OrionKismetLibrary_DebugLineSendToAll Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LineStart = std::move(LineStart);
	Parms.LineEnd = std::move(LineEnd);
	Parms.Color = std::move(Color);
	Parms.bPersistentLines = bPersistentLines;
	Parms.LifeTime = LifeTime;
	Parms.DepthPriority = DepthPriority;
	Parms.Thickness = Thickness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionKismetLibrary.DebugSphereSendToAll
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Center                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Segments                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           Color                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPersistentLines                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LifeTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   DepthPriority                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thickness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::DebugSphereSendToAll(class UObject* WorldContextObject, const struct FVector& Center, float Radius, int32 Segments, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "DebugSphereSendToAll");

	Params::OrionKismetLibrary_DebugSphereSendToAll Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Center = std::move(Center);
	Parms.Radius = Radius;
	Parms.Segments = Segments;
	Parms.Color = std::move(Color);
	Parms.bPersistentLines = bPersistentLines;
	Parms.LifeTime = LifeTime;
	Parms.DepthPriority = DepthPriority;
	Parms.Thickness = Thickness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionKismetLibrary.DistanceSquaredBetweenSegments
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A0                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          A1                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          B0                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          B1                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOrionKismetLibrary::DistanceSquaredBetweenSegments(const struct FVector& A0, const struct FVector& A1, const struct FVector& B0, const struct FVector& B1)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "DistanceSquaredBetweenSegments");

	Params::OrionKismetLibrary_DistanceSquaredBetweenSegments Parms{};

	Parms.A0 = std::move(A0);
	Parms.A1 = std::move(A1);
	Parms.B0 = std::move(B0);
	Parms.B1 = std::move(B1);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.DoesActorHaveVisionOnTarget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Source                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionKismetLibrary::DoesActorHaveVisionOnTarget(const class AActor* Source, const class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "DoesActorHaveVisionOnTarget");

	Params::OrionKismetLibrary_DoesActorHaveVisionOnTarget Parms{};

	Parms.Source = Source;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.DoesTeamHaveVisionOnTarget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EOrionTeam                              Team                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionKismetLibrary::DoesTeamHaveVisionOnTarget(const EOrionTeam Team, const class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "DoesTeamHaveVisionOnTarget");

	Params::OrionKismetLibrary_DoesTeamHaveVisionOnTarget Parms{};

	Parms.Team = Team;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.DoVisionTestBetweenActors
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Viewer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CheckMask                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionKismetLibrary::DoVisionTestBetweenActors(class AActor* Target, class AActor* Viewer, int32 CheckMask, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "DoVisionTestBetweenActors");

	Params::OrionKismetLibrary_DoVisionTestBetweenActors Parms{};

	Parms.Target = Target;
	Parms.Viewer = Viewer;
	Parms.CheckMask = CheckMask;
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.EqualEqual_ActiveGameplayEffectHandle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FActiveGameplayEffectHandle      ActiveGameplayEffectHandleA                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActiveGameplayEffectHandle      ActiveGameplayEffectHandleB                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionKismetLibrary::EqualEqual_ActiveGameplayEffectHandle(const struct FActiveGameplayEffectHandle& ActiveGameplayEffectHandleA, const struct FActiveGameplayEffectHandle& ActiveGameplayEffectHandleB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "EqualEqual_ActiveGameplayEffectHandle");

	Params::OrionKismetLibrary_EqualEqual_ActiveGameplayEffectHandle Parms{};

	Parms.ActiveGameplayEffectHandleA = std::move(ActiveGameplayEffectHandleA);
	Parms.ActiveGameplayEffectHandleB = std::move(ActiveGameplayEffectHandleB);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.EvaluateCurveTableRowHandle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FCurveTableRowHandle             RowHandle                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InXY                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEvaluateCurveTableResult               OutResult                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutXY                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ContextString                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::EvaluateCurveTableRowHandle(const struct FCurveTableRowHandle& RowHandle, float InXY, EEvaluateCurveTableResult* OutResult, float* OutXY, const class FString& ContextString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "EvaluateCurveTableRowHandle");

	Params::OrionKismetLibrary_EvaluateCurveTableRowHandle Parms{};

	Parms.RowHandle = std::move(RowHandle);
	Parms.InXY = InXY;
	Parms.ContextString = std::move(ContextString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutResult != nullptr)
		*OutResult = Parms.OutResult;

	if (OutXY != nullptr)
		*OutXY = Parms.OutXY;
}


// Function OrionGame.OrionKismetLibrary.FilterActor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FOrionActorFilter                Filter                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           Source                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionKismetLibrary::FilterActor(const struct FOrionActorFilter& Filter, const class AActor* Source, const class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "FilterActor");

	Params::OrionKismetLibrary_FilterActor Parms{};

	Parms.Filter = std::move(Filter);
	Parms.Source = Source;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.FindPlayerStart
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AController*                      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           StartPointActor                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          StartPointLocation                                     (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         StartPointRotation                                     (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::FindPlayerStart(class AController* PlayerController, class AActor** StartPointActor, struct FVector* StartPointLocation, struct FRotator* StartPointRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "FindPlayerStart");

	Params::OrionKismetLibrary_FindPlayerStart Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (StartPointActor != nullptr)
		*StartPointActor = Parms.StartPointActor;

	if (StartPointLocation != nullptr)
		*StartPointLocation = std::move(Parms.StartPointLocation);

	if (StartPointRotation != nullptr)
		*StartPointRotation = std::move(Parms.StartPointRotation);
}


// Function OrionGame.OrionKismetLibrary.GameplayCue_ApplyDecal
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             DecalName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::GameplayCue_ApplyDecal(class AActor* Actor, class FName DecalName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GameplayCue_ApplyDecal");

	Params::OrionKismetLibrary_GameplayCue_ApplyDecal Parms{};

	Parms.Actor = Actor;
	Parms.DecalName = DecalName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionKismetLibrary.GameplayCue_ApplyDecalForDuration
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             DecalName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::GameplayCue_ApplyDecalForDuration(class AActor* Actor, class FName DecalName, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GameplayCue_ApplyDecalForDuration");

	Params::OrionKismetLibrary_GameplayCue_ApplyDecalForDuration Parms{};

	Parms.Actor = Actor;
	Parms.DecalName = DecalName;
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionKismetLibrary.GameplayCue_PlaySoundTeamAdjustedForSource
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USoundBase*                       SoundToPlay                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           MyTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Parameters                                             (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    Attached                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopWhenAttachedToDestroyed                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* UOrionKismetLibrary::GameplayCue_PlaySoundTeamAdjustedForSource(class USoundBase* SoundToPlay, class AActor* MyTarget, const struct FGameplayCueParameters& Parameters, bool Attached, bool bStopWhenAttachedToDestroyed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GameplayCue_PlaySoundTeamAdjustedForSource");

	Params::OrionKismetLibrary_GameplayCue_PlaySoundTeamAdjustedForSource Parms{};

	Parms.SoundToPlay = SoundToPlay;
	Parms.MyTarget = MyTarget;
	Parms.Parameters = std::move(Parameters);
	Parms.Attached = Attached;
	Parms.bStopWhenAttachedToDestroyed = bStopWhenAttachedToDestroyed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GameplayCue_PlaySoundTeamAdjustedForTarget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USoundBase*                       SoundToPlay                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           MyTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Parameters                                             (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    Attached                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopWhenAttachedToDestroyed                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* UOrionKismetLibrary::GameplayCue_PlaySoundTeamAdjustedForTarget(class USoundBase* SoundToPlay, class AActor* MyTarget, const struct FGameplayCueParameters& Parameters, bool Attached, bool bStopWhenAttachedToDestroyed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GameplayCue_PlaySoundTeamAdjustedForTarget");

	Params::OrionKismetLibrary_GameplayCue_PlaySoundTeamAdjustedForTarget Parms{};

	Parms.SoundToPlay = SoundToPlay;
	Parms.MyTarget = MyTarget;
	Parms.Parameters = std::move(Parameters);
	Parms.Attached = Attached;
	Parms.bStopWhenAttachedToDestroyed = bStopWhenAttachedToDestroyed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GameplayCue_RemoveDecal
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             DecalName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::GameplayCue_RemoveDecal(class AActor* Actor, class FName DecalName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GameplayCue_RemoveDecal");

	Params::OrionKismetLibrary_GameplayCue_RemoveDecal Parms{};

	Parms.Actor = Actor;
	Parms.DecalName = DecalName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionKismetLibrary.GameplayCue_SourceLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayCueParameters           Parameters                                             (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UOrionKismetLibrary::GameplayCue_SourceLocation(const struct FGameplayCueParameters& Parameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GameplayCue_SourceLocation");

	Params::OrionKismetLibrary_GameplayCue_SourceLocation Parms{};

	Parms.Parameters = std::move(Parameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GameplayCue_SpawnEmitter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UParticleSystem*                  ParticleSystem                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           MyTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Parameters                                             (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    Attached                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UParticleSystemComponent*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UParticleSystemComponent* UOrionKismetLibrary::GameplayCue_SpawnEmitter(class UObject* WorldContextObject, class UParticleSystem* ParticleSystem, class AActor* MyTarget, const struct FGameplayCueParameters& Parameters, bool Attached)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GameplayCue_SpawnEmitter");

	Params::OrionKismetLibrary_GameplayCue_SpawnEmitter Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ParticleSystem = ParticleSystem;
	Parms.MyTarget = MyTarget;
	Parms.Parameters = std::move(Parameters);
	Parms.Attached = Attached;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GenerateGameplayEffectSpecsForFilter
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FOrionFilterAndEffectsContainer  FilterContainer                                        (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FOrionFilterAndEffectsContainer  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FOrionFilterAndEffectsContainer UOrionKismetLibrary::GenerateGameplayEffectSpecsForFilter(struct FOrionFilterAndEffectsContainer& FilterContainer, class AActor* Instigator, class AActor* Source, float InLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GenerateGameplayEffectSpecsForFilter");

	Params::OrionKismetLibrary_GenerateGameplayEffectSpecsForFilter Parms{};

	Parms.FilterContainer = std::move(FilterContainer);
	Parms.Instigator = Instigator;
	Parms.Source = Source;
	Parms.InLevel = InLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	FilterContainer = std::move(Parms.FilterContainer);

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GetActiveRotationalContentTags
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FGameplayTagContainer UOrionKismetLibrary::GetActiveRotationalContentTags(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GetActiveRotationalContentTags");

	Params::OrionKismetLibrary_GetActiveRotationalContentTags Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GetActorAimPosition
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UOrionKismetLibrary::GetActorAimPosition(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GetActorAimPosition");

	Params::OrionKismetLibrary_GetActorAimPosition Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GetActorBottom
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UOrionKismetLibrary::GetActorBottom(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GetActorBottom");

	Params::OrionKismetLibrary_GetActorBottom Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GetActorRadius
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOrionKismetLibrary::GetActorRadius(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GetActorRadius");

	Params::OrionKismetLibrary_GetActorRadius Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GetActorTargetPosition
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UOrionKismetLibrary::GetActorTargetPosition(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GetActorTargetPosition");

	Params::OrionKismetLibrary_GetActorTargetPosition Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GetActorTeam
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           A                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionTeam                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOrionTeam UOrionKismetLibrary::GetActorTeam(const class AActor* A)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GetActorTeam");

	Params::OrionKismetLibrary_GetActorTeam Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GetEffectsToApplyToTargetFromFilters
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOrionFilterAndEffectsContainer  FilterContainer                                        (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGameplayEffectSpecHandle>EffectSpecHandlesToApply                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionKismetLibrary::GetEffectsToApplyToTargetFromFilters(struct FOrionFilterAndEffectsContainer& FilterContainer, class AActor* Target, TArray<struct FGameplayEffectSpecHandle>* EffectSpecHandlesToApply)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GetEffectsToApplyToTargetFromFilters");

	Params::OrionKismetLibrary_GetEffectsToApplyToTargetFromFilters Parms{};

	Parms.FilterContainer = std::move(FilterContainer);
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	FilterContainer = std::move(Parms.FilterContainer);

	if (EffectSpecHandlesToApply != nullptr)
		*EffectSpecHandlesToApply = std::move(Parms.EffectSpecHandlesToApply);

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GetEnemyColorFromMPC
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UOrionKismetLibrary::GetEnemyColorFromMPC()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GetEnemyColorFromMPC");

	Params::OrionKismetLibrary_GetEnemyColorFromMPC Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GetFriendlyColorFromMPC
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UOrionKismetLibrary::GetFriendlyColorFromMPC()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GetFriendlyColorFromMPC");

	Params::OrionKismetLibrary_GetFriendlyColorFromMPC Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GetGameplayEffectSpecsFromFilter
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOrionFilterAndEffectsContainer  FilterContainer                                        (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGameplayEffectSpecHandle>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FGameplayEffectSpecHandle> UOrionKismetLibrary::GetGameplayEffectSpecsFromFilter(struct FOrionFilterAndEffectsContainer& FilterContainer, class AActor* Instigator, class AActor* Source, float InLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GetGameplayEffectSpecsFromFilter");

	Params::OrionKismetLibrary_GetGameplayEffectSpecsFromFilter Parms{};

	Parms.FilterContainer = std::move(FilterContainer);
	Parms.Instigator = Instigator;
	Parms.Source = Source;
	Parms.InLevel = InLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	FilterContainer = std::move(Parms.FilterContainer);

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GetGlobalExponentialHeightFog
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AExponentialHeightFog*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AExponentialHeightFog* UOrionKismetLibrary::GetGlobalExponentialHeightFog(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GetGlobalExponentialHeightFog");

	Params::OrionKismetLibrary_GetGlobalExponentialHeightFog Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GetHealth
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOrionKismetLibrary::GetHealth(class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GetHealth");

	Params::OrionKismetLibrary_GetHealth Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GetHealthPCT
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOrionKismetLibrary::GetHealthPCT(class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GetHealthPCT");

	Params::OrionKismetLibrary_GetHealthPCT Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GetHeroPrimaryColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UOrionKismetLibrary::GetHeroPrimaryColor(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GetHeroPrimaryColor");

	Params::OrionKismetLibrary_GetHeroPrimaryColor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GetHeroSecondaryColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UOrionKismetLibrary::GetHeroSecondaryColor(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GetHeroSecondaryColor");

	Params::OrionKismetLibrary_GetHeroSecondaryColor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GetLocalPlayerController_Base
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOrionPlayerController_Base*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOrionPlayerController_Base* UOrionKismetLibrary::GetLocalPlayerController_Base(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GetLocalPlayerController_Base");

	Params::OrionKismetLibrary_GetLocalPlayerController_Base Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GetLocalPlayerController_Game
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOrionPlayerController_Game*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOrionPlayerController_Game* UOrionKismetLibrary::GetLocalPlayerController_Game(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GetLocalPlayerController_Game");

	Params::OrionKismetLibrary_GetLocalPlayerController_Game Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GetOrionReplaySpectator
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOrionReplaySpectator*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOrionReplaySpectator* UOrionKismetLibrary::GetOrionReplaySpectator(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GetOrionReplaySpectator");

	Params::OrionKismetLibrary_GetOrionReplaySpectator Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GetPlayerControllerFromActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOrionPlayerController_Game*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOrionPlayerController_Game* UOrionKismetLibrary::GetPlayerControllerFromActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GetPlayerControllerFromActor");

	Params::OrionKismetLibrary_GetPlayerControllerFromActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GetPrimaryActorFromTargetData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayAbilityTargetDataHandle TargetData                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UOrionKismetLibrary::GetPrimaryActorFromTargetData(const struct FGameplayAbilityTargetDataHandle& TargetData, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GetPrimaryActorFromTargetData");

	Params::OrionKismetLibrary_GetPrimaryActorFromTargetData Parms{};

	Parms.TargetData = std::move(TargetData);
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GetRigPlacementRange
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOrionKismetLibrary::GetRigPlacementRange(class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GetRigPlacementRange");

	Params::OrionKismetLibrary_GetRigPlacementRange Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GetSignificanceForLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOrionKismetLibrary::GetSignificanceForLocation(class UObject* WorldContextObject, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GetSignificanceForLocation");

	Params::OrionKismetLibrary_GetSignificanceForLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GetSpawnLocationForControllerAtStartPoint
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AController*                      PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           StartSpot                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutSpawnLocation                                       (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::GetSpawnLocationForControllerAtStartPoint(class AController* PlayerController, class AActor* StartSpot, struct FVector* OutSpawnLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GetSpawnLocationForControllerAtStartPoint");

	Params::OrionKismetLibrary_GetSpawnLocationForControllerAtStartPoint Parms{};

	Parms.PlayerController = PlayerController;
	Parms.StartSpot = StartSpot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSpawnLocation != nullptr)
		*OutSpawnLocation = std::move(Parms.OutSpawnLocation);
}


// Function OrionGame.OrionKismetLibrary.GetTagContainerString
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTagContainer            InContainer                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UOrionKismetLibrary::GetTagContainerString(const struct FGameplayTagContainer& InContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GetTagContainerString");

	Params::OrionKismetLibrary_GetTagContainerString Parms{};

	Parms.InContainer = std::move(InContainer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GetTagString
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTag                     InTag                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UOrionKismetLibrary::GetTagString(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GetTagString");

	Params::OrionKismetLibrary_GetTagString Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GetTeamColorFromMPC
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UOrionKismetLibrary::GetTeamColorFromMPC(class UObject* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GetTeamColorFromMPC");

	Params::OrionKismetLibrary_GetTeamColorFromMPC Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GetTeamColorFromMPCWithTeamNum
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionTeam                              TargetTeamNum                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UOrionKismetLibrary::GetTeamColorFromMPCWithTeamNum(class UObject* WorldContextObject, EOrionTeam TargetTeamNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GetTeamColorFromMPCWithTeamNum");

	Params::OrionKismetLibrary_GetTeamColorFromMPCWithTeamNum Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TargetTeamNum = TargetTeamNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GetTravelModeMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           WorldContextActor                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETravelModeModes                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETravelModeModes UOrionKismetLibrary::GetTravelModeMode(class AActor* WorldContextActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GetTravelModeMode");

	Params::OrionKismetLibrary_GetTravelModeMode Parms{};

	Parms.WorldContextActor = WorldContextActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GetVisibilityRelativeToLocalPlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Target                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELocalVisiblityState                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELocalVisiblityState UOrionKismetLibrary::GetVisibilityRelativeToLocalPlayer(const class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GetVisibilityRelativeToLocalPlayer");

	Params::OrionKismetLibrary_GetVisibilityRelativeToLocalPlayer Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GetWorldBackwardVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UOrionKismetLibrary::GetWorldBackwardVector()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GetWorldBackwardVector");

	Params::OrionKismetLibrary_GetWorldBackwardVector Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GetWorldDownVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UOrionKismetLibrary::GetWorldDownVector()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GetWorldDownVector");

	Params::OrionKismetLibrary_GetWorldDownVector Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GetWorldForwardVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UOrionKismetLibrary::GetWorldForwardVector()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GetWorldForwardVector");

	Params::OrionKismetLibrary_GetWorldForwardVector Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GetWorldLeftVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UOrionKismetLibrary::GetWorldLeftVector()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GetWorldLeftVector");

	Params::OrionKismetLibrary_GetWorldLeftVector Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GetWorldRightVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UOrionKismetLibrary::GetWorldRightVector()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GetWorldRightVector");

	Params::OrionKismetLibrary_GetWorldRightVector Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.GetWorldUpVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UOrionKismetLibrary::GetWorldUpVector()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "GetWorldUpVector");

	Params::OrionKismetLibrary_GetWorldUpVector Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.HasTrueSight
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           A                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionKismetLibrary::HasTrueSight(const class AActor* A)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "HasTrueSight");

	Params::OrionKismetLibrary_HasTrueSight Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.IsDead
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionKismetLibrary::IsDead(class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "IsDead");

	Params::OrionKismetLibrary_IsDead Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.IsEngineDoingAsyncLoading
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionKismetLibrary::IsEngineDoingAsyncLoading()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "IsEngineDoingAsyncLoading");

	Params::OrionKismetLibrary_IsEngineDoingAsyncLoading Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.IsInShadowPlane
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           A                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionKismetLibrary::IsInShadowPlane(const class AActor* A)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "IsInShadowPlane");

	Params::OrionKismetLibrary_IsInShadowPlane Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.IsLocallyControlledPlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionKismetLibrary::IsLocallyControlledPlayer(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "IsLocallyControlledPlayer");

	Params::OrionKismetLibrary_IsLocallyControlledPlayer Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.IsOnLocalTeam
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           A                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionKismetLibrary::IsOnLocalTeam(class UObject* WorldContextObject, const class AActor* A)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "IsOnLocalTeam");

	Params::OrionKismetLibrary_IsOnLocalTeam Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.IsPhaseShifted
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           A                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionKismetLibrary::IsPhaseShifted(const class AActor* A)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "IsPhaseShifted");

	Params::OrionKismetLibrary_IsPhaseShifted Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.IsRunningOnLowEndClient
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionKismetLibrary::IsRunningOnLowEndClient()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "IsRunningOnLowEndClient");

	Params::OrionKismetLibrary_IsRunningOnLowEndClient Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.IsSprintEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           WorldContextActor                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionKismetLibrary::IsSprintEnabled(class AActor* WorldContextActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "IsSprintEnabled");

	Params::OrionKismetLibrary_IsSprintEnabled Parms{};

	Parms.WorldContextActor = WorldContextActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.IsVisibleToEnemy
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           A                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionKismetLibrary::IsVisibleToEnemy(const class AActor* A)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "IsVisibleToEnemy");

	Params::OrionKismetLibrary_IsVisibleToEnemy Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.IsVisibleToTeam
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           A                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionTeam                              TeamNum                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionKismetLibrary::IsVisibleToTeam(const class AActor* A, EOrionTeam TeamNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "IsVisibleToTeam");

	Params::OrionKismetLibrary_IsVisibleToTeam Parms{};

	Parms.A = A;
	Parms.TeamNum = TeamNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.LaunchCharacterInDirection
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Direction                                              (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LaunchVelocity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLockAirControl                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::LaunchCharacterInDirection(class AActor* Actor, const struct FVector& Direction, float LaunchVelocity, bool bLockAirControl)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "LaunchCharacterInDirection");

	Params::OrionKismetLibrary_LaunchCharacterInDirection Parms{};

	Parms.Actor = Actor;
	Parms.Direction = std::move(Direction);
	Parms.LaunchVelocity = LaunchVelocity;
	Parms.bLockAirControl = bLockAirControl;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionKismetLibrary.LaunchCharacterInDirectionFromTargetData
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle TargetDataHandle                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   LaunchVelocity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLockAirControl                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::LaunchCharacterInDirectionFromTargetData(class AActor* Actor, const struct FGameplayAbilityTargetDataHandle& TargetDataHandle, float LaunchVelocity, bool bLockAirControl)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "LaunchCharacterInDirectionFromTargetData");

	Params::OrionKismetLibrary_LaunchCharacterInDirectionFromTargetData Parms{};

	Parms.Actor = Actor;
	Parms.TargetDataHandle = std::move(TargetDataHandle);
	Parms.LaunchVelocity = LaunchVelocity;
	Parms.bLockAirControl = bLockAirControl;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionKismetLibrary.LaunchCharacterToPoint
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          EndPoint                                               (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LaunchVelocityXY                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLockAirControl                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::LaunchCharacterToPoint(class AActor* Actor, const struct FVector& EndPoint, float LaunchVelocityXY, bool bLockAirControl)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "LaunchCharacterToPoint");

	Params::OrionKismetLibrary_LaunchCharacterToPoint Parms{};

	Parms.Actor = Actor;
	Parms.EndPoint = std::move(EndPoint);
	Parms.LaunchVelocityXY = LaunchVelocityXY;
	Parms.bLockAirControl = bLockAirControl;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionKismetLibrary.LaunchCharacterToPointFromTargetData
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle TargetDataHandle                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   LaunchVelocityXY                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLockAirControl                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::LaunchCharacterToPointFromTargetData(class AActor* Actor, const struct FGameplayAbilityTargetDataHandle& TargetDataHandle, float LaunchVelocityXY, bool bLockAirControl)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "LaunchCharacterToPointFromTargetData");

	Params::OrionKismetLibrary_LaunchCharacterToPointFromTargetData Parms{};

	Parms.Actor = Actor;
	Parms.TargetDataHandle = std::move(TargetDataHandle);
	Parms.LaunchVelocityXY = LaunchVelocityXY;
	Parms.bLockAirControl = bLockAirControl;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionKismetLibrary.MakeOrionFilterHandle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FOrionAbilityTargetDataFilter    Filter                                                 (Parm, NativeAccessSpecifierPublic)
// class AActor*                           FilterActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionTeam                              FilterTeam                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTargetDataFilterHandle  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTargetDataFilterHandle UOrionKismetLibrary::MakeOrionFilterHandle(const struct FOrionAbilityTargetDataFilter& Filter, class AActor* FilterActor, EOrionTeam FilterTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "MakeOrionFilterHandle");

	Params::OrionKismetLibrary_MakeOrionFilterHandle Parms{};

	Parms.Filter = std::move(Filter);
	Parms.FilterActor = FilterActor;
	Parms.FilterTeam = FilterTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.MakeOrionTargetData
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                       SourceTransform                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                       TargetTransform                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAllowExternalTargetSwaps                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayAbilityTargetDataHandle UOrionKismetLibrary::MakeOrionTargetData(const struct FTransform& SourceTransform, const struct FTransform& TargetTransform, class AActor* TargetActor, bool bAllowExternalTargetSwaps)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "MakeOrionTargetData");

	Params::OrionKismetLibrary_MakeOrionTargetData Parms{};

	Parms.SourceTransform = std::move(SourceTransform);
	Parms.TargetTransform = std::move(TargetTransform);
	Parms.TargetActor = TargetActor;
	Parms.bAllowExternalTargetSwaps = bAllowExternalTargetSwaps;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.NewVisionManagerEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionKismetLibrary::NewVisionManagerEnabled(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "NewVisionManagerEnabled");

	Params::OrionKismetLibrary_NewVisionManagerEnabled Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.OnSameFormation
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AOrionAIController*               A                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOrionAIController*               B                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionKismetLibrary::OnSameFormation(const class AOrionAIController* A, const class AOrionAIController* B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "OnSameFormation");

	Params::OrionKismetLibrary_OnSameFormation Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.OnSameFormationChar
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AOrionChar*                       A                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOrionChar*                       B                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionKismetLibrary::OnSameFormationChar(const class AOrionChar* A, const class AOrionChar* B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "OnSameFormationChar");

	Params::OrionKismetLibrary_OnSameFormationChar Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.OnSameTeam
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionKismetLibrary::OnSameTeam(class AActor* A, class AActor* B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "OnSameTeam");

	Params::OrionKismetLibrary_OnSameTeam Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.PingMinimap
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionTeam                              TeamToPing                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::PingMinimap(class UObject* WorldContextObject, const struct FVector& Location, EOrionTeam TeamToPing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "PingMinimap");

	Params::OrionKismetLibrary_PingMinimap Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Location = std::move(Location);
	Parms.TeamToPing = TeamToPing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionKismetLibrary.PlayCameraAnimOnActor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCameraAnim*                      AnimToPlay                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendInTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendOutTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLoop                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRandomStartTime                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECameraAnimPlaySpace                    Space                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         CustomPlaySpace                                        (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::PlayCameraAnimOnActor(class AActor* Actor, class UCameraAnim* AnimToPlay, float Scale, float Rate, float BlendInTime, float BlendOutTime, bool bLoop, bool bRandomStartTime, ECameraAnimPlaySpace Space, const struct FRotator& CustomPlaySpace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "PlayCameraAnimOnActor");

	Params::OrionKismetLibrary_PlayCameraAnimOnActor Parms{};

	Parms.Actor = Actor;
	Parms.AnimToPlay = AnimToPlay;
	Parms.Scale = Scale;
	Parms.Rate = Rate;
	Parms.BlendInTime = BlendInTime;
	Parms.BlendOutTime = BlendOutTime;
	Parms.bLoop = bLoop;
	Parms.bRandomStartTime = bRandomStartTime;
	Parms.Space = Space;
	Parms.CustomPlaySpace = std::move(CustomPlaySpace);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionKismetLibrary.PlayCameraShakeOnActor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UCameraShake>         Shake                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECameraAnimPlaySpace                    PlaySpace                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         UserPlaySpaceRot                                       (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::PlayCameraShakeOnActor(class AActor* Actor, TSubclassOf<class UCameraShake> Shake, float Scale, ECameraAnimPlaySpace PlaySpace, const struct FRotator& UserPlaySpaceRot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "PlayCameraShakeOnActor");

	Params::OrionKismetLibrary_PlayCameraShakeOnActor Parms{};

	Parms.Actor = Actor;
	Parms.Shake = Shake;
	Parms.Scale = Scale;
	Parms.PlaySpace = PlaySpace;
	Parms.UserPlaySpaceRot = std::move(UserPlaySpaceRot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionKismetLibrary.PlayForceFeedbackOnActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UForceFeedbackEffect*             ForceFeedbackEffect                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLooping                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::PlayForceFeedbackOnActor(class AActor* Actor, class UForceFeedbackEffect* ForceFeedbackEffect, bool bLooping, class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "PlayForceFeedbackOnActor");

	Params::OrionKismetLibrary_PlayForceFeedbackOnActor Parms{};

	Parms.Actor = Actor;
	Parms.ForceFeedbackEffect = ForceFeedbackEffect;
	Parms.bLooping = bLooping;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionKismetLibrary.PlayViewKickOnActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UOrionViewKick>       ViewKickClass                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::PlayViewKickOnActor(class AActor* Actor, TSubclassOf<class UOrionViewKick> ViewKickClass, float Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "PlayViewKickOnActor");

	Params::OrionKismetLibrary_PlayViewKickOnActor Parms{};

	Parms.Actor = Actor;
	Parms.ViewKickClass = ViewKickClass;
	Parms.Scale = Scale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionKismetLibrary.RotateVectorDegrees
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        V0                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radians                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UOrionKismetLibrary::RotateVectorDegrees(const struct FVector2D& V0, float Radians)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "RotateVectorDegrees");

	Params::OrionKismetLibrary_RotateVectorDegrees Parms{};

	Parms.V0 = std::move(V0);
	Parms.Radians = Radians;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.RotateVectorRadians
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        V0                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radians                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UOrionKismetLibrary::RotateVectorRadians(const struct FVector2D& V0, float Radians)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "RotateVectorRadians");

	Params::OrionKismetLibrary_RotateVectorRadians Parms{};

	Parms.V0 = std::move(V0);
	Parms.Radians = Radians;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.SetFilterContextAbility
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOrionFilterAndEffectsContainer  FilterContainer                                        (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UGameplayAbility*                 Ability                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::SetFilterContextAbility(struct FOrionFilterAndEffectsContainer& FilterContainer, class UGameplayAbility* Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "SetFilterContextAbility");

	Params::OrionKismetLibrary_SetFilterContextAbility Parms{};

	Parms.FilterContainer = std::move(FilterContainer);
	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	FilterContainer = std::move(Parms.FilterContainer);
}


// Function OrionGame.OrionKismetLibrary.SetFilterContextActors
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOrionFilterAndEffectsContainer  FilterContainer                                        (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   InActors                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::SetFilterContextActors(struct FOrionFilterAndEffectsContainer& FilterContainer, const TArray<class AActor*>& InActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "SetFilterContextActors");

	Params::OrionKismetLibrary_SetFilterContextActors Parms{};

	Parms.FilterContainer = std::move(FilterContainer);
	Parms.InActors = std::move(InActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	FilterContainer = std::move(Parms.FilterContainer);
}


// Function OrionGame.OrionKismetLibrary.SetFilterContextHitResult
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOrionFilterAndEffectsContainer  FilterContainer                                        (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FHitResult                       InHitResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::SetFilterContextHitResult(struct FOrionFilterAndEffectsContainer& FilterContainer, const struct FHitResult& InHitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "SetFilterContextHitResult");

	Params::OrionKismetLibrary_SetFilterContextHitResult Parms{};

	Parms.FilterContainer = std::move(FilterContainer);
	Parms.InHitResult = std::move(InHitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	FilterContainer = std::move(Parms.FilterContainer);
}


// Function OrionGame.OrionKismetLibrary.SetFilterContextInstigator
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOrionFilterAndEffectsContainer  FilterContainer                                        (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           InInstigator                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InEffectCauser                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::SetFilterContextInstigator(struct FOrionFilterAndEffectsContainer& FilterContainer, class AActor* InInstigator, class AActor* InEffectCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "SetFilterContextInstigator");

	Params::OrionKismetLibrary_SetFilterContextInstigator Parms{};

	Parms.FilterContainer = std::move(FilterContainer);
	Parms.InInstigator = InInstigator;
	Parms.InEffectCauser = InEffectCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	FilterContainer = std::move(Parms.FilterContainer);
}


// Function OrionGame.OrionKismetLibrary.SetFilterContextOrigin
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FOrionFilterAndEffectsContainer  FilterContainer                                        (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          InOrigin                                               (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::SetFilterContextOrigin(struct FOrionFilterAndEffectsContainer& FilterContainer, const struct FVector& InOrigin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "SetFilterContextOrigin");

	Params::OrionKismetLibrary_SetFilterContextOrigin Parms{};

	Parms.FilterContainer = std::move(FilterContainer);
	Parms.InOrigin = std::move(InOrigin);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	FilterContainer = std::move(Parms.FilterContainer);
}


// Function OrionGame.OrionKismetLibrary.SetFilterContextSourceObject
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOrionFilterAndEffectsContainer  FilterContainer                                        (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UObject*                          NewSourceObject                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::SetFilterContextSourceObject(struct FOrionFilterAndEffectsContainer& FilterContainer, const class UObject* NewSourceObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "SetFilterContextSourceObject");

	Params::OrionKismetLibrary_SetFilterContextSourceObject Parms{};

	Parms.FilterContainer = std::move(FilterContainer);
	Parms.NewSourceObject = NewSourceObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	FilterContainer = std::move(Parms.FilterContainer);
}


// Function OrionGame.OrionKismetLibrary.SetFilterGameplayEffectLevel
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOrionFilterAndEffectsContainer  FilterContainer                                        (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      InGE                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   GameplayEffectLevel                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::SetFilterGameplayEffectLevel(struct FOrionFilterAndEffectsContainer& FilterContainer, TSubclassOf<class UGameplayEffect> InGE, float GameplayEffectLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "SetFilterGameplayEffectLevel");

	Params::OrionKismetLibrary_SetFilterGameplayEffectLevel Parms{};

	Parms.FilterContainer = std::move(FilterContainer);
	Parms.InGE = InGE;
	Parms.GameplayEffectLevel = GameplayEffectLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	FilterContainer = std::move(Parms.FilterContainer);
}


// Function OrionGame.OrionKismetLibrary.SetFilterSetByCallerMagnitude
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOrionFilterAndEffectsContainer  FilterContainer                                        (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      InGE                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SetByCallerName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Magnitude                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::SetFilterSetByCallerMagnitude(struct FOrionFilterAndEffectsContainer& FilterContainer, TSubclassOf<class UGameplayEffect> InGE, class FName SetByCallerName, float Magnitude)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "SetFilterSetByCallerMagnitude");

	Params::OrionKismetLibrary_SetFilterSetByCallerMagnitude Parms{};

	Parms.FilterContainer = std::move(FilterContainer);
	Parms.InGE = InGE;
	Parms.SetByCallerName = SetByCallerName;
	Parms.Magnitude = Magnitude;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	FilterContainer = std::move(Parms.FilterContainer);
}


// Function OrionGame.OrionKismetLibrary.SetFilterStackCountForGameplayEffect
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOrionFilterAndEffectsContainer  FilterContainer                                        (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      InGE                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::SetFilterStackCountForGameplayEffect(struct FOrionFilterAndEffectsContainer& FilterContainer, TSubclassOf<class UGameplayEffect> InGE, float InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "SetFilterStackCountForGameplayEffect");

	Params::OrionKismetLibrary_SetFilterStackCountForGameplayEffect Parms{};

	Parms.FilterContainer = std::move(FilterContainer);
	Parms.InGE = InGE;
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	FilterContainer = std::move(Parms.FilterContainer);
}


// Function OrionGame.OrionKismetLibrary.SetFilterTagSetByCallerMagnitude
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOrionFilterAndEffectsContainer  FilterContainer                                        (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      InGE                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     SetByCallerTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Magnitude                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::SetFilterTagSetByCallerMagnitude(struct FOrionFilterAndEffectsContainer& FilterContainer, TSubclassOf<class UGameplayEffect> InGE, const struct FGameplayTag& SetByCallerTag, float Magnitude)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "SetFilterTagSetByCallerMagnitude");

	Params::OrionKismetLibrary_SetFilterTagSetByCallerMagnitude Parms{};

	Parms.FilterContainer = std::move(FilterContainer);
	Parms.InGE = InGE;
	Parms.SetByCallerTag = std::move(SetByCallerTag);
	Parms.Magnitude = Magnitude;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	FilterContainer = std::move(Parms.FilterContainer);
}


// Function OrionGame.OrionKismetLibrary.SetTeamBarrierCollision
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Primitive                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionTeam                              OwnerTeam                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::SetTeamBarrierCollision(class UPrimitiveComponent* Primitive, EOrionTeam OwnerTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "SetTeamBarrierCollision");

	Params::OrionKismetLibrary_SetTeamBarrierCollision Parms{};

	Parms.Primitive = Primitive;
	Parms.OwnerTeam = OwnerTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionKismetLibrary.ShouldShowRenderingAndResolutionSettings
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionKismetLibrary::ShouldShowRenderingAndResolutionSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "ShouldShowRenderingAndResolutionSettings");

	Params::OrionKismetLibrary_ShouldShowRenderingAndResolutionSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.SignedAngleBetweenInDegrees
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        V0                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        V1                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOrionKismetLibrary::SignedAngleBetweenInDegrees(const struct FVector2D& V0, const struct FVector2D& V1)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "SignedAngleBetweenInDegrees");

	Params::OrionKismetLibrary_SignedAngleBetweenInDegrees Parms{};

	Parms.V0 = std::move(V0);
	Parms.V1 = std::move(V1);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.SignedAngleBetweenInRadians
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        V0                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        V1                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOrionKismetLibrary::SignedAngleBetweenInRadians(const struct FVector2D& V0, const struct FVector2D& V1)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "SignedAngleBetweenInRadians");

	Params::OrionKismetLibrary_SignedAngleBetweenInRadians Parms{};

	Parms.V0 = std::move(V0);
	Parms.V1 = std::move(V1);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.SpawnCoins
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DesiredCoinsToSpawn                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      OwnerController                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           HomingActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionTeam                              OwnerTeam                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SpawnLocation                                          (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            SourceTags                                             (Parm, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            SourceAssetTags                                        (Parm, NativeAccessSpecifierPublic)
// EOrionPickUpSpeed                       LaunchSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinCoinsToSpawnThreshold                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::SpawnCoins(class UObject* WorldContextObject, int32 DesiredCoinsToSpawn, class AActor* Owner, class AController* OwnerController, class AActor* HomingActor, EOrionTeam OwnerTeam, const struct FVector& SpawnLocation, const struct FGameplayTagContainer& SourceTags, const struct FGameplayTagContainer& SourceAssetTags, EOrionPickUpSpeed LaunchSpeed, int32 MinCoinsToSpawnThreshold)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "SpawnCoins");

	Params::OrionKismetLibrary_SpawnCoins Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.DesiredCoinsToSpawn = DesiredCoinsToSpawn;
	Parms.Owner = Owner;
	Parms.OwnerController = OwnerController;
	Parms.HomingActor = HomingActor;
	Parms.OwnerTeam = OwnerTeam;
	Parms.SpawnLocation = std::move(SpawnLocation);
	Parms.SourceTags = std::move(SourceTags);
	Parms.SourceAssetTags = std::move(SourceAssetTags);
	Parms.LaunchSpeed = LaunchSpeed;
	Parms.MinCoinsToSpawnThreshold = MinCoinsToSpawnThreshold;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionKismetLibrary.SpawnSoundOnActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USoundBase*                       SoundToPlay                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SoundTarget                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Attached                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopWhenAttachedToDestroyed                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* UOrionKismetLibrary::SpawnSoundOnActor(class USoundBase* SoundToPlay, class AActor* SoundTarget, bool Attached, bool bStopWhenAttachedToDestroyed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "SpawnSoundOnActor");

	Params::OrionKismetLibrary_SpawnSoundOnActor Parms{};

	Parms.SoundToPlay = SoundToPlay;
	Parms.SoundTarget = SoundTarget;
	Parms.Attached = Attached;
	Parms.bStopWhenAttachedToDestroyed = bStopWhenAttachedToDestroyed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.SpawnSoundOnActorAtLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class USoundBase*                       SoundToPlay                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SoundTarget                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldLocation                                          (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopWhenAttachedToDestroyed                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* UOrionKismetLibrary::SpawnSoundOnActorAtLocation(class USoundBase* SoundToPlay, class AActor* SoundTarget, const struct FVector& WorldLocation, bool bStopWhenAttachedToDestroyed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "SpawnSoundOnActorAtLocation");

	Params::OrionKismetLibrary_SpawnSoundOnActorAtLocation Parms{};

	Parms.SoundToPlay = SoundToPlay;
	Parms.SoundTarget = SoundTarget;
	Parms.WorldLocation = std::move(WorldLocation);
	Parms.bStopWhenAttachedToDestroyed = bStopWhenAttachedToDestroyed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.SpawnSoundTeamAdjusted
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USoundBase*                       SoundToPlay                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SoundInstigator                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SoundTarget                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceCreateAudioComponent                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopWhenDestroyed                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* UOrionKismetLibrary::SpawnSoundTeamAdjusted(class USoundBase* SoundToPlay, class AActor* SoundInstigator, class AActor* SoundTarget, bool bForceCreateAudioComponent, bool bStopWhenDestroyed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "SpawnSoundTeamAdjusted");

	Params::OrionKismetLibrary_SpawnSoundTeamAdjusted Parms{};

	Parms.SoundToPlay = SoundToPlay;
	Parms.SoundInstigator = SoundInstigator;
	Parms.SoundTarget = SoundTarget;
	Parms.bForceCreateAudioComponent = bForceCreateAudioComponent;
	Parms.bStopWhenDestroyed = bStopWhenDestroyed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.SpawnSoundTeamAdjustedAtLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class USoundBase*                       SoundToPlay                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SoundInstigator                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SoundTarget                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldLocation                                          (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopWhenAttachedToDestroyed                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* UOrionKismetLibrary::SpawnSoundTeamAdjustedAtLocation(class USoundBase* SoundToPlay, class AActor* SoundInstigator, class AActor* SoundTarget, const struct FVector& WorldLocation, bool bStopWhenAttachedToDestroyed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "SpawnSoundTeamAdjustedAtLocation");

	Params::OrionKismetLibrary_SpawnSoundTeamAdjustedAtLocation Parms{};

	Parms.SoundToPlay = SoundToPlay;
	Parms.SoundInstigator = SoundInstigator;
	Parms.SoundTarget = SoundTarget;
	Parms.WorldLocation = std::move(WorldLocation);
	Parms.bStopWhenAttachedToDestroyed = bStopWhenAttachedToDestroyed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.SplitGameplayEffectSpecBetweenActors
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayEffectSpecHandle        SpecHandle                                             (Parm, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   TargetActors                                           (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FName>                     DataNames                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FActiveGameplayEffectHandle>AppliedEffectHandles                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::SplitGameplayEffectSpecBetweenActors(const struct FGameplayEffectSpecHandle& SpecHandle, TArray<class AActor*>& TargetActors, TArray<class FName>& DataNames, TArray<struct FActiveGameplayEffectHandle>* AppliedEffectHandles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "SplitGameplayEffectSpecBetweenActors");

	Params::OrionKismetLibrary_SplitGameplayEffectSpecBetweenActors Parms{};

	Parms.SpecHandle = std::move(SpecHandle);
	Parms.TargetActors = std::move(TargetActors);
	Parms.DataNames = std::move(DataNames);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	TargetActors = std::move(Parms.TargetActors);
	DataNames = std::move(Parms.DataNames);

	if (AppliedEffectHandles != nullptr)
		*AppliedEffectHandles = std::move(Parms.AppliedEffectHandles);
}


// Function OrionGame.OrionKismetLibrary.SplitGameplayEffectSpecBetweenTargetData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayEffectSpecHandle        SpecHandle                                             (Parm, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle TargetDataHandle                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FName>                     DataNames                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FActiveGameplayEffectHandle>AppliedEffectHandles                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::SplitGameplayEffectSpecBetweenTargetData(const struct FGameplayEffectSpecHandle& SpecHandle, const struct FGameplayAbilityTargetDataHandle& TargetDataHandle, TArray<class FName>& DataNames, TArray<struct FActiveGameplayEffectHandle>* AppliedEffectHandles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "SplitGameplayEffectSpecBetweenTargetData");

	Params::OrionKismetLibrary_SplitGameplayEffectSpecBetweenTargetData Parms{};

	Parms.SpecHandle = std::move(SpecHandle);
	Parms.TargetDataHandle = std::move(TargetDataHandle);
	Parms.DataNames = std::move(DataNames);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DataNames = std::move(Parms.DataNames);

	if (AppliedEffectHandles != nullptr)
		*AppliedEffectHandles = std::move(Parms.AppliedEffectHandles);
}


// Function OrionGame.OrionKismetLibrary.SplitTargetData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayAbilityTargetDataHandle TargetData                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FGameplayAbilityTargetDataHandle>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FGameplayAbilityTargetDataHandle> UOrionKismetLibrary::SplitTargetData(const struct FGameplayAbilityTargetDataHandle& TargetData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "SplitTargetData");

	Params::OrionKismetLibrary_SplitTargetData Parms{};

	Parms.TargetData = std::move(TargetData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionKismetLibrary.StopCameraAnimOnActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCameraAnim*                      AnimToStop                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::StopCameraAnimOnActor(class AActor* Actor, class UCameraAnim* AnimToStop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "StopCameraAnimOnActor");

	Params::OrionKismetLibrary_StopCameraAnimOnActor Parms{};

	Parms.Actor = Actor;
	Parms.AnimToStop = AnimToStop;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionKismetLibrary.StopCameraShakeOnActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UCameraShake>         Shake                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bImmediately                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::StopCameraShakeOnActor(class AActor* Actor, TSubclassOf<class UCameraShake> Shake, bool bImmediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "StopCameraShakeOnActor");

	Params::OrionKismetLibrary_StopCameraShakeOnActor Parms{};

	Parms.Actor = Actor;
	Parms.Shake = Shake;
	Parms.bImmediately = bImmediately;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionKismetLibrary.StopForceFeedbackOnActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UForceFeedbackEffect*             ForceFeedbackEffect                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::StopForceFeedbackOnActor(class AActor* Actor, class UForceFeedbackEffect* ForceFeedbackEffect, class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "StopForceFeedbackOnActor");

	Params::OrionKismetLibrary_StopForceFeedbackOnActor Parms{};

	Parms.Actor = Actor;
	Parms.ForceFeedbackEffect = ForceFeedbackEffect;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionKismetLibrary.TagSplitGameplayEffectSpecBetweenActors
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayEffectSpecHandle        SpecHandle                                             (Parm, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   TargetActors                                           (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            DataTags                                               (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FActiveGameplayEffectHandle>AppliedEffectHandles                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::TagSplitGameplayEffectSpecBetweenActors(const struct FGameplayEffectSpecHandle& SpecHandle, TArray<class AActor*>& TargetActors, struct FGameplayTagContainer& DataTags, TArray<struct FActiveGameplayEffectHandle>* AppliedEffectHandles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "TagSplitGameplayEffectSpecBetweenActors");

	Params::OrionKismetLibrary_TagSplitGameplayEffectSpecBetweenActors Parms{};

	Parms.SpecHandle = std::move(SpecHandle);
	Parms.TargetActors = std::move(TargetActors);
	Parms.DataTags = std::move(DataTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	TargetActors = std::move(Parms.TargetActors);
	DataTags = std::move(Parms.DataTags);

	if (AppliedEffectHandles != nullptr)
		*AppliedEffectHandles = std::move(Parms.AppliedEffectHandles);
}


// Function OrionGame.OrionKismetLibrary.TagSplitGameplayEffectSpecBetweenTargetData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayEffectSpecHandle        SpecHandle                                             (Parm, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle TargetDataHandle                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            DataTags                                               (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FActiveGameplayEffectHandle>AppliedEffectHandles                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UOrionKismetLibrary::TagSplitGameplayEffectSpecBetweenTargetData(const struct FGameplayEffectSpecHandle& SpecHandle, const struct FGameplayAbilityTargetDataHandle& TargetDataHandle, struct FGameplayTagContainer& DataTags, TArray<struct FActiveGameplayEffectHandle>* AppliedEffectHandles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionKismetLibrary", "TagSplitGameplayEffectSpecBetweenTargetData");

	Params::OrionKismetLibrary_TagSplitGameplayEffectSpecBetweenTargetData Parms{};

	Parms.SpecHandle = std::move(SpecHandle);
	Parms.TargetDataHandle = std::move(TargetDataHandle);
	Parms.DataTags = std::move(DataTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DataTags = std::move(Parms.DataTags);

	if (AppliedEffectHandles != nullptr)
		*AppliedEffectHandles = std::move(Parms.AppliedEffectHandles);
}


// Function OrionGame.OrionListItem.Private_OnExpanderArrowShiftClicked
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IOrionListItem::Private_OnExpanderArrowShiftClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionListItem", "Private_OnExpanderArrowShiftClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionListItem.RegisterOnClicked
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TDelegate<void(class UUserWidget* Widget)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void IOrionListItem::RegisterOnClicked(const TDelegate<void(class UUserWidget* Widget)>& Callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionListItem", "RegisterOnClicked");

	Params::OrionListItem_RegisterOnClicked Parms{};

	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionListItem.RegisterOnHovered
// (Native, Public, HasOutParams)
// Parameters:
// TDelegate<void(class UUserWidget* Widget, bool bIsHovered)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void IOrionListItem::RegisterOnHovered(const TDelegate<void(class UUserWidget* Widget, bool bIsHovered)>& Callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionListItem", "RegisterOnHovered");

	Params::OrionListItem_RegisterOnHovered Parms{};

	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionListItem.SetIndexInList
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   InIndexInList                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IOrionListItem::SetIndexInList(int32 InIndexInList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionListItem", "SetIndexInList");

	Params::OrionListItem_SetIndexInList Parms{};

	Parms.InIndexInList = InIndexInList;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionListItem.SetSelected
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bSelected                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IOrionListItem::SetSelected(bool bSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionListItem", "SetSelected");

	Params::OrionListItem_SetSelected Parms{};

	Parms.bSelected = bSelected;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionListItem.ToggleExpansion
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IOrionListItem::ToggleExpansion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionListItem", "ToggleExpansion");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionListItem.DoesItemHaveChildren
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 IOrionListItem::DoesItemHaveChildren() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionListItem", "DoesItemHaveChildren");

	Params::OrionListItem_DoesItemHaveChildren Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionListItem.GetIndentLevel
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 IOrionListItem::GetIndentLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionListItem", "GetIndentLevel");

	Params::OrionListItem_GetIndentLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionListItem.GetSelectionMode
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// ESelectionMode                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESelectionMode IOrionListItem::GetSelectionMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionListItem", "GetSelectionMode");

	Params::OrionListItem_GetSelectionMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionListItem.IsItemExpanded
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IOrionListItem::IsItemExpanded() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionListItem", "IsItemExpanded");

	Params::OrionListItem_IsItemExpanded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionLoadingActor.OnSetSlotIndex
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionLoadingActor::OnSetSlotIndex(int32 SlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionLoadingActor", "OnSetSlotIndex");

	Params::OrionLoadingActor_OnSetSlotIndex Parms{};

	Parms.SlotIndex = SlotIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionLoadingScreen.OnLoadingScreenHidden
// (Event, Protected, BlueprintEvent)

void UOrionLoadingScreen::OnLoadingScreenHidden()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionLoadingScreen", "OnLoadingScreenHidden");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionLoadingScreen.OnLoadingScreenShown
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bIsUsingFallback                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionLoadingScreen::OnLoadingScreenShown(bool bIsUsingFallback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionLoadingScreen", "OnLoadingScreenShown");

	Params::OrionLoadingScreen_OnLoadingScreenShown Parms{};

	Parms.bIsUsingFallback = bIsUsingFallback;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionMatchmakingDisplayLibrary.GetBanReasonText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// EOrionBanReason                         BanReason                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             OutText                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UOrionMatchmakingDisplayLibrary::GetBanReasonText(EOrionBanReason BanReason, class FText* OutText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionMatchmakingDisplayLibrary", "GetBanReasonText");

	Params::OrionMatchmakingDisplayLibrary_GetBanReasonText Parms{};

	Parms.BanReason = BanReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutText != nullptr)
		*OutText = std::move(Parms.OutText);
}


// Function OrionGame.OrionMatchmakingDisplayLibrary.GetHeroAvailabilityText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EOrionHeroAvailability                  Availability                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionHeroData*                   HeroData                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             OutText                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UOrionMatchmakingDisplayLibrary::GetHeroAvailabilityText(EOrionHeroAvailability Availability, const class UOrionHeroData* HeroData, class FText* OutText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionMatchmakingDisplayLibrary", "GetHeroAvailabilityText");

	Params::OrionMatchmakingDisplayLibrary_GetHeroAvailabilityText Parms{};

	Parms.Availability = Availability;
	Parms.HeroData = HeroData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutText != nullptr)
		*OutText = std::move(Parms.OutText);
}


// Function OrionGame.OrionMatchmakingDisplayLibrary.GetTeamColor
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// EOrionTeamMemberType                    TeamMemberType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TeamColor                                              (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionMatchmakingDisplayLibrary::GetTeamColor(EOrionTeamMemberType TeamMemberType, struct FLinearColor* TeamColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionMatchmakingDisplayLibrary", "GetTeamColor");

	Params::OrionMatchmakingDisplayLibrary_GetTeamColor Parms{};

	Parms.TeamMemberType = TeamMemberType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (TeamColor != nullptr)
		*TeamColor = std::move(Parms.TeamColor);
}


// Function OrionGame.OrionMcpBannerAlterationItem.GetInternalData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UOrionMcpBannerAlterationItemDefinition*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionMcpBannerAlterationItemDefinition* UOrionMcpBannerAlterationItem::GetInternalData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpBannerAlterationItem", "GetInternalData");

	Params::OrionMcpBannerAlterationItem_GetInternalData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionMcpBannerItem.GetInternalData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UOrionMcpBannerItemDefinition*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionMcpBannerItemDefinition* UOrionMcpBannerItem::GetInternalData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpBannerItem", "GetInternalData");

	Params::OrionMcpBannerItem_GetInternalData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionMcpBoostItem.GetInternalData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UOrionBoostItemDefinition*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionBoostItemDefinition* UOrionMcpBoostItem::GetInternalData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpBoostItem", "GetInternalData");

	Params::OrionMcpBoostItem_GetInternalData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionMcpCardItem.GetInternalData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UOrionMcpCardItemDefinition*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionMcpCardItemDefinition* UOrionMcpCardItem::GetInternalData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpCardItem", "GetInternalData");

	Params::OrionMcpCardItem_GetInternalData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionMcpCardItemDefinition.GetAffinity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAffinityType                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAffinityType UOrionMcpCardItemDefinition::GetAffinity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpCardItemDefinition", "GetAffinity");

	Params::OrionMcpCardItemDefinition_GetAffinity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionMcpCardPackItem.GetInternalData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UOrionMcpCardPackItemDefinition*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionMcpCardPackItemDefinition* UOrionMcpCardPackItem::GetInternalData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpCardPackItem", "GetInternalData");

	Params::OrionMcpCardPackItem_GetInternalData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionMcpCodeTokenItem.GetInternalData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UOrionMcpCodeTokenItemDefinition* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionMcpCodeTokenItemDefinition* UOrionMcpCodeTokenItem::GetInternalData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpCodeTokenItem", "GetInternalData");

	Params::OrionMcpCodeTokenItem_GetInternalData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionEmoteItemDefinition.GetAnimMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UOrionSkinItemDefinition*         SkinItemDefinition                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UOrionEmoteItemDefinition::GetAnimMontage(const class UOrionSkinItemDefinition* SkinItemDefinition) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionEmoteItemDefinition", "GetAnimMontage");

	Params::OrionEmoteItemDefinition_GetAnimMontage Parms{};

	Parms.SkinItemDefinition = SkinItemDefinition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionMcpGiftBoxItem.GetInternalData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UOrionMcpGiftBoxItemDefinition*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionMcpGiftBoxItemDefinition* UOrionMcpGiftBoxItem::GetInternalData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpGiftBoxItem", "GetInternalData");

	Params::OrionMcpGiftBoxItem_GetInternalData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionMcpGlyphItem.GetInternalData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UOrionMcpGlyphItemDefinition*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionMcpGlyphItemDefinition* UOrionMcpGlyphItem::GetInternalData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpGlyphItem", "GetInternalData");

	Params::OrionMcpGlyphItem_GetInternalData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionMcpHeroItem.GetInternalData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UOrionHeroData*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionHeroData* UOrionMcpHeroItem::GetInternalData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpHeroItem", "GetInternalData");

	Params::OrionMcpHeroItem_GetInternalData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionMcpProfileAccount.ActivateBoost
// (Net, NetReliable, NetRequest, Native, Event, Public, HasOutParams)
// Parameters:
// class FString                           BoostId                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FClientUrlContext                Context                                                (Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)

void UOrionMcpProfileAccount::ActivateBoost(const class FString& BoostId, struct FClientUrlContext* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpProfileAccount", "ActivateBoost");

	Params::OrionMcpProfileAccount_ActivateBoost Parms{};

	Parms.BoostId = std::move(BoostId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Context != nullptr)
		*Context = std::move(Parms.Context);
}


// Function OrionGame.OrionMcpProfileAccount.ApplyBannerAlteration
// (Net, NetReliable, NetRequest, Native, Event, Public, HasOutParams)
// Parameters:
// class FString                           bannerId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           AlterationId                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AlterationSlot                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FClientUrlContext                Context                                                (Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)

void UOrionMcpProfileAccount::ApplyBannerAlteration(const class FString& bannerId, const class FString& AlterationId, int32 AlterationSlot, struct FClientUrlContext* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpProfileAccount", "ApplyBannerAlteration");

	Params::OrionMcpProfileAccount_ApplyBannerAlteration Parms{};

	Parms.bannerId = std::move(bannerId);
	Parms.AlterationId = std::move(AlterationId);
	Parms.AlterationSlot = AlterationSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Context != nullptr)
		*Context = std::move(Parms.Context);
}


// Function OrionGame.OrionMcpProfileAccount.AttachBanner
// (Net, NetReliable, NetRequest, Native, Event, Public, HasOutParams)
// Parameters:
// class FString                           AttacheeId                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           AttachmentId                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SocketIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FClientUrlContext                Context                                                (Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)

void UOrionMcpProfileAccount::AttachBanner(const class FString& AttacheeId, const class FString& AttachmentId, int32 SocketIndex, struct FClientUrlContext* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpProfileAccount", "AttachBanner");

	Params::OrionMcpProfileAccount_AttachBanner Parms{};

	Parms.AttacheeId = std::move(AttacheeId);
	Parms.AttachmentId = std::move(AttachmentId);
	Parms.SocketIndex = SocketIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Context != nullptr)
		*Context = std::move(Parms.Context);
}


// Function OrionGame.OrionMcpProfileAccount.BannerBulkEdit
// (Net, NetReliable, NetRequest, Native, Event, Public, HasOutParams)
// Parameters:
// struct FBannerBulkCommandList           Commands                                               (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FClientUrlContext                Context                                                (Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)

void UOrionMcpProfileAccount::BannerBulkEdit(const struct FBannerBulkCommandList& Commands, struct FClientUrlContext* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpProfileAccount", "BannerBulkEdit");

	Params::OrionMcpProfileAccount_BannerBulkEdit Parms{};

	Parms.Commands = std::move(Commands);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Context != nullptr)
		*Context = std::move(Parms.Context);
}


// Function OrionGame.OrionMcpProfileAccount.CheckForStuff
// (Net, NetReliable, NetRequest, Native, Event, Public, HasOutParams)
// Parameters:
// struct FClientUrlContext                Context                                                (Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)

void UOrionMcpProfileAccount::CheckForStuff(struct FClientUrlContext* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpProfileAccount", "CheckForStuff");

	Params::OrionMcpProfileAccount_CheckForStuff Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Context != nullptr)
		*Context = std::move(Parms.Context);
}


// Function OrionGame.OrionMcpProfileAccount.ClaimLoginReward
// (Net, NetReliable, NetRequest, Native, Event, Public, HasOutParams)
// Parameters:
// struct FClientUrlContext                Context                                                (Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)

void UOrionMcpProfileAccount::ClaimLoginReward(struct FClientUrlContext* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpProfileAccount", "ClaimLoginReward");

	Params::OrionMcpProfileAccount_ClaimLoginReward Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Context != nullptr)
		*Context = std::move(Parms.Context);
}


// Function OrionGame.OrionMcpProfileAccount.CompleteMatch
// (Net, NetReliable, NetRequest, Native, Event, Public, HasOutParams)
// Parameters:
// class FString                           HeroTemplateName                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayStats                   NewStatsV2                                             (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FTeamOwnershipXPBonus            TeamOwnershipXPBonus                                   (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FOrionPlayerEndMatchData         EndMatchData                                           (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FDedicatedServerUrlContext       Context                                                (Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)

void UOrionMcpProfileAccount::CompleteMatch(const class FString& HeroTemplateName, const struct FGameplayStats& NewStatsV2, const struct FTeamOwnershipXPBonus& TeamOwnershipXPBonus, const struct FOrionPlayerEndMatchData& EndMatchData, struct FDedicatedServerUrlContext* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpProfileAccount", "CompleteMatch");

	Params::OrionMcpProfileAccount_CompleteMatch Parms{};

	Parms.HeroTemplateName = std::move(HeroTemplateName);
	Parms.NewStatsV2 = std::move(NewStatsV2);
	Parms.TeamOwnershipXPBonus = std::move(TeamOwnershipXPBonus);
	Parms.EndMatchData = std::move(EndMatchData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Context != nullptr)
		*Context = std::move(Parms.Context);
}


// Function OrionGame.OrionMcpProfileAccount.CreateNewUserDeck
// (Net, NetReliable, NetRequest, Native, Event, Public, HasOutParams)
// Parameters:
// struct FClientUrlContext                Context                                                (Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)

void UOrionMcpProfileAccount::CreateNewUserDeck(struct FClientUrlContext* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpProfileAccount", "CreateNewUserDeck");

	Params::OrionMcpProfileAccount_CreateNewUserDeck Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Context != nullptr)
		*Context = std::move(Parms.Context);
}


// Function OrionGame.OrionMcpProfileAccount.CreditClientStat
// (Net, NetReliable, NetRequest, Native, Event, Public, HasOutParams)
// Parameters:
// class FString                           StatName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StatCount                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FClientUrlContext                Context                                                (Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)

void UOrionMcpProfileAccount::CreditClientStat(const class FString& StatName, const int32 StatCount, struct FClientUrlContext* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpProfileAccount", "CreditClientStat");

	Params::OrionMcpProfileAccount_CreditClientStat Parms{};

	Parms.StatName = std::move(StatName);
	Parms.StatCount = StatCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Context != nullptr)
		*Context = std::move(Parms.Context);
}


// Function OrionGame.OrionMcpProfileAccount.DeleteDeck
// (Net, NetReliable, NetRequest, Native, Event, Public, HasOutParams)
// Parameters:
// class FString                           DeckId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FClientUrlContext                Context                                                (Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)

void UOrionMcpProfileAccount::DeleteDeck(const class FString& DeckId, struct FClientUrlContext* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpProfileAccount", "DeleteDeck");

	Params::OrionMcpProfileAccount_DeleteDeck Parms{};

	Parms.DeckId = std::move(DeckId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Context != nullptr)
		*Context = std::move(Parms.Context);
}


// Function OrionGame.OrionMcpProfileAccount.ExtractBannerAlteration
// (Net, NetReliable, NetRequest, Native, Event, Public, HasOutParams)
// Parameters:
// class FString                           bannerId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AlterationSlot                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FClientUrlContext                Context                                                (Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)

void UOrionMcpProfileAccount::ExtractBannerAlteration(const class FString& bannerId, int32 AlterationSlot, struct FClientUrlContext* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpProfileAccount", "ExtractBannerAlteration");

	Params::OrionMcpProfileAccount_ExtractBannerAlteration Parms{};

	Parms.bannerId = std::move(bannerId);
	Parms.AlterationSlot = AlterationSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Context != nullptr)
		*Context = std::move(Parms.Context);
}


// Function OrionGame.OrionMcpProfileAccount.IssueFriendCode
// (Net, NetReliable, NetRequest, Native, Event, Public, HasOutParams)
// Parameters:
// class FString                           CodeTokenType                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FClientUrlContext                Context                                                (Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)

void UOrionMcpProfileAccount::IssueFriendCode(const class FString& CodeTokenType, struct FClientUrlContext* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpProfileAccount", "IssueFriendCode");

	Params::OrionMcpProfileAccount_IssueFriendCode Parms{};

	Parms.CodeTokenType = std::move(CodeTokenType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Context != nullptr)
		*Context = std::move(Parms.Context);
}


// Function OrionGame.OrionMcpProfileAccount.NoteNewItems
// (Net, NetReliable, NetRequest, Native, Event, Public, HasOutParams)
// Parameters:
// struct FItemIdList                      NewItemList                                            (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FClientUrlContext                Context                                                (Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)

void UOrionMcpProfileAccount::NoteNewItems(const struct FItemIdList& NewItemList, struct FClientUrlContext* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpProfileAccount", "NoteNewItems");

	Params::OrionMcpProfileAccount_NoteNewItems Parms{};

	Parms.NewItemList = std::move(NewItemList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Context != nullptr)
		*Context = std::move(Parms.Context);
}


// DelegateFunction OrionGame.OrionMcpProfileAccount.OnRotationalContentChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UOrionMcpProfileAccount::OnRotationalContentChanged__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpProfileAccount", "OnRotationalContentChanged__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionMcpProfileAccount.OpenCardPack
// (Net, NetReliable, NetRequest, Native, Event, Public, HasOutParams)
// Parameters:
// class FString                           CardPackItemId                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           KeyId                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FClientUrlContext                Context                                                (Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)

void UOrionMcpProfileAccount::OpenCardPack(const class FString& CardPackItemId, const class FString& KeyId, struct FClientUrlContext* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpProfileAccount", "OpenCardPack");

	Params::OrionMcpProfileAccount_OpenCardPack Parms{};

	Parms.CardPackItemId = std::move(CardPackItemId);
	Parms.KeyId = std::move(KeyId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Context != nullptr)
		*Context = std::move(Parms.Context);
}


// Function OrionGame.OrionMcpProfileAccount.OpenGiftBox
// (Net, NetReliable, NetRequest, Native, Event, Public, HasOutParams)
// Parameters:
// class FString                           GiftBoxItemID                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FClientUrlContext                Context                                                (Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)

void UOrionMcpProfileAccount::OpenGiftBox(const class FString& GiftBoxItemID, struct FClientUrlContext* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpProfileAccount", "OpenGiftBox");

	Params::OrionMcpProfileAccount_OpenGiftBox Parms{};

	Parms.GiftBoxItemID = std::move(GiftBoxItemID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Context != nullptr)
		*Context = std::move(Parms.Context);
}


// Function OrionGame.OrionMcpProfileAccount.OpenVault
// (Net, NetReliable, NetRequest, Native, Event, Public, HasOutParams)
// Parameters:
// class FString                           VaultTemplateName                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FClientUrlContext                Context                                                (Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)

void UOrionMcpProfileAccount::OpenVault(const class FString& VaultTemplateName, struct FClientUrlContext* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpProfileAccount", "OpenVault");

	Params::OrionMcpProfileAccount_OpenVault Parms{};

	Parms.VaultTemplateName = std::move(VaultTemplateName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Context != nullptr)
		*Context = std::move(Parms.Context);
}


// Function OrionGame.OrionMcpProfileAccount.PrestigeAccount
// (Net, NetReliable, NetRequest, Native, Event, Public, HasOutParams)
// Parameters:
// struct FClientUrlContext                Context                                                (Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)

void UOrionMcpProfileAccount::PrestigeAccount(struct FClientUrlContext* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpProfileAccount", "PrestigeAccount");

	Params::OrionMcpProfileAccount_PrestigeAccount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Context != nullptr)
		*Context = std::move(Parms.Context);
}


// Function OrionGame.OrionMcpProfileAccount.PurchaseDeckSlot
// (Net, NetReliable, NetRequest, Native, Event, Public, HasOutParams)
// Parameters:
// bool                                    MtxEquivalency                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FClientUrlContext                Context                                                (Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)

void UOrionMcpProfileAccount::PurchaseDeckSlot(bool MtxEquivalency, struct FClientUrlContext* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpProfileAccount", "PurchaseDeckSlot");

	Params::OrionMcpProfileAccount_PurchaseDeckSlot Parms{};

	Parms.MtxEquivalency = MtxEquivalency;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Context != nullptr)
		*Context = std::move(Parms.Context);
}


// Function OrionGame.OrionMcpProfileAccount.RankUpCard
// (Net, NetReliable, NetRequest, Native, Event, Public, HasOutParams)
// Parameters:
// class FString                           CardTemplateId                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    MtxEquivalency                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FClientUrlContext                Context                                                (Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)

void UOrionMcpProfileAccount::RankUpCard(const class FString& CardTemplateId, bool MtxEquivalency, struct FClientUrlContext* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpProfileAccount", "RankUpCard");

	Params::OrionMcpProfileAccount_RankUpCard Parms{};

	Parms.CardTemplateId = std::move(CardTemplateId);
	Parms.MtxEquivalency = MtxEquivalency;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Context != nullptr)
		*Context = std::move(Parms.Context);
}


// Function OrionGame.OrionMcpProfileAccount.RankUpMastery
// (Net, NetReliable, NetRequest, Native, Event, Public, HasOutParams)
// Parameters:
// class FString                           HeroItemId                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    MtxEquivalency                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ApplyLastMatch                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FClientUrlContext                Context                                                (Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)

void UOrionMcpProfileAccount::RankUpMastery(const class FString& HeroItemId, bool MtxEquivalency, bool ApplyLastMatch, struct FClientUrlContext* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpProfileAccount", "RankUpMastery");

	Params::OrionMcpProfileAccount_RankUpMastery Parms{};

	Parms.HeroItemId = std::move(HeroItemId);
	Parms.MtxEquivalency = MtxEquivalency;
	Parms.ApplyLastMatch = ApplyLastMatch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Context != nullptr)
		*Context = std::move(Parms.Context);
}


// Function OrionGame.OrionMcpProfileAccount.ReportQueueDodge
// (Net, NetReliable, NetRequest, Native, Event, Public, HasOutParams)
// Parameters:
// EOrionDodgeType                         DodgeType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDedicatedServerUrlContext       Context                                                (Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)

void UOrionMcpProfileAccount::ReportQueueDodge(EOrionDodgeType DodgeType, struct FDedicatedServerUrlContext* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpProfileAccount", "ReportQueueDodge");

	Params::OrionMcpProfileAccount_ReportQueueDodge Parms{};

	Parms.DodgeType = DodgeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Context != nullptr)
		*Context = std::move(Parms.Context);
}


// Function OrionGame.OrionMcpProfileAccount.SelectFreeMasteryHero
// (Net, NetReliable, NetRequest, Native, Event, Public, HasOutParams)
// Parameters:
// class FString                           HeroItemId                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           TokenTemplateName                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FClientUrlContext                Context                                                (Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)

void UOrionMcpProfileAccount::SelectFreeMasteryHero(const class FString& HeroItemId, const class FString& TokenTemplateName, struct FClientUrlContext* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpProfileAccount", "SelectFreeMasteryHero");

	Params::OrionMcpProfileAccount_SelectFreeMasteryHero Parms{};

	Parms.HeroItemId = std::move(HeroItemId);
	Parms.TokenTemplateName = std::move(TokenTemplateName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Context != nullptr)
		*Context = std::move(Parms.Context);
}


// Function OrionGame.OrionMcpProfileAccount.SetBannerForAccount
// (Net, NetReliable, NetRequest, Native, Event, Public, HasOutParams)
// Parameters:
// class FString                           bannerId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FClientUrlContext                Context                                                (Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)

void UOrionMcpProfileAccount::SetBannerForAccount(const class FString& bannerId, struct FClientUrlContext* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpProfileAccount", "SetBannerForAccount");

	Params::OrionMcpProfileAccount_SetBannerForAccount Parms{};

	Parms.bannerId = std::move(bannerId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Context != nullptr)
		*Context = std::move(Parms.Context);
}


// Function OrionGame.OrionMcpProfileAccount.SetBannerName
// (Net, NetReliable, NetRequest, Native, Event, Public, HasOutParams)
// Parameters:
// class FString                           bannerName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           bannerId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FClientUrlContext                Context                                                (Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)

void UOrionMcpProfileAccount::SetBannerName(const class FString& bannerName, const class FString& bannerId, struct FClientUrlContext* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpProfileAccount", "SetBannerName");

	Params::OrionMcpProfileAccount_SetBannerName Parms{};

	Parms.bannerName = std::move(bannerName);
	Parms.bannerId = std::move(bannerId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Context != nullptr)
		*Context = std::move(Parms.Context);
}


// Function OrionGame.OrionMcpProfileAccount.SetCosmeticChoices
// (Net, NetReliable, NetRequest, Native, Event, Public, HasOutParams)
// Parameters:
// class FString                           HeroId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FOrionCosmeticPlayerChoices      CosmeticChoices                                        (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FClientUrlContext                Context                                                (Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)

void UOrionMcpProfileAccount::SetCosmeticChoices(const class FString& HeroId, const struct FOrionCosmeticPlayerChoices& CosmeticChoices, struct FClientUrlContext* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpProfileAccount", "SetCosmeticChoices");

	Params::OrionMcpProfileAccount_SetCosmeticChoices Parms{};

	Parms.HeroId = std::move(HeroId);
	Parms.CosmeticChoices = std::move(CosmeticChoices);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Context != nullptr)
		*Context = std::move(Parms.Context);
}


// Function OrionGame.OrionMcpProfileAccount.SetDeckName
// (Net, NetReliable, NetRequest, Native, Event, Public, HasOutParams)
// Parameters:
// class FString                           DeckName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           DeckId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FClientUrlContext                Context                                                (Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)

void UOrionMcpProfileAccount::SetDeckName(const class FString& DeckName, const class FString& DeckId, struct FClientUrlContext* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpProfileAccount", "SetDeckName");

	Params::OrionMcpProfileAccount_SetDeckName Parms{};

	Parms.DeckName = std::move(DeckName);
	Parms.DeckId = std::move(DeckId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Context != nullptr)
		*Context = std::move(Parms.Context);
}


// Function OrionGame.OrionMcpProfileAccount.SetPlatform
// (Net, NetReliable, NetRequest, Native, Event, Public, HasOutParams)
// Parameters:
// EOrionPlatformType                      NewPlatform                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FClientUrlContext                Context                                                (Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)

void UOrionMcpProfileAccount::SetPlatform(const EOrionPlatformType NewPlatform, struct FClientUrlContext* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpProfileAccount", "SetPlatform");

	Params::OrionMcpProfileAccount_SetPlatform Parms{};

	Parms.NewPlatform = NewPlatform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Context != nullptr)
		*Context = std::move(Parms.Context);
}


// Function OrionGame.OrionMcpProfileAccount.SetPlayerVeterancy
// (Net, NetReliable, NetRequest, Native, Event, Public, HasOutParams)
// Parameters:
// EOrionVeterancy                         Veterancy                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FClientUrlContext                Context                                                (Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)

void UOrionMcpProfileAccount::SetPlayerVeterancy(const EOrionVeterancy& Veterancy, struct FClientUrlContext* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpProfileAccount", "SetPlayerVeterancy");

	Params::OrionMcpProfileAccount_SetPlayerVeterancy Parms{};

	Parms.Veterancy = Veterancy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Context != nullptr)
		*Context = std::move(Parms.Context);
}


// Function OrionGame.OrionMcpProfileAccount.SetSkinCosmeticChoices
// (Net, NetReliable, NetRequest, Native, Event, Public, HasOutParams)
// Parameters:
// class FString                           SkinName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ActiveSkinVariation                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FClientUrlContext                Context                                                (Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)

void UOrionMcpProfileAccount::SetSkinCosmeticChoices(const class FString& SkinName, const class FString& ActiveSkinVariation, struct FClientUrlContext* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpProfileAccount", "SetSkinCosmeticChoices");

	Params::OrionMcpProfileAccount_SetSkinCosmeticChoices Parms{};

	Parms.SkinName = std::move(SkinName);
	Parms.ActiveSkinVariation = std::move(ActiveSkinVariation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Context != nullptr)
		*Context = std::move(Parms.Context);
}


// Function OrionGame.OrionMcpProfileAccount.SetUserCreatedDeck
// (Net, NetReliable, NetRequest, Native, Event, Public, HasOutParams)
// Parameters:
// struct FUserCreatedDeck                 UserCreatedDeck                                        (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           DeckId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FClientUrlContext                Context                                                (Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)

void UOrionMcpProfileAccount::SetUserCreatedDeck(const struct FUserCreatedDeck& UserCreatedDeck, const class FString& DeckId, struct FClientUrlContext* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpProfileAccount", "SetUserCreatedDeck");

	Params::OrionMcpProfileAccount_SetUserCreatedDeck Parms{};

	Parms.UserCreatedDeck = std::move(UserCreatedDeck);
	Parms.DeckId = std::move(DeckId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Context != nullptr)
		*Context = std::move(Parms.Context);
}


// Function OrionGame.OrionMcpProfileAccount.UpdateAccountStatus
// (Net, NetReliable, NetRequest, Native, Event, Public, HasOutParams)
// Parameters:
// struct FClientUrlContext                Context                                                (Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)

void UOrionMcpProfileAccount::UpdateAccountStatus(struct FClientUrlContext* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpProfileAccount", "UpdateAccountStatus");

	Params::OrionMcpProfileAccount_UpdateAccountStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Context != nullptr)
		*Context = std::move(Parms.Context);
}


// Function OrionGame.OrionMcpProfileAccount.UpdateSimpleAchievements
// (Net, NetReliable, NetRequest, Native, Event, Public, HasOutParams)
// Parameters:
// struct FSimpleAchievements              NewSimpleAchievements                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   RelayNotifictaion                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FClientUrlContext                Context                                                (Parm, OutParm, RepSkip, NativeAccessSpecifierPublic)

void UOrionMcpProfileAccount::UpdateSimpleAchievements(const struct FSimpleAchievements& NewSimpleAchievements, const int32 RelayNotifictaion, struct FClientUrlContext* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpProfileAccount", "UpdateSimpleAchievements");

	Params::OrionMcpProfileAccount_UpdateSimpleAchievements Parms{};

	Parms.NewSimpleAchievements = std::move(NewSimpleAchievements);
	Parms.RelayNotifictaion = RelayNotifictaion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Context != nullptr)
		*Context = std::move(Parms.Context);
}


// Function OrionGame.OrionMcpQuestItem.GetInternalData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UOrionMcpQuestItemDefinition*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionMcpQuestItemDefinition* UOrionMcpQuestItem::GetInternalData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpQuestItem", "GetInternalData");

	Params::OrionMcpQuestItem_GetInternalData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionMcpSkinItem.GetInternalData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UOrionSkinItemDefinition*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionSkinItemDefinition* UOrionMcpSkinItem::GetInternalData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpSkinItem", "GetInternalData");

	Params::OrionMcpSkinItem_GetInternalData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionSkinItemDefinition.BP_ApplySkinToComponent
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class USkinnedMeshComponent*            MeshComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionSkinVariationItemDefinition*InSkinVariation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionSkinItemDefinition::BP_ApplySkinToComponent(class USkinnedMeshComponent* MeshComponent, class UOrionSkinVariationItemDefinition* InSkinVariation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionSkinItemDefinition", "BP_ApplySkinToComponent");

	Params::OrionSkinItemDefinition_BP_ApplySkinToComponent Parms{};

	Parms.MeshComponent = MeshComponent;
	Parms.InSkinVariation = InSkinVariation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionSkinItemDefinition.GetAnimInstanceClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UAnimInstance>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UAnimInstance> UOrionSkinItemDefinition::GetAnimInstanceClass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionSkinItemDefinition", "GetAnimInstanceClass");

	Params::OrionSkinItemDefinition_GetAnimInstanceClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionSkinItemDefinition.GetPawnClassOverride
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class AOrionChar>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class AOrionChar> UOrionSkinItemDefinition::GetPawnClassOverride() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionSkinItemDefinition", "GetPawnClassOverride");

	Params::OrionSkinItemDefinition_GetPawnClassOverride Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionSkinItemDefinition.GetSkelMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMesh*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMesh* UOrionSkinItemDefinition::GetSkelMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionSkinItemDefinition", "GetSkelMesh");

	Params::OrionSkinItemDefinition_GetSkelMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionSkinVariationItemDefinition.GetAllValidVariantsOfSkin
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class UOrionSkinItemDefinition*         Skin                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UOrionSkinVariationItemDefinition*>AllVariantsOfSkin                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UOrionSkinVariationItemDefinition::GetAllValidVariantsOfSkin(const class UOrionSkinItemDefinition* Skin, TArray<class UOrionSkinVariationItemDefinition*>* AllVariantsOfSkin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionSkinVariationItemDefinition", "GetAllValidVariantsOfSkin");

	Params::OrionSkinVariationItemDefinition_GetAllValidVariantsOfSkin Parms{};

	Parms.Skin = Skin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AllVariantsOfSkin != nullptr)
		*AllVariantsOfSkin = std::move(Parms.AllVariantsOfSkin);
}


// Function OrionGame.OrionMcpTokenItem.GetInternalData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UOrionMcpTokenItemDefinition*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionMcpTokenItemDefinition* UOrionMcpTokenItem::GetInternalData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMcpTokenItem", "GetInternalData");

	Params::OrionMcpTokenItem_GetInternalData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionMenuManagerWidget2.OnMenuClose
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UWidget*                          NewOpenWidget                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionMenuManagerWidget2::OnMenuClose(class UWidget* NewOpenWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMenuManagerWidget2", "OnMenuClose");

	Params::OrionMenuManagerWidget2_OnMenuClose Parms{};

	Parms.NewOpenWidget = NewOpenWidget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionMenuManagerWidget2.OnMenuOpen
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UWidget*                          NewOpenWidget                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionMenuManagerWidget2::OnMenuOpen(class UWidget* NewOpenWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMenuManagerWidget2", "OnMenuOpen");

	Params::OrionMenuManagerWidget2_OnMenuOpen Parms{};

	Parms.NewOpenWidget = NewOpenWidget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionMenuManagerWidget2.OnMenuOpenStateChange
// (Final, Native, Protected)
// Parameters:
// EOrionMenuSlotTypes                     MenuSlot                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewIsOpenState                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionMenuManagerWidget2::OnMenuOpenStateChange(EOrionMenuSlotTypes MenuSlot, bool bNewIsOpenState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMenuManagerWidget2", "OnMenuOpenStateChange");

	Params::OrionMenuManagerWidget2_OnMenuOpenStateChange Parms{};

	Parms.MenuSlot = MenuSlot;
	Parms.bNewIsOpenState = bNewIsOpenState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionMenuManagerWidget2.OnUpdateCursorState
// (Final, Native, Protected)

void UOrionMenuManagerWidget2::OnUpdateCursorState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMenuManagerWidget2", "OnUpdateCursorState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionMenuManagerWidget2.FindWidgetFromSlot
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionMenuSlotTypes                     InSlotType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UOrionMenuManagerWidget2::FindWidgetFromSlot(EOrionMenuSlotTypes InSlotType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMenuManagerWidget2", "FindWidgetFromSlot");

	Params::OrionMenuManagerWidget2_FindWidgetFromSlot Parms{};

	Parms.InSlotType = InSlotType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionMenuManagerWidget2.GetDoesMenuExist
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionMenuSlotTypes                     InSlotType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionMenuManagerWidget2::GetDoesMenuExist(EOrionMenuSlotTypes InSlotType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMenuManagerWidget2", "GetDoesMenuExist");

	Params::OrionMenuManagerWidget2_GetDoesMenuExist Parms{};

	Parms.InSlotType = InSlotType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionMenuManagerWidget2.GetIsMenuVisible
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionMenuSlotTypes                     InSlotType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionMenuManagerWidget2::GetIsMenuVisible(EOrionMenuSlotTypes InSlotType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMenuManagerWidget2", "GetIsMenuVisible");

	Params::OrionMenuManagerWidget2_GetIsMenuVisible Parms{};

	Parms.InSlotType = InSlotType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionMenuManagerWidget2.GetTopCursorState
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionDesiredAnalogCursorState          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOrionDesiredAnalogCursorState UOrionMenuManagerWidget2::GetTopCursorState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMenuManagerWidget2", "GetTopCursorState");

	Params::OrionMenuManagerWidget2_GetTopCursorState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionMenuManagerWidget2.GetTopOpenWidget
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UOrionMenuManagerWidget2::GetTopOpenWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMenuManagerWidget2", "GetTopOpenWidget");

	Params::OrionMenuManagerWidget2_GetTopOpenWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionMoveSet.OnRep_AvatarScale
// (Final, Native, Public)

void UOrionMoveSet::OnRep_AvatarScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMoveSet", "OnRep_AvatarScale");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionMoveSet.OnRep_CombatSlow
// (Final, Native, Public)

void UOrionMoveSet::OnRep_CombatSlow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMoveSet", "OnRep_CombatSlow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionMoveSet.OnRep_MaxMoveSpeed
// (Final, Native, Public)

void UOrionMoveSet::OnRep_MaxMoveSpeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMoveSet", "OnRep_MaxMoveSpeed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionMoveSet.OnRep_MinionNudgeResistanceFactorEnemy
// (Final, Native, Public)

void UOrionMoveSet::OnRep_MinionNudgeResistanceFactorEnemy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMoveSet", "OnRep_MinionNudgeResistanceFactorEnemy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionMoveSet.OnRep_MinionNudgeResistanceFactorFriendly
// (Final, Native, Public)

void UOrionMoveSet::OnRep_MinionNudgeResistanceFactorFriendly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMoveSet", "OnRep_MinionNudgeResistanceFactorFriendly");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionMurielAnimInstance.AnimNotify_Jump_Land_End
// (Final, Native, Public)
// Parameters:
// class UAnimNotify*                      AnimNotify                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionMurielAnimInstance::AnimNotify_Jump_Land_End(const class UAnimNotify* AnimNotify)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionMurielAnimInstance", "AnimNotify_Jump_Land_End");

	Params::OrionMurielAnimInstance_AnimNotify_Jump_Land_End Parms{};

	Parms.AnimNotify = AnimNotify;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionNavTowerComponent.OnNavDataGenerationFinished
// (Final, Native, Protected)
// Parameters:
// class ANavigationData*                  NavData                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionNavTowerComponent::OnNavDataGenerationFinished(class ANavigationData* NavData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionNavTowerComponent", "OnNavDataGenerationFinished");

	Params::OrionNavTowerComponent_OnNavDataGenerationFinished Parms{};

	Parms.NavData = NavData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionNotificationLibrary.AddNotification
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOrionNotification               InNotification                                         (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionNotificationLibrary::AddNotification(struct FOrionNotification& InNotification, class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionNotificationLibrary", "AddNotification");

	Params::OrionNotificationLibrary_AddNotification Parms{};

	Parms.InNotification = std::move(InNotification);
	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	InNotification = std::move(Parms.InNotification);
}


// Function OrionGame.OrionNotificationLibrary.BindToNotificationResponse
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOrionNotification               InNotification                                         (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(const struct FOrionNotification& Notification, ENotificationButton Response)>InCallback                                             (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UOrionNotificationLibrary::BindToNotificationResponse(struct FOrionNotification& InNotification, TDelegate<void(const struct FOrionNotification& Notification, ENotificationButton Response)> InCallback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionNotificationLibrary", "BindToNotificationResponse");

	Params::OrionNotificationLibrary_BindToNotificationResponse Parms{};

	Parms.InNotification = std::move(InNotification);
	Parms.InCallback = InCallback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	InNotification = std::move(Parms.InNotification);
}


// Function OrionGame.OrionNotificationLibrary.ClearAllErrorNotifications
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionNotificationLibrary::ClearAllErrorNotifications(class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionNotificationLibrary", "ClearAllErrorNotifications");

	Params::OrionNotificationLibrary_ClearAllErrorNotifications Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionNotificationLibrary.Equal
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FOrionNotification               LHS                                                    (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FOrionNotification               RHS                                                    (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionNotificationLibrary::Equal(struct FOrionNotification& LHS, struct FOrionNotification& RHS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionNotificationLibrary", "Equal");

	Params::OrionNotificationLibrary_Equal Parms{};

	Parms.LHS = std::move(LHS);
	Parms.RHS = std::move(RHS);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	LHS = std::move(Parms.LHS);
	RHS = std::move(Parms.RHS);

	return Parms.ReturnValue;
}


// Function OrionGame.OrionNotificationLibrary.GetNotificationDisplayTimeText
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FOrionNotification               InNotification                                         (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UOrionNotificationLibrary::GetNotificationDisplayTimeText(struct FOrionNotification& InNotification)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionNotificationLibrary", "GetNotificationDisplayTimeText");

	Params::OrionNotificationLibrary_GetNotificationDisplayTimeText Parms{};

	Parms.InNotification = std::move(InNotification);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	InNotification = std::move(Parms.InNotification);

	return Parms.ReturnValue;
}


// Function OrionGame.OrionNotificationLibrary.IsNotificationValid
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FOrionNotification               InNotification                                         (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionNotificationLibrary::IsNotificationValid(struct FOrionNotification& InNotification)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionNotificationLibrary", "IsNotificationValid");

	Params::OrionNotificationLibrary_IsNotificationValid Parms{};

	Parms.InNotification = std::move(InNotification);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	InNotification = std::move(Parms.InNotification);

	return Parms.ReturnValue;
}


// Function OrionGame.OrionNotificationLibrary.KillNotification
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Context                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Identifier                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionNotificationLibrary::KillNotification(class UObject* Context, class FName Identifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionNotificationLibrary", "KillNotification");

	Params::OrionNotificationLibrary_KillNotification Parms{};

	Parms.Context = Context;
	Parms.Identifier = Identifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionNotificationLibrary.OnNotificationActionTaken
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOrionNotification               InNotification                                         (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// ENotificationButton                     InSelection                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionNotificationLibrary::OnNotificationActionTaken(struct FOrionNotification& InNotification, ENotificationButton InSelection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionNotificationLibrary", "OnNotificationActionTaken");

	Params::OrionNotificationLibrary_OnNotificationActionTaken Parms{};

	Parms.InNotification = std::move(InNotification);
	Parms.InSelection = InSelection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	InNotification = std::move(Parms.InNotification);
}


// Function OrionGame.OrionNotificationLibrary.RemoveNotification
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOrionNotification               InNotification                                         (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionNotificationLibrary::RemoveNotification(struct FOrionNotification& InNotification, class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionNotificationLibrary", "RemoveNotification");

	Params::OrionNotificationLibrary_RemoveNotification Parms{};

	Parms.InNotification = std::move(InNotification);
	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	InNotification = std::move(Parms.InNotification);

	return Parms.ReturnValue;
}


// Function OrionGame.OrionNotificationLibrary.SetNotificationDisplayTime
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FOrionNotification               InNotification                                         (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FTimespan                        Time                                                   (Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionNotificationLibrary::SetNotificationDisplayTime(struct FOrionNotification& InNotification, struct FTimespan& Time, class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionNotificationLibrary", "SetNotificationDisplayTime");

	Params::OrionNotificationLibrary_SetNotificationDisplayTime Parms{};

	Parms.InNotification = std::move(InNotification);
	Parms.Time = std::move(Time);
	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	InNotification = std::move(Parms.InNotification);
	Time = std::move(Parms.Time);
}


// Function OrionGame.OrionNotificationLibrary.ShowNotification
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Context                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             TitleText                                              (Parm, NativeAccessSpecifierPublic)
// class FText                             BodyText                                               (Parm, NativeAccessSpecifierPublic)
// float                                   DisplayTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FOrionNotification               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FOrionNotification UOrionNotificationLibrary::ShowNotification(class UObject* Context, const class FText& TitleText, const class FText& BodyText, float DisplayTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionNotificationLibrary", "ShowNotification");

	Params::OrionNotificationLibrary_ShowNotification Parms{};

	Parms.Context = Context;
	Parms.TitleText = std::move(TitleText);
	Parms.BodyText = std::move(BodyText);
	Parms.DisplayTime = DisplayTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionNotificationInterface.GetNotification
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FOrionNotification               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FOrionNotification IOrionNotificationInterface::GetNotification() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionNotificationInterface", "GetNotification");

	Params::OrionNotificationInterface_GetNotification Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPartyBeaconClient.ClientAllTeamsReady
// (Net, NetReliable, Native, Event, Public, NetClient)

void AOrionPartyBeaconClient::ClientAllTeamsReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPartyBeaconClient", "ClientAllTeamsReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPartyBeaconClient.ClientSendAcceptMatchPlayersUpdate
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// TArray<struct FOrionAcceptMatchData>    AcceptMatchPlayers                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AOrionPartyBeaconClient::ClientSendAcceptMatchPlayersUpdate(const TArray<struct FOrionAcceptMatchData>& AcceptMatchPlayers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPartyBeaconClient", "ClientSendAcceptMatchPlayersUpdate");

	Params::OrionPartyBeaconClient_ClientSendAcceptMatchPlayersUpdate Parms{};

	Parms.AcceptMatchPlayers = std::move(AcceptMatchPlayers);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPartyBeaconClient.ClientSendLobbyStateChanged
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// EOrionBeaconLobbyState                  NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPartyBeaconClient::ClientSendLobbyStateChanged(EOrionBeaconLobbyState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPartyBeaconClient", "ClientSendLobbyStateChanged");

	Params::OrionPartyBeaconClient_ClientSendLobbyStateChanged Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPartyBeaconClient.ClientSetTeamInfoResponse
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// EPartySetTeamInfoResult                 Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPartyBeaconClient::ClientSetTeamInfoResponse(EPartySetTeamInfoResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPartyBeaconClient", "ClientSetTeamInfoResponse");

	Params::OrionPartyBeaconClient_ClientSetTeamInfoResponse Parms{};

	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPartyBeaconClient.ServerConfigureMatchReservationRequest
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// class FString                           InSessionId                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FOrionMatchConfig                MatchConfig                                            (Parm, NativeAccessSpecifierPublic)
// struct FPartyReservation                PartyReservation                                       (Parm, NativeAccessSpecifierPublic)

void AOrionPartyBeaconClient::ServerConfigureMatchReservationRequest(const class FString& InSessionId, const struct FOrionMatchConfig& MatchConfig, const struct FPartyReservation& PartyReservation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPartyBeaconClient", "ServerConfigureMatchReservationRequest");

	Params::OrionPartyBeaconClient_ServerConfigureMatchReservationRequest Parms{};

	Parms.InSessionId = std::move(InSessionId);
	Parms.MatchConfig = std::move(MatchConfig);
	Parms.PartyReservation = std::move(PartyReservation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPartyBeaconClient.ServerSetAcceptedMatch
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FUniqueNetIdRepl                 PartyLeader                                            (ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUniqueNetIdRepl                 MemberId                                               (ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionAcceptMatchState                  AcceptState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPartyBeaconClient::ServerSetAcceptedMatch(const struct FUniqueNetIdRepl& PartyLeader, const struct FUniqueNetIdRepl& MemberId, EOrionAcceptMatchState AcceptState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPartyBeaconClient", "ServerSetAcceptedMatch");

	Params::OrionPartyBeaconClient_ServerSetAcceptedMatch Parms{};

	Parms.PartyLeader = std::move(PartyLeader);
	Parms.MemberId = std::move(MemberId);
	Parms.AcceptState = AcceptState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPartyBeaconClient.ServerSetTeamInfoRequest
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FUniqueNetIdRepl                 PartyLeader                                            (ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayerTeam                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FOrionTBTeamInfo                 TeamInfo                                               (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void AOrionPartyBeaconClient::ServerSetTeamInfoRequest(const struct FUniqueNetIdRepl& PartyLeader, bool bPlayerTeam, const struct FOrionTBTeamInfo& TeamInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPartyBeaconClient", "ServerSetTeamInfoRequest");

	Params::OrionPartyBeaconClient_ServerSetTeamInfoRequest Parms{};

	Parms.PartyLeader = std::move(PartyLeader);
	Parms.bPlayerTeam = bPlayerTeam;
	Parms.TeamInfo = std::move(TeamInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction OrionGame.OrionPartyMemberState.OnMemberUpdated__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UOrionPartyMemberState::OnMemberUpdated__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPartyMemberState", "OnMemberUpdated__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionPartyMemberState.GetAccountLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOrionPartyMemberState::GetAccountLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPartyMemberState", "GetAccountLevel");

	Params::OrionPartyMemberState_GetAccountLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPartyMemberState.GetIsConsole
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOrionPartyMemberState::GetIsConsole() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPartyMemberState", "GetIsConsole");

	Params::OrionPartyMemberState_GetIsConsole Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPartyMemberState.GetLevelProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOrionPartyMemberState::GetLevelProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPartyMemberState", "GetLevelProgress");

	Params::OrionPartyMemberState_GetLevelProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPartyMemberState.IsDirty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionPartyMemberStateFlags             Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionPartyMemberState::IsDirty(EOrionPartyMemberStateFlags Flag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPartyMemberState", "IsDirty");

	Params::OrionPartyMemberState_IsDirty Parms{};

	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPersistentPartyMember.SetHero
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UOrionHeroData*                   InHero                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionPersistentPartyMember::SetHero(class UOrionHeroData* InHero)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPersistentPartyMember", "SetHero");

	Params::OrionPersistentPartyMember_SetHero Parms{};

	Parms.InHero = InHero;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPersistentPartyMember.SetLoaded
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InLoaded                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionPersistentPartyMember::SetLoaded(bool InLoaded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPersistentPartyMember", "SetLoaded");

	Params::OrionPersistentPartyMember_SetLoaded Parms{};

	Parms.InLoaded = InLoaded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPersistentPartyMember.SetReady
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInReady                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionPersistentPartyMember::SetReady(bool bInReady)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPersistentPartyMember", "SetReady");

	Params::OrionPersistentPartyMember_SetReady Parms{};

	Parms.bInReady = bInReady;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPersistentPartyMember.GetCurrentBanReason
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionBanReason                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOrionBanReason UOrionPersistentPartyMember::GetCurrentBanReason() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPersistentPartyMember", "GetCurrentBanReason");

	Params::OrionPersistentPartyMember_GetCurrentBanReason Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPersistentPartyMember.GetHero
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UOrionPersistentPartyMember::GetHero() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPersistentPartyMember", "GetHero");

	Params::OrionPersistentPartyMember_GetHero Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPersistentPartyMember.GetLocation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionPartyMemberLocation               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOrionPartyMemberLocation UOrionPersistentPartyMember::GetLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPersistentPartyMember", "GetLocation");

	Params::OrionPersistentPartyMember_GetLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPersistentPartyMember.HasLockedInHero
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UOrionHeroData*                   HeroData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionPersistentPartyMember::HasLockedInHero(class UOrionHeroData* HeroData) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPersistentPartyMember", "HasLockedInHero");

	Params::OrionPersistentPartyMember_HasLockedInHero Parms{};

	Parms.HeroData = HeroData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPersistentPartyMember.IsDirty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionPersistentPartyMemberStateFlags   Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionPersistentPartyMember::IsDirty(EOrionPersistentPartyMemberStateFlags Flag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPersistentPartyMember", "IsDirty");

	Params::OrionPersistentPartyMember_IsDirty Parms{};

	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPersistentPartyMember.IsLoaded
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionPersistentPartyMember::IsLoaded() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPersistentPartyMember", "IsLoaded");

	Params::OrionPersistentPartyMember_IsLoaded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPersistentPartyMember.IsReady
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionPersistentPartyMember::IsReady() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPersistentPartyMember", "IsReady");

	Params::OrionPersistentPartyMember_IsReady Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPickupManager.CheatRemoveAllPickupsFromTheWorld
// (Net, NetReliable, Native, Event, NetMulticast, Public, NetClient)

void AOrionPickupManager::CheatRemoveAllPickupsFromTheWorld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPickupManager", "CheatRemoveAllPickupsFromTheWorld");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPickupManager.DeactivatePickupsOfType
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// TSubclassOf<class AOrionPickup>         PickupClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPickupManager::DeactivatePickupsOfType(TSubclassOf<class AOrionPickup> PickupClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPickupManager", "DeactivatePickupsOfType");

	Params::OrionPickupManager_DeactivatePickupsOfType Parms{};

	Parms.PickupClass = PickupClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPickupManager.OnRep_SpawnedPickups
// (Native, Protected)

void AOrionPickupManager::OnRep_SpawnedPickups()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPickupManager", "OnRep_SpawnedPickups");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPickupManager.ReliableHandlePickupCollected
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, NetClient)
// Parameters:
// uint64                                  InPickupID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Collector                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPickupManager::ReliableHandlePickupCollected(uint64 InPickupID, class AActor* Collector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPickupManager", "ReliableHandlePickupCollected");

	Params::OrionPickupManager_ReliableHandlePickupCollected Parms{};

	Parms.InPickupID = InPickupID;
	Parms.Collector = Collector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPickupManager.ReliableRelaunchPickup
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, NetClient)
// Parameters:
// struct FPickupLaunchInfo                LaunchInfo                                             (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AOrionPickupManager::ReliableRelaunchPickup(const struct FPickupLaunchInfo& LaunchInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPickupManager", "ReliableRelaunchPickup");

	Params::OrionPickupManager_ReliableRelaunchPickup Parms{};

	Parms.LaunchInfo = std::move(LaunchInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPickupManager.ReliableSetExpireTimerTo
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, NetClient)
// Parameters:
// uint64                                  InPickupID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewExpireTime                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPickupManager::ReliableSetExpireTimerTo(uint64 InPickupID, float NewExpireTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPickupManager", "ReliableSetExpireTimerTo");

	Params::OrionPickupManager_ReliableSetExpireTimerTo Parms{};

	Parms.InPickupID = InPickupID;
	Parms.NewExpireTime = NewExpireTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPickupManager.ReliableSetPickupLocation
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, HasDefaults, NetClient)
// Parameters:
// uint64                                  InPickupID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewLocation                                            (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPickupManager::ReliableSetPickupLocation(uint64 InPickupID, const struct FVector& NewLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPickupManager", "ReliableSetPickupLocation");

	Params::OrionPickupManager_ReliableSetPickupLocation Parms{};

	Parms.InPickupID = InPickupID;
	Parms.NewLocation = std::move(NewLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPickupManager.ReliableSpawnPickup
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, NetClient)
// Parameters:
// struct FPickupSpawnInfo                 CoinSpawnInfo                                          (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void AOrionPickupManager::ReliableSpawnPickup(const struct FPickupSpawnInfo& CoinSpawnInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPickupManager", "ReliableSpawnPickup");

	Params::OrionPickupManager_ReliableSpawnPickup Parms{};

	Parms.CoinSpawnInfo = std::move(CoinSpawnInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPickupManager.UnrealiableSpawnPickup
// (Final, Net, Native, Event, NetMulticast, Private, NetClient)
// Parameters:
// struct FPickupSpawnInfo                 CoinSpawnInfo                                          (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void AOrionPickupManager::UnrealiableSpawnPickup(const struct FPickupSpawnInfo& CoinSpawnInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPickupManager", "UnrealiableSpawnPickup");

	Params::OrionPickupManager_UnrealiableSpawnPickup Parms{};

	Parms.CoinSpawnInfo = std::move(CoinSpawnInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPickupManager.UnreliableHandlePickupCollected
// (Final, Net, Native, Event, NetMulticast, Private, NetClient)
// Parameters:
// uint64                                  InPickupID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Collector                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPickupManager::UnreliableHandlePickupCollected(uint64 InPickupID, class AActor* Collector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPickupManager", "UnreliableHandlePickupCollected");

	Params::OrionPickupManager_UnreliableHandlePickupCollected Parms{};

	Parms.InPickupID = InPickupID;
	Parms.Collector = Collector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Sandbox.AskForHero
// (Net, NetReliable, Native, Event, Public, NetClient)

void AOrionPlayerController_Sandbox::AskForHero()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Sandbox", "AskForHero");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Sandbox.SetHero
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// class UOrionHeroData*                   SelectedHeroData                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Sandbox::SetHero(class UOrionHeroData* SelectedHeroData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Sandbox", "SetHero");

	Params::OrionPlayerController_Sandbox_SetHero Parms{};

	Parms.SelectedHeroData = SelectedHeroData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Tutorial.OnRep_TutorialPathArray
// (Final, Native, Protected)

void AOrionPlayerController_Tutorial::OnRep_TutorialPathArray()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Tutorial", "OnRep_TutorialPathArray");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Tutorial.RecordTutorialAnalytics
// (Final, Native, Public)
// Parameters:
// struct FGameplayStatTag                 Stat                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Tutorial::RecordTutorialAnalytics(const struct FGameplayStatTag& Stat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Tutorial", "RecordTutorialAnalytics");

	Params::OrionPlayerController_Tutorial_RecordTutorialAnalytics Parms{};

	Parms.Stat = std::move(Stat);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Tutorial.ServerClearPath
// (RequiredAPI, Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)

void AOrionPlayerController_Tutorial::ServerClearPath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Tutorial", "ServerClearPath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Tutorial.ServerFindPathToActor
// (RequiredAPI, Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class AActor*                           InTargetActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Tutorial::ServerFindPathToActor(class AActor* InTargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Tutorial", "ServerFindPathToActor");

	Params::OrionPlayerController_Tutorial_ServerFindPathToActor Parms{};

	Parms.InTargetActor = InTargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Tutorial.ServerForceStartGame
// (RequiredAPI, Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)

void AOrionPlayerController_Tutorial::ServerForceStartGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Tutorial", "ServerForceStartGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Tutorial.ServerForceStartTutorialSpawner
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class AOrionCharAISpawner*              Spawner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionCharAISpawnerType                 InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Tutorial::ServerForceStartTutorialSpawner(class AOrionCharAISpawner* Spawner, EOrionCharAISpawnerType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Tutorial", "ServerForceStartTutorialSpawner");

	Params::OrionPlayerController_Tutorial_ServerForceStartTutorialSpawner Parms{};

	Parms.Spawner = Spawner;
	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Tutorial.ServerForceStopTutorialSequencer
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class ALevelSequenceActor*              SequenceActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Tutorial::ServerForceStopTutorialSequencer(class ALevelSequenceActor* SequenceActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Tutorial", "ServerForceStopTutorialSequencer");

	Params::OrionPlayerController_Tutorial_ServerForceStopTutorialSequencer Parms{};

	Parms.SequenceActor = SequenceActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Tutorial.ServerOnMatchReady
// (RequiredAPI, Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)

void AOrionPlayerController_Tutorial::ServerOnMatchReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Tutorial", "ServerOnMatchReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Tutorial.ServerRefreshPathToActor
// (RequiredAPI, Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)

void AOrionPlayerController_Tutorial::ServerRefreshPathToActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Tutorial", "ServerRefreshPathToActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerController_Tutorial.UpdateTutorialStat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayStatTag                 Stat                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerController_Tutorial::UpdateTutorialStat(const struct FGameplayStatTag& Stat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerController_Tutorial", "UpdateTutorialStat");

	Params::OrionPlayerController_Tutorial_UpdateTutorialStat Parms{};

	Parms.Stat = std::move(Stat);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerStart.DisableStartingSpot
// (Final, Native, Public, BlueprintCallable)

void AOrionPlayerStart::DisableStartingSpot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerStart", "DisableStartingSpot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerStart.EnableStartingSpot
// (Final, Native, Public, BlueprintCallable)

void AOrionPlayerStart::EnableStartingSpot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerStart", "EnableStartingSpot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerStart.GetPlayerStartType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionPlayerStartType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOrionPlayerStartType AOrionPlayerStart::GetPlayerStartType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerStart", "GetPlayerStartType");

	Params::OrionPlayerStart_GetPlayerStartType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlayerStart.GetTeamNum
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// EOrionTeam                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOrionTeam AOrionPlayerStart::GetTeamNum() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerStart", "GetTeamNum");

	Params::OrionPlayerStart_GetTeamNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlayerStart.IsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionPlayerStart::IsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerStart", "IsEnabled");

	Params::OrionPlayerStart_IsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlayerState_DraftLobby.OnRep_AbortPenaltyReason
// (Final, Native, Private)

void AOrionPlayerState_DraftLobby::OnRep_AbortPenaltyReason()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_DraftLobby", "OnRep_AbortPenaltyReason");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerState_DraftLobby.OnRep_IsSoleHumanInDraft
// (Final, Native, Private)

void AOrionPlayerState_DraftLobby::OnRep_IsSoleHumanInDraft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_DraftLobby", "OnRep_IsSoleHumanInDraft");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerState_DraftLobby.OnRep_LockedInHeroInfo
// (Final, Native, Private)

void AOrionPlayerState_DraftLobby::OnRep_LockedInHeroInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_DraftLobby", "OnRep_LockedInHeroInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerState_DraftLobby.OnRep_PickStatus
// (Final, Native, Private)

void AOrionPlayerState_DraftLobby::OnRep_PickStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_DraftLobby", "OnRep_PickStatus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerState_DraftLobby.OnRep_TeamSpecificInfo
// (Final, Native, Private)
// Parameters:
// struct FTeamSpecificDraftPlayerInfo     OldInfo                                                (Parm, NativeAccessSpecifierPublic)

void AOrionPlayerState_DraftLobby::OnRep_TeamSpecificInfo(const struct FTeamSpecificDraftPlayerInfo& OldInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_DraftLobby", "OnRep_TeamSpecificInfo");

	Params::OrionPlayerState_DraftLobby_OnRep_TeamSpecificInfo Parms{};

	Parms.OldInfo = std::move(OldInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerState_Tutorial.ForceHeroToLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerState_Tutorial::ForceHeroToLevel(int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Tutorial", "ForceHeroToLevel");

	Params::OrionPlayerState_Tutorial_ForceHeroToLevel Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlayerState_Tutorial.ServerUpdateStatFromTutorial
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// TSubclassOf<class UOrionTutorial>       TutorialClass                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionPlayerState_Tutorial::ServerUpdateStatFromTutorial(TSubclassOf<class UOrionTutorial> TutorialClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPlayerState_Tutorial", "ServerUpdateStatFromTutorial");

	Params::OrionPlayerState_Tutorial_ServerUpdateStatFromTutorial Parms{};

	Parms.TutorialClass = TutorialClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPlaylistManager.AllowsRejoin
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PlaylistId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionPlaylistManager::AllowsRejoin(int32 PlaylistId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionPlaylistManager", "AllowsRejoin");

	Params::OrionPlaylistManager_AllowsRejoin Parms{};

	Parms.PlaylistId = PlaylistId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlaylistManager.AllowsSurrender
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PlaylistId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionPlaylistManager::AllowsSurrender(int32 PlaylistId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionPlaylistManager", "AllowsSurrender");

	Params::OrionPlaylistManager_AllowsSurrender Parms{};

	Parms.PlaylistId = PlaylistId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlaylistManager.AwardsXP
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PlaylistId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionPlaylistManager::AwardsXP(int32 PlaylistId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionPlaylistManager", "AwardsXP");

	Params::OrionPlaylistManager_AwardsXP Parms{};

	Parms.PlaylistId = PlaylistId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlaylistManager.DoesPlaylistAllowMirrorMatches
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PlaylistId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionPlaylistManager::DoesPlaylistAllowMirrorMatches(int32 PlaylistId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionPlaylistManager", "DoesPlaylistAllowMirrorMatches");

	Params::OrionPlaylistManager_DoesPlaylistAllowMirrorMatches Parms{};

	Parms.PlaylistId = PlaylistId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlaylistManager.Exists
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PlaylistId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionPlaylistManager::Exists(int32 PlaylistId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionPlaylistManager", "Exists");

	Params::OrionPlaylistManager_Exists Parms{};

	Parms.PlaylistId = PlaylistId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlaylistManager.FindPlaylist
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PlaylistId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FOrionPlaylistInfo               OutPlaylist                                            (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionPlaylistManager::FindPlaylist(int32 PlaylistId, struct FOrionPlaylistInfo* OutPlaylist)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionPlaylistManager", "FindPlaylist");

	Params::OrionPlaylistManager_FindPlaylist Parms{};

	Parms.PlaylistId = PlaylistId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPlaylist != nullptr)
		*OutPlaylist = std::move(Parms.OutPlaylist);

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlaylistManager.GetArcadeURL
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PlaylistId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UOrionPlaylistManager::GetArcadeURL(int32 PlaylistId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionPlaylistManager", "GetArcadeURL");

	Params::OrionPlaylistManager_GetArcadeURL Parms{};

	Parms.PlaylistId = PlaylistId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlaylistManager.GetGameMapURL
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PlaylistId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutMapURL                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionPlaylistManager::GetGameMapURL(int32 PlaylistId, class FString* OutMapURL)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionPlaylistManager", "GetGameMapURL");

	Params::OrionPlaylistManager_GetGameMapURL Parms{};

	Parms.PlaylistId = PlaylistId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMapURL != nullptr)
		*OutMapURL = std::move(Parms.OutMapURL);

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlaylistManager.GetLoadingScreen
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PlaylistId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UOrionPlaylistManager::GetLoadingScreen(int32 PlaylistId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionPlaylistManager", "GetLoadingScreen");

	Params::OrionPlaylistManager_GetLoadingScreen Parms{};

	Parms.PlaylistId = PlaylistId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlaylistManager.GetLobbyMapURL
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PlaylistId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutMapURL                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionPlaylistManager::GetLobbyMapURL(int32 PlaylistId, class FString* OutMapURL)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionPlaylistManager", "GetLobbyMapURL");

	Params::OrionPlaylistManager_GetLobbyMapURL Parms{};

	Parms.PlaylistId = PlaylistId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMapURL != nullptr)
		*OutMapURL = std::move(Parms.OutMapURL);

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlaylistManager.GetPlaylistName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PlaylistId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UOrionPlaylistManager::GetPlaylistName(int32 PlaylistId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionPlaylistManager", "GetPlaylistName");

	Params::OrionPlaylistManager_GetPlaylistName Parms{};

	Parms.PlaylistId = PlaylistId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlaylistManager.GetRatingType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PlaylistId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UOrionPlaylistManager::GetRatingType(int32 PlaylistId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionPlaylistManager", "GetRatingType");

	Params::OrionPlaylistManager_GetRatingType Parms{};

	Parms.PlaylistId = PlaylistId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlaylistManager.GetRawGameMapPath
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PlaylistId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutMapPath                                             (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionPlaylistManager::GetRawGameMapPath(int32 PlaylistId, class FString* OutMapPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionPlaylistManager", "GetRawGameMapPath");

	Params::OrionPlaylistManager_GetRawGameMapPath Parms{};

	Parms.PlaylistId = PlaylistId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMapPath != nullptr)
		*OutMapPath = std::move(Parms.OutMapPath);

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlaylistManager.GetReplayFlag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PlaylistId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UOrionPlaylistManager::GetReplayFlag(int32 PlaylistId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionPlaylistManager", "GetReplayFlag");

	Params::OrionPlaylistManager_GetReplayFlag Parms{};

	Parms.PlaylistId = PlaylistId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlaylistManager.GetTeamInfo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PlaylistId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutMaxPlayers                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutMaxTeams                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutTeamSize                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionPlaylistManager::GetTeamInfo(int32 PlaylistId, int32* OutMaxPlayers, int32* OutMaxTeams, int32* OutTeamSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionPlaylistManager", "GetTeamInfo");

	Params::OrionPlaylistManager_GetTeamInfo Parms{};

	Parms.PlaylistId = PlaylistId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMaxPlayers != nullptr)
		*OutMaxPlayers = Parms.OutMaxPlayers;

	if (OutMaxTeams != nullptr)
		*OutMaxTeams = Parms.OutMaxTeams;

	if (OutTeamSize != nullptr)
		*OutTeamSize = Parms.OutTeamSize;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlaylistManager.GetTeamSize
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PlaylistId                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOrionPlaylistManager::GetTeamSize(const int32 PlaylistId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionPlaylistManager", "GetTeamSize");

	Params::OrionPlaylistManager_GetTeamSize Parms{};

	Parms.PlaylistId = PlaylistId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlaylistManager.HasBots
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PlaylistId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionPlaylistManager::HasBots(int32 PlaylistId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionPlaylistManager", "HasBots");

	Params::OrionPlaylistManager_HasBots Parms{};

	Parms.PlaylistId = PlaylistId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlaylistManager.HasEnemyBots
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PlaylistId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionPlaylistManager::HasEnemyBots(int32 PlaylistId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionPlaylistManager", "HasEnemyBots");

	Params::OrionPlaylistManager_HasEnemyBots Parms{};

	Parms.PlaylistId = PlaylistId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlaylistManager.HasFriendlyBots
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PlaylistId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionPlaylistManager::HasFriendlyBots(int32 PlaylistId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionPlaylistManager", "HasFriendlyBots");

	Params::OrionPlaylistManager_HasFriendlyBots Parms{};

	Parms.PlaylistId = PlaylistId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlaylistManager.IsCoop
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PlaylistId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionPlaylistManager::IsCoop(int32 PlaylistId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionPlaylistManager", "IsCoop");

	Params::OrionPlaylistManager_IsCoop Parms{};

	Parms.PlaylistId = PlaylistId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlaylistManager.IsPVP
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PlaylistId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionPlaylistManager::IsPVP(int32 PlaylistId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionPlaylistManager", "IsPVP");

	Params::OrionPlaylistManager_IsPVP Parms{};

	Parms.PlaylistId = PlaylistId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlaylistManager.IsRanked
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PlaylistId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionPlaylistManager::IsRanked(int32 PlaylistId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionPlaylistManager", "IsRanked");

	Params::OrionPlaylistManager_IsRanked Parms{};

	Parms.PlaylistId = PlaylistId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlaylistManager.IsSolo
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PlaylistId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionPlaylistManager::IsSolo(int32 PlaylistId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionPlaylistManager", "IsSolo");

	Params::OrionPlaylistManager_IsSolo Parms{};

	Parms.PlaylistId = PlaylistId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlaylistManager.IsSoloVsAI
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PlaylistId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionPlaylistManager::IsSoloVsAI(int32 PlaylistId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionPlaylistManager", "IsSoloVsAI");

	Params::OrionPlaylistManager_IsSoloVsAI Parms{};

	Parms.PlaylistId = PlaylistId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlaylistManager.IsTutorial
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PlaylistId                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionPlaylistManager::IsTutorial(const int32 PlaylistId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionPlaylistManager", "IsTutorial");

	Params::OrionPlaylistManager_IsTutorial Parms{};

	Parms.PlaylistId = PlaylistId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlaylistManager.PlaylistHasLobby
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PlaylistId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionPlaylistManager::PlaylistHasLobby(int32 PlaylistId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionPlaylistManager", "PlaylistHasLobby");

	Params::OrionPlaylistManager_PlaylistHasLobby Parms{};

	Parms.PlaylistId = PlaylistId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlaylistManager.ShouldShowPostMatchSummary
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PlaylistId                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionPlaylistManager::ShouldShowPostMatchSummary(const int32 PlaylistId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionPlaylistManager", "ShouldShowPostMatchSummary");

	Params::OrionPlaylistManager_ShouldShowPostMatchSummary Parms{};

	Parms.PlaylistId = PlaylistId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlaylistManager.SupportsCustomMMKey
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PlaylistId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionPlaylistManager::SupportsCustomMMKey(int32 PlaylistId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionPlaylistManager", "SupportsCustomMMKey");

	Params::OrionPlaylistManager_SupportsCustomMMKey Parms{};

	Parms.PlaylistId = PlaylistId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPlaylistManager.SupportsDraftInReplays
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PlaylistId                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionPlaylistManager::SupportsDraftInReplays(const int32 PlaylistId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionPlaylistManager", "SupportsDraftInReplays");

	Params::OrionPlaylistManager_SupportsDraftInReplays Parms{};

	Parms.PlaylistId = PlaylistId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionPriceAnimInstance.AnimNotify_IK_HndShotGun_Off
// (Final, Native, Public)
// Parameters:
// class UAnimNotify*                      AnimNotify                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionPriceAnimInstance::AnimNotify_IK_HndShotGun_Off(const class UAnimNotify* AnimNotify)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPriceAnimInstance", "AnimNotify_IK_HndShotGun_Off");

	Params::OrionPriceAnimInstance_AnimNotify_IK_HndShotGun_Off Parms{};

	Parms.AnimNotify = AnimNotify;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionPriceAnimInstance.AnimNotify_IK_HndShotGun_On
// (Final, Native, Public)
// Parameters:
// class UAnimNotify*                      AnimNotify                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionPriceAnimInstance::AnimNotify_IK_HndShotGun_On(const class UAnimNotify* AnimNotify)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionPriceAnimInstance", "AnimNotify_IK_HndShotGun_On");

	Params::OrionPriceAnimInstance_AnimNotify_IK_HndShotGun_On Parms{};

	Parms.AnimNotify = AnimNotify;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionProjectileMovementComponent.GetHomingTargetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UOrionProjectileMovementComponent::GetHomingTargetLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectileMovementComponent", "GetHomingTargetLocation");

	Params::OrionProjectileMovementComponent_GetHomingTargetLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction OrionGame.OrionProjectileMovementComponent.OnOrionProjectileBounceDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams, HasDefaults)
// Parameters:
// struct FHitResult                       ImpactResult                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          ImpactVelocity                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionProjectileMovementComponent::OnOrionProjectileBounceDelegate__DelegateSignature(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectileMovementComponent", "OnOrionProjectileBounceDelegate__DelegateSignature");

	Params::OrionProjectileMovementComponent_OnOrionProjectileBounceDelegate__DelegateSignature Parms{};

	Parms.ImpactResult = std::move(ImpactResult);
	Parms.ImpactVelocity = std::move(ImpactVelocity);

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction OrionGame.OrionProjectileMovementComponent.OnOrionProjectileMaxRangeDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UOrionProjectileMovementComponent::OnOrionProjectileMaxRangeDelegate__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectileMovementComponent", "OnOrionProjectileMaxRangeDelegate__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction OrionGame.OrionProjectileMovementComponent.OnOrionProjectileStopDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FHitResult                       ImpactResult                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UOrionProjectileMovementComponent::OnOrionProjectileStopDelegate__DelegateSignature(const struct FHitResult& ImpactResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectileMovementComponent", "OnOrionProjectileStopDelegate__DelegateSignature");

	Params::OrionProjectileMovementComponent_OnOrionProjectileStopDelegate__DelegateSignature Parms{};

	Parms.ImpactResult = std::move(ImpactResult);

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction OrionGame.OrionProjectileMovementComponent.OnOrionProjectileVelocityReversedDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UOrionProjectileMovementComponent::OnOrionProjectileVelocityReversedDelegate__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectileMovementComponent", "OnOrionProjectileVelocityReversedDelegate__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionProjectileMovementComponent.SetHomingTargetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewLocation                                            (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionProjectileMovementComponent::SetHomingTargetLocation(const struct FVector& NewLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectileMovementComponent", "SetHomingTargetLocation");

	Params::OrionProjectileMovementComponent_SetHomingTargetLocation Parms{};

	Parms.NewLocation = std::move(NewLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionProjectileMovementComponent.SetVelocityInLocalSpace
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewVelocity                                            (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionProjectileMovementComponent::SetVelocityInLocalSpace(const struct FVector& NewVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectileMovementComponent", "SetVelocityInLocalSpace");

	Params::OrionProjectileMovementComponent_SetVelocityInLocalSpace Parms{};

	Parms.NewVelocity = std::move(NewVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionProjectileMovementComponent.StopSimulating
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UOrionProjectileMovementComponent::StopSimulating(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectileMovementComponent", "StopSimulating");

	Params::OrionProjectileMovementComponent_StopSimulating Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionProjectileMovementComponent.LimitVelocity
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          InVelocity                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InUnlimitedVelocity                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutVelocity                                            (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutUnlimitedVelocity                                   (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionProjectileMovementComponent::LimitVelocity(const struct FVector& InVelocity, const struct FVector& InUnlimitedVelocity, struct FVector* OutVelocity, struct FVector* OutUnlimitedVelocity) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjectileMovementComponent", "LimitVelocity");

	Params::OrionProjectileMovementComponent_LimitVelocity Parms{};

	Parms.InVelocity = std::move(InVelocity);
	Parms.InUnlimitedVelocity = std::move(InUnlimitedVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutVelocity != nullptr)
		*OutVelocity = std::move(Parms.OutVelocity);

	if (OutUnlimitedVelocity != nullptr)
		*OutUnlimitedVelocity = std::move(Parms.OutUnlimitedVelocity);
}


// Function OrionGame.OrionProjFloorMovementComponent.SetWalkableFloorAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InWalkableFloorAngle                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionProjFloorMovementComponent::SetWalkableFloorAngle(float InWalkableFloorAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjFloorMovementComponent", "SetWalkableFloorAngle");

	Params::OrionProjFloorMovementComponent_SetWalkableFloorAngle Parms{};

	Parms.InWalkableFloorAngle = InWalkableFloorAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionProjFloorMovementComponent.SetWalkableFloorZ
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InWalkableFloorZ                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionProjFloorMovementComponent::SetWalkableFloorZ(float InWalkableFloorZ)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjFloorMovementComponent", "SetWalkableFloorZ");

	Params::OrionProjFloorMovementComponent_SetWalkableFloorZ Parms{};

	Parms.InWalkableFloorZ = InWalkableFloorZ;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionProjFloorMovementComponent.GetPerchRadiusThreshold
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOrionProjFloorMovementComponent::GetPerchRadiusThreshold() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjFloorMovementComponent", "GetPerchRadiusThreshold");

	Params::OrionProjFloorMovementComponent_GetPerchRadiusThreshold Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionProjFloorMovementComponent.GetValidPerchRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOrionProjFloorMovementComponent::GetValidPerchRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjFloorMovementComponent", "GetValidPerchRadius");

	Params::OrionProjFloorMovementComponent_GetValidPerchRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionProjFloorMovementComponent.IsWalkable
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionProjFloorMovementComponent::IsWalkable(const struct FHitResult& Hit) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionProjFloorMovementComponent", "IsWalkable");

	Params::OrionProjFloorMovementComponent_IsWalkable Parms{};

	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.GameplayQualifierKeywordFunctionLibrary.EvaluateQualifierSpec
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayQualifierParameters     QualifierSpec                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// EQualifierEvaluationResult              OutResult                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayQualifierKeywordFunctionLibrary::EvaluateQualifierSpec(const struct FGameplayQualifierParameters& QualifierSpec, EQualifierEvaluationResult* OutResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayQualifierKeywordFunctionLibrary", "EvaluateQualifierSpec");

	Params::GameplayQualifierKeywordFunctionLibrary_EvaluateQualifierSpec Parms{};

	Parms.QualifierSpec = std::move(QualifierSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutResult != nullptr)
		*OutResult = Parms.OutResult;
}


// Function OrionGame.OrionQuickChatMessage.BP_OnMessageSelected
// (Event, Protected, BlueprintEvent)

void UOrionQuickChatMessage::BP_OnMessageSelected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionQuickChatMessage", "BP_OnMessageSelected");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionQuickChatMessage.HandleMessageInputReceived
// (Final, Native, Private)

void UOrionQuickChatMessage::HandleMessageInputReceived()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionQuickChatMessage", "HandleMessageInputReceived");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionQuickChatWrapper.HandleToggleChatOptions
// (Final, Native, Private)

void UOrionQuickChatWrapper::HandleToggleChatOptions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionQuickChatWrapper", "HandleToggleChatOptions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionQuickChatWrapper.OnToggleChatOptions
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bShowChatOptions                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionQuickChatWrapper::OnToggleChatOptions(bool bShowChatOptions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionQuickChatWrapper", "OnToggleChatOptions");

	Params::OrionQuickChatWrapper_OnToggleChatOptions Parms{};

	Parms.bShowChatOptions = bShowChatOptions;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionReplaySpectator.DebugSetSpectatorCameraType
// (Final, Exec, Native, Protected, HasOutParams)
// Parameters:
// class FString                           Type                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionReplaySpectator::DebugSetSpectatorCameraType(const class FString& Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionReplaySpectator", "DebugSetSpectatorCameraType");

	Params::OrionReplaySpectator_DebugSetSpectatorCameraType Parms{};

	Parms.Type = std::move(Type);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionReplaySpectator.NotifyHeroPortraitClicked
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionTeam                              HeroTeam                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionReplaySpectator::NotifyHeroPortraitClicked(EOrionTeam HeroTeam, int32 PlayerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionReplaySpectator", "NotifyHeroPortraitClicked");

	Params::OrionReplaySpectator_NotifyHeroPortraitClicked Parms{};

	Parms.HeroTeam = HeroTeam;
	Parms.PlayerIndex = PlayerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionReplaySpectator.ReplaceSpectatorPawn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASpectatorPawn*                   NewSpectatorPawn                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionReplaySpectator::ReplaceSpectatorPawn(class ASpectatorPawn* NewSpectatorPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionReplaySpectator", "ReplaceSpectatorPawn");

	Params::OrionReplaySpectator_ReplaceSpectatorPawn Parms{};

	Parms.NewSpectatorPawn = NewSpectatorPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionReplaySpectator.SetHUDVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShowHUD                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionReplaySpectator::SetHUDVisibility(bool bShowHUD)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionReplaySpectator", "SetHUDVisibility");

	Params::OrionReplaySpectator_SetHUDVisibility Parms{};

	Parms.bShowHUD = bShowHUD;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionReplaySpectator.SetSpectatorCameraType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESpectatorCameraType                    NewCameraType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionReplaySpectator::SetSpectatorCameraType(ESpectatorCameraType NewCameraType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionReplaySpectator", "SetSpectatorCameraType");

	Params::OrionReplaySpectator_SetSpectatorCameraType Parms{};

	Parms.NewCameraType = NewCameraType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionReplaySpectator.StartWatchingActor
// (Final, Native, Public, BlueprintCallable)

void AOrionReplaySpectator::StartWatchingActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionReplaySpectator", "StartWatchingActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionReplaySpectator.StopWatchingActor
// (Final, Native, Public, BlueprintCallable)

void AOrionReplaySpectator::StopWatchingActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionReplaySpectator", "StopWatchingActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionReplaySpectator.WatchActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           NewActorToWatch                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionReplaySpectator::WatchActor(class AActor* NewActorToWatch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionReplaySpectator", "WatchActor");

	Params::OrionReplaySpectator_WatchActor Parms{};

	Parms.NewActorToWatch = NewActorToWatch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionReplaySpectator.WatchHero
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionTeam                              Team                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   HeroIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionReplaySpectator::WatchHero(EOrionTeam Team, int32 HeroIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionReplaySpectator", "WatchHero");

	Params::OrionReplaySpectator_WatchHero Parms{};

	Parms.Team = Team;
	Parms.HeroIndex = HeroIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionReplaySpectator.GetCurrentCameraType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESpectatorCameraType                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESpectatorCameraType AOrionReplaySpectator::GetCurrentCameraType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionReplaySpectator", "GetCurrentCameraType");

	Params::OrionReplaySpectator_GetCurrentCameraType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionReplaySpectator.GetWatchedActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AOrionReplaySpectator::GetWatchedActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionReplaySpectator", "GetWatchedActor");

	Params::OrionReplaySpectator_GetWatchedActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionReplaySpectator.IsForPlayback
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionReplaySpectator::IsForPlayback() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionReplaySpectator", "IsForPlayback");

	Params::OrionReplaySpectator_IsForPlayback Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionReplaySpectator.IsShowingDebugCameraOptions
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionReplaySpectator::IsShowingDebugCameraOptions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionReplaySpectator", "IsShowingDebugCameraOptions");

	Params::OrionReplaySpectator_IsShowingDebugCameraOptions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionRichText.GetColorType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionTextColor                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOrionTextColor UOrionRichText::GetColorType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionRichText", "GetColorType");

	Params::OrionRichText_GetColorType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionRichText.GetInlineIconColorType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionTextColor                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOrionTextColor UOrionRichText::GetInlineIconColorType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionRichText", "GetInlineIconColorType");

	Params::OrionRichText_GetInlineIconColorType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionRichText.GetStyleSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionWidgetStyleSize                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOrionWidgetStyleSize UOrionRichText::GetStyleSize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionRichText", "GetStyleSize");

	Params::OrionRichText_GetStyleSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionRichText.Refresh
// (Final, Native, Public, BlueprintCallable)

void UOrionRichText::Refresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionRichText", "Refresh");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionRichText.SetColorType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionTextColor                         Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionRichText::SetColorType(EOrionTextColor Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionRichText", "SetColorType");

	Params::OrionRichText_SetColorType Parms{};

	Parms.Color = Color;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionRichText.SetInlineIconDisplayMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ERichTextInlineIconDisplayMode          DisplayMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionRichText::SetInlineIconDisplayMode(ERichTextInlineIconDisplayMode DisplayMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionRichText", "SetInlineIconDisplayMode");

	Params::OrionRichText_SetInlineIconDisplayMode Parms{};

	Parms.DisplayMode = DisplayMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionRichText.SetSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionWidgetStyleSize                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionRichText::SetSize(EOrionWidgetStyleSize Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionRichText", "SetSize");

	Params::OrionRichText_SetSize Parms{};

	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionRichText.SetText
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOrionRichText::SetText(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionRichText", "SetText");

	Params::OrionRichText_SetText Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionRichTextHelperLibrary.ConvertToKeyword
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             Text                                                   (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOrionRichTextHelperLibrary::ConvertToKeyword(class FText& Text)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionRichTextHelperLibrary", "ConvertToKeyword");

	Params::OrionRichTextHelperLibrary_ConvertToKeyword Parms{};

	Parms.Text = std::move(Text);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Text = std::move(Parms.Text);
}


// Function OrionGame.OrionRichTextHelperLibrary.ConvertToKeywordSpecific
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             Text                                                   (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EOrionWidgetStyleSize                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionTextColor                         Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionRichTextHelperLibrary::ConvertToKeywordSpecific(class FText& Text, EOrionWidgetStyleSize Size, EOrionTextColor Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionRichTextHelperLibrary", "ConvertToKeywordSpecific");

	Params::OrionRichTextHelperLibrary_ConvertToKeywordSpecific Parms{};

	Parms.Text = std::move(Text);
	Parms.Size = Size;
	Parms.Color = Color;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Text = std::move(Parms.Text);
}


// Function OrionGame.OrionRichTextHelperLibrary.FormatAsAttributeValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionAttributeSummand                  SummandType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UOrionRichTextHelperLibrary::FormatAsAttributeValue(const class FString& Value, EOrionAttributeSummand SummandType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionRichTextHelperLibrary", "FormatAsAttributeValue");

	Params::OrionRichTextHelperLibrary_FormatAsAttributeValue Parms{};

	Parms.Value = std::move(Value);
	Parms.SummandType = SummandType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionRichTextHelperLibrary.FormatAsCurrency
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EOrionCurrencyType                      Currency                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             DisplayValue                                           (Parm, NativeAccessSpecifierPublic)
// EOrionWidgetStyleSize                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UOrionRichTextHelperLibrary::FormatAsCurrency(EOrionCurrencyType Currency, const class FText& DisplayValue, EOrionWidgetStyleSize Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionRichTextHelperLibrary", "FormatAsCurrency");

	Params::OrionRichTextHelperLibrary_FormatAsCurrency Parms{};

	Parms.Currency = Currency;
	Parms.DisplayValue = std::move(DisplayValue);
	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionRichTextHelperLibrary.FormatAsKeyword
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Text                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UOrionRichTextHelperLibrary::FormatAsKeyword(const class FString& Text)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionRichTextHelperLibrary", "FormatAsKeyword");

	Params::OrionRichTextHelperLibrary_FormatAsKeyword Parms{};

	Parms.Text = std::move(Text);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionRichTextHelperLibrary.FormatAsKeywordSpecific
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Text                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionWidgetStyleSize                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionTextColor                         Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UOrionRichTextHelperLibrary::FormatAsKeywordSpecific(const class FString& Text, EOrionWidgetStyleSize Size, EOrionTextColor Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionRichTextHelperLibrary", "FormatAsKeywordSpecific");

	Params::OrionRichTextHelperLibrary_FormatAsKeywordSpecific Parms{};

	Parms.Text = std::move(Text);
	Parms.Size = Size;
	Parms.Color = Color;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionRichTextHelperLibrary.GetAttributeAbbreviationMarkup
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Abbreviation                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UOrionRichTextHelperLibrary::GetAttributeAbbreviationMarkup(const class FString& Abbreviation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionRichTextHelperLibrary", "GetAttributeAbbreviationMarkup");

	Params::OrionRichTextHelperLibrary_GetAttributeAbbreviationMarkup Parms{};

	Parms.Abbreviation = std::move(Abbreviation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionRichTextHelperLibrary.GetAttributeMarkup
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// struct FOrionAttributeViewItem          AttributeItem                                          (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UOrionRichTextHelperLibrary::GetAttributeMarkup(const struct FOrionAttributeViewItem& AttributeItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionRichTextHelperLibrary", "GetAttributeMarkup");

	Params::OrionRichTextHelperLibrary_GetAttributeMarkup Parms{};

	Parms.AttributeItem = std::move(AttributeItem);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionRichTextHelperLibrary.GetAttributeValueTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// EOrionAttributeSummand                  SummandType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ValueTag                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionRichTextHelperLibrary::GetAttributeValueTag(EOrionAttributeSummand SummandType, class FString* ValueTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionRichTextHelperLibrary", "GetAttributeValueTag");

	Params::OrionRichTextHelperLibrary_GetAttributeValueTag Parms{};

	Parms.SummandType = SummandType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ValueTag != nullptr)
		*ValueTag = std::move(Parms.ValueTag);
}


// Function OrionGame.OrionRichTextHelperLibrary.GetCurrencyIconTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EOrionCurrencyType                      Currency                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UOrionRichTextHelperLibrary::GetCurrencyIconTag(EOrionCurrencyType Currency)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionRichTextHelperLibrary", "GetCurrencyIconTag");

	Params::OrionRichTextHelperLibrary_GetCurrencyIconTag Parms{};

	Parms.Currency = Currency;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionRichTextHelperLibrary.GetCurrencyIconTagSpecific
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EOrionCurrencyType                      Currency                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionWidgetStyleSize                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UOrionRichTextHelperLibrary::GetCurrencyIconTagSpecific(EOrionCurrencyType Currency, EOrionWidgetStyleSize Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionRichTextHelperLibrary", "GetCurrencyIconTagSpecific");

	Params::OrionRichTextHelperLibrary_GetCurrencyIconTagSpecific Parms{};

	Parms.Currency = Currency;
	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionRigs.GetAttchedToWell
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AOrionWell_Base*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOrionWell_Base* AOrionRigs::GetAttchedToWell()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionRigs", "GetAttchedToWell");

	Params::OrionRigs_GetAttchedToWell Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionRigs.GetBoostedRigScaler
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionRigs::GetBoostedRigScaler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionRigs", "GetBoostedRigScaler");

	Params::OrionRigs_GetBoostedRigScaler Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionRigs.GetCoinSpawnLocation
// (Native, Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AOrionRigs::GetCoinSpawnLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionRigs", "GetCoinSpawnLocation");

	Params::OrionRigs_GetCoinSpawnLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionRigs.GetMatchTimePlaced
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AOrionRigs::GetMatchTimePlaced()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionRigs", "GetMatchTimePlaced");

	Params::OrionRigs_GetMatchTimePlaced Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionRigs.GetPlayerThatPlacedRig
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AOrionPlayerState_Game*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOrionPlayerState_Game* AOrionRigs::GetPlayerThatPlacedRig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionRigs", "GetPlayerThatPlacedRig");

	Params::OrionRigs_GetPlayerThatPlacedRig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionRigs.GetWellResourcePercentLeft
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionRigs::GetWellResourcePercentLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionRigs", "GetWellResourcePercentLeft");

	Params::OrionRigs_GetWellResourcePercentLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionRigs.OnAttachedToWell
// (Event, Public, BlueprintEvent)
// Parameters:
// class AOrionWell_Base*                  InWell                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionRigs::OnAttachedToWell(class AOrionWell_Base* InWell)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionRigs", "OnAttachedToWell");

	Params::OrionRigs_OnAttachedToWell Parms{};

	Parms.InWell = InWell;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionRigs.OnRep_AttachedToWell
// (Native, Protected)
// Parameters:
// class AOrionWell_Base*                  OldAttachedToWell                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionRigs::OnRep_AttachedToWell(const class AOrionWell_Base* OldAttachedToWell)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionRigs", "OnRep_AttachedToWell");

	Params::OrionRigs_OnRep_AttachedToWell Parms{};

	Parms.OldAttachedToWell = OldAttachedToWell;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionRigs.OnSpawnCoins
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   ResourceAmount                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionRigs::OnSpawnCoins(float ResourceAmount, class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionRigs", "OnSpawnCoins");

	Params::OrionRigs_OnSpawnCoins Parms{};

	Parms.ResourceAmount = ResourceAmount;
	Parms.Target = Target;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionRigs.PlayerCollectCoins
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AOrionCharHero*                   CollectingPlayer                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionRigs::PlayerCollectCoins(class AOrionCharHero* CollectingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionRigs", "PlayerCollectCoins");

	Params::OrionRigs_PlayerCollectCoins Parms{};

	Parms.CollectingPlayer = CollectingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionRigs.SetPlayerThatPlacedThisRig
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AOrionPlayerState_Game*           InPlayer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionRigs::SetPlayerThatPlacedThisRig(class AOrionPlayerState_Game* InPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionRigs", "SetPlayerThatPlacedThisRig");

	Params::OrionRigs_SetPlayerThatPlacedThisRig Parms{};

	Parms.InPlayer = InPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionRigs.WellTagCallback_VisibleToEnemy
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionRigs::WellTagCallback_VisibleToEnemy(const struct FGameplayTag& Tag, int32 NewCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionRigs", "WellTagCallback_VisibleToEnemy");

	Params::OrionRigs_WellTagCallback_VisibleToEnemy Parms{};

	Parms.Tag = std::move(Tag);
	Parms.NewCount = NewCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionRotationalContentHandlerInterface.HandleRotationalContent
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTagContainer            TagsToHandle                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void IOrionRotationalContentHandlerInterface::HandleRotationalContent(const struct FGameplayTagContainer& TagsToHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionRotationalContentHandlerInterface", "HandleRotationalContent");

	Params::OrionRotationalContentHandlerInterface_HandleRotationalContent Parms{};

	Parms.TagsToHandle = std::move(TagsToHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionRotationalContentManager.RegisterHandler
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Handler                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionRotationalContentManager*   SpecificManager                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionRotationalContentManager::RegisterHandler(class UObject* Handler, class UOrionRotationalContentManager* SpecificManager)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionRotationalContentManager", "RegisterHandler");

	Params::OrionRotationalContentManager_RegisterHandler Parms{};

	Parms.Handler = Handler;
	Parms.SpecificManager = SpecificManager;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionRotationalContentManager.UnRegisterHandler
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Handler                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionRotationalContentManager*   SpecificManager                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionRotationalContentManager::UnRegisterHandler(class UObject* Handler, class UOrionRotationalContentManager* SpecificManager)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionRotationalContentManager", "UnRegisterHandler");

	Params::OrionRotationalContentManager_UnRegisterHandler Parms{};

	Parms.Handler = Handler;
	Parms.SpecificManager = SpecificManager;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionRotationalContentManager.OnMCPTagsUpdated
// (Final, Native, Private)

void UOrionRotationalContentManager::OnMCPTagsUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionRotationalContentManager", "OnMCPTagsUpdated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionRuntimeOptions.GetRuntimeOptions
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UOrionRuntimeOptions*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionRuntimeOptions* UOrionRuntimeOptions::GetRuntimeOptions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionRuntimeOptions", "GetRuntimeOptions");

	Params::OrionRuntimeOptions_GetRuntimeOptions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction OrionGame.OrionRuntimeOptions.OnHotfixApplied__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UOrionRuntimeOptions::OnHotfixApplied__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionRuntimeOptions", "OnHotfixApplied__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionRuntimeOptions.GetBuildTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UOrionRuntimeOptions::GetBuildTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionRuntimeOptions", "GetBuildTime");

	Params::OrionRuntimeOptions_GetBuildTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionRuntimeOptions.GetDecoySwapsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionRuntimeOptions::GetDecoySwapsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionRuntimeOptions", "GetDecoySwapsEnabled");

	Params::OrionRuntimeOptions_GetDecoySwapsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionRuntimeOptions.GetFirstGamePlaylistID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOrionRuntimeOptions::GetFirstGamePlaylistID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionRuntimeOptions", "GetFirstGamePlaylistID");

	Params::OrionRuntimeOptions_GetFirstGamePlaylistID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionRuntimeOptions.GetGameVersion
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UOrionRuntimeOptions::GetGameVersion() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionRuntimeOptions", "GetGameVersion");

	Params::OrionRuntimeOptions_GetGameVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionRuntimeOptions.IsDeathcamEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionRuntimeOptions::IsDeathcamEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionRuntimeOptions", "IsDeathcamEnabled");

	Params::OrionRuntimeOptions_IsDeathcamEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionRuntimeOptions.IsImageViewer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionRuntimeOptions::IsImageViewer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionRuntimeOptions", "IsImageViewer");

	Params::OrionRuntimeOptions_IsImageViewer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionRuntimeOptions.ProjectileCustomHitsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionRuntimeOptions::ProjectileCustomHitsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionRuntimeOptions", "ProjectileCustomHitsEnabled");

	Params::OrionRuntimeOptions_ProjectileCustomHitsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionRuntimeOptions.UseLegacyDeathTimers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionRuntimeOptions::UseLegacyDeathTimers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionRuntimeOptions", "UseLegacyDeathTimers");

	Params::OrionRuntimeOptions_UseLegacyDeathTimers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionShadowPad.GameplayTagCallback_ShadowPlanePadOff
// (Final, Native, Public)
// Parameters:
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionShadowPad::GameplayTagCallback_ShadowPlanePadOff(const struct FGameplayTag& Tag, int32 NewCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionShadowPad", "GameplayTagCallback_ShadowPlanePadOff");

	Params::OrionShadowPad_GameplayTagCallback_ShadowPlanePadOff Parms{};

	Parms.Tag = std::move(Tag);
	Parms.NewCount = NewCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionShadowPad.HandleOverlappingCharDeath
// (Final, Native, Public)
// Parameters:
// class AOrionChar*                       DeadChar                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      Killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionShadowPad::HandleOverlappingCharDeath(class AOrionChar* DeadChar, class AController* Killer, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionShadowPad", "HandleOverlappingCharDeath");

	Params::OrionShadowPad_HandleOverlappingCharDeath Parms{};

	Parms.DeadChar = DeadChar;
	Parms.Killer = Killer;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionShadowPad.HandleOverlappingCharEnteredPhaseShift
// (Final, Native, Public)
// Parameters:
// class AOrionChar*                       PhaseShifedChar                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionShadowPad::HandleOverlappingCharEnteredPhaseShift(class AOrionChar* PhaseShifedChar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionShadowPad", "HandleOverlappingCharEnteredPhaseShift");

	Params::OrionShadowPad_HandleOverlappingCharEnteredPhaseShift Parms{};

	Parms.PhaseShifedChar = PhaseShifedChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionShadowPad.OnOverlapBegin
// (Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AOrionShadowPad::OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionShadowPad", "OnOverlapBegin");

	Params::OrionShadowPad_OnOverlapBegin Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionShadowPad.OnOverlapEnd
// (Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionShadowPad::OnOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionShadowPad", "OnOverlapEnd");

	Params::OrionShadowPad_OnOverlapEnd Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionShadowPad.UpdateLocalEffects
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionShadowPad::UpdateLocalEffects(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionShadowPad", "UpdateLocalEffects");

	Params::OrionShadowPad_UpdateLocalEffects Parms{};

	Parms.Enabled = Enabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionSpectatorCamComp_Arena.AddMoveForwardInput
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InputVal                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionSpectatorCamComp_Arena::AddMoveForwardInput(float InputVal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionSpectatorCamComp_Arena", "AddMoveForwardInput");

	Params::OrionSpectatorCamComp_Arena_AddMoveForwardInput Parms{};

	Parms.InputVal = InputVal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionSpectatorCamComp_Arena.AddMoveRightInput
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InputVal                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionSpectatorCamComp_Arena::AddMoveRightInput(float InputVal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionSpectatorCamComp_Arena", "AddMoveRightInput");

	Params::OrionSpectatorCamComp_Arena_AddMoveRightInput Parms{};

	Parms.InputVal = InputVal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionSpectatorCamComp_Arena.SetCameraPositionOnRail
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DistanceAlongRail                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionSpectatorCamComp_Arena::SetCameraPositionOnRail(float DistanceAlongRail)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionSpectatorCamComp_Arena", "SetCameraPositionOnRail");

	Params::OrionSpectatorCamComp_Arena_SetCameraPositionOnRail Parms{};

	Parms.DistanceAlongRail = DistanceAlongRail;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionSpectatorCamComp_Arena.SetEnforce180Rule
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewEnforce180                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionSpectatorCamComp_Arena::SetEnforce180Rule(bool bNewEnforce180)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionSpectatorCamComp_Arena", "SetEnforce180Rule");

	Params::OrionSpectatorCamComp_Arena_SetEnforce180Rule Parms{};

	Parms.bNewEnforce180 = bNewEnforce180;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionSpectatorCamComp_Chase.SetAutoFollow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewAutoFollow                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionSpectatorCamComp_Chase::SetAutoFollow(bool bNewAutoFollow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionSpectatorCamComp_Chase", "SetAutoFollow");

	Params::OrionSpectatorCamComp_Chase_SetAutoFollow Parms{};

	Parms.bNewAutoFollow = bNewAutoFollow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionSpectatorCamComp_Chase.SetLazyAutoFollow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewLazyAutoFollow                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionSpectatorCamComp_Chase::SetLazyAutoFollow(bool bNewLazyAutoFollow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionSpectatorCamComp_Chase", "SetLazyAutoFollow");

	Params::OrionSpectatorCamComp_Chase_SetLazyAutoFollow Parms{};

	Parms.bNewLazyAutoFollow = bNewLazyAutoFollow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionSpectatorCamComp_Isometric.SetCameraAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EIsometricCamAngle                      NewAngle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionSpectatorCamComp_Isometric::SetCameraAngle(EIsometricCamAngle NewAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionSpectatorCamComp_Isometric", "SetCameraAngle");

	Params::OrionSpectatorCamComp_Isometric_SetCameraAngle Parms{};

	Parms.NewAngle = NewAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionSpectatorCamComp_OTS.SetAutoFollow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewAutoFollow                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionSpectatorCamComp_OTS::SetAutoFollow(bool bNewAutoFollow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionSpectatorCamComp_OTS", "SetAutoFollow");

	Params::OrionSpectatorCamComp_OTS_SetAutoFollow Parms{};

	Parms.bNewAutoFollow = bNewAutoFollow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionTargetingFunctionLibrary.SphereAroundActor
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class AActor*                           TargetingActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AroundActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FOrionActorFilter                Filter                                                 (Parm, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayAbilityTargetDataHandle UOrionTargetingFunctionLibrary::SphereAroundActor(class AActor* TargetingActor, class AActor* AroundActor, float Radius, const struct FOrionActorFilter& Filter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionTargetingFunctionLibrary", "SphereAroundActor");

	Params::OrionTargetingFunctionLibrary_SphereAroundActor Parms{};

	Parms.TargetingActor = TargetingActor;
	Parms.AroundActor = AroundActor;
	Parms.Radius = Radius;
	Parms.Filter = std::move(Filter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTeamBuilderPartyMember.SetDeck
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           DeckId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionTeamBuilderPartyMember::SetDeck(const class FString& DeckId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamBuilderPartyMember", "SetDeck");

	Params::OrionTeamBuilderPartyMember_SetDeck Parms{};

	Parms.DeckId = std::move(DeckId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionTeamBuilderPartyMember.SetHeroName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           HeroName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionTeamBuilderPartyMember::SetHeroName(const class FString& HeroName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamBuilderPartyMember", "SetHeroName");

	Params::OrionTeamBuilderPartyMember_SetHeroName Parms{};

	Parms.HeroName = std::move(HeroName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionTeamBuilderPartyMember.SetPlatform
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionPlayerPlatform                    InPlatform                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionTeamBuilderPartyMember::SetPlatform(EOrionPlayerPlatform InPlatform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamBuilderPartyMember", "SetPlatform");

	Params::OrionTeamBuilderPartyMember_SetPlatform Parms{};

	Parms.InPlatform = InPlatform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionTeamBuilderPartyMember.SetPosition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionPosition                          Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionTeamBuilderPartyMember::SetPosition(EOrionPosition Position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamBuilderPartyMember", "SetPosition");

	Params::OrionTeamBuilderPartyMember_SetPosition Parms{};

	Parms.Position = Position;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionTeamBuilderPartyMember.SetReady
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InReady                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionTeamBuilderPartyMember::SetReady(bool InReady)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamBuilderPartyMember", "SetReady");

	Params::OrionTeamBuilderPartyMember_SetReady Parms{};

	Parms.InReady = InReady;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionTeamBuilderPartyMember.SetRole
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionRole                              Role                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionTeamBuilderPartyMember::SetRole(EOrionRole Role)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamBuilderPartyMember", "SetRole");

	Params::OrionTeamBuilderPartyMember_SetRole Parms{};

	Parms.Role = Role;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionTeamBuilderPartyMember.GetCosmeticChoices
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FOrionCosmeticPlayerChoices      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FOrionCosmeticPlayerChoices UOrionTeamBuilderPartyMember::GetCosmeticChoices() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamBuilderPartyMember", "GetCosmeticChoices");

	Params::OrionTeamBuilderPartyMember_GetCosmeticChoices Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTeamBuilderPartyMember.GetDeck
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UOrionTeamBuilderPartyMember::GetDeck() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamBuilderPartyMember", "GetDeck");

	Params::OrionTeamBuilderPartyMember_GetDeck Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTeamBuilderPartyMember.GetHeroName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UOrionTeamBuilderPartyMember::GetHeroName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamBuilderPartyMember", "GetHeroName");

	Params::OrionTeamBuilderPartyMember_GetHeroName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTeamBuilderPartyMember.GetPlatform
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionPlayerPlatform                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOrionPlayerPlatform UOrionTeamBuilderPartyMember::GetPlatform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamBuilderPartyMember", "GetPlatform");

	Params::OrionTeamBuilderPartyMember_GetPlatform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTeamBuilderPartyMember.GetPosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionPosition                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOrionPosition UOrionTeamBuilderPartyMember::GetPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamBuilderPartyMember", "GetPosition");

	Params::OrionTeamBuilderPartyMember_GetPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTeamBuilderPartyMember.GetRole
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionRole                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOrionRole UOrionTeamBuilderPartyMember::GetRole() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamBuilderPartyMember", "GetRole");

	Params::OrionTeamBuilderPartyMember_GetRole Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTeamBuilderPartyMember.GetSlotIdx
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOrionTeamBuilderPartyMember::GetSlotIdx() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamBuilderPartyMember", "GetSlotIdx");

	Params::OrionTeamBuilderPartyMember_GetSlotIdx Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTeamBuilderPartyMember.IsDirty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionTeamBuilderPartyMemberStateFlags  Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionTeamBuilderPartyMember::IsDirty(EOrionTeamBuilderPartyMemberStateFlags Flag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamBuilderPartyMember", "IsDirty");

	Params::OrionTeamBuilderPartyMember_IsDirty Parms{};

	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTeamBuilderPartyMember.IsReady
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionTeamBuilderPartyMember::IsReady() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamBuilderPartyMember", "IsReady");

	Params::OrionTeamBuilderPartyMember_IsReady Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTeamColorComponent.SetupTeamColors
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EOrionTeam                              TeamNum                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsDead                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionTeamColorComponent::SetupTeamColors(EOrionTeam TeamNum, bool bIsDead)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamColorComponent", "SetupTeamColors");

	Params::OrionTeamColorComponent_SetupTeamColors Parms{};

	Parms.TeamNum = TeamNum;
	Parms.bIsDead = bIsDead;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionTeamInfo.GetPlayerArray
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class AController*>              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AController*> AOrionTeamInfo::GetPlayerArray()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamInfo", "GetPlayerArray");

	Params::OrionTeamInfo_GetPlayerArray Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTeamInfo.OnRep_DragonKills
// (Final, Native, Protected)

void AOrionTeamInfo::OnRep_DragonKills()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamInfo", "OnRep_DragonKills");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionTeamInfo.OnRep_SurrenderVoteInstigator
// (Final, Native, Protected)

void AOrionTeamInfo::OnRep_SurrenderVoteInstigator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamInfo", "OnRep_SurrenderVoteInstigator");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionTeamInfo.OnRep_SurrenderVoteStatus
// (Final, Native, Protected)

void AOrionTeamInfo::OnRep_SurrenderVoteStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamInfo", "OnRep_SurrenderVoteStatus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionTeamInfo.OnRep_XPTrickleRate
// (Final, Native, Protected)

void AOrionTeamInfo::OnRep_XPTrickleRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamInfo", "OnRep_XPTrickleRate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionTeamInfo.UpdateXPTrickleRate
// (Final, Native, Protected)

void AOrionTeamInfo::UpdateXPTrickleRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamInfo", "UpdateXPTrickleRate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionTeamInfo.GetDragonKillCount
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AOrionTeamInfo::GetDragonKillCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamInfo", "GetDragonKillCount");

	Params::OrionTeamInfo_GetDragonKillCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTeamInfo.GetMaxPlayers
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AOrionTeamInfo::GetMaxPlayers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamInfo", "GetMaxPlayers");

	Params::OrionTeamInfo_GetMaxPlayers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTeamInfo.GetNumPlayersOnTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AOrionTeamInfo::GetNumPlayersOnTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamInfo", "GetNumPlayersOnTeam");

	Params::OrionTeamInfo_GetNumPlayersOnTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTeamInfo.GetSurrenderButtonText
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText AOrionTeamInfo::GetSurrenderButtonText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamInfo", "GetSurrenderButtonText");

	Params::OrionTeamInfo_GetSurrenderButtonText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTeamInfo.GetSurrenderVoteCooldownSecondsRemaining
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AOrionTeamInfo::GetSurrenderVoteCooldownSecondsRemaining() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamInfo", "GetSurrenderVoteCooldownSecondsRemaining");

	Params::OrionTeamInfo_GetSurrenderVoteCooldownSecondsRemaining Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTeamInfo.GetSurrenderVoteSecondsRemaining
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AOrionTeamInfo::GetSurrenderVoteSecondsRemaining() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamInfo", "GetSurrenderVoteSecondsRemaining");

	Params::OrionTeamInfo_GetSurrenderVoteSecondsRemaining Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTeamInfo.GetSurrenderVoteStatus
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETeamSurrenderStatus                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETeamSurrenderStatus AOrionTeamInfo::GetSurrenderVoteStatus() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamInfo", "GetSurrenderVoteStatus");

	Params::OrionTeamInfo_GetSurrenderVoteStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTeamInfo.GetSurrenderVoteText
// (Final, RequiredAPI, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             VoteText                                               (Parm, OutParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionTeamInfo::GetSurrenderVoteText(class FText* VoteText) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamInfo", "GetSurrenderVoteText");

	Params::OrionTeamInfo_GetSurrenderVoteText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (VoteText != nullptr)
		*VoteText = std::move(Parms.VoteText);

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTeamInfo.GetTeamAssists
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AOrionTeamInfo::GetTeamAssists() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamInfo", "GetTeamAssists");

	Params::OrionTeamInfo_GetTeamAssists Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTeamInfo.GetTeamBuilderInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FOrionTBTeamInfo                 ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FOrionTBTeamInfo AOrionTeamInfo::GetTeamBuilderInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamInfo", "GetTeamBuilderInfo");

	Params::OrionTeamInfo_GetTeamBuilderInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTeamInfo.GetTeamDeaths
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AOrionTeamInfo::GetTeamDeaths() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamInfo", "GetTeamDeaths");

	Params::OrionTeamInfo_GetTeamDeaths Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTeamInfo.GetTeamDestroyedRigs
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AOrionTeamInfo::GetTeamDestroyedRigs() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamInfo", "GetTeamDestroyedRigs");

	Params::OrionTeamInfo_GetTeamDestroyedRigs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTeamInfo.GetTeamInhibitorKills
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AOrionTeamInfo::GetTeamInhibitorKills() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamInfo", "GetTeamInhibitorKills");

	Params::OrionTeamInfo_GetTeamInhibitorKills Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTeamInfo.GetTeamInhibitorTakedowns
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AOrionTeamInfo::GetTeamInhibitorTakedowns() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamInfo", "GetTeamInhibitorTakedowns");

	Params::OrionTeamInfo_GetTeamInhibitorTakedowns Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTeamInfo.GetTeamKills
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AOrionTeamInfo::GetTeamKills() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamInfo", "GetTeamKills");

	Params::OrionTeamInfo_GetTeamKills Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTeamInfo.GetTeamMinionKills
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AOrionTeamInfo::GetTeamMinionKills() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamInfo", "GetTeamMinionKills");

	Params::OrionTeamInfo_GetTeamMinionKills Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTeamInfo.GetTeamPlacedRigs
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AOrionTeamInfo::GetTeamPlacedRigs() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamInfo", "GetTeamPlacedRigs");

	Params::OrionTeamInfo_GetTeamPlacedRigs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTeamInfo.GetTeamTowerKills
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AOrionTeamInfo::GetTeamTowerKills() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamInfo", "GetTeamTowerKills");

	Params::OrionTeamInfo_GetTeamTowerKills Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTeamInfo.GetTeamTowerTakedowns
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AOrionTeamInfo::GetTeamTowerTakedowns() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamInfo", "GetTeamTowerTakedowns");

	Params::OrionTeamInfo_GetTeamTowerTakedowns Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTeamInfo.GetXPTrickleRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionTeamInfo::GetXPTrickleRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamInfo", "GetXPTrickleRate");

	Params::OrionTeamInfo_GetXPTrickleRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTeamInfo.HasRoomForAPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionTeamInfo::HasRoomForAPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamInfo", "HasRoomForAPlayer");

	Params::OrionTeamInfo_HasRoomForAPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTeamInfo.IsPlayerTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionTeamInfo::IsPlayerTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTeamInfo", "IsPlayerTeam");

	Params::OrionTeamInfo_IsPlayerTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTextStyle.GetColor
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionTextColor                         ColorType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     OutColor                                               (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionTextStyle::GetColor(EOrionTextColor ColorType, struct FLinearColor* OutColor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTextStyle", "GetColor");

	Params::OrionTextStyle_GetColor Parms{};

	Parms.ColorType = ColorType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutColor != nullptr)
		*OutColor = std::move(Parms.OutColor);
}


// Function OrionGame.OrionTextStyle.GetFont
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionWidgetStyleSize                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSlateFontInfo                   OutFont                                                (Parm, OutParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionTextStyle::GetFont(EOrionWidgetStyleSize Size, struct FSlateFontInfo* OutFont) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTextStyle", "GetFont");

	Params::OrionTextStyle_GetFont Parms{};

	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFont != nullptr)
		*OutFont = std::move(Parms.OutFont);
}


// Function OrionGame.OrionTextStyle.GetLineHeightPercentage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionWidgetStyleSize                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOrionTextStyle::GetLineHeightPercentage(EOrionWidgetStyleSize Size) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTextStyle", "GetLineHeightPercentage");

	Params::OrionTextStyle_GetLineHeightPercentage Parms{};

	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTextStyle.GetMargin
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionWidgetStyleSize                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMargin                          OutMargin                                              (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UOrionTextStyle::GetMargin(EOrionWidgetStyleSize Size, struct FMargin* OutMargin) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTextStyle", "GetMargin");

	Params::OrionTextStyle_GetMargin Parms{};

	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMargin != nullptr)
		*OutMargin = std::move(Parms.OutMargin);
}


// Function OrionGame.OrionTextStyle.GetShadowColor
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionTextColor                         ColorType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     OutColor                                               (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionTextStyle::GetShadowColor(EOrionTextColor ColorType, struct FLinearColor* OutColor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTextStyle", "GetShadowColor");

	Params::OrionTextStyle_GetShadowColor Parms{};

	Parms.ColorType = ColorType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutColor != nullptr)
		*OutColor = std::move(Parms.OutColor);
}


// Function OrionGame.OrionTextStyle.GetShadowOffset
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionWidgetStyleSize                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        OutShadowOffset                                        (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionTextStyle::GetShadowOffset(EOrionWidgetStyleSize Size, struct FVector2D* OutShadowOffset) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTextStyle", "GetShadowOffset");

	Params::OrionTextStyle_GetShadowOffset Parms{};

	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutShadowOffset != nullptr)
		*OutShadowOffset = std::move(Parms.OutShadowOffset);
}


// Function OrionGame.OrionTextBlock.SetColorType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionTextColor                         Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionTextBlock::SetColorType(EOrionTextColor Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTextBlock", "SetColorType");

	Params::OrionTextBlock_SetColorType Parms{};

	Parms.Color = Color;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionTextBlock.SetProperties
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UOrionTextStyle>      InStyle                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionWidgetStyleSize                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionTextColor                         Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InWrapTextAt                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldUseDropShadow                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionTextBlock::SetProperties(TSubclassOf<class UOrionTextStyle> InStyle, EOrionWidgetStyleSize Size, EOrionTextColor Color, int32 InWrapTextAt, bool bShouldUseDropShadow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTextBlock", "SetProperties");

	Params::OrionTextBlock_SetProperties Parms{};

	Parms.InStyle = InStyle;
	Parms.Size = Size;
	Parms.Color = Color;
	Parms.InWrapTextAt = InWrapTextAt;
	Parms.bShouldUseDropShadow = bShouldUseDropShadow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionTextBlock.SetSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionWidgetStyleSize                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionTextBlock::SetSize(EOrionWidgetStyleSize Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTextBlock", "SetSize");

	Params::OrionTextBlock_SetSize Parms{};

	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionTextBlock.SetStyle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UOrionTextStyle>      InStyle                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionTextBlock::SetStyle(TSubclassOf<class UOrionTextStyle> InStyle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTextBlock", "SetStyle");

	Params::OrionTextBlock_SetStyle Parms{};

	Parms.InStyle = InStyle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionTextBlock.SetUseDropShadow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShouldUseDropShadow                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionTextBlock::SetUseDropShadow(bool bShouldUseDropShadow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTextBlock", "SetUseDropShadow");

	Params::OrionTextBlock_SetUseDropShadow Parms{};

	Parms.bShouldUseDropShadow = bShouldUseDropShadow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionTextBlock.SetWrapTextWidth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InWrapTextAt                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionTextBlock::SetWrapTextWidth(int32 InWrapTextAt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTextBlock", "SetWrapTextWidth");

	Params::OrionTextBlock_SetWrapTextWidth Parms{};

	Parms.InWrapTextAt = InWrapTextAt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionTooltipAnchor.BasicTooltip
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FText                             Title                                                  (Parm, NativeAccessSpecifierPublic)
// class FText                             Body                                                   (Parm, NativeAccessSpecifierPublic)
// class UOrionBasicTooltipWidget*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionBasicTooltipWidget* UOrionTooltipAnchor::BasicTooltip(const class FText& Title, const class FText& Body)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionTooltipAnchor", "BasicTooltip");

	Params::OrionTooltipAnchor_BasicTooltip Parms{};

	Parms.Title = std::move(Title);
	Parms.Body = std::move(Body);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTooltipAnchor.ForceHideCurrentTooltip
// (Final, Native, Static, Public, BlueprintCallable)

void UOrionTooltipAnchor::ForceHideCurrentTooltip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionTooltipAnchor", "ForceHideCurrentTooltip");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionTraversablePathway.CheckPathPointsRange
// (Final, Native, Public, HasDefaults)
// Parameters:
// class AActor*                           SourceActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          CheckLocation                                          (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionTraversablePathway::CheckPathPointsRange(class AActor* SourceActor, const struct FVector& CheckLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTraversablePathway", "CheckPathPointsRange");

	Params::OrionTraversablePathway_CheckPathPointsRange Parms{};

	Parms.SourceActor = SourceActor;
	Parms.CheckLocation = std::move(CheckLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionTraversablePathway.CreateDebugTraversablePathway
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          PathStart                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PathEnd                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionTraversablePathway::CreateDebugTraversablePathway(const struct FVector& PathStart, const struct FVector& PathEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTraversablePathway", "CreateDebugTraversablePathway");

	Params::OrionTraversablePathway_CreateDebugTraversablePathway Parms{};

	Parms.PathStart = std::move(PathStart);
	Parms.PathEnd = std::move(PathEnd);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionTraversablePathway.FadeOutAndDestroyPathway
// (Final, Native, Public, BlueprintCallable)

void AOrionTraversablePathway::FadeOutAndDestroyPathway()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTraversablePathway", "FadeOutAndDestroyPathway");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionTraversablePathway.GetBreadCrumpActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AOrionTraversablePathway::GetBreadCrumpActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTraversablePathway", "GetBreadCrumpActor");

	Params::OrionTraversablePathway_GetBreadCrumpActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTraversablePathway.GetEvenlySpacedPointsFromPointArray
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<struct FEvenlySpacedPoint>       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<struct FEvenlySpacedPoint> AOrionTraversablePathway::GetEvenlySpacedPointsFromPointArray()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTraversablePathway", "GetEvenlySpacedPointsFromPointArray");

	Params::OrionTraversablePathway_GetEvenlySpacedPointsFromPointArray Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionTraversablePathway.OnAddedEvenlySpacedPoint
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   ArrayIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionTraversablePathway::OnAddedEvenlySpacedPoint(int32 ArrayIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTraversablePathway", "OnAddedEvenlySpacedPoint");

	Params::OrionTraversablePathway_OnAddedEvenlySpacedPoint Parms{};

	Parms.ArrayIndex = ArrayIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionTraversablePathway.OnFirstEvenlySpacedPointChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   PrevFirstEvenlySpacedPointIndex                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewFirstEvenlySpacedPointIndex                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionTraversablePathway::OnFirstEvenlySpacedPointChanged(int32 PrevFirstEvenlySpacedPointIndex, int32 NewFirstEvenlySpacedPointIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTraversablePathway", "OnFirstEvenlySpacedPointChanged");

	Params::OrionTraversablePathway_OnFirstEvenlySpacedPointChanged Parms{};

	Parms.PrevFirstEvenlySpacedPointIndex = PrevFirstEvenlySpacedPointIndex;
	Parms.NewFirstEvenlySpacedPointIndex = NewFirstEvenlySpacedPointIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionTraversablePathway.OnLastEvenlySpacedPointChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   PrevLastEvenlySpacedPointIndex                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewLastEvenlySpacedPointIndex                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionTraversablePathway::OnLastEvenlySpacedPointChanged(int32 PrevLastEvenlySpacedPointIndex, int32 NewLastEvenlySpacedPointIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTraversablePathway", "OnLastEvenlySpacedPointChanged");

	Params::OrionTraversablePathway_OnLastEvenlySpacedPointChanged Parms{};

	Parms.PrevLastEvenlySpacedPointIndex = PrevLastEvenlySpacedPointIndex;
	Parms.NewLastEvenlySpacedPointIndex = NewLastEvenlySpacedPointIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionTraversablePathway.OnRep_OrionReplicatedPathToDestination
// (Final, Native, Public)

void AOrionTraversablePathway::OnRep_OrionReplicatedPathToDestination()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTraversablePathway", "OnRep_OrionReplicatedPathToDestination");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionTraversablePathway.OnSourceInRange
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           SourceActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionTraversablePathway::OnSourceInRange(class AActor* SourceActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTraversablePathway", "OnSourceInRange");

	Params::OrionTraversablePathway_OnSourceInRange Parms{};

	Parms.SourceActor = SourceActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionTraversablePathway.OnSourceOutOfRange
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           SourceActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionTraversablePathway::OnSourceOutOfRange(class AActor* SourceActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTraversablePathway", "OnSourceOutOfRange");

	Params::OrionTraversablePathway_OnSourceOutOfRange Parms{};

	Parms.SourceActor = SourceActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionTraversablePathway.UpdateCheckPathPoints
// (Final, Native, Public)

void AOrionTraversablePathway::UpdateCheckPathPoints()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTraversablePathway", "UpdateCheckPathPoints");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionTutorialMessageWidget.OnShowNewStage
// (Event, Public, BlueprintEvent)

void UOrionTutorialMessageWidget::OnShowNewStage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionTutorialMessageWidget", "OnShowNewStage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionUI_Game.OrionCycleShowDebug
// (Exec, Native, Public)

void AOrionUI_Game::OrionCycleShowDebug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUI_Game", "OrionCycleShowDebug");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUIBlueprintLibrary.ClearFocusForModalWindow
// (Final, Native, Static, Public, BlueprintCallable)

void UOrionUIBlueprintLibrary::ClearFocusForModalWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIBlueprintLibrary", "ClearFocusForModalWindow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUIBlueprintLibrary.Contains_OrionAffinityStruct
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FOrionAffinityStruct             Authority                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FOrionAffinityStruct             Test                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionUIBlueprintLibrary::Contains_OrionAffinityStruct(const struct FOrionAffinityStruct& Authority, const struct FOrionAffinityStruct& Test)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIBlueprintLibrary", "Contains_OrionAffinityStruct");

	Params::OrionUIBlueprintLibrary_Contains_OrionAffinityStruct Parms{};

	Parms.Authority = std::move(Authority);
	Parms.Test = std::move(Test);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUIBlueprintLibrary.CopyToClipboard
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ClipboardText                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionUIBlueprintLibrary::CopyToClipboard(const class FString& ClipboardText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIBlueprintLibrary", "CopyToClipboard");

	Params::OrionUIBlueprintLibrary_CopyToClipboard Parms{};

	Parms.ClipboardText = std::move(ClipboardText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUIBlueprintLibrary.EqualEqual_OrionPlayerStateUIID
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FOrionPlayerStateUIID            A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FOrionPlayerStateUIID            B                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionUIBlueprintLibrary::EqualEqual_OrionPlayerStateUIID(const struct FOrionPlayerStateUIID& A, const struct FOrionPlayerStateUIID& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIBlueprintLibrary", "EqualEqual_OrionPlayerStateUIID");

	Params::OrionUIBlueprintLibrary_EqualEqual_OrionPlayerStateUIID Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUIBlueprintLibrary.GetAvailableLanguages
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UOrionUIBlueprintLibrary::GetAvailableLanguages()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIBlueprintLibrary", "GetAvailableLanguages");

	Params::OrionUIBlueprintLibrary_GetAvailableLanguages Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUIBlueprintLibrary.GetCleanOffset
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        InVec                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UOrionUIBlueprintLibrary::GetCleanOffset(const struct FVector2D& InVec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIBlueprintLibrary", "GetCleanOffset");

	Params::OrionUIBlueprintLibrary_GetCleanOffset Parms{};

	Parms.InVec = std::move(InVec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUIBlueprintLibrary.GetCurrentLanguageCode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UOrionUIBlueprintLibrary::GetCurrentLanguageCode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIBlueprintLibrary", "GetCurrentLanguageCode");

	Params::OrionUIBlueprintLibrary_GetCurrentLanguageCode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUIBlueprintLibrary.GetCurrentMaterialTime
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOrionUIBlueprintLibrary::GetCurrentMaterialTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIBlueprintLibrary", "GetCurrentMaterialTime");

	Params::OrionUIBlueprintLibrary_GetCurrentMaterialTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUIBlueprintLibrary.GetHealthPipValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOrionUIBlueprintLibrary::GetHealthPipValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIBlueprintLibrary", "GetHealthPipValue");

	Params::OrionUIBlueprintLibrary_GetHealthPipValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUIBlueprintLibrary.GetHeroesForWelcomeScreen
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class UOrionHeroData*>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UOrionHeroData*> UOrionUIBlueprintLibrary::GetHeroesForWelcomeScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIBlueprintLibrary", "GetHeroesForWelcomeScreen");

	Params::OrionUIBlueprintLibrary_GetHeroesForWelcomeScreen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUIBlueprintLibrary.GetLanguageDisplayName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           LanguageCode                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UOrionUIBlueprintLibrary::GetLanguageDisplayName(const class FString& LanguageCode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIBlueprintLibrary", "GetLanguageDisplayName");

	Params::OrionUIBlueprintLibrary_GetLanguageDisplayName Parms{};

	Parms.LanguageCode = std::move(LanguageCode);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUIBlueprintLibrary.GetSegmentAngles
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Center                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   WedgeSize                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Min                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Max                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionUIBlueprintLibrary::GetSegmentAngles(float Center, float WedgeSize, float* Min, float* Max)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIBlueprintLibrary", "GetSegmentAngles");

	Params::OrionUIBlueprintLibrary_GetSegmentAngles Parms{};

	Parms.Center = Center;
	Parms.WedgeSize = WedgeSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Min != nullptr)
		*Min = Parms.Min;

	if (Max != nullptr)
		*Max = Parms.Max;
}


// Function OrionGame.OrionUIBlueprintLibrary.GetStoreOfferFrom
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FStoreOfferBP                    Result                                                 (Parm, OutParm, NativeAccessSpecifierPublic)

void UOrionUIBlueprintLibrary::GetStoreOfferFrom(class UObject* Source, struct FStoreOfferBP* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIBlueprintLibrary", "GetStoreOfferFrom");

	Params::OrionUIBlueprintLibrary_GetStoreOfferFrom Parms{};

	Parms.Source = Source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}


// Function OrionGame.OrionUIBlueprintLibrary.GetTimespanAsSimpleText
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                        Timespan                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Text                                                   (Parm, OutParm, NativeAccessSpecifierPublic)

void UOrionUIBlueprintLibrary::GetTimespanAsSimpleText(const struct FTimespan& Timespan, class FText* Text)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIBlueprintLibrary", "GetTimespanAsSimpleText");

	Params::OrionUIBlueprintLibrary_GetTimespanAsSimpleText Parms{};

	Parms.Timespan = std::move(Timespan);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Text != nullptr)
		*Text = std::move(Parms.Text);
}


// Function OrionGame.OrionUIBlueprintLibrary.GetTwoLetterLanguageCode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UOrionUIBlueprintLibrary::GetTwoLetterLanguageCode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIBlueprintLibrary", "GetTwoLetterLanguageCode");

	Params::OrionUIBlueprintLibrary_GetTwoLetterLanguageCode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUIBlueprintLibrary.HasCommandLineParameter
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           CommandLine                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionUIBlueprintLibrary::HasCommandLineParameter(const class FString& CommandLine)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIBlueprintLibrary", "HasCommandLineParameter");

	Params::OrionUIBlueprintLibrary_HasCommandLineParameter Parms{};

	Parms.CommandLine = std::move(CommandLine);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUIBlueprintLibrary.IsConsoleBuild
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionUIBlueprintLibrary::IsConsoleBuild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIBlueprintLibrary", "IsConsoleBuild");

	Params::OrionUIBlueprintLibrary_IsConsoleBuild Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUIBlueprintLibrary.IsConsoleOpen
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionUIBlueprintLibrary::IsConsoleOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIBlueprintLibrary", "IsConsoleOpen");

	Params::OrionUIBlueprintLibrary_IsConsoleOpen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUIBlueprintLibrary.IsDemoMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionUIBlueprintLibrary::IsDemoMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIBlueprintLibrary", "IsDemoMode");

	Params::OrionUIBlueprintLibrary_IsDemoMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUIBlueprintLibrary.IsGeForceNowBuild
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionUIBlueprintLibrary::IsGeForceNowBuild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIBlueprintLibrary", "IsGeForceNowBuild");

	Params::OrionUIBlueprintLibrary_IsGeForceNowBuild Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUIBlueprintLibrary.IsInSegment
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Center                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   WedgeSize                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TestAngle                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionUIBlueprintLibrary::IsInSegment(float Center, float WedgeSize, float TestAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIBlueprintLibrary", "IsInSegment");

	Params::OrionUIBlueprintLibrary_IsInSegment Parms{};

	Parms.Center = Center;
	Parms.WedgeSize = WedgeSize;
	Parms.TestAngle = TestAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUIBlueprintLibrary.IsInWorld
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          TestObject                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionUIBlueprintLibrary::IsInWorld(class UObject* TestObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIBlueprintLibrary", "IsInWorld");

	Params::OrionUIBlueprintLibrary_IsInWorld Parms{};

	Parms.TestObject = TestObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUIBlueprintLibrary.IsMTXPaymentAllowed
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionUIBlueprintLibrary::IsMTXPaymentAllowed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIBlueprintLibrary", "IsMTXPaymentAllowed");

	Params::OrionUIBlueprintLibrary_IsMTXPaymentAllowed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUIBlueprintLibrary.IsPS4Build
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionUIBlueprintLibrary::IsPS4Build()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIBlueprintLibrary", "IsPS4Build");

	Params::OrionUIBlueprintLibrary_IsPS4Build Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUIBlueprintLibrary.IsTencentBuild
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionUIBlueprintLibrary::IsTencentBuild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIBlueprintLibrary", "IsTencentBuild");

	Params::OrionUIBlueprintLibrary_IsTencentBuild Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUIBlueprintLibrary.IsWIPUIEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionUIBlueprintLibrary::IsWIPUIEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIBlueprintLibrary", "IsWIPUIEnabled");

	Params::OrionUIBlueprintLibrary_IsWIPUIEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUIBlueprintLibrary.NotEqual_OrionPlayerStateUIID
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FOrionPlayerStateUIID            A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FOrionPlayerStateUIID            B                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionUIBlueprintLibrary::NotEqual_OrionPlayerStateUIID(const struct FOrionPlayerStateUIID& A, const struct FOrionPlayerStateUIID& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIBlueprintLibrary", "NotEqual_OrionPlayerStateUIID");

	Params::OrionUIBlueprintLibrary_NotEqual_OrionPlayerStateUIID Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUIBlueprintLibrary.OrionAffinityStructToEnum
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FOrionAffinityStruct             Authority                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EAffinityType                           First                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAffinityType                           Second                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionUIBlueprintLibrary::OrionAffinityStructToEnum(const struct FOrionAffinityStruct& Authority, EAffinityType* First, EAffinityType* Second)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIBlueprintLibrary", "OrionAffinityStructToEnum");

	Params::OrionUIBlueprintLibrary_OrionAffinityStructToEnum Parms{};

	Parms.Authority = std::move(Authority);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (First != nullptr)
		*First = Parms.First;

	if (Second != nullptr)
		*Second = Parms.Second;
}


// Function OrionGame.OrionUIBlueprintLibrary.OrionLaunchURL
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           URL                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionUIBlueprintLibrary::OrionLaunchURL(class UObject* WorldContextObject, const class FString& URL)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIBlueprintLibrary", "OrionLaunchURL");

	Params::OrionUIBlueprintLibrary_OrionLaunchURL Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.URL = std::move(URL);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUIBlueprintLibrary.OrionTBFindMemberByIndex
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FOrionTBState                    Members                                                (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FOrionTBSlotState                Result                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionUIBlueprintLibrary::OrionTBFindMemberByIndex(struct FOrionTBState& Members, int32 SlotIndex, struct FOrionTBSlotState* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIBlueprintLibrary", "OrionTBFindMemberByIndex");

	Params::OrionUIBlueprintLibrary_OrionTBFindMemberByIndex Parms{};

	Parms.Members = std::move(Members);
	Parms.SlotIndex = SlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Members = std::move(Parms.Members);

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUIBlueprintLibrary.SafePercent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ValueMax                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIfInvalidReturnOne                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOrionUIBlueprintLibrary::SafePercent(const float Value, const float ValueMax, bool bIfInvalidReturnOne)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIBlueprintLibrary", "SafePercent");

	Params::OrionUIBlueprintLibrary_SafePercent Parms{};

	Parms.Value = Value;
	Parms.ValueMax = ValueMax;
	Parms.bIfInvalidReturnOne = bIfInvalidReturnOne;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUIBlueprintLibrary.SetInputModeGameAndUI
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          WidgetToFocus                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideCursorDuringCapture                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnableParallax                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnalogCursor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionUIBlueprintLibrary::SetInputModeGameAndUI(class APlayerController* Target, class UWidget* WidgetToFocus, bool bHideCursorDuringCapture, bool bEnableParallax, bool bAnalogCursor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIBlueprintLibrary", "SetInputModeGameAndUI");

	Params::OrionUIBlueprintLibrary_SetInputModeGameAndUI Parms{};

	Parms.Target = Target;
	Parms.WidgetToFocus = WidgetToFocus;
	Parms.bHideCursorDuringCapture = bHideCursorDuringCapture;
	Parms.bEnableParallax = bEnableParallax;
	Parms.bAnalogCursor = bAnalogCursor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUIBlueprintLibrary.SetInputModeGameOnly
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionUIBlueprintLibrary::SetInputModeGameOnly(class APlayerController* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIBlueprintLibrary", "SetInputModeGameOnly");

	Params::OrionUIBlueprintLibrary_SetInputModeGameOnly Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUIBlueprintLibrary.SetInputModeUIOnly
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          WidgetToFocus                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnableParallax                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionUIBlueprintLibrary::SetInputModeUIOnly(class APlayerController* Target, class UWidget* WidgetToFocus, bool bEnableParallax)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIBlueprintLibrary", "SetInputModeUIOnly");

	Params::OrionUIBlueprintLibrary_SetInputModeUIOnly Parms{};

	Parms.Target = Target;
	Parms.WidgetToFocus = WidgetToFocus;
	Parms.bEnableParallax = bEnableParallax;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUIBlueprintLibrary.SetNeedsMouse
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNeedsMouse                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionUIBlueprintLibrary::SetNeedsMouse(class UObject* WorldContextObject, bool bNeedsMouse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIBlueprintLibrary", "SetNeedsMouse");

	Params::OrionUIBlueprintLibrary_SetNeedsMouse Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bNeedsMouse = bNeedsMouse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUIBlueprintLibrary.StatToText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EOrionStatTypes                         InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UOrionUIBlueprintLibrary::StatToText(EOrionStatTypes InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIBlueprintLibrary", "StatToText");

	Params::OrionUIBlueprintLibrary_StatToText Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUIBlueprintLibrary.SupportsHDR
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionUIBlueprintLibrary::SupportsHDR()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIBlueprintLibrary", "SupportsHDR");

	Params::OrionUIBlueprintLibrary_SupportsHDR Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUIManagerWidget.BP_RegisterInputHandlerWidget
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TScriptInterface<class IOrionInputHandlerWidget>WidgetToRegister                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// struct FKey                             InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionUIManagerWidget::BP_RegisterInputHandlerWidget(class UObject* WorldContextObject, const TScriptInterface<class IOrionInputHandlerWidget>& WidgetToRegister, const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIManagerWidget", "BP_RegisterInputHandlerWidget");

	Params::OrionUIManagerWidget_BP_RegisterInputHandlerWidget Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WidgetToRegister = WidgetToRegister;
	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUIManagerWidget.BP_UnregisterInputHandlerWidget
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TScriptInterface<class IOrionInputHandlerWidget>WidgetToUnregister                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// struct FKey                             InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionUIManagerWidget::BP_UnregisterInputHandlerWidget(class UObject* WorldContextObject, const TScriptInterface<class IOrionInputHandlerWidget>& WidgetToUnregister, const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIManagerWidget", "BP_UnregisterInputHandlerWidget");

	Params::OrionUIManagerWidget_BP_UnregisterInputHandlerWidget Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WidgetToUnregister = WidgetToUnregister;
	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUIManagerWidget.EstablishCurrentBackHandlerStack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             StackName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionUIManagerWidget::EstablishCurrentBackHandlerStack(class UObject* WorldContextObject, class FName StackName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIManagerWidget", "EstablishCurrentBackHandlerStack");

	Params::OrionUIManagerWidget_EstablishCurrentBackHandlerStack Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.StackName = StackName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUIManagerWidget.GetUIManagerWidget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionUIManagerWidget*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionUIManagerWidget* UOrionUIManagerWidget::GetUIManagerWidget(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIManagerWidget", "GetUIManagerWidget");

	Params::OrionUIManagerWidget_GetUIManagerWidget Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUIManagerWidget.HideLoadingScreen
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionUIManagerWidget::HideLoadingScreen(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIManagerWidget", "HideLoadingScreen");

	Params::OrionUIManagerWidget_HideLoadingScreen Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUIManagerWidget.HideLoadingScreenIfMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionLoadingScreenMode                 Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionUIManagerWidget::HideLoadingScreenIfMode(class UObject* WorldContextObject, EOrionLoadingScreenMode Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIManagerWidget", "HideLoadingScreenIfMode");

	Params::OrionUIManagerWidget_HideLoadingScreenIfMode Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUIManagerWidget.IsLoadingScreenVisible
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionUIManagerWidget::IsLoadingScreenVisible(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIManagerWidget", "IsLoadingScreenVisible");

	Params::OrionUIManagerWidget_IsLoadingScreenVisible Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUIManagerWidget.KillConfirmationDialog
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionUIManagerWidget::KillConfirmationDialog(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIManagerWidget", "KillConfirmationDialog");

	Params::OrionUIManagerWidget_KillConfirmationDialog Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUIManagerWidget.PlayVideo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             VideoID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionUIManagerWidget::PlayVideo(class UObject* WorldContextObject, class FName VideoID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIManagerWidget", "PlayVideo");

	Params::OrionUIManagerWidget_PlayVideo Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.VideoID = VideoID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUIManagerWidget.SetActiveTutorial
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOrionTutorial*                   Tutorial                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOverrideTutorialInProgress                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionUIManagerWidget::SetActiveTutorial(class UObject* WorldContextObject, class UOrionTutorial* Tutorial, bool bOverrideTutorialInProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIManagerWidget", "SetActiveTutorial");

	Params::OrionUIManagerWidget_SetActiveTutorial Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Tutorial = Tutorial;
	Parms.bOverrideTutorialInProgress = bOverrideTutorialInProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUIManagerWidget.ShowErrorNotification
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             DisplayMessage                                         (Parm, NativeAccessSpecifierPublic)
// bool                                    bClearExistingErrors                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionUIManagerWidget::ShowErrorNotification(class UObject* WorldContextObject, const class FText& DisplayMessage, bool bClearExistingErrors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIManagerWidget", "ShowErrorNotification");

	Params::OrionUIManagerWidget_ShowErrorNotification Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.DisplayMessage = std::move(DisplayMessage);
	Parms.bClearExistingErrors = bClearExistingErrors;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUIManagerWidget.ShowLoadingScreen
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOrionLoadingScreenMode                 Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionUIManagerWidget::ShowLoadingScreen(class UObject* WorldContextObject, EOrionLoadingScreenMode Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIManagerWidget", "ShowLoadingScreen");

	Params::OrionUIManagerWidget_ShowLoadingScreen Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUIManagerWidget.StopActiveTutorial
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UOrionTutorial>       TutorialClass                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionUIManagerWidget::StopActiveTutorial(class UObject* WorldContextObject, TSubclassOf<class UOrionTutorial> TutorialClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OrionUIManagerWidget", "StopActiveTutorial");

	Params::OrionUIManagerWidget_StopActiveTutorial Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TutorialClass = TutorialClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUIManagerWidget.AddMovingWidget
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UWidget*                          WidgetToMove                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGeometry                        SourceGeometry                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             DestinationId                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MoveDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumCopies                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CopyDelay                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovingWidgetMotion                     MotionType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SpreadAngleDegrees                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionUIManagerWidget::AddMovingWidget(class UWidget* WidgetToMove, const struct FGeometry& SourceGeometry, class FName DestinationId, float MoveDuration, int32 NumCopies, float CopyDelay, const EMovingWidgetMotion MotionType, int32 SpreadAngleDegrees)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUIManagerWidget", "AddMovingWidget");

	Params::OrionUIManagerWidget_AddMovingWidget Parms{};

	Parms.WidgetToMove = WidgetToMove;
	Parms.SourceGeometry = std::move(SourceGeometry);
	Parms.DestinationId = DestinationId;
	Parms.MoveDuration = MoveDuration;
	Parms.NumCopies = NumCopies;
	Parms.CopyDelay = CopyDelay;
	Parms.MotionType = MotionType;
	Parms.SpreadAngleDegrees = SpreadAngleDegrees;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUIManagerWidget.ClearAllMovingWidgets
// (Final, Native, Public, BlueprintCallable)

void UOrionUIManagerWidget::ClearAllMovingWidgets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUIManagerWidget", "ClearAllMovingWidgets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUIManagerWidget.FadeInWorldMusic
// (Final, Native, Public, BlueprintCallable)

void UOrionUIManagerWidget::FadeInWorldMusic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUIManagerWidget", "FadeInWorldMusic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUIManagerWidget.FadeOutWorldMusic
// (Final, Native, Public, BlueprintCallable)

void UOrionUIManagerWidget::FadeOutWorldMusic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUIManagerWidget", "FadeOutWorldMusic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUIManagerWidget.HandleEnterModalMode
// (Final, Native, Private)

void UOrionUIManagerWidget::HandleEnterModalMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUIManagerWidget", "HandleEnterModalMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUIManagerWidget.HandleExitModalMode
// (Final, Native, Private)

void UOrionUIManagerWidget::HandleExitModalMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUIManagerWidget", "HandleExitModalMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUIManagerWidget.HandleMusicChanged
// (Final, Native, Protected)

void UOrionUIManagerWidget::HandleMusicChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUIManagerWidget", "HandleMusicChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUIManagerWidget.IsModalMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionUIManagerWidget::IsModalMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUIManagerWidget", "IsModalMode");

	Params::OrionUIManagerWidget_IsModalMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUIManagerWidget.KillConfirmation
// (Final, Native, Public, BlueprintCallable)

void UOrionUIManagerWidget::KillConfirmation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUIManagerWidget", "KillConfirmation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUIManagerWidget.KillMovingWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             MovingWidgetId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionUIManagerWidget::KillMovingWidget(class FName MovingWidgetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUIManagerWidget", "KillMovingWidget");

	Params::OrionUIManagerWidget_KillMovingWidget Parms{};

	Parms.MovingWidgetId = MovingWidgetId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction OrionGame.OrionUIManagerWidget.OnEnterModalMode__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UOrionUIManagerWidget::OnEnterModalMode__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUIManagerWidget", "OnEnterModalMode__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction OrionGame.OrionUIManagerWidget.OnExitModalMode__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UOrionUIManagerWidget::OnExitModalMode__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUIManagerWidget", "OnExitModalMode__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction OrionGame.OrionUIManagerWidget.OnLoadingScreenProgressUpdated__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// float                                   LoadingPercent                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionUIManagerWidget::OnLoadingScreenProgressUpdated__DelegateSignature(float LoadingPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUIManagerWidget", "OnLoadingScreenProgressUpdated__DelegateSignature");

	Params::OrionUIManagerWidget_OnLoadingScreenProgressUpdated__DelegateSignature Parms{};

	Parms.LoadingPercent = LoadingPercent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionUIManagerWidget.OnSetMatchInfoText
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOrionUIManagerWidget::OnSetMatchInfoText(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUIManagerWidget", "OnSetMatchInfoText");

	Params::OrionUIManagerWidget_OnSetMatchInfoText Parms{};

	Parms.InText = std::move(InText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionUIManagerWidget.OnSetMatchInfoVisibility
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionUIManagerWidget::OnSetMatchInfoVisibility(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUIManagerWidget", "OnSetMatchInfoVisibility");

	Params::OrionUIManagerWidget_OnSetMatchInfoVisibility Parms{};

	Parms.bVisible = bVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionUIManagerWidget.OnShowError
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FOrionDialogDescription          Description                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOrionUIManagerWidget::OnShowError(const struct FOrionDialogDescription& Description)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUIManagerWidget", "OnShowError");

	Params::OrionUIManagerWidget_OnShowError Parms{};

	Parms.Description = std::move(Description);

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction OrionGame.OrionUIManagerWidget.OnShowPreMatchLoadingScreen__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UOrionUIManagerWidget::OnShowPreMatchLoadingScreen__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUIManagerWidget", "OnShowPreMatchLoadingScreen__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionUIManagerWidget.OnStateTransitionComplete
// (Event, Protected, BlueprintEvent)

void UOrionUIManagerWidget::OnStateTransitionComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUIManagerWidget", "OnStateTransitionComplete");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionUIManagerWidget.RouteBackAction
// (Final, Native, Private)

void UOrionUIManagerWidget::RouteBackAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUIManagerWidget", "RouteBackAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUIManagerWidget.SetStateContentDisplayed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDisplay                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionUIManagerWidget::SetStateContentDisplayed(bool bDisplay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUIManagerWidget", "SetStateContentDisplayed");

	Params::OrionUIManagerWidget_SetStateContentDisplayed Parms{};

	Parms.bDisplay = bDisplay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUIManagerWidget.ShowModalContent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UOrionActivatableWidget*          ActivatableContent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionUIManagerWidget::ShowModalContent(class UOrionActivatableWidget* ActivatableContent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUIManagerWidget", "ShowModalContent");

	Params::OrionUIManagerWidget_ShowModalContent Parms{};

	Parms.ActivatableContent = ActivatableContent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUIManagerWidget.BP_GetCurrentUIStateWidget
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UOrionUIStateWidget*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrionUIStateWidget* UOrionUIManagerWidget::BP_GetCurrentUIStateWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUIManagerWidget", "BP_GetCurrentUIStateWidget");

	Params::OrionUIManagerWidget_BP_GetCurrentUIStateWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUIManagerWidget.GetCurrentUIState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionUIState                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOrionUIState UOrionUIManagerWidget::GetCurrentUIState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUIManagerWidget", "GetCurrentUIState");

	Params::OrionUIManagerWidget_GetCurrentUIState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUIManagerWidget.IsStateContentDisplayed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionUIManagerWidget::IsStateContentDisplayed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUIManagerWidget", "IsStateContentDisplayed");

	Params::OrionUIManagerWidget_IsStateContentDisplayed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUIStateWidget.OnEnterState
// (Event, Protected, BlueprintEvent)

void UOrionUIStateWidget::OnEnterState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUIStateWidget", "OnEnterState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionUIStateWidget.OnExitState
// (Event, Protected, BlueprintEvent)

void UOrionUIStateWidget::OnExitState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUIStateWidget", "OnExitState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionUIStateWidget.UpdateButtonLegend
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FButtonLegendItem>        LegendSource                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UOrionUIStateWidget::UpdateButtonLegend(const TArray<struct FButtonLegendItem>& LegendSource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUIStateWidget", "UpdateButtonLegend");

	Params::OrionUIStateWidget_UpdateButtonLegend Parms{};

	Parms.LegendSource = std::move(LegendSource);

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionUIStateWidget.IsReadyForNextState
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOrionUIStateWidget::IsReadyForNextState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUIStateWidget", "IsReadyForNextState");

	Params::OrionUIStateWidget_IsReadyForNextState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUserWidget_GameEventMessage.MessageIsFinished
// (Final, Native, Public, BlueprintCallable)

void UOrionUserWidget_GameEventMessage::MessageIsFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUserWidget_GameEventMessage", "MessageIsFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUserWidget_GameEventMessage.PlayMessage
// (Event, Public, BlueprintEvent)

void UOrionUserWidget_GameEventMessage::PlayMessage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUserWidget_GameEventMessage", "PlayMessage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionUserWidget_GameEventMessage.GetEnemyTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionTeam                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOrionTeam UOrionUserWidget_GameEventMessage::GetEnemyTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUserWidget_GameEventMessage", "GetEnemyTeam");

	Params::OrionUserWidget_GameEventMessage_GetEnemyTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionUserWidget_GameEventMessage.GetMyTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionTeam                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOrionTeam UOrionUserWidget_GameEventMessage::GetMyTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUserWidget_GameEventMessage", "GetMyTeam");

	Params::OrionUserWidget_GameEventMessage_GetMyTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionGameEventMessageContainer.AddNewGameEventMessage
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FOrionGameEventMessageData       NewMessageData                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOrionGameEventMessageContainer::AddNewGameEventMessage(const struct FOrionGameEventMessageData& NewMessageData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionGameEventMessageContainer", "AddNewGameEventMessage");

	Params::OrionGameEventMessageContainer_AddNewGameEventMessage Parms{};

	Parms.NewMessageData = std::move(NewMessageData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUserWidget_Reticle.OnSuccesfulHit
// (Final, Native, Protected)

void UOrionUserWidget_Reticle::OnSuccesfulHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUserWidget_Reticle", "OnSuccesfulHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionUserWidget_Reticle.OnTargetingUpdate
// (Final, Native, Protected)
// Parameters:
// bool                                    bIsTargeting                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionUserWidget_Reticle::OnTargetingUpdate(bool bIsTargeting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionUserWidget_Reticle", "OnTargetingUpdate");

	Params::OrionUserWidget_Reticle_OnTargetingUpdate Parms{};

	Parms.bIsTargeting = bIsTargeting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionVisionManager2.MulticastDebugLog
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// TArray<class FString>                   Strs                                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AOrionVisionManager2::MulticastDebugLog(const TArray<class FString>& Strs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionVisionManager2", "MulticastDebugLog");

	Params::OrionVisionManager2_MulticastDebugLog Parms{};

	Parms.Strs = std::move(Strs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionVisionManager2.OnRep_ReplicatedDebugDump
// (Final, Native, Public)

void AOrionVisionManager2::OnRep_ReplicatedDebugDump()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionVisionManager2", "OnRep_ReplicatedDebugDump");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionVisionManager2.OnRep_VisionDataOverrides
// (Final, Native, Protected)

void AOrionVisionManager2::OnRep_VisionDataOverrides()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionVisionManager2", "OnRep_VisionDataOverrides");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionVisionSet.OnRep_VisionRadius
// (Final, Native, Public)

void UOrionVisionSet::OnRep_VisionRadius()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionVisionSet", "OnRep_VisionRadius");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionVisionWard.HandleTrackedHeroDeath
// (Final, Native, Protected)
// Parameters:
// class AOrionChar*                       DeadChar                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      Killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionVisionWard::HandleTrackedHeroDeath(class AOrionChar* DeadChar, class AController* Killer, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionVisionWard", "HandleTrackedHeroDeath");

	Params::OrionVisionWard_HandleTrackedHeroDeath Parms{};

	Parms.DeadChar = DeadChar;
	Parms.Killer = Killer;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionVisionWard.OnPlayerSightedPing
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           SightedPlayer                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionVisionWard::OnPlayerSightedPing(class AActor* SightedPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionVisionWard", "OnPlayerSightedPing");

	Params::OrionVisionWard_OnPlayerSightedPing Parms{};

	Parms.SightedPlayer = SightedPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionVisionWard.OnVisionWardTimedOut
// (Event, Protected, BlueprintEvent)

void AOrionVisionWard::OnVisionWardTimedOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionVisionWard", "OnVisionWardTimedOut");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionVisionWard.GetLifeSpanPercentage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionVisionWard::GetLifeSpanPercentage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionVisionWard", "GetLifeSpanPercentage");

	Params::OrionVisionWard_GetLifeSpanPercentage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionWell_Base.DetachRig
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AOrionRigs*                       RigToRemove                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionWell_Base::DetachRig(class AOrionRigs* RigToRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionWell_Base", "DetachRig");

	Params::OrionWell_Base_DetachRig Parms{};

	Parms.RigToRemove = RigToRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionWell_Base.ForceWellToState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionWellState                         NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionWell_Base::ForceWellToState(EOrionWellState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionWell_Base", "ForceWellToState");

	Params::OrionWell_Base_ForceWellToState Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionWell_Base.GetAttachedRig
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AOrionRigs*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOrionRigs* AOrionWell_Base::GetAttachedRig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionWell_Base", "GetAttachedRig");

	Params::OrionWell_Base_GetAttachedRig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionWell_Base.GetCurrentWellState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionWellState                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOrionWellState AOrionWell_Base::GetCurrentWellState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionWell_Base", "GetCurrentWellState");

	Params::OrionWell_Base_GetCurrentWellState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionWell_Base.GetPlayerThatPlacedRig
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AOrionPlayerState_Game*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOrionPlayerState_Game* AOrionWell_Base::GetPlayerThatPlacedRig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionWell_Base", "GetPlayerThatPlacedRig");

	Params::OrionWell_Base_GetPlayerThatPlacedRig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionWell_Base.GetResourcePercent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionWell_Base::GetResourcePercent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionWell_Base", "GetResourcePercent");

	Params::OrionWell_Base_GetResourcePercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionWell_Base.GetRigAttachLocation
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AOrionWell_Base::GetRigAttachLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionWell_Base", "GetRigAttachLocation");

	Params::OrionWell_Base_GetRigAttachLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionWell_Base.GetRigAttachRotaion
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator AOrionWell_Base::GetRigAttachRotaion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionWell_Base", "GetRigAttachRotaion");

	Params::OrionWell_Base_GetRigAttachRotaion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionWell_Base.GetRigBoostedScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionWell_Base::GetRigBoostedScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionWell_Base", "GetRigBoostedScale");

	Params::OrionWell_Base_GetRigBoostedScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionWell_Base.HandleMatchStarted
// (Native, Event, Protected, BlueprintEvent)

void AOrionWell_Base::HandleMatchStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionWell_Base", "HandleMatchStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionWell_Base.K2_IsRigPlaced
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionWell_Base::K2_IsRigPlaced()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionWell_Base", "K2_IsRigPlaced");

	Params::OrionWell_Base_K2_IsRigPlaced Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionWell_Base.OnAttachRig
// (Event, Public, BlueprintEvent)
// Parameters:
// class AOrionRigs*                       NewAttachedRig                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionWell_Base::OnAttachRig(class AOrionRigs* NewAttachedRig)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionWell_Base", "OnAttachRig");

	Params::OrionWell_Base_OnAttachRig Parms{};

	Parms.NewAttachedRig = NewAttachedRig;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.OrionWell_Base.OnDetachRig
// (Event, Public, BlueprintEvent)

void AOrionWell_Base::OnDetachRig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionWell_Base", "OnDetachRig");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.OrionWell_Base.OnOverlapBegin
// (Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AOrionWell_Base::OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionWell_Base", "OnOverlapBegin");

	Params::OrionWell_Base_OnOverlapBegin Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionWell_Base.OnOverlapEnd
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionWell_Base::OnOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionWell_Base", "OnOverlapEnd");

	Params::OrionWell_Base_OnOverlapEnd Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionWell_Base.OnRep_InteractingHeroPawn
// (Final, Native, Protected)

void AOrionWell_Base::OnRep_InteractingHeroPawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionWell_Base", "OnRep_InteractingHeroPawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionWell_Base.OnRep_PlacedRig
// (Final, Native, Protected)

void AOrionWell_Base::OnRep_PlacedRig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionWell_Base", "OnRep_PlacedRig");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionWell_Base.OnRep_StateTimers
// (Final, Native, Protected)

void AOrionWell_Base::OnRep_StateTimers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionWell_Base", "OnRep_StateTimers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionWell_Base.OnRep_WellStateUpdate
// (Native, Protected)
// Parameters:
// EOrionWellState                         OldState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionWell_Base::OnRep_WellStateUpdate(EOrionWellState OldState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionWell_Base", "OnRep_WellStateUpdate");

	Params::OrionWell_Base_OnRep_WellStateUpdate Parms{};

	Parms.OldState = OldState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionWell_Base.PlaceRig
// (Final, Native, Protected)

void AOrionWell_Base::PlaceRig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionWell_Base", "PlaceRig");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionWell_Base.RanDry
// (Final, Native, Public, BlueprintCallable)

void AOrionWell_Base::RanDry()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionWell_Base", "RanDry");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionWell_Base.ShowRigGatherAmount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   AmountGathered                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionWell_Base::ShowRigGatherAmount(float AmountGathered)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionWell_Base", "ShowRigGatherAmount");

	Params::OrionWell_Base_ShowRigGatherAmount Parms{};

	Parms.AmountGathered = AmountGathered;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionWell_Base.StartCollectingFromRig
// (Final, Native, Protected)

void AOrionWell_Base::StartCollectingFromRig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionWell_Base", "StartCollectingFromRig");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionWell_Base.UpdateCollectionPadOverlaps
// (Final, Native, Protected)
// Parameters:
// class AActor*                           InActorToUpdate                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOrionWell_Base::UpdateCollectionPadOverlaps(class AActor* InActorToUpdate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionWell_Base", "UpdateCollectionPadOverlaps");

	Params::OrionWell_Base_UpdateCollectionPadOverlaps Parms{};

	Parms.InActorToUpdate = InActorToUpdate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionWell_Base.GetMaxResource
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionWell_Base::GetMaxResource() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionWell_Base", "GetMaxResource");

	Params::OrionWell_Base_GetMaxResource Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionWell_Base.GetRemainingDeadZoneTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionWell_Base::GetRemainingDeadZoneTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionWell_Base", "GetRemainingDeadZoneTime");

	Params::OrionWell_Base_GetRemainingDeadZoneTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionWell_Base.GetRemainingInitalSpawnDelay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionWell_Base::GetRemainingInitalSpawnDelay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionWell_Base", "GetRemainingInitalSpawnDelay");

	Params::OrionWell_Base_GetRemainingInitalSpawnDelay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionWell_Base.GetResource
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionWell_Base::GetResource() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionWell_Base", "GetResource");

	Params::OrionWell_Base_GetResource Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionWell_Base.GetWellActiveTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionWell_Base::GetWellActiveTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionWell_Base", "GetWellActiveTime");

	Params::OrionWell_Base_GetWellActiveTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionWell_Base.GetWellDeadZoneTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionWell_Base::GetWellDeadZoneTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionWell_Base", "GetWellDeadZoneTime");

	Params::OrionWell_Base_GetWellDeadZoneTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionWell_Base.GetWellGeyserTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionWell_Base::GetWellGeyserTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionWell_Base", "GetWellGeyserTime");

	Params::OrionWell_Base_GetWellGeyserTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionWell_Base.GetWellInitalSpawnDelay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOrionWell_Base::GetWellInitalSpawnDelay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionWell_Base", "GetWellInitalSpawnDelay");

	Params::OrionWell_Base_GetWellInitalSpawnDelay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionWell_Base.IsActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOrionWell_Base::IsActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionWell_Base", "IsActive");

	Params::OrionWell_Base_IsActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.OrionWidget_HUDIndicatorOverlay.DynamicHandleHUDSettingsChanged
// (Final, Native, Protected)

void UOrionWidget_HUDIndicatorOverlay::DynamicHandleHUDSettingsChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionWidget_HUDIndicatorOverlay", "DynamicHandleHUDSettingsChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.OrionWidget_HUDIndicatorOverlay.SetLocalPlayerController
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                LocalPlayerController                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOrionWidget_HUDIndicatorOverlay::SetLocalPlayerController(class APlayerController* LocalPlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OrionWidget_HUDIndicatorOverlay", "SetLocalPlayerController");

	Params::OrionWidget_HUDIndicatorOverlay_SetLocalPlayerController Parms{};

	Parms.LocalPlayerController = LocalPlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.PlayerBotSpawner.HandleMatchStarted
// (Final, Native, Protected)

void APlayerBotSpawner::HandleMatchStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerBotSpawner", "HandleMatchStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.PlayerBotSpawner.SetPosition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrionPosition                          InPosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerBotSpawner::SetPosition(EOrionPosition InPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerBotSpawner", "SetPosition");

	Params::PlayerBotSpawner_SetPosition Parms{};

	Parms.InPosition = InPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.PlayerBotSpawner.Spawn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AOrionAIBot*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOrionAIBot* APlayerBotSpawner::Spawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerBotSpawner", "Spawn");

	Params::PlayerBotSpawner_Spawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.PlayerBotSpawner.GetTeamNum
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOrionTeam                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOrionTeam APlayerBotSpawner::GetTeamNum() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerBotSpawner", "GetTeamNum");

	Params::PlayerBotSpawner_GetTeamNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.ScalableFloatUtils.GetValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FScalableFloat                   Input                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UScalableFloatUtils::GetValue(const struct FScalableFloat& Input)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ScalableFloatUtils", "GetValue");

	Params::ScalableFloatUtils_GetValue Parms{};

	Parms.Input = std::move(Input);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.ScalableFloatUtils.GetValueAtLevel
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FScalableFloat                   Input                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UScalableFloatUtils::GetValueAtLevel(const struct FScalableFloat& Input, float Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ScalableFloatUtils", "GetValueAtLevel");

	Params::ScalableFloatUtils_GetValueAtLevel Parms{};

	Parms.Input = std::move(Input);
	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.ScalableFloatUtils.IsStatic
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FScalableFloat                   Input                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UScalableFloatUtils::IsStatic(const struct FScalableFloat& Input)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ScalableFloatUtils", "IsStatic");

	Params::ScalableFloatUtils_IsStatic Parms{};

	Parms.Input = std::move(Input);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.ScalableFloatUtils.SetScalingValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FScalableFloat                   Input                                                  (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   InCoeffecient                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InRowName                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveTable*                      InTable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScalableFloatUtils::SetScalingValue(struct FScalableFloat& Input, float InCoeffecient, const class FName InRowName, class UCurveTable* InTable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ScalableFloatUtils", "SetScalingValue");

	Params::ScalableFloatUtils_SetScalingValue Parms{};

	Parms.Input = std::move(Input);
	Parms.InCoeffecient = InCoeffecient;
	Parms.InRowName = InRowName;
	Parms.InTable = InTable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Input = std::move(Parms.Input);
}


// Function OrionGame.ScalableFloatUtils.SetValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FScalableFloat                   Input                                                  (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScalableFloatUtils::SetValue(struct FScalableFloat& Input, float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ScalableFloatUtils", "SetValue");

	Params::ScalableFloatUtils_SetValue Parms{};

	Parms.Input = std::move(Input);
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Input = std::move(Parms.Input);
}


// Function OrionGame.ScalableFloatUtils.ToSimpleString
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FScalableFloat                   Input                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UScalableFloatUtils::ToSimpleString(const struct FScalableFloat& Input)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ScalableFloatUtils", "ToSimpleString");

	Params::ScalableFloatUtils_ToSimpleString Parms{};

	Parms.Input = std::move(Input);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function OrionGame.TeamCommunicationsActor.Blueprint_StartHidingBeforeDestroy
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bIsOwningPlayer                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATeamCommunicationsActor::Blueprint_StartHidingBeforeDestroy(bool bIsOwningPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamCommunicationsActor", "Blueprint_StartHidingBeforeDestroy");

	Params::TeamCommunicationsActor_Blueprint_StartHidingBeforeDestroy Parms{};

	Parms.bIsOwningPlayer = bIsOwningPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.TeamCommunicationsActor.HideMiniMapIcon
// (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)

void ATeamCommunicationsActor::HideMiniMapIcon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamCommunicationsActor", "HideMiniMapIcon");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.TeamCommunicationsActor.HideVisuals
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bIsOwningPlayer                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATeamCommunicationsActor::HideVisuals(bool bIsOwningPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamCommunicationsActor", "HideVisuals");

	Params::TeamCommunicationsActor_HideVisuals Parms{};

	Parms.bIsOwningPlayer = bIsOwningPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.TeamCommunicationsActor.HideVisualsImmediately
// (Event, Public, BlueprintEvent)

void ATeamCommunicationsActor::HideVisualsImmediately()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamCommunicationsActor", "HideVisualsImmediately");

	UObject::ProcessEvent(Func, nullptr);
}


// Function OrionGame.TeamCommunicationsActor.ShowVisuals
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bIsOwningPlayer                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATeamCommunicationsActor::ShowVisuals(bool bIsOwningPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamCommunicationsActor", "ShowVisuals");

	Params::TeamCommunicationsActor_ShowVisuals Parms{};

	Parms.bIsOwningPlayer = bIsOwningPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function OrionGame.TeamCommunicationsActor.StartHidingBeforeDestroy
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ATeamCommunicationsActor::StartHidingBeforeDestroy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamCommunicationsActor", "StartHidingBeforeDestroy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.TimeAgoLibrary.RefreshTime
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTimeAgo                         TimeAgo                                                (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FDateTime                        InTimepoint                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimeAgoLibrary::RefreshTime(struct FTimeAgo& TimeAgo, const struct FDateTime& InTimepoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TimeAgoLibrary", "RefreshTime");

	Params::TimeAgoLibrary_RefreshTime Parms{};

	Parms.TimeAgo = std::move(TimeAgo);
	Parms.InTimepoint = std::move(InTimepoint);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	TimeAgo = std::move(Parms.TimeAgo);
}


// Function OrionGame.TimeAgoLibrary.RegisterEditableText
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTimeAgo                         TimeAgo                                                (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UMultiLineEditableText*           InEditableText                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                        InTimepoint                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimeAgoLibrary::RegisterEditableText(struct FTimeAgo& TimeAgo, class UMultiLineEditableText* InEditableText, const struct FDateTime& InTimepoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TimeAgoLibrary", "RegisterEditableText");

	Params::TimeAgoLibrary_RegisterEditableText Parms{};

	Parms.TimeAgo = std::move(TimeAgo);
	Parms.InEditableText = InEditableText;
	Parms.InTimepoint = std::move(InTimepoint);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	TimeAgo = std::move(Parms.TimeAgo);
}


// Function OrionGame.TimeAgoLibrary.RegisterText
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTimeAgo                         TimeAgo                                                (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UTextBlock*                       InTextBlock                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                        InTimepoint                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimeAgoLibrary::RegisterText(struct FTimeAgo& TimeAgo, class UTextBlock* InTextBlock, const struct FDateTime& InTimepoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TimeAgoLibrary", "RegisterText");

	Params::TimeAgoLibrary_RegisterText Parms{};

	Parms.TimeAgo = std::move(TimeAgo);
	Parms.InTextBlock = InTextBlock;
	Parms.InTimepoint = std::move(InTimepoint);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	TimeAgo = std::move(Parms.TimeAgo);
}


// Function OrionGame.TimeAgoLibrary.RegisterTextBox
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTimeAgo                         TimeAgo                                                (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UMultiLineEditableTextBox*        InEditableTextBox                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                        InTimepoint                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimeAgoLibrary::RegisterTextBox(struct FTimeAgo& TimeAgo, class UMultiLineEditableTextBox* InEditableTextBox, const struct FDateTime& InTimepoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TimeAgoLibrary", "RegisterTextBox");

	Params::TimeAgoLibrary_RegisterTextBox Parms{};

	Parms.TimeAgo = std::move(TimeAgo);
	Parms.InEditableTextBox = InEditableTextBox;
	Parms.InTimepoint = std::move(InTimepoint);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	TimeAgo = std::move(Parms.TimeAgo);
}


// Function OrionGame.WidgetStack.Clear
// (Final, Native, Public, BlueprintCallable)

void UWidgetStack::Clear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetStack", "Clear");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.WidgetStack.PopWidget
// (Final, Native, Public, BlueprintCallable)

void UWidgetStack::PopWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetStack", "PopWidget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.WidgetStack.PushWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                          InWidget                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetStack::PushWidget(class UWidget* InWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetStack", "PushWidget");

	Params::WidgetStack_PushWidget Parms{};

	Parms.InWidget = InWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function OrionGame.WidgetStack.NumWidgets
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UWidgetStack::NumWidgets() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetStack", "NumWidgets");

	Params::WidgetStack_NumWidgets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

