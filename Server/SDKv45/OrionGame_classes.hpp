#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: OrionGame

#include "Basic.hpp"

#include "Party_structs.hpp"
#include "Party_classes.hpp"
#include "OrionGame_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "OnlineSubsystemUtils_classes.hpp"
#include "GameplayAbilities_structs.hpp"
#include "GameplayAbilities_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "FunctionalTesting_structs.hpp"
#include "FunctionalTesting_classes.hpp"
#include "BlueprintContext_structs.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "SlateCore_structs.hpp"
#include "UMG_classes.hpp"
#include "McpProfileSys_structs.hpp"
#include "McpProfileSys_classes.hpp"
#include "GameplayTasks_classes.hpp"
#include "AmbientEvents_classes.hpp"
#include "InputCore_structs.hpp"
#include "ClientPilot_classes.hpp"
#include "Hotfix_structs.hpp"
#include "Hotfix_classes.hpp"
#include "Slate_structs.hpp"
#include "Account_classes.hpp"
#include "Rejoin_classes.hpp"
#include "SignificanceManager_classes.hpp"
#include "Social_structs.hpp"
#include "Gauntlet_classes.hpp"


namespace SDK
{

// Class OrionGame.FunctionalTestPhase
// 0x0030 (0x0058 - 0x0028)
class UFunctionalTestPhase : public UObject
{
public:
	EFunctionalTestResult                         SetupStatus;                                       // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFunctionalTestResult                         ExecuteStatus;                                     // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFunctionalTestResult                         CleanupStatus;                                     // 0x002A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           SetupTimer;                                        // 0x0030(0x0008)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FTimerHandle                           ExecuteTimer;                                      // 0x0038(0x0008)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FTimerHandle                           CleanupTimer;                                      // 0x0040(0x0008)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SetupTimeout;                                      // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExecuteTimeout;                                    // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CleanupTimeout;                                    // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cleanup();
	void CleanupHook();
	void ClearTimeouts();
	void Execute();
	void ExecuteHook();
	EFunctionalTestResult GetCleanupStatus();
	EFunctionalTestResult GetExecuteStatus();
	EFunctionalTestResult GetSetupStatus();
	class APhasedFunctionalTest* GetTest();
	bool HasEncounteredError();
	bool HasFailed();
	bool IsCleanupFinished();
	bool IsExecuteFinished();
	bool IsPhaseRunningInEditor();
	bool IsSetupFinished();
	void LogError(const class FString& MESSAGE);
	void LogInfo(const class FString& MESSAGE);
	void LogVerbose(const class FString& MESSAGE);
	void LogWarning(const class FString& MESSAGE);
	void OnCleanupTimedOut();
	void OnExecuteTimedOut();
	void OnSetupTimedOut();
	void Reset();
	void ResetHook();
	void SetCleanupStatus(EFunctionalTestResult Status);
	void SetExecuteStatus(EFunctionalTestResult Status);
	void SetSetupStatus(EFunctionalTestResult Status);
	void Setup();
	void SetupHook();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FunctionalTestPhase">();
	}
	static class UFunctionalTestPhase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFunctionalTestPhase>();
	}
};
static_assert(alignof(UFunctionalTestPhase) == 0x000008, "Wrong alignment on UFunctionalTestPhase");
static_assert(sizeof(UFunctionalTestPhase) == 0x000058, "Wrong size on UFunctionalTestPhase");
static_assert(offsetof(UFunctionalTestPhase, SetupStatus) == 0x000028, "Member 'UFunctionalTestPhase::SetupStatus' has a wrong offset!");
static_assert(offsetof(UFunctionalTestPhase, ExecuteStatus) == 0x000029, "Member 'UFunctionalTestPhase::ExecuteStatus' has a wrong offset!");
static_assert(offsetof(UFunctionalTestPhase, CleanupStatus) == 0x00002A, "Member 'UFunctionalTestPhase::CleanupStatus' has a wrong offset!");
static_assert(offsetof(UFunctionalTestPhase, SetupTimer) == 0x000030, "Member 'UFunctionalTestPhase::SetupTimer' has a wrong offset!");
static_assert(offsetof(UFunctionalTestPhase, ExecuteTimer) == 0x000038, "Member 'UFunctionalTestPhase::ExecuteTimer' has a wrong offset!");
static_assert(offsetof(UFunctionalTestPhase, CleanupTimer) == 0x000040, "Member 'UFunctionalTestPhase::CleanupTimer' has a wrong offset!");
static_assert(offsetof(UFunctionalTestPhase, SetupTimeout) == 0x000048, "Member 'UFunctionalTestPhase::SetupTimeout' has a wrong offset!");
static_assert(offsetof(UFunctionalTestPhase, ExecuteTimeout) == 0x00004C, "Member 'UFunctionalTestPhase::ExecuteTimeout' has a wrong offset!");
static_assert(offsetof(UFunctionalTestPhase, CleanupTimeout) == 0x000050, "Member 'UFunctionalTestPhase::CleanupTimeout' has a wrong offset!");

// Class OrionGame.FTS_ExecuteAbility
// 0x0130 (0x0188 - 0x0058)
class UFTS_ExecuteAbility final : public UFunctionalTestPhase
{
public:
	EFTestActorKey                                ExecutingTestActorKey;                             // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCustomKey;                                     // 0x0059(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomKey;                                         // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAutomationAbilityActivationType              ActivationType;                                    // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionAbilityBinding                          AbilityKey;                                        // 0x0071(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x2];                                       // 0x0072(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PressHoldTime;                                     // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostReleaseWaitTime;                               // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostConfirmWaitTime;                               // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostCancelWaitTime;                                // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x104];                                     // 0x0084(0x0104)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnExecuteTimedOut_Implementation();
	void SetNextExecutionStep();
	void WaitTimerFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FTS_ExecuteAbility">();
	}
	static class UFTS_ExecuteAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFTS_ExecuteAbility>();
	}
};
static_assert(alignof(UFTS_ExecuteAbility) == 0x000008, "Wrong alignment on UFTS_ExecuteAbility");
static_assert(sizeof(UFTS_ExecuteAbility) == 0x000188, "Wrong size on UFTS_ExecuteAbility");
static_assert(offsetof(UFTS_ExecuteAbility, ExecutingTestActorKey) == 0x000058, "Member 'UFTS_ExecuteAbility::ExecutingTestActorKey' has a wrong offset!");
static_assert(offsetof(UFTS_ExecuteAbility, bUseCustomKey) == 0x000059, "Member 'UFTS_ExecuteAbility::bUseCustomKey' has a wrong offset!");
static_assert(offsetof(UFTS_ExecuteAbility, CustomKey) == 0x000060, "Member 'UFTS_ExecuteAbility::CustomKey' has a wrong offset!");
static_assert(offsetof(UFTS_ExecuteAbility, ActivationType) == 0x000070, "Member 'UFTS_ExecuteAbility::ActivationType' has a wrong offset!");
static_assert(offsetof(UFTS_ExecuteAbility, AbilityKey) == 0x000071, "Member 'UFTS_ExecuteAbility::AbilityKey' has a wrong offset!");
static_assert(offsetof(UFTS_ExecuteAbility, PressHoldTime) == 0x000074, "Member 'UFTS_ExecuteAbility::PressHoldTime' has a wrong offset!");
static_assert(offsetof(UFTS_ExecuteAbility, PostReleaseWaitTime) == 0x000078, "Member 'UFTS_ExecuteAbility::PostReleaseWaitTime' has a wrong offset!");
static_assert(offsetof(UFTS_ExecuteAbility, PostConfirmWaitTime) == 0x00007C, "Member 'UFTS_ExecuteAbility::PostConfirmWaitTime' has a wrong offset!");
static_assert(offsetof(UFTS_ExecuteAbility, PostCancelWaitTime) == 0x000080, "Member 'UFTS_ExecuteAbility::PostCancelWaitTime' has a wrong offset!");

// Class OrionGame.AITeamComm
// 0x0040 (0x0068 - 0x0028)
class UAITeamComm final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAICommander*                      AICommander;                                       // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UPCTeamCommunicationsData*>      CommDatas;                                         // 0x0050(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void RequestAITeamComm(const class AOrionAIBot* BotController, const EAITeamCommEvent Event, const bool bIgnoreTimeouts, const float TriggerDelay);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AITeamComm">();
	}
	static class UAITeamComm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAITeamComm>();
	}
};
static_assert(alignof(UAITeamComm) == 0x000008, "Wrong alignment on UAITeamComm");
static_assert(sizeof(UAITeamComm) == 0x000068, "Wrong size on UAITeamComm");
static_assert(offsetof(UAITeamComm, AICommander) == 0x000048, "Member 'UAITeamComm::AICommander' has a wrong offset!");
static_assert(offsetof(UAITeamComm, CommDatas) == 0x000050, "Member 'UAITeamComm::CommDatas' has a wrong offset!");

// Class OrionGame.FunctionalTestCondition
// 0x0030 (0x0058 - 0x0028)
class UFunctionalTestCondition : public UObject
{
public:
	class FString                                 TestCaseSummary;                                   // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldOccur;                                      // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x1F];                                      // 0x0039(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class APhasedFunctionalTest* GetTest();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FunctionalTestCondition">();
	}
	static class UFunctionalTestCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFunctionalTestCondition>();
	}
};
static_assert(alignof(UFunctionalTestCondition) == 0x000008, "Wrong alignment on UFunctionalTestCondition");
static_assert(sizeof(UFunctionalTestCondition) == 0x000058, "Wrong size on UFunctionalTestCondition");
static_assert(offsetof(UFunctionalTestCondition, TestCaseSummary) == 0x000028, "Member 'UFunctionalTestCondition::TestCaseSummary' has a wrong offset!");
static_assert(offsetof(UFunctionalTestCondition, bShouldOccur) == 0x000038, "Member 'UFunctionalTestCondition::bShouldOccur' has a wrong offset!");

// Class OrionGame.FTC_Test
// 0x0028 (0x0080 - 0x0058)
class UFTC_Test final : public UFunctionalTestCondition
{
public:
	bool                                          bValidatePass;                                     // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PreValidateTimer;                                  // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEvaluatePass;                                     // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PreEvaluateTimer;                                  // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x18];                                      // 0x0068(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AllowEvaluate();
	void AllowValidate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FTC_Test">();
	}
	static class UFTC_Test* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFTC_Test>();
	}
};
static_assert(alignof(UFTC_Test) == 0x000008, "Wrong alignment on UFTC_Test");
static_assert(sizeof(UFTC_Test) == 0x000080, "Wrong size on UFTC_Test");
static_assert(offsetof(UFTC_Test, bValidatePass) == 0x000058, "Member 'UFTC_Test::bValidatePass' has a wrong offset!");
static_assert(offsetof(UFTC_Test, PreValidateTimer) == 0x00005C, "Member 'UFTC_Test::PreValidateTimer' has a wrong offset!");
static_assert(offsetof(UFTC_Test, bEvaluatePass) == 0x000060, "Member 'UFTC_Test::bEvaluatePass' has a wrong offset!");
static_assert(offsetof(UFTC_Test, PreEvaluateTimer) == 0x000064, "Member 'UFTC_Test::PreEvaluateTimer' has a wrong offset!");

// Class OrionGame.AIInfluenceSourceComponent
// 0x0010 (0x0100 - 0x00F0)
class UAIInfluenceSourceComponent final : public UActorComponent
{
public:
	float                                         FullInfluenceRadius;                               // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x00F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIActorClassification                        SourceType;                                        // 0x00F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_SetInfluenceValues(float Radius, float InStrength);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIInfluenceSourceComponent">();
	}
	static class UAIInfluenceSourceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIInfluenceSourceComponent>();
	}
};
static_assert(alignof(UAIInfluenceSourceComponent) == 0x000008, "Wrong alignment on UAIInfluenceSourceComponent");
static_assert(sizeof(UAIInfluenceSourceComponent) == 0x000100, "Wrong size on UAIInfluenceSourceComponent");
static_assert(offsetof(UAIInfluenceSourceComponent, FullInfluenceRadius) == 0x0000F0, "Member 'UAIInfluenceSourceComponent::FullInfluenceRadius' has a wrong offset!");
static_assert(offsetof(UAIInfluenceSourceComponent, Strength) == 0x0000F4, "Member 'UAIInfluenceSourceComponent::Strength' has a wrong offset!");
static_assert(offsetof(UAIInfluenceSourceComponent, SourceType) == 0x0000F8, "Member 'UAIInfluenceSourceComponent::SourceType' has a wrong offset!");

// Class OrionGame.GameModeCommon_Base
// 0x0048 (0x0440 - 0x03F8)
class AGameModeCommon_Base : public AGameMode
{
public:
	class AGameSessionCommon*                     GameSessionCommon;                                 // 0x03F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 GameModeSessionString;                             // 0x0400(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FailsafeServerRestartTimer;                        // 0x0410(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GameplayServerHitchThreshold;                      // 0x0414(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementTimeDiscrepancyHitchCooldown;              // 0x0418(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInitReservationBeacon;                            // 0x041C(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41D[0x23];                                     // 0x041D(0x0023)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameModeCommon_Base">();
	}
	static class AGameModeCommon_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameModeCommon_Base>();
	}
};
static_assert(alignof(AGameModeCommon_Base) == 0x000008, "Wrong alignment on AGameModeCommon_Base");
static_assert(sizeof(AGameModeCommon_Base) == 0x000440, "Wrong size on AGameModeCommon_Base");
static_assert(offsetof(AGameModeCommon_Base, GameSessionCommon) == 0x0003F8, "Member 'AGameModeCommon_Base::GameSessionCommon' has a wrong offset!");
static_assert(offsetof(AGameModeCommon_Base, GameModeSessionString) == 0x000400, "Member 'AGameModeCommon_Base::GameModeSessionString' has a wrong offset!");
static_assert(offsetof(AGameModeCommon_Base, FailsafeServerRestartTimer) == 0x000410, "Member 'AGameModeCommon_Base::FailsafeServerRestartTimer' has a wrong offset!");
static_assert(offsetof(AGameModeCommon_Base, GameplayServerHitchThreshold) == 0x000414, "Member 'AGameModeCommon_Base::GameplayServerHitchThreshold' has a wrong offset!");
static_assert(offsetof(AGameModeCommon_Base, MovementTimeDiscrepancyHitchCooldown) == 0x000418, "Member 'AGameModeCommon_Base::MovementTimeDiscrepancyHitchCooldown' has a wrong offset!");
static_assert(offsetof(AGameModeCommon_Base, bInitReservationBeacon) == 0x00041C, "Member 'AGameModeCommon_Base::bInitReservationBeacon' has a wrong offset!");

// Class OrionGame.OrionGameMode_Base
// 0x00A0 (0x04E0 - 0x0440)
class AOrionGameMode_Base : public AGameModeCommon_Base
{
public:
	class AOrionGameSession*                      OrionGameSession;                                  // 0x0440(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMatchStarted;                                    // 0x0448(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_458[0x8];                                      // 0x0458(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AOrionAIBot>                AIBotClass;                                        // 0x0460(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTeamSetupData>                 Teams;                                             // 0x0468(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class AOrionGameState_Base*                   OrionGameState;                                    // 0x0478(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTeamCommunicationsData*                TopLevelTeamCommData;                              // 0x0480(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MatchCountdownSeconds;                             // 0x0488(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         WaitingForPlayersSeconds;                          // 0x048C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_490[0x50];                                     // 0x0490(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ChangeTeam(class AController* InController, EOrionTeam TeamIndex);
	void ExecuteGameplayCue(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Parameters, class AActor* TargetActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameMode_Base">();
	}
	static class AOrionGameMode_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionGameMode_Base>();
	}
};
static_assert(alignof(AOrionGameMode_Base) == 0x000008, "Wrong alignment on AOrionGameMode_Base");
static_assert(sizeof(AOrionGameMode_Base) == 0x0004E0, "Wrong size on AOrionGameMode_Base");
static_assert(offsetof(AOrionGameMode_Base, OrionGameSession) == 0x000440, "Member 'AOrionGameMode_Base::OrionGameSession' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_Base, OnMatchStarted) == 0x000448, "Member 'AOrionGameMode_Base::OnMatchStarted' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_Base, AIBotClass) == 0x000460, "Member 'AOrionGameMode_Base::AIBotClass' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_Base, Teams) == 0x000468, "Member 'AOrionGameMode_Base::Teams' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_Base, OrionGameState) == 0x000478, "Member 'AOrionGameMode_Base::OrionGameState' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_Base, TopLevelTeamCommData) == 0x000480, "Member 'AOrionGameMode_Base::TopLevelTeamCommData' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_Base, MatchCountdownSeconds) == 0x000488, "Member 'AOrionGameMode_Base::MatchCountdownSeconds' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_Base, WaitingForPlayersSeconds) == 0x00048C, "Member 'AOrionGameMode_Base::WaitingForPlayersSeconds' has a wrong offset!");

// Class OrionGame.OrionGameMode_MOBA
// 0x0910 (0x0DF0 - 0x04E0)
class AOrionGameMode_MOBA : public AOrionGameMode_Base
{
public:
	uint8                                         Pad_4E0[0xE0];                                     // 0x04E0(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AOrionCharAI*>                   RecentlySpawnedMinions;                            // 0x05C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FScalableFloat                         GameModeXPScalar;                                  // 0x05D0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScalableFloat                         GameModeCXPScalar;                                 // 0x05F8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScalableFloat                         GameModeXPSplitRatio;                              // 0x0620(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScalableFloat                         GameModeCXPSplitRatio;                             // 0x0648(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScalableFloat                         GameModeRecallTime;                                // 0x0670(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_698[0x60];                                     // 0x0698(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnMatchEnded;                                      // 0x06F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UOrionStatManager*                      MatchStatManager;                                  // 0x0708(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionMatchHeartbeatManager*            MatchHeartbeatManager;                             // 0x0710(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_718[0x68];                                     // 0x0718(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxTimeMargin;                                     // 0x0780(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinTimeMargin;                                     // 0x0784(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeMarginSlack;                                   // 0x0788(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSpeedHackDetection;                               // 0x078C(0x0001)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSpeedHackPrevention;                              // 0x078D(0x0001)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSpeedHackPreventionForceClientUpdate;             // 0x078E(0x0001)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_78F[0x1];                                      // 0x078F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrionGameState_MOBA*                   MOBAGameState;                                     // 0x0790(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECharacterSelectionType                       HeroSelectionMode;                                 // 0x0798(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_799[0x7];                                      // 0x0799(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         PlayerCardPointCurve;                              // 0x07A0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         PlayerPrimeHelixTimeCurve;                         // 0x07C8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         HeroStartingLevel;                                 // 0x07F0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         HeroStartingGold;                                  // 0x0818(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bSprintEnabled;                                    // 0x0840(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_841[0x3];                                      // 0x0841(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AllPickSelectionTime;                              // 0x0844(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RandomPickSelectionTime;                           // 0x0848(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NormalDraftSelectionTime;                          // 0x084C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CaptainsModeSelectionTime;                         // 0x0850(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndMatchTime;                                      // 0x0854(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         QuitSoloGameAfterSecondsIdle;                      // 0x0858(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldAbortMatchStartWhenPlayersMissing;          // 0x085C(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldPenalizeMissingPlayersOnAbortMatchStart;    // 0x085D(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85E[0x6];                                      // 0x085E(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MatchAbandonedTimeLimit;                           // 0x0864(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SurrenderVoteTimeLimitSeconds;                     // 0x0868(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SurrenderVoteInitialCooldownSeconds;               // 0x086C(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SurrenderVoteCooldownSeconds;                      // 0x0870(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxAssisterDepth;                                  // 0x0874(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FScalableFloat                         MinRespawnTimer;                                   // 0x0878(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         RespawnDelay;                                      // 0x08A0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         DeathPenaltyStartTime;                             // 0x08C8(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         DeathTimerCap;                                     // 0x08F0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	EOrionTrickleTeamXPRate                       TeamXPTickRate;                                    // 0x0918(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrionTrickleTeamXPAmount                     TeamXPTickAmount;                                  // 0x0919(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_91A[0x6];                                      // 0x091A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         Player_XPAssistRange;                              // 0x0920(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         Player_CXPAssistRange;                             // 0x0948(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         Minion_XPAssistRange;                              // 0x0970(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         Minion_CXPAssistRange;                             // 0x0998(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         Structure_XPAssistRange;                           // 0x09C0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         Structure_CXPAssistRange;                          // 0x09E8(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         CXPBountyBonus;                                    // 0x0A10(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	EOrionXPAssisterTimeOut                       XPAssisterTimeOut;                                 // 0x0A38(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A39[0x7];                                      // 0x0A39(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         PlayerKillStreakMinCount;                          // 0x0A40(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         PlayerMultiKillMinCount;                           // 0x0A68(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 PlayerMultiKillTimes;                              // 0x0A90(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueTag                        EndMatchGameplayCue;                               // 0x0AA0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsHeroSelectionDone;                              // 0x0AA8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AA9[0x7];                                      // 0x0AA9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEventKeywordCollectionItem>    EventKeywords;                                     // 0x0AB0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC0[0x50];                                     // 0x0AC0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIBotDifficultySettings               BotDifficultySettingsOverride;                     // 0x0B10(0x00A8)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UBotObjectiveGenerator>> ForbiddenBotObjectives;                            // 0x0BB8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         BotStartDelayBase;                                 // 0x0BC8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHaveBotsWaitForMinionsToSpawn : 1;                // 0x0BCC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideBotDifficulty : 1;                        // 0x0BCC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bBotsReactToHumanAFK : 1;                          // 0x0BCC(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDoInitialScriptedBehavior : 1;                    // 0x0BCC(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForceRoles : 1;                                   // 0x0BCC(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_BCD[0x3];                                      // 0x0BCD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UBotPlaybook>               DefaultPlaybooks[0x5];                             // 0x0BD0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BF8[0x8];                                      // 0x0BF8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AController*>                    ControllersWaitingToSpawn;                         // 0x0C00(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C10[0x30];                                     // 0x0C10(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionReplayDetailsManager*             ReplayDetailsManager;                              // 0x0C40(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETravelModeModes                              TravelModeMode;                                    // 0x0C48(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C49[0x1A7];                                    // 0x0C49(0x01A7)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceMatchWinCondition(EOrionTeam TeamNum);
	EOrionTeam GetWinningTeamNum();
	bool IsMatchObjectiveCompleted();
	void ReceiveCoreKilled(class AController* Killer, class AOrionDamageableActor* KilledCore);
	void ReceiveInhibitorKilled(class AController* Killer, class AOrionDamageableActor* KilledInhibitor);
	void ReceiveMinionKilled(class AController* Killer, class AController* KilledMinion, class APawn* KilledPawn);
	void ReceiveOtherStructureKilled(class AController* Killer, class AOrionDamageableActor* KilledActor);
	void ReceivePlayerKilled(class AController* Killer, class AController* KilledPlayer, class APawn* KilledPawn, int32 MultiKillCount, int32 KillStreakCount);
	void ReceivePlayerKillStreakShutdown(class AController* Victim, class AController* Killer, int32 KillStreakCount);
	void ReceivePlayerSpawned(class AOrionChar* SpawnedChar, EOrionTeam Team);
	void ReceiveTowerKilled(class AController* Killer, class AOrionDamageableActor* KilledTower);

	void GetBotDifficulty(EAIBotDifficulty* EnemyBotDifficulty, EAIBotDifficulty* FriendlyBotDifficulty) const;
	void GetBotTeams(TArray<class AOrionPlayerState_Game*>* OutEnemyTeam, TArray<class AOrionPlayerState_Game*>* OutFriendlyTeam) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameMode_MOBA">();
	}
	static class AOrionGameMode_MOBA* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionGameMode_MOBA>();
	}
};
static_assert(alignof(AOrionGameMode_MOBA) == 0x000008, "Wrong alignment on AOrionGameMode_MOBA");
static_assert(sizeof(AOrionGameMode_MOBA) == 0x000DF0, "Wrong size on AOrionGameMode_MOBA");
static_assert(offsetof(AOrionGameMode_MOBA, RecentlySpawnedMinions) == 0x0005C0, "Member 'AOrionGameMode_MOBA::RecentlySpawnedMinions' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, GameModeXPScalar) == 0x0005D0, "Member 'AOrionGameMode_MOBA::GameModeXPScalar' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, GameModeCXPScalar) == 0x0005F8, "Member 'AOrionGameMode_MOBA::GameModeCXPScalar' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, GameModeXPSplitRatio) == 0x000620, "Member 'AOrionGameMode_MOBA::GameModeXPSplitRatio' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, GameModeCXPSplitRatio) == 0x000648, "Member 'AOrionGameMode_MOBA::GameModeCXPSplitRatio' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, GameModeRecallTime) == 0x000670, "Member 'AOrionGameMode_MOBA::GameModeRecallTime' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, OnMatchEnded) == 0x0006F8, "Member 'AOrionGameMode_MOBA::OnMatchEnded' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, MatchStatManager) == 0x000708, "Member 'AOrionGameMode_MOBA::MatchStatManager' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, MatchHeartbeatManager) == 0x000710, "Member 'AOrionGameMode_MOBA::MatchHeartbeatManager' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, MaxTimeMargin) == 0x000780, "Member 'AOrionGameMode_MOBA::MaxTimeMargin' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, MinTimeMargin) == 0x000784, "Member 'AOrionGameMode_MOBA::MinTimeMargin' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, TimeMarginSlack) == 0x000788, "Member 'AOrionGameMode_MOBA::TimeMarginSlack' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, bSpeedHackDetection) == 0x00078C, "Member 'AOrionGameMode_MOBA::bSpeedHackDetection' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, bSpeedHackPrevention) == 0x00078D, "Member 'AOrionGameMode_MOBA::bSpeedHackPrevention' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, bSpeedHackPreventionForceClientUpdate) == 0x00078E, "Member 'AOrionGameMode_MOBA::bSpeedHackPreventionForceClientUpdate' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, MOBAGameState) == 0x000790, "Member 'AOrionGameMode_MOBA::MOBAGameState' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, HeroSelectionMode) == 0x000798, "Member 'AOrionGameMode_MOBA::HeroSelectionMode' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, PlayerCardPointCurve) == 0x0007A0, "Member 'AOrionGameMode_MOBA::PlayerCardPointCurve' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, PlayerPrimeHelixTimeCurve) == 0x0007C8, "Member 'AOrionGameMode_MOBA::PlayerPrimeHelixTimeCurve' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, HeroStartingLevel) == 0x0007F0, "Member 'AOrionGameMode_MOBA::HeroStartingLevel' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, HeroStartingGold) == 0x000818, "Member 'AOrionGameMode_MOBA::HeroStartingGold' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, bSprintEnabled) == 0x000840, "Member 'AOrionGameMode_MOBA::bSprintEnabled' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, AllPickSelectionTime) == 0x000844, "Member 'AOrionGameMode_MOBA::AllPickSelectionTime' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, RandomPickSelectionTime) == 0x000848, "Member 'AOrionGameMode_MOBA::RandomPickSelectionTime' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, NormalDraftSelectionTime) == 0x00084C, "Member 'AOrionGameMode_MOBA::NormalDraftSelectionTime' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, CaptainsModeSelectionTime) == 0x000850, "Member 'AOrionGameMode_MOBA::CaptainsModeSelectionTime' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, EndMatchTime) == 0x000854, "Member 'AOrionGameMode_MOBA::EndMatchTime' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, QuitSoloGameAfterSecondsIdle) == 0x000858, "Member 'AOrionGameMode_MOBA::QuitSoloGameAfterSecondsIdle' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, bShouldAbortMatchStartWhenPlayersMissing) == 0x00085C, "Member 'AOrionGameMode_MOBA::bShouldAbortMatchStartWhenPlayersMissing' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, bShouldPenalizeMissingPlayersOnAbortMatchStart) == 0x00085D, "Member 'AOrionGameMode_MOBA::bShouldPenalizeMissingPlayersOnAbortMatchStart' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, MatchAbandonedTimeLimit) == 0x000864, "Member 'AOrionGameMode_MOBA::MatchAbandonedTimeLimit' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, SurrenderVoteTimeLimitSeconds) == 0x000868, "Member 'AOrionGameMode_MOBA::SurrenderVoteTimeLimitSeconds' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, SurrenderVoteInitialCooldownSeconds) == 0x00086C, "Member 'AOrionGameMode_MOBA::SurrenderVoteInitialCooldownSeconds' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, SurrenderVoteCooldownSeconds) == 0x000870, "Member 'AOrionGameMode_MOBA::SurrenderVoteCooldownSeconds' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, MaxAssisterDepth) == 0x000874, "Member 'AOrionGameMode_MOBA::MaxAssisterDepth' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, MinRespawnTimer) == 0x000878, "Member 'AOrionGameMode_MOBA::MinRespawnTimer' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, RespawnDelay) == 0x0008A0, "Member 'AOrionGameMode_MOBA::RespawnDelay' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, DeathPenaltyStartTime) == 0x0008C8, "Member 'AOrionGameMode_MOBA::DeathPenaltyStartTime' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, DeathTimerCap) == 0x0008F0, "Member 'AOrionGameMode_MOBA::DeathTimerCap' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, TeamXPTickRate) == 0x000918, "Member 'AOrionGameMode_MOBA::TeamXPTickRate' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, TeamXPTickAmount) == 0x000919, "Member 'AOrionGameMode_MOBA::TeamXPTickAmount' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, Player_XPAssistRange) == 0x000920, "Member 'AOrionGameMode_MOBA::Player_XPAssistRange' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, Player_CXPAssistRange) == 0x000948, "Member 'AOrionGameMode_MOBA::Player_CXPAssistRange' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, Minion_XPAssistRange) == 0x000970, "Member 'AOrionGameMode_MOBA::Minion_XPAssistRange' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, Minion_CXPAssistRange) == 0x000998, "Member 'AOrionGameMode_MOBA::Minion_CXPAssistRange' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, Structure_XPAssistRange) == 0x0009C0, "Member 'AOrionGameMode_MOBA::Structure_XPAssistRange' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, Structure_CXPAssistRange) == 0x0009E8, "Member 'AOrionGameMode_MOBA::Structure_CXPAssistRange' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, CXPBountyBonus) == 0x000A10, "Member 'AOrionGameMode_MOBA::CXPBountyBonus' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, XPAssisterTimeOut) == 0x000A38, "Member 'AOrionGameMode_MOBA::XPAssisterTimeOut' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, PlayerKillStreakMinCount) == 0x000A40, "Member 'AOrionGameMode_MOBA::PlayerKillStreakMinCount' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, PlayerMultiKillMinCount) == 0x000A68, "Member 'AOrionGameMode_MOBA::PlayerMultiKillMinCount' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, PlayerMultiKillTimes) == 0x000A90, "Member 'AOrionGameMode_MOBA::PlayerMultiKillTimes' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, EndMatchGameplayCue) == 0x000AA0, "Member 'AOrionGameMode_MOBA::EndMatchGameplayCue' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, bIsHeroSelectionDone) == 0x000AA8, "Member 'AOrionGameMode_MOBA::bIsHeroSelectionDone' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, EventKeywords) == 0x000AB0, "Member 'AOrionGameMode_MOBA::EventKeywords' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, BotDifficultySettingsOverride) == 0x000B10, "Member 'AOrionGameMode_MOBA::BotDifficultySettingsOverride' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, ForbiddenBotObjectives) == 0x000BB8, "Member 'AOrionGameMode_MOBA::ForbiddenBotObjectives' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, BotStartDelayBase) == 0x000BC8, "Member 'AOrionGameMode_MOBA::BotStartDelayBase' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, DefaultPlaybooks) == 0x000BD0, "Member 'AOrionGameMode_MOBA::DefaultPlaybooks' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, ControllersWaitingToSpawn) == 0x000C00, "Member 'AOrionGameMode_MOBA::ControllersWaitingToSpawn' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, ReplayDetailsManager) == 0x000C40, "Member 'AOrionGameMode_MOBA::ReplayDetailsManager' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_MOBA, TravelModeMode) == 0x000C48, "Member 'AOrionGameMode_MOBA::TravelModeMode' has a wrong offset!");

// Class OrionGame.OrionGameMode_Sandbox
// 0x0080 (0x0E70 - 0x0DF0)
class AOrionGameMode_Sandbox final : public AOrionGameMode_MOBA
{
public:
	class AOrionCharAISpawner*                    LastHitting_FriendlySpawner;                       // 0x0DF0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AOrionCharAISpawner*                    LastHitting_EnemySpawner;                          // 0x0DF8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOrionAIFormationData*                  LastHitting_FormationData;                         // 0x0E00(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCurrentlySpawningLastHitting;                     // 0x0E08(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E09[0x7];                                      // 0x0E09(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrionCharAISpawner*                    TowerDefense_EnemySpawner;                         // 0x0E10(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOrionAIFormationData*                  TowerDefense_FormationData;                        // 0x0E18(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCurrentlySpawningTowerDefense;                    // 0x0E20(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E21[0x7];                                      // 0x0E21(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerBotSpawner*                      BotSpawner_Enemy_0;                                // 0x0E28(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerBotSpawner*                      BotSpawner_Enemy_1;                                // 0x0E30(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerBotSpawner*                      BotSpawner_Friendly_0;                             // 0x0E38(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCurrentlyInFightPractice;                         // 0x0E40(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCurrentlyInLevelUpArea;                           // 0x0E41(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E42[0x2];                                      // 0x0E42(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LevelUpTime;                                       // 0x0E44(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCurrentlyInShootingRange;                         // 0x0E48(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E49[0x7];                                      // 0x0E49(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AOrionDummySpawner*>             DummySpawners;                                     // 0x0E50(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E60[0x10];                                     // 0x0E60(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void KillAI();
	void KillAllNonPlayerPawns();
	void OnEnter_FightPractice(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnEnter_FightPractice_LineupSelect(class AActor* OverlappedActor, class AActor* OtherActor, EOrionPosition Enemy_0, EOrionPosition Enemy_1, EOrionPosition Friendly);
	void OnEnter_LastHitting(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnEnter_LevelUp(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnEnter_ShootingRange(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnEnter_TowerDefense(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnExit_FightPractice(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnExit_LastHitting(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnExit_LevelUp(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnExit_ShootingRange(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnExit_TowerDefense(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnHeroEnterLevelUp(class AOrionPlayerState_Game* PlayerState);
	void OnTowerDeath(class AController* Killer, class AActor* DamageCauser);

	void InitOrionSandboxPlayerState(class AOrionPlayerState_Game* PlayerState) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameMode_Sandbox">();
	}
	static class AOrionGameMode_Sandbox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionGameMode_Sandbox>();
	}
};
static_assert(alignof(AOrionGameMode_Sandbox) == 0x000008, "Wrong alignment on AOrionGameMode_Sandbox");
static_assert(sizeof(AOrionGameMode_Sandbox) == 0x000E70, "Wrong size on AOrionGameMode_Sandbox");
static_assert(offsetof(AOrionGameMode_Sandbox, LastHitting_FriendlySpawner) == 0x000DF0, "Member 'AOrionGameMode_Sandbox::LastHitting_FriendlySpawner' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_Sandbox, LastHitting_EnemySpawner) == 0x000DF8, "Member 'AOrionGameMode_Sandbox::LastHitting_EnemySpawner' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_Sandbox, LastHitting_FormationData) == 0x000E00, "Member 'AOrionGameMode_Sandbox::LastHitting_FormationData' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_Sandbox, bCurrentlySpawningLastHitting) == 0x000E08, "Member 'AOrionGameMode_Sandbox::bCurrentlySpawningLastHitting' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_Sandbox, TowerDefense_EnemySpawner) == 0x000E10, "Member 'AOrionGameMode_Sandbox::TowerDefense_EnemySpawner' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_Sandbox, TowerDefense_FormationData) == 0x000E18, "Member 'AOrionGameMode_Sandbox::TowerDefense_FormationData' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_Sandbox, bCurrentlySpawningTowerDefense) == 0x000E20, "Member 'AOrionGameMode_Sandbox::bCurrentlySpawningTowerDefense' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_Sandbox, BotSpawner_Enemy_0) == 0x000E28, "Member 'AOrionGameMode_Sandbox::BotSpawner_Enemy_0' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_Sandbox, BotSpawner_Enemy_1) == 0x000E30, "Member 'AOrionGameMode_Sandbox::BotSpawner_Enemy_1' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_Sandbox, BotSpawner_Friendly_0) == 0x000E38, "Member 'AOrionGameMode_Sandbox::BotSpawner_Friendly_0' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_Sandbox, bCurrentlyInFightPractice) == 0x000E40, "Member 'AOrionGameMode_Sandbox::bCurrentlyInFightPractice' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_Sandbox, bCurrentlyInLevelUpArea) == 0x000E41, "Member 'AOrionGameMode_Sandbox::bCurrentlyInLevelUpArea' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_Sandbox, LevelUpTime) == 0x000E44, "Member 'AOrionGameMode_Sandbox::LevelUpTime' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_Sandbox, bCurrentlyInShootingRange) == 0x000E48, "Member 'AOrionGameMode_Sandbox::bCurrentlyInShootingRange' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_Sandbox, DummySpawners) == 0x000E50, "Member 'AOrionGameMode_Sandbox::DummySpawners' has a wrong offset!");

// Class OrionGame.FTS_FXPerf_Start
// 0x0040 (0x0098 - 0x0058)
class UFTS_FXPerf_Start final : public UFunctionalTestPhase
{
public:
	class FString                                 MapName;                                           // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TestName;                                          // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         TestCategories;                                    // 0x0078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<class FString>                         StatsToRecord;                                     // 0x0088(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FTS_FXPerf_Start">();
	}
	static class UFTS_FXPerf_Start* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFTS_FXPerf_Start>();
	}
};
static_assert(alignof(UFTS_FXPerf_Start) == 0x000008, "Wrong alignment on UFTS_FXPerf_Start");
static_assert(sizeof(UFTS_FXPerf_Start) == 0x000098, "Wrong size on UFTS_FXPerf_Start");
static_assert(offsetof(UFTS_FXPerf_Start, MapName) == 0x000058, "Member 'UFTS_FXPerf_Start::MapName' has a wrong offset!");
static_assert(offsetof(UFTS_FXPerf_Start, TestName) == 0x000068, "Member 'UFTS_FXPerf_Start::TestName' has a wrong offset!");
static_assert(offsetof(UFTS_FXPerf_Start, TestCategories) == 0x000078, "Member 'UFTS_FXPerf_Start::TestCategories' has a wrong offset!");
static_assert(offsetof(UFTS_FXPerf_Start, StatsToRecord) == 0x000088, "Member 'UFTS_FXPerf_Start::StatsToRecord' has a wrong offset!");

// Class OrionGame.OrionBaseActor
// 0x00D0 (0x03E8 - 0x0318)
class AOrionBaseActor : public AActor
{
public:
	uint8                                         Pad_318[0x20];                                     // 0x0318(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	EProjectileCustomHitResponseType              ProjectileCustomHitResponseType;                   // 0x0338(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_339[0x7];                                      // 0x0339(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagRequirements               TargetingTagRequirements;                          // 0x0340(0x0040)(NativeAccessSpecifierPublic)
	int32                                         AbilityLevel;                                      // 0x0380(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionVisionDef                               VisionCategory;                                    // 0x0384(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_385[0x1];                                      // 0x0385(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionReplicatedVisionData             ReplicatedVisionData;                              // 0x0386(0x0004)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	struct FOrionReplicatedVisibleToEnemy         VisibleToEnemy;                                    // 0x038A(0x0004)(Net, IsPlainOldData, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	ESpawnOrionTaskCacheBehavior                  AbilitySpawnCacheBehavior;                         // 0x038E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38F[0x1];                                      // 0x038F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxActorsInCache;                                  // 0x0390(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGoToSpawnTransformOnAccess;                       // 0x0394(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_395[0x3];                                      // 0x0395(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicalMaterial*                      SpawnedOnMaterial;                                 // 0x0398(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AStaticMeshActor*>               AdditionalTeamColorMeshActors;                     // 0x03A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	EOrionTeam                                    TeamNum;                                           // 0x03B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrionSignificanceType                        SignificanceType;                                  // 0x03B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B2[0x2];                                      // 0x03B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bManageSignificance : 1;                           // 0x03B4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUsesTeamColors : 1;                               // 0x03B4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bBlockMinionSight : 1;                             // 0x03B4(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_3B5[0xB];                                      // 0x03B5(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentVisionZoneMask;                             // 0x03C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C4[0x4];                                      // 0x03C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           LeaveVisionZoneTimerHandle;                        // 0x03C8(0x0008)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           CantSeeVisionZoneTimerHandle;                      // 0x03D0(0x0008)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UOrionTeamColorComponent*>       CachedTeamColorComponents;                         // 0x03D8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void ExecuteGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Parameters);
	void NotifyTeamChanged(EOrionTeam NewTeamIdx);
	void OnCustomHit(const struct FHitResult& Hit, EProjectileCustomHitResponseType ProjectileCustomHitResponseType_0, float Magnitude);
	void OnRemovedTracked(class UOrionAbilitySystemComponent* AbilityComponent);
	void OnRep_ReplicatedVisionData(const struct FOrionReplicatedVisionData& OldData);
	void OnRep_TeamNum(EOrionTeam OldTeamNum);
	void OnRep_VisibleToEnemy(const struct FOrionReplicatedVisibleToEnemy& OldValue);
	void OnSpawnAbilityCacheReset();
	class UAudioComponent* PlaySoundTeamAdjustedForSelf(class USoundBase* SoundToPlay, bool Attached, bool bStopWhenAttachedToDestroyed);
	void SetTargetingTagRequirements(const struct FGameplayTagRequirements& InTargetingTagRequirements);
	void SetupTeamColors(bool bIsDead);
	void SetVisionRules(EOrionVisionIndividualRules NewType);

	EOrionTeam GetTeamNum() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionBaseActor">();
	}
	static class AOrionBaseActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionBaseActor>();
	}
};
static_assert(alignof(AOrionBaseActor) == 0x000008, "Wrong alignment on AOrionBaseActor");
static_assert(sizeof(AOrionBaseActor) == 0x0003E8, "Wrong size on AOrionBaseActor");
static_assert(offsetof(AOrionBaseActor, ProjectileCustomHitResponseType) == 0x000338, "Member 'AOrionBaseActor::ProjectileCustomHitResponseType' has a wrong offset!");
static_assert(offsetof(AOrionBaseActor, TargetingTagRequirements) == 0x000340, "Member 'AOrionBaseActor::TargetingTagRequirements' has a wrong offset!");
static_assert(offsetof(AOrionBaseActor, AbilityLevel) == 0x000380, "Member 'AOrionBaseActor::AbilityLevel' has a wrong offset!");
static_assert(offsetof(AOrionBaseActor, VisionCategory) == 0x000384, "Member 'AOrionBaseActor::VisionCategory' has a wrong offset!");
static_assert(offsetof(AOrionBaseActor, ReplicatedVisionData) == 0x000386, "Member 'AOrionBaseActor::ReplicatedVisionData' has a wrong offset!");
static_assert(offsetof(AOrionBaseActor, VisibleToEnemy) == 0x00038A, "Member 'AOrionBaseActor::VisibleToEnemy' has a wrong offset!");
static_assert(offsetof(AOrionBaseActor, AbilitySpawnCacheBehavior) == 0x00038E, "Member 'AOrionBaseActor::AbilitySpawnCacheBehavior' has a wrong offset!");
static_assert(offsetof(AOrionBaseActor, MaxActorsInCache) == 0x000390, "Member 'AOrionBaseActor::MaxActorsInCache' has a wrong offset!");
static_assert(offsetof(AOrionBaseActor, bGoToSpawnTransformOnAccess) == 0x000394, "Member 'AOrionBaseActor::bGoToSpawnTransformOnAccess' has a wrong offset!");
static_assert(offsetof(AOrionBaseActor, SpawnedOnMaterial) == 0x000398, "Member 'AOrionBaseActor::SpawnedOnMaterial' has a wrong offset!");
static_assert(offsetof(AOrionBaseActor, AdditionalTeamColorMeshActors) == 0x0003A0, "Member 'AOrionBaseActor::AdditionalTeamColorMeshActors' has a wrong offset!");
static_assert(offsetof(AOrionBaseActor, TeamNum) == 0x0003B0, "Member 'AOrionBaseActor::TeamNum' has a wrong offset!");
static_assert(offsetof(AOrionBaseActor, SignificanceType) == 0x0003B1, "Member 'AOrionBaseActor::SignificanceType' has a wrong offset!");
static_assert(offsetof(AOrionBaseActor, CurrentVisionZoneMask) == 0x0003C0, "Member 'AOrionBaseActor::CurrentVisionZoneMask' has a wrong offset!");
static_assert(offsetof(AOrionBaseActor, LeaveVisionZoneTimerHandle) == 0x0003C8, "Member 'AOrionBaseActor::LeaveVisionZoneTimerHandle' has a wrong offset!");
static_assert(offsetof(AOrionBaseActor, CantSeeVisionZoneTimerHandle) == 0x0003D0, "Member 'AOrionBaseActor::CantSeeVisionZoneTimerHandle' has a wrong offset!");
static_assert(offsetof(AOrionBaseActor, CachedTeamColorComponents) == 0x0003D8, "Member 'AOrionBaseActor::CachedTeamColorComponents' has a wrong offset!");

// Class OrionGame.OrionClientPilotComponent_Base
// 0x0058 (0x0080 - 0x0028)
class UOrionClientPilotComponent_Base : public UClientPilotComponent
{
public:
	bool                                          bVerbosePilotLogging;                              // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMakePilotSpecificLog;                             // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x1E];                                      // 0x002A(0x001E)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AccountName;                                       // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Password;                                          // 0x0058(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DesiredHero;                                       // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVerboseBotLogging;                                // 0x0078(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionClientPilotComponent_Base">();
	}
	static class UOrionClientPilotComponent_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionClientPilotComponent_Base>();
	}
};
static_assert(alignof(UOrionClientPilotComponent_Base) == 0x000008, "Wrong alignment on UOrionClientPilotComponent_Base");
static_assert(sizeof(UOrionClientPilotComponent_Base) == 0x000080, "Wrong size on UOrionClientPilotComponent_Base");
static_assert(offsetof(UOrionClientPilotComponent_Base, bVerbosePilotLogging) == 0x000028, "Member 'UOrionClientPilotComponent_Base::bVerbosePilotLogging' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Base, bMakePilotSpecificLog) == 0x000029, "Member 'UOrionClientPilotComponent_Base::bMakePilotSpecificLog' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Base, AccountName) == 0x000048, "Member 'UOrionClientPilotComponent_Base::AccountName' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Base, Password) == 0x000058, "Member 'UOrionClientPilotComponent_Base::Password' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Base, DesiredHero) == 0x000068, "Member 'UOrionClientPilotComponent_Base::DesiredHero' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Base, bVerboseBotLogging) == 0x000078, "Member 'UOrionClientPilotComponent_Base::bVerboseBotLogging' has a wrong offset!");

// Class OrionGame.OrionClientPilotComponent_Game
// 0x01B8 (0x0238 - 0x0080)
class UOrionClientPilotComponent_Game : public UOrionClientPilotComponent_Base
{
public:
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                AbilitySystem;                                     // 0x0088(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionPlayerState_Game*                 PlayerState;                                       // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionCharHero*                         MyPawn;                                            // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastCheckGoodTarget;                               // 0x00A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastPickEnemyHeroTime;                             // 0x00A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastPickEnemyMinionTime;                           // 0x00A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastPickEnemyStructureTime;                        // 0x00AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionChar*                             EnemyMinionTarget;                                 // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionCharHero*                         EnemyHeroTarget;                                   // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionDamageableObjective_Base*         EnemyStructureTarget;                              // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionDamageableObjective_Base*         FriendlyStructureTarget;                           // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionNavField*                         CachedFlowField;                                   // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeaveBaseByRunningForwardTimer;                    // 0x00D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunForYourLifeTime;                                // 0x00DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastAbilityFired;                                  // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConfirmAbilityTimer;                               // 0x00E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BuyCardsTimer;                                     // 0x00E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastCheckMoveTime;                                 // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecallLastStartedTimer;                            // 0x00F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlowFieldCheckedTimer;                             // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WhenToTryLeaving;                                  // 0x00F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChanceOfLeaving;                                   // 0x00FC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_100[0x4];                                      // 0x0100(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LevelAbilityInterval;                              // 0x0104(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LevelAbilityTimer;                                 // 0x0108(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0xC];                                      // 0x010C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoAttackRange;                                   // 0x0118(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardMovement;                                   // 0x011C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightMovement;                                     // 0x0120(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LaneAssignment;                                    // 0x0124(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ForcedLane;                                        // 0x0128(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumCardsPurchased;                                 // 0x012C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_130[0x10];                                     // 0x0130(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ViewLocation;                                      // 0x0140(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ViewRotation;                                      // 0x014C(0x000C)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                FlowFieldVector;                                   // 0x0158(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayAbility*                       PendingAbility;                                    // 0x0168(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilitySpec                   RecentlyFiredAbility;                              // 0x0170(0x00C8)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionClientPilotComponent_Game">();
	}
	static class UOrionClientPilotComponent_Game* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionClientPilotComponent_Game>();
	}
};
static_assert(alignof(UOrionClientPilotComponent_Game) == 0x000008, "Wrong alignment on UOrionClientPilotComponent_Game");
static_assert(sizeof(UOrionClientPilotComponent_Game) == 0x000238, "Wrong size on UOrionClientPilotComponent_Game");
static_assert(offsetof(UOrionClientPilotComponent_Game, AbilitySystem) == 0x000088, "Member 'UOrionClientPilotComponent_Game::AbilitySystem' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Game, PlayerState) == 0x000090, "Member 'UOrionClientPilotComponent_Game::PlayerState' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Game, MyPawn) == 0x000098, "Member 'UOrionClientPilotComponent_Game::MyPawn' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Game, LastCheckGoodTarget) == 0x0000A0, "Member 'UOrionClientPilotComponent_Game::LastCheckGoodTarget' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Game, LastPickEnemyHeroTime) == 0x0000A4, "Member 'UOrionClientPilotComponent_Game::LastPickEnemyHeroTime' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Game, LastPickEnemyMinionTime) == 0x0000A8, "Member 'UOrionClientPilotComponent_Game::LastPickEnemyMinionTime' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Game, LastPickEnemyStructureTime) == 0x0000AC, "Member 'UOrionClientPilotComponent_Game::LastPickEnemyStructureTime' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Game, EnemyMinionTarget) == 0x0000B0, "Member 'UOrionClientPilotComponent_Game::EnemyMinionTarget' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Game, EnemyHeroTarget) == 0x0000B8, "Member 'UOrionClientPilotComponent_Game::EnemyHeroTarget' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Game, EnemyStructureTarget) == 0x0000C0, "Member 'UOrionClientPilotComponent_Game::EnemyStructureTarget' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Game, FriendlyStructureTarget) == 0x0000C8, "Member 'UOrionClientPilotComponent_Game::FriendlyStructureTarget' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Game, CachedFlowField) == 0x0000D0, "Member 'UOrionClientPilotComponent_Game::CachedFlowField' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Game, LeaveBaseByRunningForwardTimer) == 0x0000D8, "Member 'UOrionClientPilotComponent_Game::LeaveBaseByRunningForwardTimer' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Game, RunForYourLifeTime) == 0x0000DC, "Member 'UOrionClientPilotComponent_Game::RunForYourLifeTime' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Game, LastAbilityFired) == 0x0000E0, "Member 'UOrionClientPilotComponent_Game::LastAbilityFired' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Game, ConfirmAbilityTimer) == 0x0000E4, "Member 'UOrionClientPilotComponent_Game::ConfirmAbilityTimer' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Game, BuyCardsTimer) == 0x0000E8, "Member 'UOrionClientPilotComponent_Game::BuyCardsTimer' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Game, LastCheckMoveTime) == 0x0000EC, "Member 'UOrionClientPilotComponent_Game::LastCheckMoveTime' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Game, RecallLastStartedTimer) == 0x0000F0, "Member 'UOrionClientPilotComponent_Game::RecallLastStartedTimer' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Game, FlowFieldCheckedTimer) == 0x0000F4, "Member 'UOrionClientPilotComponent_Game::FlowFieldCheckedTimer' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Game, WhenToTryLeaving) == 0x0000F8, "Member 'UOrionClientPilotComponent_Game::WhenToTryLeaving' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Game, ChanceOfLeaving) == 0x0000FC, "Member 'UOrionClientPilotComponent_Game::ChanceOfLeaving' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Game, LevelAbilityInterval) == 0x000104, "Member 'UOrionClientPilotComponent_Game::LevelAbilityInterval' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Game, LevelAbilityTimer) == 0x000108, "Member 'UOrionClientPilotComponent_Game::LevelAbilityTimer' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Game, AutoAttackRange) == 0x000118, "Member 'UOrionClientPilotComponent_Game::AutoAttackRange' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Game, ForwardMovement) == 0x00011C, "Member 'UOrionClientPilotComponent_Game::ForwardMovement' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Game, RightMovement) == 0x000120, "Member 'UOrionClientPilotComponent_Game::RightMovement' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Game, LaneAssignment) == 0x000124, "Member 'UOrionClientPilotComponent_Game::LaneAssignment' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Game, ForcedLane) == 0x000128, "Member 'UOrionClientPilotComponent_Game::ForcedLane' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Game, NumCardsPurchased) == 0x00012C, "Member 'UOrionClientPilotComponent_Game::NumCardsPurchased' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Game, ViewLocation) == 0x000140, "Member 'UOrionClientPilotComponent_Game::ViewLocation' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Game, ViewRotation) == 0x00014C, "Member 'UOrionClientPilotComponent_Game::ViewRotation' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Game, FlowFieldVector) == 0x000158, "Member 'UOrionClientPilotComponent_Game::FlowFieldVector' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Game, PendingAbility) == 0x000168, "Member 'UOrionClientPilotComponent_Game::PendingAbility' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_Game, RecentlyFiredAbility) == 0x000170, "Member 'UOrionClientPilotComponent_Game::RecentlyFiredAbility' has a wrong offset!");

// Class OrionGame.AIScriptedBehavior
// 0x0018 (0x0040 - 0x0028)
class UAIScriptedBehavior : public UObject
{
public:
	uint8                                         bLoop : 1;                                         // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bCancelled : 1;                                    // 0x0028(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bRunning : 1;                                      // 0x0028(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bFinished : 1;                                     // 0x0028(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bRequiresPawn : 1;                                 // 0x0028(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnBehaviorFinished;                                // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	void BehaviorFinished(class AOrionAIController* AIController);
	void FinishBehavior(class AOrionAIController* AIController);
	void K2_StopAllMovementTasks(class AOrionAIController* AIController);
	bool RunBehavior(class AOrionAIController* AIController);

	bool K2_IsFinished() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIScriptedBehavior">();
	}
	static class UAIScriptedBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIScriptedBehavior>();
	}
};
static_assert(alignof(UAIScriptedBehavior) == 0x000008, "Wrong alignment on UAIScriptedBehavior");
static_assert(sizeof(UAIScriptedBehavior) == 0x000040, "Wrong size on UAIScriptedBehavior");
static_assert(offsetof(UAIScriptedBehavior, OnBehaviorFinished) == 0x000030, "Member 'UAIScriptedBehavior::OnBehaviorFinished' has a wrong offset!");

// Class OrionGame.FTS_FXPerf_Stop
// 0x0000 (0x0058 - 0x0058)
class UFTS_FXPerf_Stop final : public UFunctionalTestPhase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FTS_FXPerf_Stop">();
	}
	static class UFTS_FXPerf_Stop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFTS_FXPerf_Stop>();
	}
};
static_assert(alignof(UFTS_FXPerf_Stop) == 0x000008, "Wrong alignment on UFTS_FXPerf_Stop");
static_assert(sizeof(UFTS_FXPerf_Stop) == 0x000058, "Wrong size on UFTS_FXPerf_Stop");

// Class OrionGame.AIWardPlacement
// 0x0038 (0x0420 - 0x03E8)
class AAIWardPlacement final : public AOrionBaseActor
{
public:
	class UCapsuleComponent*                      TriggerCollision;                                  // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AOrionVisionWard*                       TeamWards[0x2];                                    // 0x03F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_400[0x8];                                      // 0x0400(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ELaneRoleSlot                                 ScriptedBehaviorMarkup[0x2];                       // 0x0408(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40A[0x12];                                     // 0x040A(0x0012)(Fixing Size After Last Property [ Dumper-7 ])
	uint16                                        Priority;                                          // 0x041C(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41E[0x2];                                      // 0x041E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CapsuleTouched(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	ELaneRoleSlot GetScriptedRoleForTeam(EOrionTeam Team);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIWardPlacement">();
	}
	static class AAIWardPlacement* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAIWardPlacement>();
	}
};
static_assert(alignof(AAIWardPlacement) == 0x000008, "Wrong alignment on AAIWardPlacement");
static_assert(sizeof(AAIWardPlacement) == 0x000420, "Wrong size on AAIWardPlacement");
static_assert(offsetof(AAIWardPlacement, TriggerCollision) == 0x0003E8, "Member 'AAIWardPlacement::TriggerCollision' has a wrong offset!");
static_assert(offsetof(AAIWardPlacement, TeamWards) == 0x0003F0, "Member 'AAIWardPlacement::TeamWards' has a wrong offset!");
static_assert(offsetof(AAIWardPlacement, ScriptedBehaviorMarkup) == 0x000408, "Member 'AAIWardPlacement::ScriptedBehaviorMarkup' has a wrong offset!");
static_assert(offsetof(AAIWardPlacement, Priority) == 0x00041C, "Member 'AAIWardPlacement::Priority' has a wrong offset!");

// Class OrionGame.FTS_AddCondition
// 0x0008 (0x0060 - 0x0058)
class UFTS_AddCondition final : public UFunctionalTestPhase
{
public:
	class UFunctionalTestCondition*               NewCondition;                                      // 0x0058(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FTS_AddCondition">();
	}
	static class UFTS_AddCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFTS_AddCondition>();
	}
};
static_assert(alignof(UFTS_AddCondition) == 0x000008, "Wrong alignment on UFTS_AddCondition");
static_assert(sizeof(UFTS_AddCondition) == 0x000060, "Wrong size on UFTS_AddCondition");
static_assert(offsetof(UFTS_AddCondition, NewCondition) == 0x000058, "Member 'UFTS_AddCondition::NewCondition' has a wrong offset!");

// Class OrionGame.AIScriptedBehavior_BehaviorTree
// 0x0008 (0x0048 - 0x0040)
class UAIScriptedBehavior_BehaviorTree : public UAIScriptedBehavior
{
public:
	class UBehaviorTree*                          BehaviorTree;                                      // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIScriptedBehavior_BehaviorTree">();
	}
	static class UAIScriptedBehavior_BehaviorTree* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIScriptedBehavior_BehaviorTree>();
	}
};
static_assert(alignof(UAIScriptedBehavior_BehaviorTree) == 0x000008, "Wrong alignment on UAIScriptedBehavior_BehaviorTree");
static_assert(sizeof(UAIScriptedBehavior_BehaviorTree) == 0x000048, "Wrong size on UAIScriptedBehavior_BehaviorTree");
static_assert(offsetof(UAIScriptedBehavior_BehaviorTree, BehaviorTree) == 0x000040, "Member 'UAIScriptedBehavior_BehaviorTree::BehaviorTree' has a wrong offset!");

// Class OrionGame.FTS_ApplyGameplayEffects
// 0x0050 (0x00A8 - 0x0058)
class UFTS_ApplyGameplayEffects final : public UFunctionalTestPhase
{
public:
	EFTestActorKey                                TargetActor;                                       // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCustomKey;                                     // 0x0059(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomKey;                                         // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOrionEffectStack>              GameplayEffects;                                   // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         EffectsLevel;                                      // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostExecDelay;                                     // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x20];                                      // 0x0088(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetStatusToSucceeded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FTS_ApplyGameplayEffects">();
	}
	static class UFTS_ApplyGameplayEffects* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFTS_ApplyGameplayEffects>();
	}
};
static_assert(alignof(UFTS_ApplyGameplayEffects) == 0x000008, "Wrong alignment on UFTS_ApplyGameplayEffects");
static_assert(sizeof(UFTS_ApplyGameplayEffects) == 0x0000A8, "Wrong size on UFTS_ApplyGameplayEffects");
static_assert(offsetof(UFTS_ApplyGameplayEffects, TargetActor) == 0x000058, "Member 'UFTS_ApplyGameplayEffects::TargetActor' has a wrong offset!");
static_assert(offsetof(UFTS_ApplyGameplayEffects, bUseCustomKey) == 0x000059, "Member 'UFTS_ApplyGameplayEffects::bUseCustomKey' has a wrong offset!");
static_assert(offsetof(UFTS_ApplyGameplayEffects, CustomKey) == 0x000060, "Member 'UFTS_ApplyGameplayEffects::CustomKey' has a wrong offset!");
static_assert(offsetof(UFTS_ApplyGameplayEffects, GameplayEffects) == 0x000070, "Member 'UFTS_ApplyGameplayEffects::GameplayEffects' has a wrong offset!");
static_assert(offsetof(UFTS_ApplyGameplayEffects, EffectsLevel) == 0x000080, "Member 'UFTS_ApplyGameplayEffects::EffectsLevel' has a wrong offset!");
static_assert(offsetof(UFTS_ApplyGameplayEffects, PostExecDelay) == 0x000084, "Member 'UFTS_ApplyGameplayEffects::PostExecDelay' has a wrong offset!");

// Class OrionGame.AITacticsDebuggingActor
// 0x0000 (0x0318 - 0x0318)
class AAITacticsDebuggingActor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AITacticsDebuggingActor">();
	}
	static class AAITacticsDebuggingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAITacticsDebuggingActor>();
	}
};
static_assert(alignof(AAITacticsDebuggingActor) == 0x000008, "Wrong alignment on AAITacticsDebuggingActor");
static_assert(sizeof(AAITacticsDebuggingActor) == 0x000318, "Wrong size on AAITacticsDebuggingActor");

// Class OrionGame.GameInstanceCommon
// 0x0078 (0x0160 - 0x00E8)
class UGameInstanceCommon : public UGameInstance
{
public:
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UParty>                     PartyClass;                                        // 0x00F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMcpProfileManager*                     ProfileManager;                                    // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParty*                                 Party;                                             // 0x0100(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x58];                                     // 0x0108(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameInstanceCommon">();
	}
	static class UGameInstanceCommon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameInstanceCommon>();
	}
};
static_assert(alignof(UGameInstanceCommon) == 0x000008, "Wrong alignment on UGameInstanceCommon");
static_assert(sizeof(UGameInstanceCommon) == 0x000160, "Wrong size on UGameInstanceCommon");
static_assert(offsetof(UGameInstanceCommon, PartyClass) == 0x0000F0, "Member 'UGameInstanceCommon::PartyClass' has a wrong offset!");
static_assert(offsetof(UGameInstanceCommon, ProfileManager) == 0x0000F8, "Member 'UGameInstanceCommon::ProfileManager' has a wrong offset!");
static_assert(offsetof(UGameInstanceCommon, Party) == 0x000100, "Member 'UGameInstanceCommon::Party' has a wrong offset!");

// Class OrionGame.OrionGameInstance
// 0x0160 (0x02C0 - 0x0160)
class UOrionGameInstance final : public UGameInstanceCommon
{
public:
	EReturnToMainMenuReason                       NetworkFailureReason;                              // 0x0160(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_161[0x7];                                      // 0x0161(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   NetworkFailureMessage;                             // 0x0168(0x0018)(Transient, NativeAccessSpecifierPrivate)
	class UOrionMatchmaker*                       Matchmaker;                                        // 0x0180(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionMatchmakingV2*                    MatchmakingV2;                                     // 0x0188(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionRejoinCheck*                      RejoinCheck;                                       // 0x0190(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionUpdateManager*                    UpdateManager;                                     // 0x0198(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionTeamBuilder*                      TeamBuilder;                                       // 0x01A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionMatchDataLoader*                  MatchDataLoader;                                   // 0x01A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionUIManagerWidget*                  UIManager;                                         // 0x01B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B8[0x80];                                     // 0x01B8(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        UIManagerClassPath;                                // 0x0238(0x0018)(Edit, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_250[0x58];                                     // 0x0250(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionRotationalContentManager*         RotationalContentManager;                          // 0x02A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionRotationalContentTagCollection*   ActiveRotationtalContentTagCollection;             // 0x02B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameInstance">();
	}
	static class UOrionGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionGameInstance>();
	}
};
static_assert(alignof(UOrionGameInstance) == 0x000008, "Wrong alignment on UOrionGameInstance");
static_assert(sizeof(UOrionGameInstance) == 0x0002C0, "Wrong size on UOrionGameInstance");
static_assert(offsetof(UOrionGameInstance, NetworkFailureReason) == 0x000160, "Member 'UOrionGameInstance::NetworkFailureReason' has a wrong offset!");
static_assert(offsetof(UOrionGameInstance, NetworkFailureMessage) == 0x000168, "Member 'UOrionGameInstance::NetworkFailureMessage' has a wrong offset!");
static_assert(offsetof(UOrionGameInstance, Matchmaker) == 0x000180, "Member 'UOrionGameInstance::Matchmaker' has a wrong offset!");
static_assert(offsetof(UOrionGameInstance, MatchmakingV2) == 0x000188, "Member 'UOrionGameInstance::MatchmakingV2' has a wrong offset!");
static_assert(offsetof(UOrionGameInstance, RejoinCheck) == 0x000190, "Member 'UOrionGameInstance::RejoinCheck' has a wrong offset!");
static_assert(offsetof(UOrionGameInstance, UpdateManager) == 0x000198, "Member 'UOrionGameInstance::UpdateManager' has a wrong offset!");
static_assert(offsetof(UOrionGameInstance, TeamBuilder) == 0x0001A0, "Member 'UOrionGameInstance::TeamBuilder' has a wrong offset!");
static_assert(offsetof(UOrionGameInstance, MatchDataLoader) == 0x0001A8, "Member 'UOrionGameInstance::MatchDataLoader' has a wrong offset!");
static_assert(offsetof(UOrionGameInstance, UIManager) == 0x0001B0, "Member 'UOrionGameInstance::UIManager' has a wrong offset!");
static_assert(offsetof(UOrionGameInstance, UIManagerClassPath) == 0x000238, "Member 'UOrionGameInstance::UIManagerClassPath' has a wrong offset!");
static_assert(offsetof(UOrionGameInstance, RotationalContentManager) == 0x0002A8, "Member 'UOrionGameInstance::RotationalContentManager' has a wrong offset!");
static_assert(offsetof(UOrionGameInstance, ActiveRotationtalContentTagCollection) == 0x0002B0, "Member 'UOrionGameInstance::ActiveRotationtalContentTagCollection' has a wrong offset!");

// Class OrionGame.FTS_ExecCommonCommands
// 0x0010 (0x0068 - 0x0058)
class UFTS_ExecCommonCommands final : public UFunctionalTestPhase
{
public:
	float                                         PostExecDelay;                                     // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0xC];                                       // 0x005C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetStatusToSucceeded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FTS_ExecCommonCommands">();
	}
	static class UFTS_ExecCommonCommands* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFTS_ExecCommonCommands>();
	}
};
static_assert(alignof(UFTS_ExecCommonCommands) == 0x000008, "Wrong alignment on UFTS_ExecCommonCommands");
static_assert(sizeof(UFTS_ExecCommonCommands) == 0x000068, "Wrong size on UFTS_ExecCommonCommands");
static_assert(offsetof(UFTS_ExecCommonCommands, PostExecDelay) == 0x000058, "Member 'UFTS_ExecCommonCommands::PostExecDelay' has a wrong offset!");

// Class OrionGame.OrionClientPilotComponent_DraftLobby
// 0x0148 (0x01C8 - 0x0080)
class UOrionClientPilotComponent_DraftLobby final : public UOrionClientPilotComponent_Base
{
public:
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DesiredSkin;                                       // 0x0088(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UOrionHeroData*>                 DesiredHeroes;                                     // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UOrionHeroData*                         SelectedHero;                                      // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionTBPlayerChoices                  PlayerChoices;                                     // 0x00C0(0x0108)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionClientPilotComponent_DraftLobby">();
	}
	static class UOrionClientPilotComponent_DraftLobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionClientPilotComponent_DraftLobby>();
	}
};
static_assert(alignof(UOrionClientPilotComponent_DraftLobby) == 0x000008, "Wrong alignment on UOrionClientPilotComponent_DraftLobby");
static_assert(sizeof(UOrionClientPilotComponent_DraftLobby) == 0x0001C8, "Wrong size on UOrionClientPilotComponent_DraftLobby");
static_assert(offsetof(UOrionClientPilotComponent_DraftLobby, DesiredSkin) == 0x000088, "Member 'UOrionClientPilotComponent_DraftLobby::DesiredSkin' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_DraftLobby, DesiredHeroes) == 0x000098, "Member 'UOrionClientPilotComponent_DraftLobby::DesiredHeroes' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_DraftLobby, SelectedHero) == 0x0000A8, "Member 'UOrionClientPilotComponent_DraftLobby::SelectedHero' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_DraftLobby, PlayerChoices) == 0x0000C0, "Member 'UOrionClientPilotComponent_DraftLobby::PlayerChoices' has a wrong offset!");

// Class OrionGame.AITacticsRenderingComponent
// 0x0000 (0x0690 - 0x0690)
class UAITacticsRenderingComponent final : public UPrimitiveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AITacticsRenderingComponent">();
	}
	static class UAITacticsRenderingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAITacticsRenderingComponent>();
	}
};
static_assert(alignof(UAITacticsRenderingComponent) == 0x000010, "Wrong alignment on UAITacticsRenderingComponent");
static_assert(sizeof(UAITacticsRenderingComponent) == 0x000690, "Wrong size on UAITacticsRenderingComponent");

// Class OrionGame.OrionCraftingDevice
// 0x0178 (0x0560 - 0x03E8)
class AOrionCraftingDevice final : public AOrionBaseActor
{
public:
	uint8                                         Pad_3E8[0xC8];                                     // 0x03E8(0x00C8)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        ConstellationBeamFX;                               // 0x04B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ActionExecutionTimes[0x2];                         // 0x04B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ActionResetTimes[0x2];                             // 0x04C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TimeBetweenBeams;                                  // 0x04C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ConstellationFadeTime;                             // 0x04CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UParticleSystemComponent*>       ActiveConstellationEdgeBeams;                      // 0x04D0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UParticleSystemComponent*>       InactiveConstellationEdgeBeams;                    // 0x04E0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class AOrionCraftingDeviceNode*>       NodeActors;                                        // 0x04F0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AOrionCraftingDeviceGlyph*>      GlyphActors;                                       // 0x0500(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UOrionLegacyCardItemDefinition*         CurrentCardData;                                   // 0x0510(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CardQuantity;                                      // 0x0518(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EOrionCraftingAction                          ActiveCraftingAction;                              // 0x051C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51D[0x3];                                      // 0x051D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimelineComponent*                     ActionPrepTimeline;                                // 0x0520(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTimelineComponent*                     PreviewCraftTimeline;                              // 0x0528(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTimelineComponent*                     PreviewDismantleTimeline;                          // 0x0530(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTimelineComponent*                     CameraFocusDeviceTimeline;                         // 0x0538(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTimelineComponent*                     CameraResetPositionTimeline;                       // 0x0540(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_548[0x18];                                     // 0x0548(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActiveActionCancelled();
	void OnActiveActionSelected(int32 NumCards);
	void OnActiveCraftingActionChanged(EOrionCraftingAction ActionType);
	void OnConstellationComplete(const TArray<class UParticleSystemComponent*>& ActiveEdgeBeams);
	void OnConstellationEdgeCreated(class UParticleSystemComponent* EdgeBeamParticle, class AOrionCraftingDeviceNode* SourceNode, class AOrionCraftingDeviceNode* DestinationNode);
	void OnConstellationStarted();
	void OnCurrentCardDataChanged(class UOrionLegacyCardItemDefinition* NewCardData);
	void OnExecuteAction();
	void OnResetToIdle(bool bPostFanfare);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCraftingDevice">();
	}
	static class AOrionCraftingDevice* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionCraftingDevice>();
	}
};
static_assert(alignof(AOrionCraftingDevice) == 0x000008, "Wrong alignment on AOrionCraftingDevice");
static_assert(sizeof(AOrionCraftingDevice) == 0x000560, "Wrong size on AOrionCraftingDevice");
static_assert(offsetof(AOrionCraftingDevice, ConstellationBeamFX) == 0x0004B0, "Member 'AOrionCraftingDevice::ConstellationBeamFX' has a wrong offset!");
static_assert(offsetof(AOrionCraftingDevice, ActionExecutionTimes) == 0x0004B8, "Member 'AOrionCraftingDevice::ActionExecutionTimes' has a wrong offset!");
static_assert(offsetof(AOrionCraftingDevice, ActionResetTimes) == 0x0004C0, "Member 'AOrionCraftingDevice::ActionResetTimes' has a wrong offset!");
static_assert(offsetof(AOrionCraftingDevice, TimeBetweenBeams) == 0x0004C8, "Member 'AOrionCraftingDevice::TimeBetweenBeams' has a wrong offset!");
static_assert(offsetof(AOrionCraftingDevice, ConstellationFadeTime) == 0x0004CC, "Member 'AOrionCraftingDevice::ConstellationFadeTime' has a wrong offset!");
static_assert(offsetof(AOrionCraftingDevice, ActiveConstellationEdgeBeams) == 0x0004D0, "Member 'AOrionCraftingDevice::ActiveConstellationEdgeBeams' has a wrong offset!");
static_assert(offsetof(AOrionCraftingDevice, InactiveConstellationEdgeBeams) == 0x0004E0, "Member 'AOrionCraftingDevice::InactiveConstellationEdgeBeams' has a wrong offset!");
static_assert(offsetof(AOrionCraftingDevice, NodeActors) == 0x0004F0, "Member 'AOrionCraftingDevice::NodeActors' has a wrong offset!");
static_assert(offsetof(AOrionCraftingDevice, GlyphActors) == 0x000500, "Member 'AOrionCraftingDevice::GlyphActors' has a wrong offset!");
static_assert(offsetof(AOrionCraftingDevice, CurrentCardData) == 0x000510, "Member 'AOrionCraftingDevice::CurrentCardData' has a wrong offset!");
static_assert(offsetof(AOrionCraftingDevice, CardQuantity) == 0x000518, "Member 'AOrionCraftingDevice::CardQuantity' has a wrong offset!");
static_assert(offsetof(AOrionCraftingDevice, ActiveCraftingAction) == 0x00051C, "Member 'AOrionCraftingDevice::ActiveCraftingAction' has a wrong offset!");
static_assert(offsetof(AOrionCraftingDevice, ActionPrepTimeline) == 0x000520, "Member 'AOrionCraftingDevice::ActionPrepTimeline' has a wrong offset!");
static_assert(offsetof(AOrionCraftingDevice, PreviewCraftTimeline) == 0x000528, "Member 'AOrionCraftingDevice::PreviewCraftTimeline' has a wrong offset!");
static_assert(offsetof(AOrionCraftingDevice, PreviewDismantleTimeline) == 0x000530, "Member 'AOrionCraftingDevice::PreviewDismantleTimeline' has a wrong offset!");
static_assert(offsetof(AOrionCraftingDevice, CameraFocusDeviceTimeline) == 0x000538, "Member 'AOrionCraftingDevice::CameraFocusDeviceTimeline' has a wrong offset!");
static_assert(offsetof(AOrionCraftingDevice, CameraResetPositionTimeline) == 0x000540, "Member 'AOrionCraftingDevice::CameraResetPositionTimeline' has a wrong offset!");

// Class OrionGame.ArcadeGameplayEffectUIData
// 0x0038 (0x0060 - 0x0028)
class UArcadeGameplayEffectUIData final : public UGameplayEffectUIData
{
public:
	class FText                                   DisplayName;                                       // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArcadeGameplayEffectUIData">();
	}
	static class UArcadeGameplayEffectUIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArcadeGameplayEffectUIData>();
	}
};
static_assert(alignof(UArcadeGameplayEffectUIData) == 0x000008, "Wrong alignment on UArcadeGameplayEffectUIData");
static_assert(sizeof(UArcadeGameplayEffectUIData) == 0x000060, "Wrong size on UArcadeGameplayEffectUIData");
static_assert(offsetof(UArcadeGameplayEffectUIData, DisplayName) == 0x000028, "Member 'UArcadeGameplayEffectUIData::DisplayName' has a wrong offset!");
static_assert(offsetof(UArcadeGameplayEffectUIData, Description) == 0x000040, "Member 'UArcadeGameplayEffectUIData::Description' has a wrong offset!");
static_assert(offsetof(UArcadeGameplayEffectUIData, Icon) == 0x000058, "Member 'UArcadeGameplayEffectUIData::Icon' has a wrong offset!");

// Class OrionGame.ARHUD
// 0x0010 (0x0328 - 0x0318)
class AARHUD final : public AActor
{
public:
	uint8                                         Pad_318[0x10];                                     // 0x0318(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAbilityStatusChanged(EOrionAbilityBinding BindingId, const struct FOrionAbilityUIData& Data);
	void OnEnergyChanged(float EnergyValue);
	void OnHealthChanged(float HealthValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ARHUD">();
	}
	static class AARHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<AARHUD>();
	}
};
static_assert(alignof(AARHUD) == 0x000008, "Wrong alignment on AARHUD");
static_assert(sizeof(AARHUD) == 0x000328, "Wrong size on AARHUD");

// Class OrionGame.OrionPickup
// 0x01F8 (0x05E0 - 0x03E8)
class AOrionPickup : public AOrionBaseActor
{
public:
	bool                                          bReliablePickup;                                   // 0x03E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bServerOnlyCollision;                              // 0x03E9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3EA[0x2];                                      // 0x03EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeltaBetweenSpawns;                                // 0x03EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bResetExpireTimeOnPickupChange;                    // 0x03F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldLaunchPickupWhenHomingTargetDies;           // 0x03F1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F2[0x6];                                      // 0x03F2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         MaxLifespanTimer;                                  // 0x03F8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         DestroyDelayTimer;                                 // 0x0420(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_424[0x4];                                      // 0x0424(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 LockOnActor;                                       // 0x0428(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FBoundTagDelegate>              LockOnBoundTagDelegates;                           // 0x0430(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FOrionFilterAndEffectsContainer        PickUpFilterAndEffects;                            // 0x0440(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          bDestoryOnPickUp;                                  // 0x0460(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_461[0x7];                                      // 0x0461(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FActiveGameplayEffectHandle>    GameplayEffectHandles;                             // 0x0468(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         AppliedGELevel;                                    // 0x0478(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                StartInterpolationLocation;                        // 0x047C(0x000C)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                FinalDropLocation;                                 // 0x0488(0x000C)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LaunchVelocity;                                    // 0x0494(0x000C)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            LockOnOffsetCurve;                                 // 0x04A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinTravelTime;                                     // 0x04A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxTravelTime;                                     // 0x04AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinTravelOffset;                                   // 0x04B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxTravelOffset;                                   // 0x04B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinDistance;                                       // 0x04B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDistance;                                       // 0x04BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinLaunchAngle;                                    // 0x04C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxLaunchAngle;                                    // 0x04C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDropRadius;                                     // 0x04C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GravityScalar;                                     // 0x04CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D0[0x18];                                     // 0x04D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      OverlapCollision;                                  // 0x04E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   DisplayName;                                       // 0x04F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   EffectDescription;                                 // 0x0508(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     PickupMat;                                         // 0x0520(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               PickupMaterialInstance;                            // 0x0528(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECarriedBuffType                              CarriedBuffType;                                   // 0x0530(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_531[0x3];                                      // 0x0531(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           DefaultOverrideColor;                              // 0x0534(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_544[0x4];                                      // 0x0544(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ColorParamName;                                    // 0x0548(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OpacityValue;                                      // 0x0550(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_554[0x4];                                      // 0x0554(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OpacityParamName;                                  // 0x0558(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCoinTeamColoring;                                 // 0x0560(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_561[0x7];                                      // 0x0561(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0568(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPointLightComponent*                   PointLight;                                        // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PickupColorParamName;                              // 0x0578(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        PickUpEffect;                                      // 0x0580(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             PickUpSoundCue;                                    // 0x0588(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TargetPickupFXSocketName;                          // 0x0590(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TargetPickupColorParamName;                        // 0x0598(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        TargetPickupEffect;                                // 0x05A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        TimeOutEffect;                                     // 0x05A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPlayerNear;                                     // 0x05B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B1[0x3];                                      // 0x05B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Debug_TestDropLocation;                            // 0x05B4(0x000C)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Debug_TimeToReachMaxHeight;                        // 0x05C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Debug_TimeToReachTheGround;                        // 0x05C4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C8[0x18];                                     // 0x05C8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CleanUpAppliedGameplayEffects(class AActor* InActor);
	void FinishInterpolation();
	float GetCurrentMaxLifeSpan();
	struct FVector GetInterpolationEndLocation();
	void HandleHomingDeath(class AOrionChar* DeadChar);
	void HandleHomingEnterPhaseShift(class AOrionChar* PhaseShifedChar);
	void OnLockOnTagretTagAdded(const struct FGameplayTag& Tag, int32 NewCount);
	void OnLockOnTagretTagRemoved(const struct FGameplayTag& Tag);
	void OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnPickedUp(class AOrionChar* Pawn);
	void OnPickupActivated();
	void OnPickupDeactivated();
	void OnRep_InterpolationFinishedGameTime();
	void SetLockOnActor(class AActor* InNewLockOnActor);
	void TryToApplyGameplayEffectSpecToTarget(const struct FGameplayEffectSpecHandle& EffectSpecHandle, class AActor* Source, class AActor* Target);
	void UpdateInterpolation(float InElapsedTime);

	float GetMaxLifeSpan() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPickup">();
	}
	static class AOrionPickup* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionPickup>();
	}
};
static_assert(alignof(AOrionPickup) == 0x000008, "Wrong alignment on AOrionPickup");
static_assert(sizeof(AOrionPickup) == 0x0005E0, "Wrong size on AOrionPickup");
static_assert(offsetof(AOrionPickup, bReliablePickup) == 0x0003E8, "Member 'AOrionPickup::bReliablePickup' has a wrong offset!");
static_assert(offsetof(AOrionPickup, bServerOnlyCollision) == 0x0003E9, "Member 'AOrionPickup::bServerOnlyCollision' has a wrong offset!");
static_assert(offsetof(AOrionPickup, DeltaBetweenSpawns) == 0x0003EC, "Member 'AOrionPickup::DeltaBetweenSpawns' has a wrong offset!");
static_assert(offsetof(AOrionPickup, bResetExpireTimeOnPickupChange) == 0x0003F0, "Member 'AOrionPickup::bResetExpireTimeOnPickupChange' has a wrong offset!");
static_assert(offsetof(AOrionPickup, bShouldLaunchPickupWhenHomingTargetDies) == 0x0003F1, "Member 'AOrionPickup::bShouldLaunchPickupWhenHomingTargetDies' has a wrong offset!");
static_assert(offsetof(AOrionPickup, MaxLifespanTimer) == 0x0003F8, "Member 'AOrionPickup::MaxLifespanTimer' has a wrong offset!");
static_assert(offsetof(AOrionPickup, DestroyDelayTimer) == 0x000420, "Member 'AOrionPickup::DestroyDelayTimer' has a wrong offset!");
static_assert(offsetof(AOrionPickup, LockOnActor) == 0x000428, "Member 'AOrionPickup::LockOnActor' has a wrong offset!");
static_assert(offsetof(AOrionPickup, LockOnBoundTagDelegates) == 0x000430, "Member 'AOrionPickup::LockOnBoundTagDelegates' has a wrong offset!");
static_assert(offsetof(AOrionPickup, PickUpFilterAndEffects) == 0x000440, "Member 'AOrionPickup::PickUpFilterAndEffects' has a wrong offset!");
static_assert(offsetof(AOrionPickup, bDestoryOnPickUp) == 0x000460, "Member 'AOrionPickup::bDestoryOnPickUp' has a wrong offset!");
static_assert(offsetof(AOrionPickup, GameplayEffectHandles) == 0x000468, "Member 'AOrionPickup::GameplayEffectHandles' has a wrong offset!");
static_assert(offsetof(AOrionPickup, AppliedGELevel) == 0x000478, "Member 'AOrionPickup::AppliedGELevel' has a wrong offset!");
static_assert(offsetof(AOrionPickup, StartInterpolationLocation) == 0x00047C, "Member 'AOrionPickup::StartInterpolationLocation' has a wrong offset!");
static_assert(offsetof(AOrionPickup, FinalDropLocation) == 0x000488, "Member 'AOrionPickup::FinalDropLocation' has a wrong offset!");
static_assert(offsetof(AOrionPickup, LaunchVelocity) == 0x000494, "Member 'AOrionPickup::LaunchVelocity' has a wrong offset!");
static_assert(offsetof(AOrionPickup, LockOnOffsetCurve) == 0x0004A0, "Member 'AOrionPickup::LockOnOffsetCurve' has a wrong offset!");
static_assert(offsetof(AOrionPickup, MinTravelTime) == 0x0004A8, "Member 'AOrionPickup::MinTravelTime' has a wrong offset!");
static_assert(offsetof(AOrionPickup, MaxTravelTime) == 0x0004AC, "Member 'AOrionPickup::MaxTravelTime' has a wrong offset!");
static_assert(offsetof(AOrionPickup, MinTravelOffset) == 0x0004B0, "Member 'AOrionPickup::MinTravelOffset' has a wrong offset!");
static_assert(offsetof(AOrionPickup, MaxTravelOffset) == 0x0004B4, "Member 'AOrionPickup::MaxTravelOffset' has a wrong offset!");
static_assert(offsetof(AOrionPickup, MinDistance) == 0x0004B8, "Member 'AOrionPickup::MinDistance' has a wrong offset!");
static_assert(offsetof(AOrionPickup, MaxDistance) == 0x0004BC, "Member 'AOrionPickup::MaxDistance' has a wrong offset!");
static_assert(offsetof(AOrionPickup, MinLaunchAngle) == 0x0004C0, "Member 'AOrionPickup::MinLaunchAngle' has a wrong offset!");
static_assert(offsetof(AOrionPickup, MaxLaunchAngle) == 0x0004C4, "Member 'AOrionPickup::MaxLaunchAngle' has a wrong offset!");
static_assert(offsetof(AOrionPickup, MaxDropRadius) == 0x0004C8, "Member 'AOrionPickup::MaxDropRadius' has a wrong offset!");
static_assert(offsetof(AOrionPickup, GravityScalar) == 0x0004CC, "Member 'AOrionPickup::GravityScalar' has a wrong offset!");
static_assert(offsetof(AOrionPickup, OverlapCollision) == 0x0004E8, "Member 'AOrionPickup::OverlapCollision' has a wrong offset!");
static_assert(offsetof(AOrionPickup, DisplayName) == 0x0004F0, "Member 'AOrionPickup::DisplayName' has a wrong offset!");
static_assert(offsetof(AOrionPickup, EffectDescription) == 0x000508, "Member 'AOrionPickup::EffectDescription' has a wrong offset!");
static_assert(offsetof(AOrionPickup, PickupMat) == 0x000520, "Member 'AOrionPickup::PickupMat' has a wrong offset!");
static_assert(offsetof(AOrionPickup, PickupMaterialInstance) == 0x000528, "Member 'AOrionPickup::PickupMaterialInstance' has a wrong offset!");
static_assert(offsetof(AOrionPickup, CarriedBuffType) == 0x000530, "Member 'AOrionPickup::CarriedBuffType' has a wrong offset!");
static_assert(offsetof(AOrionPickup, DefaultOverrideColor) == 0x000534, "Member 'AOrionPickup::DefaultOverrideColor' has a wrong offset!");
static_assert(offsetof(AOrionPickup, ColorParamName) == 0x000548, "Member 'AOrionPickup::ColorParamName' has a wrong offset!");
static_assert(offsetof(AOrionPickup, OpacityValue) == 0x000550, "Member 'AOrionPickup::OpacityValue' has a wrong offset!");
static_assert(offsetof(AOrionPickup, OpacityParamName) == 0x000558, "Member 'AOrionPickup::OpacityParamName' has a wrong offset!");
static_assert(offsetof(AOrionPickup, bCoinTeamColoring) == 0x000560, "Member 'AOrionPickup::bCoinTeamColoring' has a wrong offset!");
static_assert(offsetof(AOrionPickup, StaticMeshComponent) == 0x000568, "Member 'AOrionPickup::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AOrionPickup, PointLight) == 0x000570, "Member 'AOrionPickup::PointLight' has a wrong offset!");
static_assert(offsetof(AOrionPickup, PickupColorParamName) == 0x000578, "Member 'AOrionPickup::PickupColorParamName' has a wrong offset!");
static_assert(offsetof(AOrionPickup, PickUpEffect) == 0x000580, "Member 'AOrionPickup::PickUpEffect' has a wrong offset!");
static_assert(offsetof(AOrionPickup, PickUpSoundCue) == 0x000588, "Member 'AOrionPickup::PickUpSoundCue' has a wrong offset!");
static_assert(offsetof(AOrionPickup, TargetPickupFXSocketName) == 0x000590, "Member 'AOrionPickup::TargetPickupFXSocketName' has a wrong offset!");
static_assert(offsetof(AOrionPickup, TargetPickupColorParamName) == 0x000598, "Member 'AOrionPickup::TargetPickupColorParamName' has a wrong offset!");
static_assert(offsetof(AOrionPickup, TargetPickupEffect) == 0x0005A0, "Member 'AOrionPickup::TargetPickupEffect' has a wrong offset!");
static_assert(offsetof(AOrionPickup, TimeOutEffect) == 0x0005A8, "Member 'AOrionPickup::TimeOutEffect' has a wrong offset!");
static_assert(offsetof(AOrionPickup, bIsPlayerNear) == 0x0005B0, "Member 'AOrionPickup::bIsPlayerNear' has a wrong offset!");
static_assert(offsetof(AOrionPickup, Debug_TestDropLocation) == 0x0005B4, "Member 'AOrionPickup::Debug_TestDropLocation' has a wrong offset!");
static_assert(offsetof(AOrionPickup, Debug_TimeToReachMaxHeight) == 0x0005C0, "Member 'AOrionPickup::Debug_TimeToReachMaxHeight' has a wrong offset!");
static_assert(offsetof(AOrionPickup, Debug_TimeToReachTheGround) == 0x0005C4, "Member 'AOrionPickup::Debug_TimeToReachTheGround' has a wrong offset!");

// Class OrionGame.OrionCoin
// 0x0070 (0x0650 - 0x05E0)
class AOrionCoin : public AOrionPickup
{
public:
	int32                                         CoinValues[0x3];                                   // 0x05E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5EC[0x4];                                      // 0x05EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  CachedSourceTags;                                  // 0x05F0(0x0020)(NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  CachedSourceAssetTags;                             // 0x0610(0x0020)(NativeAccessSpecifierPrivate)
	float                                         KillerCXPValue;                                    // 0x0630(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AssisterCXPValue;                                  // 0x0634(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsLastHit;                                        // 0x0638(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_639[0x7];                                      // 0x0639(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AOrionPlayerState_Game*>         AssistingPlayersToGetCXP;                          // 0x0640(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void HandleHomingDeath(class AOrionChar* DeadChar);
	void HandleHomingEnterPhaseShift(class AOrionChar* PhaseShifedChar);
	void OnCoinVisualScalar(EOrionCoinSize Size, class UMaterialInstanceDynamic* CoinMID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCoin">();
	}
	static class AOrionCoin* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionCoin>();
	}
};
static_assert(alignof(AOrionCoin) == 0x000008, "Wrong alignment on AOrionCoin");
static_assert(sizeof(AOrionCoin) == 0x000650, "Wrong size on AOrionCoin");
static_assert(offsetof(AOrionCoin, CoinValues) == 0x0005E0, "Member 'AOrionCoin::CoinValues' has a wrong offset!");
static_assert(offsetof(AOrionCoin, CachedSourceTags) == 0x0005F0, "Member 'AOrionCoin::CachedSourceTags' has a wrong offset!");
static_assert(offsetof(AOrionCoin, CachedSourceAssetTags) == 0x000610, "Member 'AOrionCoin::CachedSourceAssetTags' has a wrong offset!");
static_assert(offsetof(AOrionCoin, KillerCXPValue) == 0x000630, "Member 'AOrionCoin::KillerCXPValue' has a wrong offset!");
static_assert(offsetof(AOrionCoin, AssisterCXPValue) == 0x000634, "Member 'AOrionCoin::AssisterCXPValue' has a wrong offset!");
static_assert(offsetof(AOrionCoin, bIsLastHit) == 0x000638, "Member 'AOrionCoin::bIsLastHit' has a wrong offset!");
static_assert(offsetof(AOrionCoin, AssistingPlayersToGetCXP) == 0x000640, "Member 'AOrionCoin::AssistingPlayersToGetCXP' has a wrong offset!");

// Class OrionGame.ARWidget
// 0x0000 (0x0318 - 0x0318)
class AARWidget : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ARWidget">();
	}
	static class AARWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<AARWidget>();
	}
};
static_assert(alignof(AARWidget) == 0x000008, "Wrong alignment on AARWidget");
static_assert(sizeof(AARWidget) == 0x000318, "Wrong size on AARWidget");

// Class OrionGame.ARMinimap
// 0x0088 (0x03A0 - 0x0318)
class AARMinimap final : public AARWidget
{
public:
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   MapSurface;                                        // 0x0320(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   MapShadowSurface;                                  // 0x0328(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            GenericIndicator_Asset;                            // 0x0330(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<uint32, class UStaticMeshComponent*>     Entities;                                          // 0x0338(0x0050)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_388[0x18];                                     // 0x0388(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ARMinimap">();
	}
	static class AARMinimap* GetDefaultObj()
	{
		return GetDefaultObjImpl<AARMinimap>();
	}
};
static_assert(alignof(AARMinimap) == 0x000008, "Wrong alignment on AARMinimap");
static_assert(sizeof(AARMinimap) == 0x0003A0, "Wrong size on AARMinimap");
static_assert(offsetof(AARMinimap, MapSurface) == 0x000320, "Member 'AARMinimap::MapSurface' has a wrong offset!");
static_assert(offsetof(AARMinimap, MapShadowSurface) == 0x000328, "Member 'AARMinimap::MapShadowSurface' has a wrong offset!");
static_assert(offsetof(AARMinimap, GenericIndicator_Asset) == 0x000330, "Member 'AARMinimap::GenericIndicator_Asset' has a wrong offset!");
static_assert(offsetof(AARMinimap, Entities) == 0x000338, "Member 'AARMinimap::Entities' has a wrong offset!");

// Class OrionGame.OrionCraftingConstants
// 0x0030 (0x0058 - 0x0028)
class UOrionCraftingConstants final : public UObject
{
public:
	int32                                         BaseTimeCurrencyCost;                              // 0x0028(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         BaseComponentCost;                                 // 0x002C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CostScaling[0x5];                                  // 0x0030(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DismantleDivisors[0x5];                            // 0x0044(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCraftingConstants">();
	}
	static class UOrionCraftingConstants* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionCraftingConstants>();
	}
};
static_assert(alignof(UOrionCraftingConstants) == 0x000008, "Wrong alignment on UOrionCraftingConstants");
static_assert(sizeof(UOrionCraftingConstants) == 0x000058, "Wrong size on UOrionCraftingConstants");
static_assert(offsetof(UOrionCraftingConstants, BaseTimeCurrencyCost) == 0x000028, "Member 'UOrionCraftingConstants::BaseTimeCurrencyCost' has a wrong offset!");
static_assert(offsetof(UOrionCraftingConstants, BaseComponentCost) == 0x00002C, "Member 'UOrionCraftingConstants::BaseComponentCost' has a wrong offset!");
static_assert(offsetof(UOrionCraftingConstants, CostScaling) == 0x000030, "Member 'UOrionCraftingConstants::CostScaling' has a wrong offset!");
static_assert(offsetof(UOrionCraftingConstants, DismantleDivisors) == 0x000044, "Member 'UOrionCraftingConstants::DismantleDivisors' has a wrong offset!");

// Class OrionGame.AutomationPerfMontiorManager
// 0x02F0 (0x0318 - 0x0028)
class UAutomationPerfMontiorManager final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         DesiredStats;                                      // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FString>                         DesiredStatGroups;                                 // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FName>                           DesiredStatsAsLongNames;                           // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x28];                                      // 0x0060(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CurrentTestName;                                   // 0x0088(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 LogFileName;                                       // 0x0098(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRecording;                                        // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A9[0x1F];                                      // 0x00A9(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TestStartTime;                                     // 0x00C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasWarnedAboutTime;                               // 0x00CC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeSinceLastRecord;                               // 0x00D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPerfTestDataEvent                     EventToRecord;                                     // 0x00D8(0x0110)(NativeAccessSpecifierPrivate)
	int32                                         LastGoodFrame;                                     // 0x01E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1EC[0x12C];                                    // 0x01EC(0x012C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAutomationPerfMontiorManager* GetPerfMonitorInstance();

	void CleanUpPerfFileHandles();
	void FinalizeFTestPerfReport();
	bool IsRecordingFTestPerf();
	void StartRecordingFTestPerf(const class FString& Filename, const class FString& TestName, const TArray<class FString>& StatsToRecord);
	void StopRecordingFTestPerf();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutomationPerfMontiorManager">();
	}
	static class UAutomationPerfMontiorManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutomationPerfMontiorManager>();
	}
};
static_assert(alignof(UAutomationPerfMontiorManager) == 0x000008, "Wrong alignment on UAutomationPerfMontiorManager");
static_assert(sizeof(UAutomationPerfMontiorManager) == 0x000318, "Wrong size on UAutomationPerfMontiorManager");
static_assert(offsetof(UAutomationPerfMontiorManager, DesiredStats) == 0x000030, "Member 'UAutomationPerfMontiorManager::DesiredStats' has a wrong offset!");
static_assert(offsetof(UAutomationPerfMontiorManager, DesiredStatGroups) == 0x000040, "Member 'UAutomationPerfMontiorManager::DesiredStatGroups' has a wrong offset!");
static_assert(offsetof(UAutomationPerfMontiorManager, DesiredStatsAsLongNames) == 0x000050, "Member 'UAutomationPerfMontiorManager::DesiredStatsAsLongNames' has a wrong offset!");
static_assert(offsetof(UAutomationPerfMontiorManager, CurrentTestName) == 0x000088, "Member 'UAutomationPerfMontiorManager::CurrentTestName' has a wrong offset!");
static_assert(offsetof(UAutomationPerfMontiorManager, LogFileName) == 0x000098, "Member 'UAutomationPerfMontiorManager::LogFileName' has a wrong offset!");
static_assert(offsetof(UAutomationPerfMontiorManager, bRecording) == 0x0000A8, "Member 'UAutomationPerfMontiorManager::bRecording' has a wrong offset!");
static_assert(offsetof(UAutomationPerfMontiorManager, TestStartTime) == 0x0000C8, "Member 'UAutomationPerfMontiorManager::TestStartTime' has a wrong offset!");
static_assert(offsetof(UAutomationPerfMontiorManager, bHasWarnedAboutTime) == 0x0000CC, "Member 'UAutomationPerfMontiorManager::bHasWarnedAboutTime' has a wrong offset!");
static_assert(offsetof(UAutomationPerfMontiorManager, TimeSinceLastRecord) == 0x0000D0, "Member 'UAutomationPerfMontiorManager::TimeSinceLastRecord' has a wrong offset!");
static_assert(offsetof(UAutomationPerfMontiorManager, EventToRecord) == 0x0000D8, "Member 'UAutomationPerfMontiorManager::EventToRecord' has a wrong offset!");
static_assert(offsetof(UAutomationPerfMontiorManager, LastGoodFrame) == 0x0001E8, "Member 'UAutomationPerfMontiorManager::LastGoodFrame' has a wrong offset!");

// Class OrionGame.BotLoSCache
// 0x00B0 (0x03C8 - 0x0318)
class ABotLoSCache final : public AActor
{
public:
	uint8                                         Pad_318[0x58];                                     // 0x0318(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         DataVersion;                                       // 0x0370(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_371[0x3];                                      // 0x0371(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBox                                   Bounds;                                            // 0x0374(0x001C)(IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UBillboardComponent*                    SpriteComponent;                                   // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint32                                        LoSCellSize;                                       // 0x0398(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint32                                        TileSize;                                          // 0x039C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<uint32>                                ValidTiles;                                        // 0x03A0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         TraceLocationVerticalOffset;                       // 0x03B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B4[0x4];                                      // 0x03B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AAITacticsDebuggingActor*               DebuggingActor;                                    // 0x03B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             LoSCollisionChannel;                               // 0x03C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C1[0x7];                                      // 0x03C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotLoSCache">();
	}
	static class ABotLoSCache* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABotLoSCache>();
	}
};
static_assert(alignof(ABotLoSCache) == 0x000008, "Wrong alignment on ABotLoSCache");
static_assert(sizeof(ABotLoSCache) == 0x0003C8, "Wrong size on ABotLoSCache");
static_assert(offsetof(ABotLoSCache, DataVersion) == 0x000370, "Member 'ABotLoSCache::DataVersion' has a wrong offset!");
static_assert(offsetof(ABotLoSCache, Bounds) == 0x000374, "Member 'ABotLoSCache::Bounds' has a wrong offset!");
static_assert(offsetof(ABotLoSCache, SpriteComponent) == 0x000390, "Member 'ABotLoSCache::SpriteComponent' has a wrong offset!");
static_assert(offsetof(ABotLoSCache, LoSCellSize) == 0x000398, "Member 'ABotLoSCache::LoSCellSize' has a wrong offset!");
static_assert(offsetof(ABotLoSCache, TileSize) == 0x00039C, "Member 'ABotLoSCache::TileSize' has a wrong offset!");
static_assert(offsetof(ABotLoSCache, ValidTiles) == 0x0003A0, "Member 'ABotLoSCache::ValidTiles' has a wrong offset!");
static_assert(offsetof(ABotLoSCache, TraceLocationVerticalOffset) == 0x0003B0, "Member 'ABotLoSCache::TraceLocationVerticalOffset' has a wrong offset!");
static_assert(offsetof(ABotLoSCache, DebuggingActor) == 0x0003B8, "Member 'ABotLoSCache::DebuggingActor' has a wrong offset!");
static_assert(offsetof(ABotLoSCache, LoSCollisionChannel) == 0x0003C0, "Member 'ABotLoSCache::LoSCollisionChannel' has a wrong offset!");

// Class OrionGame.OrionGameplayCueNotify_Actor
// 0x0010 (0x03D0 - 0x03C0)
#pragma pack(push, 0x1)
class alignas(0x10) AOrionGameplayCueNotify_Actor : public AGameplayCueNotify_Actor
{
public:
	ELocalVisiblityState                          GameplayCueCurrentVisualState;                     // 0x03B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionGameplayCueSignificanceSettings  SignificanceSettings;                              // 0x03B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3BA[0x1];                                      // 0x03BA(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSpawnedAlwaysPlayVisualComponenet;                // 0x03BB(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3BC[0xC];                                      // 0x03BC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool OnEnterShadowplane(class AActor* MyTarget, bool bVisibleToMe);
	bool OnExitShadowplane(class AActor* MyTarget);
	void SetShadowplaneVisibility(class AActor* MyTarget, ELocalVisiblityState ShadowPlaneVisibility);
	TArray<class UNiagaraComponent*> SpawnBurstGameplayCueNiagaraParticleInfo(const struct FGameplayCueNiagaraParticleInfo& ParticleEffect, class AActor* TargetActor, const struct FGameplayCueParameters& Parameters, class USceneComponent* OptionalAttachToComponent);
	TArray<class UParticleSystemComponent*> SpawnBurstGameplayCueParticleInfo(const struct FGameplayCueParticleInfo& ParticleEffect, class AActor* TargetActor, const struct FGameplayCueParameters& Parameters, class USceneComponent* OptionalAttachToComponent);
	void UpdateGameplayCueVisuals_Hidden(class AActor* MyTarget, const bool bIsHidden);
	void UpdateGameplayCueVisuals_Shadowplane(class AActor* MyTarget, const bool bInShadowplane);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameplayCueNotify_Actor">();
	}
	static class AOrionGameplayCueNotify_Actor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionGameplayCueNotify_Actor>();
	}
};
#pragma pack(pop)
static_assert(alignof(AOrionGameplayCueNotify_Actor) == 0x000010, "Wrong alignment on AOrionGameplayCueNotify_Actor");
static_assert(sizeof(AOrionGameplayCueNotify_Actor) == 0x0003D0, "Wrong size on AOrionGameplayCueNotify_Actor");
static_assert(offsetof(AOrionGameplayCueNotify_Actor, GameplayCueCurrentVisualState) == 0x0003B8, "Member 'AOrionGameplayCueNotify_Actor::GameplayCueCurrentVisualState' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Actor, SignificanceSettings) == 0x0003B9, "Member 'AOrionGameplayCueNotify_Actor::SignificanceSettings' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Actor, bSpawnedAlwaysPlayVisualComponenet) == 0x0003BB, "Member 'AOrionGameplayCueNotify_Actor::bSpawnedAlwaysPlayVisualComponenet' has a wrong offset!");

// Class OrionGame.OrionGameplayCueNotify_StandardAttachedActor
// 0x0020 (0x03F0 - 0x03D0)
class AOrionGameplayCueNotify_StandardAttachedActor final : public AOrionGameplayCueNotify_Actor
{
public:
	int32                                         MaxSpawnedActors;                                  // 0x03C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3CC[0x4];                                      // 0x03CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     ExtraActorToSpawn;                                 // 0x03D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         SpawnedActors;                                     // 0x03D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E8[0x8];                                      // 0x03E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameplayCueNotify_StandardAttachedActor">();
	}
	static class AOrionGameplayCueNotify_StandardAttachedActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionGameplayCueNotify_StandardAttachedActor>();
	}
};
static_assert(alignof(AOrionGameplayCueNotify_StandardAttachedActor) == 0x000010, "Wrong alignment on AOrionGameplayCueNotify_StandardAttachedActor");
static_assert(sizeof(AOrionGameplayCueNotify_StandardAttachedActor) == 0x0003F0, "Wrong size on AOrionGameplayCueNotify_StandardAttachedActor");
static_assert(offsetof(AOrionGameplayCueNotify_StandardAttachedActor, MaxSpawnedActors) == 0x0003C8, "Member 'AOrionGameplayCueNotify_StandardAttachedActor::MaxSpawnedActors' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_StandardAttachedActor, ExtraActorToSpawn) == 0x0003D0, "Member 'AOrionGameplayCueNotify_StandardAttachedActor::ExtraActorToSpawn' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_StandardAttachedActor, SpawnedActors) == 0x0003D8, "Member 'AOrionGameplayCueNotify_StandardAttachedActor::SpawnedActors' has a wrong offset!");

// Class OrionGame.BotObjective
// 0x0108 (0x0130 - 0x0028)
class UBotObjective : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBotObjectiveAgent>             Agents;                                            // 0x0040(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UBehaviorTree*                          ObjectiveBT;                                       // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEnvQuery*                              EnemySelectionQueryOverride;                       // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_60[0x40];                                      // 0x0060(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 RelatedActor;                                      // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A8[0x80];                                      // 0x00A8(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAICommander*                      AICommander;                                       // 0x0128(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotObjective">();
	}
	static class UBotObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotObjective>();
	}
};
static_assert(alignof(UBotObjective) == 0x000008, "Wrong alignment on UBotObjective");
static_assert(sizeof(UBotObjective) == 0x000130, "Wrong size on UBotObjective");
static_assert(offsetof(UBotObjective, Agents) == 0x000040, "Member 'UBotObjective::Agents' has a wrong offset!");
static_assert(offsetof(UBotObjective, ObjectiveBT) == 0x000050, "Member 'UBotObjective::ObjectiveBT' has a wrong offset!");
static_assert(offsetof(UBotObjective, EnemySelectionQueryOverride) == 0x000058, "Member 'UBotObjective::EnemySelectionQueryOverride' has a wrong offset!");
static_assert(offsetof(UBotObjective, RelatedActor) == 0x0000A0, "Member 'UBotObjective::RelatedActor' has a wrong offset!");
static_assert(offsetof(UBotObjective, AICommander) == 0x000128, "Member 'UBotObjective::AICommander' has a wrong offset!");

// Class OrionGame.OrionUserWidget_LogMessage
// 0x0028 (0x0228 - 0x0200)
class UOrionUserWidget_LogMessage final : public UUserWidget
{
public:
	struct FOrionHUDLogMessageData                MessageData;                                       // 0x0200(0x0028)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionUserWidget_LogMessage">();
	}
	static class UOrionUserWidget_LogMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionUserWidget_LogMessage>();
	}
};
static_assert(alignof(UOrionUserWidget_LogMessage) == 0x000008, "Wrong alignment on UOrionUserWidget_LogMessage");
static_assert(sizeof(UOrionUserWidget_LogMessage) == 0x000228, "Wrong size on UOrionUserWidget_LogMessage");
static_assert(offsetof(UOrionUserWidget_LogMessage, MessageData) == 0x000200, "Member 'UOrionUserWidget_LogMessage::MessageData' has a wrong offset!");

// Class OrionGame.BotObjective_LaneStructure
// 0x0028 (0x0158 - 0x0130)
#pragma pack(push, 0x1)
class alignas(0x08) UBotObjective_LaneStructure : public UBotObjective
{
public:
	class AOrionDamageableObjective_Base*         GoalActor;                                         // 0x0130(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_138[0x20];                                     // 0x0138(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotObjective_LaneStructure">();
	}
	static class UBotObjective_LaneStructure* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotObjective_LaneStructure>();
	}
};
#pragma pack(pop)
static_assert(alignof(UBotObjective_LaneStructure) == 0x000008, "Wrong alignment on UBotObjective_LaneStructure");
static_assert(sizeof(UBotObjective_LaneStructure) == 0x000158, "Wrong size on UBotObjective_LaneStructure");
static_assert(offsetof(UBotObjective_LaneStructure, GoalActor) == 0x000130, "Member 'UBotObjective_LaneStructure::GoalActor' has a wrong offset!");

// Class OrionGame.OrionGameplayCueNotify_BeamAttachedSoundAndFX
// 0x0040 (0x0410 - 0x03D0)
class AOrionGameplayCueNotify_BeamAttachedSoundAndFX final : public AOrionGameplayCueNotify_Actor
{
public:
	class FName                                   SocketName_BeamSource;                             // 0x03C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Audio_FadeOutDuration;                             // 0x03D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Audio_FadeVolumeLevel;                             // 0x03D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Audio_Cue;                                         // 0x03D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        PS_Template_Beam;                                  // 0x03E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor_BeamEndPointTarget;                          // 0x03E8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName_BeamEndPointTarget;                     // 0x03F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               PS_Loop_Beam;                                      // 0x03F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAudioComponent*                        Audio_Loop;                                        // 0x0400(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitialized;                                      // 0x0408(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_409[0x7];                                      // 0x0409(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameplayCueNotify_BeamAttachedSoundAndFX">();
	}
	static class AOrionGameplayCueNotify_BeamAttachedSoundAndFX* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionGameplayCueNotify_BeamAttachedSoundAndFX>();
	}
};
static_assert(alignof(AOrionGameplayCueNotify_BeamAttachedSoundAndFX) == 0x000010, "Wrong alignment on AOrionGameplayCueNotify_BeamAttachedSoundAndFX");
static_assert(sizeof(AOrionGameplayCueNotify_BeamAttachedSoundAndFX) == 0x000410, "Wrong size on AOrionGameplayCueNotify_BeamAttachedSoundAndFX");
static_assert(offsetof(AOrionGameplayCueNotify_BeamAttachedSoundAndFX, SocketName_BeamSource) == 0x0003C8, "Member 'AOrionGameplayCueNotify_BeamAttachedSoundAndFX::SocketName_BeamSource' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_BeamAttachedSoundAndFX, Audio_FadeOutDuration) == 0x0003D0, "Member 'AOrionGameplayCueNotify_BeamAttachedSoundAndFX::Audio_FadeOutDuration' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_BeamAttachedSoundAndFX, Audio_FadeVolumeLevel) == 0x0003D4, "Member 'AOrionGameplayCueNotify_BeamAttachedSoundAndFX::Audio_FadeVolumeLevel' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_BeamAttachedSoundAndFX, Audio_Cue) == 0x0003D8, "Member 'AOrionGameplayCueNotify_BeamAttachedSoundAndFX::Audio_Cue' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_BeamAttachedSoundAndFX, PS_Template_Beam) == 0x0003E0, "Member 'AOrionGameplayCueNotify_BeamAttachedSoundAndFX::PS_Template_Beam' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_BeamAttachedSoundAndFX, Actor_BeamEndPointTarget) == 0x0003E8, "Member 'AOrionGameplayCueNotify_BeamAttachedSoundAndFX::Actor_BeamEndPointTarget' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_BeamAttachedSoundAndFX, SocketName_BeamEndPointTarget) == 0x0003F0, "Member 'AOrionGameplayCueNotify_BeamAttachedSoundAndFX::SocketName_BeamEndPointTarget' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_BeamAttachedSoundAndFX, PS_Loop_Beam) == 0x0003F8, "Member 'AOrionGameplayCueNotify_BeamAttachedSoundAndFX::PS_Loop_Beam' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_BeamAttachedSoundAndFX, Audio_Loop) == 0x000400, "Member 'AOrionGameplayCueNotify_BeamAttachedSoundAndFX::Audio_Loop' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_BeamAttachedSoundAndFX, bInitialized) == 0x000408, "Member 'AOrionGameplayCueNotify_BeamAttachedSoundAndFX::bInitialized' has a wrong offset!");

// Class OrionGame.BotObjective_WholeLane
// 0x0028 (0x0180 - 0x0158)
class UBotObjective_WholeLane : public UBotObjective_LaneStructure
{
public:
	TArray<class AOrionDamageableObjective_Base*> DefensiveObjectiveActors;                          // 0x0158(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class AOrionDamageableObjective_Base*> OffensiveObjectiveActors;                          // 0x0168(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void AttackTower(class UBotPlaybook* Playbook, EAITowerClassification Tower, EAIGenericLocation Location);
	static void DefendTower(class UBotPlaybook* Playbook, EAITowerClassification Tower, EAIGenericLocation Location);
	static void PushLane(class UBotPlaybook* Playbook, EAIGenericLocation Lane, float ToLaneProgress);
	static void TowerObjective(class UBotPlaybook* Playbook, EAITowerClassification Tower, EAIOwnership Ownership, EAIGenericLocation Location);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotObjective_WholeLane">();
	}
	static class UBotObjective_WholeLane* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotObjective_WholeLane>();
	}
};
static_assert(alignof(UBotObjective_WholeLane) == 0x000008, "Wrong alignment on UBotObjective_WholeLane");
static_assert(sizeof(UBotObjective_WholeLane) == 0x000180, "Wrong size on UBotObjective_WholeLane");
static_assert(offsetof(UBotObjective_WholeLane, DefensiveObjectiveActors) == 0x000158, "Member 'UBotObjective_WholeLane::DefensiveObjectiveActors' has a wrong offset!");
static_assert(offsetof(UBotObjective_WholeLane, OffensiveObjectiveActors) == 0x000168, "Member 'UBotObjective_WholeLane::OffensiveObjectiveActors' has a wrong offset!");

// Class OrionGame.BotObjective_AttackJungleCamp
// 0x0020 (0x0150 - 0x0130)
class UBotObjective_AttackJungleCamp final : public UBotObjective
{
public:
	class UOrionAIMinionAggroManager*             MinionAggroManager;                                // 0x0130(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AOrionCharAISpawner_Jungle*             CampSpawner;                                       // 0x0138(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEnvQuery*                              PositioningEQSQuery;                               // 0x0140(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ClearCamp(class UBotPlaybook* Playbook, EAICampType Camp, EAIGenericLocation Location, EAIOwnership Ownership, uint8 MinCreeps, bool bCanBeAbandonedForSameType, float MaxDistance, bool bFinishClearing);
	static void GroupAttackCamp(class UBotPlaybook* Playbook, EAICampType Camp, int32 MinAgents, bool bFinishClearing);

	void OnCampFinishedSpawning(class AOrionCharAISpawner* AISpawner);
	void OnCampKilled(class AOrionCharAISpawner* AISpawner, class AController* Killer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotObjective_AttackJungleCamp">();
	}
	static class UBotObjective_AttackJungleCamp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotObjective_AttackJungleCamp>();
	}
};
static_assert(alignof(UBotObjective_AttackJungleCamp) == 0x000008, "Wrong alignment on UBotObjective_AttackJungleCamp");
static_assert(sizeof(UBotObjective_AttackJungleCamp) == 0x000150, "Wrong size on UBotObjective_AttackJungleCamp");
static_assert(offsetof(UBotObjective_AttackJungleCamp, MinionAggroManager) == 0x000130, "Member 'UBotObjective_AttackJungleCamp::MinionAggroManager' has a wrong offset!");
static_assert(offsetof(UBotObjective_AttackJungleCamp, CampSpawner) == 0x000138, "Member 'UBotObjective_AttackJungleCamp::CampSpawner' has a wrong offset!");
static_assert(offsetof(UBotObjective_AttackJungleCamp, PositioningEQSQuery) == 0x000140, "Member 'UBotObjective_AttackJungleCamp::PositioningEQSQuery' has a wrong offset!");

// Class OrionGame.OrionSlottedComponentQuantityWidget
// 0x0008 (0x0208 - 0x0200)
class UOrionSlottedComponentQuantityWidget final : public UUserWidget
{
public:
	class UOrionTextBlock*                        Text_Quantity;                                     // 0x0200(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionSlottedComponentQuantityWidget">();
	}
	static class UOrionSlottedComponentQuantityWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionSlottedComponentQuantityWidget>();
	}
};
static_assert(alignof(UOrionSlottedComponentQuantityWidget) == 0x000008, "Wrong alignment on UOrionSlottedComponentQuantityWidget");
static_assert(sizeof(UOrionSlottedComponentQuantityWidget) == 0x000208, "Wrong size on UOrionSlottedComponentQuantityWidget");
static_assert(offsetof(UOrionSlottedComponentQuantityWidget, Text_Quantity) == 0x000200, "Member 'UOrionSlottedComponentQuantityWidget::Text_Quantity' has a wrong offset!");

// Class OrionGame.BotObjective_PlaceWard
// 0x0020 (0x0150 - 0x0130)
class UBotObjective_PlaceWard final : public UBotObjective
{
public:
	TArray<class AAIWardPlacement*>               WardSpots;                                         // 0x0130(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class AAIWardPlacement*                       TopSpot;                                           // 0x0140(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void PlaceWard(class UBotPlaybook* Playbook, EAIMapSide MapSide, EAIWardLocation Location);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotObjective_PlaceWard">();
	}
	static class UBotObjective_PlaceWard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotObjective_PlaceWard>();
	}
};
static_assert(alignof(UBotObjective_PlaceWard) == 0x000008, "Wrong alignment on UBotObjective_PlaceWard");
static_assert(sizeof(UBotObjective_PlaceWard) == 0x000150, "Wrong size on UBotObjective_PlaceWard");
static_assert(offsetof(UBotObjective_PlaceWard, WardSpots) == 0x000130, "Member 'UBotObjective_PlaceWard::WardSpots' has a wrong offset!");
static_assert(offsetof(UBotObjective_PlaceWard, TopSpot) == 0x000140, "Member 'UBotObjective_PlaceWard::TopSpot' has a wrong offset!");

// Class OrionGame.OrionVisionActorInterface
// 0x0000 (0x0028 - 0x0028)
class IOrionVisionActorInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionVisionActorInterface">();
	}
	static class IOrionVisionActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOrionVisionActorInterface>();
	}
};
static_assert(alignof(IOrionVisionActorInterface) == 0x000008, "Wrong alignment on IOrionVisionActorInterface");
static_assert(sizeof(IOrionVisionActorInterface) == 0x000028, "Wrong size on IOrionVisionActorInterface");

// Class OrionGame.BotObjective_AttackRefinery
// 0x0010 (0x0140 - 0x0130)
class UBotObjective_AttackRefinery final : public UBotObjective
{
public:
	class AOrionJungleRefinery*                   Refinery;                                          // 0x0130(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_138[0x8];                                      // 0x0138(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotObjective_AttackRefinery">();
	}
	static class UBotObjective_AttackRefinery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotObjective_AttackRefinery>();
	}
};
static_assert(alignof(UBotObjective_AttackRefinery) == 0x000008, "Wrong alignment on UBotObjective_AttackRefinery");
static_assert(sizeof(UBotObjective_AttackRefinery) == 0x000140, "Wrong size on UBotObjective_AttackRefinery");
static_assert(offsetof(UBotObjective_AttackRefinery, Refinery) == 0x000130, "Member 'UBotObjective_AttackRefinery::Refinery' has a wrong offset!");

// Class OrionGame.OrionGameplayCueNotify_Burst_Latent
// 0x0340 (0x0710 - 0x03D0)
class AOrionGameplayCueNotify_Burst_Latent : public AOrionGameplayCueNotify_Actor
{
public:
	struct FOrionBurstEffectData                  BurstEffectData_Default;                           // 0x03C8(0x0140)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<EPhysicalSurface, struct FOrionBurstEffectData> BurstEffectData_PerMaterialMap;                    // 0x0508(0x0050)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTraceInfo                  BurstTrace;                                        // 0x0558(0x00A0)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               PS_Burst;                                          // 0x05F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      PSNiagara_Burst;                                   // 0x0600(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 CachedTarget;                                      // 0x0608(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bMovedEffectDataToStructFormat : 1;                // 0x0610(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_611[0x7];                                      // 0x0611(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayCueParticleInfo               BurstParticleEffect;                               // 0x0618(0x0040)(Deprecated, NativeAccessSpecifierPrivate)
	struct FGameplayCueAudioInfo                  BurstSound;                                        // 0x0658(0x0018)(Deprecated, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGameplayCueCameraShakeInfo            BurstCameraShake;                                  // 0x0670(0x0028)(Deprecated, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGameplayCueCameraLensEffectInfo       BurstCameraLensEffect;                             // 0x0698(0x0018)(Deprecated, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGameplayCueForceFeedbackInfo          BurstForceFeedbackEffect;                          // 0x06B0(0x0018)(Deprecated, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGameplayCueDecalInfo                  BurstDecal;                                        // 0x06C8(0x0038)(Deprecated, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGameplayCueStencilDecalInfo           BurstStencilDecal;                                 // 0x0700(0x0010)(Deprecated, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void K2_OnExecute(class AActor* MyTarget, const struct FGameplayCueParameters& Parameters, class UParticleSystemComponent* BurstParticleSystems, const TArray<class UParticleSystemComponent*>& AdditionalParticleSystems, class UNiagaraComponent* BurstNiagaraParticleSystems, const TArray<class UNiagaraComponent*>& AdditionalNiagaraParticleSystems);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameplayCueNotify_Burst_Latent">();
	}
	static class AOrionGameplayCueNotify_Burst_Latent* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionGameplayCueNotify_Burst_Latent>();
	}
};
static_assert(alignof(AOrionGameplayCueNotify_Burst_Latent) == 0x000010, "Wrong alignment on AOrionGameplayCueNotify_Burst_Latent");
static_assert(sizeof(AOrionGameplayCueNotify_Burst_Latent) == 0x000710, "Wrong size on AOrionGameplayCueNotify_Burst_Latent");
static_assert(offsetof(AOrionGameplayCueNotify_Burst_Latent, BurstEffectData_Default) == 0x0003C8, "Member 'AOrionGameplayCueNotify_Burst_Latent::BurstEffectData_Default' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Burst_Latent, BurstEffectData_PerMaterialMap) == 0x000508, "Member 'AOrionGameplayCueNotify_Burst_Latent::BurstEffectData_PerMaterialMap' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Burst_Latent, BurstTrace) == 0x000558, "Member 'AOrionGameplayCueNotify_Burst_Latent::BurstTrace' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Burst_Latent, PS_Burst) == 0x0005F8, "Member 'AOrionGameplayCueNotify_Burst_Latent::PS_Burst' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Burst_Latent, PSNiagara_Burst) == 0x000600, "Member 'AOrionGameplayCueNotify_Burst_Latent::PSNiagara_Burst' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Burst_Latent, CachedTarget) == 0x000608, "Member 'AOrionGameplayCueNotify_Burst_Latent::CachedTarget' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Burst_Latent, BurstParticleEffect) == 0x000618, "Member 'AOrionGameplayCueNotify_Burst_Latent::BurstParticleEffect' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Burst_Latent, BurstSound) == 0x000658, "Member 'AOrionGameplayCueNotify_Burst_Latent::BurstSound' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Burst_Latent, BurstCameraShake) == 0x000670, "Member 'AOrionGameplayCueNotify_Burst_Latent::BurstCameraShake' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Burst_Latent, BurstCameraLensEffect) == 0x000698, "Member 'AOrionGameplayCueNotify_Burst_Latent::BurstCameraLensEffect' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Burst_Latent, BurstForceFeedbackEffect) == 0x0006B0, "Member 'AOrionGameplayCueNotify_Burst_Latent::BurstForceFeedbackEffect' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Burst_Latent, BurstDecal) == 0x0006C8, "Member 'AOrionGameplayCueNotify_Burst_Latent::BurstDecal' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Burst_Latent, BurstStencilDecal) == 0x000700, "Member 'AOrionGameplayCueNotify_Burst_Latent::BurstStencilDecal' has a wrong offset!");

// Class OrionGame.BotObjective_Patrol
// 0x0020 (0x0150 - 0x0130)
class UBotObjective_Patrol final : public UBotObjective
{
public:
	struct FAIRouteMarkup                         Route;                                             // 0x0130(0x0018)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void Patrol(class UBotPlaybook* Playbook);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotObjective_Patrol">();
	}
	static class UBotObjective_Patrol* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotObjective_Patrol>();
	}
};
static_assert(alignof(UBotObjective_Patrol) == 0x000008, "Wrong alignment on UBotObjective_Patrol");
static_assert(sizeof(UBotObjective_Patrol) == 0x000150, "Wrong size on UBotObjective_Patrol");
static_assert(offsetof(UBotObjective_Patrol, Route) == 0x000130, "Member 'UBotObjective_Patrol::Route' has a wrong offset!");

// Class OrionGame.BotObjective_AFKReaction
// 0x0000 (0x0130 - 0x0130)
class UBotObjective_AFKReaction final : public UBotObjective
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotObjective_AFKReaction">();
	}
	static class UBotObjective_AFKReaction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotObjective_AFKReaction>();
	}
};
static_assert(alignof(UBotObjective_AFKReaction) == 0x000008, "Wrong alignment on UBotObjective_AFKReaction");
static_assert(sizeof(UBotObjective_AFKReaction) == 0x000130, "Wrong size on UBotObjective_AFKReaction");

// Class OrionGame.OrionDecalManager
// 0x0030 (0x0348 - 0x0318)
class AOrionDecalManager final : public AInfo
{
public:
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOrionDecalTarget>              Targets;                                           // 0x0320(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_330[0x8];                                      // 0x0330(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOrionAutoRemovedDecal>         AutoRemovalDecals;                                 // 0x0338(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionDecalManager">();
	}
	static class AOrionDecalManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionDecalManager>();
	}
};
static_assert(alignof(AOrionDecalManager) == 0x000008, "Wrong alignment on AOrionDecalManager");
static_assert(sizeof(AOrionDecalManager) == 0x000348, "Wrong size on AOrionDecalManager");
static_assert(offsetof(AOrionDecalManager, Targets) == 0x000320, "Member 'AOrionDecalManager::Targets' has a wrong offset!");
static_assert(offsetof(AOrionDecalManager, AutoRemovalDecals) == 0x000338, "Member 'AOrionDecalManager::AutoRemovalDecals' has a wrong offset!");

// Class OrionGame.BotObjective_GroupPushLane
// 0x0000 (0x0180 - 0x0180)
class UBotObjective_GroupPushLane final : public UBotObjective_WholeLane
{
public:
	static void GroupPushLane(class UBotPlaybook* Playbook, EAIGenericLocation Location, float ToLaneProgress, int32 MinAgents);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotObjective_GroupPushLane">();
	}
	static class UBotObjective_GroupPushLane* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotObjective_GroupPushLane>();
	}
};
static_assert(alignof(UBotObjective_GroupPushLane) == 0x000008, "Wrong alignment on UBotObjective_GroupPushLane");
static_assert(sizeof(UBotObjective_GroupPushLane) == 0x000180, "Wrong size on UBotObjective_GroupPushLane");

// Class OrionGame.GameplayTagTableManager
// 0x0068 (0x0098 - 0x0030)
class UGameplayTagTableManager final : public UDataAsset
{
public:
	TArray<struct FManagedGameplayTagDataTableItem> Tables;                                            // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x58];                                      // 0x0040(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTagTableManager">();
	}
	static class UGameplayTagTableManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTagTableManager>();
	}
};
static_assert(alignof(UGameplayTagTableManager) == 0x000008, "Wrong alignment on UGameplayTagTableManager");
static_assert(sizeof(UGameplayTagTableManager) == 0x000098, "Wrong size on UGameplayTagTableManager");
static_assert(offsetof(UGameplayTagTableManager, Tables) == 0x000030, "Member 'UGameplayTagTableManager::Tables' has a wrong offset!");

// Class OrionGame.BotObjective_Gank
// 0x0010 (0x0140 - 0x0130)
class UBotObjective_Gank final : public UBotObjective
{
public:
	class AOrionCharHero*                         SpatialGankTargetCandidate;                        // 0x0130(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AOrionCharHero*                         HealthGankTargetCandidate;                         // 0x0138(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static void Gank(class UBotPlaybook* Playbook, float MaxDistance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotObjective_Gank">();
	}
	static class UBotObjective_Gank* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotObjective_Gank>();
	}
};
static_assert(alignof(UBotObjective_Gank) == 0x000008, "Wrong alignment on UBotObjective_Gank");
static_assert(sizeof(UBotObjective_Gank) == 0x000140, "Wrong size on UBotObjective_Gank");
static_assert(offsetof(UBotObjective_Gank, SpatialGankTargetCandidate) == 0x000130, "Member 'UBotObjective_Gank::SpatialGankTargetCandidate' has a wrong offset!");
static_assert(offsetof(UBotObjective_Gank, HealthGankTargetCandidate) == 0x000138, "Member 'UBotObjective_Gank::HealthGankTargetCandidate' has a wrong offset!");

// Class OrionGame.OrionFunctionalTestConfig
// 0x0048 (0x0070 - 0x0028)
class UOrionFunctionalTestConfig final : public UObject
{
public:
	TSubclassOf<class AOrionCharHero>             PlayerHero;                                        // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HeroSkinName;                                      // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         TestSetupCheats;                                   // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<class FString>                         CommonCheats;                                      // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<struct FStaticActorReference>          StaticActorReferences;                             // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionFunctionalTestConfig">();
	}
	static class UOrionFunctionalTestConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionFunctionalTestConfig>();
	}
};
static_assert(alignof(UOrionFunctionalTestConfig) == 0x000008, "Wrong alignment on UOrionFunctionalTestConfig");
static_assert(sizeof(UOrionFunctionalTestConfig) == 0x000070, "Wrong size on UOrionFunctionalTestConfig");
static_assert(offsetof(UOrionFunctionalTestConfig, PlayerHero) == 0x000028, "Member 'UOrionFunctionalTestConfig::PlayerHero' has a wrong offset!");
static_assert(offsetof(UOrionFunctionalTestConfig, HeroSkinName) == 0x000030, "Member 'UOrionFunctionalTestConfig::HeroSkinName' has a wrong offset!");
static_assert(offsetof(UOrionFunctionalTestConfig, TestSetupCheats) == 0x000040, "Member 'UOrionFunctionalTestConfig::TestSetupCheats' has a wrong offset!");
static_assert(offsetof(UOrionFunctionalTestConfig, CommonCheats) == 0x000050, "Member 'UOrionFunctionalTestConfig::CommonCheats' has a wrong offset!");
static_assert(offsetof(UOrionFunctionalTestConfig, StaticActorReferences) == 0x000060, "Member 'UOrionFunctionalTestConfig::StaticActorReferences' has a wrong offset!");

// Class OrionGame.OrionDamageableActor
// 0x0140 (0x0528 - 0x03E8)
class AOrionDamageableActor : public AOrionBaseActor
{
public:
	uint8                                         Pad_3E8[0x38];                                     // 0x03E8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   DeathHandler;                                      // 0x0420(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	bool                                          InitializeStartingLevelWithAbilityLevel;           // 0x0430(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_431[0x7];                                      // 0x0431(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ActorDataName;                                     // 0x0438(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  ActorTags;                                         // 0x0440(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  LootSourceTag;                                     // 0x0460(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  LootAssetTag;                                      // 0x0480(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UOrionAbilitySet*                       SharedAbilities;                                   // 0x04A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOrionAbilitySet*                       Abilities;                                         // 0x04A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrionTargetType                              TargetType;                                        // 0x04B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrionVisionType                              VisionType;                                        // 0x04B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldIgnoreCollisionWithTeamTargeting;           // 0x04B2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanBeHitWhileInShadowPlane;                       // 0x04B3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanBeHitByMinions;                                // 0x04B4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDying;                                          // 0x04B5(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B6[0x2];                                      // 0x04B6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class AController*                            KillerController;                                  // 0x04B8(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bPerceivedByBots : 1;                              // 0x04C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_4C1[0x3];                                      // 0x04C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CleanupTimer;                                      // 0x04C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C8[0x38];                                     // 0x04C8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAbilitySystemComponent*           AbilitySystemComponent;                            // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionHealthSet*                        HealthSet;                                         // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionXPSet*                            XPSet;                                             // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionVisionSet*                        VisionSet;                                         // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_520[0x8];                                      // 0x0520(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CustomMatch_RemoveOnDeath(const struct FActiveGameplayEffect& Effect);
	TArray<class UMeshComponent*> GetHighlightableMeshes();
	void K2_AddGameplayCue(const struct FGameplayTag& GameplayCueTag);
	void K2_ExecuteGameplayCue(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Parameters);
	void K2_ExecuteGameplayCueOnTarget(class AController* Target, const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Parameters);
	void K2_RemoveGameplayCue(const struct FGameplayTag& GameplayCueTag);
	void OnDamageTaken(float Damage, class AActor* DamageInstigator);
	void OnDeath();
	void OnHealthReceived(float HealthReceived, class AActor* HealthReceivedInstigator);
	void OnRep_Dying();
	void OnShieldDamageTaken(float Damage, class AActor* DamageInstigator);
	void OnShieldReceived(float ShieldReceived, class AActor* ShieldReceivedInstigator);
	void SetVisionRadius(float Radius);

	float GetHealth() const;
	float GetHealthPercent() const;
	class AController* GetKiller() const;
	float GetMaxHealth() const;
	float GetMaxShield() const;
	float GetShield() const;
	float GetShieldPercent() const;
	struct FGameplayCueParameters MakeGameplayCueParameters() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionDamageableActor">();
	}
	static class AOrionDamageableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionDamageableActor>();
	}
};
static_assert(alignof(AOrionDamageableActor) == 0x000008, "Wrong alignment on AOrionDamageableActor");
static_assert(sizeof(AOrionDamageableActor) == 0x000528, "Wrong size on AOrionDamageableActor");
static_assert(offsetof(AOrionDamageableActor, DeathHandler) == 0x000420, "Member 'AOrionDamageableActor::DeathHandler' has a wrong offset!");
static_assert(offsetof(AOrionDamageableActor, InitializeStartingLevelWithAbilityLevel) == 0x000430, "Member 'AOrionDamageableActor::InitializeStartingLevelWithAbilityLevel' has a wrong offset!");
static_assert(offsetof(AOrionDamageableActor, ActorDataName) == 0x000438, "Member 'AOrionDamageableActor::ActorDataName' has a wrong offset!");
static_assert(offsetof(AOrionDamageableActor, ActorTags) == 0x000440, "Member 'AOrionDamageableActor::ActorTags' has a wrong offset!");
static_assert(offsetof(AOrionDamageableActor, LootSourceTag) == 0x000460, "Member 'AOrionDamageableActor::LootSourceTag' has a wrong offset!");
static_assert(offsetof(AOrionDamageableActor, LootAssetTag) == 0x000480, "Member 'AOrionDamageableActor::LootAssetTag' has a wrong offset!");
static_assert(offsetof(AOrionDamageableActor, SharedAbilities) == 0x0004A0, "Member 'AOrionDamageableActor::SharedAbilities' has a wrong offset!");
static_assert(offsetof(AOrionDamageableActor, Abilities) == 0x0004A8, "Member 'AOrionDamageableActor::Abilities' has a wrong offset!");
static_assert(offsetof(AOrionDamageableActor, TargetType) == 0x0004B0, "Member 'AOrionDamageableActor::TargetType' has a wrong offset!");
static_assert(offsetof(AOrionDamageableActor, VisionType) == 0x0004B1, "Member 'AOrionDamageableActor::VisionType' has a wrong offset!");
static_assert(offsetof(AOrionDamageableActor, bShouldIgnoreCollisionWithTeamTargeting) == 0x0004B2, "Member 'AOrionDamageableActor::bShouldIgnoreCollisionWithTeamTargeting' has a wrong offset!");
static_assert(offsetof(AOrionDamageableActor, bCanBeHitWhileInShadowPlane) == 0x0004B3, "Member 'AOrionDamageableActor::bCanBeHitWhileInShadowPlane' has a wrong offset!");
static_assert(offsetof(AOrionDamageableActor, bCanBeHitByMinions) == 0x0004B4, "Member 'AOrionDamageableActor::bCanBeHitByMinions' has a wrong offset!");
static_assert(offsetof(AOrionDamageableActor, bIsDying) == 0x0004B5, "Member 'AOrionDamageableActor::bIsDying' has a wrong offset!");
static_assert(offsetof(AOrionDamageableActor, KillerController) == 0x0004B8, "Member 'AOrionDamageableActor::KillerController' has a wrong offset!");
static_assert(offsetof(AOrionDamageableActor, CleanupTimer) == 0x0004C4, "Member 'AOrionDamageableActor::CleanupTimer' has a wrong offset!");
static_assert(offsetof(AOrionDamageableActor, AbilitySystemComponent) == 0x000500, "Member 'AOrionDamageableActor::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(AOrionDamageableActor, HealthSet) == 0x000508, "Member 'AOrionDamageableActor::HealthSet' has a wrong offset!");
static_assert(offsetof(AOrionDamageableActor, XPSet) == 0x000510, "Member 'AOrionDamageableActor::XPSet' has a wrong offset!");
static_assert(offsetof(AOrionDamageableActor, VisionSet) == 0x000518, "Member 'AOrionDamageableActor::VisionSet' has a wrong offset!");

// Class OrionGame.OrionDamageableObjective_Base
// 0x0490 (0x09B8 - 0x0528)
#pragma pack(push, 0x1)
class alignas(0x08) AOrionDamageableObjective_Base : public AOrionDamageableActor
{
public:
	uint8                                         Pad_528[0x248];                                    // 0x0528(0x0248)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionObjectiveCues                    ObjectiveGameplayCues;                             // 0x0770(0x0038)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         StartEventDelayTimer;                              // 0x07A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7AC[0x2];                                      // 0x07AC(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bMatchHasStarted;                                  // 0x07AE(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7AF[0x1];                                      // 0x07AF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         BackDoorProtectionDelayTime;                       // 0x07B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bCanRevive;                                        // 0x07D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bObjectiveVulnerable;                              // 0x07D9(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDependenciesChecked;                              // 0x07DA(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7DB[0x1];                                      // 0x07DB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RemainingReviveTime;                               // 0x07DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReviveTimeEnd;                                     // 0x07E0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7E4[0x4];                                      // 0x07E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FObjectiveBackdoorProtection           ObjectiveBackdoorProtection;                       // 0x07E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<EOrionAbilityBinding>                  AbilitiesToActivate;                               // 0x07F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         SightLocationZOffset;                              // 0x0808(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_80C[0x4];                                      // 0x080C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UGameplayEffect>>    SpawnedGameplayEffectsToApply;                     // 0x0810(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UGameplayEffect>>    MatchStartGameplayEffectsToApply;                  // 0x0820(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UGameplayEffect>>    RevivedGameplayEffectsToApply;                     // 0x0830(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FObjectiveDependency>           Dependencies;                                      // 0x0840(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FOrionFilterAndEffectsContainer        ObjectiveTargetingFilter;                          // 0x0850(0x0020)(Edit, BlueprintVisible, Net, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	uint8                                         Pad_870[0xC];                                      // 0x0870(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IndicatorZOffset;                                  // 0x087C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_880[0x8];                                      // 0x0880(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionObjectiveData*                    ObjectiveData;                                     // 0x0888(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRelevantToStrategicAI;                            // 0x0890(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPunchHolesInNavmesh;                              // 0x0891(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_892[0xA];                                      // 0x0892(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EffectiveAttackRange;                              // 0x089C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  CurrentTarget;                                     // 0x08A0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  PreviousTarget;                                    // 0x08A8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8B0[0x8];                                      // 0x08B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EOrionTargetType>                      TargetTypePriority;                                // 0x08B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayTag>                   MinionTagPriority;                                 // 0x08C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class AVolume*                                TargetingVolume;                                   // 0x08D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumberOfTargetsToAttack;                           // 0x08E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8E4[0x4];                                      // 0x08E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        TargetingTowerBeamEffect;                          // 0x08E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        TargetingPlayerAttchedEffect;                      // 0x08F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BeamSocketName;                                    // 0x08F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_900[0x28];                                     // 0x0900(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionObjectiveSet*                     ObjectiveSet;                                      // 0x0928(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionCombatSet*                        CombatSet;                                         // 0x0930(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystemComponent*               TargetingTowerBeamComp;                            // 0x0938(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystemComponent*               TargetingPlayerAttchedComp;                        // 0x0940(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionNavTowerComponent*                NavModifierComp;                                   // 0x0948(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_950[0x68];                                     // 0x0950(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyBackDoorProtection();
	bool CanTargetActor(class AActor* InTarget, bool bInIgnoreHeight);
	void GetAllValidTargets(TArray<class AActor*>* OutTargetArray, bool bInIgnoreHeight);
	class UMeshComponent* GetBaseAttackingMesh();
	class FName GetBaseAttackingSocketName();
	int32 GetNumberOfTargetsToAttack();
	void GetTargetsToAttack(TArray<class AActor*>* OutTargetArray);
	void HandleCallForHelp(class AActor* DamagedActor, class AActor* AttackingActor, const struct FGameplayEffectSpec& EffectSpec);
	void HandleMatchEnded();
	void HandleMatchStarted();
	void HandleTargetActorTeamChanged(class AOrionChar* TeamChangeChar, EOrionTeam NewTeamNum);
	void LostCurrentTarget();
	void ObjectiveStartUp();
	void OnBackdoorProtectionChanged(bool bOn);
	void OnRep_Dying();
	void OnRep_MatchHasStarted();
	void OnRep_ObjectiveVulnerable();
	void OnRep_TargetingVolume(class AVolume* OldTargetingVolume);
	void OnSelfRevive();
	void ReviveSelf();
	void SetCurrentTarget(class AActor* InNewTarget);
	void SetTargetingBeamComp(class UParticleSystemComponent* InTargetingBeam);
	void TargetAcquired(class AActor* NewTarget);
	void TargetEndOverlap(class AActor* SelfActor, class AActor* OtherActor);
	void TargetStartOverlap(class AActor* SelfActor, class AActor* OtherActor);
	void UpdateTargeting(bool bInIgnoreHeight);

	float GetAttackHeight() const;
	float GetAttackRadius() const;
	float GetAttackSpeed() const;
	class UCapsuleComponent* GetCollisionCapsuleComponent() const;
	class AActor* GetCurrentTarget() const;
	class FText GetDisplayName() const;
	float GetEffectiveAttackRange() const;
	TSoftObjectPtr<class UObject> GetIcon() const;
	int32 GetNumberOfTargetedMinions() const;
	float GetReviveSelfTimer() const;
	float GetTargetingTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionDamageableObjective_Base">();
	}
	static class AOrionDamageableObjective_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionDamageableObjective_Base>();
	}
};
#pragma pack(pop)
static_assert(alignof(AOrionDamageableObjective_Base) == 0x000008, "Wrong alignment on AOrionDamageableObjective_Base");
static_assert(sizeof(AOrionDamageableObjective_Base) == 0x0009B8, "Wrong size on AOrionDamageableObjective_Base");
static_assert(offsetof(AOrionDamageableObjective_Base, ObjectiveGameplayCues) == 0x000770, "Member 'AOrionDamageableObjective_Base::ObjectiveGameplayCues' has a wrong offset!");
static_assert(offsetof(AOrionDamageableObjective_Base, StartEventDelayTimer) == 0x0007A8, "Member 'AOrionDamageableObjective_Base::StartEventDelayTimer' has a wrong offset!");
static_assert(offsetof(AOrionDamageableObjective_Base, bMatchHasStarted) == 0x0007AE, "Member 'AOrionDamageableObjective_Base::bMatchHasStarted' has a wrong offset!");
static_assert(offsetof(AOrionDamageableObjective_Base, BackDoorProtectionDelayTime) == 0x0007B0, "Member 'AOrionDamageableObjective_Base::BackDoorProtectionDelayTime' has a wrong offset!");
static_assert(offsetof(AOrionDamageableObjective_Base, bCanRevive) == 0x0007D8, "Member 'AOrionDamageableObjective_Base::bCanRevive' has a wrong offset!");
static_assert(offsetof(AOrionDamageableObjective_Base, bObjectiveVulnerable) == 0x0007D9, "Member 'AOrionDamageableObjective_Base::bObjectiveVulnerable' has a wrong offset!");
static_assert(offsetof(AOrionDamageableObjective_Base, bDependenciesChecked) == 0x0007DA, "Member 'AOrionDamageableObjective_Base::bDependenciesChecked' has a wrong offset!");
static_assert(offsetof(AOrionDamageableObjective_Base, RemainingReviveTime) == 0x0007DC, "Member 'AOrionDamageableObjective_Base::RemainingReviveTime' has a wrong offset!");
static_assert(offsetof(AOrionDamageableObjective_Base, ReviveTimeEnd) == 0x0007E0, "Member 'AOrionDamageableObjective_Base::ReviveTimeEnd' has a wrong offset!");
static_assert(offsetof(AOrionDamageableObjective_Base, ObjectiveBackdoorProtection) == 0x0007E8, "Member 'AOrionDamageableObjective_Base::ObjectiveBackdoorProtection' has a wrong offset!");
static_assert(offsetof(AOrionDamageableObjective_Base, AbilitiesToActivate) == 0x0007F8, "Member 'AOrionDamageableObjective_Base::AbilitiesToActivate' has a wrong offset!");
static_assert(offsetof(AOrionDamageableObjective_Base, SightLocationZOffset) == 0x000808, "Member 'AOrionDamageableObjective_Base::SightLocationZOffset' has a wrong offset!");
static_assert(offsetof(AOrionDamageableObjective_Base, SpawnedGameplayEffectsToApply) == 0x000810, "Member 'AOrionDamageableObjective_Base::SpawnedGameplayEffectsToApply' has a wrong offset!");
static_assert(offsetof(AOrionDamageableObjective_Base, MatchStartGameplayEffectsToApply) == 0x000820, "Member 'AOrionDamageableObjective_Base::MatchStartGameplayEffectsToApply' has a wrong offset!");
static_assert(offsetof(AOrionDamageableObjective_Base, RevivedGameplayEffectsToApply) == 0x000830, "Member 'AOrionDamageableObjective_Base::RevivedGameplayEffectsToApply' has a wrong offset!");
static_assert(offsetof(AOrionDamageableObjective_Base, Dependencies) == 0x000840, "Member 'AOrionDamageableObjective_Base::Dependencies' has a wrong offset!");
static_assert(offsetof(AOrionDamageableObjective_Base, ObjectiveTargetingFilter) == 0x000850, "Member 'AOrionDamageableObjective_Base::ObjectiveTargetingFilter' has a wrong offset!");
static_assert(offsetof(AOrionDamageableObjective_Base, IndicatorZOffset) == 0x00087C, "Member 'AOrionDamageableObjective_Base::IndicatorZOffset' has a wrong offset!");
static_assert(offsetof(AOrionDamageableObjective_Base, ObjectiveData) == 0x000888, "Member 'AOrionDamageableObjective_Base::ObjectiveData' has a wrong offset!");
static_assert(offsetof(AOrionDamageableObjective_Base, bRelevantToStrategicAI) == 0x000890, "Member 'AOrionDamageableObjective_Base::bRelevantToStrategicAI' has a wrong offset!");
static_assert(offsetof(AOrionDamageableObjective_Base, bPunchHolesInNavmesh) == 0x000891, "Member 'AOrionDamageableObjective_Base::bPunchHolesInNavmesh' has a wrong offset!");
static_assert(offsetof(AOrionDamageableObjective_Base, EffectiveAttackRange) == 0x00089C, "Member 'AOrionDamageableObjective_Base::EffectiveAttackRange' has a wrong offset!");
static_assert(offsetof(AOrionDamageableObjective_Base, CurrentTarget) == 0x0008A0, "Member 'AOrionDamageableObjective_Base::CurrentTarget' has a wrong offset!");
static_assert(offsetof(AOrionDamageableObjective_Base, PreviousTarget) == 0x0008A8, "Member 'AOrionDamageableObjective_Base::PreviousTarget' has a wrong offset!");
static_assert(offsetof(AOrionDamageableObjective_Base, TargetTypePriority) == 0x0008B8, "Member 'AOrionDamageableObjective_Base::TargetTypePriority' has a wrong offset!");
static_assert(offsetof(AOrionDamageableObjective_Base, MinionTagPriority) == 0x0008C8, "Member 'AOrionDamageableObjective_Base::MinionTagPriority' has a wrong offset!");
static_assert(offsetof(AOrionDamageableObjective_Base, TargetingVolume) == 0x0008D8, "Member 'AOrionDamageableObjective_Base::TargetingVolume' has a wrong offset!");
static_assert(offsetof(AOrionDamageableObjective_Base, NumberOfTargetsToAttack) == 0x0008E0, "Member 'AOrionDamageableObjective_Base::NumberOfTargetsToAttack' has a wrong offset!");
static_assert(offsetof(AOrionDamageableObjective_Base, TargetingTowerBeamEffect) == 0x0008E8, "Member 'AOrionDamageableObjective_Base::TargetingTowerBeamEffect' has a wrong offset!");
static_assert(offsetof(AOrionDamageableObjective_Base, TargetingPlayerAttchedEffect) == 0x0008F0, "Member 'AOrionDamageableObjective_Base::TargetingPlayerAttchedEffect' has a wrong offset!");
static_assert(offsetof(AOrionDamageableObjective_Base, BeamSocketName) == 0x0008F8, "Member 'AOrionDamageableObjective_Base::BeamSocketName' has a wrong offset!");
static_assert(offsetof(AOrionDamageableObjective_Base, ObjectiveSet) == 0x000928, "Member 'AOrionDamageableObjective_Base::ObjectiveSet' has a wrong offset!");
static_assert(offsetof(AOrionDamageableObjective_Base, CombatSet) == 0x000930, "Member 'AOrionDamageableObjective_Base::CombatSet' has a wrong offset!");
static_assert(offsetof(AOrionDamageableObjective_Base, TargetingTowerBeamComp) == 0x000938, "Member 'AOrionDamageableObjective_Base::TargetingTowerBeamComp' has a wrong offset!");
static_assert(offsetof(AOrionDamageableObjective_Base, TargetingPlayerAttchedComp) == 0x000940, "Member 'AOrionDamageableObjective_Base::TargetingPlayerAttchedComp' has a wrong offset!");
static_assert(offsetof(AOrionDamageableObjective_Base, NavModifierComp) == 0x000948, "Member 'AOrionDamageableObjective_Base::NavModifierComp' has a wrong offset!");

// Class OrionGame.OrionDamageableObjectiveTurret
// 0x0008 (0x09C0 - 0x09B8)
class AOrionDamageableObjectiveTurret : public AOrionDamageableObjective_Base
{
public:
	class USkeletalMeshComponent*                 Mesh;                                              // 0x09B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetSkeletalMesh(class USkeletalMeshComponent* InMesh);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionDamageableObjectiveTurret">();
	}
	static class AOrionDamageableObjectiveTurret* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionDamageableObjectiveTurret>();
	}
};
static_assert(alignof(AOrionDamageableObjectiveTurret) == 0x000008, "Wrong alignment on AOrionDamageableObjectiveTurret");
static_assert(sizeof(AOrionDamageableObjectiveTurret) == 0x0009C0, "Wrong size on AOrionDamageableObjectiveTurret");
static_assert(offsetof(AOrionDamageableObjectiveTurret, Mesh) == 0x0009B8, "Member 'AOrionDamageableObjectiveTurret::Mesh' has a wrong offset!");

// Class OrionGame.BotObjective_Recall
// 0x0010 (0x0140 - 0x0130)
class UBotObjective_Recall final : public UBotObjective
{
public:
	class UEnvQuery*                              TeleportLocationEQSQuery;                          // 0x0130(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_138[0x8];                                      // 0x0138(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void CardRecall(class UBotPlaybook* Playbook);
	static void CXPRecall(class UBotPlaybook* Playbook, uint8 MinCardPointsToRecall);
	static void GoldRecall(class UBotPlaybook* Playbook, float MinGoldToRecall);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotObjective_Recall">();
	}
	static class UBotObjective_Recall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotObjective_Recall>();
	}
};
static_assert(alignof(UBotObjective_Recall) == 0x000008, "Wrong alignment on UBotObjective_Recall");
static_assert(sizeof(UBotObjective_Recall) == 0x000140, "Wrong size on UBotObjective_Recall");
static_assert(offsetof(UBotObjective_Recall, TeleportLocationEQSQuery) == 0x000130, "Member 'UBotObjective_Recall::TeleportLocationEQSQuery' has a wrong offset!");

// Class OrionGame.BotObjective_Bodyguard
// 0x0010 (0x0140 - 0x0130)
class UBotObjective_Bodyguard final : public UBotObjective
{
public:
	uint8                                         Pad_130[0x10];                                     // 0x0130(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void BodyGuard(class UBotPlaybook* Playbook, const ELaneRoleSlot Role, const float TetherDistance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotObjective_Bodyguard">();
	}
	static class UBotObjective_Bodyguard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotObjective_Bodyguard>();
	}
};
static_assert(alignof(UBotObjective_Bodyguard) == 0x000008, "Wrong alignment on UBotObjective_Bodyguard");
static_assert(sizeof(UBotObjective_Bodyguard) == 0x000140, "Wrong size on UBotObjective_Bodyguard");

// Class OrionGame.OrionSuicide
// 0x0008 (0x0048 - 0x0040)
class UOrionSuicide final : public UGameplayEffectExecutionCalculation
{
public:
	TSubclassOf<class UGameplayEffect>            SuicideGE;                                         // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionSuicide">();
	}
	static class UOrionSuicide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionSuicide>();
	}
};
static_assert(alignof(UOrionSuicide) == 0x000008, "Wrong alignment on UOrionSuicide");
static_assert(sizeof(UOrionSuicide) == 0x000048, "Wrong size on UOrionSuicide");
static_assert(offsetof(UOrionSuicide, SuicideGE) == 0x000040, "Member 'UOrionSuicide::SuicideGE' has a wrong offset!");

// Class OrionGame.BotObjectiveGenerator
// 0x0008 (0x0030 - 0x0028)
class UBotObjectiveGenerator : public UObject
{
public:
	class UOrionAICommander*                      AICommander;                                       // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotObjectiveGenerator">();
	}
	static class UBotObjectiveGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotObjectiveGenerator>();
	}
};
static_assert(alignof(UBotObjectiveGenerator) == 0x000008, "Wrong alignment on UBotObjectiveGenerator");
static_assert(sizeof(UBotObjectiveGenerator) == 0x000030, "Wrong size on UBotObjectiveGenerator");
static_assert(offsetof(UBotObjectiveGenerator, AICommander) == 0x000028, "Member 'UBotObjectiveGenerator::AICommander' has a wrong offset!");

// Class OrionGame.OrionTargetingMode_Base
// 0x00D8 (0x03F0 - 0x0318)
class AOrionTargetingMode_Base : public AActor
{
public:
	struct FOrionActorFilter                      Filter;                                            // 0x0318(0x0060)(Edit, NativeAccessSpecifierPublic)
	bool                                          bSendPredictedTargetsToServer;                     // 0x0378(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInstantlyGenerateTargetDataOnServer;              // 0x0379(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTargetingModeValidationFailPolicy       ServerValidationFailPolicy;                        // 0x037A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37B[0x5];                                      // 0x037B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagRequirements               ConfirmTagRequirements;                            // 0x0380(0x0040)(Edit, NativeAccessSpecifierPublic)
	bool                                          bRequireTargetToConfirm;                           // 0x03C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFirstTargetIsPrimary;                             // 0x03C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowExternalTargetSwaps;                         // 0x03C2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C3[0x5];                                      // 0x03C3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOrionPotentialTarget>          PotentialTargets;                                  // 0x03C8(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         ValidTargets;                                      // 0x03D8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E8[0x8];                                      // 0x03E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const TArray<class AActor*> GetTargets() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTargetingMode_Base">();
	}
	static class AOrionTargetingMode_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionTargetingMode_Base>();
	}
};
static_assert(alignof(AOrionTargetingMode_Base) == 0x000008, "Wrong alignment on AOrionTargetingMode_Base");
static_assert(sizeof(AOrionTargetingMode_Base) == 0x0003F0, "Wrong size on AOrionTargetingMode_Base");
static_assert(offsetof(AOrionTargetingMode_Base, Filter) == 0x000318, "Member 'AOrionTargetingMode_Base::Filter' has a wrong offset!");
static_assert(offsetof(AOrionTargetingMode_Base, bSendPredictedTargetsToServer) == 0x000378, "Member 'AOrionTargetingMode_Base::bSendPredictedTargetsToServer' has a wrong offset!");
static_assert(offsetof(AOrionTargetingMode_Base, bInstantlyGenerateTargetDataOnServer) == 0x000379, "Member 'AOrionTargetingMode_Base::bInstantlyGenerateTargetDataOnServer' has a wrong offset!");
static_assert(offsetof(AOrionTargetingMode_Base, ServerValidationFailPolicy) == 0x00037A, "Member 'AOrionTargetingMode_Base::ServerValidationFailPolicy' has a wrong offset!");
static_assert(offsetof(AOrionTargetingMode_Base, ConfirmTagRequirements) == 0x000380, "Member 'AOrionTargetingMode_Base::ConfirmTagRequirements' has a wrong offset!");
static_assert(offsetof(AOrionTargetingMode_Base, bRequireTargetToConfirm) == 0x0003C0, "Member 'AOrionTargetingMode_Base::bRequireTargetToConfirm' has a wrong offset!");
static_assert(offsetof(AOrionTargetingMode_Base, bFirstTargetIsPrimary) == 0x0003C1, "Member 'AOrionTargetingMode_Base::bFirstTargetIsPrimary' has a wrong offset!");
static_assert(offsetof(AOrionTargetingMode_Base, bAllowExternalTargetSwaps) == 0x0003C2, "Member 'AOrionTargetingMode_Base::bAllowExternalTargetSwaps' has a wrong offset!");
static_assert(offsetof(AOrionTargetingMode_Base, PotentialTargets) == 0x0003C8, "Member 'AOrionTargetingMode_Base::PotentialTargets' has a wrong offset!");
static_assert(offsetof(AOrionTargetingMode_Base, ValidTargets) == 0x0003D8, "Member 'AOrionTargetingMode_Base::ValidTargets' has a wrong offset!");

// Class OrionGame.BotObjectiveGenerator_WholeLane
// 0x0060 (0x0090 - 0x0030)
class UBotObjectiveGenerator_WholeLane final : public UBotObjectiveGenerator
{
public:
	TArray<struct FBotTeamObjectives>             ActiveDefenseObjectives;                           // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FBotTeamObjectives>             AttackObjectives;                                  // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x40];                                      // 0x0050(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotObjectiveGenerator_WholeLane">();
	}
	static class UBotObjectiveGenerator_WholeLane* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotObjectiveGenerator_WholeLane>();
	}
};
static_assert(alignof(UBotObjectiveGenerator_WholeLane) == 0x000008, "Wrong alignment on UBotObjectiveGenerator_WholeLane");
static_assert(sizeof(UBotObjectiveGenerator_WholeLane) == 0x000090, "Wrong size on UBotObjectiveGenerator_WholeLane");
static_assert(offsetof(UBotObjectiveGenerator_WholeLane, ActiveDefenseObjectives) == 0x000030, "Member 'UBotObjectiveGenerator_WholeLane::ActiveDefenseObjectives' has a wrong offset!");
static_assert(offsetof(UBotObjectiveGenerator_WholeLane, AttackObjectives) == 0x000040, "Member 'UBotObjectiveGenerator_WholeLane::AttackObjectives' has a wrong offset!");

// Class OrionGame.PhasedFunctionalTest
// 0x0080 (0x04E0 - 0x0460)
class APhasedFunctionalTest : public AFunctionalTest
{
public:
	class UWorld*                                 CachedWorld;                                       // 0x0460(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerController*                      CachedPlayerController;                            // 0x0468(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_470[0x8];                                      // 0x0470(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TestDisplayName;                                   // 0x0478(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideExpectedResult;                           // 0x0488(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFunctionalTestResult                         ExpectedResult;                                    // 0x0489(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48A[0x6];                                      // 0x048A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFunctionalTestCondition*>       Conditions;                                        // 0x0490(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UFunctionalTestPhase*>           Phases;                                            // 0x04A0(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UFunctionalTestPhase*                   CurrentPhase;                                      // 0x04B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentPhaseIndex;                                 // 0x04B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSetUpTest;                                     // 0x04BC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4BD[0x3];                                      // 0x04BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PhaseLoopStartIndex;                               // 0x04C0(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhaseLoopEndIndex;                                 // 0x04C4(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhaseLoopCurrIter;                                 // 0x04C8(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhaseLoopMaxIter;                                  // 0x04CC(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           PhaseLoopTimer;                                    // 0x04D0(0x0008)(BlueprintVisible, Transient, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsLoopingPhases;                                  // 0x04D8(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D9[0x7];                                      // 0x04D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddCondition(class UFunctionalTestCondition* Condition);
	void BeginPlayHook();
	void CheckConditions(bool FinalCheck);
	void CleanUpPhaseLooping();
	void CompleteTest();
	void CustomBeginPlay();
	void CustomPhaseCleanup();
	void CustomPhaseSetup();
	void CustomPostTest();
	void CustomPreTest();
	void CustomTick();
	int32 GetNextPhaseIndex();
	int32 GetPhaseLoopEnd(int32 StartIndex);
	int32 GetPhaseLoopStart(int32 EndIndex);
	void LogError(const class FString& MESSAGE);
	void LogInfo(const class FString& MESSAGE);
	void LogVerbose(const class FString& MESSAGE);
	void LogWarning(const class FString& MESSAGE);
	void OnPhaseLoopTimerExpired();
	void PhaseCleanupHook();
	void PhaseSetupHook();
	void PostTestHook();
	void PreTestHook();
	void ResetNextPhase();
	bool SetUpPhaseLooping(class UPhaseLoopStart* StartPhase);
	void TickHook();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhasedFunctionalTest">();
	}
	static class APhasedFunctionalTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<APhasedFunctionalTest>();
	}
};
static_assert(alignof(APhasedFunctionalTest) == 0x000008, "Wrong alignment on APhasedFunctionalTest");
static_assert(sizeof(APhasedFunctionalTest) == 0x0004E0, "Wrong size on APhasedFunctionalTest");
static_assert(offsetof(APhasedFunctionalTest, CachedWorld) == 0x000460, "Member 'APhasedFunctionalTest::CachedWorld' has a wrong offset!");
static_assert(offsetof(APhasedFunctionalTest, CachedPlayerController) == 0x000468, "Member 'APhasedFunctionalTest::CachedPlayerController' has a wrong offset!");
static_assert(offsetof(APhasedFunctionalTest, TestDisplayName) == 0x000478, "Member 'APhasedFunctionalTest::TestDisplayName' has a wrong offset!");
static_assert(offsetof(APhasedFunctionalTest, bOverrideExpectedResult) == 0x000488, "Member 'APhasedFunctionalTest::bOverrideExpectedResult' has a wrong offset!");
static_assert(offsetof(APhasedFunctionalTest, ExpectedResult) == 0x000489, "Member 'APhasedFunctionalTest::ExpectedResult' has a wrong offset!");
static_assert(offsetof(APhasedFunctionalTest, Conditions) == 0x000490, "Member 'APhasedFunctionalTest::Conditions' has a wrong offset!");
static_assert(offsetof(APhasedFunctionalTest, Phases) == 0x0004A0, "Member 'APhasedFunctionalTest::Phases' has a wrong offset!");
static_assert(offsetof(APhasedFunctionalTest, CurrentPhase) == 0x0004B0, "Member 'APhasedFunctionalTest::CurrentPhase' has a wrong offset!");
static_assert(offsetof(APhasedFunctionalTest, CurrentPhaseIndex) == 0x0004B8, "Member 'APhasedFunctionalTest::CurrentPhaseIndex' has a wrong offset!");
static_assert(offsetof(APhasedFunctionalTest, bHasSetUpTest) == 0x0004BC, "Member 'APhasedFunctionalTest::bHasSetUpTest' has a wrong offset!");
static_assert(offsetof(APhasedFunctionalTest, PhaseLoopStartIndex) == 0x0004C0, "Member 'APhasedFunctionalTest::PhaseLoopStartIndex' has a wrong offset!");
static_assert(offsetof(APhasedFunctionalTest, PhaseLoopEndIndex) == 0x0004C4, "Member 'APhasedFunctionalTest::PhaseLoopEndIndex' has a wrong offset!");
static_assert(offsetof(APhasedFunctionalTest, PhaseLoopCurrIter) == 0x0004C8, "Member 'APhasedFunctionalTest::PhaseLoopCurrIter' has a wrong offset!");
static_assert(offsetof(APhasedFunctionalTest, PhaseLoopMaxIter) == 0x0004CC, "Member 'APhasedFunctionalTest::PhaseLoopMaxIter' has a wrong offset!");
static_assert(offsetof(APhasedFunctionalTest, PhaseLoopTimer) == 0x0004D0, "Member 'APhasedFunctionalTest::PhaseLoopTimer' has a wrong offset!");
static_assert(offsetof(APhasedFunctionalTest, bIsLoopingPhases) == 0x0004D8, "Member 'APhasedFunctionalTest::bIsLoopingPhases' has a wrong offset!");

// Class OrionGame.OrionPhasedFunctionalTest
// 0x0120 (0x0600 - 0x04E0)
class AOrionPhasedFunctionalTest final : public APhasedFunctionalTest
{
public:
	class UOrionFunctionalTestConfig*             SharedConfig;                                      // 0x04E0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         TestCases;                                         // 0x04E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<class FString>                         GameplayCueDebugStrings;                           // 0x04F8(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AOrionDamageableActor*>          MapObjectives;                                     // 0x0508(0x0010)(BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TMap<class FString, class AActor*>            TestActors;                                        // 0x0518(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FAutomationPawnInfo>            PawnInfo;                                          // 0x0568(0x0010)(BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TMap<class FString, float>                    FloatCache;                                        // 0x0578(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class AActor*                                 AutoAimTarget;                                     // 0x05C8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SublevelViewTargetCollector;                       // 0x05D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AFKResetPeriod;                                    // 0x05D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5DC[0x4];                                      // 0x05DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           AFKResetTimer;                                     // 0x05E0(0x0008)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UAutomationContext*                     CachedAutomationContext;                           // 0x05E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F0[0x10];                                     // 0x05F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CacheFloat(const class FString& Key, float Value);
	void ExecuteCommonCommands();
	void ExecuteHeroCommands();
	bool FindCachedFloat(const class FString& Key, float* OutValue);
	void GatherStaticActorReferences();
	void GatherStaticBPActorReferences();
	class UAutomationContext* GetAutomationContext();
	class AOrionDamageableActor* GetMapObjective(int32 Index_0);
	struct FAutomationPawnInfo GetPawnInfo(int32 Index_0);
	class UOrionFunctionalTestConfig* GetSharedConfig();
	class AActor* GetSublevelViewTargetCollector_Internal();
	class AActor* GetTestActor(const class FString& Key);
	void ListenToGameplayCueRoutedEvent(bool EnableGameplayCueLogging);
	void RecordGameplayCueDebugString(class AActor* TargetActor, const struct FGameplayTag& GameplayCueTag, EGameplayCueEvent EventType, const struct FGameplayCueParameters& Parameters);
	void ResetAFKTimer();
	void SetPawnInfo(int32 Index_0, class AOrionChar* OrionChar);
	void SetSublevelViewTargetCollector(class AActor* NewCollector);
	void SetTestActor(const class FString& Key, class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPhasedFunctionalTest">();
	}
	static class AOrionPhasedFunctionalTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionPhasedFunctionalTest>();
	}
};
static_assert(alignof(AOrionPhasedFunctionalTest) == 0x000008, "Wrong alignment on AOrionPhasedFunctionalTest");
static_assert(sizeof(AOrionPhasedFunctionalTest) == 0x000600, "Wrong size on AOrionPhasedFunctionalTest");
static_assert(offsetof(AOrionPhasedFunctionalTest, SharedConfig) == 0x0004E0, "Member 'AOrionPhasedFunctionalTest::SharedConfig' has a wrong offset!");
static_assert(offsetof(AOrionPhasedFunctionalTest, TestCases) == 0x0004E8, "Member 'AOrionPhasedFunctionalTest::TestCases' has a wrong offset!");
static_assert(offsetof(AOrionPhasedFunctionalTest, GameplayCueDebugStrings) == 0x0004F8, "Member 'AOrionPhasedFunctionalTest::GameplayCueDebugStrings' has a wrong offset!");
static_assert(offsetof(AOrionPhasedFunctionalTest, MapObjectives) == 0x000508, "Member 'AOrionPhasedFunctionalTest::MapObjectives' has a wrong offset!");
static_assert(offsetof(AOrionPhasedFunctionalTest, TestActors) == 0x000518, "Member 'AOrionPhasedFunctionalTest::TestActors' has a wrong offset!");
static_assert(offsetof(AOrionPhasedFunctionalTest, PawnInfo) == 0x000568, "Member 'AOrionPhasedFunctionalTest::PawnInfo' has a wrong offset!");
static_assert(offsetof(AOrionPhasedFunctionalTest, FloatCache) == 0x000578, "Member 'AOrionPhasedFunctionalTest::FloatCache' has a wrong offset!");
static_assert(offsetof(AOrionPhasedFunctionalTest, AutoAimTarget) == 0x0005C8, "Member 'AOrionPhasedFunctionalTest::AutoAimTarget' has a wrong offset!");
static_assert(offsetof(AOrionPhasedFunctionalTest, SublevelViewTargetCollector) == 0x0005D0, "Member 'AOrionPhasedFunctionalTest::SublevelViewTargetCollector' has a wrong offset!");
static_assert(offsetof(AOrionPhasedFunctionalTest, AFKResetPeriod) == 0x0005D8, "Member 'AOrionPhasedFunctionalTest::AFKResetPeriod' has a wrong offset!");
static_assert(offsetof(AOrionPhasedFunctionalTest, AFKResetTimer) == 0x0005E0, "Member 'AOrionPhasedFunctionalTest::AFKResetTimer' has a wrong offset!");
static_assert(offsetof(AOrionPhasedFunctionalTest, CachedAutomationContext) == 0x0005E8, "Member 'AOrionPhasedFunctionalTest::CachedAutomationContext' has a wrong offset!");

// Class OrionGame.OrionDecalComponent
// 0x0000 (0x02D0 - 0x02D0)
class UOrionDecalComponent final : public UDecalComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionDecalComponent">();
	}
	static class UOrionDecalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionDecalComponent>();
	}
};
static_assert(alignof(UOrionDecalComponent) == 0x000008, "Wrong alignment on UOrionDecalComponent");
static_assert(sizeof(UOrionDecalComponent) == 0x0002D0, "Wrong size on UOrionDecalComponent");

// Class OrionGame.BotObjectiveGenerator_AttackJungleCamp
// 0x0000 (0x0030 - 0x0030)
class UBotObjectiveGenerator_AttackJungleCamp final : public UBotObjectiveGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotObjectiveGenerator_AttackJungleCamp">();
	}
	static class UBotObjectiveGenerator_AttackJungleCamp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotObjectiveGenerator_AttackJungleCamp>();
	}
};
static_assert(alignof(UBotObjectiveGenerator_AttackJungleCamp) == 0x000008, "Wrong alignment on UBotObjectiveGenerator_AttackJungleCamp");
static_assert(sizeof(UBotObjectiveGenerator_AttackJungleCamp) == 0x000030, "Wrong size on UBotObjectiveGenerator_AttackJungleCamp");

// Class OrionGame.BotObjectiveGenerator_PlaceWard
// 0x0000 (0x0030 - 0x0030)
class UBotObjectiveGenerator_PlaceWard final : public UBotObjectiveGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotObjectiveGenerator_PlaceWard">();
	}
	static class UBotObjectiveGenerator_PlaceWard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotObjectiveGenerator_PlaceWard>();
	}
};
static_assert(alignof(UBotObjectiveGenerator_PlaceWard) == 0x000008, "Wrong alignment on UBotObjectiveGenerator_PlaceWard");
static_assert(sizeof(UBotObjectiveGenerator_PlaceWard) == 0x000030, "Wrong size on UBotObjectiveGenerator_PlaceWard");

// Class OrionGame.OrionDynamicWall
// 0x00D0 (0x04B8 - 0x03E8)
class AOrionDynamicWall final : public AOrionBaseActor
{
public:
	struct FOrionDynamicWall_BaseDefinition       BaseDefinition;                                    // 0x03E8(0x0018)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FOrionDynamicWall_CapDefinition> CapDefinitions;                                    // 0x0400(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class AOrionDynamicWall_Segment>  SegmentActorClass;                                 // 0x0410(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCollisionProfileName                  WallBlockingCollision;                             // 0x0418(0x0008)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCollisionProfileName                  WallOverlapCollision;                              // 0x0420(0x0008)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         WallMinLength;                                     // 0x0428(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WallMaxLength;                                     // 0x042C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WallMinHeight;                                     // 0x0430(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WallMaxHeight;                                     // 0x0434(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SegmentLength;                                     // 0x0438(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSegmentChangeInSlope;                           // 0x043C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlopeUpBias;                                       // 0x0440(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DelayBetweenSegmentConstruction;                   // 0x0444(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DelayBetweenSegmentDeconstruction;                 // 0x0448(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SegmentConstructionTime;                           // 0x044C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SegmentDeconstructionTime;                         // 0x0450(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowFloatingSegments;                            // 0x0454(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSkipFirstSegmentGroundTrace;                      // 0x0455(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceHeightOfFirstSegment;                        // 0x0456(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_457[0x1];                                      // 0x0457(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForcedFirstSegmentHeight;                          // 0x0458(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bKeepBottomFlat;                                   // 0x045C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_45D[0x3];                                      // 0x045D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCollisionProfileName                  GroundTraceProfile;                                // 0x0460(0x0008)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         GroundTraceMinHeight;                              // 0x0468(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GroundTraceMaxHeight;                              // 0x046C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayCueTag                        SegmentConstructionCue;                            // 0x0470(0x0008)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueTag                        SegmentDeconstructionCue;                          // 0x0478(0x0008)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AOrionDynamicWall_Segment*>      SegmentActors;                                     // 0x0480(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<struct FOrionDynamicWall_SegmentProperties> SegmentProperties;                                 // 0x0490(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          ConstructionToggle;                                // 0x04A0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A1[0x3];                                      // 0x04A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ConstructionSegmentCount;                          // 0x04A4(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A8[0x10];                                     // 0x04A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ConstructWall(const struct FVector& Location, const struct FRotator& Rotation, int32 InAbilityLevel, int32 SegmentCountClamp);
	bool ConstructWallWithTargetData(const struct FGameplayAbilityTargetDataHandle& TargetData, int32 InAbilityLevel, int32 SegmentCountClamp);
	void DeconstructWall();
	void OnRep_ConstructionSegmentCount();
	void OnRep_ConstructionToggle(bool OldConstructionToggle);
	void OnRep_SegmentActors();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionDynamicWall">();
	}
	static class AOrionDynamicWall* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionDynamicWall>();
	}
};
static_assert(alignof(AOrionDynamicWall) == 0x000008, "Wrong alignment on AOrionDynamicWall");
static_assert(sizeof(AOrionDynamicWall) == 0x0004B8, "Wrong size on AOrionDynamicWall");
static_assert(offsetof(AOrionDynamicWall, BaseDefinition) == 0x0003E8, "Member 'AOrionDynamicWall::BaseDefinition' has a wrong offset!");
static_assert(offsetof(AOrionDynamicWall, CapDefinitions) == 0x000400, "Member 'AOrionDynamicWall::CapDefinitions' has a wrong offset!");
static_assert(offsetof(AOrionDynamicWall, SegmentActorClass) == 0x000410, "Member 'AOrionDynamicWall::SegmentActorClass' has a wrong offset!");
static_assert(offsetof(AOrionDynamicWall, WallBlockingCollision) == 0x000418, "Member 'AOrionDynamicWall::WallBlockingCollision' has a wrong offset!");
static_assert(offsetof(AOrionDynamicWall, WallOverlapCollision) == 0x000420, "Member 'AOrionDynamicWall::WallOverlapCollision' has a wrong offset!");
static_assert(offsetof(AOrionDynamicWall, WallMinLength) == 0x000428, "Member 'AOrionDynamicWall::WallMinLength' has a wrong offset!");
static_assert(offsetof(AOrionDynamicWall, WallMaxLength) == 0x00042C, "Member 'AOrionDynamicWall::WallMaxLength' has a wrong offset!");
static_assert(offsetof(AOrionDynamicWall, WallMinHeight) == 0x000430, "Member 'AOrionDynamicWall::WallMinHeight' has a wrong offset!");
static_assert(offsetof(AOrionDynamicWall, WallMaxHeight) == 0x000434, "Member 'AOrionDynamicWall::WallMaxHeight' has a wrong offset!");
static_assert(offsetof(AOrionDynamicWall, SegmentLength) == 0x000438, "Member 'AOrionDynamicWall::SegmentLength' has a wrong offset!");
static_assert(offsetof(AOrionDynamicWall, MaxSegmentChangeInSlope) == 0x00043C, "Member 'AOrionDynamicWall::MaxSegmentChangeInSlope' has a wrong offset!");
static_assert(offsetof(AOrionDynamicWall, SlopeUpBias) == 0x000440, "Member 'AOrionDynamicWall::SlopeUpBias' has a wrong offset!");
static_assert(offsetof(AOrionDynamicWall, DelayBetweenSegmentConstruction) == 0x000444, "Member 'AOrionDynamicWall::DelayBetweenSegmentConstruction' has a wrong offset!");
static_assert(offsetof(AOrionDynamicWall, DelayBetweenSegmentDeconstruction) == 0x000448, "Member 'AOrionDynamicWall::DelayBetweenSegmentDeconstruction' has a wrong offset!");
static_assert(offsetof(AOrionDynamicWall, SegmentConstructionTime) == 0x00044C, "Member 'AOrionDynamicWall::SegmentConstructionTime' has a wrong offset!");
static_assert(offsetof(AOrionDynamicWall, SegmentDeconstructionTime) == 0x000450, "Member 'AOrionDynamicWall::SegmentDeconstructionTime' has a wrong offset!");
static_assert(offsetof(AOrionDynamicWall, bAllowFloatingSegments) == 0x000454, "Member 'AOrionDynamicWall::bAllowFloatingSegments' has a wrong offset!");
static_assert(offsetof(AOrionDynamicWall, bSkipFirstSegmentGroundTrace) == 0x000455, "Member 'AOrionDynamicWall::bSkipFirstSegmentGroundTrace' has a wrong offset!");
static_assert(offsetof(AOrionDynamicWall, bForceHeightOfFirstSegment) == 0x000456, "Member 'AOrionDynamicWall::bForceHeightOfFirstSegment' has a wrong offset!");
static_assert(offsetof(AOrionDynamicWall, ForcedFirstSegmentHeight) == 0x000458, "Member 'AOrionDynamicWall::ForcedFirstSegmentHeight' has a wrong offset!");
static_assert(offsetof(AOrionDynamicWall, bKeepBottomFlat) == 0x00045C, "Member 'AOrionDynamicWall::bKeepBottomFlat' has a wrong offset!");
static_assert(offsetof(AOrionDynamicWall, GroundTraceProfile) == 0x000460, "Member 'AOrionDynamicWall::GroundTraceProfile' has a wrong offset!");
static_assert(offsetof(AOrionDynamicWall, GroundTraceMinHeight) == 0x000468, "Member 'AOrionDynamicWall::GroundTraceMinHeight' has a wrong offset!");
static_assert(offsetof(AOrionDynamicWall, GroundTraceMaxHeight) == 0x00046C, "Member 'AOrionDynamicWall::GroundTraceMaxHeight' has a wrong offset!");
static_assert(offsetof(AOrionDynamicWall, SegmentConstructionCue) == 0x000470, "Member 'AOrionDynamicWall::SegmentConstructionCue' has a wrong offset!");
static_assert(offsetof(AOrionDynamicWall, SegmentDeconstructionCue) == 0x000478, "Member 'AOrionDynamicWall::SegmentDeconstructionCue' has a wrong offset!");
static_assert(offsetof(AOrionDynamicWall, SegmentActors) == 0x000480, "Member 'AOrionDynamicWall::SegmentActors' has a wrong offset!");
static_assert(offsetof(AOrionDynamicWall, SegmentProperties) == 0x000490, "Member 'AOrionDynamicWall::SegmentProperties' has a wrong offset!");
static_assert(offsetof(AOrionDynamicWall, ConstructionToggle) == 0x0004A0, "Member 'AOrionDynamicWall::ConstructionToggle' has a wrong offset!");
static_assert(offsetof(AOrionDynamicWall, ConstructionSegmentCount) == 0x0004A4, "Member 'AOrionDynamicWall::ConstructionSegmentCount' has a wrong offset!");

// Class OrionGame.BotObjectiveGenerator_AttackRefinery
// 0x0000 (0x0030 - 0x0030)
class UBotObjectiveGenerator_AttackRefinery final : public UBotObjectiveGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotObjectiveGenerator_AttackRefinery">();
	}
	static class UBotObjectiveGenerator_AttackRefinery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotObjectiveGenerator_AttackRefinery>();
	}
};
static_assert(alignof(UBotObjectiveGenerator_AttackRefinery) == 0x000008, "Wrong alignment on UBotObjectiveGenerator_AttackRefinery");
static_assert(sizeof(UBotObjectiveGenerator_AttackRefinery) == 0x000030, "Wrong size on UBotObjectiveGenerator_AttackRefinery");

// Class OrionGame.OrionTBSlotHelper
// 0x04C8 (0x04F0 - 0x0028)
class UOrionTBSlotHelper final : public UObject
{
public:
	float                                         CancelSearchDelay;                                 // 0x0028(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NoResultsAvailableDelay;                           // 0x002C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SentInvitationExpiredDelay;                        // 0x0030(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ApprovePlayerTimeout;                              // 0x0034(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x148];                                     // 0x0038(0x0148)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SlotIndex;                                         // 0x0180(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_184[0x4];                                      // 0x0184(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUniqueNetIdRepl                       PendingPlayerId;                                   // 0x0188(0x0018)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FUniqueNetIdRepl                       PendingSessionId;                                  // 0x01A0(0x0018)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 PendingXmppResource;                               // 0x01B8(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FOrionTBPlayerChoices                  FoundChoices;                                      // 0x01C8(0x0108)(Transient, NativeAccessSpecifierPrivate)
	struct FTBSearchParams                        CurrentSearchParams;                               // 0x02D0(0x0048)(Transient, NativeAccessSpecifierPrivate)
	struct FTBSearchPassState                     CurrentSearchPassState;                            // 0x0318(0x000C)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_324[0x4];                                      // 0x0324(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionTBPlayerChoices                  QueryChoices;                                      // 0x0328(0x0108)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_430[0xC0];                                     // 0x0430(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTBSlotHelper">();
	}
	static class UOrionTBSlotHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionTBSlotHelper>();
	}
};
static_assert(alignof(UOrionTBSlotHelper) == 0x000008, "Wrong alignment on UOrionTBSlotHelper");
static_assert(sizeof(UOrionTBSlotHelper) == 0x0004F0, "Wrong size on UOrionTBSlotHelper");
static_assert(offsetof(UOrionTBSlotHelper, CancelSearchDelay) == 0x000028, "Member 'UOrionTBSlotHelper::CancelSearchDelay' has a wrong offset!");
static_assert(offsetof(UOrionTBSlotHelper, NoResultsAvailableDelay) == 0x00002C, "Member 'UOrionTBSlotHelper::NoResultsAvailableDelay' has a wrong offset!");
static_assert(offsetof(UOrionTBSlotHelper, SentInvitationExpiredDelay) == 0x000030, "Member 'UOrionTBSlotHelper::SentInvitationExpiredDelay' has a wrong offset!");
static_assert(offsetof(UOrionTBSlotHelper, ApprovePlayerTimeout) == 0x000034, "Member 'UOrionTBSlotHelper::ApprovePlayerTimeout' has a wrong offset!");
static_assert(offsetof(UOrionTBSlotHelper, SlotIndex) == 0x000180, "Member 'UOrionTBSlotHelper::SlotIndex' has a wrong offset!");
static_assert(offsetof(UOrionTBSlotHelper, PendingPlayerId) == 0x000188, "Member 'UOrionTBSlotHelper::PendingPlayerId' has a wrong offset!");
static_assert(offsetof(UOrionTBSlotHelper, PendingSessionId) == 0x0001A0, "Member 'UOrionTBSlotHelper::PendingSessionId' has a wrong offset!");
static_assert(offsetof(UOrionTBSlotHelper, PendingXmppResource) == 0x0001B8, "Member 'UOrionTBSlotHelper::PendingXmppResource' has a wrong offset!");
static_assert(offsetof(UOrionTBSlotHelper, FoundChoices) == 0x0001C8, "Member 'UOrionTBSlotHelper::FoundChoices' has a wrong offset!");
static_assert(offsetof(UOrionTBSlotHelper, CurrentSearchParams) == 0x0002D0, "Member 'UOrionTBSlotHelper::CurrentSearchParams' has a wrong offset!");
static_assert(offsetof(UOrionTBSlotHelper, CurrentSearchPassState) == 0x000318, "Member 'UOrionTBSlotHelper::CurrentSearchPassState' has a wrong offset!");
static_assert(offsetof(UOrionTBSlotHelper, QueryChoices) == 0x000328, "Member 'UOrionTBSlotHelper::QueryChoices' has a wrong offset!");

// Class OrionGame.BotObjectiveGenerator_Patrol
// 0x0000 (0x0030 - 0x0030)
class UBotObjectiveGenerator_Patrol final : public UBotObjectiveGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotObjectiveGenerator_Patrol">();
	}
	static class UBotObjectiveGenerator_Patrol* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotObjectiveGenerator_Patrol>();
	}
};
static_assert(alignof(UBotObjectiveGenerator_Patrol) == 0x000008, "Wrong alignment on UBotObjectiveGenerator_Patrol");
static_assert(sizeof(UBotObjectiveGenerator_Patrol) == 0x000030, "Wrong size on UBotObjectiveGenerator_Patrol");

// Class OrionGame.BotObjectiveGenerator_Simple
// 0x0000 (0x0030 - 0x0030)
class UBotObjectiveGenerator_Simple final : public UBotObjectiveGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotObjectiveGenerator_Simple">();
	}
	static class UBotObjectiveGenerator_Simple* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotObjectiveGenerator_Simple>();
	}
};
static_assert(alignof(UBotObjectiveGenerator_Simple) == 0x000008, "Wrong alignment on UBotObjectiveGenerator_Simple");
static_assert(sizeof(UBotObjectiveGenerator_Simple) == 0x000030, "Wrong size on UBotObjectiveGenerator_Simple");

// Class OrionGame.BotObjectiveGraph
// 0x0198 (0x04B0 - 0x0318)
class ABotObjectiveGraph final : public AActor
{
public:
	class UBillboardComponent*                    SpriteComponent;                                   // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FBotObjectiveGraphAuxNode>      AdditionalNodes;                                   // 0x0320(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBotObjectiveGraphNode>         Nodes;                                             // 0x0330(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_340[0x18];                                     // 0x0340(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBox                                   Bounds;                                            // 0x0358(0x001C)(IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         PruneDistanceEpsilon;                              // 0x0374(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PruneDistanceOffset;                               // 0x0378(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PruneMaxDistance;                                  // 0x037C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint32                                        NodeProximityGridCellSize;                         // 0x0380(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_384[0x4];                                      // 0x0384(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBotObjectiveGraphForcedEdge>   ForcedEdges;                                       // 0x0388(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FBotObjectiveGraphPathfindingCost      PathfindingCost[0x3];                              // 0x0398(0x0014)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         MaxInfluencePropagationDistance;                   // 0x03D4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D8[0x4];                                      // 0x03D8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LaneMinionInfluenceModifier;                       // 0x03DC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CoreNodeIndices[0x2];                              // 0x03E0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint32                                        DataVersion;                                       // 0x03E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3EC[0x4];                                      // 0x03EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLanePath                              LanePaths[0x3];                                    // 0x03F0(0x0018)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	int32                                         HomeBasePads[0x2];                                 // 0x0438(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_440[0x5C];                                     // 0x0440(0x005C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBotObjectiveGraphDebugDrawingParams   DrawingParams;                                     // 0x049C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4AC[0x4];                                      // 0x04AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EditorBuild();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotObjectiveGraph">();
	}
	static class ABotObjectiveGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABotObjectiveGraph>();
	}
};
static_assert(alignof(ABotObjectiveGraph) == 0x000008, "Wrong alignment on ABotObjectiveGraph");
static_assert(sizeof(ABotObjectiveGraph) == 0x0004B0, "Wrong size on ABotObjectiveGraph");
static_assert(offsetof(ABotObjectiveGraph, SpriteComponent) == 0x000318, "Member 'ABotObjectiveGraph::SpriteComponent' has a wrong offset!");
static_assert(offsetof(ABotObjectiveGraph, AdditionalNodes) == 0x000320, "Member 'ABotObjectiveGraph::AdditionalNodes' has a wrong offset!");
static_assert(offsetof(ABotObjectiveGraph, Nodes) == 0x000330, "Member 'ABotObjectiveGraph::Nodes' has a wrong offset!");
static_assert(offsetof(ABotObjectiveGraph, Bounds) == 0x000358, "Member 'ABotObjectiveGraph::Bounds' has a wrong offset!");
static_assert(offsetof(ABotObjectiveGraph, PruneDistanceEpsilon) == 0x000374, "Member 'ABotObjectiveGraph::PruneDistanceEpsilon' has a wrong offset!");
static_assert(offsetof(ABotObjectiveGraph, PruneDistanceOffset) == 0x000378, "Member 'ABotObjectiveGraph::PruneDistanceOffset' has a wrong offset!");
static_assert(offsetof(ABotObjectiveGraph, PruneMaxDistance) == 0x00037C, "Member 'ABotObjectiveGraph::PruneMaxDistance' has a wrong offset!");
static_assert(offsetof(ABotObjectiveGraph, NodeProximityGridCellSize) == 0x000380, "Member 'ABotObjectiveGraph::NodeProximityGridCellSize' has a wrong offset!");
static_assert(offsetof(ABotObjectiveGraph, ForcedEdges) == 0x000388, "Member 'ABotObjectiveGraph::ForcedEdges' has a wrong offset!");
static_assert(offsetof(ABotObjectiveGraph, PathfindingCost) == 0x000398, "Member 'ABotObjectiveGraph::PathfindingCost' has a wrong offset!");
static_assert(offsetof(ABotObjectiveGraph, MaxInfluencePropagationDistance) == 0x0003D4, "Member 'ABotObjectiveGraph::MaxInfluencePropagationDistance' has a wrong offset!");
static_assert(offsetof(ABotObjectiveGraph, LaneMinionInfluenceModifier) == 0x0003DC, "Member 'ABotObjectiveGraph::LaneMinionInfluenceModifier' has a wrong offset!");
static_assert(offsetof(ABotObjectiveGraph, CoreNodeIndices) == 0x0003E0, "Member 'ABotObjectiveGraph::CoreNodeIndices' has a wrong offset!");
static_assert(offsetof(ABotObjectiveGraph, DataVersion) == 0x0003E8, "Member 'ABotObjectiveGraph::DataVersion' has a wrong offset!");
static_assert(offsetof(ABotObjectiveGraph, LanePaths) == 0x0003F0, "Member 'ABotObjectiveGraph::LanePaths' has a wrong offset!");
static_assert(offsetof(ABotObjectiveGraph, HomeBasePads) == 0x000438, "Member 'ABotObjectiveGraph::HomeBasePads' has a wrong offset!");
static_assert(offsetof(ABotObjectiveGraph, DrawingParams) == 0x00049C, "Member 'ABotObjectiveGraph::DrawingParams' has a wrong offset!");

// Class OrionGame.OrionDamageNumberManager
// 0x4538 (0x4850 - 0x0318)
class AOrionDamageNumberManager : public AActor
{
public:
	struct FOrionDamageNumberStyleData            DamageNumberStyles[0x19];                          // 0x0318(0x0170)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FOrionDamageNumberInfo>         DamageNumbers;                                     // 0x2708(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FOrionDamageNumberInfo>         FloatingNumberSpawnQueue;                          // 0x2718(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint32                                        MaxNumbersPerFrame;                                // 0x2728(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_272C[0x4];                                     // 0x272C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionDamageNumberInfo                 AggregatorNumbers[0x20];                           // 0x2730(0x0108)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4830[0x20];                                    // 0x4830(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetDamageNumberOffset(const struct FOrionDamageNumberInfo& DamageNumberInfo) const;
	struct FVector GetDamageNumberStartLocation(const struct FOrionDamageNumberInfo& DamageNumberInfo) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionDamageNumberManager">();
	}
	static class AOrionDamageNumberManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionDamageNumberManager>();
	}
};
static_assert(alignof(AOrionDamageNumberManager) == 0x000008, "Wrong alignment on AOrionDamageNumberManager");
static_assert(sizeof(AOrionDamageNumberManager) == 0x004850, "Wrong size on AOrionDamageNumberManager");
static_assert(offsetof(AOrionDamageNumberManager, DamageNumberStyles) == 0x000318, "Member 'AOrionDamageNumberManager::DamageNumberStyles' has a wrong offset!");
static_assert(offsetof(AOrionDamageNumberManager, DamageNumbers) == 0x002708, "Member 'AOrionDamageNumberManager::DamageNumbers' has a wrong offset!");
static_assert(offsetof(AOrionDamageNumberManager, FloatingNumberSpawnQueue) == 0x002718, "Member 'AOrionDamageNumberManager::FloatingNumberSpawnQueue' has a wrong offset!");
static_assert(offsetof(AOrionDamageNumberManager, MaxNumbersPerFrame) == 0x002728, "Member 'AOrionDamageNumberManager::MaxNumbersPerFrame' has a wrong offset!");
static_assert(offsetof(AOrionDamageNumberManager, AggregatorNumbers) == 0x002730, "Member 'AOrionDamageNumberManager::AggregatorNumbers' has a wrong offset!");

// Class OrionGame.BotObjectiveGraphRenderingComponent
// 0x0000 (0x0690 - 0x0690)
class UBotObjectiveGraphRenderingComponent final : public UPrimitiveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotObjectiveGraphRenderingComponent">();
	}
	static class UBotObjectiveGraphRenderingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotObjectiveGraphRenderingComponent>();
	}
};
static_assert(alignof(UBotObjectiveGraphRenderingComponent) == 0x000010, "Wrong alignment on UBotObjectiveGraphRenderingComponent");
static_assert(sizeof(UBotObjectiveGraphRenderingComponent) == 0x000690, "Wrong size on UBotObjectiveGraphRenderingComponent");

// Class OrionGame.OrionTeamActorInterface
// 0x0000 (0x0028 - 0x0028)
class IOrionTeamActorInterface final : public IGenericTeamAgentInterface
{
public:
	void OnTeamChanged(EOrionTeam NewTeamIdx);

	EOrionTeam GetTeamNum() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTeamActorInterface">();
	}
	static class IOrionTeamActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOrionTeamActorInterface>();
	}
};
static_assert(alignof(IOrionTeamActorInterface) == 0x000008, "Wrong alignment on IOrionTeamActorInterface");
static_assert(sizeof(IOrionTeamActorInterface) == 0x000028, "Wrong size on IOrionTeamActorInterface");

// Class OrionGame.BotPlaybook
// 0x0030 (0x0058 - 0x0028)
class UBotPlaybook final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAIScriptedBehavior>        InitialScriptedBehavior;                           // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AdditionalCondition(const struct FOrionGenericAITest& Condition);
	void AdditionalConditions(const TArray<struct FOrionGenericAITest>& Conditions);
	void AddTeamCommAssignOverride(const EAITeamCommEvent AssignCommOverride);
	void AddTeamCommConfirmOverride(const EAITeamCommEvent ConfirmCommOverride);
	void OnGenerateObjectiveList();

	EAIBotDifficulty GetAgentDifficulty() const;
	EAIMatchProgress GetMatchPhase() const;
	bool IsRole(ELaneRoleSlot Role) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotPlaybook">();
	}
	static class UBotPlaybook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotPlaybook>();
	}
};
static_assert(alignof(UBotPlaybook) == 0x000008, "Wrong alignment on UBotPlaybook");
static_assert(sizeof(UBotPlaybook) == 0x000058, "Wrong size on UBotPlaybook");
static_assert(offsetof(UBotPlaybook, InitialScriptedBehavior) == 0x000038, "Member 'UBotPlaybook::InitialScriptedBehavior' has a wrong offset!");

// Class OrionGame.OrionDummySpawner
// 0x0050 (0x0368 - 0x0318)
class AOrionDummySpawner final : public AActor
{
public:
	bool                                          bAutoSpawn;                                        // 0x0318(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrionTeam                                    TeamNum;                                           // 0x0319(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31A[0x6];                                      // 0x031A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAIData*                           AIData;                                            // 0x0320(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RespawnTime;                                       // 0x0328(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32C[0x4];                                      // 0x032C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionHeroData*                         HeroData;                                          // 0x0330(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDummy;                                          // 0x0338(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAIBotDifficulty                              BotDifficulty;                                     // 0x0339(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33A[0x6];                                      // 0x033A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIScriptedBehavior*                    ScriptedBehavior;                                  // 0x0340(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         StartingLevel;                                     // 0x0348(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartingHealthPercent;                             // 0x034C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AOrionCharAI*                           SpawnedMinionDummy;                                // 0x0350(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AOrionChar*                             SpawnedHeroDummy;                                  // 0x0358(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_360[0x8];                                      // 0x0360(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void KillAI();
	void OnDeath(class AOrionChar* DeadChar, class AController* Killer, class AActor* DamageCauser);
	void Spawn();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionDummySpawner">();
	}
	static class AOrionDummySpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionDummySpawner>();
	}
};
static_assert(alignof(AOrionDummySpawner) == 0x000008, "Wrong alignment on AOrionDummySpawner");
static_assert(sizeof(AOrionDummySpawner) == 0x000368, "Wrong size on AOrionDummySpawner");
static_assert(offsetof(AOrionDummySpawner, bAutoSpawn) == 0x000318, "Member 'AOrionDummySpawner::bAutoSpawn' has a wrong offset!");
static_assert(offsetof(AOrionDummySpawner, TeamNum) == 0x000319, "Member 'AOrionDummySpawner::TeamNum' has a wrong offset!");
static_assert(offsetof(AOrionDummySpawner, AIData) == 0x000320, "Member 'AOrionDummySpawner::AIData' has a wrong offset!");
static_assert(offsetof(AOrionDummySpawner, RespawnTime) == 0x000328, "Member 'AOrionDummySpawner::RespawnTime' has a wrong offset!");
static_assert(offsetof(AOrionDummySpawner, HeroData) == 0x000330, "Member 'AOrionDummySpawner::HeroData' has a wrong offset!");
static_assert(offsetof(AOrionDummySpawner, bIsDummy) == 0x000338, "Member 'AOrionDummySpawner::bIsDummy' has a wrong offset!");
static_assert(offsetof(AOrionDummySpawner, BotDifficulty) == 0x000339, "Member 'AOrionDummySpawner::BotDifficulty' has a wrong offset!");
static_assert(offsetof(AOrionDummySpawner, ScriptedBehavior) == 0x000340, "Member 'AOrionDummySpawner::ScriptedBehavior' has a wrong offset!");
static_assert(offsetof(AOrionDummySpawner, StartingLevel) == 0x000348, "Member 'AOrionDummySpawner::StartingLevel' has a wrong offset!");
static_assert(offsetof(AOrionDummySpawner, StartingHealthPercent) == 0x00034C, "Member 'AOrionDummySpawner::StartingHealthPercent' has a wrong offset!");
static_assert(offsetof(AOrionDummySpawner, SpawnedMinionDummy) == 0x000350, "Member 'AOrionDummySpawner::SpawnedMinionDummy' has a wrong offset!");
static_assert(offsetof(AOrionDummySpawner, SpawnedHeroDummy) == 0x000358, "Member 'AOrionDummySpawner::SpawnedHeroDummy' has a wrong offset!");

// Class OrionGame.BotSpawningConfig
// 0x0038 (0x0350 - 0x0318)
class ABotSpawningConfig final : public AActor
{
public:
	struct FHeroDataCollection                    HeroesPerTeam[0x3];                                // 0x0318(0x0010)(Edit, NativeAccessSpecifierPublic)
	bool                                          bSameSetupForAllTeams;                             // 0x0348(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0349(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFallbackToSpawningRandoms;                        // 0x034A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34B[0x5];                                      // 0x034B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotSpawningConfig">();
	}
	static class ABotSpawningConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABotSpawningConfig>();
	}
};
static_assert(alignof(ABotSpawningConfig) == 0x000008, "Wrong alignment on ABotSpawningConfig");
static_assert(sizeof(ABotSpawningConfig) == 0x000350, "Wrong size on ABotSpawningConfig");
static_assert(offsetof(ABotSpawningConfig, HeroesPerTeam) == 0x000318, "Member 'ABotSpawningConfig::HeroesPerTeam' has a wrong offset!");
static_assert(offsetof(ABotSpawningConfig, bSameSetupForAllTeams) == 0x000348, "Member 'ABotSpawningConfig::bSameSetupForAllTeams' has a wrong offset!");
static_assert(offsetof(ABotSpawningConfig, bEnabled) == 0x000349, "Member 'ABotSpawningConfig::bEnabled' has a wrong offset!");
static_assert(offsetof(ABotSpawningConfig, bFallbackToSpawningRandoms) == 0x00034A, "Member 'ABotSpawningConfig::bFallbackToSpawningRandoms' has a wrong offset!");

// Class OrionGame.GenericRecord
// 0x0020 (0x0048 - 0x0028)
class UGenericRecord : public UObject
{
public:
	int32                                         DataVersion;                                       // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x1C];                                      // 0x002C(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenericRecord">();
	}
	static class UGenericRecord* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGenericRecord>();
	}
};
static_assert(alignof(UGenericRecord) == 0x000008, "Wrong alignment on UGenericRecord");
static_assert(sizeof(UGenericRecord) == 0x000048, "Wrong size on UGenericRecord");
static_assert(offsetof(UGenericRecord, DataVersion) == 0x000028, "Member 'UGenericRecord::DataVersion' has a wrong offset!");

// Class OrionGame.OrionAttributeSet
// 0x0000 (0x0030 - 0x0030)
class UOrionAttributeSet : public UAttributeSet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAttributeSet">();
	}
	static class UOrionAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAttributeSet>();
	}
};
static_assert(alignof(UOrionAttributeSet) == 0x000008, "Wrong alignment on UOrionAttributeSet");
static_assert(sizeof(UOrionAttributeSet) == 0x000030, "Wrong size on UOrionAttributeSet");

// Class OrionGame.OrionEnergySet
// 0x0020 (0x0050 - 0x0030)
class UOrionEnergySet final : public UOrionAttributeSet
{
public:
	float                                         Energy;                                            // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnergyCostReduction;                               // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnergyCostReductionPercentage;                     // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxEnergy;                                         // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnergyRegenRate;                                   // 0x0040(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownReductionValue;                            // 0x0044(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownReductionPercentage;                       // 0x0048(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_CooldownReductionPercentage();
	void OnRep_CooldownReductionValue();
	void OnRep_Energy();
	void OnRep_EnergyReduction();
	void OnRep_EnergyReductionPercentage();
	void OnRep_EnergyRegenRate();
	void OnRep_MaxEnergy();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionEnergySet">();
	}
	static class UOrionEnergySet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionEnergySet>();
	}
};
static_assert(alignof(UOrionEnergySet) == 0x000008, "Wrong alignment on UOrionEnergySet");
static_assert(sizeof(UOrionEnergySet) == 0x000050, "Wrong size on UOrionEnergySet");
static_assert(offsetof(UOrionEnergySet, Energy) == 0x000030, "Member 'UOrionEnergySet::Energy' has a wrong offset!");
static_assert(offsetof(UOrionEnergySet, EnergyCostReduction) == 0x000034, "Member 'UOrionEnergySet::EnergyCostReduction' has a wrong offset!");
static_assert(offsetof(UOrionEnergySet, EnergyCostReductionPercentage) == 0x000038, "Member 'UOrionEnergySet::EnergyCostReductionPercentage' has a wrong offset!");
static_assert(offsetof(UOrionEnergySet, MaxEnergy) == 0x00003C, "Member 'UOrionEnergySet::MaxEnergy' has a wrong offset!");
static_assert(offsetof(UOrionEnergySet, EnergyRegenRate) == 0x000040, "Member 'UOrionEnergySet::EnergyRegenRate' has a wrong offset!");
static_assert(offsetof(UOrionEnergySet, CooldownReductionValue) == 0x000044, "Member 'UOrionEnergySet::CooldownReductionValue' has a wrong offset!");
static_assert(offsetof(UOrionEnergySet, CooldownReductionPercentage) == 0x000048, "Member 'UOrionEnergySet::CooldownReductionPercentage' has a wrong offset!");

// Class OrionGame.ClientSettingsRecord
// 0x0218 (0x0260 - 0x0048)
class UClientSettingsRecord : public UGenericRecord
{
public:
	uint8                                         Pad_48[0x1];                                       // 0x0048(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EPartyType                                    LastPartyType;                                     // 0x0049(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLastLeaderInvitesOnly;                            // 0x004A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLastLeaderFriendsOnly;                            // 0x004B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSaveToCloud;                                      // 0x004C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCloudIsBusy;                                      // 0x004D(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4E[0xBA];                                      // 0x004E(0x00BA)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bInvertedMouse;                                    // 0x0108(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MouseLookSensitivity;                              // 0x010C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         GamepadPitchSensitivity;                           // 0x0110(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         GamepadYawSensitivity;                             // 0x0114(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         GamepadInvertPitch;                                // 0x0118(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         GamepadInvertYaw;                                  // 0x011C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         GamepadRadialSelectEnabled;                        // 0x0120(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         GamepadAbilityConfirmOnRelease;                    // 0x0124(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ShowXPPerMinute;                                   // 0x0128(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         GamepadConfigIndex;                                // 0x012C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         GamepadHandednessConfigIndex;                      // 0x0130(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ShowPingAndFPS;                                    // 0x0134(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSoftObjectPath                        UserAudioSettingsSoundMixName;                     // 0x0138(0x0018)(Edit, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundMix*                              UserAudioSettingsSoundMix;                         // 0x0150(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSoftObjectPath                        UserMasterSoundClassName;                          // 0x0158(0x0018)(Edit, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundClass*                            UserMasterSoundClass;                              // 0x0170(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSoftObjectPath                        UserMusicSoundClassName;                           // 0x0178(0x0018)(Edit, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundClass*                            UserMusicSoundClass;                               // 0x0190(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSoftObjectPath                        UserVoiceSoundClassName;                           // 0x0198(0x0018)(Edit, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundClass*                            UserVoiceSoundClass;                               // 0x01B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSoftObjectPath                        UserOtherSoundClassName;                           // 0x01B8(0x0018)(Edit, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundClass*                            UserOtherSoundClass;                               // 0x01D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MasterGameVolume;                                  // 0x01D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MusicGameVolume;                                   // 0x01DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         VoiceGameVolume;                                   // 0x01E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OtherGameVolume;                                   // 0x01E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 ThemeMusic;                                        // 0x01E8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          ContinuousMusic;                                   // 0x01F8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FActionKeyOverride>             ActionKeyOverrides;                                // 0x0200(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FActionKeyOverride>             ActionKeyOverridesCached;                          // 0x0210(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FAxisKeyOverride>               AxisKeyOverrides;                                  // 0x0220(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FAxisKeyOverride>               AxisKeyOverridesCached;                            // 0x0230(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class FString                                 SelectedRegionId;                                  // 0x0240(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 LastKnownBestRegionId;                             // 0x0250(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ResetToDefaultControlSettings();
	void ResetToDefaultGameplaySettings();
	void SetGamepadAbilityConfirmOnRelease(int32 NewValue);
	void SetGamepadInvertPitch(int32 NewValue);
	void SetGamepadInvertYaw(int32 NewValue);
	void SetGamepadPitchSensitivity(int32 NewValue);
	void SetGamepadRadialSelectEnabled(int32 NewValue);
	void SetGamepadYawSensitivity(int32 NewValue);
	void SetInvertedMouse(bool bInvert);
	void SetMouseLookSensitivity(float NewValue);
	void SetShowPingAndFPS(int32 NewValue);
	void SetShowXPPerMinute(int32 NewValue);

	int32 GetGamepadAbilityConfirmOnRelease() const;
	int32 GetGamepadInvertPitch() const;
	int32 GetGamepadInvertYaw() const;
	int32 GetGamepadPitchSensitivity() const;
	int32 GetGamepadRadialSelectEnabled() const;
	int32 GetGamepadYawSensitivity() const;
	bool GetInvertedMouse() const;
	float GetMouseLookSensitivity() const;
	int32 GetShowPingAndFPS() const;
	int32 GetShowXPPerMinute() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClientSettingsRecord">();
	}
	static class UClientSettingsRecord* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClientSettingsRecord>();
	}
};
static_assert(alignof(UClientSettingsRecord) == 0x000008, "Wrong alignment on UClientSettingsRecord");
static_assert(sizeof(UClientSettingsRecord) == 0x000260, "Wrong size on UClientSettingsRecord");
static_assert(offsetof(UClientSettingsRecord, LastPartyType) == 0x000049, "Member 'UClientSettingsRecord::LastPartyType' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, bLastLeaderInvitesOnly) == 0x00004A, "Member 'UClientSettingsRecord::bLastLeaderInvitesOnly' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, bLastLeaderFriendsOnly) == 0x00004B, "Member 'UClientSettingsRecord::bLastLeaderFriendsOnly' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, bSaveToCloud) == 0x00004C, "Member 'UClientSettingsRecord::bSaveToCloud' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, bCloudIsBusy) == 0x00004D, "Member 'UClientSettingsRecord::bCloudIsBusy' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, bInvertedMouse) == 0x000108, "Member 'UClientSettingsRecord::bInvertedMouse' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, MouseLookSensitivity) == 0x00010C, "Member 'UClientSettingsRecord::MouseLookSensitivity' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, GamepadPitchSensitivity) == 0x000110, "Member 'UClientSettingsRecord::GamepadPitchSensitivity' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, GamepadYawSensitivity) == 0x000114, "Member 'UClientSettingsRecord::GamepadYawSensitivity' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, GamepadInvertPitch) == 0x000118, "Member 'UClientSettingsRecord::GamepadInvertPitch' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, GamepadInvertYaw) == 0x00011C, "Member 'UClientSettingsRecord::GamepadInvertYaw' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, GamepadRadialSelectEnabled) == 0x000120, "Member 'UClientSettingsRecord::GamepadRadialSelectEnabled' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, GamepadAbilityConfirmOnRelease) == 0x000124, "Member 'UClientSettingsRecord::GamepadAbilityConfirmOnRelease' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, ShowXPPerMinute) == 0x000128, "Member 'UClientSettingsRecord::ShowXPPerMinute' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, GamepadConfigIndex) == 0x00012C, "Member 'UClientSettingsRecord::GamepadConfigIndex' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, GamepadHandednessConfigIndex) == 0x000130, "Member 'UClientSettingsRecord::GamepadHandednessConfigIndex' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, ShowPingAndFPS) == 0x000134, "Member 'UClientSettingsRecord::ShowPingAndFPS' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, UserAudioSettingsSoundMixName) == 0x000138, "Member 'UClientSettingsRecord::UserAudioSettingsSoundMixName' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, UserAudioSettingsSoundMix) == 0x000150, "Member 'UClientSettingsRecord::UserAudioSettingsSoundMix' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, UserMasterSoundClassName) == 0x000158, "Member 'UClientSettingsRecord::UserMasterSoundClassName' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, UserMasterSoundClass) == 0x000170, "Member 'UClientSettingsRecord::UserMasterSoundClass' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, UserMusicSoundClassName) == 0x000178, "Member 'UClientSettingsRecord::UserMusicSoundClassName' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, UserMusicSoundClass) == 0x000190, "Member 'UClientSettingsRecord::UserMusicSoundClass' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, UserVoiceSoundClassName) == 0x000198, "Member 'UClientSettingsRecord::UserVoiceSoundClassName' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, UserVoiceSoundClass) == 0x0001B0, "Member 'UClientSettingsRecord::UserVoiceSoundClass' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, UserOtherSoundClassName) == 0x0001B8, "Member 'UClientSettingsRecord::UserOtherSoundClassName' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, UserOtherSoundClass) == 0x0001D0, "Member 'UClientSettingsRecord::UserOtherSoundClass' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, MasterGameVolume) == 0x0001D8, "Member 'UClientSettingsRecord::MasterGameVolume' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, MusicGameVolume) == 0x0001DC, "Member 'UClientSettingsRecord::MusicGameVolume' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, VoiceGameVolume) == 0x0001E0, "Member 'UClientSettingsRecord::VoiceGameVolume' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, OtherGameVolume) == 0x0001E4, "Member 'UClientSettingsRecord::OtherGameVolume' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, ThemeMusic) == 0x0001E8, "Member 'UClientSettingsRecord::ThemeMusic' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, ContinuousMusic) == 0x0001F8, "Member 'UClientSettingsRecord::ContinuousMusic' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, ActionKeyOverrides) == 0x000200, "Member 'UClientSettingsRecord::ActionKeyOverrides' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, ActionKeyOverridesCached) == 0x000210, "Member 'UClientSettingsRecord::ActionKeyOverridesCached' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, AxisKeyOverrides) == 0x000220, "Member 'UClientSettingsRecord::AxisKeyOverrides' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, AxisKeyOverridesCached) == 0x000230, "Member 'UClientSettingsRecord::AxisKeyOverridesCached' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, SelectedRegionId) == 0x000240, "Member 'UClientSettingsRecord::SelectedRegionId' has a wrong offset!");
static_assert(offsetof(UClientSettingsRecord, LastKnownBestRegionId) == 0x000250, "Member 'UClientSettingsRecord::LastKnownBestRegionId' has a wrong offset!");

// Class OrionGame.OrionAnimInstance
// 0x0060 (0x0418 - 0x03B8)
#pragma pack(push, 0x1)
class alignas(0x08) UOrionAnimInstance : public UAnimInstance
{
public:
	uint8                                         Pad_3B8[0x60];                                     // 0x03B8(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool ShouldRateLimitBlueprintTicks(bool bIsHero, float* Amount);

	void AnimNotify_LeftFootStep(const class UAnimNotify* Notify);
	void AnimNotify_RightFootStep(const class UAnimNotify* Notify);
	void OnHit(const struct FGameplayTagContainer& TargetTags, const struct FGameplayCueParameters& GameplayCueParameters);

	bool IsGameplayCueActive(const struct FGameplayTag& GameplayCueTag) const;
	bool IsSlotNodePlayingAMontage(const class FName& SlotNodeName) const;
	bool OwnerHasMatchingGameplayTag(const struct FGameplayTag& TagToCheck) const;
	class AOrionChar* TryGetOrionChar() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAnimInstance">();
	}
	static class UOrionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UOrionAnimInstance) == 0x000008, "Wrong alignment on UOrionAnimInstance");
static_assert(sizeof(UOrionAnimInstance) == 0x000418, "Wrong size on UOrionAnimInstance");

// Class OrionGame.OrionEnergyMissingPCT
// 0x0000 (0x0040 - 0x0040)
class UOrionEnergyMissingPCT final : public UGameplayModMagnitudeCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionEnergyMissingPCT">();
	}
	static class UOrionEnergyMissingPCT* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionEnergyMissingPCT>();
	}
};
static_assert(alignof(UOrionEnergyMissingPCT) == 0x000008, "Wrong alignment on UOrionEnergyMissingPCT");
static_assert(sizeof(UOrionEnergyMissingPCT) == 0x000040, "Wrong size on UOrionEnergyMissingPCT");

// Class OrionGame.OrionCoreRingsAnimInstance
// 0x0028 (0x0440 - 0x0418)
class UOrionCoreRingsAnimInstance final : public UOrionAnimInstance
{
public:
	class AActor*                                 OwnerActor;                                        // 0x0418(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CoreIsExposed;                                     // 0x0420(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_421[0x7];                                      // 0x0421(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CoreExposedFieldName;                              // 0x0428(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_438[0x8];                                      // 0x0438(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCoreRingsAnimInstance">();
	}
	static class UOrionCoreRingsAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionCoreRingsAnimInstance>();
	}
};
static_assert(alignof(UOrionCoreRingsAnimInstance) == 0x000008, "Wrong alignment on UOrionCoreRingsAnimInstance");
static_assert(sizeof(UOrionCoreRingsAnimInstance) == 0x000440, "Wrong size on UOrionCoreRingsAnimInstance");
static_assert(offsetof(UOrionCoreRingsAnimInstance, OwnerActor) == 0x000418, "Member 'UOrionCoreRingsAnimInstance::OwnerActor' has a wrong offset!");
static_assert(offsetof(UOrionCoreRingsAnimInstance, CoreIsExposed) == 0x000420, "Member 'UOrionCoreRingsAnimInstance::CoreIsExposed' has a wrong offset!");
static_assert(offsetof(UOrionCoreRingsAnimInstance, CoreExposedFieldName) == 0x000428, "Member 'UOrionCoreRingsAnimInstance::CoreExposedFieldName' has a wrong offset!");

// Class OrionGame.OrionClientPilotBlackboard
// 0x00D0 (0x00F8 - 0x0028)
class UOrionClientPilotBlackboard final : public UClientPilotBlackboard
{
public:
	uint8                                         Pad_28[0xD0];                                      // 0x0028(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionClientPilotBlackboard">();
	}
	static class UOrionClientPilotBlackboard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionClientPilotBlackboard>();
	}
};
static_assert(alignof(UOrionClientPilotBlackboard) == 0x000008, "Wrong alignment on UOrionClientPilotBlackboard");
static_assert(sizeof(UOrionClientPilotBlackboard) == 0x0000F8, "Wrong size on UOrionClientPilotBlackboard");

// Class OrionGame.EdgeNavLinks
// 0x0038 (0x03A0 - 0x0368)
class AEdgeNavLinks final : public ANavLinkProxy
{
public:
	float                                         DistanceBetweenLinks;                              // 0x0368(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Start;                                             // 0x036C(0x000C)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                End;                                               // 0x0378(0x000C)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SnapRadius;                                        // 0x0384(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SnapHeight;                                        // 0x0388(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LinkProjectionHeight;                              // 0x038C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RightLinkForwardOffset;                            // 0x0390(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             CollisionChannel;                                  // 0x0394(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_395[0x3];                                      // 0x0395(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bManualAdjustment : 1;                             // 0x0398(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_399[0x7];                                      // 0x0399(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EdgeNavLinks">();
	}
	static class AEdgeNavLinks* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEdgeNavLinks>();
	}
};
static_assert(alignof(AEdgeNavLinks) == 0x000008, "Wrong alignment on AEdgeNavLinks");
static_assert(sizeof(AEdgeNavLinks) == 0x0003A0, "Wrong size on AEdgeNavLinks");
static_assert(offsetof(AEdgeNavLinks, DistanceBetweenLinks) == 0x000368, "Member 'AEdgeNavLinks::DistanceBetweenLinks' has a wrong offset!");
static_assert(offsetof(AEdgeNavLinks, Start) == 0x00036C, "Member 'AEdgeNavLinks::Start' has a wrong offset!");
static_assert(offsetof(AEdgeNavLinks, End) == 0x000378, "Member 'AEdgeNavLinks::End' has a wrong offset!");
static_assert(offsetof(AEdgeNavLinks, SnapRadius) == 0x000384, "Member 'AEdgeNavLinks::SnapRadius' has a wrong offset!");
static_assert(offsetof(AEdgeNavLinks, SnapHeight) == 0x000388, "Member 'AEdgeNavLinks::SnapHeight' has a wrong offset!");
static_assert(offsetof(AEdgeNavLinks, LinkProjectionHeight) == 0x00038C, "Member 'AEdgeNavLinks::LinkProjectionHeight' has a wrong offset!");
static_assert(offsetof(AEdgeNavLinks, RightLinkForwardOffset) == 0x000390, "Member 'AEdgeNavLinks::RightLinkForwardOffset' has a wrong offset!");
static_assert(offsetof(AEdgeNavLinks, CollisionChannel) == 0x000394, "Member 'AEdgeNavLinks::CollisionChannel' has a wrong offset!");

// Class OrionGame.OrionClientBotManager_Base
// 0x00B8 (0x00E0 - 0x0028)
class UOrionClientBotManager_Base : public UObject
{
public:
	uint8                                         Pad_28[0x38];                                      // 0x0028(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CharToUse;                                         // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x4];                                       // 0x0070(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumLoginAttempts;                                  // 0x0074(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastChangedStateTime;                              // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSinceCreation;                                 // 0x007C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSinceLastJoinChatAttempt;                      // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AccountName;                                       // 0x0088(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Password;                                          // 0x0098(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChatDisabled;                                     // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWatchingForCallStack;                             // 0x00A9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVerboseBotLogging;                                // 0x00AA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMakeBotSpecificLog;                               // 0x00AB(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         SpecifiedDisplayNamesToInvite;                     // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x20];                                      // 0x00C0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionClientBotManager_Base">();
	}
	static class UOrionClientBotManager_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionClientBotManager_Base>();
	}
};
static_assert(alignof(UOrionClientBotManager_Base) == 0x000008, "Wrong alignment on UOrionClientBotManager_Base");
static_assert(sizeof(UOrionClientBotManager_Base) == 0x0000E0, "Wrong size on UOrionClientBotManager_Base");
static_assert(offsetof(UOrionClientBotManager_Base, CharToUse) == 0x000060, "Member 'UOrionClientBotManager_Base::CharToUse' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Base, NumLoginAttempts) == 0x000074, "Member 'UOrionClientBotManager_Base::NumLoginAttempts' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Base, LastChangedStateTime) == 0x000078, "Member 'UOrionClientBotManager_Base::LastChangedStateTime' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Base, TimeSinceCreation) == 0x00007C, "Member 'UOrionClientBotManager_Base::TimeSinceCreation' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Base, TimeSinceLastJoinChatAttempt) == 0x000080, "Member 'UOrionClientBotManager_Base::TimeSinceLastJoinChatAttempt' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Base, AccountName) == 0x000088, "Member 'UOrionClientBotManager_Base::AccountName' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Base, Password) == 0x000098, "Member 'UOrionClientBotManager_Base::Password' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Base, bChatDisabled) == 0x0000A8, "Member 'UOrionClientBotManager_Base::bChatDisabled' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Base, bWatchingForCallStack) == 0x0000A9, "Member 'UOrionClientBotManager_Base::bWatchingForCallStack' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Base, bVerboseBotLogging) == 0x0000AA, "Member 'UOrionClientBotManager_Base::bVerboseBotLogging' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Base, bMakeBotSpecificLog) == 0x0000AB, "Member 'UOrionClientBotManager_Base::bMakeBotSpecificLog' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Base, SpecifiedDisplayNamesToInvite) == 0x0000B0, "Member 'UOrionClientBotManager_Base::SpecifiedDisplayNamesToInvite' has a wrong offset!");

// Class OrionGame.OrionClientBotManager_Game
// 0x0390 (0x0470 - 0x00E0)
class UOrionClientBotManager_Game : public UOrionClientBotManager_Base
{
public:
	class UAbilitySystemComponent*                AbilitySystem;                                     // 0x00E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionPlayerState_Game*                 PlayerState;                                       // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionCharHero*                         MyPawn;                                            // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionTBRoboCaptain*                    CachedRoboCaptain;                                 // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CachedSelectedCharName;                            // 0x0100(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastCachedPosition;                                // 0x0110(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionTBPlayerChoices                  PlayerChoices;                                     // 0x0120(0x0108)(NativeAccessSpecifierPublic)
	TArray<class UOrionHeroData*>                 DesiredHeroes;                                     // 0x0228(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UOrionHeroData*                         SelectedHero;                                      // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         PartyLeaderPlayerChoices;                          // 0x0240(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         LastCheckGoodTarget;                               // 0x0250(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastPickEnemyHeroTime;                             // 0x0254(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastPickEnemyMinionTime;                           // 0x0258(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastPickEnemyStructureTime;                        // 0x025C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastTriedToRejoinTime;                             // 0x0260(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastTBLoopTime;                                    // 0x0264(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastDraftLoopTime;                                 // 0x0268(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToWaitForSocial;                               // 0x026C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeaveBaseByRunningForwardTimer;                    // 0x0270(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastTriedToReadyUpTime;                            // 0x0274(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AccountMmr;                                        // 0x0278(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27C[0x8];                                      // 0x027C(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bNeedsAccountMMRUpdate;                            // 0x0284(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMatchmakingOnly;                                  // 0x0285(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldRecordMemoryReports;                        // 0x0286(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldRecordMatchPerf;                            // 0x0287(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseOldFlow;                                       // 0x0288(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCaptain;                                        // 0x0289(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSoloRider;                                      // 0x028A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFastClientBot;                                  // 0x028B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasTriedToLockChar;                               // 0x028C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28D[0x3];                                      // 0x028D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlaylistId;                                        // 0x0290(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInGoodParty;                                    // 0x0294(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReadyToTravelToLobby;                             // 0x0295(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSentStartEvent;                                // 0x0296(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAgainstServerBots;                                // 0x0297(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowedToQueue;                                   // 0x0298(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPartyCharactersAssigned;                          // 0x0299(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFriendInvitesSent;                                // 0x029A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasCleanedUpPostGame;                             // 0x029B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TryToJoinRedTeamTime;                              // 0x029C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumPlayersInLobbyBeforeExiting;                    // 0x02A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumPlayersInQueue;                                 // 0x02A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionPartyMatchmakingState                   CachedMatchmakingState;                            // 0x02A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9[0x3];                                      // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeaveLobbyTime;                                    // 0x02AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PressAnyButtonOnTitleScreenTime;                   // 0x02B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunForYourLifeTime;                                // 0x02B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastAbilityFired;                                  // 0x02B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConfirmAbilityTimer;                               // 0x02BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BuyCardsTimer;                                     // 0x02C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastCheckMoveTime;                                 // 0x02C4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecallLastStartedTimer;                            // 0x02C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlowFieldCheckedTimer;                             // 0x02CC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeartbeatTimer;                                    // 0x02D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BotStateTimer;                                     // 0x02D4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastScreenshotTakenTime;                           // 0x02D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBetweenScreenshots;                            // 0x02DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldUseDefaultSkin;                             // 0x02E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldSendInvitesToRecentPlayers;                 // 0x02E1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E2[0x6];                                      // 0x02E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SkinToUse;                                         // 0x02E8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WhenToTryLeaving;                                  // 0x02F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChanceOfLeaving;                                   // 0x02FC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChanceOfClosingGame;                               // 0x0300(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumRejoinFailures;                                 // 0x0304(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WhenToClick;                                       // 0x0308(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasQueued;                                         // 0x030C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30D[0x3];                                      // 0x030D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LevelAbilityInterval;                              // 0x0310(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LevelAbilityTimer;                                 // 0x0314(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoAttackRange;                                   // 0x0318(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardMovement;                                   // 0x031C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightMovement;                                     // 0x0320(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_324[0x4];                                      // 0x0324(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrionNavField*                         CachedFlowField;                                   // 0x0328(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LaneAssignment;                                    // 0x0330(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ForcedLane;                                        // 0x0334(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionChar*                             EnemyMinionTarget;                                 // 0x0338(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionCharHero*                         EnemyHeroTarget;                                   // 0x0340(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionDamageableObjective_Base*         EnemyStructureTarget;                              // 0x0348(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionDamageableObjective_Base*         FriendlyStructureTarget;                           // 0x0350(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumCardsPurchased;                                 // 0x0358(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35C[0x14];                                     // 0x035C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ViewLocation;                                      // 0x0370(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ViewRotation;                                      // 0x037C(0x000C)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                FlowFieldVector;                                   // 0x0388(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_394[0x4];                                      // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayAbility*                       PendingAbility;                                    // 0x0398(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilitySpec                   RecentlyFiredAbility;                              // 0x03A0(0x00C8)(NativeAccessSpecifierPublic)
	uint8                                         Pad_468[0x8];                                      // 0x0468(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionClientBotManager_Game">();
	}
	static class UOrionClientBotManager_Game* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionClientBotManager_Game>();
	}
};
static_assert(alignof(UOrionClientBotManager_Game) == 0x000008, "Wrong alignment on UOrionClientBotManager_Game");
static_assert(sizeof(UOrionClientBotManager_Game) == 0x000470, "Wrong size on UOrionClientBotManager_Game");
static_assert(offsetof(UOrionClientBotManager_Game, AbilitySystem) == 0x0000E0, "Member 'UOrionClientBotManager_Game::AbilitySystem' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, PlayerState) == 0x0000E8, "Member 'UOrionClientBotManager_Game::PlayerState' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, MyPawn) == 0x0000F0, "Member 'UOrionClientBotManager_Game::MyPawn' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, CachedRoboCaptain) == 0x0000F8, "Member 'UOrionClientBotManager_Game::CachedRoboCaptain' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, CachedSelectedCharName) == 0x000100, "Member 'UOrionClientBotManager_Game::CachedSelectedCharName' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, LastCachedPosition) == 0x000110, "Member 'UOrionClientBotManager_Game::LastCachedPosition' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, PlayerChoices) == 0x000120, "Member 'UOrionClientBotManager_Game::PlayerChoices' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, DesiredHeroes) == 0x000228, "Member 'UOrionClientBotManager_Game::DesiredHeroes' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, SelectedHero) == 0x000238, "Member 'UOrionClientBotManager_Game::SelectedHero' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, PartyLeaderPlayerChoices) == 0x000240, "Member 'UOrionClientBotManager_Game::PartyLeaderPlayerChoices' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, LastCheckGoodTarget) == 0x000250, "Member 'UOrionClientBotManager_Game::LastCheckGoodTarget' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, LastPickEnemyHeroTime) == 0x000254, "Member 'UOrionClientBotManager_Game::LastPickEnemyHeroTime' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, LastPickEnemyMinionTime) == 0x000258, "Member 'UOrionClientBotManager_Game::LastPickEnemyMinionTime' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, LastPickEnemyStructureTime) == 0x00025C, "Member 'UOrionClientBotManager_Game::LastPickEnemyStructureTime' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, LastTriedToRejoinTime) == 0x000260, "Member 'UOrionClientBotManager_Game::LastTriedToRejoinTime' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, LastTBLoopTime) == 0x000264, "Member 'UOrionClientBotManager_Game::LastTBLoopTime' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, LastDraftLoopTime) == 0x000268, "Member 'UOrionClientBotManager_Game::LastDraftLoopTime' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, TimeToWaitForSocial) == 0x00026C, "Member 'UOrionClientBotManager_Game::TimeToWaitForSocial' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, LeaveBaseByRunningForwardTimer) == 0x000270, "Member 'UOrionClientBotManager_Game::LeaveBaseByRunningForwardTimer' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, LastTriedToReadyUpTime) == 0x000274, "Member 'UOrionClientBotManager_Game::LastTriedToReadyUpTime' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, AccountMmr) == 0x000278, "Member 'UOrionClientBotManager_Game::AccountMmr' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, bNeedsAccountMMRUpdate) == 0x000284, "Member 'UOrionClientBotManager_Game::bNeedsAccountMMRUpdate' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, bMatchmakingOnly) == 0x000285, "Member 'UOrionClientBotManager_Game::bMatchmakingOnly' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, bShouldRecordMemoryReports) == 0x000286, "Member 'UOrionClientBotManager_Game::bShouldRecordMemoryReports' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, bShouldRecordMatchPerf) == 0x000287, "Member 'UOrionClientBotManager_Game::bShouldRecordMatchPerf' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, bUseOldFlow) == 0x000288, "Member 'UOrionClientBotManager_Game::bUseOldFlow' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, bIsCaptain) == 0x000289, "Member 'UOrionClientBotManager_Game::bIsCaptain' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, bIsSoloRider) == 0x00028A, "Member 'UOrionClientBotManager_Game::bIsSoloRider' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, bIsFastClientBot) == 0x00028B, "Member 'UOrionClientBotManager_Game::bIsFastClientBot' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, bHasTriedToLockChar) == 0x00028C, "Member 'UOrionClientBotManager_Game::bHasTriedToLockChar' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, PlaylistId) == 0x000290, "Member 'UOrionClientBotManager_Game::PlaylistId' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, bIsInGoodParty) == 0x000294, "Member 'UOrionClientBotManager_Game::bIsInGoodParty' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, bReadyToTravelToLobby) == 0x000295, "Member 'UOrionClientBotManager_Game::bReadyToTravelToLobby' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, bHasSentStartEvent) == 0x000296, "Member 'UOrionClientBotManager_Game::bHasSentStartEvent' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, bAgainstServerBots) == 0x000297, "Member 'UOrionClientBotManager_Game::bAgainstServerBots' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, bAllowedToQueue) == 0x000298, "Member 'UOrionClientBotManager_Game::bAllowedToQueue' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, bPartyCharactersAssigned) == 0x000299, "Member 'UOrionClientBotManager_Game::bPartyCharactersAssigned' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, bFriendInvitesSent) == 0x00029A, "Member 'UOrionClientBotManager_Game::bFriendInvitesSent' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, bHasCleanedUpPostGame) == 0x00029B, "Member 'UOrionClientBotManager_Game::bHasCleanedUpPostGame' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, TryToJoinRedTeamTime) == 0x00029C, "Member 'UOrionClientBotManager_Game::TryToJoinRedTeamTime' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, NumPlayersInLobbyBeforeExiting) == 0x0002A0, "Member 'UOrionClientBotManager_Game::NumPlayersInLobbyBeforeExiting' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, NumPlayersInQueue) == 0x0002A4, "Member 'UOrionClientBotManager_Game::NumPlayersInQueue' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, CachedMatchmakingState) == 0x0002A8, "Member 'UOrionClientBotManager_Game::CachedMatchmakingState' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, LeaveLobbyTime) == 0x0002AC, "Member 'UOrionClientBotManager_Game::LeaveLobbyTime' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, PressAnyButtonOnTitleScreenTime) == 0x0002B0, "Member 'UOrionClientBotManager_Game::PressAnyButtonOnTitleScreenTime' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, RunForYourLifeTime) == 0x0002B4, "Member 'UOrionClientBotManager_Game::RunForYourLifeTime' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, LastAbilityFired) == 0x0002B8, "Member 'UOrionClientBotManager_Game::LastAbilityFired' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, ConfirmAbilityTimer) == 0x0002BC, "Member 'UOrionClientBotManager_Game::ConfirmAbilityTimer' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, BuyCardsTimer) == 0x0002C0, "Member 'UOrionClientBotManager_Game::BuyCardsTimer' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, LastCheckMoveTime) == 0x0002C4, "Member 'UOrionClientBotManager_Game::LastCheckMoveTime' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, RecallLastStartedTimer) == 0x0002C8, "Member 'UOrionClientBotManager_Game::RecallLastStartedTimer' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, FlowFieldCheckedTimer) == 0x0002CC, "Member 'UOrionClientBotManager_Game::FlowFieldCheckedTimer' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, HeartbeatTimer) == 0x0002D0, "Member 'UOrionClientBotManager_Game::HeartbeatTimer' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, BotStateTimer) == 0x0002D4, "Member 'UOrionClientBotManager_Game::BotStateTimer' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, LastScreenshotTakenTime) == 0x0002D8, "Member 'UOrionClientBotManager_Game::LastScreenshotTakenTime' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, TimeBetweenScreenshots) == 0x0002DC, "Member 'UOrionClientBotManager_Game::TimeBetweenScreenshots' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, bShouldUseDefaultSkin) == 0x0002E0, "Member 'UOrionClientBotManager_Game::bShouldUseDefaultSkin' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, bShouldSendInvitesToRecentPlayers) == 0x0002E1, "Member 'UOrionClientBotManager_Game::bShouldSendInvitesToRecentPlayers' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, SkinToUse) == 0x0002E8, "Member 'UOrionClientBotManager_Game::SkinToUse' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, WhenToTryLeaving) == 0x0002F8, "Member 'UOrionClientBotManager_Game::WhenToTryLeaving' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, ChanceOfLeaving) == 0x0002FC, "Member 'UOrionClientBotManager_Game::ChanceOfLeaving' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, ChanceOfClosingGame) == 0x000300, "Member 'UOrionClientBotManager_Game::ChanceOfClosingGame' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, NumRejoinFailures) == 0x000304, "Member 'UOrionClientBotManager_Game::NumRejoinFailures' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, WhenToClick) == 0x000308, "Member 'UOrionClientBotManager_Game::WhenToClick' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, HasQueued) == 0x00030C, "Member 'UOrionClientBotManager_Game::HasQueued' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, LevelAbilityInterval) == 0x000310, "Member 'UOrionClientBotManager_Game::LevelAbilityInterval' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, LevelAbilityTimer) == 0x000314, "Member 'UOrionClientBotManager_Game::LevelAbilityTimer' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, AutoAttackRange) == 0x000318, "Member 'UOrionClientBotManager_Game::AutoAttackRange' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, ForwardMovement) == 0x00031C, "Member 'UOrionClientBotManager_Game::ForwardMovement' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, RightMovement) == 0x000320, "Member 'UOrionClientBotManager_Game::RightMovement' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, CachedFlowField) == 0x000328, "Member 'UOrionClientBotManager_Game::CachedFlowField' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, LaneAssignment) == 0x000330, "Member 'UOrionClientBotManager_Game::LaneAssignment' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, ForcedLane) == 0x000334, "Member 'UOrionClientBotManager_Game::ForcedLane' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, EnemyMinionTarget) == 0x000338, "Member 'UOrionClientBotManager_Game::EnemyMinionTarget' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, EnemyHeroTarget) == 0x000340, "Member 'UOrionClientBotManager_Game::EnemyHeroTarget' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, EnemyStructureTarget) == 0x000348, "Member 'UOrionClientBotManager_Game::EnemyStructureTarget' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, FriendlyStructureTarget) == 0x000350, "Member 'UOrionClientBotManager_Game::FriendlyStructureTarget' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, NumCardsPurchased) == 0x000358, "Member 'UOrionClientBotManager_Game::NumCardsPurchased' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, ViewLocation) == 0x000370, "Member 'UOrionClientBotManager_Game::ViewLocation' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, ViewRotation) == 0x00037C, "Member 'UOrionClientBotManager_Game::ViewRotation' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, FlowFieldVector) == 0x000388, "Member 'UOrionClientBotManager_Game::FlowFieldVector' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, PendingAbility) == 0x000398, "Member 'UOrionClientBotManager_Game::PendingAbility' has a wrong offset!");
static_assert(offsetof(UOrionClientBotManager_Game, RecentlyFiredAbility) == 0x0003A0, "Member 'UOrionClientBotManager_Game::RecentlyFiredAbility' has a wrong offset!");

// Class OrionGame.OrionClientBotManager_MatchPerf
// 0x0090 (0x0500 - 0x0470)
class UOrionClientBotManager_MatchPerf final : public UOrionClientBotManager_Game
{
public:
	uint8                                         Pad_470[0x90];                                     // 0x0470(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionClientBotManager_MatchPerf">();
	}
	static class UOrionClientBotManager_MatchPerf* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionClientBotManager_MatchPerf>();
	}
};
static_assert(alignof(UOrionClientBotManager_MatchPerf) == 0x000008, "Wrong alignment on UOrionClientBotManager_MatchPerf");
static_assert(sizeof(UOrionClientBotManager_MatchPerf) == 0x000500, "Wrong size on UOrionClientBotManager_MatchPerf");

// Class OrionGame.EdgeNavLinksRenderingComponent
// 0x0000 (0x0690 - 0x0690)
class UEdgeNavLinksRenderingComponent final : public UNavLinkRenderingComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EdgeNavLinksRenderingComponent">();
	}
	static class UEdgeNavLinksRenderingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEdgeNavLinksRenderingComponent>();
	}
};
static_assert(alignof(UEdgeNavLinksRenderingComponent) == 0x000010, "Wrong alignment on UEdgeNavLinksRenderingComponent");
static_assert(sizeof(UEdgeNavLinksRenderingComponent) == 0x000690, "Wrong size on UEdgeNavLinksRenderingComponent");

// Class OrionGame.FrontEndManager
// 0x0060 (0x0378 - 0x0318)
class AFrontEndManager : public AActor
{
public:
	TArray<struct FFrontEndCamera>                CameraScenes;                                      // 0x0318(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TMap<class FName, class ACameraActor*>        SceneMapping;                                      // 0x0328(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	class AActor* GetScene(const class FName SceneName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FrontEndManager">();
	}
	static class AFrontEndManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFrontEndManager>();
	}
};
static_assert(alignof(AFrontEndManager) == 0x000008, "Wrong alignment on AFrontEndManager");
static_assert(sizeof(AFrontEndManager) == 0x000378, "Wrong size on AFrontEndManager");
static_assert(offsetof(AFrontEndManager, CameraScenes) == 0x000318, "Member 'AFrontEndManager::CameraScenes' has a wrong offset!");
static_assert(offsetof(AFrontEndManager, SceneMapping) == 0x000328, "Member 'AFrontEndManager::SceneMapping' has a wrong offset!");

// Class OrionGame.FTC_ActorDestroyed
// 0x0030 (0x0088 - 0x0058)
class UFTC_ActorDestroyed final : public UFunctionalTestCondition
{
public:
	EFTestActorKey                                TestActorKey;                                      // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomKey;                                         // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x18];                                      // 0x0070(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FTC_ActorDestroyed">();
	}
	static class UFTC_ActorDestroyed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFTC_ActorDestroyed>();
	}
};
static_assert(alignof(UFTC_ActorDestroyed) == 0x000008, "Wrong alignment on UFTC_ActorDestroyed");
static_assert(sizeof(UFTC_ActorDestroyed) == 0x000088, "Wrong size on UFTC_ActorDestroyed");
static_assert(offsetof(UFTC_ActorDestroyed, TestActorKey) == 0x000058, "Member 'UFTC_ActorDestroyed::TestActorKey' has a wrong offset!");
static_assert(offsetof(UFTC_ActorDestroyed, CustomKey) == 0x000060, "Member 'UFTC_ActorDestroyed::CustomKey' has a wrong offset!");

// Class OrionGame.FTC_ActorExists
// 0x0030 (0x0088 - 0x0058)
class UFTC_ActorExists final : public UFunctionalTestCondition
{
public:
	EFCheckType                                   CheckType;                                         // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFTestActorKey                                TestActorKey;                                      // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomKey;                                         // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x18];                                      // 0x0070(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FTC_ActorExists">();
	}
	static class UFTC_ActorExists* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFTC_ActorExists>();
	}
};
static_assert(alignof(UFTC_ActorExists) == 0x000008, "Wrong alignment on UFTC_ActorExists");
static_assert(sizeof(UFTC_ActorExists) == 0x000088, "Wrong size on UFTC_ActorExists");
static_assert(offsetof(UFTC_ActorExists, CheckType) == 0x000058, "Member 'UFTC_ActorExists::CheckType' has a wrong offset!");
static_assert(offsetof(UFTC_ActorExists, TestActorKey) == 0x000059, "Member 'UFTC_ActorExists::TestActorKey' has a wrong offset!");
static_assert(offsetof(UFTC_ActorExists, CustomKey) == 0x000060, "Member 'UFTC_ActorExists::CustomKey' has a wrong offset!");

// Class OrionGame.FTC_DefaultRunTestSteps
// 0x0000 (0x0058 - 0x0058)
class UFTC_DefaultRunTestSteps final : public UFunctionalTestCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FTC_DefaultRunTestSteps">();
	}
	static class UFTC_DefaultRunTestSteps* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFTC_DefaultRunTestSteps>();
	}
};
static_assert(alignof(UFTC_DefaultRunTestSteps) == 0x000008, "Wrong alignment on UFTC_DefaultRunTestSteps");
static_assert(sizeof(UFTC_DefaultRunTestSteps) == 0x000058, "Wrong size on UFTC_DefaultRunTestSteps");

// Class OrionGame.OrionGameMode_ArcadeLobby
// 0x0050 (0x0530 - 0x04E0)
class AOrionGameMode_ArcadeLobby final : public AOrionGameMode_Base
{
public:
	uint8                                         Pad_4E0[0x8];                                      // 0x04E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FinishAsyncLoadTimeout;                            // 0x04E8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4EC[0xC];                                      // 0x04EC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLadderURLData                         LadderData;                                        // 0x04F8(0x0038)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameMode_ArcadeLobby">();
	}
	static class AOrionGameMode_ArcadeLobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionGameMode_ArcadeLobby>();
	}
};
static_assert(alignof(AOrionGameMode_ArcadeLobby) == 0x000008, "Wrong alignment on AOrionGameMode_ArcadeLobby");
static_assert(sizeof(AOrionGameMode_ArcadeLobby) == 0x000530, "Wrong size on AOrionGameMode_ArcadeLobby");
static_assert(offsetof(AOrionGameMode_ArcadeLobby, FinishAsyncLoadTimeout) == 0x0004E8, "Member 'AOrionGameMode_ArcadeLobby::FinishAsyncLoadTimeout' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_ArcadeLobby, LadderData) == 0x0004F8, "Member 'AOrionGameMode_ArcadeLobby::LadderData' has a wrong offset!");

// Class OrionGame.FTC_DistanceMoved
// 0x0078 (0x00D0 - 0x0058)
class UFTC_DistanceMoved final : public UFunctionalTestCondition
{
public:
	EFTestActorKey                                SuggestedActorKey;                                 // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomKey;                                         // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExpectedDistance;                                  // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EActorDistanceType                            DistanceToTrack;                                   // 0x0074(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreVerticality;                                // 0x0075(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_76[0x5A];                                      // 0x0076(0x005A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FTC_DistanceMoved">();
	}
	static class UFTC_DistanceMoved* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFTC_DistanceMoved>();
	}
};
static_assert(alignof(UFTC_DistanceMoved) == 0x000008, "Wrong alignment on UFTC_DistanceMoved");
static_assert(sizeof(UFTC_DistanceMoved) == 0x0000D0, "Wrong size on UFTC_DistanceMoved");
static_assert(offsetof(UFTC_DistanceMoved, SuggestedActorKey) == 0x000058, "Member 'UFTC_DistanceMoved::SuggestedActorKey' has a wrong offset!");
static_assert(offsetof(UFTC_DistanceMoved, CustomKey) == 0x000060, "Member 'UFTC_DistanceMoved::CustomKey' has a wrong offset!");
static_assert(offsetof(UFTC_DistanceMoved, ExpectedDistance) == 0x000070, "Member 'UFTC_DistanceMoved::ExpectedDistance' has a wrong offset!");
static_assert(offsetof(UFTC_DistanceMoved, DistanceToTrack) == 0x000074, "Member 'UFTC_DistanceMoved::DistanceToTrack' has a wrong offset!");
static_assert(offsetof(UFTC_DistanceMoved, bIgnoreVerticality) == 0x000075, "Member 'UFTC_DistanceMoved::bIgnoreVerticality' has a wrong offset!");

// Class OrionGame.FTC_GameplayAttributeChanged
// 0x0058 (0x00B0 - 0x0058)
class UFTC_GameplayAttributeChanged final : public UFunctionalTestCondition
{
public:
	struct FGameplayAttribute                     AttributeToCheck;                                  // 0x0058(0x0020)(Edit, BlueprintVisible, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExpectedDelta;                                     // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFTestActorKey                                SuggestedTargetActorKey;                           // 0x007C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomTargetActorKey;                              // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x20];                                      // 0x0090(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FTC_GameplayAttributeChanged">();
	}
	static class UFTC_GameplayAttributeChanged* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFTC_GameplayAttributeChanged>();
	}
};
static_assert(alignof(UFTC_GameplayAttributeChanged) == 0x000008, "Wrong alignment on UFTC_GameplayAttributeChanged");
static_assert(sizeof(UFTC_GameplayAttributeChanged) == 0x0000B0, "Wrong size on UFTC_GameplayAttributeChanged");
static_assert(offsetof(UFTC_GameplayAttributeChanged, AttributeToCheck) == 0x000058, "Member 'UFTC_GameplayAttributeChanged::AttributeToCheck' has a wrong offset!");
static_assert(offsetof(UFTC_GameplayAttributeChanged, ExpectedDelta) == 0x000078, "Member 'UFTC_GameplayAttributeChanged::ExpectedDelta' has a wrong offset!");
static_assert(offsetof(UFTC_GameplayAttributeChanged, SuggestedTargetActorKey) == 0x00007C, "Member 'UFTC_GameplayAttributeChanged::SuggestedTargetActorKey' has a wrong offset!");
static_assert(offsetof(UFTC_GameplayAttributeChanged, CustomTargetActorKey) == 0x000080, "Member 'UFTC_GameplayAttributeChanged::CustomTargetActorKey' has a wrong offset!");

// Class OrionGame.OrionGameEventManager
// 0x0178 (0x0490 - 0x0318)
class AOrionGameEventManager final : public AInfo
{
public:
	TArray<class AOrionPlayerState_Game*>         TrackedPlayers;                                    // 0x0318(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FOrionTrackedQuests>            QuestsWaitingOnPlayer;                             // 0x0328(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FOrionTrackedQuests>            RegisteredQuests;                                  // 0x0338(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_348[0x148];                                    // 0x0348(0x0148)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameEventManager">();
	}
	static class AOrionGameEventManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionGameEventManager>();
	}
};
static_assert(alignof(AOrionGameEventManager) == 0x000008, "Wrong alignment on AOrionGameEventManager");
static_assert(sizeof(AOrionGameEventManager) == 0x000490, "Wrong size on AOrionGameEventManager");
static_assert(offsetof(AOrionGameEventManager, TrackedPlayers) == 0x000318, "Member 'AOrionGameEventManager::TrackedPlayers' has a wrong offset!");
static_assert(offsetof(AOrionGameEventManager, QuestsWaitingOnPlayer) == 0x000328, "Member 'AOrionGameEventManager::QuestsWaitingOnPlayer' has a wrong offset!");
static_assert(offsetof(AOrionGameEventManager, RegisteredQuests) == 0x000338, "Member 'AOrionGameEventManager::RegisteredQuests' has a wrong offset!");

// Class OrionGame.FTC_GameplayCue
// 0x0070 (0x00C8 - 0x0058)
class UFTC_GameplayCue final : public UFunctionalTestCondition
{
public:
	struct FGameplayTag                           ExpectedGameplayCueTag;                            // 0x0058(0x0008)(Edit, BlueprintVisible, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFTestActorKey                                SuggestedActorKey;                                 // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomKey;                                         // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpectedOnActiveInstances;                         // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpectedWhileActiveInstances;                      // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpectedRemovedInstances;                          // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpectedExecutedInstances;                         // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDebugLogging;                               // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3F];                                      // 0x0089(0x003F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FTC_GameplayCue">();
	}
	static class UFTC_GameplayCue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFTC_GameplayCue>();
	}
};
static_assert(alignof(UFTC_GameplayCue) == 0x000008, "Wrong alignment on UFTC_GameplayCue");
static_assert(sizeof(UFTC_GameplayCue) == 0x0000C8, "Wrong size on UFTC_GameplayCue");
static_assert(offsetof(UFTC_GameplayCue, ExpectedGameplayCueTag) == 0x000058, "Member 'UFTC_GameplayCue::ExpectedGameplayCueTag' has a wrong offset!");
static_assert(offsetof(UFTC_GameplayCue, SuggestedActorKey) == 0x000060, "Member 'UFTC_GameplayCue::SuggestedActorKey' has a wrong offset!");
static_assert(offsetof(UFTC_GameplayCue, CustomKey) == 0x000068, "Member 'UFTC_GameplayCue::CustomKey' has a wrong offset!");
static_assert(offsetof(UFTC_GameplayCue, ExpectedOnActiveInstances) == 0x000078, "Member 'UFTC_GameplayCue::ExpectedOnActiveInstances' has a wrong offset!");
static_assert(offsetof(UFTC_GameplayCue, ExpectedWhileActiveInstances) == 0x00007C, "Member 'UFTC_GameplayCue::ExpectedWhileActiveInstances' has a wrong offset!");
static_assert(offsetof(UFTC_GameplayCue, ExpectedRemovedInstances) == 0x000080, "Member 'UFTC_GameplayCue::ExpectedRemovedInstances' has a wrong offset!");
static_assert(offsetof(UFTC_GameplayCue, ExpectedExecutedInstances) == 0x000084, "Member 'UFTC_GameplayCue::ExpectedExecutedInstances' has a wrong offset!");
static_assert(offsetof(UFTC_GameplayCue, bEnableDebugLogging) == 0x000088, "Member 'UFTC_GameplayCue::bEnableDebugLogging' has a wrong offset!");

// Class OrionGame.FTC_GameplayEffect
// 0x0050 (0x00A8 - 0x0058)
class UFTC_GameplayEffect final : public UFunctionalTestCondition
{
public:
	TSubclassOf<class UGameplayEffect>            GameplayEffect;                                    // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFTestActorKey                                SuggestedActorKey;                                 // 0x0060(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomKey;                                         // 0x0068(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpectedGameplayEffectStacks;                      // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x2C];                                      // 0x007C(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FTC_GameplayEffect">();
	}
	static class UFTC_GameplayEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFTC_GameplayEffect>();
	}
};
static_assert(alignof(UFTC_GameplayEffect) == 0x000008, "Wrong alignment on UFTC_GameplayEffect");
static_assert(sizeof(UFTC_GameplayEffect) == 0x0000A8, "Wrong size on UFTC_GameplayEffect");
static_assert(offsetof(UFTC_GameplayEffect, GameplayEffect) == 0x000058, "Member 'UFTC_GameplayEffect::GameplayEffect' has a wrong offset!");
static_assert(offsetof(UFTC_GameplayEffect, SuggestedActorKey) == 0x000060, "Member 'UFTC_GameplayEffect::SuggestedActorKey' has a wrong offset!");
static_assert(offsetof(UFTC_GameplayEffect, CustomKey) == 0x000068, "Member 'UFTC_GameplayEffect::CustomKey' has a wrong offset!");
static_assert(offsetof(UFTC_GameplayEffect, ExpectedGameplayEffectStacks) == 0x000078, "Member 'UFTC_GameplayEffect::ExpectedGameplayEffectStacks' has a wrong offset!");

// Class OrionGame.OrionEQSTestingPawn
// 0x0070 (0x0820 - 0x07B0)
class AOrionEQSTestingPawn final : public AEQSTestingPawn
{
public:
	EOrionTeam                                    TeamNum;                                           // 0x07B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B1[0x7];                                      // 0x07B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         EnemyList;                                         // 0x07B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         DamageLocations;                                   // 0x07C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         Teammates;                                         // 0x07D8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class AActor*                                 SafeHouseActor;                                    // 0x07E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionDamageableObjective_Base*         LaneGoal;                                          // 0x07F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ObjectiveActor;                                    // 0x07F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 CurrentDestination;                                // 0x0800(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AbilityRange;                                      // 0x0808(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Aggression;                                        // 0x080C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LaneID;                                            // 0x0810(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_814[0xC];                                      // 0x0814(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EOrionTeam GetTeamNum() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionEQSTestingPawn">();
	}
	static class AOrionEQSTestingPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionEQSTestingPawn>();
	}
};
static_assert(alignof(AOrionEQSTestingPawn) == 0x000010, "Wrong alignment on AOrionEQSTestingPawn");
static_assert(sizeof(AOrionEQSTestingPawn) == 0x000820, "Wrong size on AOrionEQSTestingPawn");
static_assert(offsetof(AOrionEQSTestingPawn, TeamNum) == 0x0007B0, "Member 'AOrionEQSTestingPawn::TeamNum' has a wrong offset!");
static_assert(offsetof(AOrionEQSTestingPawn, EnemyList) == 0x0007B8, "Member 'AOrionEQSTestingPawn::EnemyList' has a wrong offset!");
static_assert(offsetof(AOrionEQSTestingPawn, DamageLocations) == 0x0007C8, "Member 'AOrionEQSTestingPawn::DamageLocations' has a wrong offset!");
static_assert(offsetof(AOrionEQSTestingPawn, Teammates) == 0x0007D8, "Member 'AOrionEQSTestingPawn::Teammates' has a wrong offset!");
static_assert(offsetof(AOrionEQSTestingPawn, SafeHouseActor) == 0x0007E8, "Member 'AOrionEQSTestingPawn::SafeHouseActor' has a wrong offset!");
static_assert(offsetof(AOrionEQSTestingPawn, LaneGoal) == 0x0007F0, "Member 'AOrionEQSTestingPawn::LaneGoal' has a wrong offset!");
static_assert(offsetof(AOrionEQSTestingPawn, ObjectiveActor) == 0x0007F8, "Member 'AOrionEQSTestingPawn::ObjectiveActor' has a wrong offset!");
static_assert(offsetof(AOrionEQSTestingPawn, CurrentDestination) == 0x000800, "Member 'AOrionEQSTestingPawn::CurrentDestination' has a wrong offset!");
static_assert(offsetof(AOrionEQSTestingPawn, AbilityRange) == 0x000808, "Member 'AOrionEQSTestingPawn::AbilityRange' has a wrong offset!");
static_assert(offsetof(AOrionEQSTestingPawn, Aggression) == 0x00080C, "Member 'AOrionEQSTestingPawn::Aggression' has a wrong offset!");
static_assert(offsetof(AOrionEQSTestingPawn, LaneID) == 0x000810, "Member 'AOrionEQSTestingPawn::LaneID' has a wrong offset!");

// Class OrionGame.FTC_GameplayTag
// 0x0040 (0x0098 - 0x0058)
class UFTC_GameplayTag final : public UFunctionalTestCondition
{
public:
	EFTestActorKey                                SuggestedTargetActorKey;                           // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomTargetActorKey;                              // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TagToCheck;                                        // 0x0070(0x0008)(Edit, BlueprintVisible, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x20];                                      // 0x0078(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FTC_GameplayTag">();
	}
	static class UFTC_GameplayTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFTC_GameplayTag>();
	}
};
static_assert(alignof(UFTC_GameplayTag) == 0x000008, "Wrong alignment on UFTC_GameplayTag");
static_assert(sizeof(UFTC_GameplayTag) == 0x000098, "Wrong size on UFTC_GameplayTag");
static_assert(offsetof(UFTC_GameplayTag, SuggestedTargetActorKey) == 0x000058, "Member 'UFTC_GameplayTag::SuggestedTargetActorKey' has a wrong offset!");
static_assert(offsetof(UFTC_GameplayTag, CustomTargetActorKey) == 0x000060, "Member 'UFTC_GameplayTag::CustomTargetActorKey' has a wrong offset!");
static_assert(offsetof(UFTC_GameplayTag, TagToCheck) == 0x000070, "Member 'UFTC_GameplayTag::TagToCheck' has a wrong offset!");

// Class OrionGame.OrionPlayerState_Base
// 0x0560 (0x0910 - 0x03B0)
class AOrionPlayerState_Base : public APlayerState
{
public:
	uint8                                         Pad_3B0[0x8];                                      // 0x03B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionHeroDataSpec                     HeroDataSpec;                                      // 0x03B8(0x00A8)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	EOrionPlayerPlatform                          PlayerPlatform;                                    // 0x0460(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_461[0x7];                                      // 0x0461(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrionTeamInfo*                         TeamInfo;                                          // 0x0468(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_470[0x4];                                      // 0x0470(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bReadyToStartMatch;                                // 0x0474(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_475[0x3];                                      // 0x0475(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUniqueNetIdRepl                       PartyOwnerUniqueId;                                // 0x0478(0x0018)(Net, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_490[0x134];                                    // 0x0490(0x0134)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsAfk;                                            // 0x05C4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C5[0x3];                                      // 0x05C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastAfkStartWorldTime;                             // 0x05C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ClientLastActiveWorldTime;                         // 0x05CC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ServerLastActiveWorldTime;                         // 0x05D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ServerLastActiveRealTime;                          // 0x05D4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ServerLastSlateActivityWorldTime;                  // 0x05D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinClientAfkPeriod;                                // 0x05DC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinServerAfkPeriod;                                // 0x05E0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          AllowSlateTouch;                                   // 0x05E4(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInitializedFromMatchmakingData;                   // 0x05E5(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E6[0x23A];                                    // 0x05E6(0x023A)(Fixing Size After Last Property [ Dumper-7 ])
	EOrionPosition                                PlayerPosition;                                    // 0x0820(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPlayerDisconnected;                             // 0x0821(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_822[0x6];                                      // 0x0822(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UOrionMcpBannerItem*>            CurrentBanners;                                    // 0x0828(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UOrionMcpBannerAlterationItem*>  CurrentBannerAlterations;                          // 0x0838(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FString                                 CurrentlyActiveBanner;                             // 0x0848(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_858[0x10];                                     // 0x0858(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionHeroDataSpec                     OldHeroDataSpec;                                   // 0x0868(0x00A8)(Transient, NativeAccessSpecifierPrivate)

public:
	void ClientAutomationKeepActive();
	void ClientFailedToPickHero(const struct FOrionHeroDataSpec& InHeroDataSpec);
	void OnRep_bInitializedFromMatchmakingData();
	void OnRep_bIsPlayerDisconnected();
	void OnRep_bReadyToStartMatch();
	void OnRep_HeroDataSpec();
	void OnRep_PartyOwner();
	void OnRep_Team(const class AOrionTeamInfo* OldTeamInfo);
	void ServerAutomationKeepActive();
	void ServerClearPlayerHeroData();
	void ServerNotifySlateActivity();
	void ServerSetPlayerHeroDataSpec(const struct FOrionHeroDataSpec& InHeroDataSpec);

	class UOrionHeroData* _BPGetHeroData() const;
	EOrionPosition GetPlayerPosition() const;
	EOrionTeam GetTeamNum() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPlayerState_Base">();
	}
	static class AOrionPlayerState_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionPlayerState_Base>();
	}
};
static_assert(alignof(AOrionPlayerState_Base) == 0x000008, "Wrong alignment on AOrionPlayerState_Base");
static_assert(sizeof(AOrionPlayerState_Base) == 0x000910, "Wrong size on AOrionPlayerState_Base");
static_assert(offsetof(AOrionPlayerState_Base, HeroDataSpec) == 0x0003B8, "Member 'AOrionPlayerState_Base::HeroDataSpec' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Base, PlayerPlatform) == 0x000460, "Member 'AOrionPlayerState_Base::PlayerPlatform' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Base, TeamInfo) == 0x000468, "Member 'AOrionPlayerState_Base::TeamInfo' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Base, bReadyToStartMatch) == 0x000474, "Member 'AOrionPlayerState_Base::bReadyToStartMatch' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Base, PartyOwnerUniqueId) == 0x000478, "Member 'AOrionPlayerState_Base::PartyOwnerUniqueId' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Base, bIsAfk) == 0x0005C4, "Member 'AOrionPlayerState_Base::bIsAfk' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Base, LastAfkStartWorldTime) == 0x0005C8, "Member 'AOrionPlayerState_Base::LastAfkStartWorldTime' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Base, ClientLastActiveWorldTime) == 0x0005CC, "Member 'AOrionPlayerState_Base::ClientLastActiveWorldTime' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Base, ServerLastActiveWorldTime) == 0x0005D0, "Member 'AOrionPlayerState_Base::ServerLastActiveWorldTime' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Base, ServerLastActiveRealTime) == 0x0005D4, "Member 'AOrionPlayerState_Base::ServerLastActiveRealTime' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Base, ServerLastSlateActivityWorldTime) == 0x0005D8, "Member 'AOrionPlayerState_Base::ServerLastSlateActivityWorldTime' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Base, MinClientAfkPeriod) == 0x0005DC, "Member 'AOrionPlayerState_Base::MinClientAfkPeriod' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Base, MinServerAfkPeriod) == 0x0005E0, "Member 'AOrionPlayerState_Base::MinServerAfkPeriod' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Base, AllowSlateTouch) == 0x0005E4, "Member 'AOrionPlayerState_Base::AllowSlateTouch' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Base, bInitializedFromMatchmakingData) == 0x0005E5, "Member 'AOrionPlayerState_Base::bInitializedFromMatchmakingData' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Base, PlayerPosition) == 0x000820, "Member 'AOrionPlayerState_Base::PlayerPosition' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Base, bIsPlayerDisconnected) == 0x000821, "Member 'AOrionPlayerState_Base::bIsPlayerDisconnected' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Base, CurrentBanners) == 0x000828, "Member 'AOrionPlayerState_Base::CurrentBanners' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Base, CurrentBannerAlterations) == 0x000838, "Member 'AOrionPlayerState_Base::CurrentBannerAlterations' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Base, CurrentlyActiveBanner) == 0x000848, "Member 'AOrionPlayerState_Base::CurrentlyActiveBanner' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Base, OldHeroDataSpec) == 0x000868, "Member 'AOrionPlayerState_Base::OldHeroDataSpec' has a wrong offset!");

// Class OrionGame.FTS_AimAtTarget
// 0x0030 (0x0088 - 0x0058)
class UFTS_AimAtTarget final : public UFunctionalTestPhase
{
public:
	EFTestActorKey                                SuggestedTargetKey;                                // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomTargetKey;                                   // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayBeforeNextPhase;                              // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0xC];                                       // 0x007C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void WaitTimerFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FTS_AimAtTarget">();
	}
	static class UFTS_AimAtTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFTS_AimAtTarget>();
	}
};
static_assert(alignof(UFTS_AimAtTarget) == 0x000008, "Wrong alignment on UFTS_AimAtTarget");
static_assert(sizeof(UFTS_AimAtTarget) == 0x000088, "Wrong size on UFTS_AimAtTarget");
static_assert(offsetof(UFTS_AimAtTarget, SuggestedTargetKey) == 0x000058, "Member 'UFTS_AimAtTarget::SuggestedTargetKey' has a wrong offset!");
static_assert(offsetof(UFTS_AimAtTarget, CustomTargetKey) == 0x000060, "Member 'UFTS_AimAtTarget::CustomTargetKey' has a wrong offset!");
static_assert(offsetof(UFTS_AimAtTarget, DelayBeforeNextPhase) == 0x000078, "Member 'UFTS_AimAtTarget::DelayBeforeNextPhase' has a wrong offset!");

// Class OrionGame.GameModeCommon_EmptyServer
// 0x0000 (0x0440 - 0x0440)
class AGameModeCommon_EmptyServer : public AGameModeCommon_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameModeCommon_EmptyServer">();
	}
	static class AGameModeCommon_EmptyServer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameModeCommon_EmptyServer>();
	}
};
static_assert(alignof(AGameModeCommon_EmptyServer) == 0x000008, "Wrong alignment on AGameModeCommon_EmptyServer");
static_assert(sizeof(AGameModeCommon_EmptyServer) == 0x000440, "Wrong size on AGameModeCommon_EmptyServer");

// Class OrionGame.OrionGameMode_EmptyServer
// 0x0000 (0x0440 - 0x0440)
class AOrionGameMode_EmptyServer final : public AGameModeCommon_EmptyServer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameMode_EmptyServer">();
	}
	static class AOrionGameMode_EmptyServer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionGameMode_EmptyServer>();
	}
};
static_assert(alignof(AOrionGameMode_EmptyServer) == 0x000008, "Wrong alignment on AOrionGameMode_EmptyServer");
static_assert(sizeof(AOrionGameMode_EmptyServer) == 0x000440, "Wrong size on AOrionGameMode_EmptyServer");

// Class OrionGame.FTS_EquipItems
// 0x0048 (0x00A0 - 0x0058)
class UFTS_EquipItems final : public UFunctionalTestPhase
{
public:
	EFTestActorKey                                SuggestedTargetKey;                                // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomTargetKey;                                   // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FEquipCardData>                 CardsToEquip;                                      // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         PostExecDelay;                                     // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x1C];                                      // 0x0084(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FTS_EquipItems">();
	}
	static class UFTS_EquipItems* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFTS_EquipItems>();
	}
};
static_assert(alignof(UFTS_EquipItems) == 0x000008, "Wrong alignment on UFTS_EquipItems");
static_assert(sizeof(UFTS_EquipItems) == 0x0000A0, "Wrong size on UFTS_EquipItems");
static_assert(offsetof(UFTS_EquipItems, SuggestedTargetKey) == 0x000058, "Member 'UFTS_EquipItems::SuggestedTargetKey' has a wrong offset!");
static_assert(offsetof(UFTS_EquipItems, CustomTargetKey) == 0x000060, "Member 'UFTS_EquipItems::CustomTargetKey' has a wrong offset!");
static_assert(offsetof(UFTS_EquipItems, CardsToEquip) == 0x000070, "Member 'UFTS_EquipItems::CardsToEquip' has a wrong offset!");
static_assert(offsetof(UFTS_EquipItems, PostExecDelay) == 0x000080, "Member 'UFTS_EquipItems::PostExecDelay' has a wrong offset!");

// Class OrionGame.FTS_ExecCommand
// 0x0020 (0x0078 - 0x0058)
class UFTS_ExecCommand final : public UFunctionalTestPhase
{
public:
	class FString                                 Command;                                           // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostExecDelay;                                     // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0xC];                                       // 0x006C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetStatusToSucceeded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FTS_ExecCommand">();
	}
	static class UFTS_ExecCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFTS_ExecCommand>();
	}
};
static_assert(alignof(UFTS_ExecCommand) == 0x000008, "Wrong alignment on UFTS_ExecCommand");
static_assert(sizeof(UFTS_ExecCommand) == 0x000078, "Wrong size on UFTS_ExecCommand");
static_assert(offsetof(UFTS_ExecCommand, Command) == 0x000058, "Member 'UFTS_ExecCommand::Command' has a wrong offset!");
static_assert(offsetof(UFTS_ExecCommand, PostExecDelay) == 0x000068, "Member 'UFTS_ExecCommand::PostExecDelay' has a wrong offset!");

// Class OrionGame.OrionRejoinCheck
// 0x0020 (0x01D0 - 0x01B0)
class UOrionRejoinCheck final : public URejoinCheck
{
public:
	class UOrionMatchDataLoader*                  MatchDataLoader;                                   // 0x01B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FOrionHeroDataSpec>             HeroDataToLoad;                                    // 0x01B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C8[0x8];                                      // 0x01C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionRejoinCheck">();
	}
	static class UOrionRejoinCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionRejoinCheck>();
	}
};
static_assert(alignof(UOrionRejoinCheck) == 0x000008, "Wrong alignment on UOrionRejoinCheck");
static_assert(sizeof(UOrionRejoinCheck) == 0x0001D0, "Wrong size on UOrionRejoinCheck");
static_assert(offsetof(UOrionRejoinCheck, MatchDataLoader) == 0x0001B0, "Member 'UOrionRejoinCheck::MatchDataLoader' has a wrong offset!");
static_assert(offsetof(UOrionRejoinCheck, HeroDataToLoad) == 0x0001B8, "Member 'UOrionRejoinCheck::HeroDataToLoad' has a wrong offset!");

// Class OrionGame.FTS_LogTestNote
// 0x0018 (0x0070 - 0x0058)
class UFTS_LogTestNote final : public UFunctionalTestPhase
{
public:
	class FString                                 StringToLog;                                       // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              DateCreated;                                       // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FTS_LogTestNote">();
	}
	static class UFTS_LogTestNote* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFTS_LogTestNote>();
	}
};
static_assert(alignof(UFTS_LogTestNote) == 0x000008, "Wrong alignment on UFTS_LogTestNote");
static_assert(sizeof(UFTS_LogTestNote) == 0x000070, "Wrong size on UFTS_LogTestNote");
static_assert(offsetof(UFTS_LogTestNote, StringToLog) == 0x000058, "Member 'UFTS_LogTestNote::StringToLog' has a wrong offset!");
static_assert(offsetof(UFTS_LogTestNote, DateCreated) == 0x000068, "Member 'UFTS_LogTestNote::DateCreated' has a wrong offset!");

// Class OrionGame.FTS_MoveCharacter
// 0x0078 (0x00D0 - 0x0058)
class UFTS_MoveCharacter final : public UFunctionalTestPhase
{
public:
	EFTestActorKey                                SuggestedPawnToMoveKey;                            // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomPawnToMoveKey;                               // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFTestActorKey                                SuggestedTargetKey;                                // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomTargetKey;                                   // 0x0078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CustomTargetLocation;                              // 0x0088(0x000C)(Edit, BlueprintVisible, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTeleportToLocation;                               // 0x0094(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreVerticality;                                // 0x0095(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_96[0x2];                                       // 0x0096(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ArrivalDistance;                                   // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuppressInvalidPawnFailure;                       // 0x009C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x13];                                      // 0x009D(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayBeforeNextPhase;                              // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x1C];                                      // 0x00B4(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void WaitTimerFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FTS_MoveCharacter">();
	}
	static class UFTS_MoveCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFTS_MoveCharacter>();
	}
};
static_assert(alignof(UFTS_MoveCharacter) == 0x000008, "Wrong alignment on UFTS_MoveCharacter");
static_assert(sizeof(UFTS_MoveCharacter) == 0x0000D0, "Wrong size on UFTS_MoveCharacter");
static_assert(offsetof(UFTS_MoveCharacter, SuggestedPawnToMoveKey) == 0x000058, "Member 'UFTS_MoveCharacter::SuggestedPawnToMoveKey' has a wrong offset!");
static_assert(offsetof(UFTS_MoveCharacter, CustomPawnToMoveKey) == 0x000060, "Member 'UFTS_MoveCharacter::CustomPawnToMoveKey' has a wrong offset!");
static_assert(offsetof(UFTS_MoveCharacter, SuggestedTargetKey) == 0x000070, "Member 'UFTS_MoveCharacter::SuggestedTargetKey' has a wrong offset!");
static_assert(offsetof(UFTS_MoveCharacter, CustomTargetKey) == 0x000078, "Member 'UFTS_MoveCharacter::CustomTargetKey' has a wrong offset!");
static_assert(offsetof(UFTS_MoveCharacter, CustomTargetLocation) == 0x000088, "Member 'UFTS_MoveCharacter::CustomTargetLocation' has a wrong offset!");
static_assert(offsetof(UFTS_MoveCharacter, bTeleportToLocation) == 0x000094, "Member 'UFTS_MoveCharacter::bTeleportToLocation' has a wrong offset!");
static_assert(offsetof(UFTS_MoveCharacter, bIgnoreVerticality) == 0x000095, "Member 'UFTS_MoveCharacter::bIgnoreVerticality' has a wrong offset!");
static_assert(offsetof(UFTS_MoveCharacter, ArrivalDistance) == 0x000098, "Member 'UFTS_MoveCharacter::ArrivalDistance' has a wrong offset!");
static_assert(offsetof(UFTS_MoveCharacter, bSuppressInvalidPawnFailure) == 0x00009C, "Member 'UFTS_MoveCharacter::bSuppressInvalidPawnFailure' has a wrong offset!");
static_assert(offsetof(UFTS_MoveCharacter, DelayBeforeNextPhase) == 0x0000B0, "Member 'UFTS_MoveCharacter::DelayBeforeNextPhase' has a wrong offset!");

// Class OrionGame.OrionGameplayItem
// 0x0188 (0x01B0 - 0x0028)
class UOrionGameplayItem : public UObject
{
public:
	TArray<struct FItemAbilityHandle>             ItemAbilityHandles;                                // 0x0028(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	EOrionGameplayItemState                       CurrentItemState;                                  // 0x0038(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionMcpItemDefinition*                SourceItemDefinition;                              // 0x0040(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         UniformPropertyLevelOverride;                      // 0x0048(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         StackCostCount;                                    // 0x004C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x160];                                     // 0x0050(0x0160)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_CurrentItemState();
	void OnRep_ItemAbilityHandles();
	void OnRep_StackCostCount();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameplayItem">();
	}
	static class UOrionGameplayItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionGameplayItem>();
	}
};
static_assert(alignof(UOrionGameplayItem) == 0x000008, "Wrong alignment on UOrionGameplayItem");
static_assert(sizeof(UOrionGameplayItem) == 0x0001B0, "Wrong size on UOrionGameplayItem");
static_assert(offsetof(UOrionGameplayItem, ItemAbilityHandles) == 0x000028, "Member 'UOrionGameplayItem::ItemAbilityHandles' has a wrong offset!");
static_assert(offsetof(UOrionGameplayItem, CurrentItemState) == 0x000038, "Member 'UOrionGameplayItem::CurrentItemState' has a wrong offset!");
static_assert(offsetof(UOrionGameplayItem, SourceItemDefinition) == 0x000040, "Member 'UOrionGameplayItem::SourceItemDefinition' has a wrong offset!");
static_assert(offsetof(UOrionGameplayItem, UniformPropertyLevelOverride) == 0x000048, "Member 'UOrionGameplayItem::UniformPropertyLevelOverride' has a wrong offset!");
static_assert(offsetof(UOrionGameplayItem, StackCostCount) == 0x00004C, "Member 'UOrionGameplayItem::StackCostCount' has a wrong offset!");

// Class OrionGame.FTS_RemoveGameplayEffects
// 0x0040 (0x0098 - 0x0058)
class UFTS_RemoveGameplayEffects final : public UFunctionalTestPhase
{
public:
	EFTestActorKey                                SuggestedTargetKey;                                // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomTargetKey;                                   // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGameplayEffect>>    EffectsToRemove;                                   // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayBeforeNextPhase;                              // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0xC];                                       // 0x008C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void WaitTimerFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FTS_RemoveGameplayEffects">();
	}
	static class UFTS_RemoveGameplayEffects* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFTS_RemoveGameplayEffects>();
	}
};
static_assert(alignof(UFTS_RemoveGameplayEffects) == 0x000008, "Wrong alignment on UFTS_RemoveGameplayEffects");
static_assert(sizeof(UFTS_RemoveGameplayEffects) == 0x000098, "Wrong size on UFTS_RemoveGameplayEffects");
static_assert(offsetof(UFTS_RemoveGameplayEffects, SuggestedTargetKey) == 0x000058, "Member 'UFTS_RemoveGameplayEffects::SuggestedTargetKey' has a wrong offset!");
static_assert(offsetof(UFTS_RemoveGameplayEffects, CustomTargetKey) == 0x000060, "Member 'UFTS_RemoveGameplayEffects::CustomTargetKey' has a wrong offset!");
static_assert(offsetof(UFTS_RemoveGameplayEffects, EffectsToRemove) == 0x000070, "Member 'UFTS_RemoveGameplayEffects::EffectsToRemove' has a wrong offset!");
static_assert(offsetof(UFTS_RemoveGameplayEffects, DelayBeforeNextPhase) == 0x000088, "Member 'UFTS_RemoveGameplayEffects::DelayBeforeNextPhase' has a wrong offset!");

// Class OrionGame.FTS_SetHealth
// 0x0040 (0x0098 - 0x0058)
class UFTS_SetHealth final : public UFunctionalTestPhase
{
public:
	EFTestActorKey                                ExecutingTestActorKey;                             // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCustomKey;                                     // 0x0059(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomKey;                                         // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthScale;                                       // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostExecDelay;                                     // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x20];                                      // 0x0078(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetExecuteStatusSuccess();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FTS_SetHealth">();
	}
	static class UFTS_SetHealth* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFTS_SetHealth>();
	}
};
static_assert(alignof(UFTS_SetHealth) == 0x000008, "Wrong alignment on UFTS_SetHealth");
static_assert(sizeof(UFTS_SetHealth) == 0x000098, "Wrong size on UFTS_SetHealth");
static_assert(offsetof(UFTS_SetHealth, ExecutingTestActorKey) == 0x000058, "Member 'UFTS_SetHealth::ExecutingTestActorKey' has a wrong offset!");
static_assert(offsetof(UFTS_SetHealth, bUseCustomKey) == 0x000059, "Member 'UFTS_SetHealth::bUseCustomKey' has a wrong offset!");
static_assert(offsetof(UFTS_SetHealth, CustomKey) == 0x000060, "Member 'UFTS_SetHealth::CustomKey' has a wrong offset!");
static_assert(offsetof(UFTS_SetHealth, HealthScale) == 0x000070, "Member 'UFTS_SetHealth::HealthScale' has a wrong offset!");
static_assert(offsetof(UFTS_SetHealth, PostExecDelay) == 0x000074, "Member 'UFTS_SetHealth::PostExecDelay' has a wrong offset!");

// Class OrionGame.OrionGameMode_MOBA_Tutorial
// 0x0020 (0x0E10 - 0x0DF0)
class AOrionGameMode_MOBA_Tutorial final : public AOrionGameMode_MOBA
{
public:
	TArray<struct FSpecificHeroInfo>              SpecificHeroes;                                    // 0x0DF0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_E00[0x10];                                     // 0x0E00(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void TutorialPause(class APlayerController* Pauser, bool bPause);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameMode_MOBA_Tutorial">();
	}
	static class AOrionGameMode_MOBA_Tutorial* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionGameMode_MOBA_Tutorial>();
	}
};
static_assert(alignof(AOrionGameMode_MOBA_Tutorial) == 0x000008, "Wrong alignment on AOrionGameMode_MOBA_Tutorial");
static_assert(sizeof(AOrionGameMode_MOBA_Tutorial) == 0x000E10, "Wrong size on AOrionGameMode_MOBA_Tutorial");
static_assert(offsetof(AOrionGameMode_MOBA_Tutorial, SpecificHeroes) == 0x000DF0, "Member 'AOrionGameMode_MOBA_Tutorial::SpecificHeroes' has a wrong offset!");

// Class OrionGame.OrionReplenishCardHand
// 0x0000 (0x0040 - 0x0040)
class UOrionReplenishCardHand final : public UGameplayEffectExecutionCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionReplenishCardHand">();
	}
	static class UOrionReplenishCardHand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionReplenishCardHand>();
	}
};
static_assert(alignof(UOrionReplenishCardHand) == 0x000008, "Wrong alignment on UOrionReplenishCardHand");
static_assert(sizeof(UOrionReplenishCardHand) == 0x000040, "Wrong size on UOrionReplenishCardHand");

// Class OrionGame.FTS_SpawnHero
// 0x0060 (0x00B8 - 0x0058)
class UFTS_SpawnHero final : public UFunctionalTestPhase
{
public:
	bool                                          bIsEnemy;                                          // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionHeroData*                         HeroAsset;                                         // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPauseAI;                                          // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnWithController;                              // 0x0069(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFTestActorKey                                SuggestedActorKey;                                 // 0x006A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6B[0x5];                                       // 0x006B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomKey;                                         // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnDistance;                                     // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostSpawnDelay;                                    // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x30];                                      // 0x0088(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FTS_SpawnHero">();
	}
	static class UFTS_SpawnHero* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFTS_SpawnHero>();
	}
};
static_assert(alignof(UFTS_SpawnHero) == 0x000008, "Wrong alignment on UFTS_SpawnHero");
static_assert(sizeof(UFTS_SpawnHero) == 0x0000B8, "Wrong size on UFTS_SpawnHero");
static_assert(offsetof(UFTS_SpawnHero, bIsEnemy) == 0x000058, "Member 'UFTS_SpawnHero::bIsEnemy' has a wrong offset!");
static_assert(offsetof(UFTS_SpawnHero, HeroAsset) == 0x000060, "Member 'UFTS_SpawnHero::HeroAsset' has a wrong offset!");
static_assert(offsetof(UFTS_SpawnHero, bPauseAI) == 0x000068, "Member 'UFTS_SpawnHero::bPauseAI' has a wrong offset!");
static_assert(offsetof(UFTS_SpawnHero, bSpawnWithController) == 0x000069, "Member 'UFTS_SpawnHero::bSpawnWithController' has a wrong offset!");
static_assert(offsetof(UFTS_SpawnHero, SuggestedActorKey) == 0x00006A, "Member 'UFTS_SpawnHero::SuggestedActorKey' has a wrong offset!");
static_assert(offsetof(UFTS_SpawnHero, CustomKey) == 0x000070, "Member 'UFTS_SpawnHero::CustomKey' has a wrong offset!");
static_assert(offsetof(UFTS_SpawnHero, SpawnDistance) == 0x000080, "Member 'UFTS_SpawnHero::SpawnDistance' has a wrong offset!");
static_assert(offsetof(UFTS_SpawnHero, PostSpawnDelay) == 0x000084, "Member 'UFTS_SpawnHero::PostSpawnDelay' has a wrong offset!");

// Class OrionGame.FTS_SpawnJungle
// 0x0058 (0x00B0 - 0x0058)
class UFTS_SpawnJungle final : public UFunctionalTestPhase
{
public:
	bool                                          bPauseAI;                                          // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETestJungleCreatures                          CreatureToSpawn;                                   // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFTestActorKey                                SuggestedActorKey;                                 // 0x005A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B[0x5];                                       // 0x005B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomKey;                                         // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnDistance;                                     // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostSpawnDelay;                                    // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x38];                                      // 0x0078(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FTS_SpawnJungle">();
	}
	static class UFTS_SpawnJungle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFTS_SpawnJungle>();
	}
};
static_assert(alignof(UFTS_SpawnJungle) == 0x000008, "Wrong alignment on UFTS_SpawnJungle");
static_assert(sizeof(UFTS_SpawnJungle) == 0x0000B0, "Wrong size on UFTS_SpawnJungle");
static_assert(offsetof(UFTS_SpawnJungle, bPauseAI) == 0x000058, "Member 'UFTS_SpawnJungle::bPauseAI' has a wrong offset!");
static_assert(offsetof(UFTS_SpawnJungle, CreatureToSpawn) == 0x000059, "Member 'UFTS_SpawnJungle::CreatureToSpawn' has a wrong offset!");
static_assert(offsetof(UFTS_SpawnJungle, SuggestedActorKey) == 0x00005A, "Member 'UFTS_SpawnJungle::SuggestedActorKey' has a wrong offset!");
static_assert(offsetof(UFTS_SpawnJungle, CustomKey) == 0x000060, "Member 'UFTS_SpawnJungle::CustomKey' has a wrong offset!");
static_assert(offsetof(UFTS_SpawnJungle, SpawnDistance) == 0x000070, "Member 'UFTS_SpawnJungle::SpawnDistance' has a wrong offset!");
static_assert(offsetof(UFTS_SpawnJungle, PostSpawnDelay) == 0x000074, "Member 'UFTS_SpawnJungle::PostSpawnDelay' has a wrong offset!");

// Class OrionGame.OrionGameplayCueNotify_Looping
// 0x0470 (0x0840 - 0x03D0)
class AOrionGameplayCueNotify_Looping : public AOrionGameplayCueNotify_Actor
{
public:
	uint8                                         Pad_3C8[0x8];                                      // 0x03C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayCueParticleInfo               ApplicationParticleEffects;                        // 0x03D0(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayCueNiagaraParticleInfo        ApplicationNiagaraParticleEffects;                 // 0x0410(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayCueAudioInfo                  ApplicationSound;                                  // 0x0450(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueCameraShakeInfo            ApplicationCameraShake;                            // 0x0468(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueCameraLensEffectInfo       ApplicationCameraLensEffect;                       // 0x0490(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueForceFeedbackInfo          ApplicationForceFeedbackEffect;                    // 0x04A8(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueDecalInfo                  ApplicationDecal;                                  // 0x04C0(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class UParticleSystemComponent*>       PS_Application;                                    // 0x04F8(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UNiagaraComponent*>              PSNiagara_Application;                             // 0x0508(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UAudioComponent*                        Audio_Application;                                 // 0x0518(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraShake*                           CameraShake_Application;                           // 0x0520(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AEmitterCameraLensEffectBase*           CameraLensEffect_Application;                      // 0x0528(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParticleInfo               LoopingParticleEffects;                            // 0x0530(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayCueNiagaraParticleInfo        LoopingNiagaraParticleEffects;                     // 0x0570(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayCueAudioInfo_Looping          LoopingSound;                                      // 0x05B0(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueForceFeedbackInfo          LoopingForceFeedbackEffect;                        // 0x05D0(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueCameraLensEffectInfo       LoopingCameraLensEffect;                           // 0x05E8(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   DecalName;                                         // 0x0600(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueTrailInfo                  LoopingTrails;                                     // 0x0608(0x0008)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class AActor*                                 CachedDecalTargetActor;                            // 0x0610(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UParticleSystemComponent*>       PS_Looping;                                        // 0x0618(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UNiagaraComponent*>              PSNiagara_Looping;                                 // 0x0628(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UAudioComponent*                        Audio_Looping;                                     // 0x0638(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AEmitterCameraLensEffectBase*           LoopingCameraLensEffectInstance;                   // 0x0640(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParticleInfo               RecurringParticleEffects;                          // 0x0648(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayCueNiagaraParticleInfo        RecurringNiagaraParticleEffects;                   // 0x0688(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayCueAudioInfo                  RecurringSound;                                    // 0x06C8(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueCameraLensEffectInfo       RecurringCameraLensEffect;                         // 0x06E0(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class UParticleSystemComponent*>       PS_Recurring;                                      // 0x06F8(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UNiagaraComponent*>              PSNiagara_Recurring;                               // 0x0708(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UAudioComponent*                        Audio_Recurring;                                   // 0x0718(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParticleInfo               RemovalParticleEffect;                             // 0x0720(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayCueNiagaraParticleInfo        RemovalNiagaraParticleEffect;                      // 0x0760(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayCueCameraLensEffectInfo       RemovalCameraLensEffect;                           // 0x07A0(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueAudioInfo                  RemovalSound;                                      // 0x07B8(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueCameraShakeInfo            RemovalCameraShake;                                // 0x07D0(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class UParticleSystemComponent*>       PS_Removal;                                        // 0x07F8(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UNiagaraComponent*>              PSNiagara_Removal;                                 // 0x0808(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UAudioComponent*                        Audio_Removal;                                     // 0x0818(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraShake*                           CameraShake_Removal;                               // 0x0820(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTickEnabled;                                      // 0x0828(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_829[0x3];                                      // 0x0829(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TickInterval;                                      // 0x082C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 CachedTarget;                                      // 0x0830(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_838[0x8];                                      // 0x0838(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_OnActive(class AActor* MyTarget, const struct FGameplayCueParameters& Parameters, class UParticleSystemComponent* ApplicationParticleSystem, const TArray<class UParticleSystemComponent*>& AdditionalParticleSystems, class UCameraShake* ApplicationCameraShakeInstance, class UNiagaraComponent* ApplicationNiagaraParticleSystem, const TArray<class UNiagaraComponent*>& AdditionalNiagaraParticleSystems);
	void K2_OnExecute(class AActor* MyTarget, const struct FGameplayCueParameters& Parameters, class UParticleSystemComponent* RecurringParticleSystem, const TArray<class UParticleSystemComponent*>& AdditionalParticleSystems, class UNiagaraComponent* RecurringNiagaraParticleSystem, const TArray<class UNiagaraComponent*>& AdditionalNiagaraParticleSystems);
	void K2_OnRemove(class AActor* MyTarget, const struct FGameplayCueParameters& Parameters, class UParticleSystemComponent* RemovalParticleSystem, const TArray<class UParticleSystemComponent*>& AdditionalParticleSystems, class UNiagaraComponent* RemovalNiagaraParticleSystem, const TArray<class UNiagaraComponent*>& AdditionalNiagaraParticleSystems);
	void K2_WhileActive(class AActor* MyTarget, const struct FGameplayCueParameters& Parameters, class UParticleSystemComponent* LoopingParticleSystem, const TArray<class UParticleSystemComponent*>& AdditionalParticleSystem, class UNiagaraComponent* LoopingNiagaraParticleSystem, const TArray<class UNiagaraComponent*>& AdditionalNiagaraParticleSystems);
	void ReceiveTick(float DeltaSeconds);

	float GetGameplayCueLoopingAnimationDuration() const;
	class UParticleSystemComponent* GetTrailParticleSystem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameplayCueNotify_Looping">();
	}
	static class AOrionGameplayCueNotify_Looping* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionGameplayCueNotify_Looping>();
	}
};
static_assert(alignof(AOrionGameplayCueNotify_Looping) == 0x000010, "Wrong alignment on AOrionGameplayCueNotify_Looping");
static_assert(sizeof(AOrionGameplayCueNotify_Looping) == 0x000840, "Wrong size on AOrionGameplayCueNotify_Looping");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, ApplicationParticleEffects) == 0x0003D0, "Member 'AOrionGameplayCueNotify_Looping::ApplicationParticleEffects' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, ApplicationNiagaraParticleEffects) == 0x000410, "Member 'AOrionGameplayCueNotify_Looping::ApplicationNiagaraParticleEffects' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, ApplicationSound) == 0x000450, "Member 'AOrionGameplayCueNotify_Looping::ApplicationSound' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, ApplicationCameraShake) == 0x000468, "Member 'AOrionGameplayCueNotify_Looping::ApplicationCameraShake' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, ApplicationCameraLensEffect) == 0x000490, "Member 'AOrionGameplayCueNotify_Looping::ApplicationCameraLensEffect' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, ApplicationForceFeedbackEffect) == 0x0004A8, "Member 'AOrionGameplayCueNotify_Looping::ApplicationForceFeedbackEffect' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, ApplicationDecal) == 0x0004C0, "Member 'AOrionGameplayCueNotify_Looping::ApplicationDecal' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, PS_Application) == 0x0004F8, "Member 'AOrionGameplayCueNotify_Looping::PS_Application' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, PSNiagara_Application) == 0x000508, "Member 'AOrionGameplayCueNotify_Looping::PSNiagara_Application' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, Audio_Application) == 0x000518, "Member 'AOrionGameplayCueNotify_Looping::Audio_Application' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, CameraShake_Application) == 0x000520, "Member 'AOrionGameplayCueNotify_Looping::CameraShake_Application' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, CameraLensEffect_Application) == 0x000528, "Member 'AOrionGameplayCueNotify_Looping::CameraLensEffect_Application' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, LoopingParticleEffects) == 0x000530, "Member 'AOrionGameplayCueNotify_Looping::LoopingParticleEffects' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, LoopingNiagaraParticleEffects) == 0x000570, "Member 'AOrionGameplayCueNotify_Looping::LoopingNiagaraParticleEffects' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, LoopingSound) == 0x0005B0, "Member 'AOrionGameplayCueNotify_Looping::LoopingSound' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, LoopingForceFeedbackEffect) == 0x0005D0, "Member 'AOrionGameplayCueNotify_Looping::LoopingForceFeedbackEffect' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, LoopingCameraLensEffect) == 0x0005E8, "Member 'AOrionGameplayCueNotify_Looping::LoopingCameraLensEffect' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, DecalName) == 0x000600, "Member 'AOrionGameplayCueNotify_Looping::DecalName' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, LoopingTrails) == 0x000608, "Member 'AOrionGameplayCueNotify_Looping::LoopingTrails' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, CachedDecalTargetActor) == 0x000610, "Member 'AOrionGameplayCueNotify_Looping::CachedDecalTargetActor' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, PS_Looping) == 0x000618, "Member 'AOrionGameplayCueNotify_Looping::PS_Looping' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, PSNiagara_Looping) == 0x000628, "Member 'AOrionGameplayCueNotify_Looping::PSNiagara_Looping' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, Audio_Looping) == 0x000638, "Member 'AOrionGameplayCueNotify_Looping::Audio_Looping' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, LoopingCameraLensEffectInstance) == 0x000640, "Member 'AOrionGameplayCueNotify_Looping::LoopingCameraLensEffectInstance' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, RecurringParticleEffects) == 0x000648, "Member 'AOrionGameplayCueNotify_Looping::RecurringParticleEffects' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, RecurringNiagaraParticleEffects) == 0x000688, "Member 'AOrionGameplayCueNotify_Looping::RecurringNiagaraParticleEffects' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, RecurringSound) == 0x0006C8, "Member 'AOrionGameplayCueNotify_Looping::RecurringSound' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, RecurringCameraLensEffect) == 0x0006E0, "Member 'AOrionGameplayCueNotify_Looping::RecurringCameraLensEffect' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, PS_Recurring) == 0x0006F8, "Member 'AOrionGameplayCueNotify_Looping::PS_Recurring' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, PSNiagara_Recurring) == 0x000708, "Member 'AOrionGameplayCueNotify_Looping::PSNiagara_Recurring' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, Audio_Recurring) == 0x000718, "Member 'AOrionGameplayCueNotify_Looping::Audio_Recurring' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, RemovalParticleEffect) == 0x000720, "Member 'AOrionGameplayCueNotify_Looping::RemovalParticleEffect' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, RemovalNiagaraParticleEffect) == 0x000760, "Member 'AOrionGameplayCueNotify_Looping::RemovalNiagaraParticleEffect' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, RemovalCameraLensEffect) == 0x0007A0, "Member 'AOrionGameplayCueNotify_Looping::RemovalCameraLensEffect' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, RemovalSound) == 0x0007B8, "Member 'AOrionGameplayCueNotify_Looping::RemovalSound' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, RemovalCameraShake) == 0x0007D0, "Member 'AOrionGameplayCueNotify_Looping::RemovalCameraShake' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, PS_Removal) == 0x0007F8, "Member 'AOrionGameplayCueNotify_Looping::PS_Removal' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, PSNiagara_Removal) == 0x000808, "Member 'AOrionGameplayCueNotify_Looping::PSNiagara_Removal' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, Audio_Removal) == 0x000818, "Member 'AOrionGameplayCueNotify_Looping::Audio_Removal' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, CameraShake_Removal) == 0x000820, "Member 'AOrionGameplayCueNotify_Looping::CameraShake_Removal' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, bTickEnabled) == 0x000828, "Member 'AOrionGameplayCueNotify_Looping::bTickEnabled' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, TickInterval) == 0x00082C, "Member 'AOrionGameplayCueNotify_Looping::TickInterval' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_Looping, CachedTarget) == 0x000830, "Member 'AOrionGameplayCueNotify_Looping::CachedTarget' has a wrong offset!");

// Class OrionGame.FTS_SpawnMinion
// 0x0050 (0x00A8 - 0x0058)
class UFTS_SpawnMinion final : public UFunctionalTestPhase
{
public:
	bool                                          bIsEnemy;                                          // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPauseAI;                                          // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMinionOverride                               MinionOverride;                                    // 0x005A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETestMinions                                  MinionType;                                        // 0x005B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFTestActorKey                                SuggestedActorKey;                                 // 0x005C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomKey;                                         // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnDistance;                                     // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostSpawnDelay;                                    // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x30];                                      // 0x0078(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FTS_SpawnMinion">();
	}
	static class UFTS_SpawnMinion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFTS_SpawnMinion>();
	}
};
static_assert(alignof(UFTS_SpawnMinion) == 0x000008, "Wrong alignment on UFTS_SpawnMinion");
static_assert(sizeof(UFTS_SpawnMinion) == 0x0000A8, "Wrong size on UFTS_SpawnMinion");
static_assert(offsetof(UFTS_SpawnMinion, bIsEnemy) == 0x000058, "Member 'UFTS_SpawnMinion::bIsEnemy' has a wrong offset!");
static_assert(offsetof(UFTS_SpawnMinion, bPauseAI) == 0x000059, "Member 'UFTS_SpawnMinion::bPauseAI' has a wrong offset!");
static_assert(offsetof(UFTS_SpawnMinion, MinionOverride) == 0x00005A, "Member 'UFTS_SpawnMinion::MinionOverride' has a wrong offset!");
static_assert(offsetof(UFTS_SpawnMinion, MinionType) == 0x00005B, "Member 'UFTS_SpawnMinion::MinionType' has a wrong offset!");
static_assert(offsetof(UFTS_SpawnMinion, SuggestedActorKey) == 0x00005C, "Member 'UFTS_SpawnMinion::SuggestedActorKey' has a wrong offset!");
static_assert(offsetof(UFTS_SpawnMinion, CustomKey) == 0x000060, "Member 'UFTS_SpawnMinion::CustomKey' has a wrong offset!");
static_assert(offsetof(UFTS_SpawnMinion, SpawnDistance) == 0x000070, "Member 'UFTS_SpawnMinion::SpawnDistance' has a wrong offset!");
static_assert(offsetof(UFTS_SpawnMinion, PostSpawnDelay) == 0x000074, "Member 'UFTS_SpawnMinion::PostSpawnDelay' has a wrong offset!");

// Class OrionGame.FTS_SpawnPlayer
// 0x0040 (0x0098 - 0x0058)
class UFTS_SpawnPlayer final : public UFunctionalTestPhase
{
public:
	float                                         PostSpawnDelay;                                    // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x3C];                                      // 0x005C(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FTS_SpawnPlayer">();
	}
	static class UFTS_SpawnPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFTS_SpawnPlayer>();
	}
};
static_assert(alignof(UFTS_SpawnPlayer) == 0x000008, "Wrong alignment on UFTS_SpawnPlayer");
static_assert(sizeof(UFTS_SpawnPlayer) == 0x000098, "Wrong size on UFTS_SpawnPlayer");
static_assert(offsetof(UFTS_SpawnPlayer, PostSpawnDelay) == 0x000058, "Member 'UFTS_SpawnPlayer::PostSpawnDelay' has a wrong offset!");

// Class OrionGame.OrionResistanceSum
// 0x0000 (0x0040 - 0x0040)
class UOrionResistanceSum final : public UGameplayModMagnitudeCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionResistanceSum">();
	}
	static class UOrionResistanceSum* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionResistanceSum>();
	}
};
static_assert(alignof(UOrionResistanceSum) == 0x000008, "Wrong alignment on UOrionResistanceSum");
static_assert(sizeof(UOrionResistanceSum) == 0x000040, "Wrong size on UOrionResistanceSum");

// Class OrionGame.FTS_Wait
// 0x0010 (0x0068 - 0x0058)
class UFTS_Wait final : public UFunctionalTestPhase
{
public:
	float                                         Duration;                                          // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0xC];                                       // 0x005C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void WaitTimerFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FTS_Wait">();
	}
	static class UFTS_Wait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFTS_Wait>();
	}
};
static_assert(alignof(UFTS_Wait) == 0x000008, "Wrong alignment on UFTS_Wait");
static_assert(sizeof(UFTS_Wait) == 0x000068, "Wrong size on UFTS_Wait");
static_assert(offsetof(UFTS_Wait, Duration) == 0x000058, "Member 'UFTS_Wait::Duration' has a wrong offset!");

// Class OrionGame.PhaseLoopStart
// 0x0008 (0x0060 - 0x0058)
class UPhaseLoopStart final : public UFunctionalTestPhase
{
public:
	int32                                         LoopCount;                                         // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoopSeconds;                                       // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhaseLoopStart">();
	}
	static class UPhaseLoopStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhaseLoopStart>();
	}
};
static_assert(alignof(UPhaseLoopStart) == 0x000008, "Wrong alignment on UPhaseLoopStart");
static_assert(sizeof(UPhaseLoopStart) == 0x000060, "Wrong size on UPhaseLoopStart");
static_assert(offsetof(UPhaseLoopStart, LoopCount) == 0x000058, "Member 'UPhaseLoopStart::LoopCount' has a wrong offset!");
static_assert(offsetof(UPhaseLoopStart, LoopSeconds) == 0x00005C, "Member 'UPhaseLoopStart::LoopSeconds' has a wrong offset!");

// Class OrionGame.PhaseLoopEnd
// 0x0000 (0x0058 - 0x0058)
class UPhaseLoopEnd final : public UFunctionalTestPhase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhaseLoopEnd">();
	}
	static class UPhaseLoopEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhaseLoopEnd>();
	}
};
static_assert(alignof(UPhaseLoopEnd) == 0x000008, "Wrong alignment on UPhaseLoopEnd");
static_assert(sizeof(UPhaseLoopEnd) == 0x000058, "Wrong size on UPhaseLoopEnd");

// Class OrionGame.OrionRichTextInlineWidget
// 0x0008 (0x0208 - 0x0200)
class UOrionRichTextInlineWidget : public UUserWidget
{
public:
	class UOrionTextBlock*                        Text_DisplayText;                                  // 0x0200(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnApplyMetaData(const class FString& Tag, const class FString& Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionRichTextInlineWidget">();
	}
	static class UOrionRichTextInlineWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionRichTextInlineWidget>();
	}
};
static_assert(alignof(UOrionRichTextInlineWidget) == 0x000008, "Wrong alignment on UOrionRichTextInlineWidget");
static_assert(sizeof(UOrionRichTextInlineWidget) == 0x000208, "Wrong size on UOrionRichTextInlineWidget");
static_assert(offsetof(UOrionRichTextInlineWidget, Text_DisplayText) == 0x000200, "Member 'UOrionRichTextInlineWidget::Text_DisplayText' has a wrong offset!");

// Class OrionGame.OrionGameplayStatsLibrary
// 0x0000 (0x0028 - 0x0028)
class UOrionGameplayStatsLibrary final : public UBlueprintFunctionLibrary
{
public:
	static int32 GetCoreTakedowns(const struct FGameplayStats& GameplayStats, bool bUseTrackedStat);
	static int32 GetHarvesterTakedowns(const struct FGameplayStats& GameplayStats, bool bUseTrackedStat);
	static int32 GetHeroTakedowns(const struct FGameplayStats& GameplayStats, bool bUseTrackedStat);
	static int32 GetInhibitorTakedowns(const struct FGameplayStats& GameplayStats, bool bUseTrackedStat);
	static int32 GetMatchStatValue(const struct FGameplayStats& GameplayStats, const struct FGameplayStatTag& Stat, EOrionStatTrackType TrackType);
	static int32 GetPersistentStatValue(const struct FGameplayStats& GameplayStats, const struct FGameplayStatTag& Stat);
	static int32 GetTotalAssists(const struct FGameplayStats& GameplayStats, bool bUseTrackedStat);
	static int32 GetTotalDeaths(const struct FGameplayStats& GameplayStats, bool bUseTrackedStat);
	static int32 GetTotalKills(const struct FGameplayStats& GameplayStats, bool bUseTrackedStat);
	static int32 GetTowerTakedowns(const struct FGameplayStats& GameplayStats, bool bUseTrackedStat);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameplayStatsLibrary">();
	}
	static class UOrionGameplayStatsLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionGameplayStatsLibrary>();
	}
};
static_assert(alignof(UOrionGameplayStatsLibrary) == 0x000008, "Wrong alignment on UOrionGameplayStatsLibrary");
static_assert(sizeof(UOrionGameplayStatsLibrary) == 0x000028, "Wrong size on UOrionGameplayStatsLibrary");

// Class OrionGame.OrionWardSet
// 0x0008 (0x0038 - 0x0030)
class UOrionWardSet final : public UOrionAttributeSet
{
public:
	float                                         LifeSpan;                                          // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionWardSet">();
	}
	static class UOrionWardSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionWardSet>();
	}
};
static_assert(alignof(UOrionWardSet) == 0x000008, "Wrong alignment on UOrionWardSet");
static_assert(sizeof(UOrionWardSet) == 0x000038, "Wrong size on UOrionWardSet");
static_assert(offsetof(UOrionWardSet, LifeSpan) == 0x000030, "Member 'UOrionWardSet::LifeSpan' has a wrong offset!");

// Class OrionGame.GameSessionCommon
// 0x0200 (0x0530 - 0x0330)
class AGameSessionCommon : public AGameSession
{
public:
	class AOnlineBeaconHost*                      BeaconHostListener;                                // 0x0330(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APartyBeaconHost*                       ReservationBeaconHost;                             // 0x0338(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AQosBeaconHost*                         QosBeaconHost;                                     // 0x0340(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class APartyBeaconHost>           ReservationBeaconHostClass;                        // 0x0348(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AQosBeaconHost>             QosBeaconHostClass;                                // 0x0350(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DefaultMaxTeamSize;                                // 0x0358(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DefaultMaxTeamCount;                               // 0x035C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DefaultMaxPartySize;                               // 0x0360(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_364[0x4];                                      // 0x0364(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BeaconStateInterfaceName;                          // 0x0368(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ServerSecondsToLive;                               // 0x0370(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_374[0x1BC];                                    // 0x0374(0x01BC)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameSessionCommon">();
	}
	static class AGameSessionCommon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameSessionCommon>();
	}
};
static_assert(alignof(AGameSessionCommon) == 0x000008, "Wrong alignment on AGameSessionCommon");
static_assert(sizeof(AGameSessionCommon) == 0x000530, "Wrong size on AGameSessionCommon");
static_assert(offsetof(AGameSessionCommon, BeaconHostListener) == 0x000330, "Member 'AGameSessionCommon::BeaconHostListener' has a wrong offset!");
static_assert(offsetof(AGameSessionCommon, ReservationBeaconHost) == 0x000338, "Member 'AGameSessionCommon::ReservationBeaconHost' has a wrong offset!");
static_assert(offsetof(AGameSessionCommon, QosBeaconHost) == 0x000340, "Member 'AGameSessionCommon::QosBeaconHost' has a wrong offset!");
static_assert(offsetof(AGameSessionCommon, ReservationBeaconHostClass) == 0x000348, "Member 'AGameSessionCommon::ReservationBeaconHostClass' has a wrong offset!");
static_assert(offsetof(AGameSessionCommon, QosBeaconHostClass) == 0x000350, "Member 'AGameSessionCommon::QosBeaconHostClass' has a wrong offset!");
static_assert(offsetof(AGameSessionCommon, DefaultMaxTeamSize) == 0x000358, "Member 'AGameSessionCommon::DefaultMaxTeamSize' has a wrong offset!");
static_assert(offsetof(AGameSessionCommon, DefaultMaxTeamCount) == 0x00035C, "Member 'AGameSessionCommon::DefaultMaxTeamCount' has a wrong offset!");
static_assert(offsetof(AGameSessionCommon, DefaultMaxPartySize) == 0x000360, "Member 'AGameSessionCommon::DefaultMaxPartySize' has a wrong offset!");
static_assert(offsetof(AGameSessionCommon, BeaconStateInterfaceName) == 0x000368, "Member 'AGameSessionCommon::BeaconStateInterfaceName' has a wrong offset!");
static_assert(offsetof(AGameSessionCommon, ServerSecondsToLive) == 0x000370, "Member 'AGameSessionCommon::ServerSecondsToLive' has a wrong offset!");

// Class OrionGame.OrionWidgetData
// 0x0010 (0x0040 - 0x0030)
class UOrionWidgetData final : public UDataAsset
{
public:
	TArray<struct FWidgetDataEntry>               WidgetEntries;                                     // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionWidgetData">();
	}
	static class UOrionWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionWidgetData>();
	}
};
static_assert(alignof(UOrionWidgetData) == 0x000008, "Wrong alignment on UOrionWidgetData");
static_assert(sizeof(UOrionWidgetData) == 0x000040, "Wrong size on UOrionWidgetData");
static_assert(offsetof(UOrionWidgetData, WidgetEntries) == 0x000030, "Member 'UOrionWidgetData::WidgetEntries' has a wrong offset!");

// Class OrionGame.GameUserSettingsCommon
// 0x0028 (0x0130 - 0x0108)
class UGameUserSettingsCommon : public UGameUserSettings
{
public:
	bool                                          bRememberMeCheckbox;                               // 0x0108(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RememberMeToken;                                   // 0x0110(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LastLoginEmail;                                    // 0x0120(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameUserSettingsCommon">();
	}
	static class UGameUserSettingsCommon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameUserSettingsCommon>();
	}
};
static_assert(alignof(UGameUserSettingsCommon) == 0x000008, "Wrong alignment on UGameUserSettingsCommon");
static_assert(sizeof(UGameUserSettingsCommon) == 0x000130, "Wrong size on UGameUserSettingsCommon");
static_assert(offsetof(UGameUserSettingsCommon, bRememberMeCheckbox) == 0x000108, "Member 'UGameUserSettingsCommon::bRememberMeCheckbox' has a wrong offset!");
static_assert(offsetof(UGameUserSettingsCommon, RememberMeToken) == 0x000110, "Member 'UGameUserSettingsCommon::RememberMeToken' has a wrong offset!");
static_assert(offsetof(UGameUserSettingsCommon, LastLoginEmail) == 0x000120, "Member 'UGameUserSettingsCommon::LastLoginEmail' has a wrong offset!");

// Class OrionGame.OrionMockGameItemDefinitionAsset
// 0x0270 (0x02A0 - 0x0030)
class UOrionMockGameItemDefinitionAsset final : public UDataAsset
{
public:
	struct FOrionMockGameItemDefinition           Def;                                               // 0x0030(0x0270)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMockGameItemDefinitionAsset">();
	}
	static class UOrionMockGameItemDefinitionAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMockGameItemDefinitionAsset>();
	}
};
static_assert(alignof(UOrionMockGameItemDefinitionAsset) == 0x000010, "Wrong alignment on UOrionMockGameItemDefinitionAsset");
static_assert(sizeof(UOrionMockGameItemDefinitionAsset) == 0x0002A0, "Wrong size on UOrionMockGameItemDefinitionAsset");
static_assert(offsetof(UOrionMockGameItemDefinitionAsset, Def) == 0x000030, "Member 'UOrionMockGameItemDefinitionAsset::Def' has a wrong offset!");

// Class OrionGame.OrionXPSet
// 0x00D0 (0x0100 - 0x0030)
class UOrionXPSet final : public UOrionAttributeSet
{
public:
	float                                         CurrentLevel;                                      // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLevel;                                          // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         XPToLevel;                                         // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         XPToGain;                                          // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalXP;                                           // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         XPBonusScalar;                                     // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         XPBounty;                                          // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         XPAssistBounty;                                    // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GainXPFromKills;                                   // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccumulatedXP;                                     // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CXPToGain;                                         // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentTotalCardXP;                                // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalCXPNetWorth;                                  // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CXPBonusScalar;                                    // 0x0064(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CXPBounty;                                         // 0x0068(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CXPTeamBounty;                                     // 0x006C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CXPSpawnTime;                                      // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RefineryPayOut;                                    // 0x0074(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccumulatedCardXP;                                 // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccumulatedTeamCardXP;                             // 0x007C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 AccumulatedTeamCardXPEarner;                       // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            AwardXPEffect;                                     // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGameplayEffect>            AwardCardXPEffect;                                 // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A0[0x60];                                      // 0x00A0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_CurrentLevel();
	void OnRep_CurrentTotalCardXP();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionXPSet">();
	}
	static class UOrionXPSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionXPSet>();
	}
};
static_assert(alignof(UOrionXPSet) == 0x000008, "Wrong alignment on UOrionXPSet");
static_assert(sizeof(UOrionXPSet) == 0x000100, "Wrong size on UOrionXPSet");
static_assert(offsetof(UOrionXPSet, CurrentLevel) == 0x000030, "Member 'UOrionXPSet::CurrentLevel' has a wrong offset!");
static_assert(offsetof(UOrionXPSet, MaxLevel) == 0x000034, "Member 'UOrionXPSet::MaxLevel' has a wrong offset!");
static_assert(offsetof(UOrionXPSet, XPToLevel) == 0x000038, "Member 'UOrionXPSet::XPToLevel' has a wrong offset!");
static_assert(offsetof(UOrionXPSet, XPToGain) == 0x00003C, "Member 'UOrionXPSet::XPToGain' has a wrong offset!");
static_assert(offsetof(UOrionXPSet, TotalXP) == 0x000040, "Member 'UOrionXPSet::TotalXP' has a wrong offset!");
static_assert(offsetof(UOrionXPSet, XPBonusScalar) == 0x000044, "Member 'UOrionXPSet::XPBonusScalar' has a wrong offset!");
static_assert(offsetof(UOrionXPSet, XPBounty) == 0x000048, "Member 'UOrionXPSet::XPBounty' has a wrong offset!");
static_assert(offsetof(UOrionXPSet, XPAssistBounty) == 0x00004C, "Member 'UOrionXPSet::XPAssistBounty' has a wrong offset!");
static_assert(offsetof(UOrionXPSet, GainXPFromKills) == 0x000050, "Member 'UOrionXPSet::GainXPFromKills' has a wrong offset!");
static_assert(offsetof(UOrionXPSet, AccumulatedXP) == 0x000054, "Member 'UOrionXPSet::AccumulatedXP' has a wrong offset!");
static_assert(offsetof(UOrionXPSet, CXPToGain) == 0x000058, "Member 'UOrionXPSet::CXPToGain' has a wrong offset!");
static_assert(offsetof(UOrionXPSet, CurrentTotalCardXP) == 0x00005C, "Member 'UOrionXPSet::CurrentTotalCardXP' has a wrong offset!");
static_assert(offsetof(UOrionXPSet, TotalCXPNetWorth) == 0x000060, "Member 'UOrionXPSet::TotalCXPNetWorth' has a wrong offset!");
static_assert(offsetof(UOrionXPSet, CXPBonusScalar) == 0x000064, "Member 'UOrionXPSet::CXPBonusScalar' has a wrong offset!");
static_assert(offsetof(UOrionXPSet, CXPBounty) == 0x000068, "Member 'UOrionXPSet::CXPBounty' has a wrong offset!");
static_assert(offsetof(UOrionXPSet, CXPTeamBounty) == 0x00006C, "Member 'UOrionXPSet::CXPTeamBounty' has a wrong offset!");
static_assert(offsetof(UOrionXPSet, CXPSpawnTime) == 0x000070, "Member 'UOrionXPSet::CXPSpawnTime' has a wrong offset!");
static_assert(offsetof(UOrionXPSet, RefineryPayOut) == 0x000074, "Member 'UOrionXPSet::RefineryPayOut' has a wrong offset!");
static_assert(offsetof(UOrionXPSet, AccumulatedCardXP) == 0x000078, "Member 'UOrionXPSet::AccumulatedCardXP' has a wrong offset!");
static_assert(offsetof(UOrionXPSet, AccumulatedTeamCardXP) == 0x00007C, "Member 'UOrionXPSet::AccumulatedTeamCardXP' has a wrong offset!");
static_assert(offsetof(UOrionXPSet, AccumulatedTeamCardXPEarner) == 0x000080, "Member 'UOrionXPSet::AccumulatedTeamCardXPEarner' has a wrong offset!");
static_assert(offsetof(UOrionXPSet, AwardXPEffect) == 0x000090, "Member 'UOrionXPSet::AwardXPEffect' has a wrong offset!");
static_assert(offsetof(UOrionXPSet, AwardCardXPEffect) == 0x000098, "Member 'UOrionXPSet::AwardCardXPEffect' has a wrong offset!");

// Class OrionGame.GraphicsCardInfoDB
// 0x0070 (0x00A8 - 0x0038)
class UGraphicsCardInfoDB final : public UDeveloperSettings
{
public:
	TArray<struct FGraphicsCardVendorEntry>       Vendors;                                           // 0x0038(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGraphicsCardEntry>             Cards;                                             // 0x0048(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x50];                                      // 0x0058(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GraphicsCardInfoDB">();
	}
	static class UGraphicsCardInfoDB* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGraphicsCardInfoDB>();
	}
};
static_assert(alignof(UGraphicsCardInfoDB) == 0x000008, "Wrong alignment on UGraphicsCardInfoDB");
static_assert(sizeof(UGraphicsCardInfoDB) == 0x0000A8, "Wrong size on UGraphicsCardInfoDB");
static_assert(offsetof(UGraphicsCardInfoDB, Vendors) == 0x000038, "Member 'UGraphicsCardInfoDB::Vendors' has a wrong offset!");
static_assert(offsetof(UGraphicsCardInfoDB, Cards) == 0x000048, "Member 'UGraphicsCardInfoDB::Cards' has a wrong offset!");

// Class OrionGame.HoverDroneMovementComponent
// 0x00C8 (0x0260 - 0x0198)
class UHoverDroneMovementComponent final : public USpectatorPawnMovement
{
public:
	uint8                                         Pad_198[0x48];                                     // 0x0198(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotAcceleration;                                   // 0x01E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RotDeceleration;                                   // 0x01E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxPitchRotSpeed;                                  // 0x01E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxYawRotSpeed;                                    // 0x01EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurboRotAcceleration;                              // 0x01F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurboRotDeceleration;                              // 0x01F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurboMaxPitchRotSpeed;                             // 0x01F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurboMaxYawRotSpeed;                               // 0x01FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              TurboAccelerationRange;                            // 0x0200(0x0008)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              TurboAccelerationAltitudeRange;                    // 0x0208(0x0008)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurboDeceleration;                                 // 0x0210(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurboHoverThrustScale;                             // 0x0214(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FullAirFrictionVelocity;                           // 0x0218(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21C[0x44];                                     // 0x021C(0x0044)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HoverDroneMovementComponent">();
	}
	static class UHoverDroneMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHoverDroneMovementComponent>();
	}
};
static_assert(alignof(UHoverDroneMovementComponent) == 0x000008, "Wrong alignment on UHoverDroneMovementComponent");
static_assert(sizeof(UHoverDroneMovementComponent) == 0x000260, "Wrong size on UHoverDroneMovementComponent");
static_assert(offsetof(UHoverDroneMovementComponent, RotAcceleration) == 0x0001E0, "Member 'UHoverDroneMovementComponent::RotAcceleration' has a wrong offset!");
static_assert(offsetof(UHoverDroneMovementComponent, RotDeceleration) == 0x0001E4, "Member 'UHoverDroneMovementComponent::RotDeceleration' has a wrong offset!");
static_assert(offsetof(UHoverDroneMovementComponent, MaxPitchRotSpeed) == 0x0001E8, "Member 'UHoverDroneMovementComponent::MaxPitchRotSpeed' has a wrong offset!");
static_assert(offsetof(UHoverDroneMovementComponent, MaxYawRotSpeed) == 0x0001EC, "Member 'UHoverDroneMovementComponent::MaxYawRotSpeed' has a wrong offset!");
static_assert(offsetof(UHoverDroneMovementComponent, TurboRotAcceleration) == 0x0001F0, "Member 'UHoverDroneMovementComponent::TurboRotAcceleration' has a wrong offset!");
static_assert(offsetof(UHoverDroneMovementComponent, TurboRotDeceleration) == 0x0001F4, "Member 'UHoverDroneMovementComponent::TurboRotDeceleration' has a wrong offset!");
static_assert(offsetof(UHoverDroneMovementComponent, TurboMaxPitchRotSpeed) == 0x0001F8, "Member 'UHoverDroneMovementComponent::TurboMaxPitchRotSpeed' has a wrong offset!");
static_assert(offsetof(UHoverDroneMovementComponent, TurboMaxYawRotSpeed) == 0x0001FC, "Member 'UHoverDroneMovementComponent::TurboMaxYawRotSpeed' has a wrong offset!");
static_assert(offsetof(UHoverDroneMovementComponent, TurboAccelerationRange) == 0x000200, "Member 'UHoverDroneMovementComponent::TurboAccelerationRange' has a wrong offset!");
static_assert(offsetof(UHoverDroneMovementComponent, TurboAccelerationAltitudeRange) == 0x000208, "Member 'UHoverDroneMovementComponent::TurboAccelerationAltitudeRange' has a wrong offset!");
static_assert(offsetof(UHoverDroneMovementComponent, TurboDeceleration) == 0x000210, "Member 'UHoverDroneMovementComponent::TurboDeceleration' has a wrong offset!");
static_assert(offsetof(UHoverDroneMovementComponent, TurboHoverThrustScale) == 0x000214, "Member 'UHoverDroneMovementComponent::TurboHoverThrustScale' has a wrong offset!");
static_assert(offsetof(UHoverDroneMovementComponent, FullAirFrictionVelocity) == 0x000218, "Member 'UHoverDroneMovementComponent::FullAirFrictionVelocity' has a wrong offset!");

// Class OrionGame.OrionReplaySpectatorPawnBase
// 0x0008 (0x03A8 - 0x03A0)
class AOrionReplaySpectatorPawnBase : public ASpectatorPawn
{
public:
	class UOrionReplaySpectatorCameraComponent*   SpectatorCameraComponent;                          // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionReplaySpectatorPawnBase">();
	}
	static class AOrionReplaySpectatorPawnBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionReplaySpectatorPawnBase>();
	}
};
static_assert(alignof(AOrionReplaySpectatorPawnBase) == 0x000008, "Wrong alignment on AOrionReplaySpectatorPawnBase");
static_assert(sizeof(AOrionReplaySpectatorPawnBase) == 0x0003A8, "Wrong size on AOrionReplaySpectatorPawnBase");
static_assert(offsetof(AOrionReplaySpectatorPawnBase, SpectatorCameraComponent) == 0x0003A0, "Member 'AOrionReplaySpectatorPawnBase::SpectatorCameraComponent' has a wrong offset!");

// Class OrionGame.OrionGameplayVolumeComponent
// 0x02D0 (0x0560 - 0x0290)
class UOrionGameplayVolumeComponent final : public USceneComponent
{
public:
	TWeakObjectPtr<class AOrionDamageableObjective_Base> DefaultSourceActor;                                // 0x0290(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionFilterAndEffectsContainer        FilterAndEffectsContainers;                        // 0x0298(0x0020)(Edit, BlueprintVisible, ExposeOnSpawn, NativeAccessSpecifierPublic)
	struct FOrionFilterAndEffectsContainer        PersistentFilterAndEffectsContainers;              // 0x02B8(0x0020)(Edit, BlueprintVisible, ExposeOnSpawn, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D8[0x10];                                     // 0x02D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionFilterAndEffectsContainer        PeriodicFilterAndEffectsContainers;                // 0x02E8(0x0020)(Edit, BlueprintVisible, ExposeOnSpawn, NativeAccessSpecifierPublic)
	uint8                                         Pad_308[0x10];                                     // 0x0308(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionFilterAndEffectsContainer        PersistentPeriodicFilterAndEffectsContainers;      // 0x0318(0x0020)(Edit, BlueprintVisible, ExposeOnSpawn, NativeAccessSpecifierPublic)
	struct FOrionFilterAndEffectsContainer        ExitFilterAndEffectsContainers;                    // 0x0338(0x0020)(Edit, BlueprintVisible, ExposeOnSpawn, NativeAccessSpecifierPublic)
	TArray<class AVolume*>                        LinkedVolumes;                                     // 0x0358(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, ExposeOnSpawn, NativeAccessSpecifierPublic)
	TArray<struct FLinkedCollisionComp>           LinkedCollisionData;                               // 0x0368(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bEffectRemainsAfterLeavingVolume;                  // 0x0378(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEffectsHandledManually;                           // 0x0379(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReapplyOnRemoval;                                 // 0x037A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnablePrdictiveClientcollision;                   // 0x037B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyEverApplyOnce;                                // 0x037C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVolumeEnabled;                                    // 0x037D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37E[0x2];                                      // 0x037E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumTargetsToApplyEffectsTo;                        // 0x0380(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumGameplayEffectsApplied;                         // 0x0384(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PeriodicEffectApplicationPeriod;                   // 0x0388(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38C[0x4];                                      // 0x038C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            CooldownEffectToApply;                             // 0x0390(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SnapshotSourceForPeriodicEffects;                  // 0x0398(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_399[0x18F];                                    // 0x0399(0x018F)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAbility*                          OwningAbility;                                     // 0x0528(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnGameplayEffectApplyCallback;                     // 0x0530(0x0010)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnAllGameplayEffectsApplied;                       // 0x0540(0x0010)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnGameplayEffectRemovedCallback;                   // 0x0550(0x0010)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void ApplyEffects();
	bool CanStillApplyEffectsToTargets();
	void DisableGameplayVolume(bool ResetInternalState);
	void EnableGameplayVolume();
	void EnableLinkedCollisionViaPrimitive(const TArray<class UPrimitiveComponent*>& LinkedPrimitives, bool bEnablePrimitiveOverlap);
	bool EnableLinkedCollisionViaTags(const struct FGameplayTagContainer& LinkedVolumeTag, bool bEnablePrimitiveOverlap);
	int32 GetNumAppliedEffectsLeftToApply();
	void HandleMatchStarted();
	bool IsValidTarget(class AActor* Actor);
	void OnBeginOverlapCallback(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlapCallback(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnOwnerChangedDimension(class AOrionChar* CharInChangedDimension);
	void OnRep_NumGameplayEffectsApplied();
	void ProcessLinkedBeginOverlapCallback(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void ProcessLinkedEndOverlapCallback(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameplayVolumeComponent">();
	}
	static class UOrionGameplayVolumeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionGameplayVolumeComponent>();
	}
};
static_assert(alignof(UOrionGameplayVolumeComponent) == 0x000008, "Wrong alignment on UOrionGameplayVolumeComponent");
static_assert(sizeof(UOrionGameplayVolumeComponent) == 0x000560, "Wrong size on UOrionGameplayVolumeComponent");
static_assert(offsetof(UOrionGameplayVolumeComponent, DefaultSourceActor) == 0x000290, "Member 'UOrionGameplayVolumeComponent::DefaultSourceActor' has a wrong offset!");
static_assert(offsetof(UOrionGameplayVolumeComponent, FilterAndEffectsContainers) == 0x000298, "Member 'UOrionGameplayVolumeComponent::FilterAndEffectsContainers' has a wrong offset!");
static_assert(offsetof(UOrionGameplayVolumeComponent, PersistentFilterAndEffectsContainers) == 0x0002B8, "Member 'UOrionGameplayVolumeComponent::PersistentFilterAndEffectsContainers' has a wrong offset!");
static_assert(offsetof(UOrionGameplayVolumeComponent, PeriodicFilterAndEffectsContainers) == 0x0002E8, "Member 'UOrionGameplayVolumeComponent::PeriodicFilterAndEffectsContainers' has a wrong offset!");
static_assert(offsetof(UOrionGameplayVolumeComponent, PersistentPeriodicFilterAndEffectsContainers) == 0x000318, "Member 'UOrionGameplayVolumeComponent::PersistentPeriodicFilterAndEffectsContainers' has a wrong offset!");
static_assert(offsetof(UOrionGameplayVolumeComponent, ExitFilterAndEffectsContainers) == 0x000338, "Member 'UOrionGameplayVolumeComponent::ExitFilterAndEffectsContainers' has a wrong offset!");
static_assert(offsetof(UOrionGameplayVolumeComponent, LinkedVolumes) == 0x000358, "Member 'UOrionGameplayVolumeComponent::LinkedVolumes' has a wrong offset!");
static_assert(offsetof(UOrionGameplayVolumeComponent, LinkedCollisionData) == 0x000368, "Member 'UOrionGameplayVolumeComponent::LinkedCollisionData' has a wrong offset!");
static_assert(offsetof(UOrionGameplayVolumeComponent, bEffectRemainsAfterLeavingVolume) == 0x000378, "Member 'UOrionGameplayVolumeComponent::bEffectRemainsAfterLeavingVolume' has a wrong offset!");
static_assert(offsetof(UOrionGameplayVolumeComponent, bEffectsHandledManually) == 0x000379, "Member 'UOrionGameplayVolumeComponent::bEffectsHandledManually' has a wrong offset!");
static_assert(offsetof(UOrionGameplayVolumeComponent, bReapplyOnRemoval) == 0x00037A, "Member 'UOrionGameplayVolumeComponent::bReapplyOnRemoval' has a wrong offset!");
static_assert(offsetof(UOrionGameplayVolumeComponent, bEnablePrdictiveClientcollision) == 0x00037B, "Member 'UOrionGameplayVolumeComponent::bEnablePrdictiveClientcollision' has a wrong offset!");
static_assert(offsetof(UOrionGameplayVolumeComponent, bOnlyEverApplyOnce) == 0x00037C, "Member 'UOrionGameplayVolumeComponent::bOnlyEverApplyOnce' has a wrong offset!");
static_assert(offsetof(UOrionGameplayVolumeComponent, bVolumeEnabled) == 0x00037D, "Member 'UOrionGameplayVolumeComponent::bVolumeEnabled' has a wrong offset!");
static_assert(offsetof(UOrionGameplayVolumeComponent, NumTargetsToApplyEffectsTo) == 0x000380, "Member 'UOrionGameplayVolumeComponent::NumTargetsToApplyEffectsTo' has a wrong offset!");
static_assert(offsetof(UOrionGameplayVolumeComponent, NumGameplayEffectsApplied) == 0x000384, "Member 'UOrionGameplayVolumeComponent::NumGameplayEffectsApplied' has a wrong offset!");
static_assert(offsetof(UOrionGameplayVolumeComponent, PeriodicEffectApplicationPeriod) == 0x000388, "Member 'UOrionGameplayVolumeComponent::PeriodicEffectApplicationPeriod' has a wrong offset!");
static_assert(offsetof(UOrionGameplayVolumeComponent, CooldownEffectToApply) == 0x000390, "Member 'UOrionGameplayVolumeComponent::CooldownEffectToApply' has a wrong offset!");
static_assert(offsetof(UOrionGameplayVolumeComponent, SnapshotSourceForPeriodicEffects) == 0x000398, "Member 'UOrionGameplayVolumeComponent::SnapshotSourceForPeriodicEffects' has a wrong offset!");
static_assert(offsetof(UOrionGameplayVolumeComponent, OwningAbility) == 0x000528, "Member 'UOrionGameplayVolumeComponent::OwningAbility' has a wrong offset!");
static_assert(offsetof(UOrionGameplayVolumeComponent, OnGameplayEffectApplyCallback) == 0x000530, "Member 'UOrionGameplayVolumeComponent::OnGameplayEffectApplyCallback' has a wrong offset!");
static_assert(offsetof(UOrionGameplayVolumeComponent, OnAllGameplayEffectsApplied) == 0x000540, "Member 'UOrionGameplayVolumeComponent::OnAllGameplayEffectsApplied' has a wrong offset!");
static_assert(offsetof(UOrionGameplayVolumeComponent, OnGameplayEffectRemovedCallback) == 0x000550, "Member 'UOrionGameplayVolumeComponent::OnGameplayEffectRemovedCallback' has a wrong offset!");

// Class OrionGame.HoverDronePawn
// 0x0010 (0x03B8 - 0x03A8)
class AHoverDronePawn : public AOrionReplaySpectatorPawnBase
{
public:
	uint8                                         Pad_3A8[0x10];                                     // 0x03A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetAltitude() const;
	bool IsMaintainingConstantAltitude() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HoverDronePawn">();
	}
	static class AHoverDronePawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHoverDronePawn>();
	}
};
static_assert(alignof(AHoverDronePawn) == 0x000008, "Wrong alignment on AHoverDronePawn");
static_assert(sizeof(AHoverDronePawn) == 0x0003B8, "Wrong size on AHoverDronePawn");

// Class OrionGame.HUDAlertAsset
// 0x0018 (0x0048 - 0x0030)
class UHUDAlertAsset final : public UDataAsset
{
public:
	class FText                                   AlertText;                                         // 0x0030(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	class FText GetAlertText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDAlertAsset">();
	}
	static class UHUDAlertAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDAlertAsset>();
	}
};
static_assert(alignof(UHUDAlertAsset) == 0x000008, "Wrong alignment on UHUDAlertAsset");
static_assert(sizeof(UHUDAlertAsset) == 0x000048, "Wrong size on UHUDAlertAsset");
static_assert(offsetof(UHUDAlertAsset, AlertText) == 0x000030, "Member 'UHUDAlertAsset::AlertText' has a wrong offset!");

// Class OrionGame.OrionGameState_Base
// 0x0258 (0x05D0 - 0x0378)
class AOrionGameState_Base : public AGameState
{
public:
	UMulticastDelegateProperty_                   OnGameStateMatchStarted;                           // 0x0378(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class AOrionTeamInfo*>                 Teams;                                             // 0x0388(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPublic)
	float                                         ServerMatchStartTime;                              // 0x0398(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ServerFPS;                                         // 0x039C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionReplicatedCheatFlags             ReplicatedCheatFlags;                              // 0x03A0(0x0003)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A3[0x1];                                      // 0x03A3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SecondsUntilMatchBegins;                           // 0x03A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SecondsUntilPlayerTimeout;                         // 0x03A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlaylistId;                                        // 0x03AC(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSessionRegistrationLocked;                        // 0x03B0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B1[0x7];                                      // 0x03B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UOrionHeroData*>                 AvailableHeroData;                                 // 0x03B8(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bTeamInfoReceived;                                 // 0x03C8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C9[0x7];                                      // 0x03C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GameSessionId;                                     // 0x03D0(0x0010)(Net, ZeroConstructor, RepNotify, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FOrionHeroDialogAudioControl           AnnouncerDialogControl;                            // 0x03E0(0x0080)(Edit, Protected, NativeAccessSpecifierProtected)
	class AExponentialHeightFog*                  GlobalExponentialHeightFog;                        // 0x0460(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEnforceAbilityLevel;                              // 0x0468(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_469[0x157];                                    // 0x0469(0x0157)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableRootMotionSources;                          // 0x05C0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C1[0x7];                                      // 0x05C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionGameplayCueManager*               CachedGameplayCueManager;                          // 0x05C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AnnouncerSay(class AActor* SoundInstigator, const class FString& Ident);
	void ExecuteGameplayCue(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& CueParameters, class AActor* TargetActor);
	void OnRep_CheatFlags();
	void OnRep_EnableRootMotionSources();
	void OnRep_GameSessionID();
	void OnRep_PlaylistId();
	void OnRep_SecondsUntilMatchBegins();
	void OnRep_SecondsUntilPlayerTimeout();
	void OnRep_SessionRegistrationLocked();
	void OnRep_Teams();

	bool AreRootMotionSourcesEnabled() const;
	class AOrionTeamInfo* GetTeamByIndex(EOrionTeam TeamIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameState_Base">();
	}
	static class AOrionGameState_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionGameState_Base>();
	}
};
static_assert(alignof(AOrionGameState_Base) == 0x000010, "Wrong alignment on AOrionGameState_Base");
static_assert(sizeof(AOrionGameState_Base) == 0x0005D0, "Wrong size on AOrionGameState_Base");
static_assert(offsetof(AOrionGameState_Base, OnGameStateMatchStarted) == 0x000378, "Member 'AOrionGameState_Base::OnGameStateMatchStarted' has a wrong offset!");
static_assert(offsetof(AOrionGameState_Base, Teams) == 0x000388, "Member 'AOrionGameState_Base::Teams' has a wrong offset!");
static_assert(offsetof(AOrionGameState_Base, ServerMatchStartTime) == 0x000398, "Member 'AOrionGameState_Base::ServerMatchStartTime' has a wrong offset!");
static_assert(offsetof(AOrionGameState_Base, ServerFPS) == 0x00039C, "Member 'AOrionGameState_Base::ServerFPS' has a wrong offset!");
static_assert(offsetof(AOrionGameState_Base, ReplicatedCheatFlags) == 0x0003A0, "Member 'AOrionGameState_Base::ReplicatedCheatFlags' has a wrong offset!");
static_assert(offsetof(AOrionGameState_Base, SecondsUntilMatchBegins) == 0x0003A4, "Member 'AOrionGameState_Base::SecondsUntilMatchBegins' has a wrong offset!");
static_assert(offsetof(AOrionGameState_Base, SecondsUntilPlayerTimeout) == 0x0003A8, "Member 'AOrionGameState_Base::SecondsUntilPlayerTimeout' has a wrong offset!");
static_assert(offsetof(AOrionGameState_Base, PlaylistId) == 0x0003AC, "Member 'AOrionGameState_Base::PlaylistId' has a wrong offset!");
static_assert(offsetof(AOrionGameState_Base, bSessionRegistrationLocked) == 0x0003B0, "Member 'AOrionGameState_Base::bSessionRegistrationLocked' has a wrong offset!");
static_assert(offsetof(AOrionGameState_Base, AvailableHeroData) == 0x0003B8, "Member 'AOrionGameState_Base::AvailableHeroData' has a wrong offset!");
static_assert(offsetof(AOrionGameState_Base, bTeamInfoReceived) == 0x0003C8, "Member 'AOrionGameState_Base::bTeamInfoReceived' has a wrong offset!");
static_assert(offsetof(AOrionGameState_Base, GameSessionId) == 0x0003D0, "Member 'AOrionGameState_Base::GameSessionId' has a wrong offset!");
static_assert(offsetof(AOrionGameState_Base, AnnouncerDialogControl) == 0x0003E0, "Member 'AOrionGameState_Base::AnnouncerDialogControl' has a wrong offset!");
static_assert(offsetof(AOrionGameState_Base, GlobalExponentialHeightFog) == 0x000460, "Member 'AOrionGameState_Base::GlobalExponentialHeightFog' has a wrong offset!");
static_assert(offsetof(AOrionGameState_Base, bEnforceAbilityLevel) == 0x000468, "Member 'AOrionGameState_Base::bEnforceAbilityLevel' has a wrong offset!");
static_assert(offsetof(AOrionGameState_Base, bEnableRootMotionSources) == 0x0005C0, "Member 'AOrionGameState_Base::bEnableRootMotionSources' has a wrong offset!");
static_assert(offsetof(AOrionGameState_Base, CachedGameplayCueManager) == 0x0005C8, "Member 'AOrionGameState_Base::CachedGameplayCueManager' has a wrong offset!");

// Class OrionGame.OrionGameState_Main
// 0x0000 (0x05D0 - 0x05D0)
class AOrionGameState_Main final : public AOrionGameState_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameState_Main">();
	}
	static class AOrionGameState_Main* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionGameState_Main>();
	}
};
static_assert(alignof(AOrionGameState_Main) == 0x000010, "Wrong alignment on AOrionGameState_Main");
static_assert(sizeof(AOrionGameState_Main) == 0x0005D0, "Wrong size on AOrionGameState_Main");

// Class OrionGame.InfluenceMapRenderingComponent
// 0x0000 (0x0690 - 0x0690)
class UInfluenceMapRenderingComponent final : public UPrimitiveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InfluenceMapRenderingComponent">();
	}
	static class UInfluenceMapRenderingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInfluenceMapRenderingComponent>();
	}
};
static_assert(alignof(UInfluenceMapRenderingComponent) == 0x000010, "Wrong alignment on UInfluenceMapRenderingComponent");
static_assert(sizeof(UInfluenceMapRenderingComponent) == 0x000690, "Wrong size on UInfluenceMapRenderingComponent");

// Class OrionGame.OrionCPPHeroBaseAnimInstance
// 0x0348 (0x0760 - 0x0418)
class UOrionCPPHeroBaseAnimInstance : public UOrionAnimInstance
{
public:
	class AOrionChar*                             HeroChar;                                          // 0x0418(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedAnimStateData                   DefaultIdleCachedState;                            // 0x0420(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedAnimRelevancyData               CachedDirectionChangeDipARelevantAnimData;         // 0x0440(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedAnimRelevancyData               CachedDirectionChangeDipBRelevantAnimData;         // 0x0460(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedAnimRelevancyData               CachedSlopeChangeRelevantAnimData;                 // 0x0480(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedAnimRelevancyData               CachedIdle2JogRelevantAnimData;                    // 0x04A0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedAnimTransitionData              CachedIdle2JogToDefaultTransitionData;             // 0x04C0(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedAnimStateData                   TravelMode_IdleCachedState;                        // 0x04E8(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedAnimRelevancyData               CachedTurnInPlaceRelevantAnimData;                 // 0x0508(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedAnimTransitionData              CachedTurnInPlaceToTravelMode_IdleTransitionData;  // 0x0528(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FFloatRange                            LocomotionAdditiveAlphaRange;                      // 0x0550(0x0010)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AdditiveTransitionScalesWhenAttacking;             // 0x0560(0x0008)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasTravelModeIdle;                                // 0x0568(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_569[0x3];                                      // 0x0569(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSpeed;                                          // 0x056C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitReactIndex;                                     // 0x0570(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsKnockedUp;                                      // 0x0574(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsKnockedBack;                                    // 0x0575(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInTravelMode;                                   // 0x0576(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTravelModeCasting;                              // 0x0577(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTravelModeInReverse;                            // 0x0578(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_579[0x3];                                      // 0x0579(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TravelModeAnimAuthoredSpeed;                       // 0x057C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TravelModePlayRate;                                // 0x0580(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeleeTwist;                                        // 0x0584(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionAdjustedByMeleeTwist;                     // 0x0588(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRecalling;                                      // 0x058C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsStunned;                                        // 0x058D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58E[0x2];                                      // 0x058E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsAbilityTargeting_LMB_BasicPrimary;              // 0x0590(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAbilityTargeting_RMB_Alternate;                 // 0x0591(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAbilityTargeting_Q_Primary;                     // 0x0592(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAbilityTargeting_E_Secondary;                   // 0x0593(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAbilityTargeting_R_Ultimate;                    // 0x0594(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAttacking;                                      // 0x0595(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_596[0x2];                                      // 0x0596(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Speed;                                             // 0x0598(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionTime;                                    // 0x059C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimPitch;                                          // 0x05A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimYaw;                                            // 0x05A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentTickYawDelta;                               // 0x05A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvgYawDelta;                                       // 0x05AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanAngle;                                         // 0x05B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ActorRotationLastTick;                             // 0x05B4(0x000C)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsMoving;                                         // 0x05C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C1[0x3];                                      // 0x05C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Direction;                                         // 0x05C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionLastTick;                                 // 0x05C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionBackPedal;                                // 0x05CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionChangeStrength;                           // 0x05D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionDelta;                                    // 0x05D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsJumping;                                        // 0x05D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOnGround;                                       // 0x05D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLanding;                                        // 0x05DA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5DB[0x1];                                      // 0x05DB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpTime;                                          // 0x05DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpLandPlayRate;                                  // 0x05E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionAdditiveAlpha;                           // 0x05E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveTransitionScale;                           // 0x05E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5EC[0x4];                                      // 0x05EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitReactAlpha;                                     // 0x05F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitReactAlphaClamped;                              // 0x05F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayHitReactA;                                    // 0x05F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayHitReactB;                                    // 0x05F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5FA[0x2];                                      // 0x05FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DirectionKnockbackUp;                              // 0x05FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseKnockBackBackward;                             // 0x0600(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInIdleState;                                    // 0x0601(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_602[0x2];                                      // 0x0602(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActorYawOffset;                                    // 0x0604(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTurning;                                        // 0x0608(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_609[0x3];                                      // 0x0609(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnAnimRotation;                                  // 0x060C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnAnimLength;                                    // 0x0610(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnThreshold;                                     // 0x0614(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmoothedDirection;                                 // 0x0618(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RootYawAdjustment;                                 // 0x061C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustedAimYaw;                                    // 0x0620(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecallingOrStunnedAimPitch;                        // 0x0624(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecallingOrStunnedAimYaw;                          // 0x0628(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMovingOnGroundInTravelMode;                     // 0x062C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62D[0x3];                                      // 0x062D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               SlopeAngle;                                        // 0x0630(0x000C)(Edit, BlueprintVisible, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               SlopeDelta;                                        // 0x063C(0x000C)(Edit, BlueprintVisible, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               SlopeDeltaForAdditive;                             // 0x0648(0x000C)(Edit, BlueprintVisible, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SlopeTiltAlpha;                                    // 0x0654(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LegsSlopeRollWhenMoving;                           // 0x0658(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LegsSlopePitchWhenMoving;                          // 0x065C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_660[0x4];                                      // 0x0660(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RelaxedIdleTimer;                                  // 0x0664(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldTransitionToIdle;                           // 0x0668(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldTransitionToJog;                            // 0x0669(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMeleeCharacter;                                 // 0x066A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMeleeFullBody;                                  // 0x066B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayMontageFullBody;                              // 0x066C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseLeftTurnAnim;                                  // 0x066D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_66E[0x2];                                      // 0x066E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnAnimPlayRate;                                  // 0x0670(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseLeftTurnInPlaceAnim;                           // 0x0674(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_675[0x3];                                      // 0x0675(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocomotionNoiseBlendAlpha;                         // 0x0678(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionChangeAdditiveDeltaStrength;              // 0x067C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionChangePlayRate;                           // 0x0680(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Idle2JogTravelModePlayRate;                        // 0x0684(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Idle2JogDirectionChangeAdditiveDeltaStrength;      // 0x0688(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Idle2JogDirectionChangeMappingFrom;                // 0x068C(0x0008)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Idle2JogDirectionChangeMappingTo;                  // 0x0694(0x0008)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Idle2JogBlendOutAlpha;                             // 0x069C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSlopeChangeDropDown;                            // 0x06A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A1[0x3];                                      // 0x06A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlopeChangeAdditiveAlpha;                          // 0x06A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A8[0x1];                                      // 0x06A8(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bTransition_Locomotion_IdlesAndTurns_To_Jump;      // 0x06A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_Locomotion_Jump_To_IdlesAndTurns;      // 0x06AA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_Locomotion_IdlesAndTurns_To_Fall_JumpApex; // 0x06AB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_Locomotion_Jump_To_Fall_JumpApex;      // 0x06AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_Locomotion_Fall_JumpApex_To_FallLoop;  // 0x06AD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_Locomotion_FallLoop_To_IdlesAndTurns;  // 0x06AE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_Locomotion_IdlesAndTurns_To_Jog_Run;   // 0x06AF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_Locomotion_Jog_Run_To_IdlesAndTurns;   // 0x06B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_Locomotion_IdlesAndTurns_To_KnockedBack; // 0x06B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_Locomotion_KnockedBack_To_IdlesAndTurns; // 0x06B2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_Locomotion_IdlesAndTurns_To_StunStart; // 0x06B3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_Locomotion_StunStart_To_StunLoop;      // 0x06B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_Locomotion_StunLoop_To_IdlesAndTurns;  // 0x06B5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_Locomotion_IdlesAndTurns_To_RecallStart; // 0x06B6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_Locomotion_RecallStart_To_RecallLoop;  // 0x06B7(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_Locomotion_RecallLoop_To_Recall_End;   // 0x06B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_Locomotion_Recall_End_To_IdlesAndTurns; // 0x06B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_Base_Idle_DefaultIdle_To_Turning_LowerBody; // 0x06BA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_Base_Idle_Turning_LowerBody_To_DefaultIdle; // 0x06BB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_Base_Idle_DefaultIdle_To_TurnInPlace;  // 0x06BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_Base_Idle_TurnInPlace_To_DefaultIdle;  // 0x06BD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_Base_Idle_DefaultIdle_To_RelaxedIdle;  // 0x06BE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_Base_Idle_RelaxedIdle_To_DefaultIdle;  // 0x06BF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_Base_Idle_DefaultIdle_To_TravelMode_Idle; // 0x06C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_Base_Idle_TravelMode_Idle_To_DefaultIdle; // 0x06C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_Base_Idle_TravelMode_Idle_To_TurnInPlace; // 0x06C2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_Base_Idle_TurnInPlace_To_TravelMode_Idle; // 0x06C3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_LocomotionTransitions_Default_To_JumpLand; // 0x06C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_LocomotionTransitions_JumpLand_To_Default; // 0x06C5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_LocomotionTransitions_Default_To_JumpFall; // 0x06C6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_LocomotionTransitions_JumpFall_To_Default; // 0x06C7(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_LocomotionTransitions_Default_To_DirectionChangeDipA; // 0x06C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_LocomotionTransitions_DirectionChangeDipA_To_Default; // 0x06C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_LocomotionTransitions_DirectionChangeDipA_To_DirectionChangeDipB; // 0x06CA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_LocomotionTransitions_DirectionChangeDipB_To_DirectionChangeDipA; // 0x06CB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_LocomotionTransitions_Default_To_SlopeChange; // 0x06CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_LocomotionTransitions_SlopeChange_To_Default; // 0x06CD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_LocomotionTransitions_Default_To_Idle2Jog; // 0x06CE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_LocomotionTransitions_Idle2Jog_To_Default; // 0x06CF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_LocomotionTransitions_Default_To_Jog2Idle; // 0x06D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_LocomotionTransitions_Jog2Idle_To_Default; // 0x06D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D2[0x6];                                      // 0x06D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionDirectionalAnimRef               HitReactAnims;                                     // 0x06D8(0x0020)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      HitReactAnim;                                      // 0x06F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayingHitReact;                                  // 0x0700(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_701[0x3];                                      // 0x0701(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitReactAnimPosition;                              // 0x0704(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitReactBlendAlpha;                                // 0x0708(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70C[0x4];                                      // 0x070C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AbilityInMotionSlotName;                           // 0x0710(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UpperBodySlotName;                                 // 0x0718(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpperBodySlotMaskWeight;                           // 0x0720(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionHeroSpeedWarpingSettings         LocomotionSpeedWarpingSettings;                    // 0x0724(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FOrionHeroSpeedWarpingSettings         TravelModeSpeedWarpingSettings;                    // 0x0734(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LocalSpaceVelocityDirPreTurn;                      // 0x0744(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimDynamicsForceScaling;                          // 0x0750(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AnimDynamicsForce;                                 // 0x0754(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AnimNotify_EnteredDefaultIdle(const class UAnimNotify* Notify);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCPPHeroBaseAnimInstance">();
	}
	static class UOrionCPPHeroBaseAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionCPPHeroBaseAnimInstance>();
	}
};
static_assert(alignof(UOrionCPPHeroBaseAnimInstance) == 0x000008, "Wrong alignment on UOrionCPPHeroBaseAnimInstance");
static_assert(sizeof(UOrionCPPHeroBaseAnimInstance) == 0x000760, "Wrong size on UOrionCPPHeroBaseAnimInstance");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, HeroChar) == 0x000418, "Member 'UOrionCPPHeroBaseAnimInstance::HeroChar' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, DefaultIdleCachedState) == 0x000420, "Member 'UOrionCPPHeroBaseAnimInstance::DefaultIdleCachedState' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, CachedDirectionChangeDipARelevantAnimData) == 0x000440, "Member 'UOrionCPPHeroBaseAnimInstance::CachedDirectionChangeDipARelevantAnimData' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, CachedDirectionChangeDipBRelevantAnimData) == 0x000460, "Member 'UOrionCPPHeroBaseAnimInstance::CachedDirectionChangeDipBRelevantAnimData' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, CachedSlopeChangeRelevantAnimData) == 0x000480, "Member 'UOrionCPPHeroBaseAnimInstance::CachedSlopeChangeRelevantAnimData' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, CachedIdle2JogRelevantAnimData) == 0x0004A0, "Member 'UOrionCPPHeroBaseAnimInstance::CachedIdle2JogRelevantAnimData' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, CachedIdle2JogToDefaultTransitionData) == 0x0004C0, "Member 'UOrionCPPHeroBaseAnimInstance::CachedIdle2JogToDefaultTransitionData' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, TravelMode_IdleCachedState) == 0x0004E8, "Member 'UOrionCPPHeroBaseAnimInstance::TravelMode_IdleCachedState' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, CachedTurnInPlaceRelevantAnimData) == 0x000508, "Member 'UOrionCPPHeroBaseAnimInstance::CachedTurnInPlaceRelevantAnimData' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, CachedTurnInPlaceToTravelMode_IdleTransitionData) == 0x000528, "Member 'UOrionCPPHeroBaseAnimInstance::CachedTurnInPlaceToTravelMode_IdleTransitionData' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, LocomotionAdditiveAlphaRange) == 0x000550, "Member 'UOrionCPPHeroBaseAnimInstance::LocomotionAdditiveAlphaRange' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, AdditiveTransitionScalesWhenAttacking) == 0x000560, "Member 'UOrionCPPHeroBaseAnimInstance::AdditiveTransitionScalesWhenAttacking' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bHasTravelModeIdle) == 0x000568, "Member 'UOrionCPPHeroBaseAnimInstance::bHasTravelModeIdle' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, MaxSpeed) == 0x00056C, "Member 'UOrionCPPHeroBaseAnimInstance::MaxSpeed' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, HitReactIndex) == 0x000570, "Member 'UOrionCPPHeroBaseAnimInstance::HitReactIndex' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bIsKnockedUp) == 0x000574, "Member 'UOrionCPPHeroBaseAnimInstance::bIsKnockedUp' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bIsKnockedBack) == 0x000575, "Member 'UOrionCPPHeroBaseAnimInstance::bIsKnockedBack' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bIsInTravelMode) == 0x000576, "Member 'UOrionCPPHeroBaseAnimInstance::bIsInTravelMode' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bIsTravelModeCasting) == 0x000577, "Member 'UOrionCPPHeroBaseAnimInstance::bIsTravelModeCasting' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bIsTravelModeInReverse) == 0x000578, "Member 'UOrionCPPHeroBaseAnimInstance::bIsTravelModeInReverse' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, TravelModeAnimAuthoredSpeed) == 0x00057C, "Member 'UOrionCPPHeroBaseAnimInstance::TravelModeAnimAuthoredSpeed' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, TravelModePlayRate) == 0x000580, "Member 'UOrionCPPHeroBaseAnimInstance::TravelModePlayRate' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, MeleeTwist) == 0x000584, "Member 'UOrionCPPHeroBaseAnimInstance::MeleeTwist' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, DirectionAdjustedByMeleeTwist) == 0x000588, "Member 'UOrionCPPHeroBaseAnimInstance::DirectionAdjustedByMeleeTwist' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bIsRecalling) == 0x00058C, "Member 'UOrionCPPHeroBaseAnimInstance::bIsRecalling' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bIsStunned) == 0x00058D, "Member 'UOrionCPPHeroBaseAnimInstance::bIsStunned' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bIsAbilityTargeting_LMB_BasicPrimary) == 0x000590, "Member 'UOrionCPPHeroBaseAnimInstance::bIsAbilityTargeting_LMB_BasicPrimary' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bIsAbilityTargeting_RMB_Alternate) == 0x000591, "Member 'UOrionCPPHeroBaseAnimInstance::bIsAbilityTargeting_RMB_Alternate' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bIsAbilityTargeting_Q_Primary) == 0x000592, "Member 'UOrionCPPHeroBaseAnimInstance::bIsAbilityTargeting_Q_Primary' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bIsAbilityTargeting_E_Secondary) == 0x000593, "Member 'UOrionCPPHeroBaseAnimInstance::bIsAbilityTargeting_E_Secondary' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bIsAbilityTargeting_R_Ultimate) == 0x000594, "Member 'UOrionCPPHeroBaseAnimInstance::bIsAbilityTargeting_R_Ultimate' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bIsAttacking) == 0x000595, "Member 'UOrionCPPHeroBaseAnimInstance::bIsAttacking' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, Speed) == 0x000598, "Member 'UOrionCPPHeroBaseAnimInstance::Speed' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, LocomotionTime) == 0x00059C, "Member 'UOrionCPPHeroBaseAnimInstance::LocomotionTime' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, AimPitch) == 0x0005A0, "Member 'UOrionCPPHeroBaseAnimInstance::AimPitch' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, AimYaw) == 0x0005A4, "Member 'UOrionCPPHeroBaseAnimInstance::AimYaw' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, CurrentTickYawDelta) == 0x0005A8, "Member 'UOrionCPPHeroBaseAnimInstance::CurrentTickYawDelta' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, AvgYawDelta) == 0x0005AC, "Member 'UOrionCPPHeroBaseAnimInstance::AvgYawDelta' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, LeanAngle) == 0x0005B0, "Member 'UOrionCPPHeroBaseAnimInstance::LeanAngle' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, ActorRotationLastTick) == 0x0005B4, "Member 'UOrionCPPHeroBaseAnimInstance::ActorRotationLastTick' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bIsMoving) == 0x0005C0, "Member 'UOrionCPPHeroBaseAnimInstance::bIsMoving' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, Direction) == 0x0005C4, "Member 'UOrionCPPHeroBaseAnimInstance::Direction' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, DirectionLastTick) == 0x0005C8, "Member 'UOrionCPPHeroBaseAnimInstance::DirectionLastTick' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, DirectionBackPedal) == 0x0005CC, "Member 'UOrionCPPHeroBaseAnimInstance::DirectionBackPedal' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, DirectionChangeStrength) == 0x0005D0, "Member 'UOrionCPPHeroBaseAnimInstance::DirectionChangeStrength' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, DirectionDelta) == 0x0005D4, "Member 'UOrionCPPHeroBaseAnimInstance::DirectionDelta' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bIsJumping) == 0x0005D8, "Member 'UOrionCPPHeroBaseAnimInstance::bIsJumping' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bIsOnGround) == 0x0005D9, "Member 'UOrionCPPHeroBaseAnimInstance::bIsOnGround' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bIsLanding) == 0x0005DA, "Member 'UOrionCPPHeroBaseAnimInstance::bIsLanding' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, JumpTime) == 0x0005DC, "Member 'UOrionCPPHeroBaseAnimInstance::JumpTime' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, JumpLandPlayRate) == 0x0005E0, "Member 'UOrionCPPHeroBaseAnimInstance::JumpLandPlayRate' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, LocomotionAdditiveAlpha) == 0x0005E4, "Member 'UOrionCPPHeroBaseAnimInstance::LocomotionAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, AdditiveTransitionScale) == 0x0005E8, "Member 'UOrionCPPHeroBaseAnimInstance::AdditiveTransitionScale' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, HitReactAlpha) == 0x0005F0, "Member 'UOrionCPPHeroBaseAnimInstance::HitReactAlpha' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, HitReactAlphaClamped) == 0x0005F4, "Member 'UOrionCPPHeroBaseAnimInstance::HitReactAlphaClamped' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bPlayHitReactA) == 0x0005F8, "Member 'UOrionCPPHeroBaseAnimInstance::bPlayHitReactA' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bPlayHitReactB) == 0x0005F9, "Member 'UOrionCPPHeroBaseAnimInstance::bPlayHitReactB' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, DirectionKnockbackUp) == 0x0005FC, "Member 'UOrionCPPHeroBaseAnimInstance::DirectionKnockbackUp' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bUseKnockBackBackward) == 0x000600, "Member 'UOrionCPPHeroBaseAnimInstance::bUseKnockBackBackward' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bIsInIdleState) == 0x000601, "Member 'UOrionCPPHeroBaseAnimInstance::bIsInIdleState' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, ActorYawOffset) == 0x000604, "Member 'UOrionCPPHeroBaseAnimInstance::ActorYawOffset' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bIsTurning) == 0x000608, "Member 'UOrionCPPHeroBaseAnimInstance::bIsTurning' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, TurnAnimRotation) == 0x00060C, "Member 'UOrionCPPHeroBaseAnimInstance::TurnAnimRotation' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, TurnAnimLength) == 0x000610, "Member 'UOrionCPPHeroBaseAnimInstance::TurnAnimLength' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, TurnThreshold) == 0x000614, "Member 'UOrionCPPHeroBaseAnimInstance::TurnThreshold' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, SmoothedDirection) == 0x000618, "Member 'UOrionCPPHeroBaseAnimInstance::SmoothedDirection' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, RootYawAdjustment) == 0x00061C, "Member 'UOrionCPPHeroBaseAnimInstance::RootYawAdjustment' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, AdjustedAimYaw) == 0x000620, "Member 'UOrionCPPHeroBaseAnimInstance::AdjustedAimYaw' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, RecallingOrStunnedAimPitch) == 0x000624, "Member 'UOrionCPPHeroBaseAnimInstance::RecallingOrStunnedAimPitch' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, RecallingOrStunnedAimYaw) == 0x000628, "Member 'UOrionCPPHeroBaseAnimInstance::RecallingOrStunnedAimYaw' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bIsMovingOnGroundInTravelMode) == 0x00062C, "Member 'UOrionCPPHeroBaseAnimInstance::bIsMovingOnGroundInTravelMode' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, SlopeAngle) == 0x000630, "Member 'UOrionCPPHeroBaseAnimInstance::SlopeAngle' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, SlopeDelta) == 0x00063C, "Member 'UOrionCPPHeroBaseAnimInstance::SlopeDelta' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, SlopeDeltaForAdditive) == 0x000648, "Member 'UOrionCPPHeroBaseAnimInstance::SlopeDeltaForAdditive' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, SlopeTiltAlpha) == 0x000654, "Member 'UOrionCPPHeroBaseAnimInstance::SlopeTiltAlpha' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, LegsSlopeRollWhenMoving) == 0x000658, "Member 'UOrionCPPHeroBaseAnimInstance::LegsSlopeRollWhenMoving' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, LegsSlopePitchWhenMoving) == 0x00065C, "Member 'UOrionCPPHeroBaseAnimInstance::LegsSlopePitchWhenMoving' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, RelaxedIdleTimer) == 0x000664, "Member 'UOrionCPPHeroBaseAnimInstance::RelaxedIdleTimer' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bShouldTransitionToIdle) == 0x000668, "Member 'UOrionCPPHeroBaseAnimInstance::bShouldTransitionToIdle' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bShouldTransitionToJog) == 0x000669, "Member 'UOrionCPPHeroBaseAnimInstance::bShouldTransitionToJog' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bIsMeleeCharacter) == 0x00066A, "Member 'UOrionCPPHeroBaseAnimInstance::bIsMeleeCharacter' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bIsMeleeFullBody) == 0x00066B, "Member 'UOrionCPPHeroBaseAnimInstance::bIsMeleeFullBody' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bPlayMontageFullBody) == 0x00066C, "Member 'UOrionCPPHeroBaseAnimInstance::bPlayMontageFullBody' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bUseLeftTurnAnim) == 0x00066D, "Member 'UOrionCPPHeroBaseAnimInstance::bUseLeftTurnAnim' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, TurnAnimPlayRate) == 0x000670, "Member 'UOrionCPPHeroBaseAnimInstance::TurnAnimPlayRate' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bUseLeftTurnInPlaceAnim) == 0x000674, "Member 'UOrionCPPHeroBaseAnimInstance::bUseLeftTurnInPlaceAnim' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, LocomotionNoiseBlendAlpha) == 0x000678, "Member 'UOrionCPPHeroBaseAnimInstance::LocomotionNoiseBlendAlpha' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, DirectionChangeAdditiveDeltaStrength) == 0x00067C, "Member 'UOrionCPPHeroBaseAnimInstance::DirectionChangeAdditiveDeltaStrength' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, DirectionChangePlayRate) == 0x000680, "Member 'UOrionCPPHeroBaseAnimInstance::DirectionChangePlayRate' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, Idle2JogTravelModePlayRate) == 0x000684, "Member 'UOrionCPPHeroBaseAnimInstance::Idle2JogTravelModePlayRate' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, Idle2JogDirectionChangeAdditiveDeltaStrength) == 0x000688, "Member 'UOrionCPPHeroBaseAnimInstance::Idle2JogDirectionChangeAdditiveDeltaStrength' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, Idle2JogDirectionChangeMappingFrom) == 0x00068C, "Member 'UOrionCPPHeroBaseAnimInstance::Idle2JogDirectionChangeMappingFrom' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, Idle2JogDirectionChangeMappingTo) == 0x000694, "Member 'UOrionCPPHeroBaseAnimInstance::Idle2JogDirectionChangeMappingTo' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, Idle2JogBlendOutAlpha) == 0x00069C, "Member 'UOrionCPPHeroBaseAnimInstance::Idle2JogBlendOutAlpha' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bIsSlopeChangeDropDown) == 0x0006A0, "Member 'UOrionCPPHeroBaseAnimInstance::bIsSlopeChangeDropDown' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, SlopeChangeAdditiveAlpha) == 0x0006A4, "Member 'UOrionCPPHeroBaseAnimInstance::SlopeChangeAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_Locomotion_IdlesAndTurns_To_Jump) == 0x0006A9, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_Locomotion_IdlesAndTurns_To_Jump' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_Locomotion_Jump_To_IdlesAndTurns) == 0x0006AA, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_Locomotion_Jump_To_IdlesAndTurns' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_Locomotion_IdlesAndTurns_To_Fall_JumpApex) == 0x0006AB, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_Locomotion_IdlesAndTurns_To_Fall_JumpApex' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_Locomotion_Jump_To_Fall_JumpApex) == 0x0006AC, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_Locomotion_Jump_To_Fall_JumpApex' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_Locomotion_Fall_JumpApex_To_FallLoop) == 0x0006AD, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_Locomotion_Fall_JumpApex_To_FallLoop' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_Locomotion_FallLoop_To_IdlesAndTurns) == 0x0006AE, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_Locomotion_FallLoop_To_IdlesAndTurns' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_Locomotion_IdlesAndTurns_To_Jog_Run) == 0x0006AF, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_Locomotion_IdlesAndTurns_To_Jog_Run' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_Locomotion_Jog_Run_To_IdlesAndTurns) == 0x0006B0, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_Locomotion_Jog_Run_To_IdlesAndTurns' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_Locomotion_IdlesAndTurns_To_KnockedBack) == 0x0006B1, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_Locomotion_IdlesAndTurns_To_KnockedBack' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_Locomotion_KnockedBack_To_IdlesAndTurns) == 0x0006B2, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_Locomotion_KnockedBack_To_IdlesAndTurns' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_Locomotion_IdlesAndTurns_To_StunStart) == 0x0006B3, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_Locomotion_IdlesAndTurns_To_StunStart' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_Locomotion_StunStart_To_StunLoop) == 0x0006B4, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_Locomotion_StunStart_To_StunLoop' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_Locomotion_StunLoop_To_IdlesAndTurns) == 0x0006B5, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_Locomotion_StunLoop_To_IdlesAndTurns' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_Locomotion_IdlesAndTurns_To_RecallStart) == 0x0006B6, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_Locomotion_IdlesAndTurns_To_RecallStart' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_Locomotion_RecallStart_To_RecallLoop) == 0x0006B7, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_Locomotion_RecallStart_To_RecallLoop' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_Locomotion_RecallLoop_To_Recall_End) == 0x0006B8, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_Locomotion_RecallLoop_To_Recall_End' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_Locomotion_Recall_End_To_IdlesAndTurns) == 0x0006B9, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_Locomotion_Recall_End_To_IdlesAndTurns' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_Base_Idle_DefaultIdle_To_Turning_LowerBody) == 0x0006BA, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_Base_Idle_DefaultIdle_To_Turning_LowerBody' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_Base_Idle_Turning_LowerBody_To_DefaultIdle) == 0x0006BB, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_Base_Idle_Turning_LowerBody_To_DefaultIdle' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_Base_Idle_DefaultIdle_To_TurnInPlace) == 0x0006BC, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_Base_Idle_DefaultIdle_To_TurnInPlace' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_Base_Idle_TurnInPlace_To_DefaultIdle) == 0x0006BD, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_Base_Idle_TurnInPlace_To_DefaultIdle' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_Base_Idle_DefaultIdle_To_RelaxedIdle) == 0x0006BE, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_Base_Idle_DefaultIdle_To_RelaxedIdle' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_Base_Idle_RelaxedIdle_To_DefaultIdle) == 0x0006BF, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_Base_Idle_RelaxedIdle_To_DefaultIdle' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_Base_Idle_DefaultIdle_To_TravelMode_Idle) == 0x0006C0, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_Base_Idle_DefaultIdle_To_TravelMode_Idle' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_Base_Idle_TravelMode_Idle_To_DefaultIdle) == 0x0006C1, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_Base_Idle_TravelMode_Idle_To_DefaultIdle' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_Base_Idle_TravelMode_Idle_To_TurnInPlace) == 0x0006C2, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_Base_Idle_TravelMode_Idle_To_TurnInPlace' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_Base_Idle_TurnInPlace_To_TravelMode_Idle) == 0x0006C3, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_Base_Idle_TurnInPlace_To_TravelMode_Idle' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_LocomotionTransitions_Default_To_JumpLand) == 0x0006C4, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_LocomotionTransitions_Default_To_JumpLand' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_LocomotionTransitions_JumpLand_To_Default) == 0x0006C5, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_LocomotionTransitions_JumpLand_To_Default' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_LocomotionTransitions_Default_To_JumpFall) == 0x0006C6, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_LocomotionTransitions_Default_To_JumpFall' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_LocomotionTransitions_JumpFall_To_Default) == 0x0006C7, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_LocomotionTransitions_JumpFall_To_Default' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_LocomotionTransitions_Default_To_DirectionChangeDipA) == 0x0006C8, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_LocomotionTransitions_Default_To_DirectionChangeDipA' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_LocomotionTransitions_DirectionChangeDipA_To_Default) == 0x0006C9, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_LocomotionTransitions_DirectionChangeDipA_To_Default' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_LocomotionTransitions_DirectionChangeDipA_To_DirectionChangeDipB) == 0x0006CA, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_LocomotionTransitions_DirectionChangeDipA_To_DirectionChangeDipB' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_LocomotionTransitions_DirectionChangeDipB_To_DirectionChangeDipA) == 0x0006CB, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_LocomotionTransitions_DirectionChangeDipB_To_DirectionChangeDipA' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_LocomotionTransitions_Default_To_SlopeChange) == 0x0006CC, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_LocomotionTransitions_Default_To_SlopeChange' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_LocomotionTransitions_SlopeChange_To_Default) == 0x0006CD, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_LocomotionTransitions_SlopeChange_To_Default' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_LocomotionTransitions_Default_To_Idle2Jog) == 0x0006CE, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_LocomotionTransitions_Default_To_Idle2Jog' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_LocomotionTransitions_Idle2Jog_To_Default) == 0x0006CF, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_LocomotionTransitions_Idle2Jog_To_Default' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_LocomotionTransitions_Default_To_Jog2Idle) == 0x0006D0, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_LocomotionTransitions_Default_To_Jog2Idle' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bTransition_LocomotionTransitions_Jog2Idle_To_Default) == 0x0006D1, "Member 'UOrionCPPHeroBaseAnimInstance::bTransition_LocomotionTransitions_Jog2Idle_To_Default' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, HitReactAnims) == 0x0006D8, "Member 'UOrionCPPHeroBaseAnimInstance::HitReactAnims' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, HitReactAnim) == 0x0006F8, "Member 'UOrionCPPHeroBaseAnimInstance::HitReactAnim' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, bPlayingHitReact) == 0x000700, "Member 'UOrionCPPHeroBaseAnimInstance::bPlayingHitReact' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, HitReactAnimPosition) == 0x000704, "Member 'UOrionCPPHeroBaseAnimInstance::HitReactAnimPosition' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, HitReactBlendAlpha) == 0x000708, "Member 'UOrionCPPHeroBaseAnimInstance::HitReactBlendAlpha' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, AbilityInMotionSlotName) == 0x000710, "Member 'UOrionCPPHeroBaseAnimInstance::AbilityInMotionSlotName' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, UpperBodySlotName) == 0x000718, "Member 'UOrionCPPHeroBaseAnimInstance::UpperBodySlotName' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, UpperBodySlotMaskWeight) == 0x000720, "Member 'UOrionCPPHeroBaseAnimInstance::UpperBodySlotMaskWeight' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, LocomotionSpeedWarpingSettings) == 0x000724, "Member 'UOrionCPPHeroBaseAnimInstance::LocomotionSpeedWarpingSettings' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, TravelModeSpeedWarpingSettings) == 0x000734, "Member 'UOrionCPPHeroBaseAnimInstance::TravelModeSpeedWarpingSettings' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, LocalSpaceVelocityDirPreTurn) == 0x000744, "Member 'UOrionCPPHeroBaseAnimInstance::LocalSpaceVelocityDirPreTurn' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, AnimDynamicsForceScaling) == 0x000750, "Member 'UOrionCPPHeroBaseAnimInstance::AnimDynamicsForceScaling' has a wrong offset!");
static_assert(offsetof(UOrionCPPHeroBaseAnimInstance, AnimDynamicsForce) == 0x000754, "Member 'UOrionCPPHeroBaseAnimInstance::AnimDynamicsForce' has a wrong offset!");

// Class OrionGame.OrionBaseHeroAnimInstance
// 0x0010 (0x0770 - 0x0760)
class UOrionBaseHeroAnimInstance : public UOrionCPPHeroBaseAnimInstance
{
public:
	uint8                                         Pad_760[0x10];                                     // 0x0760(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AnimNotify_EnteredIdle(const class UAnimNotify* Notify);
	void AnimNotify_EnteredTurnInPlace(const class UAnimNotify* Notify);
	void AnimNotify_ExitedIdle(const class UAnimNotify* Notify);
	void AnimNotify_ExitedTurnInPlace(const class UAnimNotify* Notify);
	void AnimNotify_HitReactEnd(const class UAnimNotify* Notify);
	void AnimNotify_IdleToJog(const class UAnimNotify* Notify);
	void AnimNotify_JogToIdle(const class UAnimNotify* Notify);
	void AnimNotify_JumpExit(const class UAnimNotify* Notify);
	void AnimNotify_JumpLandingExit(const class UAnimNotify* Notify);
	void AnimNotify_MeleeFullBody(const class UAnimNotify* Notify);
	void AnimNotify_MeleeUpperBody(const class UAnimNotify* Notify);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionBaseHeroAnimInstance">();
	}
	static class UOrionBaseHeroAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionBaseHeroAnimInstance>();
	}
};
static_assert(alignof(UOrionBaseHeroAnimInstance) == 0x000008, "Wrong alignment on UOrionBaseHeroAnimInstance");
static_assert(sizeof(UOrionBaseHeroAnimInstance) == 0x000770, "Wrong size on UOrionBaseHeroAnimInstance");

// Class OrionGame.OrionGadgetAnimInstance
// 0x0010 (0x0780 - 0x0770)
class UOrionGadgetAnimInstance final : public UOrionBaseHeroAnimInstance
{
public:
	bool                                          bIsQCooldown;                                      // 0x0770(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsQTargeting;                                     // 0x0771(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_772[0x2];                                      // 0x0772(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FreeBotAlpha;                                      // 0x0774(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAbilityAdditives_QTargetLoop_to_Default;          // 0x0778(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAbilityAdditives_QTargetLoop_to_QCooldown;        // 0x0779(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_77A[0x6];                                      // 0x077A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGadgetAnimInstance">();
	}
	static class UOrionGadgetAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionGadgetAnimInstance>();
	}
};
static_assert(alignof(UOrionGadgetAnimInstance) == 0x000008, "Wrong alignment on UOrionGadgetAnimInstance");
static_assert(sizeof(UOrionGadgetAnimInstance) == 0x000780, "Wrong size on UOrionGadgetAnimInstance");
static_assert(offsetof(UOrionGadgetAnimInstance, bIsQCooldown) == 0x000770, "Member 'UOrionGadgetAnimInstance::bIsQCooldown' has a wrong offset!");
static_assert(offsetof(UOrionGadgetAnimInstance, bIsQTargeting) == 0x000771, "Member 'UOrionGadgetAnimInstance::bIsQTargeting' has a wrong offset!");
static_assert(offsetof(UOrionGadgetAnimInstance, FreeBotAlpha) == 0x000774, "Member 'UOrionGadgetAnimInstance::FreeBotAlpha' has a wrong offset!");
static_assert(offsetof(UOrionGadgetAnimInstance, bAbilityAdditives_QTargetLoop_to_Default) == 0x000778, "Member 'UOrionGadgetAnimInstance::bAbilityAdditives_QTargetLoop_to_Default' has a wrong offset!");
static_assert(offsetof(UOrionGadgetAnimInstance, bAbilityAdditives_QTargetLoop_to_QCooldown) == 0x000779, "Member 'UOrionGadgetAnimInstance::bAbilityAdditives_QTargetLoop_to_QCooldown' has a wrong offset!");

// Class OrionGame.OrionInputHandlerWidget
// 0x0000 (0x0028 - 0x0028)
class IOrionInputHandlerWidget final : public IInterface
{
public:
	void HandleRequestedInput(const struct FKey& Key, EInputEvent EventType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionInputHandlerWidget">();
	}
	static class IOrionInputHandlerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOrionInputHandlerWidget>();
	}
};
static_assert(alignof(IOrionInputHandlerWidget) == 0x000008, "Wrong alignment on IOrionInputHandlerWidget");
static_assert(sizeof(IOrionInputHandlerWidget) == 0x000028, "Wrong size on IOrionInputHandlerWidget");

// Class OrionGame.OrionGameState_ArcadeLobby
// 0x0000 (0x05D0 - 0x05D0)
class AOrionGameState_ArcadeLobby final : public AOrionGameState_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameState_ArcadeLobby">();
	}
	static class AOrionGameState_ArcadeLobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionGameState_ArcadeLobby>();
	}
};
static_assert(alignof(AOrionGameState_ArcadeLobby) == 0x000010, "Wrong alignment on AOrionGameState_ArcadeLobby");
static_assert(sizeof(AOrionGameState_ArcadeLobby) == 0x0005D0, "Wrong size on AOrionGameState_ArcadeLobby");

// Class OrionGame.LocalPlayerCommon
// 0x0198 (0x0360 - 0x01C8)
class ULocalPlayerCommon : public ULocalPlayer
{
public:
	class UOnlineAccountCommon*                   OnlineAccount;                                     // 0x01C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D0[0x30];                                     // 0x01D0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UClientSettingsRecord*                  ClientSettingsRecord;                              // 0x0200(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_208[0x158];                                    // 0x0208(0x0158)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalPlayerCommon">();
	}
	static class ULocalPlayerCommon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalPlayerCommon>();
	}
};
static_assert(alignof(ULocalPlayerCommon) == 0x000008, "Wrong alignment on ULocalPlayerCommon");
static_assert(sizeof(ULocalPlayerCommon) == 0x000360, "Wrong size on ULocalPlayerCommon");
static_assert(offsetof(ULocalPlayerCommon, OnlineAccount) == 0x0001C8, "Member 'ULocalPlayerCommon::OnlineAccount' has a wrong offset!");
static_assert(offsetof(ULocalPlayerCommon, ClientSettingsRecord) == 0x000200, "Member 'ULocalPlayerCommon::ClientSettingsRecord' has a wrong offset!");

// Class OrionGame.MapPreloadList
// 0x0038 (0x0068 - 0x0030)
class UMapPreloadList final : public UDataAsset
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        ReferencedObjects;                                 // 0x0050(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapPreloadList">();
	}
	static class UMapPreloadList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapPreloadList>();
	}
};
static_assert(alignof(UMapPreloadList) == 0x000008, "Wrong alignment on UMapPreloadList");
static_assert(sizeof(UMapPreloadList) == 0x000068, "Wrong size on UMapPreloadList");
static_assert(offsetof(UMapPreloadList, ReferencedObjects) == 0x000050, "Member 'UMapPreloadList::ReferencedObjects' has a wrong offset!");

// Class OrionGame.OrionProjectile
// 0x03F8 (0x0710 - 0x0318)
class AOrionProjectile : public AActor
{
public:
	uint8                                         Pad_318[0x10];                                     // 0x0318(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagRequirements               TargetingTagRequirements;                          // 0x0328(0x0040)(NativeAccessSpecifierPublic)
	uint8                                         Pad_368[0x30];                                     // 0x0368(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayEffectContextHandle           EffectContext;                                     // 0x0398(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class AActor*                                 Shooter;                                           // 0x03B0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 CachedHitActor;                                    // 0x03B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrionTeam                                    ShooterTeam;                                       // 0x03C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C1[0x3];                                      // 0x03C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  LockOnActor;                                       // 0x03C4(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                HomingOffset;                                      // 0x03CC(0x000C)(BlueprintVisible, BlueprintReadOnly, Net, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FOrionFilterAndEffectsContainer        OnHitFilterAndEffectsContainters;                  // 0x03D8(0x0020)(Edit, BlueprintVisible, Net, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	struct FOrionFilterAndEffectsContainer        OnPassThroughFilterAndEffectsContainers;           // 0x03F8(0x0020)(Edit, BlueprintVisible, Net, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	struct FOrionFilterAndEffectsContainer        OnExplosionFilterAndEffectsContainters;            // 0x0418(0x0020)(Edit, BlueprintVisible, Net, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	float                                         ResetActorOverlapSeconds;                          // 0x0438(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_43C[0x6C];                                     // 0x043C(0x006C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldCleanUpAppliedGameplayEffects;              // 0x04A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrionMuzzleSocket                            MuzzleSocket;                                      // 0x04A9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4AA[0x2];                                      // 0x04AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MuzzleOffsetBlendDistance;                         // 0x04AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MuzzleOffsetBlendExponent;                         // 0x04B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B4[0x54];                                     // 0x04B4(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	EOrionProjectileSpeed                         LaunchSpeed;                                       // 0x0508(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_509[0x3];                                      // 0x0509(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LaunchSpeedCoeffecient;                            // 0x050C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrionProjectileLaunchMode                    LaunchMode;                                        // 0x0510(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_511[0x3];                                      // 0x0511(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize100                 SpawnOrigin;                                       // 0x0514(0x000C)(Net, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector_NetQuantize100                 SpawnEndPoint;                                     // 0x0520(0x000C)(Net, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               SpawnRotation;                                     // 0x052C(0x000C)(Net, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bArcToTarget : 1;                                  // 0x0538(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsCloned : 1;                                     // 0x0538(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bOnlyCollideWithLockOnActor : 1;                   // 0x0538(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsShutdown : 1;                                   // 0x0538(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDestroyOnHitActor : 1;                            // 0x0538(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDestroyOnStop : 1;                                // 0x0538(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDestroyAtMaxRange : 1;                            // 0x0538(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bGrantExtendedMaxRangeWhenHoming : 1;              // 0x0538(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_539[0x3];                                      // 0x0539(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bFindHomingOffsetLocation : 1;                     // 0x053C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         BitPad_53C_1 : 7;                                  // 0x053C(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         Pad_53D[0x3];                                      // 0x053D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bDestroyOnVelocityReversed : 1;                    // 0x0540(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bStickOnStop : 1;                                  // 0x0540(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bNetSyncOnWorldCollision : 1;                      // 0x0540(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bNetSyncOnHitActor : 1;                            // 0x0540(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCurrentEventSyncToServerPosAndVel : 1;            // 0x0540(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCurrentEventConsumeBehavior : 1;                  // 0x0540(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_541[0x3];                                      // 0x0541(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastWorldCollisionTime;                            // 0x0544(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         WorldCollisionCount;                               // 0x0548(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AutoDestroyTime;                                   // 0x054C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FScalableFloat                         Range;                                             // 0x0550(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         HomingExtendedRangeScalar;                         // 0x0578(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  AllowedExtendedRangeHomingTargetTags;              // 0x05A0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         NotifyTime;                                        // 0x05C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C4[0x4];                                      // 0x05C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         NotifyRange;                                       // 0x05C8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FVector                                NotifyOrigin;                                      // 0x05F0(0x000C)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bReachedNotifyRange : 1;                           // 0x05FC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHasExploded : 1;                                  // 0x05FC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bExplodeOnDestroy : 1;                             // 0x05FC(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_5FD[0x3];                                      // 0x05FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         ExplosionRadius;                                   // 0x0600(0x0028)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FOrionProjectileCues                   ProjectileGameplayCues;                            // 0x0628(0x0048)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	int32                                         AbilityLevel;                                      // 0x0670(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          OrionProjectile_AlwaysRelevant;                    // 0x0674(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_675[0x3];                                      // 0x0675(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VisualComponentOffset;                             // 0x0678(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_684[0x4];                                      // 0x0684(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       CollisionBlockComponent;                           // 0x0688(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       CollisionOverlapComponent;                         // 0x0690(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionProjectileMovementComponent*      MovementComponent;                                 // 0x0698(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        VisualRootComponent;                               // 0x06A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   MeshComponent;                                     // 0x06A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystemComponent*               ParticleTrailComponent;                            // 0x06B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioComponent*                        LoopingAudioComponent;                             // 0x06B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6C0[0x34];                                     // 0x06C0(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Debug_ReplicatedLocation;                          // 0x06F4(0x000C)(Net, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               Debug_ReplicatedRotation;                          // 0x0700(0x000C)(Net, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70C[0x4];                                      // 0x070C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Parameters);
	void DestroyActorReplicated();
	void EndTimeDilation(const int32 WhichDilationChannel, const float LerpOutSeconds, const float Delay);
	void ExecuteGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Parameters);
	void Explode();
	void HandleHomingEnterPhaseShift(class AOrionChar* PhaseShifedChar);
	bool K2_InitProjectileFilters(class AActor* InInstigator, class AActor* InSource, float InLevel, class UGameplayAbility* InAbility);
	void NetSync_HitActor(const struct FHitResult& Hit, int32 UserStateID, bool bSyncClientToServerPosAndVel);
	void NetSync_SetNewTarget(class AActor* NewTargetActor, const struct FVector& NewSourceLocation, const struct FVector& NewTargetLocation, int32 UserStateID, bool bSyncClientToServerPosAndVel);
	void NetSync_WorldCollision(const struct FHitResult& Hit, const struct FVector& ImpactVelocity, const int32 InWorldCollisionCount, bool bSyncClientToServerPosAndVel);
	void OnActorDestroy(class AActor* DestroyedActor);
	void OnAutoDestroy();
	void OnBounce(const struct FHitResult& Hit);
	void OnBounceCallback(const struct FHitResult& Hit, const struct FVector& ImpactVelocity);
	void OnBounceCallbackInternal(const struct FHitResult& Hit, const struct FVector& ImpactVelocity, const int32 InNewWorldCollisionCount);
	void OnCloned(class AActor* InNewInstigator, class AActor* InNewSourceActor, class AOrionProjectile* SourceProjectile, class UOrionProjectileMovementComponent* SourceMovementComponent);
	void OnCustomHit(const struct FHitResult& Hit, EProjectileCustomHitResponseType ProjectileCustomHitResponseType, bool* bConsumeEvent, bool* bConsumeDestroy);
	void OnExplode(const TArray<class AActor*>& EffectedActors);
	void OnHitActor(const struct FHitResult& Hit);
	void OnMaxRangeCallback();
	void OnNetSync_HitActor(const struct FHitResult& Hit, int32 UserStateID);
	void OnNetSync_SetNewTarget(class AActor* NewTargetActor, const struct FVector& NewSourceLocation, const struct FVector& NewTargetLocation, int32 UserStateID);
	void OnNetSync_WorldCollision(const int32 InWorldCollisionCount, const struct FHitResult& Hit, const struct FVector& ImpactVelocity);
	void OnNotifyRange();
	void OnNotifyTime();
	void OnOverlapCallback(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnOverlappedLockOnActor(class AActor* PreviousLockOnActor);
	void OnRep_LockOnActor();
	void OnRep_Shooter();
	void OnShutdown();
	void OnStop(const struct FHitResult& Hit);
	void OnStopCallback(const struct FHitResult& Hit);
	void OnVelocityReversed();
	void OnVelocityReversedCallback();
	void ProjectileHitDelegate__DelegateSignature(const struct FHitResult& HitResult);
	void ProjectileShutdownDelegate__DelegateSignature();
	void RemoveGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Parameters);
	void SetAutoDestroyTime(float Time);
	void SetExplosionFilterAndEffectsContainer(struct FOrionFilterAndEffectsContainer& NewFilterContainer);
	void SetHitFilterAndEffectsContainter(struct FOrionFilterAndEffectsContainer& NewFilterContainer);
	void SetLockOnActor(class AActor* Actor, const struct FVector& InHomingOffset);
	void SetNotifyRange(float Range_0);
	void SetNotifyTime(float Time);
	void SetTargetingTagRequirements(const struct FGameplayTagRequirements& InTargetingTagRequirements);
	void StartTimeDilation(const int32 WhichDilationChannel, const float TargetDilation, const float LerpInSeconds, const float Duration, const float LerpOutSeconds, const float Opt_StartDilation);
	void SyncHitActor(const struct FHitResult& Hit, int32 UserStateID, const struct FVector& ServerPosition, const struct FVector& ServerVelocity);
	void SyncSetNewTarget(class AActor* NewTargetActor, const struct FVector& NewSourceLocation, const struct FVector& NewTargetLocation, int32 UserStateID, const struct FVector& ServerPosition, const struct FVector& ServerVelocity);
	void SyncStartTimeDilation(const struct FVector& ServerPosition, const struct FVector& ServerVelocity, const int32 WhichDilationChannel, const float TargetDilation, const float LerpInSeconds, const float Duration, const float LerpOutSeconds, const float Opt_StartDilation);
	void SyncTimeDilationArrivedAtTarget(const int32 WhichDilationChannel, const struct FVector& ServerPosition, const struct FVector& ServerVelocity);
	void SyncWorldCollision(const struct FHitResult& Hit, const struct FVector& ImpactVelocity, const int32 InWorldCollisionCount, const struct FVector& ServerPosition, const struct FVector& ServerVelocity);

	float GetNotifyRange() const;
	EOrionTeam GetTeamNum() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionProjectile">();
	}
	static class AOrionProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionProjectile>();
	}
};
static_assert(alignof(AOrionProjectile) == 0x000008, "Wrong alignment on AOrionProjectile");
static_assert(sizeof(AOrionProjectile) == 0x000710, "Wrong size on AOrionProjectile");
static_assert(offsetof(AOrionProjectile, TargetingTagRequirements) == 0x000328, "Member 'AOrionProjectile::TargetingTagRequirements' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, EffectContext) == 0x000398, "Member 'AOrionProjectile::EffectContext' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, Shooter) == 0x0003B0, "Member 'AOrionProjectile::Shooter' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, CachedHitActor) == 0x0003B8, "Member 'AOrionProjectile::CachedHitActor' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, ShooterTeam) == 0x0003C0, "Member 'AOrionProjectile::ShooterTeam' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, LockOnActor) == 0x0003C4, "Member 'AOrionProjectile::LockOnActor' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, HomingOffset) == 0x0003CC, "Member 'AOrionProjectile::HomingOffset' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, OnHitFilterAndEffectsContainters) == 0x0003D8, "Member 'AOrionProjectile::OnHitFilterAndEffectsContainters' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, OnPassThroughFilterAndEffectsContainers) == 0x0003F8, "Member 'AOrionProjectile::OnPassThroughFilterAndEffectsContainers' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, OnExplosionFilterAndEffectsContainters) == 0x000418, "Member 'AOrionProjectile::OnExplosionFilterAndEffectsContainters' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, ResetActorOverlapSeconds) == 0x000438, "Member 'AOrionProjectile::ResetActorOverlapSeconds' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, bShouldCleanUpAppliedGameplayEffects) == 0x0004A8, "Member 'AOrionProjectile::bShouldCleanUpAppliedGameplayEffects' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, MuzzleSocket) == 0x0004A9, "Member 'AOrionProjectile::MuzzleSocket' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, MuzzleOffsetBlendDistance) == 0x0004AC, "Member 'AOrionProjectile::MuzzleOffsetBlendDistance' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, MuzzleOffsetBlendExponent) == 0x0004B0, "Member 'AOrionProjectile::MuzzleOffsetBlendExponent' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, LaunchSpeed) == 0x000508, "Member 'AOrionProjectile::LaunchSpeed' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, LaunchSpeedCoeffecient) == 0x00050C, "Member 'AOrionProjectile::LaunchSpeedCoeffecient' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, LaunchMode) == 0x000510, "Member 'AOrionProjectile::LaunchMode' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, SpawnOrigin) == 0x000514, "Member 'AOrionProjectile::SpawnOrigin' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, SpawnEndPoint) == 0x000520, "Member 'AOrionProjectile::SpawnEndPoint' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, SpawnRotation) == 0x00052C, "Member 'AOrionProjectile::SpawnRotation' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, LastWorldCollisionTime) == 0x000544, "Member 'AOrionProjectile::LastWorldCollisionTime' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, WorldCollisionCount) == 0x000548, "Member 'AOrionProjectile::WorldCollisionCount' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, AutoDestroyTime) == 0x00054C, "Member 'AOrionProjectile::AutoDestroyTime' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, Range) == 0x000550, "Member 'AOrionProjectile::Range' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, HomingExtendedRangeScalar) == 0x000578, "Member 'AOrionProjectile::HomingExtendedRangeScalar' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, AllowedExtendedRangeHomingTargetTags) == 0x0005A0, "Member 'AOrionProjectile::AllowedExtendedRangeHomingTargetTags' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, NotifyTime) == 0x0005C0, "Member 'AOrionProjectile::NotifyTime' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, NotifyRange) == 0x0005C8, "Member 'AOrionProjectile::NotifyRange' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, NotifyOrigin) == 0x0005F0, "Member 'AOrionProjectile::NotifyOrigin' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, ExplosionRadius) == 0x000600, "Member 'AOrionProjectile::ExplosionRadius' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, ProjectileGameplayCues) == 0x000628, "Member 'AOrionProjectile::ProjectileGameplayCues' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, AbilityLevel) == 0x000670, "Member 'AOrionProjectile::AbilityLevel' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, OrionProjectile_AlwaysRelevant) == 0x000674, "Member 'AOrionProjectile::OrionProjectile_AlwaysRelevant' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, VisualComponentOffset) == 0x000678, "Member 'AOrionProjectile::VisualComponentOffset' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, CollisionBlockComponent) == 0x000688, "Member 'AOrionProjectile::CollisionBlockComponent' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, CollisionOverlapComponent) == 0x000690, "Member 'AOrionProjectile::CollisionOverlapComponent' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, MovementComponent) == 0x000698, "Member 'AOrionProjectile::MovementComponent' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, VisualRootComponent) == 0x0006A0, "Member 'AOrionProjectile::VisualRootComponent' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, MeshComponent) == 0x0006A8, "Member 'AOrionProjectile::MeshComponent' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, ParticleTrailComponent) == 0x0006B0, "Member 'AOrionProjectile::ParticleTrailComponent' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, LoopingAudioComponent) == 0x0006B8, "Member 'AOrionProjectile::LoopingAudioComponent' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, Debug_ReplicatedLocation) == 0x0006F4, "Member 'AOrionProjectile::Debug_ReplicatedLocation' has a wrong offset!");
static_assert(offsetof(AOrionProjectile, Debug_ReplicatedRotation) == 0x000700, "Member 'AOrionProjectile::Debug_ReplicatedRotation' has a wrong offset!");

// Class OrionGame.OrionFloorProjectile
// 0x0000 (0x0710 - 0x0710)
class AOrionFloorProjectile final : public AOrionProjectile
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionFloorProjectile">();
	}
	static class AOrionFloorProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionFloorProjectile>();
	}
};
static_assert(alignof(AOrionFloorProjectile) == 0x000008, "Wrong alignment on AOrionFloorProjectile");
static_assert(sizeof(AOrionFloorProjectile) == 0x000710, "Wrong size on AOrionFloorProjectile");

// Class OrionGame.MessageOfTheDay
// 0x0060 (0x0088 - 0x0028)
class UMessageOfTheDay final : public UObject
{
public:
	class FText                                   Title;                                             // 0x0028(0x0018)(BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   Body;                                              // 0x0040(0x0018)(BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FText                                   Date;                                              // 0x0058(0x0018)(BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	bool                                          bHasShown;                                         // 0x0070(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x17];                                      // 0x0071(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMessageOfTheDay* GetMessageOfTheDay();

	bool ShouldShowMOTD() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MessageOfTheDay">();
	}
	static class UMessageOfTheDay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMessageOfTheDay>();
	}
};
static_assert(alignof(UMessageOfTheDay) == 0x000008, "Wrong alignment on UMessageOfTheDay");
static_assert(sizeof(UMessageOfTheDay) == 0x000088, "Wrong size on UMessageOfTheDay");
static_assert(offsetof(UMessageOfTheDay, Title) == 0x000028, "Member 'UMessageOfTheDay::Title' has a wrong offset!");
static_assert(offsetof(UMessageOfTheDay, Body) == 0x000040, "Member 'UMessageOfTheDay::Body' has a wrong offset!");
static_assert(offsetof(UMessageOfTheDay, Date) == 0x000058, "Member 'UMessageOfTheDay::Date' has a wrong offset!");
static_assert(offsetof(UMessageOfTheDay, bHasShown) == 0x000070, "Member 'UMessageOfTheDay::bHasShown' has a wrong offset!");

// Class OrionGame.OnlineSessionClientCommon
// 0x0000 (0x02C0 - 0x02C0)
class UOnlineSessionClientCommon : public UOnlineSessionClient
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineSessionClientCommon">();
	}
	static class UOnlineSessionClientCommon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineSessionClientCommon>();
	}
};
static_assert(alignof(UOnlineSessionClientCommon) == 0x000008, "Wrong alignment on UOnlineSessionClientCommon");
static_assert(sizeof(UOnlineSessionClientCommon) == 0x0002C0, "Wrong size on UOnlineSessionClientCommon");

// Class OrionGame.OrionQueryTest_CharacterType
// 0x0018 (0x01D8 - 0x01C0)
class UOrionQueryTest_CharacterType final : public UEnvQueryTest
{
public:
	float                                         HeroWeight;                                        // 0x01C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinionWeight;                                      // 0x01C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C8[0xC];                                      // 0x01C8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bTestAgainstHeroes : 1;                            // 0x01D4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTestAgainstMinions : 1;                           // 0x01D4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D5[0x3];                                      // 0x01D5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionQueryTest_CharacterType">();
	}
	static class UOrionQueryTest_CharacterType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionQueryTest_CharacterType>();
	}
};
static_assert(alignof(UOrionQueryTest_CharacterType) == 0x000008, "Wrong alignment on UOrionQueryTest_CharacterType");
static_assert(sizeof(UOrionQueryTest_CharacterType) == 0x0001D8, "Wrong size on UOrionQueryTest_CharacterType");
static_assert(offsetof(UOrionQueryTest_CharacterType, HeroWeight) == 0x0001C0, "Member 'UOrionQueryTest_CharacterType::HeroWeight' has a wrong offset!");
static_assert(offsetof(UOrionQueryTest_CharacterType, MinionWeight) == 0x0001C4, "Member 'UOrionQueryTest_CharacterType::MinionWeight' has a wrong offset!");

// Class OrionGame.OrionAbility
// 0x0578 (0x0B70 - 0x05F8)
class UOrionAbility : public UGameplayAbility
{
public:
	uint8                                         Pad_5F8[0x78];                                     // 0x05F8(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOrionIconTextureOverrides>     IconTextureOverrides;                              // 0x0670(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0680(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScalableFloat                         MaxAbilityLevel;                                   // 0x0698(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScalableFloat                         StartingAbilityLevel;                              // 0x06C0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScalableFloat                         NextLevelUnlock;                                   // 0x06E8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bAbilityStartsUnlocked;                            // 0x0710(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_711[0x7];                                      // 0x0711(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AOrionTargetingMode_Base>> TargetingModeClasses;                              // 0x0718(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bActivateOnInputHeld;                              // 0x0728(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeQueued;                                      // 0x0729(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoEnableQueuingWhenBlocking;                    // 0x072A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPassiveActivation                            PassiveActivationType;                             // 0x072B(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbilityAutoConfirmInputMode                  AutoConfirmInputMode;                              // 0x072C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72D[0x13];                                     // 0x072D(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionCooldownInfo                     CooldownInfo;                                      // 0x0740(0x0068)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FOrionCostInfo                         CostInfo;                                          // 0x07A8(0x0100)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          ConsumeGameplayEffectStack;                        // 0x08A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionAbilityActivationGroup                  ActivationGroup;                                   // 0x08A9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bServerAuthoritativeOnActivationBlock;             // 0x08AA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EReticleVisibility                            ReticleVisibility;                                 // 0x08AB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8AC[0x4];                                      // 0x08AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UOrionUserWidget_Reticle>   ReticleWidgetClass;                                // 0x08B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8B8[0x8];                                      // 0x08B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPassiveHUDInfo                        PassiveHUDInfo;                                    // 0x08C0(0x0180)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bShowEngagedWhileAbilityIsActive;                  // 0x0A40(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeverActivates;                                   // 0x0A41(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A42[0x2E];                                     // 0x0A42(0x002E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         MaxTrackedActors;                                  // 0x0A70(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScalableFloat                         MaxTrackedActorLifetimes;                          // 0x0A98(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EOrionAbilityBotInputConfirmation             InputConfirmationPolicy;                           // 0x0AC0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionAbilityBotFocusOverride                 BotFocusOverride;                                  // 0x0AC1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC2[0x2];                                      // 0x0AC2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConfirmationParameter;                             // 0x0AC4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGameplayTaskResource>> RequiredAIResources;                               // 0x0AC8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	class UEnvQuery*                              PositioningEQSQuery;                               // 0x0AD8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BotAbilityRangeOverride;                           // 0x0AE0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BotAbilityLifeSpanOverride;                        // 0x0AE4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiresValidTarget;                              // 0x0AE8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bBotAoENotify : 1;                                 // 0x0AE9(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bActivateViaInputID : 1;                           // 0x0AE9(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRequireLoS : 1;                                   // 0x0AE9(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAvailableToBots : 1;                              // 0x0AE9(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_AEA[0x6];                                      // 0x0AEA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             IconTexture;                                       // 0x0AF0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AF8[0x8];                                      // 0x0AF8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionAbilityCues                      AbilityGameplayCues;                               // 0x0B00(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B08[0x10];                                     // 0x0B08(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAbilityQueuingFromMontage;                        // 0x0B18(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B19[0x7];                                      // 0x0B19(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Description;                                       // 0x0B20(0x0018)(Edit, NativeAccessSpecifierPrivate)
	class FText                                   ShortDescription;                                  // 0x0B38(0x0018)(Edit, NativeAccessSpecifierPrivate)
	TArray<struct FUIDescriptionLookup>           DescriptionLookups;                                // 0x0B50(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FUICustomDescriptionLookup>     CustomDescriptionLookups;                          // 0x0B60(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	struct FOrionAuraHandle BeginAura(const struct FOrionFilterAndEffectsContainer& FilterAndEffectsContainers, const struct FOrionFilterAndEffectsContainer& PeriodicFilterAndEffectsContainers, float Radius, const struct FScalableFloat& Period, bool ReapplyEffectOnRemoval, bool EndWhenAbilityEnds);
	void BlockMovementInput(bool bResetOnDeath);
	struct FActiveGameplayEffectHandle BP_ApplyGameplayEffectToOwner_Cached(TSubclassOf<class UGameplayEffect> GameplayEffectClass);
	void BP_CommitConsumableStack(bool BroadcastCommitEvent);
	struct FGameplayEffectSpecHandle BP_GetCachedGameplayEffeectSpec(TSubclassOf<class UGameplayEffect> GameplayEffectClass);
	void CancelCombo();
	void ChangeActivationGroup(EOrionAbilityActivationGroup NewGroup);
	void ClearCameraMode();
	bool ClearLookAtActor();
	void DisableAbilityQueuing();
	void EnableAbilityQueuing();
	void EndAura(const struct FOrionAuraHandle& Handle);
	int32 GetExternalAbilityLevel(const struct FGameplayTag& AbilityTag);
	struct FGameplayAbilityTargetDataHandle GetTargets();
	struct FOrionFilterAndEffectsContainer InitAndApplyFilterContainerToTargetData(struct FOrionFilterAndEffectsContainer& FilterContainer, const struct FGameplayAbilityTargetDataHandle& TargetData, TArray<struct FActiveGameplayEffectHandle>* AppliedEffectHandles);
	struct FOrionFilterAndEffectsContainer InitFilterAndEffectsContainer(struct FOrionFilterAndEffectsContainer& FilterContainer);
	void K2_OrionAddGameplayCue(const struct FGameplayTag& GameplayCueTag, const struct FGameplayEffectContextHandle& Context, bool bRemoveOnAbilityEnd);
	void K2_OrionApplyIgnorePawnCollision();
	void K2_OrionApplyInterruptionImmunity();
	void K2_OrionApplyLimboStatus();
	void K2_OrionApplyUnselectableStatus();
	void K2_OrionExecuteGameplayCue(const struct FGameplayTag& GameplayCueTag, const struct FGameplayEffectContextHandle& Context);
	void K2_OrionExecuteGameplayCueWithParams(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters);
	void K2_OrionRemoveGameplayCue(const struct FGameplayTag& GameplayCueTag);
	void K2_OrionRemoveIgnorePawnCollision();
	void K2_OrionRemoveInterruptionImmunity();
	void K2_OrionRemoveLimboStatus();
	void K2_OrionRemoveUnselectableStatus();
	void K2_SetUseFixedSkeletalBounds(bool UseFixedSkeletalBounds);
	void LockCameraRotation(bool bResetOnDeath);
	void LockCharacterRotation();
	void SetCameraMode(TSubclassOf<class UOrionCameraMode> CameraModeClass);
	bool SetLookAtActor(const class AActor* LookTarget, class FName LookSocket, float LookLerp, float LookAccel);
	void SetPassiveTargetingMode(int32 TargetingModeIndex);
	void SetReticleVisibility(EReticleVisibility Visibility);
	void SnapCharacterRotationToCamera();
	class AOrionChar* SpawnCharHeroDecoy(class AController* Controller, TSubclassOf<class AOrionCharHero_Decoy> OrionCharHeroDecoyClass, TSubclassOf<class UOrionVisionDef> VisionData);
	void TrackActor(class AActor* ActorToTrack);
	void TrackGroupedActor(class AActor* ActorToTrack, const struct FGameplayTag& GroupingTag);
	void TravelModeBlockAbilities();
	void TravelModeUnblockAbilities();
	void TryCombo();
	void UnBlockMovementInput(bool bResetOnDeath);
	void UnlockCameraRotation(bool bResetOnDeath);
	void UnlockCharacterRotation();

	bool AbilityHasTag(const struct FGameplayTag& TagToCheck) const;
	TArray<struct FGameplayAbilitySpecHandle> GetAbilitiesByTag(const struct FGameplayTagContainer& TagContainer) const;
	class UAnimMontage* GetMontageForEmoteByInputID() const;
	class UAnimMontage* GetMontageForEmoteType(EOrionEmoteType EmoteType) const;
	class AOrionCharAI* GetOrionCharAIFromActorInfo() const;
	class AOrionChar* GetOrionCharFromActorInfo() const;
	class AOrionCharHero* GetOrionCharHeroFromActorInfo() const;
	bool IsCharacterFalling() const;
	float K2_GetAttackSpeedMultiplier() const;
	class UAnimMontage* K2_GetBestMontageForAttackSpeed(const struct FOrionAbilityMontageContainer& MontageContainer, float* OutPlayRate) const;
	float K2_GetRateForAttackSpeedMontage(const class UAnimMontage* Montage, class FName SectionName, bool FillEntireAttackTime) const;
	float K2_GetTotalAttackTime() const;
	float K2_ScaleTimeByAttackSpeed(float BaseTime) const;
	struct FGameplayCueParameters MakeGameplayCueParameters(const struct FGameplayAbilityTargetDataHandle& TargetData) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbility">();
	}
	static class UOrionAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbility>();
	}
};
static_assert(alignof(UOrionAbility) == 0x000010, "Wrong alignment on UOrionAbility");
static_assert(sizeof(UOrionAbility) == 0x000B70, "Wrong size on UOrionAbility");
static_assert(offsetof(UOrionAbility, IconTextureOverrides) == 0x000670, "Member 'UOrionAbility::IconTextureOverrides' has a wrong offset!");
static_assert(offsetof(UOrionAbility, DisplayName) == 0x000680, "Member 'UOrionAbility::DisplayName' has a wrong offset!");
static_assert(offsetof(UOrionAbility, MaxAbilityLevel) == 0x000698, "Member 'UOrionAbility::MaxAbilityLevel' has a wrong offset!");
static_assert(offsetof(UOrionAbility, StartingAbilityLevel) == 0x0006C0, "Member 'UOrionAbility::StartingAbilityLevel' has a wrong offset!");
static_assert(offsetof(UOrionAbility, NextLevelUnlock) == 0x0006E8, "Member 'UOrionAbility::NextLevelUnlock' has a wrong offset!");
static_assert(offsetof(UOrionAbility, bAbilityStartsUnlocked) == 0x000710, "Member 'UOrionAbility::bAbilityStartsUnlocked' has a wrong offset!");
static_assert(offsetof(UOrionAbility, TargetingModeClasses) == 0x000718, "Member 'UOrionAbility::TargetingModeClasses' has a wrong offset!");
static_assert(offsetof(UOrionAbility, bActivateOnInputHeld) == 0x000728, "Member 'UOrionAbility::bActivateOnInputHeld' has a wrong offset!");
static_assert(offsetof(UOrionAbility, bCanBeQueued) == 0x000729, "Member 'UOrionAbility::bCanBeQueued' has a wrong offset!");
static_assert(offsetof(UOrionAbility, bAutoEnableQueuingWhenBlocking) == 0x00072A, "Member 'UOrionAbility::bAutoEnableQueuingWhenBlocking' has a wrong offset!");
static_assert(offsetof(UOrionAbility, PassiveActivationType) == 0x00072B, "Member 'UOrionAbility::PassiveActivationType' has a wrong offset!");
static_assert(offsetof(UOrionAbility, AutoConfirmInputMode) == 0x00072C, "Member 'UOrionAbility::AutoConfirmInputMode' has a wrong offset!");
static_assert(offsetof(UOrionAbility, CooldownInfo) == 0x000740, "Member 'UOrionAbility::CooldownInfo' has a wrong offset!");
static_assert(offsetof(UOrionAbility, CostInfo) == 0x0007A8, "Member 'UOrionAbility::CostInfo' has a wrong offset!");
static_assert(offsetof(UOrionAbility, ConsumeGameplayEffectStack) == 0x0008A8, "Member 'UOrionAbility::ConsumeGameplayEffectStack' has a wrong offset!");
static_assert(offsetof(UOrionAbility, ActivationGroup) == 0x0008A9, "Member 'UOrionAbility::ActivationGroup' has a wrong offset!");
static_assert(offsetof(UOrionAbility, bServerAuthoritativeOnActivationBlock) == 0x0008AA, "Member 'UOrionAbility::bServerAuthoritativeOnActivationBlock' has a wrong offset!");
static_assert(offsetof(UOrionAbility, ReticleVisibility) == 0x0008AB, "Member 'UOrionAbility::ReticleVisibility' has a wrong offset!");
static_assert(offsetof(UOrionAbility, ReticleWidgetClass) == 0x0008B0, "Member 'UOrionAbility::ReticleWidgetClass' has a wrong offset!");
static_assert(offsetof(UOrionAbility, PassiveHUDInfo) == 0x0008C0, "Member 'UOrionAbility::PassiveHUDInfo' has a wrong offset!");
static_assert(offsetof(UOrionAbility, bShowEngagedWhileAbilityIsActive) == 0x000A40, "Member 'UOrionAbility::bShowEngagedWhileAbilityIsActive' has a wrong offset!");
static_assert(offsetof(UOrionAbility, bNeverActivates) == 0x000A41, "Member 'UOrionAbility::bNeverActivates' has a wrong offset!");
static_assert(offsetof(UOrionAbility, MaxTrackedActors) == 0x000A70, "Member 'UOrionAbility::MaxTrackedActors' has a wrong offset!");
static_assert(offsetof(UOrionAbility, MaxTrackedActorLifetimes) == 0x000A98, "Member 'UOrionAbility::MaxTrackedActorLifetimes' has a wrong offset!");
static_assert(offsetof(UOrionAbility, InputConfirmationPolicy) == 0x000AC0, "Member 'UOrionAbility::InputConfirmationPolicy' has a wrong offset!");
static_assert(offsetof(UOrionAbility, BotFocusOverride) == 0x000AC1, "Member 'UOrionAbility::BotFocusOverride' has a wrong offset!");
static_assert(offsetof(UOrionAbility, ConfirmationParameter) == 0x000AC4, "Member 'UOrionAbility::ConfirmationParameter' has a wrong offset!");
static_assert(offsetof(UOrionAbility, RequiredAIResources) == 0x000AC8, "Member 'UOrionAbility::RequiredAIResources' has a wrong offset!");
static_assert(offsetof(UOrionAbility, PositioningEQSQuery) == 0x000AD8, "Member 'UOrionAbility::PositioningEQSQuery' has a wrong offset!");
static_assert(offsetof(UOrionAbility, BotAbilityRangeOverride) == 0x000AE0, "Member 'UOrionAbility::BotAbilityRangeOverride' has a wrong offset!");
static_assert(offsetof(UOrionAbility, BotAbilityLifeSpanOverride) == 0x000AE4, "Member 'UOrionAbility::BotAbilityLifeSpanOverride' has a wrong offset!");
static_assert(offsetof(UOrionAbility, bRequiresValidTarget) == 0x000AE8, "Member 'UOrionAbility::bRequiresValidTarget' has a wrong offset!");
static_assert(offsetof(UOrionAbility, IconTexture) == 0x000AF0, "Member 'UOrionAbility::IconTexture' has a wrong offset!");
static_assert(offsetof(UOrionAbility, AbilityGameplayCues) == 0x000B00, "Member 'UOrionAbility::AbilityGameplayCues' has a wrong offset!");
static_assert(offsetof(UOrionAbility, bAbilityQueuingFromMontage) == 0x000B18, "Member 'UOrionAbility::bAbilityQueuingFromMontage' has a wrong offset!");
static_assert(offsetof(UOrionAbility, Description) == 0x000B20, "Member 'UOrionAbility::Description' has a wrong offset!");
static_assert(offsetof(UOrionAbility, ShortDescription) == 0x000B38, "Member 'UOrionAbility::ShortDescription' has a wrong offset!");
static_assert(offsetof(UOrionAbility, DescriptionLookups) == 0x000B50, "Member 'UOrionAbility::DescriptionLookups' has a wrong offset!");
static_assert(offsetof(UOrionAbility, CustomDescriptionLookups) == 0x000B60, "Member 'UOrionAbility::CustomDescriptionLookups' has a wrong offset!");

// Class OrionGame.OrionBTDecorator_GameplayTagsMatch
// 0x0010 (0x00D8 - 0x00C8)
class UOrionBTDecorator_GameplayTagsMatch final : public UBTDecorator_CheckGameplayTagsOnActor
{
public:
	class UAbilitySystemComponent*                PreviousAbility;                                   // 0x00C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionBTDecorator_GameplayTagsMatch">();
	}
	static class UOrionBTDecorator_GameplayTagsMatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionBTDecorator_GameplayTagsMatch>();
	}
};
static_assert(alignof(UOrionBTDecorator_GameplayTagsMatch) == 0x000008, "Wrong alignment on UOrionBTDecorator_GameplayTagsMatch");
static_assert(sizeof(UOrionBTDecorator_GameplayTagsMatch) == 0x0000D8, "Wrong size on UOrionBTDecorator_GameplayTagsMatch");
static_assert(offsetof(UOrionBTDecorator_GameplayTagsMatch, PreviousAbility) == 0x0000C8, "Member 'UOrionBTDecorator_GameplayTagsMatch::PreviousAbility' has a wrong offset!");

// Class OrionGame.OrionAbility_CharacterJump
// 0x0000 (0x0B70 - 0x0B70)
class UOrionAbility_CharacterJump : public UOrionAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbility_CharacterJump">();
	}
	static class UOrionAbility_CharacterJump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbility_CharacterJump>();
	}
};
static_assert(alignof(UOrionAbility_CharacterJump) == 0x000010, "Wrong alignment on UOrionAbility_CharacterJump");
static_assert(sizeof(UOrionAbility_CharacterJump) == 0x000B70, "Wrong size on UOrionAbility_CharacterJump");

// Class OrionGame.OrionAbility_EventEvaluator
// 0x0010 (0x0B80 - 0x0B70)
class UOrionAbility_EventEvaluator final : public UOrionAbility
{
public:
	struct FGameplayEventKeywordTag               EventKeywordTag;                                   // 0x0B70(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B78[0x8];                                      // 0x0B78(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastEventComplete();
	void OnAbilityActivatedOrCommitCallback(class UGameplayAbility* AbilityThatActivated);
	void OnEventkeywordCallback();
	void OnGameplayEffectAppliedSelf(class AActor* Target, const struct FGameplayEffectSpecHandle& SpecHandle, const struct FActiveGameplayEffectHandle& ActiveHandle);
	void OnGameplayEffectAppliedTarget(class AActor* Target, const struct FGameplayEffectSpecHandle& SpecHandle, const struct FActiveGameplayEffectHandle& ActiveHandle);
	void OnGameplayEventCallback(const struct FGameplayEventData& Payload);
	void OnTagAddedCallback();
	void OnTagRemovedCallback();
	void TagTableLoaded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbility_EventEvaluator">();
	}
	static class UOrionAbility_EventEvaluator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbility_EventEvaluator>();
	}
};
static_assert(alignof(UOrionAbility_EventEvaluator) == 0x000010, "Wrong alignment on UOrionAbility_EventEvaluator");
static_assert(sizeof(UOrionAbility_EventEvaluator) == 0x000B80, "Wrong size on UOrionAbility_EventEvaluator");
static_assert(offsetof(UOrionAbility_EventEvaluator, EventKeywordTag) == 0x000B70, "Member 'UOrionAbility_EventEvaluator::EventKeywordTag' has a wrong offset!");

// Class OrionGame.OrionAbility_MeleeAttack
// 0x0100 (0x0C70 - 0x0B70)
class UOrionAbility_MeleeAttack final : public UOrionAbility
{
public:
	TArray<struct FOrionMeleeAttack>              MeleeAttacks;                                      // 0x0B70(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	EMovementMode                                 MeleeMovementMode;                                 // 0x0B80(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B81[0x7];                                      // 0x0B81(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         MeleeHitActors;                                    // 0x0B88(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FOrionAbilityTargetDataFilter          MeleeTargetFilter;                                 // 0x0B98(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         CurrentMeleeAttackIndex;                           // 0x0BC8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMeleeBlockInput;                                  // 0x0BCC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BCD[0x3];                                      // 0x0BCD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  BlockAbilitiesWithTagUntilCancelNotify;            // 0x0BD0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_BF0[0x35];                                     // 0x0BF0(0x0035)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAutoTransitionBetweenBlockingAndReplaceable;      // 0x0C25(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseMeleeTargetingIndicator;                       // 0x0C26(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C27[0xD];                                      // 0x0C27(0x000D)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MeleeTargetUpdateInterval;                         // 0x0C34(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MeleeTargetScoreInnerRadius;                       // 0x0C38(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MeleeTargetScoreOuterRadius;                       // 0x0C3C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MeleeTargetScoreCamAngleLimit;                     // 0x0C40(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MeleeTargetScoreInputAngleLimit;                   // 0x0C44(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MeleeTargetScoreHeightThreshold;                   // 0x0C48(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MeleeTargetScoreRangeFactor;                       // 0x0C4C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MeleeTargetScoreControlDirFactor;                  // 0x0C50(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MeleeTargetScoreCamDirFactor;                      // 0x0C54(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MeleeTargetScoreCharDirFactor;                     // 0x0C58(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C5C[0x14];                                     // 0x0C5C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMeleeTouch(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted);
	void ServerMeleeTouch(class AActor* MeleeTarget, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbility_MeleeAttack">();
	}
	static class UOrionAbility_MeleeAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbility_MeleeAttack>();
	}
};
static_assert(alignof(UOrionAbility_MeleeAttack) == 0x000010, "Wrong alignment on UOrionAbility_MeleeAttack");
static_assert(sizeof(UOrionAbility_MeleeAttack) == 0x000C70, "Wrong size on UOrionAbility_MeleeAttack");
static_assert(offsetof(UOrionAbility_MeleeAttack, MeleeAttacks) == 0x000B70, "Member 'UOrionAbility_MeleeAttack::MeleeAttacks' has a wrong offset!");
static_assert(offsetof(UOrionAbility_MeleeAttack, MeleeMovementMode) == 0x000B80, "Member 'UOrionAbility_MeleeAttack::MeleeMovementMode' has a wrong offset!");
static_assert(offsetof(UOrionAbility_MeleeAttack, MeleeHitActors) == 0x000B88, "Member 'UOrionAbility_MeleeAttack::MeleeHitActors' has a wrong offset!");
static_assert(offsetof(UOrionAbility_MeleeAttack, MeleeTargetFilter) == 0x000B98, "Member 'UOrionAbility_MeleeAttack::MeleeTargetFilter' has a wrong offset!");
static_assert(offsetof(UOrionAbility_MeleeAttack, CurrentMeleeAttackIndex) == 0x000BC8, "Member 'UOrionAbility_MeleeAttack::CurrentMeleeAttackIndex' has a wrong offset!");
static_assert(offsetof(UOrionAbility_MeleeAttack, bMeleeBlockInput) == 0x000BCC, "Member 'UOrionAbility_MeleeAttack::bMeleeBlockInput' has a wrong offset!");
static_assert(offsetof(UOrionAbility_MeleeAttack, BlockAbilitiesWithTagUntilCancelNotify) == 0x000BD0, "Member 'UOrionAbility_MeleeAttack::BlockAbilitiesWithTagUntilCancelNotify' has a wrong offset!");
static_assert(offsetof(UOrionAbility_MeleeAttack, bAutoTransitionBetweenBlockingAndReplaceable) == 0x000C25, "Member 'UOrionAbility_MeleeAttack::bAutoTransitionBetweenBlockingAndReplaceable' has a wrong offset!");
static_assert(offsetof(UOrionAbility_MeleeAttack, bUseMeleeTargetingIndicator) == 0x000C26, "Member 'UOrionAbility_MeleeAttack::bUseMeleeTargetingIndicator' has a wrong offset!");
static_assert(offsetof(UOrionAbility_MeleeAttack, MeleeTargetUpdateInterval) == 0x000C34, "Member 'UOrionAbility_MeleeAttack::MeleeTargetUpdateInterval' has a wrong offset!");
static_assert(offsetof(UOrionAbility_MeleeAttack, MeleeTargetScoreInnerRadius) == 0x000C38, "Member 'UOrionAbility_MeleeAttack::MeleeTargetScoreInnerRadius' has a wrong offset!");
static_assert(offsetof(UOrionAbility_MeleeAttack, MeleeTargetScoreOuterRadius) == 0x000C3C, "Member 'UOrionAbility_MeleeAttack::MeleeTargetScoreOuterRadius' has a wrong offset!");
static_assert(offsetof(UOrionAbility_MeleeAttack, MeleeTargetScoreCamAngleLimit) == 0x000C40, "Member 'UOrionAbility_MeleeAttack::MeleeTargetScoreCamAngleLimit' has a wrong offset!");
static_assert(offsetof(UOrionAbility_MeleeAttack, MeleeTargetScoreInputAngleLimit) == 0x000C44, "Member 'UOrionAbility_MeleeAttack::MeleeTargetScoreInputAngleLimit' has a wrong offset!");
static_assert(offsetof(UOrionAbility_MeleeAttack, MeleeTargetScoreHeightThreshold) == 0x000C48, "Member 'UOrionAbility_MeleeAttack::MeleeTargetScoreHeightThreshold' has a wrong offset!");
static_assert(offsetof(UOrionAbility_MeleeAttack, MeleeTargetScoreRangeFactor) == 0x000C4C, "Member 'UOrionAbility_MeleeAttack::MeleeTargetScoreRangeFactor' has a wrong offset!");
static_assert(offsetof(UOrionAbility_MeleeAttack, MeleeTargetScoreControlDirFactor) == 0x000C50, "Member 'UOrionAbility_MeleeAttack::MeleeTargetScoreControlDirFactor' has a wrong offset!");
static_assert(offsetof(UOrionAbility_MeleeAttack, MeleeTargetScoreCamDirFactor) == 0x000C54, "Member 'UOrionAbility_MeleeAttack::MeleeTargetScoreCamDirFactor' has a wrong offset!");
static_assert(offsetof(UOrionAbility_MeleeAttack, MeleeTargetScoreCharDirFactor) == 0x000C58, "Member 'UOrionAbility_MeleeAttack::MeleeTargetScoreCharDirFactor' has a wrong offset!");

// Class OrionGame.OrionQueryTest_LaneProgress
// 0x0018 (0x01D8 - 0x01C0)
class UOrionQueryTest_LaneProgress final : public UEnvQueryTest
{
public:
	uint8                                         bIgnoreJungleCreeps : 1;                           // 0x01C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UEnvQueryContext>           TeamMember;                                        // 0x01C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAILaneProgressReference                      ProgressReference;                                 // 0x01D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D1[0x7];                                      // 0x01D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionQueryTest_LaneProgress">();
	}
	static class UOrionQueryTest_LaneProgress* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionQueryTest_LaneProgress>();
	}
};
static_assert(alignof(UOrionQueryTest_LaneProgress) == 0x000008, "Wrong alignment on UOrionQueryTest_LaneProgress");
static_assert(sizeof(UOrionQueryTest_LaneProgress) == 0x0001D8, "Wrong size on UOrionQueryTest_LaneProgress");
static_assert(offsetof(UOrionQueryTest_LaneProgress, TeamMember) == 0x0001C8, "Member 'UOrionQueryTest_LaneProgress::TeamMember' has a wrong offset!");
static_assert(offsetof(UOrionQueryTest_LaneProgress, ProgressReference) == 0x0001D0, "Member 'UOrionQueryTest_LaneProgress::ProgressReference' has a wrong offset!");

// Class OrionGame.OrionAbility_Sprint
// 0x0000 (0x0B70 - 0x0B70)
class UOrionAbility_Sprint : public UOrionAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbility_Sprint">();
	}
	static class UOrionAbility_Sprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbility_Sprint>();
	}
};
static_assert(alignof(UOrionAbility_Sprint) == 0x000010, "Wrong alignment on UOrionAbility_Sprint");
static_assert(sizeof(UOrionAbility_Sprint) == 0x000B70, "Wrong size on UOrionAbility_Sprint");

// Class OrionGame.OrionRampageAnimInstance
// 0x0030 (0x07A0 - 0x0770)
class UOrionRampageAnimInstance final : public UOrionBaseHeroAnimInstance
{
public:
	bool                                          bIsDoingUlt;                                       // 0x0770(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRoarBuffed;                                     // 0x0771(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDoingRipNToss;                                  // 0x0772(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDoingAirAttack;                                 // 0x0773(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRipNTossCasting;                                // 0x0774(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRipNTossPreCast;                                // 0x0775(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRipNTossHold;                                   // 0x0776(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_Rampage_Idle_DefaultIdle_To_RelaxedIdle; // 0x0777(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HandIKAlpha;                                       // 0x0778(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                UltRootScale;                                      // 0x077C(0x000C)(Edit, BlueprintVisible, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RootScaleAlpha;                                    // 0x0788(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrillsOverrideWeight;                              // 0x078C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldBypassFrillsPostProcess;                     // 0x0790(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_791[0x7];                                      // 0x0791(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 RampageSkelMeshComponent;                          // 0x0798(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionRampageAnimInstance">();
	}
	static class UOrionRampageAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionRampageAnimInstance>();
	}
};
static_assert(alignof(UOrionRampageAnimInstance) == 0x000008, "Wrong alignment on UOrionRampageAnimInstance");
static_assert(sizeof(UOrionRampageAnimInstance) == 0x0007A0, "Wrong size on UOrionRampageAnimInstance");
static_assert(offsetof(UOrionRampageAnimInstance, bIsDoingUlt) == 0x000770, "Member 'UOrionRampageAnimInstance::bIsDoingUlt' has a wrong offset!");
static_assert(offsetof(UOrionRampageAnimInstance, bIsRoarBuffed) == 0x000771, "Member 'UOrionRampageAnimInstance::bIsRoarBuffed' has a wrong offset!");
static_assert(offsetof(UOrionRampageAnimInstance, bIsDoingRipNToss) == 0x000772, "Member 'UOrionRampageAnimInstance::bIsDoingRipNToss' has a wrong offset!");
static_assert(offsetof(UOrionRampageAnimInstance, bIsDoingAirAttack) == 0x000773, "Member 'UOrionRampageAnimInstance::bIsDoingAirAttack' has a wrong offset!");
static_assert(offsetof(UOrionRampageAnimInstance, bIsRipNTossCasting) == 0x000774, "Member 'UOrionRampageAnimInstance::bIsRipNTossCasting' has a wrong offset!");
static_assert(offsetof(UOrionRampageAnimInstance, bIsRipNTossPreCast) == 0x000775, "Member 'UOrionRampageAnimInstance::bIsRipNTossPreCast' has a wrong offset!");
static_assert(offsetof(UOrionRampageAnimInstance, bIsRipNTossHold) == 0x000776, "Member 'UOrionRampageAnimInstance::bIsRipNTossHold' has a wrong offset!");
static_assert(offsetof(UOrionRampageAnimInstance, bTransition_Rampage_Idle_DefaultIdle_To_RelaxedIdle) == 0x000777, "Member 'UOrionRampageAnimInstance::bTransition_Rampage_Idle_DefaultIdle_To_RelaxedIdle' has a wrong offset!");
static_assert(offsetof(UOrionRampageAnimInstance, HandIKAlpha) == 0x000778, "Member 'UOrionRampageAnimInstance::HandIKAlpha' has a wrong offset!");
static_assert(offsetof(UOrionRampageAnimInstance, UltRootScale) == 0x00077C, "Member 'UOrionRampageAnimInstance::UltRootScale' has a wrong offset!");
static_assert(offsetof(UOrionRampageAnimInstance, RootScaleAlpha) == 0x000788, "Member 'UOrionRampageAnimInstance::RootScaleAlpha' has a wrong offset!");
static_assert(offsetof(UOrionRampageAnimInstance, FrillsOverrideWeight) == 0x00078C, "Member 'UOrionRampageAnimInstance::FrillsOverrideWeight' has a wrong offset!");
static_assert(offsetof(UOrionRampageAnimInstance, ShouldBypassFrillsPostProcess) == 0x000790, "Member 'UOrionRampageAnimInstance::ShouldBypassFrillsPostProcess' has a wrong offset!");
static_assert(offsetof(UOrionRampageAnimInstance, RampageSkelMeshComponent) == 0x000798, "Member 'UOrionRampageAnimInstance::RampageSkelMeshComponent' has a wrong offset!");

// Class OrionGame.OrionAbilityTask_StartTargeting
// 0x0040 (0x00C0 - 0x0080)
class UOrionAbilityTask_StartTargeting : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   Confirmed;                                         // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   Cancelled;                                         // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x20];                                      // 0x00A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOrionAbilityTask_StartTargeting* StartTargeting(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, EGameplayTargetingConfirmation ConfirmationType, int32 Index_0);

	void CancelImpl();
	void ConfirmOrCancel();
	void ConfirmOrWait();
	void ServerForceClientTargetData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityTask_StartTargeting">();
	}
	static class UOrionAbilityTask_StartTargeting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbilityTask_StartTargeting>();
	}
};
static_assert(alignof(UOrionAbilityTask_StartTargeting) == 0x000008, "Wrong alignment on UOrionAbilityTask_StartTargeting");
static_assert(sizeof(UOrionAbilityTask_StartTargeting) == 0x0000C0, "Wrong size on UOrionAbilityTask_StartTargeting");
static_assert(offsetof(UOrionAbilityTask_StartTargeting, Confirmed) == 0x000080, "Member 'UOrionAbilityTask_StartTargeting::Confirmed' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_StartTargeting, Cancelled) == 0x000090, "Member 'UOrionAbilityTask_StartTargeting::Cancelled' has a wrong offset!");

// Class OrionGame.OrionAnimNotify_CameraShake
// 0x0010 (0x0048 - 0x0038)
class UOrionAnimNotify_CameraShake final : public UAnimNotify
{
public:
	TSubclassOf<class UCameraShake>               ShakeBP;                                           // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShakeScale;                                        // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraAnimPlaySpace                          ShakeSpace;                                        // 0x0044(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAnimNotify_CameraShake">();
	}
	static class UOrionAnimNotify_CameraShake* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAnimNotify_CameraShake>();
	}
};
static_assert(alignof(UOrionAnimNotify_CameraShake) == 0x000008, "Wrong alignment on UOrionAnimNotify_CameraShake");
static_assert(sizeof(UOrionAnimNotify_CameraShake) == 0x000048, "Wrong size on UOrionAnimNotify_CameraShake");
static_assert(offsetof(UOrionAnimNotify_CameraShake, ShakeBP) == 0x000038, "Member 'UOrionAnimNotify_CameraShake::ShakeBP' has a wrong offset!");
static_assert(offsetof(UOrionAnimNotify_CameraShake, ShakeScale) == 0x000040, "Member 'UOrionAnimNotify_CameraShake::ShakeScale' has a wrong offset!");
static_assert(offsetof(UOrionAnimNotify_CameraShake, ShakeSpace) == 0x000044, "Member 'UOrionAnimNotify_CameraShake::ShakeSpace' has a wrong offset!");

// Class OrionGame.OrionAbilityAITask_DoTargeting
// 0x0040 (0x0100 - 0x00C0)
class UOrionAbilityAITask_DoTargeting final : public UOrionAbilityTask_StartTargeting
{
public:
	uint8                                         Pad_C0[0x30];                                      // 0x00C0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrionAIBot*                            OwnerAIBot;                                        // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityAITask_DoTargeting">();
	}
	static class UOrionAbilityAITask_DoTargeting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbilityAITask_DoTargeting>();
	}
};
static_assert(alignof(UOrionAbilityAITask_DoTargeting) == 0x000008, "Wrong alignment on UOrionAbilityAITask_DoTargeting");
static_assert(sizeof(UOrionAbilityAITask_DoTargeting) == 0x000100, "Wrong size on UOrionAbilityAITask_DoTargeting");
static_assert(offsetof(UOrionAbilityAITask_DoTargeting, OwnerAIBot) == 0x0000F0, "Member 'UOrionAbilityAITask_DoTargeting::OwnerAIBot' has a wrong offset!");

// Class OrionGame.OrionTeamComposer
// 0x0010 (0x0048 - 0x0038)
class UOrionTeamComposer final : public UDeveloperSettings
{
public:
	TArray<struct FOrionTeamComp>                 TeamCompositions;                                  // 0x0038(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTeamComposer">();
	}
	static class UOrionTeamComposer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionTeamComposer>();
	}
};
static_assert(alignof(UOrionTeamComposer) == 0x000008, "Wrong alignment on UOrionTeamComposer");
static_assert(sizeof(UOrionTeamComposer) == 0x000048, "Wrong size on UOrionTeamComposer");
static_assert(offsetof(UOrionTeamComposer, TeamCompositions) == 0x000038, "Member 'UOrionTeamComposer::TeamCompositions' has a wrong offset!");

// Class OrionGame.OrionAbilityAITask_ExecuteGameplayAbility
// 0x00A0 (0x0110 - 0x0070)
class UOrionAbilityAITask_ExecuteGameplayAbility final : public UAITask
{
public:
	uint8                                         bWaitForAbilityEnd : 1;                            // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAbortAbilityOnTaskAbort : 1;                      // 0x0070(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bWaitIfAbilityOnCooldown : 1;                      // 0x0070(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bStompOverPreviousAbilities : 1;                   // 0x0070(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   Finished;                                          // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayAbility>           AbilityClassToActivate;                            // 0x0088(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  GameplayTagContainerOfAbilityTags;                 // 0x0090(0x0020)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B0[0x60];                                      // 0x00B0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOrionAbilityAITask_ExecuteGameplayAbility* AIExecuteAvailableGameplayAbility(class AAIController* AIController, bool bWaitForAbilityEnd_0);
	static class UOrionAbilityAITask_ExecuteGameplayAbility* AIExecuteGameplayAbilityByClass(class AAIController* AIController, TSubclassOf<class UOrionAbility> AbilityClass, bool bWaitForAbilityEnd_0);
	static class UOrionAbilityAITask_ExecuteGameplayAbility* AIExecuteGameplayAbilityByHandle(class AAIController* AIController, const struct FGameplayAbilitySpecHandle& Handle, bool bWaitForAbilityEnd_0);
	static class UOrionAbilityAITask_ExecuteGameplayAbility* AIExecuteGameplayAbilityByTag(class AAIController* AIController, const struct FGameplayTagContainer& InGameplayTagContainerOfAbilityTags, bool bWaitForAbilityEnd_0);

	void K2_SetUp(class AAIController* AIController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityAITask_ExecuteGameplayAbility">();
	}
	static class UOrionAbilityAITask_ExecuteGameplayAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbilityAITask_ExecuteGameplayAbility>();
	}
};
static_assert(alignof(UOrionAbilityAITask_ExecuteGameplayAbility) == 0x000008, "Wrong alignment on UOrionAbilityAITask_ExecuteGameplayAbility");
static_assert(sizeof(UOrionAbilityAITask_ExecuteGameplayAbility) == 0x000110, "Wrong size on UOrionAbilityAITask_ExecuteGameplayAbility");
static_assert(offsetof(UOrionAbilityAITask_ExecuteGameplayAbility, Finished) == 0x000078, "Member 'UOrionAbilityAITask_ExecuteGameplayAbility::Finished' has a wrong offset!");
static_assert(offsetof(UOrionAbilityAITask_ExecuteGameplayAbility, AbilityClassToActivate) == 0x000088, "Member 'UOrionAbilityAITask_ExecuteGameplayAbility::AbilityClassToActivate' has a wrong offset!");
static_assert(offsetof(UOrionAbilityAITask_ExecuteGameplayAbility, GameplayTagContainerOfAbilityTags) == 0x000090, "Member 'UOrionAbilityAITask_ExecuteGameplayAbility::GameplayTagContainerOfAbilityTags' has a wrong offset!");

// Class OrionGame.OrionAnimNotify_InstantFaceForward
// 0x0008 (0x0040 - 0x0038)
class UOrionAnimNotify_InstantFaceForward final : public UAnimNotify
{
public:
	float                                         AngleLimitMin;                                     // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleLimitMax;                                     // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAnimNotify_InstantFaceForward">();
	}
	static class UOrionAnimNotify_InstantFaceForward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAnimNotify_InstantFaceForward>();
	}
};
static_assert(alignof(UOrionAnimNotify_InstantFaceForward) == 0x000008, "Wrong alignment on UOrionAnimNotify_InstantFaceForward");
static_assert(sizeof(UOrionAnimNotify_InstantFaceForward) == 0x000040, "Wrong size on UOrionAnimNotify_InstantFaceForward");
static_assert(offsetof(UOrionAnimNotify_InstantFaceForward, AngleLimitMin) == 0x000038, "Member 'UOrionAnimNotify_InstantFaceForward::AngleLimitMin' has a wrong offset!");
static_assert(offsetof(UOrionAnimNotify_InstantFaceForward, AngleLimitMax) == 0x00003C, "Member 'UOrionAnimNotify_InstantFaceForward::AngleLimitMax' has a wrong offset!");

// Class OrionGame.OrionAbilitySet
// 0x0030 (0x0060 - 0x0030)
class UOrionAbilitySet final : public UDataAsset
{
public:
	TArray<struct FOrionAbilityBindInfo>          KeyBinding;                                        // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UGameplayEffect*>                PassiveGameplayEffects;                            // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGameplayEffect>>    PassiveGameplayEffectClasses;                      // 0x0050(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilitySet">();
	}
	static class UOrionAbilitySet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbilitySet>();
	}
};
static_assert(alignof(UOrionAbilitySet) == 0x000008, "Wrong alignment on UOrionAbilitySet");
static_assert(sizeof(UOrionAbilitySet) == 0x000060, "Wrong size on UOrionAbilitySet");
static_assert(offsetof(UOrionAbilitySet, KeyBinding) == 0x000030, "Member 'UOrionAbilitySet::KeyBinding' has a wrong offset!");
static_assert(offsetof(UOrionAbilitySet, PassiveGameplayEffects) == 0x000040, "Member 'UOrionAbilitySet::PassiveGameplayEffects' has a wrong offset!");
static_assert(offsetof(UOrionAbilitySet, PassiveGameplayEffectClasses) == 0x000050, "Member 'UOrionAbilitySet::PassiveGameplayEffectClasses' has a wrong offset!");

// Class OrionGame.OrionTestControllerBase
// 0x0020 (0x0050 - 0x0030)
class UOrionTestControllerBase : public UGauntletTestController
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTestControllerBase">();
	}
	static class UOrionTestControllerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionTestControllerBase>();
	}
};
static_assert(alignof(UOrionTestControllerBase) == 0x000008, "Wrong alignment on UOrionTestControllerBase");
static_assert(sizeof(UOrionTestControllerBase) == 0x000050, "Wrong size on UOrionTestControllerBase");

// Class OrionGame.OrionAbilitySystemComponent
// 0x0A20 (0x2190 - 0x1770)
class UOrionAbilitySystemComponent final : public UAbilitySystemComponent
{
public:
	uint8                                         Pad_1770[0x2C4];                                   // 0x1770(0x02C4)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        AuthoritativeAbilityGroupMask;                     // 0x1A34(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A38[0x88];                                    // 0x1A38(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionGoldXPGameplayCueBatch           PendingGoldXPBatchData;                            // 0x1AC0(0x0018)(NativeAccessSpecifierPublic)
	uint8                                         Pad_1AD8[0x79];                                    // 0x1AD8(0x0079)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         CooldownReductionCount;                            // 0x1B51(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B52[0x1AE];                                   // 0x1B52(0x01AE)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPassiveHudRuntimeState>        PassiveHUDAbilities;                               // 0x1D00(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPublic)
	class AOrionTargetingMode_Base*               ActiveTargetingMode;                               // 0x1D10(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AOrionTargetingMode_Base*               PassiveTargetingMode;                              // 0x1D18(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D20[0x10];                                    // 0x1D20(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         CachedTargets0;                                    // 0x1D30(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         CachedTargets1;                                    // 0x1D40(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         LostTargetsThisFrame;                              // 0x1D50(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         NewTargetsThisFrame;                               // 0x1D60(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D70[0x120];                                   // 0x1D70(0x0120)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FStackCountRefreshInfo>         ReplicatedStackCountRefreshTime;                   // 0x1E90(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FDynamicGrantedCooldownTags>    ReplicatedDynamicCooldownTags;                     // 0x1EA0(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	class UOrionHealthSet*                        HealthSetRef;                                      // 0x1EB0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOrionCombatSet*                        CombatSetRef;                                      // 0x1EB8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOrionMoveSet*                          MoveSetRef;                                        // 0x1EC0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOrionXPSet*                            XPSetRef;                                          // 0x1EC8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOrionVisionSet*                        VisionSetRef;                                      // 0x1ED0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOrionEnergySet*                        EnergySetRef;                                      // 0x1ED8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOrionObjectiveSet*                     ObjectiveSetRef;                                   // 0x1EE0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOrionRigSet*                           RigSetRef;                                         // 0x1EE8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOrionWellSet*                          WellSetRef;                                        // 0x1EF0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOrionJungleRefinerySet*                JungleRefinerySetRef;                              // 0x1EF8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F00[0x290];                                   // 0x1F00(0x0290)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FGameplayEffectSpecHandle BP_CopyGameplayEffectToSpecForReapply(const struct FActiveGameplayEffectHandle& GameplayEffectHandle);
	float BP_GetGameplayEffectDurationRemaining(const struct FActiveGameplayEffectHandle& GameplayEffectHandle);
	struct FActiveGameplayEffectHandle BP_ReapplyGameplayEffectSpecToSelf(struct FGameplayEffectSpecHandle& SpecHandle, float DurationRemaning);
	struct FActiveGameplayEffectHandle BP_ReapplyGameplayEffectSpecToTarget(struct FGameplayEffectSpecHandle& SpecHandle, class UAbilitySystemComponent* Target, float DurationRemaning);
	void ClientBatchedGoldXP(const struct FOrionGoldXPGameplayCueBatch& Data);
	void ClientNotifyPostAbilityLevelUp(const struct FGameplayAbilitySpecHandle& AbilitySpecHandle, int32 Level);
	void NetMulticast_OrionGameplayCueExecutedBatch(const struct FOrionGameplayCueBatch& Data);
	void OnRep_CooldownReductionCount();
	void OnRep_ReplicatedDynamicCooldownTags();
	void TrackActor(class AActor* ActorToTrack, const struct FGameplayAbilitySpecHandle& Handle, const int32 MaxTracked, const float RemovalTime);
	void TrackGroupedActor(class AActor* ActorToTrack, const struct FGameplayTag& GroupingTag, const int32 MaxTracked, const float RemovalTime);

	TArray<struct FActiveGameplayEffectHandle> BP_GetActiveGameplayEffects(const struct FGameplayEffectQuery& Query) const;
	bool DidActiveTargetsChange() const;
	int32 GetExternalAbilityLevel(const struct FGameplayTag& AbilityTag) const;
	bool IsActivelyTargetingAnyActor() const;
	TArray<struct FGameplayAbilitySpec> K2_GetActivatableAbilities() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilitySystemComponent">();
	}
	static class UOrionAbilitySystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbilitySystemComponent>();
	}
};
static_assert(alignof(UOrionAbilitySystemComponent) == 0x000010, "Wrong alignment on UOrionAbilitySystemComponent");
static_assert(sizeof(UOrionAbilitySystemComponent) == 0x002190, "Wrong size on UOrionAbilitySystemComponent");
static_assert(offsetof(UOrionAbilitySystemComponent, AuthoritativeAbilityGroupMask) == 0x001A34, "Member 'UOrionAbilitySystemComponent::AuthoritativeAbilityGroupMask' has a wrong offset!");
static_assert(offsetof(UOrionAbilitySystemComponent, PendingGoldXPBatchData) == 0x001AC0, "Member 'UOrionAbilitySystemComponent::PendingGoldXPBatchData' has a wrong offset!");
static_assert(offsetof(UOrionAbilitySystemComponent, CooldownReductionCount) == 0x001B51, "Member 'UOrionAbilitySystemComponent::CooldownReductionCount' has a wrong offset!");
static_assert(offsetof(UOrionAbilitySystemComponent, PassiveHUDAbilities) == 0x001D00, "Member 'UOrionAbilitySystemComponent::PassiveHUDAbilities' has a wrong offset!");
static_assert(offsetof(UOrionAbilitySystemComponent, ActiveTargetingMode) == 0x001D10, "Member 'UOrionAbilitySystemComponent::ActiveTargetingMode' has a wrong offset!");
static_assert(offsetof(UOrionAbilitySystemComponent, PassiveTargetingMode) == 0x001D18, "Member 'UOrionAbilitySystemComponent::PassiveTargetingMode' has a wrong offset!");
static_assert(offsetof(UOrionAbilitySystemComponent, CachedTargets0) == 0x001D30, "Member 'UOrionAbilitySystemComponent::CachedTargets0' has a wrong offset!");
static_assert(offsetof(UOrionAbilitySystemComponent, CachedTargets1) == 0x001D40, "Member 'UOrionAbilitySystemComponent::CachedTargets1' has a wrong offset!");
static_assert(offsetof(UOrionAbilitySystemComponent, LostTargetsThisFrame) == 0x001D50, "Member 'UOrionAbilitySystemComponent::LostTargetsThisFrame' has a wrong offset!");
static_assert(offsetof(UOrionAbilitySystemComponent, NewTargetsThisFrame) == 0x001D60, "Member 'UOrionAbilitySystemComponent::NewTargetsThisFrame' has a wrong offset!");
static_assert(offsetof(UOrionAbilitySystemComponent, ReplicatedStackCountRefreshTime) == 0x001E90, "Member 'UOrionAbilitySystemComponent::ReplicatedStackCountRefreshTime' has a wrong offset!");
static_assert(offsetof(UOrionAbilitySystemComponent, ReplicatedDynamicCooldownTags) == 0x001EA0, "Member 'UOrionAbilitySystemComponent::ReplicatedDynamicCooldownTags' has a wrong offset!");
static_assert(offsetof(UOrionAbilitySystemComponent, HealthSetRef) == 0x001EB0, "Member 'UOrionAbilitySystemComponent::HealthSetRef' has a wrong offset!");
static_assert(offsetof(UOrionAbilitySystemComponent, CombatSetRef) == 0x001EB8, "Member 'UOrionAbilitySystemComponent::CombatSetRef' has a wrong offset!");
static_assert(offsetof(UOrionAbilitySystemComponent, MoveSetRef) == 0x001EC0, "Member 'UOrionAbilitySystemComponent::MoveSetRef' has a wrong offset!");
static_assert(offsetof(UOrionAbilitySystemComponent, XPSetRef) == 0x001EC8, "Member 'UOrionAbilitySystemComponent::XPSetRef' has a wrong offset!");
static_assert(offsetof(UOrionAbilitySystemComponent, VisionSetRef) == 0x001ED0, "Member 'UOrionAbilitySystemComponent::VisionSetRef' has a wrong offset!");
static_assert(offsetof(UOrionAbilitySystemComponent, EnergySetRef) == 0x001ED8, "Member 'UOrionAbilitySystemComponent::EnergySetRef' has a wrong offset!");
static_assert(offsetof(UOrionAbilitySystemComponent, ObjectiveSetRef) == 0x001EE0, "Member 'UOrionAbilitySystemComponent::ObjectiveSetRef' has a wrong offset!");
static_assert(offsetof(UOrionAbilitySystemComponent, RigSetRef) == 0x001EE8, "Member 'UOrionAbilitySystemComponent::RigSetRef' has a wrong offset!");
static_assert(offsetof(UOrionAbilitySystemComponent, WellSetRef) == 0x001EF0, "Member 'UOrionAbilitySystemComponent::WellSetRef' has a wrong offset!");
static_assert(offsetof(UOrionAbilitySystemComponent, JungleRefinerySetRef) == 0x001EF8, "Member 'UOrionAbilitySystemComponent::JungleRefinerySetRef' has a wrong offset!");

// Class OrionGame.OrionAbilitySystemGlobals
// 0x0000 (0x0350 - 0x0350)
class UOrionAbilitySystemGlobals final : public UAbilitySystemGlobals
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilitySystemGlobals">();
	}
	static class UOrionAbilitySystemGlobals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbilitySystemGlobals>();
	}
};
static_assert(alignof(UOrionAbilitySystemGlobals) == 0x000008, "Wrong alignment on UOrionAbilitySystemGlobals");
static_assert(sizeof(UOrionAbilitySystemGlobals) == 0x000350, "Wrong size on UOrionAbilitySystemGlobals");

// Class OrionGame.OrionTestControllerDumpHitches
// 0x0008 (0x0058 - 0x0050)
class UOrionTestControllerDumpHitches final : public UOrionTestControllerBase
{
public:
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTestControllerDumpHitches">();
	}
	static class UOrionTestControllerDumpHitches* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionTestControllerDumpHitches>();
	}
};
static_assert(alignof(UOrionTestControllerDumpHitches) == 0x000008, "Wrong alignment on UOrionTestControllerDumpHitches");
static_assert(sizeof(UOrionTestControllerDumpHitches) == 0x000058, "Wrong size on UOrionTestControllerDumpHitches");

// Class OrionGame.OrionAbilityTargetActor_Beam
// 0x0070 (0x0550 - 0x04E0)
class AOrionAbilityTargetActor_Beam final : public AGameplayAbilityTargetActor
{
public:
	float                                         BeamLength;                                        // 0x04D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BeamBlockingRadius;                                // 0x04DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BeamOverlapRadius;                                 // 0x04E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4E4[0x4];                                      // 0x04E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCollisionProfileName                  BeamCollisionProfile;                              // 0x04E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	struct FGameplayEffectSpecHandle              BeamGameplayEffectSpec;                            // 0x04F0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	EOrionTickInterval                            BeamGameplayEffectTick;                            // 0x0508(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_509[0x7];                                      // 0x0509(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        BeamParticleSystem;                                // 0x0510(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        BeamBlockingParticleSystem;                        // 0x0518(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        BeamOverlapParticleSystem;                         // 0x0520(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FBeamHitResult>                 BeamHitList;                                       // 0x0528(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               BeamParticleComponent;                             // 0x0538(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystemComponent*               BlockingParticleComponent;                         // 0x0540(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_548[0x8];                                      // 0x0548(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityTargetActor_Beam">();
	}
	static class AOrionAbilityTargetActor_Beam* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionAbilityTargetActor_Beam>();
	}
};
static_assert(alignof(AOrionAbilityTargetActor_Beam) == 0x000010, "Wrong alignment on AOrionAbilityTargetActor_Beam");
static_assert(sizeof(AOrionAbilityTargetActor_Beam) == 0x000550, "Wrong size on AOrionAbilityTargetActor_Beam");
static_assert(offsetof(AOrionAbilityTargetActor_Beam, BeamLength) == 0x0004D8, "Member 'AOrionAbilityTargetActor_Beam::BeamLength' has a wrong offset!");
static_assert(offsetof(AOrionAbilityTargetActor_Beam, BeamBlockingRadius) == 0x0004DC, "Member 'AOrionAbilityTargetActor_Beam::BeamBlockingRadius' has a wrong offset!");
static_assert(offsetof(AOrionAbilityTargetActor_Beam, BeamOverlapRadius) == 0x0004E0, "Member 'AOrionAbilityTargetActor_Beam::BeamOverlapRadius' has a wrong offset!");
static_assert(offsetof(AOrionAbilityTargetActor_Beam, BeamCollisionProfile) == 0x0004E8, "Member 'AOrionAbilityTargetActor_Beam::BeamCollisionProfile' has a wrong offset!");
static_assert(offsetof(AOrionAbilityTargetActor_Beam, BeamGameplayEffectSpec) == 0x0004F0, "Member 'AOrionAbilityTargetActor_Beam::BeamGameplayEffectSpec' has a wrong offset!");
static_assert(offsetof(AOrionAbilityTargetActor_Beam, BeamGameplayEffectTick) == 0x000508, "Member 'AOrionAbilityTargetActor_Beam::BeamGameplayEffectTick' has a wrong offset!");
static_assert(offsetof(AOrionAbilityTargetActor_Beam, BeamParticleSystem) == 0x000510, "Member 'AOrionAbilityTargetActor_Beam::BeamParticleSystem' has a wrong offset!");
static_assert(offsetof(AOrionAbilityTargetActor_Beam, BeamBlockingParticleSystem) == 0x000518, "Member 'AOrionAbilityTargetActor_Beam::BeamBlockingParticleSystem' has a wrong offset!");
static_assert(offsetof(AOrionAbilityTargetActor_Beam, BeamOverlapParticleSystem) == 0x000520, "Member 'AOrionAbilityTargetActor_Beam::BeamOverlapParticleSystem' has a wrong offset!");
static_assert(offsetof(AOrionAbilityTargetActor_Beam, BeamHitList) == 0x000528, "Member 'AOrionAbilityTargetActor_Beam::BeamHitList' has a wrong offset!");
static_assert(offsetof(AOrionAbilityTargetActor_Beam, BeamParticleComponent) == 0x000538, "Member 'AOrionAbilityTargetActor_Beam::BeamParticleComponent' has a wrong offset!");
static_assert(offsetof(AOrionAbilityTargetActor_Beam, BlockingParticleComponent) == 0x000540, "Member 'AOrionAbilityTargetActor_Beam::BlockingParticleComponent' has a wrong offset!");

// Class OrionGame.OrionAnimNotifyState_MeleeComboWindow
// 0x0010 (0x0040 - 0x0030)
class UOrionAnimNotifyState_MeleeComboWindow final : public UAnimNotifyState
{
public:
	TArray<class FName>                           NextAttackNames;                                   // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAnimNotifyState_MeleeComboWindow">();
	}
	static class UOrionAnimNotifyState_MeleeComboWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAnimNotifyState_MeleeComboWindow>();
	}
};
static_assert(alignof(UOrionAnimNotifyState_MeleeComboWindow) == 0x000008, "Wrong alignment on UOrionAnimNotifyState_MeleeComboWindow");
static_assert(sizeof(UOrionAnimNotifyState_MeleeComboWindow) == 0x000040, "Wrong size on UOrionAnimNotifyState_MeleeComboWindow");
static_assert(offsetof(UOrionAnimNotifyState_MeleeComboWindow, NextAttackNames) == 0x000030, "Member 'UOrionAnimNotifyState_MeleeComboWindow::NextAttackNames' has a wrong offset!");

// Class OrionGame.OrionAbilityTargetActor_SelectMultipleTargets
// 0x0040 (0x0520 - 0x04E0)
class AOrionAbilityTargetActor_SelectMultipleTargets final : public AGameplayAbilityTargetActor
{
public:
	uint8                                         Pad_4D8[0x8];                                      // 0x04D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAddSelfToTargetData;                              // 0x04E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTeamCompare                             RelationshipTypeToAcquire;                         // 0x04E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTargetType                              TargetType;                                        // 0x04E2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E3[0x1];                                      // 0x04E3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxRangeToAcquire;                                 // 0x04E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRangeToRetain;                                  // 0x04E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngleToAcquire;                                 // 0x04EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F0[0x4];                                      // 0x04F0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxAngleToRetain;                                  // 0x04F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F8[0x4];                                      // 0x04F8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRequiresCameraLOSToAcquire;                       // 0x04FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiresCameraLOSToRetain;                        // 0x04FD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4FE[0x22];                                     // 0x04FE(0x0022)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityTargetActor_SelectMultipleTargets">();
	}
	static class AOrionAbilityTargetActor_SelectMultipleTargets* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionAbilityTargetActor_SelectMultipleTargets>();
	}
};
static_assert(alignof(AOrionAbilityTargetActor_SelectMultipleTargets) == 0x000010, "Wrong alignment on AOrionAbilityTargetActor_SelectMultipleTargets");
static_assert(sizeof(AOrionAbilityTargetActor_SelectMultipleTargets) == 0x000520, "Wrong size on AOrionAbilityTargetActor_SelectMultipleTargets");
static_assert(offsetof(AOrionAbilityTargetActor_SelectMultipleTargets, bAddSelfToTargetData) == 0x0004E0, "Member 'AOrionAbilityTargetActor_SelectMultipleTargets::bAddSelfToTargetData' has a wrong offset!");
static_assert(offsetof(AOrionAbilityTargetActor_SelectMultipleTargets, RelationshipTypeToAcquire) == 0x0004E1, "Member 'AOrionAbilityTargetActor_SelectMultipleTargets::RelationshipTypeToAcquire' has a wrong offset!");
static_assert(offsetof(AOrionAbilityTargetActor_SelectMultipleTargets, TargetType) == 0x0004E2, "Member 'AOrionAbilityTargetActor_SelectMultipleTargets::TargetType' has a wrong offset!");
static_assert(offsetof(AOrionAbilityTargetActor_SelectMultipleTargets, MaxRangeToAcquire) == 0x0004E4, "Member 'AOrionAbilityTargetActor_SelectMultipleTargets::MaxRangeToAcquire' has a wrong offset!");
static_assert(offsetof(AOrionAbilityTargetActor_SelectMultipleTargets, MaxRangeToRetain) == 0x0004E8, "Member 'AOrionAbilityTargetActor_SelectMultipleTargets::MaxRangeToRetain' has a wrong offset!");
static_assert(offsetof(AOrionAbilityTargetActor_SelectMultipleTargets, MaxAngleToAcquire) == 0x0004EC, "Member 'AOrionAbilityTargetActor_SelectMultipleTargets::MaxAngleToAcquire' has a wrong offset!");
static_assert(offsetof(AOrionAbilityTargetActor_SelectMultipleTargets, MaxAngleToRetain) == 0x0004F4, "Member 'AOrionAbilityTargetActor_SelectMultipleTargets::MaxAngleToRetain' has a wrong offset!");
static_assert(offsetof(AOrionAbilityTargetActor_SelectMultipleTargets, bRequiresCameraLOSToAcquire) == 0x0004FC, "Member 'AOrionAbilityTargetActor_SelectMultipleTargets::bRequiresCameraLOSToAcquire' has a wrong offset!");
static_assert(offsetof(AOrionAbilityTargetActor_SelectMultipleTargets, bRequiresCameraLOSToRetain) == 0x0004FD, "Member 'AOrionAbilityTargetActor_SelectMultipleTargets::bRequiresCameraLOSToRetain' has a wrong offset!");

// Class OrionGame.OrionAbilityTargetActor_SelectSingleTarget
// 0x0030 (0x0510 - 0x04E0)
class AOrionAbilityTargetActor_SelectSingleTarget final : public AGameplayAbilityTargetActor
{
public:
	uint8                                         Pad_4D8[0x8];                                      // 0x04D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EOrionTeamCompare                             RelationshipTypeToAcquire;                         // 0x04E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTargetType                              TargetType;                                        // 0x04E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E2[0x2];                                      // 0x04E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxRangeToAcquire;                                 // 0x04E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRangeToRetain;                                  // 0x04E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngleToAcquire;                                 // 0x04EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F0[0x4];                                      // 0x04F0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxAngleToRetain;                                  // 0x04F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F8[0x4];                                      // 0x04F8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRequiresCameraLOSToAcquire;                       // 0x04FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiresCameraLOSToRetain;                        // 0x04FD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4FE[0x12];                                     // 0x04FE(0x0012)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityTargetActor_SelectSingleTarget">();
	}
	static class AOrionAbilityTargetActor_SelectSingleTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionAbilityTargetActor_SelectSingleTarget>();
	}
};
static_assert(alignof(AOrionAbilityTargetActor_SelectSingleTarget) == 0x000010, "Wrong alignment on AOrionAbilityTargetActor_SelectSingleTarget");
static_assert(sizeof(AOrionAbilityTargetActor_SelectSingleTarget) == 0x000510, "Wrong size on AOrionAbilityTargetActor_SelectSingleTarget");
static_assert(offsetof(AOrionAbilityTargetActor_SelectSingleTarget, RelationshipTypeToAcquire) == 0x0004E0, "Member 'AOrionAbilityTargetActor_SelectSingleTarget::RelationshipTypeToAcquire' has a wrong offset!");
static_assert(offsetof(AOrionAbilityTargetActor_SelectSingleTarget, TargetType) == 0x0004E1, "Member 'AOrionAbilityTargetActor_SelectSingleTarget::TargetType' has a wrong offset!");
static_assert(offsetof(AOrionAbilityTargetActor_SelectSingleTarget, MaxRangeToAcquire) == 0x0004E4, "Member 'AOrionAbilityTargetActor_SelectSingleTarget::MaxRangeToAcquire' has a wrong offset!");
static_assert(offsetof(AOrionAbilityTargetActor_SelectSingleTarget, MaxRangeToRetain) == 0x0004E8, "Member 'AOrionAbilityTargetActor_SelectSingleTarget::MaxRangeToRetain' has a wrong offset!");
static_assert(offsetof(AOrionAbilityTargetActor_SelectSingleTarget, MaxAngleToAcquire) == 0x0004EC, "Member 'AOrionAbilityTargetActor_SelectSingleTarget::MaxAngleToAcquire' has a wrong offset!");
static_assert(offsetof(AOrionAbilityTargetActor_SelectSingleTarget, MaxAngleToRetain) == 0x0004F4, "Member 'AOrionAbilityTargetActor_SelectSingleTarget::MaxAngleToRetain' has a wrong offset!");
static_assert(offsetof(AOrionAbilityTargetActor_SelectSingleTarget, bRequiresCameraLOSToAcquire) == 0x0004FC, "Member 'AOrionAbilityTargetActor_SelectSingleTarget::bRequiresCameraLOSToAcquire' has a wrong offset!");
static_assert(offsetof(AOrionAbilityTargetActor_SelectSingleTarget, bRequiresCameraLOSToRetain) == 0x0004FD, "Member 'AOrionAbilityTargetActor_SelectSingleTarget::bRequiresCameraLOSToRetain' has a wrong offset!");

// Class OrionGame.OrionArcBladeAnimInstance
// 0x0040 (0x07B0 - 0x0770)
class UOrionArcBladeAnimInstance final : public UOrionBaseHeroAnimInstance
{
public:
	TArray<class UAnimMontage*>                   AttackMontages;                                    // 0x0770(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ShieldMontage;                                     // 0x0780(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChainAlpha;                                        // 0x0788(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BladeState;                                        // 0x078C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsArcBladeAttacking;                              // 0x0790(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBlocking;                                       // 0x0791(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPrimaryAttackActive;                            // 0x0792(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInBladeState0;                                  // 0x0793(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInBladeState1;                                  // 0x0794(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInBladeState2;                                  // 0x0795(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInBladeState3;                                  // 0x0796(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOnGroundInTravelMode;                           // 0x0797(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RHandIKAlpha;                                      // 0x0798(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RHandIKTravelModeAlpha;                            // 0x079C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CopyWeaponBoneAlpha;                               // 0x07A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A4[0xC];                                      // 0x07A4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnterBladeState00();
	void EnterBladeState01();
	void EnterBladeState02();
	void EnterBladeState03();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionArcBladeAnimInstance">();
	}
	static class UOrionArcBladeAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionArcBladeAnimInstance>();
	}
};
static_assert(alignof(UOrionArcBladeAnimInstance) == 0x000008, "Wrong alignment on UOrionArcBladeAnimInstance");
static_assert(sizeof(UOrionArcBladeAnimInstance) == 0x0007B0, "Wrong size on UOrionArcBladeAnimInstance");
static_assert(offsetof(UOrionArcBladeAnimInstance, AttackMontages) == 0x000770, "Member 'UOrionArcBladeAnimInstance::AttackMontages' has a wrong offset!");
static_assert(offsetof(UOrionArcBladeAnimInstance, ShieldMontage) == 0x000780, "Member 'UOrionArcBladeAnimInstance::ShieldMontage' has a wrong offset!");
static_assert(offsetof(UOrionArcBladeAnimInstance, ChainAlpha) == 0x000788, "Member 'UOrionArcBladeAnimInstance::ChainAlpha' has a wrong offset!");
static_assert(offsetof(UOrionArcBladeAnimInstance, BladeState) == 0x00078C, "Member 'UOrionArcBladeAnimInstance::BladeState' has a wrong offset!");
static_assert(offsetof(UOrionArcBladeAnimInstance, bIsArcBladeAttacking) == 0x000790, "Member 'UOrionArcBladeAnimInstance::bIsArcBladeAttacking' has a wrong offset!");
static_assert(offsetof(UOrionArcBladeAnimInstance, bIsBlocking) == 0x000791, "Member 'UOrionArcBladeAnimInstance::bIsBlocking' has a wrong offset!");
static_assert(offsetof(UOrionArcBladeAnimInstance, bIsPrimaryAttackActive) == 0x000792, "Member 'UOrionArcBladeAnimInstance::bIsPrimaryAttackActive' has a wrong offset!");
static_assert(offsetof(UOrionArcBladeAnimInstance, bIsInBladeState0) == 0x000793, "Member 'UOrionArcBladeAnimInstance::bIsInBladeState0' has a wrong offset!");
static_assert(offsetof(UOrionArcBladeAnimInstance, bIsInBladeState1) == 0x000794, "Member 'UOrionArcBladeAnimInstance::bIsInBladeState1' has a wrong offset!");
static_assert(offsetof(UOrionArcBladeAnimInstance, bIsInBladeState2) == 0x000795, "Member 'UOrionArcBladeAnimInstance::bIsInBladeState2' has a wrong offset!");
static_assert(offsetof(UOrionArcBladeAnimInstance, bIsInBladeState3) == 0x000796, "Member 'UOrionArcBladeAnimInstance::bIsInBladeState3' has a wrong offset!");
static_assert(offsetof(UOrionArcBladeAnimInstance, bIsOnGroundInTravelMode) == 0x000797, "Member 'UOrionArcBladeAnimInstance::bIsOnGroundInTravelMode' has a wrong offset!");
static_assert(offsetof(UOrionArcBladeAnimInstance, RHandIKAlpha) == 0x000798, "Member 'UOrionArcBladeAnimInstance::RHandIKAlpha' has a wrong offset!");
static_assert(offsetof(UOrionArcBladeAnimInstance, RHandIKTravelModeAlpha) == 0x00079C, "Member 'UOrionArcBladeAnimInstance::RHandIKTravelModeAlpha' has a wrong offset!");
static_assert(offsetof(UOrionArcBladeAnimInstance, CopyWeaponBoneAlpha) == 0x0007A0, "Member 'UOrionArcBladeAnimInstance::CopyWeaponBoneAlpha' has a wrong offset!");

// Class OrionGame.OrionAbilityTargetActor_SelectTargets
// 0x0040 (0x0520 - 0x04E0)
class AOrionAbilityTargetActor_SelectTargets final : public AGameplayAbilityTargetActor
{
public:
	uint8                                         Pad_4D8[0x8];                                      // 0x04D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EOrionTeamCompare                             RelationshipTypeToAcquire;                         // 0x04E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionTargetType                              TargetType;                                        // 0x04E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E2[0x2];                                      // 0x04E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxRangeToAcquire;                                 // 0x04E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRangeToRetain;                                  // 0x04E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngleToAcquire;                                 // 0x04EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F0[0x4];                                      // 0x04F0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxAngleToRetain;                                  // 0x04F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F8[0x4];                                      // 0x04F8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRequiresCameraLOSToAcquire;                       // 0x04FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiresCameraLOSToRetain;                        // 0x04FD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddSelf;                                          // 0x04FE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPrioritizePreexistingTargets;                     // 0x04FF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxResultCount;                                    // 0x0500(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_504[0x1C];                                     // 0x0504(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityTargetActor_SelectTargets">();
	}
	static class AOrionAbilityTargetActor_SelectTargets* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionAbilityTargetActor_SelectTargets>();
	}
};
static_assert(alignof(AOrionAbilityTargetActor_SelectTargets) == 0x000010, "Wrong alignment on AOrionAbilityTargetActor_SelectTargets");
static_assert(sizeof(AOrionAbilityTargetActor_SelectTargets) == 0x000520, "Wrong size on AOrionAbilityTargetActor_SelectTargets");
static_assert(offsetof(AOrionAbilityTargetActor_SelectTargets, RelationshipTypeToAcquire) == 0x0004E0, "Member 'AOrionAbilityTargetActor_SelectTargets::RelationshipTypeToAcquire' has a wrong offset!");
static_assert(offsetof(AOrionAbilityTargetActor_SelectTargets, TargetType) == 0x0004E1, "Member 'AOrionAbilityTargetActor_SelectTargets::TargetType' has a wrong offset!");
static_assert(offsetof(AOrionAbilityTargetActor_SelectTargets, MaxRangeToAcquire) == 0x0004E4, "Member 'AOrionAbilityTargetActor_SelectTargets::MaxRangeToAcquire' has a wrong offset!");
static_assert(offsetof(AOrionAbilityTargetActor_SelectTargets, MaxRangeToRetain) == 0x0004E8, "Member 'AOrionAbilityTargetActor_SelectTargets::MaxRangeToRetain' has a wrong offset!");
static_assert(offsetof(AOrionAbilityTargetActor_SelectTargets, MaxAngleToAcquire) == 0x0004EC, "Member 'AOrionAbilityTargetActor_SelectTargets::MaxAngleToAcquire' has a wrong offset!");
static_assert(offsetof(AOrionAbilityTargetActor_SelectTargets, MaxAngleToRetain) == 0x0004F4, "Member 'AOrionAbilityTargetActor_SelectTargets::MaxAngleToRetain' has a wrong offset!");
static_assert(offsetof(AOrionAbilityTargetActor_SelectTargets, bRequiresCameraLOSToAcquire) == 0x0004FC, "Member 'AOrionAbilityTargetActor_SelectTargets::bRequiresCameraLOSToAcquire' has a wrong offset!");
static_assert(offsetof(AOrionAbilityTargetActor_SelectTargets, bRequiresCameraLOSToRetain) == 0x0004FD, "Member 'AOrionAbilityTargetActor_SelectTargets::bRequiresCameraLOSToRetain' has a wrong offset!");
static_assert(offsetof(AOrionAbilityTargetActor_SelectTargets, bAddSelf) == 0x0004FE, "Member 'AOrionAbilityTargetActor_SelectTargets::bAddSelf' has a wrong offset!");
static_assert(offsetof(AOrionAbilityTargetActor_SelectTargets, bPrioritizePreexistingTargets) == 0x0004FF, "Member 'AOrionAbilityTargetActor_SelectTargets::bPrioritizePreexistingTargets' has a wrong offset!");
static_assert(offsetof(AOrionAbilityTargetActor_SelectTargets, MaxResultCount) == 0x000500, "Member 'AOrionAbilityTargetActor_SelectTargets::MaxResultCount' has a wrong offset!");

// Class OrionGame.OrionTestControllerSoakTest
// 0x0048 (0x0098 - 0x0050)
class UOrionTestControllerSoakTest : public UOrionTestControllerBase
{
public:
	uint8                                         Pad_50[0x48];                                      // 0x0050(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTestControllerSoakTest">();
	}
	static class UOrionTestControllerSoakTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionTestControllerSoakTest>();
	}
};
static_assert(alignof(UOrionTestControllerSoakTest) == 0x000008, "Wrong alignment on UOrionTestControllerSoakTest");
static_assert(sizeof(UOrionTestControllerSoakTest) == 0x000098, "Wrong size on UOrionTestControllerSoakTest");

// Class OrionGame.OrionTestControllerSoloAllHeroes
// 0x0008 (0x00A0 - 0x0098)
class UOrionTestControllerSoloAllHeroes final : public UOrionTestControllerSoakTest
{
public:
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTestControllerSoloAllHeroes">();
	}
	static class UOrionTestControllerSoloAllHeroes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionTestControllerSoloAllHeroes>();
	}
};
static_assert(alignof(UOrionTestControllerSoloAllHeroes) == 0x000008, "Wrong alignment on UOrionTestControllerSoloAllHeroes");
static_assert(sizeof(UOrionTestControllerSoloAllHeroes) == 0x0000A0, "Wrong size on UOrionTestControllerSoloAllHeroes");

// Class OrionGame.OrionAbilityTargetActor_WellSelector
// 0x0000 (0x04E0 - 0x04E0)
class AOrionAbilityTargetActor_WellSelector final : public AGameplayAbilityTargetActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityTargetActor_WellSelector">();
	}
	static class AOrionAbilityTargetActor_WellSelector* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionAbilityTargetActor_WellSelector>();
	}
};
static_assert(alignof(AOrionAbilityTargetActor_WellSelector) == 0x000010, "Wrong alignment on AOrionAbilityTargetActor_WellSelector");
static_assert(sizeof(AOrionAbilityTargetActor_WellSelector) == 0x0004E0, "Wrong size on AOrionAbilityTargetActor_WellSelector");

// Class OrionGame.OrionAnimNotifyState_TrailEffectTeamAdjusted
// 0x0028 (0x0088 - 0x0060)
class UOrionAnimNotifyState_TrailEffectTeamAdjusted final : public UAnimNotifyState_Trail
{
public:
	TArray<struct FTagAdjustedTrailInfo>          TagOverrides;                                      // 0x0060(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UParticleSystem*                        P_OverrideEnemy;                                   // 0x0070(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        P_OverrideFriendly;                                // 0x0078(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        OriginalPSTemplate;                                // 0x0080(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAnimNotifyState_TrailEffectTeamAdjusted">();
	}
	static class UOrionAnimNotifyState_TrailEffectTeamAdjusted* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAnimNotifyState_TrailEffectTeamAdjusted>();
	}
};
static_assert(alignof(UOrionAnimNotifyState_TrailEffectTeamAdjusted) == 0x000008, "Wrong alignment on UOrionAnimNotifyState_TrailEffectTeamAdjusted");
static_assert(sizeof(UOrionAnimNotifyState_TrailEffectTeamAdjusted) == 0x000088, "Wrong size on UOrionAnimNotifyState_TrailEffectTeamAdjusted");
static_assert(offsetof(UOrionAnimNotifyState_TrailEffectTeamAdjusted, TagOverrides) == 0x000060, "Member 'UOrionAnimNotifyState_TrailEffectTeamAdjusted::TagOverrides' has a wrong offset!");
static_assert(offsetof(UOrionAnimNotifyState_TrailEffectTeamAdjusted, P_OverrideEnemy) == 0x000070, "Member 'UOrionAnimNotifyState_TrailEffectTeamAdjusted::P_OverrideEnemy' has a wrong offset!");
static_assert(offsetof(UOrionAnimNotifyState_TrailEffectTeamAdjusted, P_OverrideFriendly) == 0x000078, "Member 'UOrionAnimNotifyState_TrailEffectTeamAdjusted::P_OverrideFriendly' has a wrong offset!");
static_assert(offsetof(UOrionAnimNotifyState_TrailEffectTeamAdjusted, OriginalPSTemplate) == 0x000080, "Member 'UOrionAnimNotifyState_TrailEffectTeamAdjusted::OriginalPSTemplate' has a wrong offset!");

// Class OrionGame.OrionAbilityTask_AddPlayerScoreListener
// 0x0140 (0x01C0 - 0x0080)
class UOrionAbilityTask_AddPlayerScoreListener final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   OnPlayerAssist;                                    // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPlayerKill;                                      // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMinionAssist;                                    // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMinionKill;                                      // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x100];                                     // 0x00C0(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOrionAbilityTask_AddPlayerScoreListener* CreateAddPlayerScoreListenerTask(class UGameplayAbility* OwningAbility, class FName ListenerName, const struct FOrionActorFilter& TargetFilter, const struct FGameplayTagRequirements& SourceTagRequirements, const struct FGameplayTagRequirements& TargetTagRequirements);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityTask_AddPlayerScoreListener">();
	}
	static class UOrionAbilityTask_AddPlayerScoreListener* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbilityTask_AddPlayerScoreListener>();
	}
};
static_assert(alignof(UOrionAbilityTask_AddPlayerScoreListener) == 0x000008, "Wrong alignment on UOrionAbilityTask_AddPlayerScoreListener");
static_assert(sizeof(UOrionAbilityTask_AddPlayerScoreListener) == 0x0001C0, "Wrong size on UOrionAbilityTask_AddPlayerScoreListener");
static_assert(offsetof(UOrionAbilityTask_AddPlayerScoreListener, OnPlayerAssist) == 0x000080, "Member 'UOrionAbilityTask_AddPlayerScoreListener::OnPlayerAssist' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_AddPlayerScoreListener, OnPlayerKill) == 0x000090, "Member 'UOrionAbilityTask_AddPlayerScoreListener::OnPlayerKill' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_AddPlayerScoreListener, OnMinionAssist) == 0x0000A0, "Member 'UOrionAbilityTask_AddPlayerScoreListener::OnMinionAssist' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_AddPlayerScoreListener, OnMinionKill) == 0x0000B0, "Member 'UOrionAbilityTask_AddPlayerScoreListener::OnMinionKill' has a wrong offset!");

// Class OrionGame.OrionAbilityTask_DirectedMovement
// 0x0060 (0x00E0 - 0x0080)
class UOrionAbilityTask_DirectedMovement final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   OnMovementComplete;                                // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x1C];                                      // 0x0090(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetLocation;                                    // 0x00AC(0x000C)(Net, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        TargetComponent;                                   // 0x00B8(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementDistance;                                  // 0x00C0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IdealArrivalDistance;                              // 0x00C4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DurationOfMovement;                                // 0x00C8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bModifyZ;                                          // 0x00CC(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterMovementComponent*            MovementComponent;                                 // 0x00D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOrionAbilityTask_DirectedMovement* DirectedMovement(class UGameplayAbility* OwningAbility, const struct FVector& MovementDirection, EOrionDirectedMovementSpace MovementSpaceType, float MovementDistance_0, float MovementDuration, float IdealDistance, bool ModifyZ);
	static class UOrionAbilityTask_DirectedMovement* DirectedMovementToActor(class UGameplayAbility* OwningAbility, class AActor* TargetActor, float MaxMovementDistance, float MovementDuration, float IdealDistance, bool ModifyZ);
	static class UOrionAbilityTask_DirectedMovement* DirectedMovementToComponent(class UGameplayAbility* OwningAbility, class USceneComponent* TargetComponent_0, float MaxMovementDistance, float MovementDuration, float IdealDistance, bool ModifyZ);
	static class UOrionAbilityTask_DirectedMovement* DirectedMovementToLocation(class UGameplayAbility* OwningAbility, const struct FVector& MovementTargetLocation, EOrionDirectedMovementSpace MovementSpaceType, float MovementDuration, float CloseEnoughDistance, bool ModifyZ);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityTask_DirectedMovement">();
	}
	static class UOrionAbilityTask_DirectedMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbilityTask_DirectedMovement>();
	}
};
static_assert(alignof(UOrionAbilityTask_DirectedMovement) == 0x000008, "Wrong alignment on UOrionAbilityTask_DirectedMovement");
static_assert(sizeof(UOrionAbilityTask_DirectedMovement) == 0x0000E0, "Wrong size on UOrionAbilityTask_DirectedMovement");
static_assert(offsetof(UOrionAbilityTask_DirectedMovement, OnMovementComplete) == 0x000080, "Member 'UOrionAbilityTask_DirectedMovement::OnMovementComplete' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_DirectedMovement, TargetLocation) == 0x0000AC, "Member 'UOrionAbilityTask_DirectedMovement::TargetLocation' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_DirectedMovement, TargetComponent) == 0x0000B8, "Member 'UOrionAbilityTask_DirectedMovement::TargetComponent' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_DirectedMovement, MovementDistance) == 0x0000C0, "Member 'UOrionAbilityTask_DirectedMovement::MovementDistance' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_DirectedMovement, IdealArrivalDistance) == 0x0000C4, "Member 'UOrionAbilityTask_DirectedMovement::IdealArrivalDistance' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_DirectedMovement, DurationOfMovement) == 0x0000C8, "Member 'UOrionAbilityTask_DirectedMovement::DurationOfMovement' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_DirectedMovement, bModifyZ) == 0x0000CC, "Member 'UOrionAbilityTask_DirectedMovement::bModifyZ' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_DirectedMovement, MovementComponent) == 0x0000D0, "Member 'UOrionAbilityTask_DirectedMovement::MovementComponent' has a wrong offset!");

// Class OrionGame.OrionRigSet
// 0x0058 (0x0088 - 0x0030)
class UOrionRigSet final : public UOrionAttributeSet
{
public:
	float                                         DeployTime;                                        // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GatherRate;                                        // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GatherAmount;                                      // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoostedGatherRate;                                 // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BuildingXPRewardScalar;                            // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GatherXPRewardScalar;                              // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerCollectionRate;                              // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerCollectionAmount;                            // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentResourceAmount;                             // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCollectedResources;                             // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtraResourceAmount;                               // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResourceToSpawnACoin;                              // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StoreResourceScalar;                               // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DripResourceScalar;                                // 0x0064(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OnHitResourceStealScalar;                          // 0x0068(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResourceLeachScalar;                               // 0x006C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResourceLeachXPScalar;                             // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            GatherResourceEffect;                              // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGameplayEffect>            GatherOverFlowResourceEffect;                      // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionRigSet">();
	}
	static class UOrionRigSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionRigSet>();
	}
};
static_assert(alignof(UOrionRigSet) == 0x000008, "Wrong alignment on UOrionRigSet");
static_assert(sizeof(UOrionRigSet) == 0x000088, "Wrong size on UOrionRigSet");
static_assert(offsetof(UOrionRigSet, DeployTime) == 0x000030, "Member 'UOrionRigSet::DeployTime' has a wrong offset!");
static_assert(offsetof(UOrionRigSet, GatherRate) == 0x000034, "Member 'UOrionRigSet::GatherRate' has a wrong offset!");
static_assert(offsetof(UOrionRigSet, GatherAmount) == 0x000038, "Member 'UOrionRigSet::GatherAmount' has a wrong offset!");
static_assert(offsetof(UOrionRigSet, BoostedGatherRate) == 0x00003C, "Member 'UOrionRigSet::BoostedGatherRate' has a wrong offset!");
static_assert(offsetof(UOrionRigSet, BuildingXPRewardScalar) == 0x000040, "Member 'UOrionRigSet::BuildingXPRewardScalar' has a wrong offset!");
static_assert(offsetof(UOrionRigSet, GatherXPRewardScalar) == 0x000044, "Member 'UOrionRigSet::GatherXPRewardScalar' has a wrong offset!");
static_assert(offsetof(UOrionRigSet, PlayerCollectionRate) == 0x000048, "Member 'UOrionRigSet::PlayerCollectionRate' has a wrong offset!");
static_assert(offsetof(UOrionRigSet, PlayerCollectionAmount) == 0x00004C, "Member 'UOrionRigSet::PlayerCollectionAmount' has a wrong offset!");
static_assert(offsetof(UOrionRigSet, CurrentResourceAmount) == 0x000050, "Member 'UOrionRigSet::CurrentResourceAmount' has a wrong offset!");
static_assert(offsetof(UOrionRigSet, MaxCollectedResources) == 0x000054, "Member 'UOrionRigSet::MaxCollectedResources' has a wrong offset!");
static_assert(offsetof(UOrionRigSet, ExtraResourceAmount) == 0x000058, "Member 'UOrionRigSet::ExtraResourceAmount' has a wrong offset!");
static_assert(offsetof(UOrionRigSet, ResourceToSpawnACoin) == 0x00005C, "Member 'UOrionRigSet::ResourceToSpawnACoin' has a wrong offset!");
static_assert(offsetof(UOrionRigSet, StoreResourceScalar) == 0x000060, "Member 'UOrionRigSet::StoreResourceScalar' has a wrong offset!");
static_assert(offsetof(UOrionRigSet, DripResourceScalar) == 0x000064, "Member 'UOrionRigSet::DripResourceScalar' has a wrong offset!");
static_assert(offsetof(UOrionRigSet, OnHitResourceStealScalar) == 0x000068, "Member 'UOrionRigSet::OnHitResourceStealScalar' has a wrong offset!");
static_assert(offsetof(UOrionRigSet, ResourceLeachScalar) == 0x00006C, "Member 'UOrionRigSet::ResourceLeachScalar' has a wrong offset!");
static_assert(offsetof(UOrionRigSet, ResourceLeachXPScalar) == 0x000070, "Member 'UOrionRigSet::ResourceLeachXPScalar' has a wrong offset!");
static_assert(offsetof(UOrionRigSet, GatherResourceEffect) == 0x000078, "Member 'UOrionRigSet::GatherResourceEffect' has a wrong offset!");
static_assert(offsetof(UOrionRigSet, GatherOverFlowResourceEffect) == 0x000080, "Member 'UOrionRigSet::GatherOverFlowResourceEffect' has a wrong offset!");

// Class OrionGame.OrionAbilityTask_InstantTargetData
// 0x0030 (0x00F0 - 0x00C0)
class UOrionAbilityTask_InstantTargetData final : public UAbilityTask_WaitTargetData
{
public:
	UMulticastDelegateProperty_                   OnTargetData;                                      // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x20];                                      // 0x00D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOrionAbilityTask_InstantTargetData* HitScanTube(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetingLocationInfo& StartLocation, float Range, float BlockingRadius, float OverlapRadius, const struct FCollisionProfileName& CollisionProfile, const struct FGameplayTargetDataFilterHandle& Filter, bool bMultiHit, bool bDebug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityTask_InstantTargetData">();
	}
	static class UOrionAbilityTask_InstantTargetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbilityTask_InstantTargetData>();
	}
};
static_assert(alignof(UOrionAbilityTask_InstantTargetData) == 0x000008, "Wrong alignment on UOrionAbilityTask_InstantTargetData");
static_assert(sizeof(UOrionAbilityTask_InstantTargetData) == 0x0000F0, "Wrong size on UOrionAbilityTask_InstantTargetData");
static_assert(offsetof(UOrionAbilityTask_InstantTargetData, OnTargetData) == 0x0000C0, "Member 'UOrionAbilityTask_InstantTargetData::OnTargetData' has a wrong offset!");

// Class OrionGame.OrionAbilityTask_PlayMontageAndWaitNotifyName
// 0x0110 (0x0190 - 0x0080)
class UOrionAbilityTask_PlayMontageAndWaitNotifyName final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   OnCompleted;                                       // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnBlendOut;                                        // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnInterrupted;                                     // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnCancelled;                                       // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnNotifyBegin;                                     // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnNotifyEnd;                                       // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0xB0];                                      // 0x00E0(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOrionAbilityTask_PlayMontageAndWaitNotifyName* CreatePlayMontageAndWaitProxy(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class UAnimMontage* MontageToPlay, float Rate, class FName StartSection, bool bStopWhenAbilityEnds);
	static class UOrionAbilityTask_PlayMontageAndWaitNotifyName* PlayMontageAndWaitNotifyName(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class UAnimMontage* MontageToPlay, float Rate, class FName StartSection, bool bStopWhenAbilityEnds);

	void OnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted);
	void OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted);
	void OnMontageInterrupted();
	void OnNotifyBeginReceived(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload);
	void OnNotifyEndReceived(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityTask_PlayMontageAndWaitNotifyName">();
	}
	static class UOrionAbilityTask_PlayMontageAndWaitNotifyName* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbilityTask_PlayMontageAndWaitNotifyName>();
	}
};
static_assert(alignof(UOrionAbilityTask_PlayMontageAndWaitNotifyName) == 0x000008, "Wrong alignment on UOrionAbilityTask_PlayMontageAndWaitNotifyName");
static_assert(sizeof(UOrionAbilityTask_PlayMontageAndWaitNotifyName) == 0x000190, "Wrong size on UOrionAbilityTask_PlayMontageAndWaitNotifyName");
static_assert(offsetof(UOrionAbilityTask_PlayMontageAndWaitNotifyName, OnCompleted) == 0x000080, "Member 'UOrionAbilityTask_PlayMontageAndWaitNotifyName::OnCompleted' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_PlayMontageAndWaitNotifyName, OnBlendOut) == 0x000090, "Member 'UOrionAbilityTask_PlayMontageAndWaitNotifyName::OnBlendOut' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_PlayMontageAndWaitNotifyName, OnInterrupted) == 0x0000A0, "Member 'UOrionAbilityTask_PlayMontageAndWaitNotifyName::OnInterrupted' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_PlayMontageAndWaitNotifyName, OnCancelled) == 0x0000B0, "Member 'UOrionAbilityTask_PlayMontageAndWaitNotifyName::OnCancelled' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_PlayMontageAndWaitNotifyName, OnNotifyBegin) == 0x0000C0, "Member 'UOrionAbilityTask_PlayMontageAndWaitNotifyName::OnNotifyBegin' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_PlayMontageAndWaitNotifyName, OnNotifyEnd) == 0x0000D0, "Member 'UOrionAbilityTask_PlayMontageAndWaitNotifyName::OnNotifyEnd' has a wrong offset!");

// Class OrionGame.OrionAbilityTask_RepeatedAction
// 0x0038 (0x00B8 - 0x0080)
class UOrionAbilityTask_RepeatedAction final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   OnPerformAction;                                   // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFinished;                                        // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOrionAbilityTask_RepeatedAction* PerformRepeatedAction(class UGameplayAbility* OwningAbility, float TimeBetweenActions, int32 TotalActionCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityTask_RepeatedAction">();
	}
	static class UOrionAbilityTask_RepeatedAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbilityTask_RepeatedAction>();
	}
};
static_assert(alignof(UOrionAbilityTask_RepeatedAction) == 0x000008, "Wrong alignment on UOrionAbilityTask_RepeatedAction");
static_assert(sizeof(UOrionAbilityTask_RepeatedAction) == 0x0000B8, "Wrong size on UOrionAbilityTask_RepeatedAction");
static_assert(offsetof(UOrionAbilityTask_RepeatedAction, OnPerformAction) == 0x000080, "Member 'UOrionAbilityTask_RepeatedAction::OnPerformAction' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_RepeatedAction, OnFinished) == 0x000090, "Member 'UOrionAbilityTask_RepeatedAction::OnFinished' has a wrong offset!");

// Class OrionGame.OrionAttributeProxyActor
// 0x0010 (0x0328 - 0x0318)
class AOrionAttributeProxyActor final : public AActor
{
public:
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAbilitySystemComponent*           AbilitySystemComponent;                            // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAttributeProxyActor">();
	}
	static class AOrionAttributeProxyActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionAttributeProxyActor>();
	}
};
static_assert(alignof(AOrionAttributeProxyActor) == 0x000008, "Wrong alignment on AOrionAttributeProxyActor");
static_assert(sizeof(AOrionAttributeProxyActor) == 0x000328, "Wrong size on AOrionAttributeProxyActor");
static_assert(offsetof(AOrionAttributeProxyActor, AbilitySystemComponent) == 0x000320, "Member 'AOrionAttributeProxyActor::AbilitySystemComponent' has a wrong offset!");

// Class OrionGame.OrionAbilityTask_SpawnOrionActor
// 0x0080 (0x0100 - 0x0080)
class UOrionAbilityTask_SpawnOrionActor final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   Success;                                           // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   NotAuthority;                                      // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   FailedToSpawn;                                     // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0x50];                                      // 0x00B0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOrionAbilityTask_SpawnOrionActor* SpawnOrionActor(class UGameplayAbility* OwningAbility, TSubclassOf<class AActor> Class_0, const struct FTransform& SpawnTransform, const struct FGameplayAbilityTargetDataHandle& TargetData);
	static class UOrionAbilityTask_SpawnOrionActor* SpawnOrionActorTargetData(class UGameplayAbility* OwningAbility, TSubclassOf<class AActor> Class_0, const struct FGameplayAbilityTargetDataHandle& TargetData);
	static class UOrionAbilityTask_SpawnOrionActor* SpawnOrionActorTransform(class UGameplayAbility* OwningAbility, TSubclassOf<class AActor> Class_0, const struct FTransform& SpawnTransform);

	bool BeginSpawningActor(class UGameplayAbility* OwningAbility, TSubclassOf<class AActor> Class_0, class AActor** SpawnedActor);
	void FinishSpawningActor(class UGameplayAbility* OwningAbility, class AActor* SpawnedActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityTask_SpawnOrionActor">();
	}
	static class UOrionAbilityTask_SpawnOrionActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbilityTask_SpawnOrionActor>();
	}
};
static_assert(alignof(UOrionAbilityTask_SpawnOrionActor) == 0x000008, "Wrong alignment on UOrionAbilityTask_SpawnOrionActor");
static_assert(sizeof(UOrionAbilityTask_SpawnOrionActor) == 0x000100, "Wrong size on UOrionAbilityTask_SpawnOrionActor");
static_assert(offsetof(UOrionAbilityTask_SpawnOrionActor, Success) == 0x000080, "Member 'UOrionAbilityTask_SpawnOrionActor::Success' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_SpawnOrionActor, NotAuthority) == 0x000090, "Member 'UOrionAbilityTask_SpawnOrionActor::NotAuthority' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_SpawnOrionActor, FailedToSpawn) == 0x0000A0, "Member 'UOrionAbilityTask_SpawnOrionActor::FailedToSpawn' has a wrong offset!");

// Class OrionGame.OrionRotationalContentTagCollection
// 0x0078 (0x00A0 - 0x0028)
class UOrionRotationalContentTagCollection final : public UObject
{
public:
	uint8                                         Pad_28[0x78];                                      // 0x0028(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionRotationalContentTagCollection">();
	}
	static class UOrionRotationalContentTagCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionRotationalContentTagCollection>();
	}
};
static_assert(alignof(UOrionRotationalContentTagCollection) == 0x000008, "Wrong alignment on UOrionRotationalContentTagCollection");
static_assert(sizeof(UOrionRotationalContentTagCollection) == 0x0000A0, "Wrong size on UOrionRotationalContentTagCollection");

// Class OrionGame.OrionAbilityTask_SpawnProjectile
// 0x0078 (0x00F8 - 0x0080)
class UOrionAbilityTask_SpawnProjectile final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   Success;                                           // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   PreSpawned;                                        // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   NotAuthority;                                      // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   FailedToSpawn;                                     // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x20];                                      // 0x00C0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrionProjectile*                       CachedSourceProjectile;                            // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSpawningClone;                                    // 0x00E8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E9[0xF];                                       // 0x00E9(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOrionAbilityTask_SpawnProjectile* CloneProjectile(class UGameplayAbility* OwningAbility, class AOrionProjectile* SourceProjectile, const struct FGameplayAbilityTargetDataHandle& TargetData, float PitchOffset, float YawOffset, TSubclassOf<class AOrionProjectile> Class_0);
	static class UOrionAbilityTask_SpawnProjectile* SpawnProjectile(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetData, float PitchOffset, float YawOffset, TSubclassOf<class AOrionProjectile> Class_0);

	bool BeginSpawningActor(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetData, TSubclassOf<class AOrionProjectile> Class_0, class AOrionProjectile** SpawnedActor);
	void FinishSpawningActor(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetData, class AOrionProjectile* SpawnedActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityTask_SpawnProjectile">();
	}
	static class UOrionAbilityTask_SpawnProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbilityTask_SpawnProjectile>();
	}
};
static_assert(alignof(UOrionAbilityTask_SpawnProjectile) == 0x000008, "Wrong alignment on UOrionAbilityTask_SpawnProjectile");
static_assert(sizeof(UOrionAbilityTask_SpawnProjectile) == 0x0000F8, "Wrong size on UOrionAbilityTask_SpawnProjectile");
static_assert(offsetof(UOrionAbilityTask_SpawnProjectile, Success) == 0x000080, "Member 'UOrionAbilityTask_SpawnProjectile::Success' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_SpawnProjectile, PreSpawned) == 0x000090, "Member 'UOrionAbilityTask_SpawnProjectile::PreSpawned' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_SpawnProjectile, NotAuthority) == 0x0000A0, "Member 'UOrionAbilityTask_SpawnProjectile::NotAuthority' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_SpawnProjectile, FailedToSpawn) == 0x0000B0, "Member 'UOrionAbilityTask_SpawnProjectile::FailedToSpawn' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_SpawnProjectile, CachedSourceProjectile) == 0x0000E0, "Member 'UOrionAbilityTask_SpawnProjectile::CachedSourceProjectile' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_SpawnProjectile, bSpawningClone) == 0x0000E8, "Member 'UOrionAbilityTask_SpawnProjectile::bSpawningClone' has a wrong offset!");

// Class OrionGame.OrionAbilityTask_SpawnProjectileMulti
// 0x0058 (0x00D8 - 0x0080)
class UOrionAbilityTask_SpawnProjectileMulti : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   SingleProjectileSpawned;                           // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   AllProjectilesSpawned;                             // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x38];                                      // 0x00A0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOrionAbilityTask_SpawnProjectileMulti* SpawnProjectileMulti(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetDataArray, TSubclassOf<class AOrionProjectile> Class_0);

	bool BeginSpawningActorArray(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetDataArray, TSubclassOf<class AOrionProjectile> Class_0, TArray<class AOrionProjectile*>* SpawnedActor, class AOrionProjectile** SpawnedProjectile);
	void FinishSpawningActorArray(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetDataArray, const TArray<class AOrionProjectile*>& SpawnedActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityTask_SpawnProjectileMulti">();
	}
	static class UOrionAbilityTask_SpawnProjectileMulti* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbilityTask_SpawnProjectileMulti>();
	}
};
static_assert(alignof(UOrionAbilityTask_SpawnProjectileMulti) == 0x000008, "Wrong alignment on UOrionAbilityTask_SpawnProjectileMulti");
static_assert(sizeof(UOrionAbilityTask_SpawnProjectileMulti) == 0x0000D8, "Wrong size on UOrionAbilityTask_SpawnProjectileMulti");
static_assert(offsetof(UOrionAbilityTask_SpawnProjectileMulti, SingleProjectileSpawned) == 0x000080, "Member 'UOrionAbilityTask_SpawnProjectileMulti::SingleProjectileSpawned' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_SpawnProjectileMulti, AllProjectilesSpawned) == 0x000090, "Member 'UOrionAbilityTask_SpawnProjectileMulti::AllProjectilesSpawned' has a wrong offset!");

// Class OrionGame.OrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire
// 0x0030 (0x0108 - 0x00D8)
class UOrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire final : public UOrionAbilityTask_SpawnProjectileMulti
{
public:
	UMulticastDelegateProperty_                   SingleProjectileSpawned_;                          // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   AllProjectilesSpawned_;                            // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x10];                                      // 0x00F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire* SpawnProjectileMulti_HorizontalSpread(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetData, int32 ProjectileCount, float PitchRandom, float PitchOffset, float YawRange, float YawOffset, TSubclassOf<class AOrionProjectile> Class_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire">();
	}
	static class UOrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire>();
	}
};
static_assert(alignof(UOrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire) == 0x000008, "Wrong alignment on UOrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire");
static_assert(sizeof(UOrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire) == 0x000108, "Wrong size on UOrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire");
static_assert(offsetof(UOrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire, SingleProjectileSpawned_) == 0x0000D8, "Member 'UOrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire::SingleProjectileSpawned_' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire, AllProjectilesSpawned_) == 0x0000E8, "Member 'UOrionAbilityTask_SpawnProjectileMulti_HorizontalSpreadFire::AllProjectilesSpawned_' has a wrong offset!");

// Class OrionGame.OrionAbilityTask_SpawnProjectileMulti_Cone
// 0x0030 (0x0108 - 0x00D8)
class UOrionAbilityTask_SpawnProjectileMulti_Cone final : public UOrionAbilityTask_SpawnProjectileMulti
{
public:
	UMulticastDelegateProperty_                   SingleProjectileSpawned_;                          // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   AllProjectilesSpawned_;                            // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x10];                                      // 0x00F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOrionAbilityTask_SpawnProjectileMulti_Cone* SpawnProjectileMulti_Cone(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetData, int32 ProjectileCount, float PitchRandom, float PitchOffset, float YawRandom, float YawOffset, TSubclassOf<class AOrionProjectile> Class_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityTask_SpawnProjectileMulti_Cone">();
	}
	static class UOrionAbilityTask_SpawnProjectileMulti_Cone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbilityTask_SpawnProjectileMulti_Cone>();
	}
};
static_assert(alignof(UOrionAbilityTask_SpawnProjectileMulti_Cone) == 0x000008, "Wrong alignment on UOrionAbilityTask_SpawnProjectileMulti_Cone");
static_assert(sizeof(UOrionAbilityTask_SpawnProjectileMulti_Cone) == 0x000108, "Wrong size on UOrionAbilityTask_SpawnProjectileMulti_Cone");
static_assert(offsetof(UOrionAbilityTask_SpawnProjectileMulti_Cone, SingleProjectileSpawned_) == 0x0000D8, "Member 'UOrionAbilityTask_SpawnProjectileMulti_Cone::SingleProjectileSpawned_' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_SpawnProjectileMulti_Cone, AllProjectilesSpawned_) == 0x0000E8, "Member 'UOrionAbilityTask_SpawnProjectileMulti_Cone::AllProjectilesSpawned_' has a wrong offset!");

// Class OrionGame.OrionSessionHelper
// 0x0178 (0x01A0 - 0x0028)
class UOrionSessionHelper final : public UObject
{
public:
	uint8                                         Pad_28[0x98];                                      // 0x0028(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsJoining;                                        // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasJoined;                                        // 0x00C1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCancelRequested;                                  // 0x00C2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C3[0x15];                                      // 0x00C3(0x0015)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CurrentSessionName;                                // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0xC0];                                      // 0x00E0(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionSessionHelper">();
	}
	static class UOrionSessionHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionSessionHelper>();
	}
};
static_assert(alignof(UOrionSessionHelper) == 0x000008, "Wrong alignment on UOrionSessionHelper");
static_assert(sizeof(UOrionSessionHelper) == 0x0001A0, "Wrong size on UOrionSessionHelper");
static_assert(offsetof(UOrionSessionHelper, bIsJoining) == 0x0000C0, "Member 'UOrionSessionHelper::bIsJoining' has a wrong offset!");
static_assert(offsetof(UOrionSessionHelper, bHasJoined) == 0x0000C1, "Member 'UOrionSessionHelper::bHasJoined' has a wrong offset!");
static_assert(offsetof(UOrionSessionHelper, bCancelRequested) == 0x0000C2, "Member 'UOrionSessionHelper::bCancelRequested' has a wrong offset!");
static_assert(offsetof(UOrionSessionHelper, CurrentSessionName) == 0x0000D8, "Member 'UOrionSessionHelper::CurrentSessionName' has a wrong offset!");

// Class OrionGame.OrionAbilityTask_SpawnRig
// 0x0058 (0x00D8 - 0x0080)
class UOrionAbilityTask_SpawnRig final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   Success;                                           // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   NotAuthority;                                      // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   FailedToSpawn;                                     // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0x20];                                      // 0x00B0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	EOrionTeam                                    CachedTeamNum;                                     // 0x00D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOrionAbilityTask_SpawnRig* SpawnRig(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetData, EOrionTeam RigTeamNum, TSubclassOf<class AOrionRigs> Class_0);

	bool BeginSpawningActor(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetData, TSubclassOf<class AOrionRigs> Class_0, class AOrionRigs** SpawnedActor);
	void FinishSpawningActor(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetData, class AOrionRigs* SpawnedActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityTask_SpawnRig">();
	}
	static class UOrionAbilityTask_SpawnRig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbilityTask_SpawnRig>();
	}
};
static_assert(alignof(UOrionAbilityTask_SpawnRig) == 0x000008, "Wrong alignment on UOrionAbilityTask_SpawnRig");
static_assert(sizeof(UOrionAbilityTask_SpawnRig) == 0x0000D8, "Wrong size on UOrionAbilityTask_SpawnRig");
static_assert(offsetof(UOrionAbilityTask_SpawnRig, Success) == 0x000080, "Member 'UOrionAbilityTask_SpawnRig::Success' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_SpawnRig, NotAuthority) == 0x000090, "Member 'UOrionAbilityTask_SpawnRig::NotAuthority' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_SpawnRig, FailedToSpawn) == 0x0000A0, "Member 'UOrionAbilityTask_SpawnRig::FailedToSpawn' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_SpawnRig, CachedTeamNum) == 0x0000D0, "Member 'UOrionAbilityTask_SpawnRig::CachedTeamNum' has a wrong offset!");

// Class OrionGame.OrionAbilityTask_SpawnWard
// 0x0058 (0x00D8 - 0x0080)
class UOrionAbilityTask_SpawnWard final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   Success;                                           // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   NotAuthority;                                      // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   FailedToSpawn;                                     // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0x20];                                      // 0x00B0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	EOrionTeam                                    CachedTeamNum;                                     // 0x00D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOrionAbilityTask_SpawnWard* SpawnWard(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetData, EOrionTeam TeamNum, TSubclassOf<class AOrionVisionWard> Class_0);

	bool BeginSpawningActor(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetData, TSubclassOf<class AOrionVisionWard> Class_0, class AOrionVisionWard** SpawnedActor);
	void FinishSpawningActor(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetData, class AOrionVisionWard* SpawnedActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityTask_SpawnWard">();
	}
	static class UOrionAbilityTask_SpawnWard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbilityTask_SpawnWard>();
	}
};
static_assert(alignof(UOrionAbilityTask_SpawnWard) == 0x000008, "Wrong alignment on UOrionAbilityTask_SpawnWard");
static_assert(sizeof(UOrionAbilityTask_SpawnWard) == 0x0000D8, "Wrong size on UOrionAbilityTask_SpawnWard");
static_assert(offsetof(UOrionAbilityTask_SpawnWard, Success) == 0x000080, "Member 'UOrionAbilityTask_SpawnWard::Success' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_SpawnWard, NotAuthority) == 0x000090, "Member 'UOrionAbilityTask_SpawnWard::NotAuthority' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_SpawnWard, FailedToSpawn) == 0x0000A0, "Member 'UOrionAbilityTask_SpawnWard::FailedToSpawn' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_SpawnWard, CachedTeamNum) == 0x0000D0, "Member 'UOrionAbilityTask_SpawnWard::CachedTeamNum' has a wrong offset!");

// Class OrionGame.OrionAbilityTask_WaitAbilityLevelUp
// 0x0030 (0x00B0 - 0x0080)
class UOrionAbilityTask_WaitAbilityLevelUp final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   OnLevelUp;                                         // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x20];                                      // 0x0090(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOrionAbilityTask_WaitAbilityLevelUp* WaitAbilityLevelUp(class UGameplayAbility* OwningAbility, const struct FGameplayTag& AbilityTag, bool OnlyTriggerOnce);
	static class UOrionAbilityTask_WaitAbilityLevelUp* WaitThisAbilityLevelUp(class UGameplayAbility* OwningAbility, bool OnlyTriggerOnce);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityTask_WaitAbilityLevelUp">();
	}
	static class UOrionAbilityTask_WaitAbilityLevelUp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbilityTask_WaitAbilityLevelUp>();
	}
};
static_assert(alignof(UOrionAbilityTask_WaitAbilityLevelUp) == 0x000008, "Wrong alignment on UOrionAbilityTask_WaitAbilityLevelUp");
static_assert(sizeof(UOrionAbilityTask_WaitAbilityLevelUp) == 0x0000B0, "Wrong size on UOrionAbilityTask_WaitAbilityLevelUp");
static_assert(offsetof(UOrionAbilityTask_WaitAbilityLevelUp, OnLevelUp) == 0x000080, "Member 'UOrionAbilityTask_WaitAbilityLevelUp::OnLevelUp' has a wrong offset!");

// Class OrionGame.OrionAbilityTask_WaitReactivate
// 0x0088 (0x0108 - 0x0080)
class UOrionAbilityTask_WaitReactivate final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   OnReactivateConfirmed;                             // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnClientPredictReactivate;                         // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x68];                                      // 0x00A0(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOrionAbilityTask_WaitReactivate* WaitAbilityReactivate(class UGameplayAbility* OwningAbility, EOrionAbilityActivationGroup NewActivationGroup, const struct FGameplayTagRequirements& AdditionalAbilityInputToListenFor, bool TriggerOnlyOnce);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityTask_WaitReactivate">();
	}
	static class UOrionAbilityTask_WaitReactivate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbilityTask_WaitReactivate>();
	}
};
static_assert(alignof(UOrionAbilityTask_WaitReactivate) == 0x000008, "Wrong alignment on UOrionAbilityTask_WaitReactivate");
static_assert(sizeof(UOrionAbilityTask_WaitReactivate) == 0x000108, "Wrong size on UOrionAbilityTask_WaitReactivate");
static_assert(offsetof(UOrionAbilityTask_WaitReactivate, OnReactivateConfirmed) == 0x000080, "Member 'UOrionAbilityTask_WaitReactivate::OnReactivateConfirmed' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_WaitReactivate, OnClientPredictReactivate) == 0x000090, "Member 'UOrionAbilityTask_WaitReactivate::OnClientPredictReactivate' has a wrong offset!");

// Class OrionGame.OrionAbilityTask_WaitAnyAbilityInput
// 0x0068 (0x00E8 - 0x0080)
class UOrionAbilityTask_WaitAnyAbilityInput final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   OnInput;                                           // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x58];                                      // 0x0090(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOrionAbilityTask_WaitAnyAbilityInput* WaitAnyAbilityInput(class UGameplayAbility* OwningAbility, const struct FGameplayTagRequirements& TagRequirements, bool bConsumeInput);

	void OnAnyAbilityInput();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityTask_WaitAnyAbilityInput">();
	}
	static class UOrionAbilityTask_WaitAnyAbilityInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbilityTask_WaitAnyAbilityInput>();
	}
};
static_assert(alignof(UOrionAbilityTask_WaitAnyAbilityInput) == 0x000008, "Wrong alignment on UOrionAbilityTask_WaitAnyAbilityInput");
static_assert(sizeof(UOrionAbilityTask_WaitAnyAbilityInput) == 0x0000E8, "Wrong size on UOrionAbilityTask_WaitAnyAbilityInput");
static_assert(offsetof(UOrionAbilityTask_WaitAnyAbilityInput, OnInput) == 0x000080, "Member 'UOrionAbilityTask_WaitAnyAbilityInput::OnInput' has a wrong offset!");

// Class OrionGame.OrionAutomationHelper
// 0x0000 (0x0028 - 0x0028)
class UOrionAutomationHelper final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAutomationHelper">();
	}
	static class UOrionAutomationHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAutomationHelper>();
	}
};
static_assert(alignof(UOrionAutomationHelper) == 0x000008, "Wrong alignment on UOrionAutomationHelper");
static_assert(sizeof(UOrionAutomationHelper) == 0x000028, "Wrong size on UOrionAutomationHelper");

// Class OrionGame.OrionAbilityTask_WaitEventKeywordBase
// 0x0098 (0x0118 - 0x0080)
class UOrionAbilityTask_WaitEventKeywordBase : public UAbilityTask
{
public:
	uint8                                         Pad_80[0x98];                                      // 0x0080(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEventCallback();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityTask_WaitEventKeywordBase">();
	}
	static class UOrionAbilityTask_WaitEventKeywordBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbilityTask_WaitEventKeywordBase>();
	}
};
static_assert(alignof(UOrionAbilityTask_WaitEventKeywordBase) == 0x000008, "Wrong alignment on UOrionAbilityTask_WaitEventKeywordBase");
static_assert(sizeof(UOrionAbilityTask_WaitEventKeywordBase) == 0x000118, "Wrong size on UOrionAbilityTask_WaitEventKeywordBase");

// Class OrionGame.OrionAbilityTask_WaitDamage
// 0x00A0 (0x01B8 - 0x0118)
class UOrionAbilityTask_WaitDamage final : public UOrionAbilityTask_WaitEventKeywordBase
{
public:
	UMulticastDelegateProperty_                   OnDamage;                                          // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x90];                                     // 0x0128(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOrionAbilityTask_WaitDamage* WaitDamageDealt(class UGameplayAbility* OwningAbility, const struct FDamageQualifierKeywordsWithContext& AdditionalQualifiers, bool TriggerOnce);
	static class UOrionAbilityTask_WaitDamage* WaitDamageTaken(class UGameplayAbility* OwningAbility, const struct FDamageQualifierKeywordsWithContext& AdditionalQualifiers, bool TriggerOnce);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityTask_WaitDamage">();
	}
	static class UOrionAbilityTask_WaitDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbilityTask_WaitDamage>();
	}
};
static_assert(alignof(UOrionAbilityTask_WaitDamage) == 0x000008, "Wrong alignment on UOrionAbilityTask_WaitDamage");
static_assert(sizeof(UOrionAbilityTask_WaitDamage) == 0x0001B8, "Wrong size on UOrionAbilityTask_WaitDamage");
static_assert(offsetof(UOrionAbilityTask_WaitDamage, OnDamage) == 0x000118, "Member 'UOrionAbilityTask_WaitDamage::OnDamage' has a wrong offset!");

// Class OrionGame.OrionAsyncLoadRequestQueue
// 0x0030 (0x0058 - 0x0028)
class UOrionAsyncLoadRequestQueue final : public UObject
{
public:
	TArray<struct FSoftObjectPath>                LoadingQueue;                                      // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAsyncLoadRequestQueue*            Next;                                              // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAsyncLoadRequestQueue">();
	}
	static class UOrionAsyncLoadRequestQueue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAsyncLoadRequestQueue>();
	}
};
static_assert(alignof(UOrionAsyncLoadRequestQueue) == 0x000008, "Wrong alignment on UOrionAsyncLoadRequestQueue");
static_assert(sizeof(UOrionAsyncLoadRequestQueue) == 0x000058, "Wrong size on UOrionAsyncLoadRequestQueue");
static_assert(offsetof(UOrionAsyncLoadRequestQueue, LoadingQueue) == 0x000028, "Member 'UOrionAsyncLoadRequestQueue::LoadingQueue' has a wrong offset!");
static_assert(offsetof(UOrionAsyncLoadRequestQueue, Next) == 0x000040, "Member 'UOrionAsyncLoadRequestQueue::Next' has a wrong offset!");

// Class OrionGame.OrionAbilityTask_WaitEventKeyword
// 0x0010 (0x0128 - 0x0118)
class UOrionAbilityTask_WaitEventKeyword final : public UOrionAbilityTask_WaitEventKeywordBase
{
public:
	UMulticastDelegateProperty_                   OnBroadcast;                                       // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UOrionAbilityTask_WaitEventKeyword* WaitEventKeyword(class UGameplayAbility* OwningAbility, const struct FEventKeywordWithQualifiers& EventInfo, bool TriggerOnce);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityTask_WaitEventKeyword">();
	}
	static class UOrionAbilityTask_WaitEventKeyword* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbilityTask_WaitEventKeyword>();
	}
};
static_assert(alignof(UOrionAbilityTask_WaitEventKeyword) == 0x000008, "Wrong alignment on UOrionAbilityTask_WaitEventKeyword");
static_assert(sizeof(UOrionAbilityTask_WaitEventKeyword) == 0x000128, "Wrong size on UOrionAbilityTask_WaitEventKeyword");
static_assert(offsetof(UOrionAbilityTask_WaitEventKeyword, OnBroadcast) == 0x000118, "Member 'UOrionAbilityTask_WaitEventKeyword::OnBroadcast' has a wrong offset!");

// Class OrionGame.OrionAbilityTask_WaitForCombo
// 0x0040 (0x00C0 - 0x0080)
class UOrionAbilityTask_WaitForCombo final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   OnSuccess;                                         // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFail;                                            // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x20];                                      // 0x00A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOrionAbilityTask_WaitForCombo* WaitForCombo(class UGameplayAbility* OwningAbility);

	void FailEventCallback();
	void SuccessEventCallback();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityTask_WaitForCombo">();
	}
	static class UOrionAbilityTask_WaitForCombo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbilityTask_WaitForCombo>();
	}
};
static_assert(alignof(UOrionAbilityTask_WaitForCombo) == 0x000008, "Wrong alignment on UOrionAbilityTask_WaitForCombo");
static_assert(sizeof(UOrionAbilityTask_WaitForCombo) == 0x0000C0, "Wrong size on UOrionAbilityTask_WaitForCombo");
static_assert(offsetof(UOrionAbilityTask_WaitForCombo, OnSuccess) == 0x000080, "Member 'UOrionAbilityTask_WaitForCombo::OnSuccess' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_WaitForCombo, OnFail) == 0x000090, "Member 'UOrionAbilityTask_WaitForCombo::OnFail' has a wrong offset!");

// Class OrionGame.OrionButtonStyle
// 0x0A80 (0x0AA8 - 0x0028)
class UOrionButtonStyle : public UObject
{
public:
	struct FSlateBrush                            NormalBase[0x3];                                   // 0x0028(0x0078)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrush                            NormalHovered[0x3];                                // 0x0190(0x0078)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrush                            NormalPressed[0x3];                                // 0x02F8(0x0078)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrush                            SelectedBase[0x3];                                 // 0x0460(0x0078)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrush                            SelectedHovered[0x3];                              // 0x05C8(0x0078)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrush                            SelectedPressed[0x3];                              // 0x0730(0x0078)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrush                            Disabled[0x3];                                     // 0x0898(0x0078)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FMargin                                ButtonPadding[0x3];                                // 0x0A00(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FMargin                                CustomPadding[0x3];                                // 0x0A30(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UOrionTextStyle>            NormalTextStyle;                                   // 0x0A60(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UOrionTextStyle>            SelectedTextStyle;                                 // 0x0A68(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UOrionTextStyle>            DisabledTextStyle;                                 // 0x0A70(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateSound                            PressedSlateSound;                                 // 0x0A78(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FSlateSound                            HoveredSlateSound;                                 // 0x0A90(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

public:
	void GetButtonPadding(EOrionWidgetStyleSize Size, struct FMargin* OutButtonPadding) const;
	void GetCustomPadding(EOrionWidgetStyleSize Size, struct FMargin* OutCustomPadding) const;
	void GetDisabledBrush(EOrionWidgetStyleSize Size, struct FSlateBrush* Brush) const;
	class UOrionTextStyle* GetDisabledTextStyle() const;
	void GetNormalBaseBrush(EOrionWidgetStyleSize Size, struct FSlateBrush* Brush) const;
	void GetNormalHoveredBrush(EOrionWidgetStyleSize Size, struct FSlateBrush* Brush) const;
	void GetNormalPressedBrush(EOrionWidgetStyleSize Size, struct FSlateBrush* Brush) const;
	class UOrionTextStyle* GetNormalTextStyle() const;
	void GetSelectedBaseBrush(EOrionWidgetStyleSize Size, struct FSlateBrush* Brush) const;
	void GetSelectedHoveredBrush(EOrionWidgetStyleSize Size, struct FSlateBrush* Brush) const;
	void GetSelectedPressedBrush(EOrionWidgetStyleSize Size, struct FSlateBrush* Brush) const;
	class UOrionTextStyle* GetSelectedTextStyle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionButtonStyle">();
	}
	static class UOrionButtonStyle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionButtonStyle>();
	}
};
static_assert(alignof(UOrionButtonStyle) == 0x000008, "Wrong alignment on UOrionButtonStyle");
static_assert(sizeof(UOrionButtonStyle) == 0x000AA8, "Wrong size on UOrionButtonStyle");
static_assert(offsetof(UOrionButtonStyle, NormalBase) == 0x000028, "Member 'UOrionButtonStyle::NormalBase' has a wrong offset!");
static_assert(offsetof(UOrionButtonStyle, NormalHovered) == 0x000190, "Member 'UOrionButtonStyle::NormalHovered' has a wrong offset!");
static_assert(offsetof(UOrionButtonStyle, NormalPressed) == 0x0002F8, "Member 'UOrionButtonStyle::NormalPressed' has a wrong offset!");
static_assert(offsetof(UOrionButtonStyle, SelectedBase) == 0x000460, "Member 'UOrionButtonStyle::SelectedBase' has a wrong offset!");
static_assert(offsetof(UOrionButtonStyle, SelectedHovered) == 0x0005C8, "Member 'UOrionButtonStyle::SelectedHovered' has a wrong offset!");
static_assert(offsetof(UOrionButtonStyle, SelectedPressed) == 0x000730, "Member 'UOrionButtonStyle::SelectedPressed' has a wrong offset!");
static_assert(offsetof(UOrionButtonStyle, Disabled) == 0x000898, "Member 'UOrionButtonStyle::Disabled' has a wrong offset!");
static_assert(offsetof(UOrionButtonStyle, ButtonPadding) == 0x000A00, "Member 'UOrionButtonStyle::ButtonPadding' has a wrong offset!");
static_assert(offsetof(UOrionButtonStyle, CustomPadding) == 0x000A30, "Member 'UOrionButtonStyle::CustomPadding' has a wrong offset!");
static_assert(offsetof(UOrionButtonStyle, NormalTextStyle) == 0x000A60, "Member 'UOrionButtonStyle::NormalTextStyle' has a wrong offset!");
static_assert(offsetof(UOrionButtonStyle, SelectedTextStyle) == 0x000A68, "Member 'UOrionButtonStyle::SelectedTextStyle' has a wrong offset!");
static_assert(offsetof(UOrionButtonStyle, DisabledTextStyle) == 0x000A70, "Member 'UOrionButtonStyle::DisabledTextStyle' has a wrong offset!");
static_assert(offsetof(UOrionButtonStyle, PressedSlateSound) == 0x000A78, "Member 'UOrionButtonStyle::PressedSlateSound' has a wrong offset!");
static_assert(offsetof(UOrionButtonStyle, HoveredSlateSound) == 0x000A90, "Member 'UOrionButtonStyle::HoveredSlateSound' has a wrong offset!");

// Class OrionGame.OrionAbilityTask_WaitForMovementInput
// 0x0020 (0x00A0 - 0x0080)
class UOrionAbilityTask_WaitForMovementInput final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   OnMovementInput;                                   // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x10];                                      // 0x0090(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOrionAbilityTask_WaitForMovementInput* WaitForMovementInput(class UGameplayAbility* OwningAbility);

	void OnMovementInputCallback();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityTask_WaitForMovementInput">();
	}
	static class UOrionAbilityTask_WaitForMovementInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbilityTask_WaitForMovementInput>();
	}
};
static_assert(alignof(UOrionAbilityTask_WaitForMovementInput) == 0x000008, "Wrong alignment on UOrionAbilityTask_WaitForMovementInput");
static_assert(sizeof(UOrionAbilityTask_WaitForMovementInput) == 0x0000A0, "Wrong size on UOrionAbilityTask_WaitForMovementInput");
static_assert(offsetof(UOrionAbilityTask_WaitForMovementInput, OnMovementInput) == 0x000080, "Member 'UOrionAbilityTask_WaitForMovementInput::OnMovementInput' has a wrong offset!");

// Class OrionGame.OrionAbilityTask_WaitForSpecialAttackRotation
// 0x0028 (0x00A8 - 0x0080)
class UOrionAbilityTask_WaitForSpecialAttackRotation final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   OnCompleted;                                       // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x10];                                      // 0x0090(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrionCharAI_JungleBoss*                OwnerChar;                                         // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UOrionAbilityTask_WaitForSpecialAttackRotation* WaitForSpecialAttackRotation(class UGameplayAbility* OwningAbility, EOrionJungleTarget Mode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityTask_WaitForSpecialAttackRotation">();
	}
	static class UOrionAbilityTask_WaitForSpecialAttackRotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbilityTask_WaitForSpecialAttackRotation>();
	}
};
static_assert(alignof(UOrionAbilityTask_WaitForSpecialAttackRotation) == 0x000008, "Wrong alignment on UOrionAbilityTask_WaitForSpecialAttackRotation");
static_assert(sizeof(UOrionAbilityTask_WaitForSpecialAttackRotation) == 0x0000A8, "Wrong size on UOrionAbilityTask_WaitForSpecialAttackRotation");
static_assert(offsetof(UOrionAbilityTask_WaitForSpecialAttackRotation, OnCompleted) == 0x000080, "Member 'UOrionAbilityTask_WaitForSpecialAttackRotation::OnCompleted' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_WaitForSpecialAttackRotation, OwnerChar) == 0x0000A0, "Member 'UOrionAbilityTask_WaitForSpecialAttackRotation::OwnerChar' has a wrong offset!");

// Class OrionGame.OrionBBKeyType_AbilitySpecHandle
// 0x0000 (0x0030 - 0x0030)
class UOrionBBKeyType_AbilitySpecHandle final : public UBlackboardKeyType_Int
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionBBKeyType_AbilitySpecHandle">();
	}
	static class UOrionBBKeyType_AbilitySpecHandle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionBBKeyType_AbilitySpecHandle>();
	}
};
static_assert(alignof(UOrionBBKeyType_AbilitySpecHandle) == 0x000008, "Wrong alignment on UOrionBBKeyType_AbilitySpecHandle");
static_assert(sizeof(UOrionBBKeyType_AbilitySpecHandle) == 0x000030, "Wrong size on UOrionBBKeyType_AbilitySpecHandle");

// Class OrionGame.OrionAbilityTask_WaitHeroGameplayTag
// 0x0028 (0x00A8 - 0x0080)
class UOrionAbilityTask_WaitHeroGameplayTag final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   Event;                                             // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x18];                                      // 0x0090(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOrionAbilityTask_WaitHeroGameplayTag* WaitHeroGameplayTagAdd(class UGameplayAbility* OwningAbility, const struct FGameplayTag& Tag, bool bAllies, bool bEnemies, bool bOnlyTriggerOnce);
	static class UOrionAbilityTask_WaitHeroGameplayTag* WaitHeroGameplayTagRemove(class UGameplayAbility* OwningAbility, const struct FGameplayTag& Tag, bool bAllies, bool bEnemies, bool bOnlyTriggerOnce);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityTask_WaitHeroGameplayTag">();
	}
	static class UOrionAbilityTask_WaitHeroGameplayTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbilityTask_WaitHeroGameplayTag>();
	}
};
static_assert(alignof(UOrionAbilityTask_WaitHeroGameplayTag) == 0x000008, "Wrong alignment on UOrionAbilityTask_WaitHeroGameplayTag");
static_assert(sizeof(UOrionAbilityTask_WaitHeroGameplayTag) == 0x0000A8, "Wrong size on UOrionAbilityTask_WaitHeroGameplayTag");
static_assert(offsetof(UOrionAbilityTask_WaitHeroGameplayTag, Event) == 0x000080, "Member 'UOrionAbilityTask_WaitHeroGameplayTag::Event' has a wrong offset!");

// Class OrionGame.OrionQueryContext_DefenseLineTower
// 0x0000 (0x0028 - 0x0028)
class UOrionQueryContext_DefenseLineTower final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionQueryContext_DefenseLineTower">();
	}
	static class UOrionQueryContext_DefenseLineTower* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionQueryContext_DefenseLineTower>();
	}
};
static_assert(alignof(UOrionQueryContext_DefenseLineTower) == 0x000008, "Wrong alignment on UOrionQueryContext_DefenseLineTower");
static_assert(sizeof(UOrionQueryContext_DefenseLineTower) == 0x000028, "Wrong size on UOrionQueryContext_DefenseLineTower");

// Class OrionGame.OrionAbilityTask_WaitInputPress_WithState
// 0x0020 (0x00A0 - 0x0080)
class UOrionAbilityTask_WaitInputPress_WithState final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   OnPress;                                           // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x10];                                      // 0x0090(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOrionAbilityTask_WaitInputPress_WithState* WaitInputPress_WithState(class UGameplayAbility* OwningAbility, bool bTestAlreadyPressed, bool bForceAlreadyPressed);

	void OnPressCallback();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityTask_WaitInputPress_WithState">();
	}
	static class UOrionAbilityTask_WaitInputPress_WithState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbilityTask_WaitInputPress_WithState>();
	}
};
static_assert(alignof(UOrionAbilityTask_WaitInputPress_WithState) == 0x000008, "Wrong alignment on UOrionAbilityTask_WaitInputPress_WithState");
static_assert(sizeof(UOrionAbilityTask_WaitInputPress_WithState) == 0x0000A0, "Wrong size on UOrionAbilityTask_WaitInputPress_WithState");
static_assert(offsetof(UOrionAbilityTask_WaitInputPress_WithState, OnPress) == 0x000080, "Member 'UOrionAbilityTask_WaitInputPress_WithState::OnPress' has a wrong offset!");

// Class OrionGame.OrionButtonInternal
// 0x0030 (0x0408 - 0x03D8)
class UOrionButtonInternal final : public UButton
{
public:
	int32                                         MinWidth;                                          // 0x03D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinHeight;                                         // 0x03DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInteractionEnabled;                               // 0x03E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E1[0x27];                                     // 0x03E1(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionButtonInternal">();
	}
	static class UOrionButtonInternal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionButtonInternal>();
	}
};
static_assert(alignof(UOrionButtonInternal) == 0x000008, "Wrong alignment on UOrionButtonInternal");
static_assert(sizeof(UOrionButtonInternal) == 0x000408, "Wrong size on UOrionButtonInternal");
static_assert(offsetof(UOrionButtonInternal, MinWidth) == 0x0003D8, "Member 'UOrionButtonInternal::MinWidth' has a wrong offset!");
static_assert(offsetof(UOrionButtonInternal, MinHeight) == 0x0003DC, "Member 'UOrionButtonInternal::MinHeight' has a wrong offset!");
static_assert(offsetof(UOrionButtonInternal, bInteractionEnabled) == 0x0003E0, "Member 'UOrionButtonInternal::bInteractionEnabled' has a wrong offset!");

// Class OrionGame.OrionAbilityTask_WaitKilled
// 0x00A8 (0x0128 - 0x0080)
class UOrionAbilityTask_WaitKilled final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   OnKilled;                                          // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AActor*                                 TestActor;                                         // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x90];                                      // 0x0098(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOrionAbilityTask_WaitKilled* WaitActorKilled(class UGameplayAbility* OwningAbility, class AActor* Actor, const struct FGameplayTagRequirements& SourceTagRequirements, const struct FGameplayTagRequirements& TargetTagRequirements, bool TriggerOnce);
	static class UOrionAbilityTask_WaitKilled* WaitOwnerKilled(class UGameplayAbility* OwningAbility, const struct FGameplayTagRequirements& SourceTagRequirements, const struct FGameplayTagRequirements& TargetTagRequirements, bool TriggerOnce);

	void OnKilledCallback(const struct FGameplayEffectSpec& Spec);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityTask_WaitKilled">();
	}
	static class UOrionAbilityTask_WaitKilled* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbilityTask_WaitKilled>();
	}
};
static_assert(alignof(UOrionAbilityTask_WaitKilled) == 0x000008, "Wrong alignment on UOrionAbilityTask_WaitKilled");
static_assert(sizeof(UOrionAbilityTask_WaitKilled) == 0x000128, "Wrong size on UOrionAbilityTask_WaitKilled");
static_assert(offsetof(UOrionAbilityTask_WaitKilled, OnKilled) == 0x000080, "Member 'UOrionAbilityTask_WaitKilled::OnKilled' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_WaitKilled, TestActor) == 0x000090, "Member 'UOrionAbilityTask_WaitKilled::TestActor' has a wrong offset!");

// Class OrionGame.OrionAbilityTask_WaitLanded
// 0x0018 (0x0098 - 0x0080)
class UOrionAbilityTask_WaitLanded final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   OnLanded;                                          // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOrionAbilityTask_WaitLanded* WaitLanded(class UGameplayAbility* OwningAbility);

	void OnLandedCallback(const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityTask_WaitLanded">();
	}
	static class UOrionAbilityTask_WaitLanded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbilityTask_WaitLanded>();
	}
};
static_assert(alignof(UOrionAbilityTask_WaitLanded) == 0x000008, "Wrong alignment on UOrionAbilityTask_WaitLanded");
static_assert(sizeof(UOrionAbilityTask_WaitLanded) == 0x000098, "Wrong size on UOrionAbilityTask_WaitLanded");
static_assert(offsetof(UOrionAbilityTask_WaitLanded, OnLanded) == 0x000080, "Member 'UOrionAbilityTask_WaitLanded::OnLanded' has a wrong offset!");

// Class OrionGame.OrionCurveTableSetManager
// 0x0120 (0x0148 - 0x0028)
class UOrionCurveTableSetManager final : public UObject
{
public:
	TArray<struct FDataTableNameMappingPair>      Mappings;                                          // 0x0028(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	class FName                                   ActiveSet;                                         // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCurveTableSet>                 Sets;                                              // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCurveTableSet                         DefaultSet;                                        // 0x0050(0x0070)(NativeAccessSpecifierPublic)
	struct FCurveTableSet                         BackupSet;                                         // 0x00C0(0x0070)(NativeAccessSpecifierPublic)
	class FString                                 ExplicitOverride;                                  // 0x0130(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DataIsPoisoned;                                    // 0x0140(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_141[0x7];                                      // 0x0141(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCurveTableSetManager">();
	}
	static class UOrionCurveTableSetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionCurveTableSetManager>();
	}
};
static_assert(alignof(UOrionCurveTableSetManager) == 0x000008, "Wrong alignment on UOrionCurveTableSetManager");
static_assert(sizeof(UOrionCurveTableSetManager) == 0x000148, "Wrong size on UOrionCurveTableSetManager");
static_assert(offsetof(UOrionCurveTableSetManager, Mappings) == 0x000028, "Member 'UOrionCurveTableSetManager::Mappings' has a wrong offset!");
static_assert(offsetof(UOrionCurveTableSetManager, ActiveSet) == 0x000038, "Member 'UOrionCurveTableSetManager::ActiveSet' has a wrong offset!");
static_assert(offsetof(UOrionCurveTableSetManager, Sets) == 0x000040, "Member 'UOrionCurveTableSetManager::Sets' has a wrong offset!");
static_assert(offsetof(UOrionCurveTableSetManager, DefaultSet) == 0x000050, "Member 'UOrionCurveTableSetManager::DefaultSet' has a wrong offset!");
static_assert(offsetof(UOrionCurveTableSetManager, BackupSet) == 0x0000C0, "Member 'UOrionCurveTableSetManager::BackupSet' has a wrong offset!");
static_assert(offsetof(UOrionCurveTableSetManager, ExplicitOverride) == 0x000130, "Member 'UOrionCurveTableSetManager::ExplicitOverride' has a wrong offset!");
static_assert(offsetof(UOrionCurveTableSetManager, DataIsPoisoned) == 0x000140, "Member 'UOrionCurveTableSetManager::DataIsPoisoned' has a wrong offset!");

// Class OrionGame.OrionAbilityTask_WaitMeleeImpact
// 0x0020 (0x00A0 - 0x0080)
class UOrionAbilityTask_WaitMeleeImpact final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   OnImpact;                                          // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x10];                                      // 0x0090(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOrionAbilityTask_WaitMeleeImpact* CreateWaitMovementModeChange(class UGameplayAbility* OwningAbility);

	void OnMeleeImpact(class AActor* OtherActor, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityTask_WaitMeleeImpact">();
	}
	static class UOrionAbilityTask_WaitMeleeImpact* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbilityTask_WaitMeleeImpact>();
	}
};
static_assert(alignof(UOrionAbilityTask_WaitMeleeImpact) == 0x000008, "Wrong alignment on UOrionAbilityTask_WaitMeleeImpact");
static_assert(sizeof(UOrionAbilityTask_WaitMeleeImpact) == 0x0000A0, "Wrong size on UOrionAbilityTask_WaitMeleeImpact");
static_assert(offsetof(UOrionAbilityTask_WaitMeleeImpact, OnImpact) == 0x000080, "Member 'UOrionAbilityTask_WaitMeleeImpact::OnImpact' has a wrong offset!");

// Class OrionGame.OrionQueryContext_ObjectiveLocation
// 0x0000 (0x0028 - 0x0028)
class UOrionQueryContext_ObjectiveLocation final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionQueryContext_ObjectiveLocation">();
	}
	static class UOrionQueryContext_ObjectiveLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionQueryContext_ObjectiveLocation>();
	}
};
static_assert(alignof(UOrionQueryContext_ObjectiveLocation) == 0x000008, "Wrong alignment on UOrionQueryContext_ObjectiveLocation");
static_assert(sizeof(UOrionQueryContext_ObjectiveLocation) == 0x000028, "Wrong size on UOrionQueryContext_ObjectiveLocation");

// Class OrionGame.OrionAbilityTask_WaitProjectileShutdown
// 0x0018 (0x0098 - 0x0080)
class UOrionAbilityTask_WaitProjectileShutdown final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   OnShutdown;                                        // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AOrionProjectile*                       Projectile;                                        // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UOrionAbilityTask_WaitProjectileShutdown* WaitProjectileShutdown(class UGameplayAbility* OwningAbility, class AOrionProjectile* Projectile_0);

	void OnShutdownCallback();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityTask_WaitProjectileShutdown">();
	}
	static class UOrionAbilityTask_WaitProjectileShutdown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbilityTask_WaitProjectileShutdown>();
	}
};
static_assert(alignof(UOrionAbilityTask_WaitProjectileShutdown) == 0x000008, "Wrong alignment on UOrionAbilityTask_WaitProjectileShutdown");
static_assert(sizeof(UOrionAbilityTask_WaitProjectileShutdown) == 0x000098, "Wrong size on UOrionAbilityTask_WaitProjectileShutdown");
static_assert(offsetof(UOrionAbilityTask_WaitProjectileShutdown, OnShutdown) == 0x000080, "Member 'UOrionAbilityTask_WaitProjectileShutdown::OnShutdown' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_WaitProjectileShutdown, Projectile) == 0x000090, "Member 'UOrionAbilityTask_WaitProjectileShutdown::Projectile' has a wrong offset!");

// Class OrionGame.OrionAbilityTask_WaitProjectileHitActor
// 0x0028 (0x00A8 - 0x0080)
class UOrionAbilityTask_WaitProjectileHitActor final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   OnShutdown;                                        // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnHitActor;                                        // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AOrionProjectile*                       Projectile;                                        // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UOrionAbilityTask_WaitProjectileHitActor* WaitProjectileHitActor(class UGameplayAbility* OwningAbility, class AOrionProjectile* Projectile_0);

	void OnHitActorCallback(const struct FHitResult& HitResult);
	void OnShutdownCallback();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityTask_WaitProjectileHitActor">();
	}
	static class UOrionAbilityTask_WaitProjectileHitActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbilityTask_WaitProjectileHitActor>();
	}
};
static_assert(alignof(UOrionAbilityTask_WaitProjectileHitActor) == 0x000008, "Wrong alignment on UOrionAbilityTask_WaitProjectileHitActor");
static_assert(sizeof(UOrionAbilityTask_WaitProjectileHitActor) == 0x0000A8, "Wrong size on UOrionAbilityTask_WaitProjectileHitActor");
static_assert(offsetof(UOrionAbilityTask_WaitProjectileHitActor, OnShutdown) == 0x000080, "Member 'UOrionAbilityTask_WaitProjectileHitActor::OnShutdown' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_WaitProjectileHitActor, OnHitActor) == 0x000090, "Member 'UOrionAbilityTask_WaitProjectileHitActor::OnHitActor' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_WaitProjectileHitActor, Projectile) == 0x0000A0, "Member 'UOrionAbilityTask_WaitProjectileHitActor::Projectile' has a wrong offset!");

// Class OrionGame.OrionAbilityTask_WaitProjectileStop
// 0x0028 (0x00A8 - 0x0080)
class UOrionAbilityTask_WaitProjectileStop final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   OnShutdown;                                        // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnStop;                                            // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AOrionProjectile*                       Projectile;                                        // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UOrionAbilityTask_WaitProjectileStop* WaitProjectileStop(class UGameplayAbility* OwningAbility, class AOrionProjectile* Projectile_0);

	void OnShutdownCallback();
	void OnStopCallback(const struct FHitResult& HitResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityTask_WaitProjectileStop">();
	}
	static class UOrionAbilityTask_WaitProjectileStop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbilityTask_WaitProjectileStop>();
	}
};
static_assert(alignof(UOrionAbilityTask_WaitProjectileStop) == 0x000008, "Wrong alignment on UOrionAbilityTask_WaitProjectileStop");
static_assert(sizeof(UOrionAbilityTask_WaitProjectileStop) == 0x0000A8, "Wrong size on UOrionAbilityTask_WaitProjectileStop");
static_assert(offsetof(UOrionAbilityTask_WaitProjectileStop, OnShutdown) == 0x000080, "Member 'UOrionAbilityTask_WaitProjectileStop::OnShutdown' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_WaitProjectileStop, OnStop) == 0x000090, "Member 'UOrionAbilityTask_WaitProjectileStop::OnStop' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_WaitProjectileStop, Projectile) == 0x0000A0, "Member 'UOrionAbilityTask_WaitProjectileStop::Projectile' has a wrong offset!");

// Class OrionGame.OrionBTDecorator_EnemyInPrimaryRange
// 0x0008 (0x0070 - 0x0068)
class UOrionBTDecorator_EnemyInPrimaryRange final : public UBTDecorator
{
public:
	bool                                          bOnlyIfPrimaryAbilityIsRanged;                     // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionBTDecorator_EnemyInPrimaryRange">();
	}
	static class UOrionBTDecorator_EnemyInPrimaryRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionBTDecorator_EnemyInPrimaryRange>();
	}
};
static_assert(alignof(UOrionBTDecorator_EnemyInPrimaryRange) == 0x000008, "Wrong alignment on UOrionBTDecorator_EnemyInPrimaryRange");
static_assert(sizeof(UOrionBTDecorator_EnemyInPrimaryRange) == 0x000070, "Wrong size on UOrionBTDecorator_EnemyInPrimaryRange");
static_assert(offsetof(UOrionBTDecorator_EnemyInPrimaryRange, bOnlyIfPrimaryAbilityIsRanged) == 0x000068, "Member 'UOrionBTDecorator_EnemyInPrimaryRange::bOnlyIfPrimaryAbilityIsRanged' has a wrong offset!");

// Class OrionGame.OrionAbilityTask_WaitSprintCancel
// 0x0020 (0x00A0 - 0x0080)
class UOrionAbilityTask_WaitSprintCancel final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   OnCancel;                                          // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AOrionCharHero*                         HeroAvatar;                                        // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOrionAbilityTask_WaitSprintCancel* WaitSprintCancel(class UGameplayAbility* OwningAbility);

	void HandleReplicatedEvent();
	void OnSprintDirectionChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityTask_WaitSprintCancel">();
	}
	static class UOrionAbilityTask_WaitSprintCancel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbilityTask_WaitSprintCancel>();
	}
};
static_assert(alignof(UOrionAbilityTask_WaitSprintCancel) == 0x000008, "Wrong alignment on UOrionAbilityTask_WaitSprintCancel");
static_assert(sizeof(UOrionAbilityTask_WaitSprintCancel) == 0x0000A0, "Wrong size on UOrionAbilityTask_WaitSprintCancel");
static_assert(offsetof(UOrionAbilityTask_WaitSprintCancel, OnCancel) == 0x000080, "Member 'UOrionAbilityTask_WaitSprintCancel::OnCancel' has a wrong offset!");
static_assert(offsetof(UOrionAbilityTask_WaitSprintCancel, HeroAvatar) == 0x000090, "Member 'UOrionAbilityTask_WaitSprintCancel::HeroAvatar' has a wrong offset!");

// Class OrionGame.OrionQueryContext_Teammates
// 0x0008 (0x0030 - 0x0028)
class UOrionQueryContext_Teammates final : public UEnvQueryContext
{
public:
	uint8                                         bIgnoreSelf : 1;                                   // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionQueryContext_Teammates">();
	}
	static class UOrionQueryContext_Teammates* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionQueryContext_Teammates>();
	}
};
static_assert(alignof(UOrionQueryContext_Teammates) == 0x000008, "Wrong alignment on UOrionQueryContext_Teammates");
static_assert(sizeof(UOrionQueryContext_Teammates) == 0x000030, "Wrong size on UOrionQueryContext_Teammates");

// Class OrionGame.OrionAbilityTask_WaitTowerTargetAcquired
// 0x0010 (0x0090 - 0x0080)
class UOrionAbilityTask_WaitTowerTargetAcquired final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   FireProjectile;                                    // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UOrionAbilityTask_WaitTowerTargetAcquired* WaitTowerTargetAcquired(class UGameplayAbility* OwningAbility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAbilityTask_WaitTowerTargetAcquired">();
	}
	static class UOrionAbilityTask_WaitTowerTargetAcquired* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAbilityTask_WaitTowerTargetAcquired>();
	}
};
static_assert(alignof(UOrionAbilityTask_WaitTowerTargetAcquired) == 0x000008, "Wrong alignment on UOrionAbilityTask_WaitTowerTargetAcquired");
static_assert(sizeof(UOrionAbilityTask_WaitTowerTargetAcquired) == 0x000090, "Wrong size on UOrionAbilityTask_WaitTowerTargetAcquired");
static_assert(offsetof(UOrionAbilityTask_WaitTowerTargetAcquired, FireProjectile) == 0x000080, "Member 'UOrionAbilityTask_WaitTowerTargetAcquired::FireProjectile' has a wrong offset!");

// Class OrionGame.OrionCheatManagerBase
// 0x0048 (0x00C0 - 0x0078)
class UOrionCheatManagerBase : public UCheatManager
{
public:
	uint8                                         Pad_78[0x10];                                      // 0x0078(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionLobbyBuilder*                     LobbyBuilder;                                      // 0x0088(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOrionTBRoboCaptain*                    RoboCaptain;                                       // 0x0090(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UOrionTBSoloRider*>              SoloRiders;                                        // 0x0098(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FOrionTBState                          TBState;                                           // 0x00A8(0x0010)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddTestNotification(int32 Count);
	void CalculateMaxMMRDelta(int32 SecondsInQueue, int32 YourMMR);
	void ClearCardOnboardingClientRecord();
	void ClearDeckBuilderOnboardingSeenClientRecord();
	void ClearNewCardsUpdateSeenClientRecord();
	void DraftPick(const class FString& HeroName);
	void DumpPlaylistInfos();
	void DumpPlaylistInfosVerbose();
	void DumpReservations();
	void DumpTeamInfo();
	void EComListCatalogOffers();
	void EComPurchaseOffer(const class FString& StorefrontName, int32 OfferIndex, int32 Quantity);
	void ForceHideMouseCursor();
	void ForceMouseCursor();
	void ForceRotationalContent(const class FString& Msg);
	void GenerateBotMatchup(const class FString& DifficultyName);
	void GetAccountMMR(const class FString& RatingType);
	void HideLoadingScreen();
	void HideTowerTargetingBeams();
	void IcmpPingAddr(const class FString& Target, float Timeout);
	void LBBugIt();
	void McpCheat();
	void McpGetUnredeemedCodes();
	void McpGetVersion();
	void McpIssueCodeToken(const class FString& TokenId);
	void McpLogin(const class FString& User, const class FString& Password);
	void McpLogout();
	void McpOpenGiftBox(const class FString& GiftBoxItemID);
	void McpRedeemPurchases();
	void McpRefreshProfile();
	void McpSimulateMatchComplete(bool bVictory, const class FString& HeroName);
	void McpSimulateMatchCompleteAbandon(bool bVictory, const class FString& HeroName);
	void McpTestSubmitLogs();
	void McpTestTeamBuilderGetMatchTimes();
	void McpTestTeamBuilderTeamSlots(const class FString& MatchmakingBucket, int32 SlotCount);
	void OrionDemoMode(bool bDemoMode);
	void OrionForceCharLOD(int32 LOD);
	void OrionWatermark(int32 Enable);
	void PingStress();
	void PlayVideo(const class FString& VideoID);
	void ReplaySetAperture(float FStop);
	void ReplaySetAutoExposure();
	void ReplaySetAutoFocus();
	void ReplaySetDroneCollision(bool bCollides);
	void ReplaySetManualExposure(float ExposureBias);
	void ReplaySetManualFocus(float NewFocusDistance);
	void ReplayShowFocusPlane(bool bShowFocusPlane);
	void ResetDraft();
	void ResetNewDawnVideo();
	void SetGamepadConfig(int32 ConfigIndex);
	void SetGamepadSensitivity(int32 YawIndex, int32 PitchIndex);
	void SetHomeScreenHero(const class FString& HeroName, const class FString& Skin, const class FString& SkinVariation);
	void SetInputMode(EOrionInputType Mode);
	void SetNumLobbyPlayers(int32 NumLobbyPlayers);
	void SetParallaxLerpSpeed(float LerpSpeed);
	void SetParallaxScaleFactor(float Factor);
	void SetPerfBots(const class FString& HeroList);
	void ShowLoadingScreen(int32 Mode);
	void ShowLoadingScreenByName(const class FString& ModeName);
	void TBAcceptSocialInvite(bool bAccept);
	void TBCancelMatchmaking();
	void TBCancelSlot(int32 SlotIdx);
	void TBCaptain();
	void TBCaptainAcceptSlot(int32 SlotIdx, bool bAccept);
	void TBClearDebugState();
	void TBDebugState();
	void TBLeaveTeam();
	void TBMultiSoloRider(int32 NumRiders);
	void TBQuickmatch(bool bCoopVsAI, const class FString& HeroName);
	void TBSetReady(bool bReady);
	void TBSetSlotChoice(int32 SlotIdx, int32 Position, int32 Role);
	void TBStartTeamMatchmaking();
	void TBUnlockSoloRider(const class FString& SoloriderUserId);
	void TestChangePartyPrivacy(bool bPrivate, bool bLeaderFriendsOnly, bool bLeaderInvitesOnly);
	void TestChangePartySize(int32 NewSize);
	void TestComputeBestTeamComp(const class FString& HeroListName);
	void TestGracefulShutdownServer(int32 ExitCode);
	void TestLobbyBuilderAcceptMatch(bool bAcceptMatch);
	void TestLobbyBuilderCancel();
	void TestLobbyBuilderMatchmake(int32 PlaylistId);
	void TestSoloRiderAcceptOrRejectInvite(bool bAccept, int32 RiderIdx);
	void TestSoloRiderCancelAdvertising();
	void TestSoloRiderStartAdvertising(const class FString& HeroName, int32 Position, int32 Role);
	void ToggleUI(int32 Enable);
	void TriggerAfk();
	void TriggerReturnFromAfk(int32 NewAfkPeriod);
	void UdpPingAddr(const class FString& Target, float Timeout);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCheatManagerBase">();
	}
	static class UOrionCheatManagerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionCheatManagerBase>();
	}
};
static_assert(alignof(UOrionCheatManagerBase) == 0x000008, "Wrong alignment on UOrionCheatManagerBase");
static_assert(sizeof(UOrionCheatManagerBase) == 0x0000C0, "Wrong size on UOrionCheatManagerBase");
static_assert(offsetof(UOrionCheatManagerBase, LobbyBuilder) == 0x000088, "Member 'UOrionCheatManagerBase::LobbyBuilder' has a wrong offset!");
static_assert(offsetof(UOrionCheatManagerBase, RoboCaptain) == 0x000090, "Member 'UOrionCheatManagerBase::RoboCaptain' has a wrong offset!");
static_assert(offsetof(UOrionCheatManagerBase, SoloRiders) == 0x000098, "Member 'UOrionCheatManagerBase::SoloRiders' has a wrong offset!");
static_assert(offsetof(UOrionCheatManagerBase, TBState) == 0x0000A8, "Member 'UOrionCheatManagerBase::TBState' has a wrong offset!");

// Class OrionGame.OrionUserWidgetBase
// 0x00B8 (0x02B8 - 0x0200)
#pragma pack(push, 0x1)
class alignas(0x08) UOrionUserWidgetBase : public UUserWidget
{
public:
	class FName                                   AnalyticsTrackingOverrideName;                     // 0x0200(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bConsumePointerInput;                              // 0x0208(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_209[0x7];                                      // 0x0209(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   OrionTooltipTitleText;                             // 0x0210(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   OrionTooltipText;                                  // 0x0228(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	EMenuPlacement                                TooltipAnchorPlacement;                            // 0x0240(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_241[0x7];                                      // 0x0241(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   WidgetId;                                          // 0x0248(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMenuPlacement                                AttachedMessagePlacement;                          // 0x0250(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWrapWithInvalidationPanel;                        // 0x0251(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrionUIAnalyticsTrackingLevel                MouseEnteredTrackingLevel;                         // 0x0252(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrionUIAnalyticsTrackingLevel                MouseLeftTrackingLevel;                            // 0x0253(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_254[0x4C];                                     // 0x0254(0x004C)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionTooltipAnchor*                    Anchor_TooltipArea;                                // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A8[0x10];                                     // 0x02A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FireAnalyticsEvent(EOrionUIAnalyticsTrackingLevel EventTrackingLevel, const class FString& WidgetType, const class FString& EventName);
	void FireAnalyticsEventWithParam(EOrionUIAnalyticsTrackingLevel EventTrackingLevel, const class FString& WidgetType, const class FString& EventName, const class FString& ParamName, const class FString& ParamValue);
	bool InitTooltipAnchor();
	void RequestHideTooltip();
	void RequestShowTooltip();
	void SetBasicTooltipInfo(const class FText& NewTooltipTitle, const class FText& NewTooltipText);
	void SetBasicTooltipText(const class FText& NewTooltipText);
	void SetBasicTooltipTitle(const class FText& NewTooltipTitle);
	void SetTooltipAnchorPlacement(EMenuPlacement TooltipPlacement);

	class UWidget* BP_OnGetTooltipWidget() const;
	const class FText GetBasicTooltipText() const;
	class UOrionClientSettingsRecord* GetClientSettings() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionUserWidgetBase">();
	}
	static class UOrionUserWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionUserWidgetBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(UOrionUserWidgetBase) == 0x000008, "Wrong alignment on UOrionUserWidgetBase");
static_assert(sizeof(UOrionUserWidgetBase) == 0x0002B8, "Wrong size on UOrionUserWidgetBase");
static_assert(offsetof(UOrionUserWidgetBase, AnalyticsTrackingOverrideName) == 0x000200, "Member 'UOrionUserWidgetBase::AnalyticsTrackingOverrideName' has a wrong offset!");
static_assert(offsetof(UOrionUserWidgetBase, bConsumePointerInput) == 0x000208, "Member 'UOrionUserWidgetBase::bConsumePointerInput' has a wrong offset!");
static_assert(offsetof(UOrionUserWidgetBase, OrionTooltipTitleText) == 0x000210, "Member 'UOrionUserWidgetBase::OrionTooltipTitleText' has a wrong offset!");
static_assert(offsetof(UOrionUserWidgetBase, OrionTooltipText) == 0x000228, "Member 'UOrionUserWidgetBase::OrionTooltipText' has a wrong offset!");
static_assert(offsetof(UOrionUserWidgetBase, TooltipAnchorPlacement) == 0x000240, "Member 'UOrionUserWidgetBase::TooltipAnchorPlacement' has a wrong offset!");
static_assert(offsetof(UOrionUserWidgetBase, WidgetId) == 0x000248, "Member 'UOrionUserWidgetBase::WidgetId' has a wrong offset!");
static_assert(offsetof(UOrionUserWidgetBase, AttachedMessagePlacement) == 0x000250, "Member 'UOrionUserWidgetBase::AttachedMessagePlacement' has a wrong offset!");
static_assert(offsetof(UOrionUserWidgetBase, bWrapWithInvalidationPanel) == 0x000251, "Member 'UOrionUserWidgetBase::bWrapWithInvalidationPanel' has a wrong offset!");
static_assert(offsetof(UOrionUserWidgetBase, MouseEnteredTrackingLevel) == 0x000252, "Member 'UOrionUserWidgetBase::MouseEnteredTrackingLevel' has a wrong offset!");
static_assert(offsetof(UOrionUserWidgetBase, MouseLeftTrackingLevel) == 0x000253, "Member 'UOrionUserWidgetBase::MouseLeftTrackingLevel' has a wrong offset!");
static_assert(offsetof(UOrionUserWidgetBase, Anchor_TooltipArea) == 0x0002A0, "Member 'UOrionUserWidgetBase::Anchor_TooltipArea' has a wrong offset!");

// Class OrionGame.OrionActivatableWidget
// 0x0190 (0x0448 - 0x02B8)
#pragma pack(push, 0x1)
class alignas(0x08) UOrionActivatableWidget : public UOrionUserWidgetBase
{
public:
	UMulticastDelegateProperty_                   OnWidgetActivated;                                 // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C8[0x78];                                     // 0x02C8(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnWidgetDeactivated;                               // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_350[0x70];                                     // 0x0350(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAutoActivate;                                     // 0x03C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C1[0x7];                                      // 0x03C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FButtonLegendItem>              ButtonLegend;                                      // 0x03C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	EBackHandlerType                              BackHandlerType;                                   // 0x03D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsActive;                                         // 0x03D9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrionUIAnalyticsTrackingLevel                ActivatedTrackingLevel;                            // 0x03DA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrionUIAnalyticsTrackingLevel                DeactivatedTrackingLevel;                          // 0x03DB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3DC[0x4];                                      // 0x03DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GroupID;                                           // 0x03E0(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F0[0x58];                                     // 0x03F0(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateWidget();
	void AddDeactivateAnalyticsParam(const class FString& ParamName, const class FString& ParamValue);
	void DeactivateWidget();
	void OnActivated();
	void OnDeactivated();
	bool OnHandleBackAction();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionActivatableWidget">();
	}
	static class UOrionActivatableWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionActivatableWidget>();
	}
};
#pragma pack(pop)
static_assert(alignof(UOrionActivatableWidget) == 0x000008, "Wrong alignment on UOrionActivatableWidget");
static_assert(sizeof(UOrionActivatableWidget) == 0x000448, "Wrong size on UOrionActivatableWidget");
static_assert(offsetof(UOrionActivatableWidget, OnWidgetActivated) == 0x0002B8, "Member 'UOrionActivatableWidget::OnWidgetActivated' has a wrong offset!");
static_assert(offsetof(UOrionActivatableWidget, OnWidgetDeactivated) == 0x000340, "Member 'UOrionActivatableWidget::OnWidgetDeactivated' has a wrong offset!");
static_assert(offsetof(UOrionActivatableWidget, bAutoActivate) == 0x0003C0, "Member 'UOrionActivatableWidget::bAutoActivate' has a wrong offset!");
static_assert(offsetof(UOrionActivatableWidget, ButtonLegend) == 0x0003C8, "Member 'UOrionActivatableWidget::ButtonLegend' has a wrong offset!");
static_assert(offsetof(UOrionActivatableWidget, BackHandlerType) == 0x0003D8, "Member 'UOrionActivatableWidget::BackHandlerType' has a wrong offset!");
static_assert(offsetof(UOrionActivatableWidget, bIsActive) == 0x0003D9, "Member 'UOrionActivatableWidget::bIsActive' has a wrong offset!");
static_assert(offsetof(UOrionActivatableWidget, ActivatedTrackingLevel) == 0x0003DA, "Member 'UOrionActivatableWidget::ActivatedTrackingLevel' has a wrong offset!");
static_assert(offsetof(UOrionActivatableWidget, DeactivatedTrackingLevel) == 0x0003DB, "Member 'UOrionActivatableWidget::DeactivatedTrackingLevel' has a wrong offset!");
static_assert(offsetof(UOrionActivatableWidget, GroupID) == 0x0003E0, "Member 'UOrionActivatableWidget::GroupID' has a wrong offset!");

// Class OrionGame.OrionActorLoadingWidget
// 0x0010 (0x0210 - 0x0200)
class UOrionActorLoadingWidget : public UUserWidget
{
public:
	class UOrionTextBlock*                        Text_ActorName;                                    // 0x0200(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Image_ActorIcon;                                   // 0x0208(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionActorLoadingWidget">();
	}
	static class UOrionActorLoadingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionActorLoadingWidget>();
	}
};
static_assert(alignof(UOrionActorLoadingWidget) == 0x000008, "Wrong alignment on UOrionActorLoadingWidget");
static_assert(sizeof(UOrionActorLoadingWidget) == 0x000210, "Wrong size on UOrionActorLoadingWidget");
static_assert(offsetof(UOrionActorLoadingWidget, Text_ActorName) == 0x000200, "Member 'UOrionActorLoadingWidget::Text_ActorName' has a wrong offset!");
static_assert(offsetof(UOrionActorLoadingWidget, Image_ActorIcon) == 0x000208, "Member 'UOrionActorLoadingWidget::Image_ActorIcon' has a wrong offset!");

// Class OrionGame.OrionTargetingMode_FacetShape
// 0x0358 (0x0748 - 0x03F0)
class AOrionTargetingMode_FacetShape : public AOrionTargetingMode_Base
{
public:
	struct FOrionTargetingModePlacement           Placement;                                         // 0x03F0(0x0268)(Edit, NativeAccessSpecifierPublic)
	struct FOrionShapeDefinition                  ShapeDefinition;                                   // 0x0658(0x0010)(Edit, NativeAccessSpecifierPublic)
	class UOrionShape*                            Shape;                                             // 0x0668(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionActorPrioritizer                 Prioritizer;                                       // 0x0670(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bPrototypeDisplayEnabled;                          // 0x0678(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_679[0x7];                                      // 0x0679(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterial*                              PrototypeDisplayMeshMaterialUnblocked;             // 0x0680(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              PrototypeDisplayMeshMaterialBlocked;               // 0x0688(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPrototypeMeshVisible;                             // 0x0690(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_691[0x7];                                      // 0x0691(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AGameplayAbilityWorldReticle> ReticleClass;                                      // 0x0698(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReticleUsesTargetScale;                           // 0x06A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreviousConfirmAllowed;                           // 0x06A1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitializeConfirmAllowed;                         // 0x06A2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPositioningFailed;                                // 0x06A3(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A4[0x4];                                      // 0x06A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCustomMeshComponent*                   PrototypeDisplayMesh;                              // 0x06A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTickIfNotLocallyControlled;                       // 0x06B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActivelyTargeting;                              // 0x06B1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6B2[0x6];                                      // 0x06B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAbilitySystemComponent*           AbilitySystem;                                     // 0x06B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C0[0x8];                                      // 0x06C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAbility*                          AbilityCDO;                                        // 0x06C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D0[0x68];                                     // 0x06D0(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ViewLockTarget;                                    // 0x0738(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_740[0x8];                                      // 0x0740(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnConfirmAllowedChange(bool ConfirmAllowed);
	void OnFacetBeamBuilt(const struct FVector& Start, const struct FVector& End, float Radius);
	void OnFacetBoxBuilt(const struct FVector& MinBounds, const struct FVector& MaxBounds);
	void OnFacetCharacterBuilt(float Radius, float HalfHeight);
	void OnFacetCylinderBuilt(float Radius, float HeightMin, float HeightMax);
	void OnFacetSectorBuilt(float AngleHorizontal, float RadiusMin, float RadiusMax, float HeightMin, float HeightMax);
	void OnFacetSphereBuilt(float Radius);
	void OnStartBuildingFacets();
	void OnTargetingModeActivate();
	void OnTargetingModeCancel();
	void OnTargetingModeConfirm();
	void SetPrototypeMeshVisibility(const bool In_bSetVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTargetingMode_FacetShape">();
	}
	static class AOrionTargetingMode_FacetShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionTargetingMode_FacetShape>();
	}
};
static_assert(alignof(AOrionTargetingMode_FacetShape) == 0x000008, "Wrong alignment on AOrionTargetingMode_FacetShape");
static_assert(sizeof(AOrionTargetingMode_FacetShape) == 0x000748, "Wrong size on AOrionTargetingMode_FacetShape");
static_assert(offsetof(AOrionTargetingMode_FacetShape, Placement) == 0x0003F0, "Member 'AOrionTargetingMode_FacetShape::Placement' has a wrong offset!");
static_assert(offsetof(AOrionTargetingMode_FacetShape, ShapeDefinition) == 0x000658, "Member 'AOrionTargetingMode_FacetShape::ShapeDefinition' has a wrong offset!");
static_assert(offsetof(AOrionTargetingMode_FacetShape, Shape) == 0x000668, "Member 'AOrionTargetingMode_FacetShape::Shape' has a wrong offset!");
static_assert(offsetof(AOrionTargetingMode_FacetShape, Prioritizer) == 0x000670, "Member 'AOrionTargetingMode_FacetShape::Prioritizer' has a wrong offset!");
static_assert(offsetof(AOrionTargetingMode_FacetShape, bPrototypeDisplayEnabled) == 0x000678, "Member 'AOrionTargetingMode_FacetShape::bPrototypeDisplayEnabled' has a wrong offset!");
static_assert(offsetof(AOrionTargetingMode_FacetShape, PrototypeDisplayMeshMaterialUnblocked) == 0x000680, "Member 'AOrionTargetingMode_FacetShape::PrototypeDisplayMeshMaterialUnblocked' has a wrong offset!");
static_assert(offsetof(AOrionTargetingMode_FacetShape, PrototypeDisplayMeshMaterialBlocked) == 0x000688, "Member 'AOrionTargetingMode_FacetShape::PrototypeDisplayMeshMaterialBlocked' has a wrong offset!");
static_assert(offsetof(AOrionTargetingMode_FacetShape, bPrototypeMeshVisible) == 0x000690, "Member 'AOrionTargetingMode_FacetShape::bPrototypeMeshVisible' has a wrong offset!");
static_assert(offsetof(AOrionTargetingMode_FacetShape, ReticleClass) == 0x000698, "Member 'AOrionTargetingMode_FacetShape::ReticleClass' has a wrong offset!");
static_assert(offsetof(AOrionTargetingMode_FacetShape, bReticleUsesTargetScale) == 0x0006A0, "Member 'AOrionTargetingMode_FacetShape::bReticleUsesTargetScale' has a wrong offset!");
static_assert(offsetof(AOrionTargetingMode_FacetShape, bPreviousConfirmAllowed) == 0x0006A1, "Member 'AOrionTargetingMode_FacetShape::bPreviousConfirmAllowed' has a wrong offset!");
static_assert(offsetof(AOrionTargetingMode_FacetShape, bInitializeConfirmAllowed) == 0x0006A2, "Member 'AOrionTargetingMode_FacetShape::bInitializeConfirmAllowed' has a wrong offset!");
static_assert(offsetof(AOrionTargetingMode_FacetShape, bPositioningFailed) == 0x0006A3, "Member 'AOrionTargetingMode_FacetShape::bPositioningFailed' has a wrong offset!");
static_assert(offsetof(AOrionTargetingMode_FacetShape, PrototypeDisplayMesh) == 0x0006A8, "Member 'AOrionTargetingMode_FacetShape::PrototypeDisplayMesh' has a wrong offset!");
static_assert(offsetof(AOrionTargetingMode_FacetShape, bTickIfNotLocallyControlled) == 0x0006B0, "Member 'AOrionTargetingMode_FacetShape::bTickIfNotLocallyControlled' has a wrong offset!");
static_assert(offsetof(AOrionTargetingMode_FacetShape, bIsActivelyTargeting) == 0x0006B1, "Member 'AOrionTargetingMode_FacetShape::bIsActivelyTargeting' has a wrong offset!");
static_assert(offsetof(AOrionTargetingMode_FacetShape, AbilitySystem) == 0x0006B8, "Member 'AOrionTargetingMode_FacetShape::AbilitySystem' has a wrong offset!");
static_assert(offsetof(AOrionTargetingMode_FacetShape, AbilityCDO) == 0x0006C8, "Member 'AOrionTargetingMode_FacetShape::AbilityCDO' has a wrong offset!");
static_assert(offsetof(AOrionTargetingMode_FacetShape, ViewLockTarget) == 0x000738, "Member 'AOrionTargetingMode_FacetShape::ViewLockTarget' has a wrong offset!");

// Class OrionGame.OrionAIAbilityTargetInterface
// 0x0000 (0x0028 - 0x0028)
class IOrionAIAbilityTargetInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAIAbilityTargetInterface">();
	}
	static class IOrionAIAbilityTargetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOrionAIAbilityTargetInterface>();
	}
};
static_assert(alignof(IOrionAIAbilityTargetInterface) == 0x000008, "Wrong alignment on IOrionAIAbilityTargetInterface");
static_assert(sizeof(IOrionAIAbilityTargetInterface) == 0x000028, "Wrong size on IOrionAIAbilityTargetInterface");

// Class OrionGame.PlayerControllerCommon
// 0x00A0 (0x0710 - 0x0670)
class APlayerControllerCommon : public APlayerController
{
public:
	class UMcpProfileGroup*                       McpProfileGroup;                                   // 0x0670(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMcpProfile*                            MainMcpProfile;                                    // 0x0678(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SynchronizingWithMcpCount;                         // 0x0680(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_684[0x8C];                                     // 0x0684(0x008C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientSetInviteFlags(const struct FJoinabilitySettings& Settings);
	void ClientUpdateRichPresence(ERichPresenceStateChange RichPresenceChange, bool bImportant);
	void ServerReturnToMainMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerControllerCommon">();
	}
	static class APlayerControllerCommon* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerControllerCommon>();
	}
};
static_assert(alignof(APlayerControllerCommon) == 0x000008, "Wrong alignment on APlayerControllerCommon");
static_assert(sizeof(APlayerControllerCommon) == 0x000710, "Wrong size on APlayerControllerCommon");
static_assert(offsetof(APlayerControllerCommon, McpProfileGroup) == 0x000670, "Member 'APlayerControllerCommon::McpProfileGroup' has a wrong offset!");
static_assert(offsetof(APlayerControllerCommon, MainMcpProfile) == 0x000678, "Member 'APlayerControllerCommon::MainMcpProfile' has a wrong offset!");
static_assert(offsetof(APlayerControllerCommon, SynchronizingWithMcpCount) == 0x000680, "Member 'APlayerControllerCommon::SynchronizingWithMcpCount' has a wrong offset!");

// Class OrionGame.OrionPlayerController_Base
// 0x0240 (0x0950 - 0x0710)
class AOrionPlayerController_Base : public APlayerControllerCommon
{
public:
	uint8                                         Pad_710[0x18];                                     // 0x0710(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         IdleKickTime;                                      // 0x0728(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72C[0x4];                                      // 0x072C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionHeartbeatManager*                 HeartbeatManager;                                  // 0x0730(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_738[0x48];                                     // 0x0738(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionPlayerInput*                      OrionPlayerInput;                                  // 0x0780(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HideLoadingScreenDelay;                            // 0x0788(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_78C[0xE];                                      // 0x078C(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	ESpectatorCameraType                          CurrentSpectatorMode;                              // 0x079A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESpectatorCameraType                          LastSpectatorViewMode;                             // 0x079B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CurrentCameraIndex;                                // 0x079C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CurrentHeroIndex;                                  // 0x07A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7A4[0x4];                                      // 0x07A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrionArenaCamera*                      ViewedArenaCam;                                    // 0x07A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7B0[0x20];                                     // 0x07B0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionClientBotManager_Base*            BotManager;                                        // 0x07D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7D8[0x10];                                     // 0x07D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionClientPilotComponent_Base*        PilotManager;                                      // 0x07E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7F0[0x160];                                    // 0x07F0(0x0160)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cheat(const class FString& Msg);
	void CheatAll(const class FString& Msg);
	void ClientDisplayCheatDetectedMessage(const class FString& CheatMessage);
	void ClientExecCheatAll(const class FString& Msg);
	void ClientFollowTarget(class AActor* InTarget);
	void ClientReceiveLoot(const struct FOrionLootNotification& LootNotification);
	void ClientRegisterInitialAnalytics();
	void ClientRegisterWithParty();
	void ClientReturnToMainMenuReason(EReturnToMainMenuReason Reason);
	void ClientSendPartyJoinInfoToPlayer(const class FString& JoinInfoStr);
	void ClientStayWithParty(bool bStayWithSocialParty, bool bStayWithTeamParty);
	void FollowedPlayerDestroyed(class AActor* DestroyedActor);
	void FollowedPlayerDied(class AOrionChar* DeadChar);
	void FollowedPlayerKilled(class AOrionChar* DeadChar, class AController* Killer, class AActor* DamageCauser);
	void LocalUserRequestingReturnToMainMenu(EReturnToMainMenuReason Reason);
	void OnMenuEntered(const class FString& MenuName);
	void OnMenuExited();
	void ServerChangeNextViewTarget();
	void ServerChangePreviousViewTarget();
	void ServerChangeTeam(EOrionTeam TeamIndex);
	void ServerChangeViewMode();
	void ServerExecCheat(const class FString& Msg);
	void ServerExecCheatAll(const class FString& Msg);
	void ServerRegisterInitialAnalytics(const struct FOrionPlayerInitialAnalytics& InInitialAnalytics);
	void ServerSendPartyJoinInfoToPlayer(const struct FUniqueNetIdRepl& RecipientId, const class FString& JoinInfoStr);
	void ServerSetPartyOwner(const struct FUniqueNetIdRepl& PartyOwnerUniqueId);
	void ServerSetReadyToStartMatch(bool bReady);
	void ServerTeamChatRoomReady(const class FString& ChatRoomId);

	class UOrionClientSettingsRecord* GetOrionClientSettings() const;
	EOrionTeam GetTeamNum() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPlayerController_Base">();
	}
	static class AOrionPlayerController_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionPlayerController_Base>();
	}
};
static_assert(alignof(AOrionPlayerController_Base) == 0x000008, "Wrong alignment on AOrionPlayerController_Base");
static_assert(sizeof(AOrionPlayerController_Base) == 0x000950, "Wrong size on AOrionPlayerController_Base");
static_assert(offsetof(AOrionPlayerController_Base, IdleKickTime) == 0x000728, "Member 'AOrionPlayerController_Base::IdleKickTime' has a wrong offset!");
static_assert(offsetof(AOrionPlayerController_Base, HeartbeatManager) == 0x000730, "Member 'AOrionPlayerController_Base::HeartbeatManager' has a wrong offset!");
static_assert(offsetof(AOrionPlayerController_Base, OrionPlayerInput) == 0x000780, "Member 'AOrionPlayerController_Base::OrionPlayerInput' has a wrong offset!");
static_assert(offsetof(AOrionPlayerController_Base, HideLoadingScreenDelay) == 0x000788, "Member 'AOrionPlayerController_Base::HideLoadingScreenDelay' has a wrong offset!");
static_assert(offsetof(AOrionPlayerController_Base, CurrentSpectatorMode) == 0x00079A, "Member 'AOrionPlayerController_Base::CurrentSpectatorMode' has a wrong offset!");
static_assert(offsetof(AOrionPlayerController_Base, LastSpectatorViewMode) == 0x00079B, "Member 'AOrionPlayerController_Base::LastSpectatorViewMode' has a wrong offset!");
static_assert(offsetof(AOrionPlayerController_Base, CurrentCameraIndex) == 0x00079C, "Member 'AOrionPlayerController_Base::CurrentCameraIndex' has a wrong offset!");
static_assert(offsetof(AOrionPlayerController_Base, CurrentHeroIndex) == 0x0007A0, "Member 'AOrionPlayerController_Base::CurrentHeroIndex' has a wrong offset!");
static_assert(offsetof(AOrionPlayerController_Base, ViewedArenaCam) == 0x0007A8, "Member 'AOrionPlayerController_Base::ViewedArenaCam' has a wrong offset!");
static_assert(offsetof(AOrionPlayerController_Base, BotManager) == 0x0007D0, "Member 'AOrionPlayerController_Base::BotManager' has a wrong offset!");
static_assert(offsetof(AOrionPlayerController_Base, PilotManager) == 0x0007E8, "Member 'AOrionPlayerController_Base::PilotManager' has a wrong offset!");

// Class OrionGame.OrionAIController
// 0x0040 (0x0450 - 0x0410)
class AOrionAIController : public AAIController
{
public:
	uint8                                         Pad_410[0x20];                                     // 0x0410(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAIFormation*                      MyFormation;                                       // 0x0430(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 CurrentTarget;                                     // 0x0438(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_440[0x10];                                     // 0x0440(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UOrionAIFormation* GetAIFormation() const;
	class AOrionChar* GetOrionChar() const;
	EOrionTeam GetTeamNum() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAIController">();
	}
	static class AOrionAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionAIController>();
	}
};
static_assert(alignof(AOrionAIController) == 0x000008, "Wrong alignment on AOrionAIController");
static_assert(sizeof(AOrionAIController) == 0x000450, "Wrong size on AOrionAIController");
static_assert(offsetof(AOrionAIController, MyFormation) == 0x000430, "Member 'AOrionAIController::MyFormation' has a wrong offset!");
static_assert(offsetof(AOrionAIController, CurrentTarget) == 0x000438, "Member 'AOrionAIController::CurrentTarget' has a wrong offset!");

// Class OrionGame.OrionTBSoloRider
// 0x03F8 (0x0420 - 0x0028)
class UOrionTBSoloRider final : public UObject
{
public:
	float                                         ApproveTeamTime;                                   // 0x0028(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C[0x10];                                      // 0x002C(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ApprovalTimeRemaining;                             // 0x003C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EOrionTBSoloRiderResult                       PendingResult;                                     // 0x0040(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EOrionTBSoloRiderState                        CurrentState;                                      // 0x0041(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionTBParams                         Params_0;                                          // 0x0048(0x0160)(Transient, NativeAccessSpecifierPrivate)
	int32                                         SoloRiderMMR;                                      // 0x01A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1AC[0x274];                                    // 0x01AC(0x0274)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTBSoloRider">();
	}
	static class UOrionTBSoloRider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionTBSoloRider>();
	}
};
static_assert(alignof(UOrionTBSoloRider) == 0x000008, "Wrong alignment on UOrionTBSoloRider");
static_assert(sizeof(UOrionTBSoloRider) == 0x000420, "Wrong size on UOrionTBSoloRider");
static_assert(offsetof(UOrionTBSoloRider, ApproveTeamTime) == 0x000028, "Member 'UOrionTBSoloRider::ApproveTeamTime' has a wrong offset!");
static_assert(offsetof(UOrionTBSoloRider, ApprovalTimeRemaining) == 0x00003C, "Member 'UOrionTBSoloRider::ApprovalTimeRemaining' has a wrong offset!");
static_assert(offsetof(UOrionTBSoloRider, PendingResult) == 0x000040, "Member 'UOrionTBSoloRider::PendingResult' has a wrong offset!");
static_assert(offsetof(UOrionTBSoloRider, CurrentState) == 0x000041, "Member 'UOrionTBSoloRider::CurrentState' has a wrong offset!");
static_assert(offsetof(UOrionTBSoloRider, Params_0) == 0x000048, "Member 'UOrionTBSoloRider::Params_0' has a wrong offset!");
static_assert(offsetof(UOrionTBSoloRider, SoloRiderMMR) == 0x0001A8, "Member 'UOrionTBSoloRider::SoloRiderMMR' has a wrong offset!");

// Class OrionGame.OrionAIBot
// 0x0800 (0x0C50 - 0x0450)
class AOrionAIBot : public AOrionAIController
{
public:
	uint8                                         Pad_450[0x10];                                     // 0x0450(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAbilitySystemComponent*           OrionAbilitySysComponent;                          // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_468[0x1C0];                                    // 0x0468(0x01C0)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrionCharHero*                         MyHeroPawn;                                        // 0x0628(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAIEnemy                               CurrentEnemy;                                      // 0x0630(0x0010)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class AOrionChar*                             ClosestEnemy;                                      // 0x0640(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBotEnemySelection                     EnemySelection;                                    // 0x0648(0x0028)(BlueprintVisible, Transient, Protected, NativeAccessSpecifierProtected)
	class AOrionCharHero*                         FriendToSupport;                                   // 0x0670(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FEQSParametrizedQueryExecutionRequest  EnemySelectionEQSRequest;                          // 0x0678(0x0048)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C0[0x44];                                     // 0x06C0(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilitySpecHandle             CurrentCombatAbilityHandle;                        // 0x0704(0x0004)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayAbilitySpecHandle             CurrentSupportAbilityHandle;                       // 0x0708(0x0004)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_70C[0x4];                                      // 0x070C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAIBotHandledTask>              TasksBeingHandled;                                 // 0x0710(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UAIScriptedBehavior*                    ScriptedBehavior;                                  // 0x0720(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOrionAISystem*                         OrionAISys;                                        // 0x0728(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AOrionPlayerState_Game*                 CachedOrionPlayerState;                            // 0x0730(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOrionPathFollowingComponent*           OrionPathFollowingComp;                            // 0x0738(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOrionAIBotPerceptionComponent*         BotPerceptionComponent;                            // 0x0740(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBotObjective*                          CurrentObjective;                                  // 0x0748(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_750[0x30];                                     // 0x0750(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UBotObjective*                          NextObjective;                                     // 0x0780(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_788[0x30];                                     // 0x0788(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UAITeamComm*                            TeamComm;                                          // 0x07B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOrionAICommander*                      AICommander;                                       // 0x07C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C8[0x1C8];                                    // 0x07C8(0x01C8)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HomeBaseLocationApproximation;                     // 0x0990(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_99C[0x2B4];                                    // 0x099C(0x02B4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_SetAbilityToUse(const struct FGameplayAbilitySpec& AbilitySpec);
	void K2_SetDifficultySettings(const struct FAIBotDifficultySettings& Settings);
	void K2_SetEnemy(class AOrionChar* NewEnemy);
	void K2_SetIgnoreEnemies(const bool bNewIgnoreEnemies);
	void OnCharacterDied(class AOrionChar* DeadChar, class AController* Killer, class AActor* DamageCauser);
	bool PlaceWard();
	bool Recall(const bool bFailIfUnsafeToRecall);

	bool CanActivateAbility(const struct FGameplayTagContainer& AbilityTags, bool bRequirePerfectMatch) const;
	struct FVector GetAvatarLocation() const;
	float GetCurrentLaneFrontWaveTeamProgress() const;
	EAITeamCommEvent GetCurrentObjectiveTeamCommEvent() const;
	class UAIScriptedBehavior* GetCurrentScriptedBehavior() const;
	float GetLaneProgress() const;
	struct FVector GetSpawnLocation() const;
	bool HasUsableAbilityAgainstCurrentEnemy() const;
	bool IsAbilityInRage(const struct FVector& WorldLocation, TSubclassOf<class UOrionAbility> AbilityClass) const;
	bool IsSafeToRecall() const;
	ELaneRoleSlot K2_GetAssignedRole() const;
	struct FAIBotDifficultySettings K2_GetDifficultySettings() const;
	class AActor* K2_GetEnemyCharacter() const;
	class UEnvQuery* K2_GetEnemySelectionQuery() const;
	int32 K2_GetLaneID() const;
	class AActor* K2_GetObjectiveActor() const;
	struct FGameplayAbilitySpecHandle K2_GetPrimaryAttackHandle() const;
	bool K2_IsInsideTurret() const;
	bool K2_IsSafeToApproachOffensiveLaneGoal() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAIBot">();
	}
	static class AOrionAIBot* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionAIBot>();
	}
};
static_assert(alignof(AOrionAIBot) == 0x000008, "Wrong alignment on AOrionAIBot");
static_assert(sizeof(AOrionAIBot) == 0x000C50, "Wrong size on AOrionAIBot");
static_assert(offsetof(AOrionAIBot, OrionAbilitySysComponent) == 0x000460, "Member 'AOrionAIBot::OrionAbilitySysComponent' has a wrong offset!");
static_assert(offsetof(AOrionAIBot, MyHeroPawn) == 0x000628, "Member 'AOrionAIBot::MyHeroPawn' has a wrong offset!");
static_assert(offsetof(AOrionAIBot, CurrentEnemy) == 0x000630, "Member 'AOrionAIBot::CurrentEnemy' has a wrong offset!");
static_assert(offsetof(AOrionAIBot, ClosestEnemy) == 0x000640, "Member 'AOrionAIBot::ClosestEnemy' has a wrong offset!");
static_assert(offsetof(AOrionAIBot, EnemySelection) == 0x000648, "Member 'AOrionAIBot::EnemySelection' has a wrong offset!");
static_assert(offsetof(AOrionAIBot, FriendToSupport) == 0x000670, "Member 'AOrionAIBot::FriendToSupport' has a wrong offset!");
static_assert(offsetof(AOrionAIBot, EnemySelectionEQSRequest) == 0x000678, "Member 'AOrionAIBot::EnemySelectionEQSRequest' has a wrong offset!");
static_assert(offsetof(AOrionAIBot, CurrentCombatAbilityHandle) == 0x000704, "Member 'AOrionAIBot::CurrentCombatAbilityHandle' has a wrong offset!");
static_assert(offsetof(AOrionAIBot, CurrentSupportAbilityHandle) == 0x000708, "Member 'AOrionAIBot::CurrentSupportAbilityHandle' has a wrong offset!");
static_assert(offsetof(AOrionAIBot, TasksBeingHandled) == 0x000710, "Member 'AOrionAIBot::TasksBeingHandled' has a wrong offset!");
static_assert(offsetof(AOrionAIBot, ScriptedBehavior) == 0x000720, "Member 'AOrionAIBot::ScriptedBehavior' has a wrong offset!");
static_assert(offsetof(AOrionAIBot, OrionAISys) == 0x000728, "Member 'AOrionAIBot::OrionAISys' has a wrong offset!");
static_assert(offsetof(AOrionAIBot, CachedOrionPlayerState) == 0x000730, "Member 'AOrionAIBot::CachedOrionPlayerState' has a wrong offset!");
static_assert(offsetof(AOrionAIBot, OrionPathFollowingComp) == 0x000738, "Member 'AOrionAIBot::OrionPathFollowingComp' has a wrong offset!");
static_assert(offsetof(AOrionAIBot, BotPerceptionComponent) == 0x000740, "Member 'AOrionAIBot::BotPerceptionComponent' has a wrong offset!");
static_assert(offsetof(AOrionAIBot, CurrentObjective) == 0x000748, "Member 'AOrionAIBot::CurrentObjective' has a wrong offset!");
static_assert(offsetof(AOrionAIBot, NextObjective) == 0x000780, "Member 'AOrionAIBot::NextObjective' has a wrong offset!");
static_assert(offsetof(AOrionAIBot, TeamComm) == 0x0007B8, "Member 'AOrionAIBot::TeamComm' has a wrong offset!");
static_assert(offsetof(AOrionAIBot, AICommander) == 0x0007C0, "Member 'AOrionAIBot::AICommander' has a wrong offset!");
static_assert(offsetof(AOrionAIBot, HomeBaseLocationApproximation) == 0x000990, "Member 'AOrionAIBot::HomeBaseLocationApproximation' has a wrong offset!");

// Class OrionGame.OrionBTDecorator_WalkingDistanceToHomeBase
// 0x0008 (0x0070 - 0x0068)
class UOrionBTDecorator_WalkingDistanceToHomeBase final : public UBTDecorator
{
public:
	float                                         HomeBaseRadius;                                    // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionBTDecorator_WalkingDistanceToHomeBase">();
	}
	static class UOrionBTDecorator_WalkingDistanceToHomeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionBTDecorator_WalkingDistanceToHomeBase>();
	}
};
static_assert(alignof(UOrionBTDecorator_WalkingDistanceToHomeBase) == 0x000008, "Wrong alignment on UOrionBTDecorator_WalkingDistanceToHomeBase");
static_assert(sizeof(UOrionBTDecorator_WalkingDistanceToHomeBase) == 0x000070, "Wrong size on UOrionBTDecorator_WalkingDistanceToHomeBase");
static_assert(offsetof(UOrionBTDecorator_WalkingDistanceToHomeBase, HomeBaseRadius) == 0x000068, "Member 'UOrionBTDecorator_WalkingDistanceToHomeBase::HomeBaseRadius' has a wrong offset!");

// Class OrionGame.OrionAIBot_Babysitter
// 0x0000 (0x0C50 - 0x0C50)
class AOrionAIBot_Babysitter final : public AOrionAIBot
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAIBot_Babysitter">();
	}
	static class AOrionAIBot_Babysitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionAIBot_Babysitter>();
	}
};
static_assert(alignof(AOrionAIBot_Babysitter) == 0x000008, "Wrong alignment on AOrionAIBot_Babysitter");
static_assert(sizeof(AOrionAIBot_Babysitter) == 0x000C50, "Wrong size on AOrionAIBot_Babysitter");

// Class OrionGame.OrionAIBot_Arcade
// 0x0000 (0x0C50 - 0x0C50)
class AOrionAIBot_Arcade final : public AOrionAIBot
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAIBot_Arcade">();
	}
	static class AOrionAIBot_Arcade* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionAIBot_Arcade>();
	}
};
static_assert(alignof(AOrionAIBot_Arcade) == 0x000008, "Wrong alignment on AOrionAIBot_Arcade");
static_assert(sizeof(AOrionAIBot_Arcade) == 0x000C50, "Wrong size on AOrionAIBot_Arcade");

// Class OrionGame.OrionTeamBuilder
// 0x10C8 (0x10F0 - 0x0028)
class UOrionTeamBuilder final : public UObject
{
public:
	int32                                         LogTailLengthKb;                                   // 0x0028(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SlotSearchDelay;                                   // 0x002C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AbandonServerTimeout;                              // 0x0030(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AbandonServerRandomness;                           // 0x0034(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AbandonServerWaitForTeamTime;                      // 0x0038(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxMeleeBotsPerTeam;                               // 0x003C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StatsUpdateInterval;                               // 0x0040(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CaptainFindServerAttempts;                         // 0x0044(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CaptainCreateServerChance;                         // 0x0048(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         TeamMemberJoinSessionAttempts;                     // 0x004C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FSkillRatingTimeRestriction>    MMRTimeRestrictions;                               // 0x0050(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	TArray<struct FSkillRatingTimeRestriction>    ELOTimeRestrictions;                               // 0x0060(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	TArray<struct FTBPlayerFilterDuration>        PlayerFilterDurations;                             // 0x0070(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x690];                                     // 0x0080(0x0690)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bStayWithChatOnExit;                               // 0x0710(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_711[0x7];                                      // 0x0711(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionChat*                             Chatroom;                                          // 0x0718(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FOrionTBParams                         Params_0;                                          // 0x0720(0x0160)(Transient, NativeAccessSpecifierPublic)
	bool                                          bTeamMatchmaking;                                  // 0x0880(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCancelingMatchmaking;                             // 0x0881(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAbandoningServer;                                 // 0x0882(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeavingTeam;                                      // 0x0883(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCaptainLeftTeam;                                  // 0x0884(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllMembersReady;                                  // 0x0885(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamBuilderRole                              CurrentRole;                                       // 0x0886(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_887[0x31];                                     // 0x0887(0x0031)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrionPartyBeaconClient*                PartyBeaconClient;                                 // 0x08B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionTBSoloRider*                      SoloRider;                                         // 0x08C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionTeamBuilderParty*                 TeamParty;                                         // 0x08C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UOrionTBSlotHelper*>             QuerySlots;                                        // 0x08D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class UOrionTBSlotHelper*>             PendingQueries;                                    // 0x08E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_8F0[0x4D0];                                    // 0x08F0(0x04D0)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayerMMR;                                         // 0x0DC0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamElo;                                           // 0x0DC4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionTBSkillRatingTimer*               MMRTimer;                                          // 0x0DC8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionTBSkillRatingTimer*               ELOTimer;                                          // 0x0DD0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DD8[0x2D0];                                    // 0x0DD8(0x02D0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTBFilteredPlayer>              FilteredPlayers;                                   // 0x10A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10B8[0x30];                                    // 0x10B8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionTBStats*                          TBStatsManager;                                    // 0x10E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTeamBuilder">();
	}
	static class UOrionTeamBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionTeamBuilder>();
	}
};
static_assert(alignof(UOrionTeamBuilder) == 0x000008, "Wrong alignment on UOrionTeamBuilder");
static_assert(sizeof(UOrionTeamBuilder) == 0x0010F0, "Wrong size on UOrionTeamBuilder");
static_assert(offsetof(UOrionTeamBuilder, LogTailLengthKb) == 0x000028, "Member 'UOrionTeamBuilder::LogTailLengthKb' has a wrong offset!");
static_assert(offsetof(UOrionTeamBuilder, SlotSearchDelay) == 0x00002C, "Member 'UOrionTeamBuilder::SlotSearchDelay' has a wrong offset!");
static_assert(offsetof(UOrionTeamBuilder, AbandonServerTimeout) == 0x000030, "Member 'UOrionTeamBuilder::AbandonServerTimeout' has a wrong offset!");
static_assert(offsetof(UOrionTeamBuilder, AbandonServerRandomness) == 0x000034, "Member 'UOrionTeamBuilder::AbandonServerRandomness' has a wrong offset!");
static_assert(offsetof(UOrionTeamBuilder, AbandonServerWaitForTeamTime) == 0x000038, "Member 'UOrionTeamBuilder::AbandonServerWaitForTeamTime' has a wrong offset!");
static_assert(offsetof(UOrionTeamBuilder, MaxMeleeBotsPerTeam) == 0x00003C, "Member 'UOrionTeamBuilder::MaxMeleeBotsPerTeam' has a wrong offset!");
static_assert(offsetof(UOrionTeamBuilder, StatsUpdateInterval) == 0x000040, "Member 'UOrionTeamBuilder::StatsUpdateInterval' has a wrong offset!");
static_assert(offsetof(UOrionTeamBuilder, CaptainFindServerAttempts) == 0x000044, "Member 'UOrionTeamBuilder::CaptainFindServerAttempts' has a wrong offset!");
static_assert(offsetof(UOrionTeamBuilder, CaptainCreateServerChance) == 0x000048, "Member 'UOrionTeamBuilder::CaptainCreateServerChance' has a wrong offset!");
static_assert(offsetof(UOrionTeamBuilder, TeamMemberJoinSessionAttempts) == 0x00004C, "Member 'UOrionTeamBuilder::TeamMemberJoinSessionAttempts' has a wrong offset!");
static_assert(offsetof(UOrionTeamBuilder, MMRTimeRestrictions) == 0x000050, "Member 'UOrionTeamBuilder::MMRTimeRestrictions' has a wrong offset!");
static_assert(offsetof(UOrionTeamBuilder, ELOTimeRestrictions) == 0x000060, "Member 'UOrionTeamBuilder::ELOTimeRestrictions' has a wrong offset!");
static_assert(offsetof(UOrionTeamBuilder, PlayerFilterDurations) == 0x000070, "Member 'UOrionTeamBuilder::PlayerFilterDurations' has a wrong offset!");
static_assert(offsetof(UOrionTeamBuilder, bStayWithChatOnExit) == 0x000710, "Member 'UOrionTeamBuilder::bStayWithChatOnExit' has a wrong offset!");
static_assert(offsetof(UOrionTeamBuilder, Chatroom) == 0x000718, "Member 'UOrionTeamBuilder::Chatroom' has a wrong offset!");
static_assert(offsetof(UOrionTeamBuilder, Params_0) == 0x000720, "Member 'UOrionTeamBuilder::Params_0' has a wrong offset!");
static_assert(offsetof(UOrionTeamBuilder, bTeamMatchmaking) == 0x000880, "Member 'UOrionTeamBuilder::bTeamMatchmaking' has a wrong offset!");
static_assert(offsetof(UOrionTeamBuilder, bCancelingMatchmaking) == 0x000881, "Member 'UOrionTeamBuilder::bCancelingMatchmaking' has a wrong offset!");
static_assert(offsetof(UOrionTeamBuilder, bAbandoningServer) == 0x000882, "Member 'UOrionTeamBuilder::bAbandoningServer' has a wrong offset!");
static_assert(offsetof(UOrionTeamBuilder, bLeavingTeam) == 0x000883, "Member 'UOrionTeamBuilder::bLeavingTeam' has a wrong offset!");
static_assert(offsetof(UOrionTeamBuilder, bCaptainLeftTeam) == 0x000884, "Member 'UOrionTeamBuilder::bCaptainLeftTeam' has a wrong offset!");
static_assert(offsetof(UOrionTeamBuilder, bAllMembersReady) == 0x000885, "Member 'UOrionTeamBuilder::bAllMembersReady' has a wrong offset!");
static_assert(offsetof(UOrionTeamBuilder, CurrentRole) == 0x000886, "Member 'UOrionTeamBuilder::CurrentRole' has a wrong offset!");
static_assert(offsetof(UOrionTeamBuilder, PartyBeaconClient) == 0x0008B8, "Member 'UOrionTeamBuilder::PartyBeaconClient' has a wrong offset!");
static_assert(offsetof(UOrionTeamBuilder, SoloRider) == 0x0008C0, "Member 'UOrionTeamBuilder::SoloRider' has a wrong offset!");
static_assert(offsetof(UOrionTeamBuilder, TeamParty) == 0x0008C8, "Member 'UOrionTeamBuilder::TeamParty' has a wrong offset!");
static_assert(offsetof(UOrionTeamBuilder, QuerySlots) == 0x0008D0, "Member 'UOrionTeamBuilder::QuerySlots' has a wrong offset!");
static_assert(offsetof(UOrionTeamBuilder, PendingQueries) == 0x0008E0, "Member 'UOrionTeamBuilder::PendingQueries' has a wrong offset!");
static_assert(offsetof(UOrionTeamBuilder, PlayerMMR) == 0x000DC0, "Member 'UOrionTeamBuilder::PlayerMMR' has a wrong offset!");
static_assert(offsetof(UOrionTeamBuilder, TeamElo) == 0x000DC4, "Member 'UOrionTeamBuilder::TeamElo' has a wrong offset!");
static_assert(offsetof(UOrionTeamBuilder, MMRTimer) == 0x000DC8, "Member 'UOrionTeamBuilder::MMRTimer' has a wrong offset!");
static_assert(offsetof(UOrionTeamBuilder, ELOTimer) == 0x000DD0, "Member 'UOrionTeamBuilder::ELOTimer' has a wrong offset!");
static_assert(offsetof(UOrionTeamBuilder, FilteredPlayers) == 0x0010A8, "Member 'UOrionTeamBuilder::FilteredPlayers' has a wrong offset!");
static_assert(offsetof(UOrionTeamBuilder, TBStatsManager) == 0x0010E8, "Member 'UOrionTeamBuilder::TBStatsManager' has a wrong offset!");

// Class OrionGame.OrionAIPerceptionComponent
// 0x0008 (0x01D0 - 0x01C8)
class UOrionAIPerceptionComponent : public UAIPerceptionComponent
{
public:
	uint8                                         Pad_1C8[0x8];                                      // 0x01C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetCallForHelpRating(class AActor* Actor) const;
	float GetRecentDamageTakenFromActor(class AActor* Actor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAIPerceptionComponent">();
	}
	static class UOrionAIPerceptionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAIPerceptionComponent>();
	}
};
static_assert(alignof(UOrionAIPerceptionComponent) == 0x000008, "Wrong alignment on UOrionAIPerceptionComponent");
static_assert(sizeof(UOrionAIPerceptionComponent) == 0x0001D0, "Wrong size on UOrionAIPerceptionComponent");

// Class OrionGame.OrionBTTask_FlowFieldMove
// 0x0008 (0x0080 - 0x0078)
class UOrionBTTask_FlowFieldMove final : public UBTTask_GameplayTaskBase
{
public:
	bool                                          bStopMovementOnAbort;                              // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionBTTask_FlowFieldMove">();
	}
	static class UOrionBTTask_FlowFieldMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionBTTask_FlowFieldMove>();
	}
};
static_assert(alignof(UOrionBTTask_FlowFieldMove) == 0x000008, "Wrong alignment on UOrionBTTask_FlowFieldMove");
static_assert(sizeof(UOrionBTTask_FlowFieldMove) == 0x000080, "Wrong size on UOrionBTTask_FlowFieldMove");
static_assert(offsetof(UOrionBTTask_FlowFieldMove, bStopMovementOnAbort) == 0x000078, "Member 'UOrionBTTask_FlowFieldMove::bStopMovementOnAbort' has a wrong offset!");

// Class OrionGame.OrionAIBotPerceptionComponent
// 0x0000 (0x01D0 - 0x01D0)
class UOrionAIBotPerceptionComponent final : public UOrionAIPerceptionComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAIBotPerceptionComponent">();
	}
	static class UOrionAIBotPerceptionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAIBotPerceptionComponent>();
	}
};
static_assert(alignof(UOrionAIBotPerceptionComponent) == 0x000008, "Wrong alignment on UOrionAIBotPerceptionComponent");
static_assert(sizeof(UOrionAIBotPerceptionComponent) == 0x0001D0, "Wrong size on UOrionAIBotPerceptionComponent");

// Class OrionGame.OrionAICommander
// 0x02F8 (0x0320 - 0x0028)
class UOrionAICommander final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBotObjectiveGenerator*>         ObjectiveGenerators;                               // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FOrionBotTeam                          BotTeams[0x2];                                     // 0x0040(0x0120)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_280[0x8];                                      // 0x0280(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAISystem*                         AISystem;                                          // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABotObjectiveGraph*                     ObjectiveGraph;                                    // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_298[0x88];                                     // 0x0298(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MinionWaveSpawned(class AOrionCharAISpawner* Spawner);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAICommander">();
	}
	static class UOrionAICommander* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAICommander>();
	}
};
static_assert(alignof(UOrionAICommander) == 0x000008, "Wrong alignment on UOrionAICommander");
static_assert(sizeof(UOrionAICommander) == 0x000320, "Wrong size on UOrionAICommander");
static_assert(offsetof(UOrionAICommander, ObjectiveGenerators) == 0x000030, "Member 'UOrionAICommander::ObjectiveGenerators' has a wrong offset!");
static_assert(offsetof(UOrionAICommander, BotTeams) == 0x000040, "Member 'UOrionAICommander::BotTeams' has a wrong offset!");
static_assert(offsetof(UOrionAICommander, AISystem) == 0x000288, "Member 'UOrionAICommander::AISystem' has a wrong offset!");
static_assert(offsetof(UOrionAICommander, ObjectiveGraph) == 0x000290, "Member 'UOrionAICommander::ObjectiveGraph' has a wrong offset!");

// Class OrionGame.OrionBTDecorator_LockUntil
// 0x0000 (0x0090 - 0x0090)
class UOrionBTDecorator_LockUntil final : public UBTDecorator_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionBTDecorator_LockUntil">();
	}
	static class UOrionBTDecorator_LockUntil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionBTDecorator_LockUntil>();
	}
};
static_assert(alignof(UOrionBTDecorator_LockUntil) == 0x000008, "Wrong alignment on UOrionBTDecorator_LockUntil");
static_assert(sizeof(UOrionBTDecorator_LockUntil) == 0x000090, "Wrong size on UOrionBTDecorator_LockUntil");

// Class OrionGame.OrionAISettings
// 0x11F0 (0x1228 - 0x0038)
class UOrionAISettings final : public UDeveloperSettings
{
public:
	uint8                                         Pad_38[0xC0];                                      // 0x0038(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIBotDifficultySettings               BotDifficultyConfig[0x6];                          // 0x00F8(0x00A8)(Config, NativeAccessSpecifierPublic)
	TArray<struct FOrionAIBotCardEntry>           DefaultCardSelectionScenario;                      // 0x04E8(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	struct FDefaultEQSQueries                     DefaultEQSQueries;                                 // 0x04F8(0x02B8)(Edit, Config, NativeAccessSpecifierPublic)
	float                                         DefenseDistanceToTower;                            // 0x07B0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BasicMinionScore;                                  // 0x07B4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstLevelHeroScore;                               // 0x07B8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeroPerLevelScore;                                 // 0x07BC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AICalculationsHeroMaxLevel;                        // 0x07C0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TacticalSituationAssessmentRadius;                 // 0x07C4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPerceptionStimulusAge;                          // 0x07C8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PredictionStimulusMaxAge;                          // 0x07CC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MapVisionStimulusMaxAge;                           // 0x07D0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerPositionTrackingHistoryTime;                 // 0x07D4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemySelectionRangeWhileFleeing;                   // 0x07D8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7DC[0x4];                                      // 0x07DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAIScriptedBehavior>        IntroductoryBehavior;                              // 0x07E0(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         IntroductoryBehaviorRef;                           // 0x07E8(0x0018)(Config, NativeAccessSpecifierPublic)
	TSubclassOf<class UAIScriptedBehavior>        BlindBehavior;                                     // 0x0800(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         BlindBehaviorRef;                                  // 0x0808(0x0018)(Config, NativeAccessSpecifierPublic)
	TSubclassOf<class UAIScriptedBehavior>        AFKBehavior;                                       // 0x0820(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         AFKBehaviorRef;                                    // 0x0828(0x0018)(Config, NativeAccessSpecifierPublic)
	TSubclassOf<class UAIScriptedBehavior>        HomeScriptedBeahavior;                             // 0x0840(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         HomeScriptedBeahaviorRef;                          // 0x0848(0x0018)(Config, NativeAccessSpecifierPublic)
	struct FCardRef                               PrimeHelixCards[0x5];                              // 0x0860(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	class FString                                 DefaultStrategicParamsGenome;                      // 0x0900(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultCombatZoneRadius;                           // 0x0910(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTimeoutBetweenComms;                            // 0x0914(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecallDistanceBumpAfterDamage;                     // 0x0918(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UnusedCardPointsWorthRecallingFor;                 // 0x091C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bMakeBotsWaitForMinionsToSpawn : 1;                // 0x0920(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_921[0x7];                                      // 0x0921(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FNamedHeroList>                 NamedBotHeroLists;                                 // 0x0928(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	int32                                         CoarseInfluenceMapCellSize;                        // 0x0938(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InfluenceMapUpdateFrequenzyHz;                     // 0x093C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinionInfluenceRadius;                             // 0x0940(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialHeroInfluence;                              // 0x0944(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeroInfluenceRadius;                               // 0x0948(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JungleAggroStackDuration;                          // 0x094C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinionAggroIgnoreDuration;                         // 0x0950(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinionAggroHelpMinionsDuration;                    // 0x0954(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinionAggroCallForHelpDuration;                    // 0x0958(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinionAggroCallForHelpRange;                       // 0x095C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinionAggroTowerRange;                             // 0x0960(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_964[0x4];                                      // 0x0964(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EOrionMinionPriority>                  AggroPrioritiesMelee;                              // 0x0968(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<EOrionMinionPriority>                  AggroPrioritiesRanged;                             // 0x0978(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<EOrionMinionPriority>                  AggroPrioritiesSiege;                              // 0x0988(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<EOrionMinionPriority>                  AggroPrioritiesSuper;                              // 0x0998(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	float                                         MeleeAttackValidationDistance;                     // 0x09A8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinionsLeftToConsiderAWave;                        // 0x09AC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMinionDifficultyAttributeModifier     MinionDifficulty[0x6];                             // 0x09B0(0x0060)(Config, NoDestructor, NativeAccessSpecifierPublic)
	struct FObjectiveDifficultyAttributeModifier  ObjectiveDifficulty[0x6];                          // 0x0BF0(0x00B0)(Config, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bCreateBotSubsystemsOnlyWhenBotsArePresent;        // 0x1010(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableFlowFieldMovement;                          // 0x1011(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseInfluenceMapForPerception;                     // 0x1012(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHotfixing;                                      // 0x1013(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1014[0x4];                                     // 0x1014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBTRef                                 GlobatBotBTOverride;                               // 0x1018(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	struct FBTRef                                 DisconnectedPlayerBTOverride;                      // 0x1038(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	struct FBTRef                                 DefaultObjectiveBT;                                // 0x1058(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	struct FBTRef                                 AttackTowerBT;                                     // 0x1078(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	struct FBTRef                                 DefendTowerBT;                                     // 0x1098(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	struct FBTRef                                 WellActionBT;                                      // 0x10B8(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	struct FBTRef                                 AttackObjectiveBT;                                 // 0x10D8(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	struct FBTRef                                 MoveToObjective;                                   // 0x10F8(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	struct FBTRef                                 PlaceWard;                                         // 0x1118(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	struct FBTRef                                 Recall;                                            // 0x1138(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	struct FBTRef                                 SidekickBT;                                        // 0x1158(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	struct FBTRef                                 BodyguardBT;                                       // 0x1178(0x0020)(Edit, Config, NativeAccessSpecifierPublic)
	TArray<struct FBTRef>                         AuxBTs;                                            // 0x1198(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	float                                         WantToLastHitHeroToMinionRatio;                    // 0x11A8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinionThreatScore;                                 // 0x11AC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeroThreatScorePerLevel;                           // 0x11B0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeroThreatScoreBase;                               // 0x11B4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             HeroThreatHealthFactorCurve;                       // 0x11B8(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeroThreatRoleFactorBase[0x5];                     // 0x11E0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeroThreatRoleFactorPerLevel[0x5];                 // 0x11F4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FriendlyMinionsSignificanceRange;                  // 0x1208(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FriendlyHeroesSignificanceRange;                   // 0x120C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyMinionsSignificanceRange;                     // 0x1210(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyHeroesSignificanceRange;                      // 0x1214(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FleeAbsoluteThreatResetDelta;                      // 0x1218(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FleeAbsoluteThreatResumeDefaultDelta;              // 0x121C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultThreatValue;                                // 0x1220(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondaryAsPrimaryChance;                          // 0x1224(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAISettings">();
	}
	static class UOrionAISettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAISettings>();
	}
};
static_assert(alignof(UOrionAISettings) == 0x000008, "Wrong alignment on UOrionAISettings");
static_assert(sizeof(UOrionAISettings) == 0x001228, "Wrong size on UOrionAISettings");
static_assert(offsetof(UOrionAISettings, BotDifficultyConfig) == 0x0000F8, "Member 'UOrionAISettings::BotDifficultyConfig' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, DefaultCardSelectionScenario) == 0x0004E8, "Member 'UOrionAISettings::DefaultCardSelectionScenario' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, DefaultEQSQueries) == 0x0004F8, "Member 'UOrionAISettings::DefaultEQSQueries' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, DefenseDistanceToTower) == 0x0007B0, "Member 'UOrionAISettings::DefenseDistanceToTower' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, BasicMinionScore) == 0x0007B4, "Member 'UOrionAISettings::BasicMinionScore' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, FirstLevelHeroScore) == 0x0007B8, "Member 'UOrionAISettings::FirstLevelHeroScore' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, HeroPerLevelScore) == 0x0007BC, "Member 'UOrionAISettings::HeroPerLevelScore' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, AICalculationsHeroMaxLevel) == 0x0007C0, "Member 'UOrionAISettings::AICalculationsHeroMaxLevel' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, TacticalSituationAssessmentRadius) == 0x0007C4, "Member 'UOrionAISettings::TacticalSituationAssessmentRadius' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, MaxPerceptionStimulusAge) == 0x0007C8, "Member 'UOrionAISettings::MaxPerceptionStimulusAge' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, PredictionStimulusMaxAge) == 0x0007CC, "Member 'UOrionAISettings::PredictionStimulusMaxAge' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, MapVisionStimulusMaxAge) == 0x0007D0, "Member 'UOrionAISettings::MapVisionStimulusMaxAge' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, PlayerPositionTrackingHistoryTime) == 0x0007D4, "Member 'UOrionAISettings::PlayerPositionTrackingHistoryTime' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, EnemySelectionRangeWhileFleeing) == 0x0007D8, "Member 'UOrionAISettings::EnemySelectionRangeWhileFleeing' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, IntroductoryBehavior) == 0x0007E0, "Member 'UOrionAISettings::IntroductoryBehavior' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, IntroductoryBehaviorRef) == 0x0007E8, "Member 'UOrionAISettings::IntroductoryBehaviorRef' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, BlindBehavior) == 0x000800, "Member 'UOrionAISettings::BlindBehavior' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, BlindBehaviorRef) == 0x000808, "Member 'UOrionAISettings::BlindBehaviorRef' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, AFKBehavior) == 0x000820, "Member 'UOrionAISettings::AFKBehavior' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, AFKBehaviorRef) == 0x000828, "Member 'UOrionAISettings::AFKBehaviorRef' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, HomeScriptedBeahavior) == 0x000840, "Member 'UOrionAISettings::HomeScriptedBeahavior' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, HomeScriptedBeahaviorRef) == 0x000848, "Member 'UOrionAISettings::HomeScriptedBeahaviorRef' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, PrimeHelixCards) == 0x000860, "Member 'UOrionAISettings::PrimeHelixCards' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, DefaultStrategicParamsGenome) == 0x000900, "Member 'UOrionAISettings::DefaultStrategicParamsGenome' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, DefaultCombatZoneRadius) == 0x000910, "Member 'UOrionAISettings::DefaultCombatZoneRadius' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, MinTimeoutBetweenComms) == 0x000914, "Member 'UOrionAISettings::MinTimeoutBetweenComms' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, RecallDistanceBumpAfterDamage) == 0x000918, "Member 'UOrionAISettings::RecallDistanceBumpAfterDamage' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, UnusedCardPointsWorthRecallingFor) == 0x00091C, "Member 'UOrionAISettings::UnusedCardPointsWorthRecallingFor' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, NamedBotHeroLists) == 0x000928, "Member 'UOrionAISettings::NamedBotHeroLists' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, CoarseInfluenceMapCellSize) == 0x000938, "Member 'UOrionAISettings::CoarseInfluenceMapCellSize' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, InfluenceMapUpdateFrequenzyHz) == 0x00093C, "Member 'UOrionAISettings::InfluenceMapUpdateFrequenzyHz' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, MinionInfluenceRadius) == 0x000940, "Member 'UOrionAISettings::MinionInfluenceRadius' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, InitialHeroInfluence) == 0x000944, "Member 'UOrionAISettings::InitialHeroInfluence' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, HeroInfluenceRadius) == 0x000948, "Member 'UOrionAISettings::HeroInfluenceRadius' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, JungleAggroStackDuration) == 0x00094C, "Member 'UOrionAISettings::JungleAggroStackDuration' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, MinionAggroIgnoreDuration) == 0x000950, "Member 'UOrionAISettings::MinionAggroIgnoreDuration' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, MinionAggroHelpMinionsDuration) == 0x000954, "Member 'UOrionAISettings::MinionAggroHelpMinionsDuration' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, MinionAggroCallForHelpDuration) == 0x000958, "Member 'UOrionAISettings::MinionAggroCallForHelpDuration' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, MinionAggroCallForHelpRange) == 0x00095C, "Member 'UOrionAISettings::MinionAggroCallForHelpRange' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, MinionAggroTowerRange) == 0x000960, "Member 'UOrionAISettings::MinionAggroTowerRange' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, AggroPrioritiesMelee) == 0x000968, "Member 'UOrionAISettings::AggroPrioritiesMelee' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, AggroPrioritiesRanged) == 0x000978, "Member 'UOrionAISettings::AggroPrioritiesRanged' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, AggroPrioritiesSiege) == 0x000988, "Member 'UOrionAISettings::AggroPrioritiesSiege' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, AggroPrioritiesSuper) == 0x000998, "Member 'UOrionAISettings::AggroPrioritiesSuper' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, MeleeAttackValidationDistance) == 0x0009A8, "Member 'UOrionAISettings::MeleeAttackValidationDistance' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, MinionsLeftToConsiderAWave) == 0x0009AC, "Member 'UOrionAISettings::MinionsLeftToConsiderAWave' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, MinionDifficulty) == 0x0009B0, "Member 'UOrionAISettings::MinionDifficulty' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, ObjectiveDifficulty) == 0x000BF0, "Member 'UOrionAISettings::ObjectiveDifficulty' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, bCreateBotSubsystemsOnlyWhenBotsArePresent) == 0x001010, "Member 'UOrionAISettings::bCreateBotSubsystemsOnlyWhenBotsArePresent' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, bEnableFlowFieldMovement) == 0x001011, "Member 'UOrionAISettings::bEnableFlowFieldMovement' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, bUseInfluenceMapForPerception) == 0x001012, "Member 'UOrionAISettings::bUseInfluenceMapForPerception' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, bIsHotfixing) == 0x001013, "Member 'UOrionAISettings::bIsHotfixing' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, GlobatBotBTOverride) == 0x001018, "Member 'UOrionAISettings::GlobatBotBTOverride' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, DisconnectedPlayerBTOverride) == 0x001038, "Member 'UOrionAISettings::DisconnectedPlayerBTOverride' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, DefaultObjectiveBT) == 0x001058, "Member 'UOrionAISettings::DefaultObjectiveBT' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, AttackTowerBT) == 0x001078, "Member 'UOrionAISettings::AttackTowerBT' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, DefendTowerBT) == 0x001098, "Member 'UOrionAISettings::DefendTowerBT' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, WellActionBT) == 0x0010B8, "Member 'UOrionAISettings::WellActionBT' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, AttackObjectiveBT) == 0x0010D8, "Member 'UOrionAISettings::AttackObjectiveBT' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, MoveToObjective) == 0x0010F8, "Member 'UOrionAISettings::MoveToObjective' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, PlaceWard) == 0x001118, "Member 'UOrionAISettings::PlaceWard' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, Recall) == 0x001138, "Member 'UOrionAISettings::Recall' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, SidekickBT) == 0x001158, "Member 'UOrionAISettings::SidekickBT' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, BodyguardBT) == 0x001178, "Member 'UOrionAISettings::BodyguardBT' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, AuxBTs) == 0x001198, "Member 'UOrionAISettings::AuxBTs' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, WantToLastHitHeroToMinionRatio) == 0x0011A8, "Member 'UOrionAISettings::WantToLastHitHeroToMinionRatio' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, MinionThreatScore) == 0x0011AC, "Member 'UOrionAISettings::MinionThreatScore' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, HeroThreatScorePerLevel) == 0x0011B0, "Member 'UOrionAISettings::HeroThreatScorePerLevel' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, HeroThreatScoreBase) == 0x0011B4, "Member 'UOrionAISettings::HeroThreatScoreBase' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, HeroThreatHealthFactorCurve) == 0x0011B8, "Member 'UOrionAISettings::HeroThreatHealthFactorCurve' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, HeroThreatRoleFactorBase) == 0x0011E0, "Member 'UOrionAISettings::HeroThreatRoleFactorBase' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, HeroThreatRoleFactorPerLevel) == 0x0011F4, "Member 'UOrionAISettings::HeroThreatRoleFactorPerLevel' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, FriendlyMinionsSignificanceRange) == 0x001208, "Member 'UOrionAISettings::FriendlyMinionsSignificanceRange' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, FriendlyHeroesSignificanceRange) == 0x00120C, "Member 'UOrionAISettings::FriendlyHeroesSignificanceRange' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, EnemyMinionsSignificanceRange) == 0x001210, "Member 'UOrionAISettings::EnemyMinionsSignificanceRange' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, EnemyHeroesSignificanceRange) == 0x001214, "Member 'UOrionAISettings::EnemyHeroesSignificanceRange' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, FleeAbsoluteThreatResetDelta) == 0x001218, "Member 'UOrionAISettings::FleeAbsoluteThreatResetDelta' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, FleeAbsoluteThreatResumeDefaultDelta) == 0x00121C, "Member 'UOrionAISettings::FleeAbsoluteThreatResumeDefaultDelta' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, DefaultThreatValue) == 0x001220, "Member 'UOrionAISettings::DefaultThreatValue' has a wrong offset!");
static_assert(offsetof(UOrionAISettings, SecondaryAsPrimaryChance) == 0x001224, "Member 'UOrionAISettings::SecondaryAsPrimaryChance' has a wrong offset!");

// Class OrionGame.OrionTerminusAnimInstance
// 0x0078 (0x0490 - 0x0418)
class UOrionTerminusAnimInstance final : public UOrionAnimInstance
{
public:
	class AActor*                                 OwnerActor;                                        // 0x0418(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ParentDeadFlagFieldName;                           // 0x0420(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bParentDead;                                       // 0x0430(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLooping;                                          // 0x0431(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_432[0x2];                                      // 0x0432(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentLoopSpeed;                                  // 0x0434(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFanSpeed;                                       // 0x0438(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FanInterpSpeed;                                    // 0x043C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedAnimRelevancyData               CachedStartRelevantAnimData;                       // 0x0440(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedAnimTransitionData              CachedStartToLoopingTransitionData;                // 0x0460(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bTransition_Start_To_Looping;                      // 0x0488(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_489[0x7];                                      // 0x0489(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AnimNotify_StartLooping(const class UAnimNotify* Notify);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTerminusAnimInstance">();
	}
	static class UOrionTerminusAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionTerminusAnimInstance>();
	}
};
static_assert(alignof(UOrionTerminusAnimInstance) == 0x000008, "Wrong alignment on UOrionTerminusAnimInstance");
static_assert(sizeof(UOrionTerminusAnimInstance) == 0x000490, "Wrong size on UOrionTerminusAnimInstance");
static_assert(offsetof(UOrionTerminusAnimInstance, OwnerActor) == 0x000418, "Member 'UOrionTerminusAnimInstance::OwnerActor' has a wrong offset!");
static_assert(offsetof(UOrionTerminusAnimInstance, ParentDeadFlagFieldName) == 0x000420, "Member 'UOrionTerminusAnimInstance::ParentDeadFlagFieldName' has a wrong offset!");
static_assert(offsetof(UOrionTerminusAnimInstance, bParentDead) == 0x000430, "Member 'UOrionTerminusAnimInstance::bParentDead' has a wrong offset!");
static_assert(offsetof(UOrionTerminusAnimInstance, bLooping) == 0x000431, "Member 'UOrionTerminusAnimInstance::bLooping' has a wrong offset!");
static_assert(offsetof(UOrionTerminusAnimInstance, CurrentLoopSpeed) == 0x000434, "Member 'UOrionTerminusAnimInstance::CurrentLoopSpeed' has a wrong offset!");
static_assert(offsetof(UOrionTerminusAnimInstance, MaxFanSpeed) == 0x000438, "Member 'UOrionTerminusAnimInstance::MaxFanSpeed' has a wrong offset!");
static_assert(offsetof(UOrionTerminusAnimInstance, FanInterpSpeed) == 0x00043C, "Member 'UOrionTerminusAnimInstance::FanInterpSpeed' has a wrong offset!");
static_assert(offsetof(UOrionTerminusAnimInstance, CachedStartRelevantAnimData) == 0x000440, "Member 'UOrionTerminusAnimInstance::CachedStartRelevantAnimData' has a wrong offset!");
static_assert(offsetof(UOrionTerminusAnimInstance, CachedStartToLoopingTransitionData) == 0x000460, "Member 'UOrionTerminusAnimInstance::CachedStartToLoopingTransitionData' has a wrong offset!");
static_assert(offsetof(UOrionTerminusAnimInstance, bTransition_Start_To_Looping) == 0x000488, "Member 'UOrionTerminusAnimInstance::bTransition_Start_To_Looping' has a wrong offset!");

// Class OrionGame.OrionAIController_MinionBase
// 0x0028 (0x0478 - 0x0450)
class AOrionAIController_MinionBase : public AOrionAIController
{
public:
	uint8                                         Pad_450[0x28];                                     // 0x0450(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAIController_MinionBase">();
	}
	static class AOrionAIController_MinionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionAIController_MinionBase>();
	}
};
static_assert(alignof(AOrionAIController_MinionBase) == 0x000008, "Wrong alignment on AOrionAIController_MinionBase");
static_assert(sizeof(AOrionAIController_MinionBase) == 0x000478, "Wrong size on AOrionAIController_MinionBase");

// Class OrionGame.OrionBTTask_PerformAbility
// 0x0030 (0x00A0 - 0x0070)
class UOrionBTTask_PerformAbility : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 AbilityHandleBBKey;                                // 0x0070(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	EOrionAbilityBinding                          AbilityInputID;                                    // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrionBotAbilityTargetType                    TargetType;                                        // 0x0099(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9A[0x2];                                       // 0x009A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bUsePrimaryAttack : 1;                             // 0x009C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAlwaysWaitForAbilityEnd : 1;                      // 0x009C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAbortAbilityOnTaskAbort : 1;                      // 0x009C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bStompOverPreviousAbilities : 1;                   // 0x009C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bWaitIfAbilityOnCooldownOrActivationBlocked : 1;   // 0x009C(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionBTTask_PerformAbility">();
	}
	static class UOrionBTTask_PerformAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionBTTask_PerformAbility>();
	}
};
static_assert(alignof(UOrionBTTask_PerformAbility) == 0x000008, "Wrong alignment on UOrionBTTask_PerformAbility");
static_assert(sizeof(UOrionBTTask_PerformAbility) == 0x0000A0, "Wrong size on UOrionBTTask_PerformAbility");
static_assert(offsetof(UOrionBTTask_PerformAbility, AbilityHandleBBKey) == 0x000070, "Member 'UOrionBTTask_PerformAbility::AbilityHandleBBKey' has a wrong offset!");
static_assert(offsetof(UOrionBTTask_PerformAbility, AbilityInputID) == 0x000098, "Member 'UOrionBTTask_PerformAbility::AbilityInputID' has a wrong offset!");
static_assert(offsetof(UOrionBTTask_PerformAbility, TargetType) == 0x000099, "Member 'UOrionBTTask_PerformAbility::TargetType' has a wrong offset!");

// Class OrionGame.OrionBTTask_LMBClosestEnemy
// 0x0008 (0x00A8 - 0x00A0)
class UOrionBTTask_LMBClosestEnemy final : public UOrionBTTask_PerformAbility
{
public:
	uint8                                         bCancelOnAbort : 1;                                // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionBTTask_LMBClosestEnemy">();
	}
	static class UOrionBTTask_LMBClosestEnemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionBTTask_LMBClosestEnemy>();
	}
};
static_assert(alignof(UOrionBTTask_LMBClosestEnemy) == 0x000008, "Wrong alignment on UOrionBTTask_LMBClosestEnemy");
static_assert(sizeof(UOrionBTTask_LMBClosestEnemy) == 0x0000A8, "Wrong size on UOrionBTTask_LMBClosestEnemy");

// Class OrionGame.OrionAIController_MinionBaseAdvanced
// 0x0070 (0x04E8 - 0x0478)
class AOrionAIController_MinionBaseAdvanced : public AOrionAIController_MinionBase
{
public:
	uint8                                         Pad_478[0x8];                                      // 0x0478(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrionCharAISpawner*                    MySpawner;                                         // 0x0480(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AOrionCharAI*                           MyPawn;                                            // 0x0488(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_490[0x58];                                     // 0x0490(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetTether(const struct FVector& TetherLocation, const struct FRotator& TetherRotation);

	class AOrionCharAISpawner* GetSpawner() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAIController_MinionBaseAdvanced">();
	}
	static class AOrionAIController_MinionBaseAdvanced* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionAIController_MinionBaseAdvanced>();
	}
};
static_assert(alignof(AOrionAIController_MinionBaseAdvanced) == 0x000008, "Wrong alignment on AOrionAIController_MinionBaseAdvanced");
static_assert(sizeof(AOrionAIController_MinionBaseAdvanced) == 0x0004E8, "Wrong size on AOrionAIController_MinionBaseAdvanced");
static_assert(offsetof(AOrionAIController_MinionBaseAdvanced, MySpawner) == 0x000480, "Member 'AOrionAIController_MinionBaseAdvanced::MySpawner' has a wrong offset!");
static_assert(offsetof(AOrionAIController_MinionBaseAdvanced, MyPawn) == 0x000488, "Member 'AOrionAIController_MinionBaseAdvanced::MyPawn' has a wrong offset!");

// Class OrionGame.OrionAIController_CoreBoss
// 0x0008 (0x04F0 - 0x04E8)
class AOrionAIController_CoreBoss final : public AOrionAIController_MinionBaseAdvanced
{
public:
	class AOrionCharAI_JungleBoss*                CoreBossPawn;                                      // 0x04E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAIController_CoreBoss">();
	}
	static class AOrionAIController_CoreBoss* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionAIController_CoreBoss>();
	}
};
static_assert(alignof(AOrionAIController_CoreBoss) == 0x000008, "Wrong alignment on AOrionAIController_CoreBoss");
static_assert(sizeof(AOrionAIController_CoreBoss) == 0x0004F0, "Wrong size on AOrionAIController_CoreBoss");
static_assert(offsetof(AOrionAIController_CoreBoss, CoreBossPawn) == 0x0004E8, "Member 'AOrionAIController_CoreBoss::CoreBossPawn' has a wrong offset!");

// Class OrionGame.OrionBTTask_WaitUntilTimestamp
// 0x0028 (0x00A0 - 0x0078)
class UOrionBTTask_WaitUntilTimestamp final : public UBTTask_Wait
{
public:
	struct FBlackboardKeySelector                 BlackboardKey;                                     // 0x0078(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionBTTask_WaitUntilTimestamp">();
	}
	static class UOrionBTTask_WaitUntilTimestamp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionBTTask_WaitUntilTimestamp>();
	}
};
static_assert(alignof(UOrionBTTask_WaitUntilTimestamp) == 0x000008, "Wrong alignment on UOrionBTTask_WaitUntilTimestamp");
static_assert(sizeof(UOrionBTTask_WaitUntilTimestamp) == 0x0000A0, "Wrong size on UOrionBTTask_WaitUntilTimestamp");
static_assert(offsetof(UOrionBTTask_WaitUntilTimestamp, BlackboardKey) == 0x000078, "Member 'UOrionBTTask_WaitUntilTimestamp::BlackboardKey' has a wrong offset!");

// Class OrionGame.OrionPlacementActor
// 0x00A8 (0x03C0 - 0x0318)
class AOrionPlacementActor : public AActor
{
public:
	class AActor*                                 DisplayedActor;                                    // 0x0318(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_320[0x8];                                      // 0x0320(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneComponent;                                    // 0x0328(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetComponent*                       WidgetComponent;                                   // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PlacementActorId;                                  // 0x0338(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_340[0x80];                                     // 0x0340(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLoadingChanged(bool bIsLoading);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPlacementActor">();
	}
	static class AOrionPlacementActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionPlacementActor>();
	}
};
static_assert(alignof(AOrionPlacementActor) == 0x000008, "Wrong alignment on AOrionPlacementActor");
static_assert(sizeof(AOrionPlacementActor) == 0x0003C0, "Wrong size on AOrionPlacementActor");
static_assert(offsetof(AOrionPlacementActor, DisplayedActor) == 0x000318, "Member 'AOrionPlacementActor::DisplayedActor' has a wrong offset!");
static_assert(offsetof(AOrionPlacementActor, SceneComponent) == 0x000328, "Member 'AOrionPlacementActor::SceneComponent' has a wrong offset!");
static_assert(offsetof(AOrionPlacementActor, WidgetComponent) == 0x000330, "Member 'AOrionPlacementActor::WidgetComponent' has a wrong offset!");
static_assert(offsetof(AOrionPlacementActor, PlacementActorId) == 0x000338, "Member 'AOrionPlacementActor::PlacementActorId' has a wrong offset!");

// Class OrionGame.OrionHeroPlacementActor
// 0x0030 (0x03F0 - 0x03C0)
class AOrionHeroPlacementActor final : public AOrionPlacementActor
{
public:
	class USoundCue*                              SkinSwapSound;                                     // 0x03C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPedestalActorType                            PedestalActorType;                                 // 0x03C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C9[0x27];                                     // 0x03C9(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHeroPlacementActor">();
	}
	static class AOrionHeroPlacementActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionHeroPlacementActor>();
	}
};
static_assert(alignof(AOrionHeroPlacementActor) == 0x000008, "Wrong alignment on AOrionHeroPlacementActor");
static_assert(sizeof(AOrionHeroPlacementActor) == 0x0003F0, "Wrong size on AOrionHeroPlacementActor");
static_assert(offsetof(AOrionHeroPlacementActor, SkinSwapSound) == 0x0003C0, "Member 'AOrionHeroPlacementActor::SkinSwapSound' has a wrong offset!");
static_assert(offsetof(AOrionHeroPlacementActor, PedestalActorType) == 0x0003C8, "Member 'AOrionHeroPlacementActor::PedestalActorType' has a wrong offset!");

// Class OrionGame.OrionAIController_Jungle
// 0x0008 (0x04F0 - 0x04E8)
class AOrionAIController_Jungle final : public AOrionAIController_MinionBaseAdvanced
{
public:
	class AOrionCharAI_JungleBoss*                JungleBossPawn;                                    // 0x04E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAIController_Jungle">();
	}
	static class AOrionAIController_Jungle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionAIController_Jungle>();
	}
};
static_assert(alignof(AOrionAIController_Jungle) == 0x000008, "Wrong alignment on AOrionAIController_Jungle");
static_assert(sizeof(AOrionAIController_Jungle) == 0x0004F0, "Wrong size on AOrionAIController_Jungle");
static_assert(offsetof(AOrionAIController_Jungle, JungleBossPawn) == 0x0004E8, "Member 'AOrionAIController_Jungle::JungleBossPawn' has a wrong offset!");

// Class OrionGame.OrionAIController_Lane
// 0x0020 (0x0498 - 0x0478)
class AOrionAIController_Lane : public AOrionAIController_MinionBase
{
public:
	uint8                                         Pad_478[0x20];                                     // 0x0478(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAIController_Lane">();
	}
	static class AOrionAIController_Lane* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionAIController_Lane>();
	}
};
static_assert(alignof(AOrionAIController_Lane) == 0x000008, "Wrong alignment on AOrionAIController_Lane");
static_assert(sizeof(AOrionAIController_Lane) == 0x000498, "Wrong size on AOrionAIController_Lane");

// Class OrionGame.OrionBTTask_ParametrizedMoveTo
// 0x0038 (0x00E8 - 0x00B0)
class UOrionBTTask_ParametrizedMoveTo : public UBTTask_MoveTo
{
public:
	struct FAIDataProviderFloatValue              ParametrizedAcceptableRadius;                      // 0x00B0(0x0030)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          bUseParametrizedRadius;                            // 0x00E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionBTTask_ParametrizedMoveTo">();
	}
	static class UOrionBTTask_ParametrizedMoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionBTTask_ParametrizedMoveTo>();
	}
};
static_assert(alignof(UOrionBTTask_ParametrizedMoveTo) == 0x000008, "Wrong alignment on UOrionBTTask_ParametrizedMoveTo");
static_assert(sizeof(UOrionBTTask_ParametrizedMoveTo) == 0x0000E8, "Wrong size on UOrionBTTask_ParametrizedMoveTo");
static_assert(offsetof(UOrionBTTask_ParametrizedMoveTo, ParametrizedAcceptableRadius) == 0x0000B0, "Member 'UOrionBTTask_ParametrizedMoveTo::ParametrizedAcceptableRadius' has a wrong offset!");
static_assert(offsetof(UOrionBTTask_ParametrizedMoveTo, bUseParametrizedRadius) == 0x0000E0, "Member 'UOrionBTTask_ParametrizedMoveTo::bUseParametrizedRadius' has a wrong offset!");

// Class OrionGame.OrionAIController_MinionLaneJoiner
// 0x0010 (0x04A8 - 0x0498)
class AOrionAIController_MinionLaneJoiner final : public AOrionAIController_Lane
{
public:
	uint8                                         Pad_498[0x10];                                     // 0x0498(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAIController_MinionLaneJoiner">();
	}
	static class AOrionAIController_MinionLaneJoiner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionAIController_MinionLaneJoiner>();
	}
};
static_assert(alignof(AOrionAIController_MinionLaneJoiner) == 0x000008, "Wrong alignment on AOrionAIController_MinionLaneJoiner");
static_assert(sizeof(AOrionAIController_MinionLaneJoiner) == 0x0004A8, "Wrong size on AOrionAIController_MinionLaneJoiner");

// Class OrionGame.OrionHeroAnimInstance
// 0x0DA8 (0x11C0 - 0x0418)
#pragma pack(push, 0x1)
class alignas(0x10) UOrionHeroAnimInstance : public UOrionAnimInstance
{
public:
	uint8                                         Pad_418[0x38];                                     // 0x0418(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAttachMeshToSpring;                               // 0x0450(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_451[0x3];                                      // 0x0451(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVectorRK4SpringInterpolator           MeshSpringInterpolator;                            // 0x0454(0x0008)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45C[0x34];                                     // 0x045C(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ForceFullBodyMontageCountMoving;                   // 0x0490(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ForceFullBodyMontageCountTurning;                  // 0x0494(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ForceFullBodyMontageCountJumping;                  // 0x0498(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ForceFullBodyMontageCountLanding;                  // 0x049C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ForceFacingForwardCount;                           // 0x04A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInstantFaceForward;                               // 0x04A4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInstantFaceForwardInterruptTransitions;           // 0x04A5(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A6[0x2];                                      // 0x04A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrionChar*                             MyOrionCharHero;                                   // 0x04A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionCharMovementComponent*            MovementComponent;                                 // 0x04B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SkelMeshComponent;                                 // 0x04B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionHeroCapsuleAnimData              CapsuleData;                                       // 0x04C0(0x0060)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FOrionHeroAnimData                     HeroData;                                          // 0x0520(0x0100)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FOrionHeroAnimData                     LastFrameHeroData;                                 // 0x0620(0x0100)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  UROInterpLocalPoseRotOffset;                       // 0x0720(0x0010)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bDebugLocomotion;                                  // 0x0730(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableIdleBreak;                                  // 0x0731(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_732[0x6];                                      // 0x0732(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCachedAnimStateData>           IdleCachedStates;                                  // 0x0738(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         IdleBreakTargetWeightNotRelevant;                  // 0x0748(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatRK4SpringInterpolator            IdleInterpolator;                                  // 0x074C(0x0008)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_754[0x1C];                                     // 0x0754(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IdleBreakWeight;                                   // 0x0770(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlaySimpleIdleBreak;                              // 0x0774(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_775[0x3];                                      // 0x0775(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedAnimStateData                   LocomotionIdleCachedState;                         // 0x0778(0x0020)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCachedAnimStateData                   LocomotionCachedState;                             // 0x0798(0x0020)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsOnGround;                                       // 0x07B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMoving2D;                                       // 0x07B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7BA[0x2];                                      // 0x07BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Speed2D;                                           // 0x07BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ActorSpaceVelocityDirPreTurn;                      // 0x07C0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECardinalDirection                            LocomotionCardinalDirection;                       // 0x07CC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7CD[0x3];                                      // 0x07CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocomotionDeltaAngle_N;                            // 0x07D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LocomotionDeltaAngle_S;                            // 0x07D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LocomotionDeltaAngle_E;                            // 0x07D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LocomotionDeltaAngle_W;                            // 0x07DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LocomotionYawAimOffset_N;                          // 0x07E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LocomotionYawAimOffset_S;                          // 0x07E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LocomotionYawAimOffset_E;                          // 0x07E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LocomotionYawAimOffset_W;                          // 0x07EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CardinalDirectionBlendTime;                        // 0x07F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CardinalDirectionTransitionDeadzone;               // 0x07F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LocomotionSyncGroupName;                           // 0x07F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUsingSyncMarkers;                                 // 0x0800(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAccelerating;                                   // 0x0801(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_802[0x2];                                      // 0x0802(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocalMovementAngle2D;                              // 0x0804(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LocalAccelAngle2D;                                 // 0x0808(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LowSpeedBlendWeight;                               // 0x080C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasNegativeForwardVelocity;                       // 0x0810(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_811[0x7];                                      // 0x0811(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionDistanceCurve                    DistanceCurve;                                     // 0x0818(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FOrionDistanceCurve                    JumpApexDistanceCurve;                             // 0x0828(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         AuthoredJogSpeed;                                  // 0x0838(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JogPlayRateScale;                                  // 0x083C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JogSpeedWarpingAmount;                             // 0x0840(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AuthoredTravelModeSpeed;                           // 0x0844(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TravelModePlayRateScale;                           // 0x0848(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TravelModeSpeedWarpingAmount;                      // 0x084C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            JogSpeedWarpingPlayRateAdjustmentCurve;            // 0x0850(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              JogSpeedWarpingLimits;                             // 0x0858(0x0008)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              JogSpeedWarpingLimitsAddlRateScale;                // 0x0860(0x0008)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FOrionCachedFloatCurve                 DisableSpeedWarpingCurve;                          // 0x0868(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         LeanAngle;                                         // 0x0878(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatRK4SpringInterpolator            LeanAngleInterpolator;                             // 0x087C(0x0008)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_884[0x1C];                                     // 0x0884(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlopeForwardAngle;                                 // 0x08A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlopeRightAngle;                                   // 0x08A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVectorRK4SpringInterpolator           FloorNormalInterpolator;                           // 0x08A8(0x0008)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8B0[0x34];                                     // 0x08B0(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CurrentFloorNormal;                                // 0x08E4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SmoothedFloorNormal;                               // 0x08F0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8FC[0x4];                                      // 0x08FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DisableSlopeWarpingCurveName;                      // 0x0900(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlopeWarpingAlpha;                                 // 0x0908(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStartTransitionTriggered;                         // 0x090C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_90D[0x3];                                      // 0x090D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedAnimStateData                   StartingCachedState;                               // 0x0910(0x0020)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      StartAnim;                                         // 0x0930(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartAnimDirectionAngle;                           // 0x0938(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartAnimYawAimOffset;                             // 0x093C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartAnimPosition;                                 // 0x0940(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECardinalDirection                            StartingCardinalDirection;                         // 0x0944(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_945[0x3];                                      // 0x0945(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionDirectionalAnimRef               DefaultStartAnims;                                 // 0x0948(0x0020)(Edit, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         StartAnimDistanceFromMarker;                       // 0x0968(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartAnimSpeedWarpingAmount;                       // 0x096C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartTransitionSpeedWarpingAlpha;                  // 0x0970(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartTransitionFirstStepAlpha;                     // 0x0974(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      StartAnimFirstStepA;                               // 0x0978(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      StartAnimFirstStepB;                               // 0x0980(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartAnimFirstStepAPosition;                       // 0x0988(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartAnimFirstStepBPosition;                       // 0x098C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartAnimFirstStepAlpha;                           // 0x0990(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_994[0x4];                                      // 0x0994(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedAnimStateData                   StoppingCachedState;                               // 0x0998(0x0020)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bStopTransitionTriggered;                          // 0x09B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9B9[0x7];                                      // 0x09B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionDirectionalAnimRef               DefaultStopAnims;                                  // 0x09C0(0x0020)(Edit, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      StopAnimA;                                         // 0x09E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      StopAnimB;                                         // 0x09E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StoppingMovementAngle;                             // 0x09F0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StopAnimAlpha;                                     // 0x09F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StopAnimAPosition;                                 // 0x09F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StopAnimBPosition;                                 // 0x09FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StoppingDeltaAngle_N;                              // 0x0A00(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StoppingDeltaAngle_S;                              // 0x0A04(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StoppingDeltaAngle_E;                              // 0x0A08(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StoppingDeltaAngle_W;                              // 0x0A0C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCachedAnimStateData                   PrePivotCachedState;                               // 0x0A10(0x0020)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bPivotTransitionTriggered;                         // 0x0A30(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A31[0x3];                                      // 0x0A31(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PivotDirection;                                    // 0x0A34(0x000C)(Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PivotLocation;                                     // 0x0A40(0x000C)(Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasPivoted;                                       // 0x0A4C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECardinalDirection                            PrePivotCardinalDirection;                         // 0x0A4D(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A4E[0x2];                                      // 0x0A4E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PrePivotDistanceFromMarker;                        // 0x0A50(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PivotDirLerpAlpha;                                 // 0x0A54(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FOrionDirectionalAnimRef               DefaultPivotAnims;                                 // 0x0A58(0x0020)(Edit, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      PrePivotAnim;                                      // 0x0A78(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PrePivotAnimPosition;                              // 0x0A80(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PrePivotAnimDeltaAngle;                            // 0x0A84(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PrePivotAnimYawAimOffset;                          // 0x0A88(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A8C[0x4];                                      // 0x0A8C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedAnimStateData                   PostPivotCachedState;                              // 0x0A90(0x0020)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bPostPivotTransitionTriggered;                     // 0x0AB0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AB1[0x7];                                      // 0x0AB1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      PostPivotAnim;                                     // 0x0AB8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECardinalDirection                            PostPivotCardinalDirection;                        // 0x0AC0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC1[0x3];                                      // 0x0AC1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PostPivotDistanceFromMarker;                       // 0x0AC4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PostPivotAnimPosition;                             // 0x0AC8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PostPivotAnimDeltaAngle;                           // 0x0ACC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PostPivotAnimYawAimOffset;                         // 0x0AD0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PostPivotLockedDeltaAngle;                         // 0x0AD4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PostPivotTransitionSpeedWarpingAlpha;              // 0x0AD8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PostPivotTransitionSpeedWarpingAmount;             // 0x0ADC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPostPivotLockedRotation;                          // 0x0AE0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AE1[0x7];                                      // 0x0AE1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionHeroJumpAnimSet                  DefaultJumpAnimSet;                                // 0x0AE8(0x0028)(Edit, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FOrionHeroJumpAnimSet                  TravelModeOverrideJumpAnimSet;                     // 0x0B10(0x0028)(Edit, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FOrionHeroJumpAnimSet                  JumpAnimSet;                                       // 0x0B38(0x0028)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCachedAnimStateData                   JumpingCachedState;                                // 0x0B60(0x0020)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bJumpTriggered;                                    // 0x0B80(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFallTriggered;                                    // 0x0B81(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B82[0x2];                                      // 0x0B82(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                JumpTakeOffLocation;                               // 0x0B84(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpTakeOffAnimPosition;                           // 0x0B90(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpTakeOffToApexBlendTime;                        // 0x0B94(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpTakeOffToApexBlendAlpha;                       // 0x0B98(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUpdateJumpArc;                                    // 0x0B9C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B9D[0x3];                                      // 0x0B9D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpArcApexPosition;                               // 0x0BA0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpArcAnimPosition;                               // 0x0BA4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpArcEdgeCompressionExponent;                    // 0x0BA8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayPreLand;                                      // 0x0BAC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BAD[0x3];                                      // 0x0BAD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PredictedLandingLocation;                          // 0x0BB0(0x000C)(Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpPreLandAnimPosition;                           // 0x0BBC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpPostLandAdditiveAnimPosition;                  // 0x0BC0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpPostLandAdditiveAnimMaxWeight;                 // 0x0BC4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpPostLandAdditiveAnimMaxWeightJogging;          // 0x0BC8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpPostLandAdditiveAnimMaxWeightOnSlope;          // 0x0BCC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PredictedJumpStateWeight;                          // 0x0BD0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpPostLandAdditiveAnimWeight;                    // 0x0BD4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpPostLandAdditiveActiveWeight;                  // 0x0BD8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatRK4SpringInterpolator            JumpPostLandAnimWeightInterpolator;                // 0x0BDC(0x0008)(Edit, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BE4[0x1C];                                     // 0x0BE4(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bJumpPostLandAdditiveResetAnimPostion;             // 0x0C00(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C01[0x3];                                      // 0x0C01(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpRootRotation;                                  // 0x0C04(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpRootRotationOffset;                            // 0x0C08(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinusJumpRootRotation;                             // 0x0C0C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PelvisBoneName;                                    // 0x0C10(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PelvisBoneIndex;                                   // 0x0C18(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAxis                                         PelvisBoneForwardAxis;                             // 0x0C1C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bJumpHasLanded;                                    // 0x0C1D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C1E[0x2];                                      // 0x0C1E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionDirectionalAnimRef               JumpPostLandStartAnimOverride;                     // 0x0C20(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bPlayStartTransitionOnLand;                        // 0x0C40(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C41[0x3];                                      // 0x0C41(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnRootRotationYaw;                               // 0x0C44(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FinalRootRotationYaw;                              // 0x0C48(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C4C[0x4];                                      // 0x0C4C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           SlotNodesForcingFacingForward;                     // 0x0C50(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsForcedFacingForward;                            // 0x0C60(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C61[0x3];                                      // 0x0C61(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatRK4SpringInterpolator            ForcedFacingForwardInterpolator;                   // 0x0C64(0x0008)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C6C[0x1C];                                     // 0x0C6C(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatRK4SpringInterpolator            TurnSpeedInterpolator;                             // 0x0C88(0x0008)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C90[0x1C];                                     // 0x0C90(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnSpeedInterpolatorLimit;                        // 0x0CAC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnSpeedMinThreshold;                             // 0x0CB0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FOrionHeroAbilityFlags                 TargetingAbilityForcedFacingForward;               // 0x0CB4(0x0009)(Edit, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FOrionHeroAbilityFlags                 ActiveAbilityForcedFacingForward;                  // 0x0CBD(0x0009)(Edit, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bEnableTurnInPlaceTransition;                      // 0x0CC6(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTurnCompensatingActorRotation;                    // 0x0CC7(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FCachedAnimStateData>           TurnInPlaceCachedStates;                           // 0x0CC8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FOrionTurnTransition>           TurnTransitions;                                   // 0x0CD8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FOrionTurnTransition>           TravelModeTurnTransitions;                         // 0x0CE8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         TurnTransitionDeadZoneAngle;                       // 0x0CF8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnInPlaceRootRotation;                           // 0x0CFC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnInPlaceAimOffsetYaw;                           // 0x0D00(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnTransitionAimOffsetLagWeight;                  // 0x0D04(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatRK4SpringInterpolator            TurnInPlaceAimOffsetInterpolator;                  // 0x0D08(0x0008)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D10[0x1C];                                     // 0x0D10(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bTurnInPlaceTransitionTriggered;                   // 0x0D2C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D2D[0x3];                                      // 0x0D2D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedAnimStateData                   TurnTransitionCachedState;                         // 0x0D30(0x0020)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      TurnInPlaceAnim;                                   // 0x0D50(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnInPlaceAnimPosition;                           // 0x0D58(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D5C[0x14];                                     // 0x0D5C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastTimeCheckedForATurnTransition;                 // 0x0D70(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnInPlaceDelayCounter;                           // 0x0D74(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnInPlaceAnimCurrentAngle;                       // 0x0D78(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayTurnInPlaceRecovery;                          // 0x0D7C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTurnInPlaceRecoveryTriggered;                     // 0x0D7D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D7E[0x2];                                      // 0x0D7E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedAnimStateData                   TurnRecoveryCachedState;                           // 0x0D80(0x0020)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      TurnInPlaceRecoveryAnim;                           // 0x0DA0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnInPlaceRecoveryAnimPosition;                   // 0x0DA8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableSpinTransition;                             // 0x0DAC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DAD[0x3];                                      // 0x0DAD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedAnimStateData                   SpinTransitionCachedState;                         // 0x0DB0(0x0020)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bSpinTransitionStateTriggered;                     // 0x0DD0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSpinTransitionCompleted;                          // 0x0DD1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DD2[0x2];                                      // 0x0DD2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatRK4SpringInterpolator            SpinInterpolator;                                  // 0x0DD4(0x0008)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DDC[0x1C];                                     // 0x0DDC(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionHeroSpinAnimSet                  DefaultSpinAnimSet;                                // 0x0DF8(0x0020)(Edit, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FOrionHeroSpinAnimSet                  TravelModeSpinAnimSetOverride;                     // 0x0E18(0x0020)(Edit, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bSpinTransitionIsLeader;                           // 0x0E38(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E39[0x7];                                      // 0x0E39(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      SpinTransitionAnim;                                // 0x0E40(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpinTransitionAnimPosition;                        // 0x0E48(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECardinalDirection                            SpinTransitionCardinalDir;                         // 0x0E4C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E4D[0x3];                                      // 0x0E4D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpinTransitionRootYawOffset;                       // 0x0E50(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatRK4SpringInterpolator            SpinTransitionAimOffsetInterpolator;               // 0x0E54(0x0008)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E5C[0x1C];                                     // 0x0E5C(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpinTransitionAimYawOffset;                        // 0x0E78(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpinTransitionAccumulatedYawTurn;                  // 0x0E7C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpinTransitionCurrentAngle;                        // 0x0E80(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpinTransitionAngleSign;                           // 0x0E84(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          SpinTransitionIsClockwiseTurn;                     // 0x0E88(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          SpinTransitionIsABackPedal;                        // 0x0E89(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E8A[0x2];                                      // 0x0E8A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimOffsetYaw;                                      // 0x0E8C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimOffsetPitch;                                    // 0x0E90(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimOffsetAlpha;                                    // 0x0E94(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DisableAimOffsetCurveName;                         // 0x0E98(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MeleeTwistCurveName;                               // 0x0EA0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MeleeTwistCurveValue;                              // 0x0EA8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinusMeleeTwistCurveValue;                         // 0x0EAC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MeleeTwistBlendWeight;                             // 0x0EB0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatRK4SpringInterpolator            MeleeTwistBlendWeightInterpolator;                 // 0x0EB4(0x0008)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EBC[0x1C];                                     // 0x0EBC(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MeleeTwistDirectionalBlendTime;                    // 0x0ED8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnInPlaceStrafePlayRate;                         // 0x0EDC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnInPlaceStrafeBlendWeight;                      // 0x0EE0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnInPlaceMeleeTwistStrafeBlendWeight;            // 0x0EE4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnInPlaceStrafeMovementAngle;                    // 0x0EE8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WeaponScaleCurveAlpha;                             // 0x0EEC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FOrionHeroAbilityTags                  AbilityTags;                                       // 0x0EF0(0x0040)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsKnockedBack;                                    // 0x0F30(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsKnockedUp;                                      // 0x0F31(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsRecalling;                                      // 0x0F32(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsStunned;                                        // 0x0F33(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsTravelModeStunned;                              // 0x0F34(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FOrionHeroAbilityFlags                 AbilityStateTriggered;                             // 0x0F35(0x0009)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FOrionHeroAbilityFlags                 AbilityStateUntriggered;                           // 0x0F3E(0x0009)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FOrionHeroAbilityFlags                 AbilityStateActive;                                // 0x0F47(0x0009)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FOrionHeroAbilityFlags                 AbilityStateLastFrame;                             // 0x0F50(0x0009)(Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FOrionHeroAbilityFlags                 AbilityTargetingTriggered;                         // 0x0F59(0x0009)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FOrionHeroAbilityFlags                 AbilityTargetingActive;                            // 0x0F62(0x0009)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FOrionHeroAbilityFlags                 AbilityTargetingLastFrame;                         // 0x0F6B(0x0009)(Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsAbilityTargeting_LMB_BasicPrimary;              // 0x0F74(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAbilityTargeting_RMB_Alternate;                 // 0x0F75(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAbilityTargeting_Q_Primary;                     // 0x0F76(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAbilityTargeting_E_Secondary;                   // 0x0F77(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAbilityTargeting_R_Ultimate;                    // 0x0F78(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FOrionHeroStatusFlags                  HeroStatusFlagsActive;                             // 0x0F79(0x0009)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FOrionHeroStatusFlags                  HeroStatusFlagsTriggered;                          // 0x0F82(0x0009)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FOrionHeroStatusFlags                  InternalHeroStatusFlagsLastFrame;                  // 0x0F8B(0x0009)(Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FOrionHeroAbilityFlags                 ActiveAbilityFlagsForcingTravelModeAnims;          // 0x0F94(0x0009)(Edit, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FOrionHeroAbilityFlags                 AbilityTargetingFlagsForcingTravelModeAnims;       // 0x0F9D(0x0009)(Edit, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FOrionHeroStatusFlags                  ActiveStatusFlagsForcingTravelModeAnims;           // 0x0FA6(0x0009)(Edit, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_FAF[0x1];                                      // 0x0FAF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForcedTravelModeExtendedTime;                      // 0x0FB0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ForcedTravelModeExtendedTimeLeft;                  // 0x0FB4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsInTravelMode;                                   // 0x0FB8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTravelModeTriggered;                              // 0x0FB9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTravelModeUntriggered;                            // 0x0FBA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWasInTravelModeLastFrame;                         // 0x0FBB(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsCastingTravelMode;                              // 0x0FBC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FBD[0x3];                                      // 0x0FBD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionDirectionalAnimRef               TravelModeStartAnimOverride;                       // 0x0FC0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FOrionDirectionalAnimRef               TravelModeStopAnimOverride;                        // 0x0FE0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FOrionDirectionalAnimRef               TravelModePivotAnimOverride;                       // 0x1000(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         TravelModeLocomotionDeltaAngle_E;                  // 0x1020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TravelModeLocomotionDeltaAngle_W;                  // 0x1024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSwitchTransitionAnimsOnTravelModeTriggered;       // 0x1028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSwitchTransitionAnimsOnTravelModeUnTriggered;     // 0x1029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FOrionHeroAllowedTransitions           CurrentAllowedTransitionFlags;                     // 0x102A(0x0007)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FOrionHeroAllowedTransitions           DefaultAllowedTransitionFlags;                     // 0x1031(0x0007)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FOrionHeroAllowedTransitions           TravelModeAllowedTransitionFlags;                  // 0x1038(0x0007)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FOrionHeroAllowedTransitions           ForcedFacingForwardOverrideTransitionFlags;        // 0x103F(0x0007)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1046[0x2];                                     // 0x1046(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionDirectionalAnimRef               HitReactAnims;                                     // 0x1048(0x0020)(Edit, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      HitReactAnim;                                      // 0x1068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayingHitReact;                                  // 0x1070(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1071[0x3];                                     // 0x1071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitReactAnimPosition;                              // 0x1074(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitReactBlendAlpha;                                // 0x1078(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlaySimpleHitReact;                               // 0x107C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_107D[0x3];                                     // 0x107D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SlotName_FullBody;                                 // 0x1080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SlotName_FullBody_FWD;                             // 0x1088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SlotName_FullBodyInAir;                            // 0x1090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SlotName_FullBodyOnGround;                         // 0x1098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SlotName_UpperBodyInMotion;                        // 0x10A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SlotName_FullBodyInPlace;                          // 0x10A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SlotName_UpperBody;                                // 0x10B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SlotName_FullBodyYawAdjust;                        // 0x10B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SlotName_ArmsAndHead;                              // 0x10C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SlotName_ArmsAndHead_InMotion;                     // 0x10C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SlotName_UpperBodyMSA;                             // 0x10D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SlotName_UpperBodyMSA_InMotion;                    // 0x10D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UpperBodySlotMaskWeight;                           // 0x10E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLowerBodyInMotion;                                // 0x10E4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bActivateFullBodyInAirMask;                        // 0x10E5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bActivateUpperBodyInMotionMask;                    // 0x10E6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10E7[0x1];                                     // 0x10E7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FullBodyYawAdjustRotation;                         // 0x10E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayingFullBodyDirectional;                       // 0x10EC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10ED[0x3];                                     // 0x10ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpperBodyApplyMSAWeight;                           // 0x10F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UpperBodyMSAMaskWeight;                            // 0x10F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmsAndHeadMaskWeight;                             // 0x10F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10FC[0x4];                                     // 0x10FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedAnimStateData                   ArmsAndHead_IdleCachedState;                       // 0x1100(0x0020)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCachedAnimStateData                   UpperBodyMSA_IdleCachedState;                      // 0x1120(0x0020)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCachedAnimStateData                   UpperBody_IdleCachedState;                         // 0x1140(0x0020)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bChildClassTriggeredUpperBodyMSALayer;             // 0x1160(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bChildClassTriggeredArmsAndHeadLayer;              // 0x1161(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1162[0x2];                                     // 0x1162(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ArmsAndHeadLayerFullBodyWeight;                    // 0x1164(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCachedAnimStateArray                  MSALayerFullBodyCachedStateArray;                  // 0x1168(0x0018)(Transient, Protected, NativeAccessSpecifierProtected)
	float                                         MSALayerFullBodyWeight;                            // 0x1180(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAMontageStartedBlendingOut;                       // 0x1184(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bATagHasChanged;                                   // 0x1185(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsUpperBodyMSA_InMotion;                          // 0x1186(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsArmsAndHead_InMotion;                           // 0x1187(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayTargetingAbilityInMotion;                     // 0x1188(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldTransitionToStunnedState;                   // 0x1189(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldTransitionToKnockedBackState;               // 0x118A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldEarlyOutTurnInPlaceState;                   // 0x118B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldEarlyOutPrePivotState;                      // 0x118C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldEarlyOutPostPivotState;                     // 0x118D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldEarlyOutSpinState;                          // 0x118E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldEarlyOutLocomotionLoopState;                // 0x118F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIdle2LocomotionLoopStateFailsafeTransition;       // 0x1190(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldEarlyOutStopState;                          // 0x1191(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldEarlyOutStartState;                         // 0x1192(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldEarlyOutJumpingState;                       // 0x1193(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPostLandIdleTriggered;                            // 0x1194(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldEarlyOutPostLandIdleState;                  // 0x1195(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1196[0x2];                                     // 0x1196(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimDynamicsForceScaling;                          // 0x1198(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                AnimDynamicsForce;                                 // 0x119C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DisableClothAlphaCurveName;                        // 0x11A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   WeaponScaleCurveName;                              // 0x11B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnAllMontageInstancesEndedCallback();
	void OnMontageBlendingOutDelegate(class UAnimMontage* Montage, bool bInterrupted);
	void OnMontageStartedDelegate(class UAnimMontage* Montage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHeroAnimInstance">();
	}
	static class UOrionHeroAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHeroAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UOrionHeroAnimInstance) == 0x000010, "Wrong alignment on UOrionHeroAnimInstance");
static_assert(sizeof(UOrionHeroAnimInstance) == 0x0011C0, "Wrong size on UOrionHeroAnimInstance");
static_assert(offsetof(UOrionHeroAnimInstance, bAttachMeshToSpring) == 0x000450, "Member 'UOrionHeroAnimInstance::bAttachMeshToSpring' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, MeshSpringInterpolator) == 0x000454, "Member 'UOrionHeroAnimInstance::MeshSpringInterpolator' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, ForceFullBodyMontageCountMoving) == 0x000490, "Member 'UOrionHeroAnimInstance::ForceFullBodyMontageCountMoving' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, ForceFullBodyMontageCountTurning) == 0x000494, "Member 'UOrionHeroAnimInstance::ForceFullBodyMontageCountTurning' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, ForceFullBodyMontageCountJumping) == 0x000498, "Member 'UOrionHeroAnimInstance::ForceFullBodyMontageCountJumping' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, ForceFullBodyMontageCountLanding) == 0x00049C, "Member 'UOrionHeroAnimInstance::ForceFullBodyMontageCountLanding' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, ForceFacingForwardCount) == 0x0004A0, "Member 'UOrionHeroAnimInstance::ForceFacingForwardCount' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bInstantFaceForward) == 0x0004A4, "Member 'UOrionHeroAnimInstance::bInstantFaceForward' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bInstantFaceForwardInterruptTransitions) == 0x0004A5, "Member 'UOrionHeroAnimInstance::bInstantFaceForwardInterruptTransitions' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, MyOrionCharHero) == 0x0004A8, "Member 'UOrionHeroAnimInstance::MyOrionCharHero' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, MovementComponent) == 0x0004B0, "Member 'UOrionHeroAnimInstance::MovementComponent' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, SkelMeshComponent) == 0x0004B8, "Member 'UOrionHeroAnimInstance::SkelMeshComponent' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, CapsuleData) == 0x0004C0, "Member 'UOrionHeroAnimInstance::CapsuleData' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, HeroData) == 0x000520, "Member 'UOrionHeroAnimInstance::HeroData' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, LastFrameHeroData) == 0x000620, "Member 'UOrionHeroAnimInstance::LastFrameHeroData' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, UROInterpLocalPoseRotOffset) == 0x000720, "Member 'UOrionHeroAnimInstance::UROInterpLocalPoseRotOffset' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bDebugLocomotion) == 0x000730, "Member 'UOrionHeroAnimInstance::bDebugLocomotion' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bEnableIdleBreak) == 0x000731, "Member 'UOrionHeroAnimInstance::bEnableIdleBreak' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, IdleCachedStates) == 0x000738, "Member 'UOrionHeroAnimInstance::IdleCachedStates' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, IdleBreakTargetWeightNotRelevant) == 0x000748, "Member 'UOrionHeroAnimInstance::IdleBreakTargetWeightNotRelevant' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, IdleInterpolator) == 0x00074C, "Member 'UOrionHeroAnimInstance::IdleInterpolator' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, IdleBreakWeight) == 0x000770, "Member 'UOrionHeroAnimInstance::IdleBreakWeight' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bPlaySimpleIdleBreak) == 0x000774, "Member 'UOrionHeroAnimInstance::bPlaySimpleIdleBreak' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, LocomotionIdleCachedState) == 0x000778, "Member 'UOrionHeroAnimInstance::LocomotionIdleCachedState' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, LocomotionCachedState) == 0x000798, "Member 'UOrionHeroAnimInstance::LocomotionCachedState' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bIsOnGround) == 0x0007B8, "Member 'UOrionHeroAnimInstance::bIsOnGround' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bIsMoving2D) == 0x0007B9, "Member 'UOrionHeroAnimInstance::bIsMoving2D' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, Speed2D) == 0x0007BC, "Member 'UOrionHeroAnimInstance::Speed2D' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, ActorSpaceVelocityDirPreTurn) == 0x0007C0, "Member 'UOrionHeroAnimInstance::ActorSpaceVelocityDirPreTurn' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, LocomotionCardinalDirection) == 0x0007CC, "Member 'UOrionHeroAnimInstance::LocomotionCardinalDirection' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, LocomotionDeltaAngle_N) == 0x0007D0, "Member 'UOrionHeroAnimInstance::LocomotionDeltaAngle_N' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, LocomotionDeltaAngle_S) == 0x0007D4, "Member 'UOrionHeroAnimInstance::LocomotionDeltaAngle_S' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, LocomotionDeltaAngle_E) == 0x0007D8, "Member 'UOrionHeroAnimInstance::LocomotionDeltaAngle_E' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, LocomotionDeltaAngle_W) == 0x0007DC, "Member 'UOrionHeroAnimInstance::LocomotionDeltaAngle_W' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, LocomotionYawAimOffset_N) == 0x0007E0, "Member 'UOrionHeroAnimInstance::LocomotionYawAimOffset_N' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, LocomotionYawAimOffset_S) == 0x0007E4, "Member 'UOrionHeroAnimInstance::LocomotionYawAimOffset_S' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, LocomotionYawAimOffset_E) == 0x0007E8, "Member 'UOrionHeroAnimInstance::LocomotionYawAimOffset_E' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, LocomotionYawAimOffset_W) == 0x0007EC, "Member 'UOrionHeroAnimInstance::LocomotionYawAimOffset_W' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, CardinalDirectionBlendTime) == 0x0007F0, "Member 'UOrionHeroAnimInstance::CardinalDirectionBlendTime' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, CardinalDirectionTransitionDeadzone) == 0x0007F4, "Member 'UOrionHeroAnimInstance::CardinalDirectionTransitionDeadzone' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, LocomotionSyncGroupName) == 0x0007F8, "Member 'UOrionHeroAnimInstance::LocomotionSyncGroupName' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bUsingSyncMarkers) == 0x000800, "Member 'UOrionHeroAnimInstance::bUsingSyncMarkers' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bIsAccelerating) == 0x000801, "Member 'UOrionHeroAnimInstance::bIsAccelerating' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, LocalMovementAngle2D) == 0x000804, "Member 'UOrionHeroAnimInstance::LocalMovementAngle2D' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, LocalAccelAngle2D) == 0x000808, "Member 'UOrionHeroAnimInstance::LocalAccelAngle2D' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, LowSpeedBlendWeight) == 0x00080C, "Member 'UOrionHeroAnimInstance::LowSpeedBlendWeight' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bHasNegativeForwardVelocity) == 0x000810, "Member 'UOrionHeroAnimInstance::bHasNegativeForwardVelocity' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, DistanceCurve) == 0x000818, "Member 'UOrionHeroAnimInstance::DistanceCurve' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, JumpApexDistanceCurve) == 0x000828, "Member 'UOrionHeroAnimInstance::JumpApexDistanceCurve' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, AuthoredJogSpeed) == 0x000838, "Member 'UOrionHeroAnimInstance::AuthoredJogSpeed' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, JogPlayRateScale) == 0x00083C, "Member 'UOrionHeroAnimInstance::JogPlayRateScale' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, JogSpeedWarpingAmount) == 0x000840, "Member 'UOrionHeroAnimInstance::JogSpeedWarpingAmount' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, AuthoredTravelModeSpeed) == 0x000844, "Member 'UOrionHeroAnimInstance::AuthoredTravelModeSpeed' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, TravelModePlayRateScale) == 0x000848, "Member 'UOrionHeroAnimInstance::TravelModePlayRateScale' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, TravelModeSpeedWarpingAmount) == 0x00084C, "Member 'UOrionHeroAnimInstance::TravelModeSpeedWarpingAmount' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, JogSpeedWarpingPlayRateAdjustmentCurve) == 0x000850, "Member 'UOrionHeroAnimInstance::JogSpeedWarpingPlayRateAdjustmentCurve' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, JogSpeedWarpingLimits) == 0x000858, "Member 'UOrionHeroAnimInstance::JogSpeedWarpingLimits' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, JogSpeedWarpingLimitsAddlRateScale) == 0x000860, "Member 'UOrionHeroAnimInstance::JogSpeedWarpingLimitsAddlRateScale' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, DisableSpeedWarpingCurve) == 0x000868, "Member 'UOrionHeroAnimInstance::DisableSpeedWarpingCurve' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, LeanAngle) == 0x000878, "Member 'UOrionHeroAnimInstance::LeanAngle' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, LeanAngleInterpolator) == 0x00087C, "Member 'UOrionHeroAnimInstance::LeanAngleInterpolator' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, SlopeForwardAngle) == 0x0008A0, "Member 'UOrionHeroAnimInstance::SlopeForwardAngle' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, SlopeRightAngle) == 0x0008A4, "Member 'UOrionHeroAnimInstance::SlopeRightAngle' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, FloorNormalInterpolator) == 0x0008A8, "Member 'UOrionHeroAnimInstance::FloorNormalInterpolator' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, CurrentFloorNormal) == 0x0008E4, "Member 'UOrionHeroAnimInstance::CurrentFloorNormal' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, SmoothedFloorNormal) == 0x0008F0, "Member 'UOrionHeroAnimInstance::SmoothedFloorNormal' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, DisableSlopeWarpingCurveName) == 0x000900, "Member 'UOrionHeroAnimInstance::DisableSlopeWarpingCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, SlopeWarpingAlpha) == 0x000908, "Member 'UOrionHeroAnimInstance::SlopeWarpingAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bStartTransitionTriggered) == 0x00090C, "Member 'UOrionHeroAnimInstance::bStartTransitionTriggered' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, StartingCachedState) == 0x000910, "Member 'UOrionHeroAnimInstance::StartingCachedState' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, StartAnim) == 0x000930, "Member 'UOrionHeroAnimInstance::StartAnim' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, StartAnimDirectionAngle) == 0x000938, "Member 'UOrionHeroAnimInstance::StartAnimDirectionAngle' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, StartAnimYawAimOffset) == 0x00093C, "Member 'UOrionHeroAnimInstance::StartAnimYawAimOffset' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, StartAnimPosition) == 0x000940, "Member 'UOrionHeroAnimInstance::StartAnimPosition' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, StartingCardinalDirection) == 0x000944, "Member 'UOrionHeroAnimInstance::StartingCardinalDirection' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, DefaultStartAnims) == 0x000948, "Member 'UOrionHeroAnimInstance::DefaultStartAnims' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, StartAnimDistanceFromMarker) == 0x000968, "Member 'UOrionHeroAnimInstance::StartAnimDistanceFromMarker' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, StartAnimSpeedWarpingAmount) == 0x00096C, "Member 'UOrionHeroAnimInstance::StartAnimSpeedWarpingAmount' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, StartTransitionSpeedWarpingAlpha) == 0x000970, "Member 'UOrionHeroAnimInstance::StartTransitionSpeedWarpingAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, StartTransitionFirstStepAlpha) == 0x000974, "Member 'UOrionHeroAnimInstance::StartTransitionFirstStepAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, StartAnimFirstStepA) == 0x000978, "Member 'UOrionHeroAnimInstance::StartAnimFirstStepA' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, StartAnimFirstStepB) == 0x000980, "Member 'UOrionHeroAnimInstance::StartAnimFirstStepB' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, StartAnimFirstStepAPosition) == 0x000988, "Member 'UOrionHeroAnimInstance::StartAnimFirstStepAPosition' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, StartAnimFirstStepBPosition) == 0x00098C, "Member 'UOrionHeroAnimInstance::StartAnimFirstStepBPosition' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, StartAnimFirstStepAlpha) == 0x000990, "Member 'UOrionHeroAnimInstance::StartAnimFirstStepAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, StoppingCachedState) == 0x000998, "Member 'UOrionHeroAnimInstance::StoppingCachedState' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bStopTransitionTriggered) == 0x0009B8, "Member 'UOrionHeroAnimInstance::bStopTransitionTriggered' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, DefaultStopAnims) == 0x0009C0, "Member 'UOrionHeroAnimInstance::DefaultStopAnims' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, StopAnimA) == 0x0009E0, "Member 'UOrionHeroAnimInstance::StopAnimA' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, StopAnimB) == 0x0009E8, "Member 'UOrionHeroAnimInstance::StopAnimB' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, StoppingMovementAngle) == 0x0009F0, "Member 'UOrionHeroAnimInstance::StoppingMovementAngle' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, StopAnimAlpha) == 0x0009F4, "Member 'UOrionHeroAnimInstance::StopAnimAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, StopAnimAPosition) == 0x0009F8, "Member 'UOrionHeroAnimInstance::StopAnimAPosition' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, StopAnimBPosition) == 0x0009FC, "Member 'UOrionHeroAnimInstance::StopAnimBPosition' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, StoppingDeltaAngle_N) == 0x000A00, "Member 'UOrionHeroAnimInstance::StoppingDeltaAngle_N' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, StoppingDeltaAngle_S) == 0x000A04, "Member 'UOrionHeroAnimInstance::StoppingDeltaAngle_S' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, StoppingDeltaAngle_E) == 0x000A08, "Member 'UOrionHeroAnimInstance::StoppingDeltaAngle_E' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, StoppingDeltaAngle_W) == 0x000A0C, "Member 'UOrionHeroAnimInstance::StoppingDeltaAngle_W' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, PrePivotCachedState) == 0x000A10, "Member 'UOrionHeroAnimInstance::PrePivotCachedState' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bPivotTransitionTriggered) == 0x000A30, "Member 'UOrionHeroAnimInstance::bPivotTransitionTriggered' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, PivotDirection) == 0x000A34, "Member 'UOrionHeroAnimInstance::PivotDirection' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, PivotLocation) == 0x000A40, "Member 'UOrionHeroAnimInstance::PivotLocation' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bHasPivoted) == 0x000A4C, "Member 'UOrionHeroAnimInstance::bHasPivoted' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, PrePivotCardinalDirection) == 0x000A4D, "Member 'UOrionHeroAnimInstance::PrePivotCardinalDirection' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, PrePivotDistanceFromMarker) == 0x000A50, "Member 'UOrionHeroAnimInstance::PrePivotDistanceFromMarker' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, PivotDirLerpAlpha) == 0x000A54, "Member 'UOrionHeroAnimInstance::PivotDirLerpAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, DefaultPivotAnims) == 0x000A58, "Member 'UOrionHeroAnimInstance::DefaultPivotAnims' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, PrePivotAnim) == 0x000A78, "Member 'UOrionHeroAnimInstance::PrePivotAnim' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, PrePivotAnimPosition) == 0x000A80, "Member 'UOrionHeroAnimInstance::PrePivotAnimPosition' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, PrePivotAnimDeltaAngle) == 0x000A84, "Member 'UOrionHeroAnimInstance::PrePivotAnimDeltaAngle' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, PrePivotAnimYawAimOffset) == 0x000A88, "Member 'UOrionHeroAnimInstance::PrePivotAnimYawAimOffset' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, PostPivotCachedState) == 0x000A90, "Member 'UOrionHeroAnimInstance::PostPivotCachedState' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bPostPivotTransitionTriggered) == 0x000AB0, "Member 'UOrionHeroAnimInstance::bPostPivotTransitionTriggered' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, PostPivotAnim) == 0x000AB8, "Member 'UOrionHeroAnimInstance::PostPivotAnim' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, PostPivotCardinalDirection) == 0x000AC0, "Member 'UOrionHeroAnimInstance::PostPivotCardinalDirection' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, PostPivotDistanceFromMarker) == 0x000AC4, "Member 'UOrionHeroAnimInstance::PostPivotDistanceFromMarker' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, PostPivotAnimPosition) == 0x000AC8, "Member 'UOrionHeroAnimInstance::PostPivotAnimPosition' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, PostPivotAnimDeltaAngle) == 0x000ACC, "Member 'UOrionHeroAnimInstance::PostPivotAnimDeltaAngle' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, PostPivotAnimYawAimOffset) == 0x000AD0, "Member 'UOrionHeroAnimInstance::PostPivotAnimYawAimOffset' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, PostPivotLockedDeltaAngle) == 0x000AD4, "Member 'UOrionHeroAnimInstance::PostPivotLockedDeltaAngle' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, PostPivotTransitionSpeedWarpingAlpha) == 0x000AD8, "Member 'UOrionHeroAnimInstance::PostPivotTransitionSpeedWarpingAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, PostPivotTransitionSpeedWarpingAmount) == 0x000ADC, "Member 'UOrionHeroAnimInstance::PostPivotTransitionSpeedWarpingAmount' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bPostPivotLockedRotation) == 0x000AE0, "Member 'UOrionHeroAnimInstance::bPostPivotLockedRotation' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, DefaultJumpAnimSet) == 0x000AE8, "Member 'UOrionHeroAnimInstance::DefaultJumpAnimSet' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, TravelModeOverrideJumpAnimSet) == 0x000B10, "Member 'UOrionHeroAnimInstance::TravelModeOverrideJumpAnimSet' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, JumpAnimSet) == 0x000B38, "Member 'UOrionHeroAnimInstance::JumpAnimSet' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, JumpingCachedState) == 0x000B60, "Member 'UOrionHeroAnimInstance::JumpingCachedState' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bJumpTriggered) == 0x000B80, "Member 'UOrionHeroAnimInstance::bJumpTriggered' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bFallTriggered) == 0x000B81, "Member 'UOrionHeroAnimInstance::bFallTriggered' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, JumpTakeOffLocation) == 0x000B84, "Member 'UOrionHeroAnimInstance::JumpTakeOffLocation' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, JumpTakeOffAnimPosition) == 0x000B90, "Member 'UOrionHeroAnimInstance::JumpTakeOffAnimPosition' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, JumpTakeOffToApexBlendTime) == 0x000B94, "Member 'UOrionHeroAnimInstance::JumpTakeOffToApexBlendTime' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, JumpTakeOffToApexBlendAlpha) == 0x000B98, "Member 'UOrionHeroAnimInstance::JumpTakeOffToApexBlendAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bUpdateJumpArc) == 0x000B9C, "Member 'UOrionHeroAnimInstance::bUpdateJumpArc' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, JumpArcApexPosition) == 0x000BA0, "Member 'UOrionHeroAnimInstance::JumpArcApexPosition' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, JumpArcAnimPosition) == 0x000BA4, "Member 'UOrionHeroAnimInstance::JumpArcAnimPosition' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, JumpArcEdgeCompressionExponent) == 0x000BA8, "Member 'UOrionHeroAnimInstance::JumpArcEdgeCompressionExponent' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bPlayPreLand) == 0x000BAC, "Member 'UOrionHeroAnimInstance::bPlayPreLand' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, PredictedLandingLocation) == 0x000BB0, "Member 'UOrionHeroAnimInstance::PredictedLandingLocation' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, JumpPreLandAnimPosition) == 0x000BBC, "Member 'UOrionHeroAnimInstance::JumpPreLandAnimPosition' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, JumpPostLandAdditiveAnimPosition) == 0x000BC0, "Member 'UOrionHeroAnimInstance::JumpPostLandAdditiveAnimPosition' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, JumpPostLandAdditiveAnimMaxWeight) == 0x000BC4, "Member 'UOrionHeroAnimInstance::JumpPostLandAdditiveAnimMaxWeight' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, JumpPostLandAdditiveAnimMaxWeightJogging) == 0x000BC8, "Member 'UOrionHeroAnimInstance::JumpPostLandAdditiveAnimMaxWeightJogging' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, JumpPostLandAdditiveAnimMaxWeightOnSlope) == 0x000BCC, "Member 'UOrionHeroAnimInstance::JumpPostLandAdditiveAnimMaxWeightOnSlope' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, PredictedJumpStateWeight) == 0x000BD0, "Member 'UOrionHeroAnimInstance::PredictedJumpStateWeight' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, JumpPostLandAdditiveAnimWeight) == 0x000BD4, "Member 'UOrionHeroAnimInstance::JumpPostLandAdditiveAnimWeight' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, JumpPostLandAdditiveActiveWeight) == 0x000BD8, "Member 'UOrionHeroAnimInstance::JumpPostLandAdditiveActiveWeight' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, JumpPostLandAnimWeightInterpolator) == 0x000BDC, "Member 'UOrionHeroAnimInstance::JumpPostLandAnimWeightInterpolator' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bJumpPostLandAdditiveResetAnimPostion) == 0x000C00, "Member 'UOrionHeroAnimInstance::bJumpPostLandAdditiveResetAnimPostion' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, JumpRootRotation) == 0x000C04, "Member 'UOrionHeroAnimInstance::JumpRootRotation' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, JumpRootRotationOffset) == 0x000C08, "Member 'UOrionHeroAnimInstance::JumpRootRotationOffset' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, MinusJumpRootRotation) == 0x000C0C, "Member 'UOrionHeroAnimInstance::MinusJumpRootRotation' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, PelvisBoneName) == 0x000C10, "Member 'UOrionHeroAnimInstance::PelvisBoneName' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, PelvisBoneIndex) == 0x000C18, "Member 'UOrionHeroAnimInstance::PelvisBoneIndex' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, PelvisBoneForwardAxis) == 0x000C1C, "Member 'UOrionHeroAnimInstance::PelvisBoneForwardAxis' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bJumpHasLanded) == 0x000C1D, "Member 'UOrionHeroAnimInstance::bJumpHasLanded' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, JumpPostLandStartAnimOverride) == 0x000C20, "Member 'UOrionHeroAnimInstance::JumpPostLandStartAnimOverride' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bPlayStartTransitionOnLand) == 0x000C40, "Member 'UOrionHeroAnimInstance::bPlayStartTransitionOnLand' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, TurnRootRotationYaw) == 0x000C44, "Member 'UOrionHeroAnimInstance::TurnRootRotationYaw' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, FinalRootRotationYaw) == 0x000C48, "Member 'UOrionHeroAnimInstance::FinalRootRotationYaw' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, SlotNodesForcingFacingForward) == 0x000C50, "Member 'UOrionHeroAnimInstance::SlotNodesForcingFacingForward' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bIsForcedFacingForward) == 0x000C60, "Member 'UOrionHeroAnimInstance::bIsForcedFacingForward' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, ForcedFacingForwardInterpolator) == 0x000C64, "Member 'UOrionHeroAnimInstance::ForcedFacingForwardInterpolator' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, TurnSpeedInterpolator) == 0x000C88, "Member 'UOrionHeroAnimInstance::TurnSpeedInterpolator' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, TurnSpeedInterpolatorLimit) == 0x000CAC, "Member 'UOrionHeroAnimInstance::TurnSpeedInterpolatorLimit' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, TurnSpeedMinThreshold) == 0x000CB0, "Member 'UOrionHeroAnimInstance::TurnSpeedMinThreshold' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, TargetingAbilityForcedFacingForward) == 0x000CB4, "Member 'UOrionHeroAnimInstance::TargetingAbilityForcedFacingForward' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, ActiveAbilityForcedFacingForward) == 0x000CBD, "Member 'UOrionHeroAnimInstance::ActiveAbilityForcedFacingForward' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bEnableTurnInPlaceTransition) == 0x000CC6, "Member 'UOrionHeroAnimInstance::bEnableTurnInPlaceTransition' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bTurnCompensatingActorRotation) == 0x000CC7, "Member 'UOrionHeroAnimInstance::bTurnCompensatingActorRotation' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, TurnInPlaceCachedStates) == 0x000CC8, "Member 'UOrionHeroAnimInstance::TurnInPlaceCachedStates' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, TurnTransitions) == 0x000CD8, "Member 'UOrionHeroAnimInstance::TurnTransitions' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, TravelModeTurnTransitions) == 0x000CE8, "Member 'UOrionHeroAnimInstance::TravelModeTurnTransitions' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, TurnTransitionDeadZoneAngle) == 0x000CF8, "Member 'UOrionHeroAnimInstance::TurnTransitionDeadZoneAngle' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, TurnInPlaceRootRotation) == 0x000CFC, "Member 'UOrionHeroAnimInstance::TurnInPlaceRootRotation' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, TurnInPlaceAimOffsetYaw) == 0x000D00, "Member 'UOrionHeroAnimInstance::TurnInPlaceAimOffsetYaw' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, TurnTransitionAimOffsetLagWeight) == 0x000D04, "Member 'UOrionHeroAnimInstance::TurnTransitionAimOffsetLagWeight' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, TurnInPlaceAimOffsetInterpolator) == 0x000D08, "Member 'UOrionHeroAnimInstance::TurnInPlaceAimOffsetInterpolator' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bTurnInPlaceTransitionTriggered) == 0x000D2C, "Member 'UOrionHeroAnimInstance::bTurnInPlaceTransitionTriggered' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, TurnTransitionCachedState) == 0x000D30, "Member 'UOrionHeroAnimInstance::TurnTransitionCachedState' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, TurnInPlaceAnim) == 0x000D50, "Member 'UOrionHeroAnimInstance::TurnInPlaceAnim' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, TurnInPlaceAnimPosition) == 0x000D58, "Member 'UOrionHeroAnimInstance::TurnInPlaceAnimPosition' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, LastTimeCheckedForATurnTransition) == 0x000D70, "Member 'UOrionHeroAnimInstance::LastTimeCheckedForATurnTransition' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, TurnInPlaceDelayCounter) == 0x000D74, "Member 'UOrionHeroAnimInstance::TurnInPlaceDelayCounter' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, TurnInPlaceAnimCurrentAngle) == 0x000D78, "Member 'UOrionHeroAnimInstance::TurnInPlaceAnimCurrentAngle' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bPlayTurnInPlaceRecovery) == 0x000D7C, "Member 'UOrionHeroAnimInstance::bPlayTurnInPlaceRecovery' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bTurnInPlaceRecoveryTriggered) == 0x000D7D, "Member 'UOrionHeroAnimInstance::bTurnInPlaceRecoveryTriggered' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, TurnRecoveryCachedState) == 0x000D80, "Member 'UOrionHeroAnimInstance::TurnRecoveryCachedState' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, TurnInPlaceRecoveryAnim) == 0x000DA0, "Member 'UOrionHeroAnimInstance::TurnInPlaceRecoveryAnim' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, TurnInPlaceRecoveryAnimPosition) == 0x000DA8, "Member 'UOrionHeroAnimInstance::TurnInPlaceRecoveryAnimPosition' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bEnableSpinTransition) == 0x000DAC, "Member 'UOrionHeroAnimInstance::bEnableSpinTransition' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, SpinTransitionCachedState) == 0x000DB0, "Member 'UOrionHeroAnimInstance::SpinTransitionCachedState' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bSpinTransitionStateTriggered) == 0x000DD0, "Member 'UOrionHeroAnimInstance::bSpinTransitionStateTriggered' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bSpinTransitionCompleted) == 0x000DD1, "Member 'UOrionHeroAnimInstance::bSpinTransitionCompleted' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, SpinInterpolator) == 0x000DD4, "Member 'UOrionHeroAnimInstance::SpinInterpolator' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, DefaultSpinAnimSet) == 0x000DF8, "Member 'UOrionHeroAnimInstance::DefaultSpinAnimSet' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, TravelModeSpinAnimSetOverride) == 0x000E18, "Member 'UOrionHeroAnimInstance::TravelModeSpinAnimSetOverride' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bSpinTransitionIsLeader) == 0x000E38, "Member 'UOrionHeroAnimInstance::bSpinTransitionIsLeader' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, SpinTransitionAnim) == 0x000E40, "Member 'UOrionHeroAnimInstance::SpinTransitionAnim' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, SpinTransitionAnimPosition) == 0x000E48, "Member 'UOrionHeroAnimInstance::SpinTransitionAnimPosition' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, SpinTransitionCardinalDir) == 0x000E4C, "Member 'UOrionHeroAnimInstance::SpinTransitionCardinalDir' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, SpinTransitionRootYawOffset) == 0x000E50, "Member 'UOrionHeroAnimInstance::SpinTransitionRootYawOffset' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, SpinTransitionAimOffsetInterpolator) == 0x000E54, "Member 'UOrionHeroAnimInstance::SpinTransitionAimOffsetInterpolator' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, SpinTransitionAimYawOffset) == 0x000E78, "Member 'UOrionHeroAnimInstance::SpinTransitionAimYawOffset' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, SpinTransitionAccumulatedYawTurn) == 0x000E7C, "Member 'UOrionHeroAnimInstance::SpinTransitionAccumulatedYawTurn' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, SpinTransitionCurrentAngle) == 0x000E80, "Member 'UOrionHeroAnimInstance::SpinTransitionCurrentAngle' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, SpinTransitionAngleSign) == 0x000E84, "Member 'UOrionHeroAnimInstance::SpinTransitionAngleSign' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, SpinTransitionIsClockwiseTurn) == 0x000E88, "Member 'UOrionHeroAnimInstance::SpinTransitionIsClockwiseTurn' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, SpinTransitionIsABackPedal) == 0x000E89, "Member 'UOrionHeroAnimInstance::SpinTransitionIsABackPedal' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, AimOffsetYaw) == 0x000E8C, "Member 'UOrionHeroAnimInstance::AimOffsetYaw' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, AimOffsetPitch) == 0x000E90, "Member 'UOrionHeroAnimInstance::AimOffsetPitch' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, AimOffsetAlpha) == 0x000E94, "Member 'UOrionHeroAnimInstance::AimOffsetAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, DisableAimOffsetCurveName) == 0x000E98, "Member 'UOrionHeroAnimInstance::DisableAimOffsetCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, MeleeTwistCurveName) == 0x000EA0, "Member 'UOrionHeroAnimInstance::MeleeTwistCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, MeleeTwistCurveValue) == 0x000EA8, "Member 'UOrionHeroAnimInstance::MeleeTwistCurveValue' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, MinusMeleeTwistCurveValue) == 0x000EAC, "Member 'UOrionHeroAnimInstance::MinusMeleeTwistCurveValue' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, MeleeTwistBlendWeight) == 0x000EB0, "Member 'UOrionHeroAnimInstance::MeleeTwistBlendWeight' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, MeleeTwistBlendWeightInterpolator) == 0x000EB4, "Member 'UOrionHeroAnimInstance::MeleeTwistBlendWeightInterpolator' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, MeleeTwistDirectionalBlendTime) == 0x000ED8, "Member 'UOrionHeroAnimInstance::MeleeTwistDirectionalBlendTime' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, TurnInPlaceStrafePlayRate) == 0x000EDC, "Member 'UOrionHeroAnimInstance::TurnInPlaceStrafePlayRate' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, TurnInPlaceStrafeBlendWeight) == 0x000EE0, "Member 'UOrionHeroAnimInstance::TurnInPlaceStrafeBlendWeight' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, TurnInPlaceMeleeTwistStrafeBlendWeight) == 0x000EE4, "Member 'UOrionHeroAnimInstance::TurnInPlaceMeleeTwistStrafeBlendWeight' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, TurnInPlaceStrafeMovementAngle) == 0x000EE8, "Member 'UOrionHeroAnimInstance::TurnInPlaceStrafeMovementAngle' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, WeaponScaleCurveAlpha) == 0x000EEC, "Member 'UOrionHeroAnimInstance::WeaponScaleCurveAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, AbilityTags) == 0x000EF0, "Member 'UOrionHeroAnimInstance::AbilityTags' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bIsKnockedBack) == 0x000F30, "Member 'UOrionHeroAnimInstance::bIsKnockedBack' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bIsKnockedUp) == 0x000F31, "Member 'UOrionHeroAnimInstance::bIsKnockedUp' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bIsRecalling) == 0x000F32, "Member 'UOrionHeroAnimInstance::bIsRecalling' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bIsStunned) == 0x000F33, "Member 'UOrionHeroAnimInstance::bIsStunned' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bIsTravelModeStunned) == 0x000F34, "Member 'UOrionHeroAnimInstance::bIsTravelModeStunned' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, AbilityStateTriggered) == 0x000F35, "Member 'UOrionHeroAnimInstance::AbilityStateTriggered' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, AbilityStateUntriggered) == 0x000F3E, "Member 'UOrionHeroAnimInstance::AbilityStateUntriggered' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, AbilityStateActive) == 0x000F47, "Member 'UOrionHeroAnimInstance::AbilityStateActive' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, AbilityStateLastFrame) == 0x000F50, "Member 'UOrionHeroAnimInstance::AbilityStateLastFrame' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, AbilityTargetingTriggered) == 0x000F59, "Member 'UOrionHeroAnimInstance::AbilityTargetingTriggered' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, AbilityTargetingActive) == 0x000F62, "Member 'UOrionHeroAnimInstance::AbilityTargetingActive' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, AbilityTargetingLastFrame) == 0x000F6B, "Member 'UOrionHeroAnimInstance::AbilityTargetingLastFrame' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bIsAbilityTargeting_LMB_BasicPrimary) == 0x000F74, "Member 'UOrionHeroAnimInstance::bIsAbilityTargeting_LMB_BasicPrimary' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bIsAbilityTargeting_RMB_Alternate) == 0x000F75, "Member 'UOrionHeroAnimInstance::bIsAbilityTargeting_RMB_Alternate' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bIsAbilityTargeting_Q_Primary) == 0x000F76, "Member 'UOrionHeroAnimInstance::bIsAbilityTargeting_Q_Primary' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bIsAbilityTargeting_E_Secondary) == 0x000F77, "Member 'UOrionHeroAnimInstance::bIsAbilityTargeting_E_Secondary' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bIsAbilityTargeting_R_Ultimate) == 0x000F78, "Member 'UOrionHeroAnimInstance::bIsAbilityTargeting_R_Ultimate' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, HeroStatusFlagsActive) == 0x000F79, "Member 'UOrionHeroAnimInstance::HeroStatusFlagsActive' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, HeroStatusFlagsTriggered) == 0x000F82, "Member 'UOrionHeroAnimInstance::HeroStatusFlagsTriggered' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, InternalHeroStatusFlagsLastFrame) == 0x000F8B, "Member 'UOrionHeroAnimInstance::InternalHeroStatusFlagsLastFrame' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, ActiveAbilityFlagsForcingTravelModeAnims) == 0x000F94, "Member 'UOrionHeroAnimInstance::ActiveAbilityFlagsForcingTravelModeAnims' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, AbilityTargetingFlagsForcingTravelModeAnims) == 0x000F9D, "Member 'UOrionHeroAnimInstance::AbilityTargetingFlagsForcingTravelModeAnims' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, ActiveStatusFlagsForcingTravelModeAnims) == 0x000FA6, "Member 'UOrionHeroAnimInstance::ActiveStatusFlagsForcingTravelModeAnims' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, ForcedTravelModeExtendedTime) == 0x000FB0, "Member 'UOrionHeroAnimInstance::ForcedTravelModeExtendedTime' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, ForcedTravelModeExtendedTimeLeft) == 0x000FB4, "Member 'UOrionHeroAnimInstance::ForcedTravelModeExtendedTimeLeft' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bIsInTravelMode) == 0x000FB8, "Member 'UOrionHeroAnimInstance::bIsInTravelMode' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bTravelModeTriggered) == 0x000FB9, "Member 'UOrionHeroAnimInstance::bTravelModeTriggered' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bTravelModeUntriggered) == 0x000FBA, "Member 'UOrionHeroAnimInstance::bTravelModeUntriggered' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bWasInTravelModeLastFrame) == 0x000FBB, "Member 'UOrionHeroAnimInstance::bWasInTravelModeLastFrame' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bIsCastingTravelMode) == 0x000FBC, "Member 'UOrionHeroAnimInstance::bIsCastingTravelMode' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, TravelModeStartAnimOverride) == 0x000FC0, "Member 'UOrionHeroAnimInstance::TravelModeStartAnimOverride' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, TravelModeStopAnimOverride) == 0x000FE0, "Member 'UOrionHeroAnimInstance::TravelModeStopAnimOverride' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, TravelModePivotAnimOverride) == 0x001000, "Member 'UOrionHeroAnimInstance::TravelModePivotAnimOverride' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, TravelModeLocomotionDeltaAngle_E) == 0x001020, "Member 'UOrionHeroAnimInstance::TravelModeLocomotionDeltaAngle_E' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, TravelModeLocomotionDeltaAngle_W) == 0x001024, "Member 'UOrionHeroAnimInstance::TravelModeLocomotionDeltaAngle_W' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bSwitchTransitionAnimsOnTravelModeTriggered) == 0x001028, "Member 'UOrionHeroAnimInstance::bSwitchTransitionAnimsOnTravelModeTriggered' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bSwitchTransitionAnimsOnTravelModeUnTriggered) == 0x001029, "Member 'UOrionHeroAnimInstance::bSwitchTransitionAnimsOnTravelModeUnTriggered' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, CurrentAllowedTransitionFlags) == 0x00102A, "Member 'UOrionHeroAnimInstance::CurrentAllowedTransitionFlags' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, DefaultAllowedTransitionFlags) == 0x001031, "Member 'UOrionHeroAnimInstance::DefaultAllowedTransitionFlags' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, TravelModeAllowedTransitionFlags) == 0x001038, "Member 'UOrionHeroAnimInstance::TravelModeAllowedTransitionFlags' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, ForcedFacingForwardOverrideTransitionFlags) == 0x00103F, "Member 'UOrionHeroAnimInstance::ForcedFacingForwardOverrideTransitionFlags' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, HitReactAnims) == 0x001048, "Member 'UOrionHeroAnimInstance::HitReactAnims' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, HitReactAnim) == 0x001068, "Member 'UOrionHeroAnimInstance::HitReactAnim' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bPlayingHitReact) == 0x001070, "Member 'UOrionHeroAnimInstance::bPlayingHitReact' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, HitReactAnimPosition) == 0x001074, "Member 'UOrionHeroAnimInstance::HitReactAnimPosition' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, HitReactBlendAlpha) == 0x001078, "Member 'UOrionHeroAnimInstance::HitReactBlendAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bPlaySimpleHitReact) == 0x00107C, "Member 'UOrionHeroAnimInstance::bPlaySimpleHitReact' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, SlotName_FullBody) == 0x001080, "Member 'UOrionHeroAnimInstance::SlotName_FullBody' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, SlotName_FullBody_FWD) == 0x001088, "Member 'UOrionHeroAnimInstance::SlotName_FullBody_FWD' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, SlotName_FullBodyInAir) == 0x001090, "Member 'UOrionHeroAnimInstance::SlotName_FullBodyInAir' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, SlotName_FullBodyOnGround) == 0x001098, "Member 'UOrionHeroAnimInstance::SlotName_FullBodyOnGround' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, SlotName_UpperBodyInMotion) == 0x0010A0, "Member 'UOrionHeroAnimInstance::SlotName_UpperBodyInMotion' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, SlotName_FullBodyInPlace) == 0x0010A8, "Member 'UOrionHeroAnimInstance::SlotName_FullBodyInPlace' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, SlotName_UpperBody) == 0x0010B0, "Member 'UOrionHeroAnimInstance::SlotName_UpperBody' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, SlotName_FullBodyYawAdjust) == 0x0010B8, "Member 'UOrionHeroAnimInstance::SlotName_FullBodyYawAdjust' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, SlotName_ArmsAndHead) == 0x0010C0, "Member 'UOrionHeroAnimInstance::SlotName_ArmsAndHead' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, SlotName_ArmsAndHead_InMotion) == 0x0010C8, "Member 'UOrionHeroAnimInstance::SlotName_ArmsAndHead_InMotion' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, SlotName_UpperBodyMSA) == 0x0010D0, "Member 'UOrionHeroAnimInstance::SlotName_UpperBodyMSA' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, SlotName_UpperBodyMSA_InMotion) == 0x0010D8, "Member 'UOrionHeroAnimInstance::SlotName_UpperBodyMSA_InMotion' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, UpperBodySlotMaskWeight) == 0x0010E0, "Member 'UOrionHeroAnimInstance::UpperBodySlotMaskWeight' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bLowerBodyInMotion) == 0x0010E4, "Member 'UOrionHeroAnimInstance::bLowerBodyInMotion' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bActivateFullBodyInAirMask) == 0x0010E5, "Member 'UOrionHeroAnimInstance::bActivateFullBodyInAirMask' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bActivateUpperBodyInMotionMask) == 0x0010E6, "Member 'UOrionHeroAnimInstance::bActivateUpperBodyInMotionMask' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, FullBodyYawAdjustRotation) == 0x0010E8, "Member 'UOrionHeroAnimInstance::FullBodyYawAdjustRotation' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bPlayingFullBodyDirectional) == 0x0010EC, "Member 'UOrionHeroAnimInstance::bPlayingFullBodyDirectional' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, UpperBodyApplyMSAWeight) == 0x0010F0, "Member 'UOrionHeroAnimInstance::UpperBodyApplyMSAWeight' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, UpperBodyMSAMaskWeight) == 0x0010F4, "Member 'UOrionHeroAnimInstance::UpperBodyMSAMaskWeight' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, ArmsAndHeadMaskWeight) == 0x0010F8, "Member 'UOrionHeroAnimInstance::ArmsAndHeadMaskWeight' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, ArmsAndHead_IdleCachedState) == 0x001100, "Member 'UOrionHeroAnimInstance::ArmsAndHead_IdleCachedState' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, UpperBodyMSA_IdleCachedState) == 0x001120, "Member 'UOrionHeroAnimInstance::UpperBodyMSA_IdleCachedState' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, UpperBody_IdleCachedState) == 0x001140, "Member 'UOrionHeroAnimInstance::UpperBody_IdleCachedState' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bChildClassTriggeredUpperBodyMSALayer) == 0x001160, "Member 'UOrionHeroAnimInstance::bChildClassTriggeredUpperBodyMSALayer' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bChildClassTriggeredArmsAndHeadLayer) == 0x001161, "Member 'UOrionHeroAnimInstance::bChildClassTriggeredArmsAndHeadLayer' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, ArmsAndHeadLayerFullBodyWeight) == 0x001164, "Member 'UOrionHeroAnimInstance::ArmsAndHeadLayerFullBodyWeight' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, MSALayerFullBodyCachedStateArray) == 0x001168, "Member 'UOrionHeroAnimInstance::MSALayerFullBodyCachedStateArray' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, MSALayerFullBodyWeight) == 0x001180, "Member 'UOrionHeroAnimInstance::MSALayerFullBodyWeight' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bAMontageStartedBlendingOut) == 0x001184, "Member 'UOrionHeroAnimInstance::bAMontageStartedBlendingOut' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bATagHasChanged) == 0x001185, "Member 'UOrionHeroAnimInstance::bATagHasChanged' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bIsUpperBodyMSA_InMotion) == 0x001186, "Member 'UOrionHeroAnimInstance::bIsUpperBodyMSA_InMotion' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bIsArmsAndHead_InMotion) == 0x001187, "Member 'UOrionHeroAnimInstance::bIsArmsAndHead_InMotion' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bPlayTargetingAbilityInMotion) == 0x001188, "Member 'UOrionHeroAnimInstance::bPlayTargetingAbilityInMotion' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bShouldTransitionToStunnedState) == 0x001189, "Member 'UOrionHeroAnimInstance::bShouldTransitionToStunnedState' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bShouldTransitionToKnockedBackState) == 0x00118A, "Member 'UOrionHeroAnimInstance::bShouldTransitionToKnockedBackState' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bShouldEarlyOutTurnInPlaceState) == 0x00118B, "Member 'UOrionHeroAnimInstance::bShouldEarlyOutTurnInPlaceState' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bShouldEarlyOutPrePivotState) == 0x00118C, "Member 'UOrionHeroAnimInstance::bShouldEarlyOutPrePivotState' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bShouldEarlyOutPostPivotState) == 0x00118D, "Member 'UOrionHeroAnimInstance::bShouldEarlyOutPostPivotState' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bShouldEarlyOutSpinState) == 0x00118E, "Member 'UOrionHeroAnimInstance::bShouldEarlyOutSpinState' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bShouldEarlyOutLocomotionLoopState) == 0x00118F, "Member 'UOrionHeroAnimInstance::bShouldEarlyOutLocomotionLoopState' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bIdle2LocomotionLoopStateFailsafeTransition) == 0x001190, "Member 'UOrionHeroAnimInstance::bIdle2LocomotionLoopStateFailsafeTransition' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bShouldEarlyOutStopState) == 0x001191, "Member 'UOrionHeroAnimInstance::bShouldEarlyOutStopState' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bShouldEarlyOutStartState) == 0x001192, "Member 'UOrionHeroAnimInstance::bShouldEarlyOutStartState' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bShouldEarlyOutJumpingState) == 0x001193, "Member 'UOrionHeroAnimInstance::bShouldEarlyOutJumpingState' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bPostLandIdleTriggered) == 0x001194, "Member 'UOrionHeroAnimInstance::bPostLandIdleTriggered' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, bShouldEarlyOutPostLandIdleState) == 0x001195, "Member 'UOrionHeroAnimInstance::bShouldEarlyOutPostLandIdleState' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, AnimDynamicsForceScaling) == 0x001198, "Member 'UOrionHeroAnimInstance::AnimDynamicsForceScaling' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, AnimDynamicsForce) == 0x00119C, "Member 'UOrionHeroAnimInstance::AnimDynamicsForce' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, DisableClothAlphaCurveName) == 0x0011A8, "Member 'UOrionHeroAnimInstance::DisableClothAlphaCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroAnimInstance, WeaponScaleCurveName) == 0x0011B0, "Member 'UOrionHeroAnimInstance::WeaponScaleCurveName' has a wrong offset!");

// Class OrionGame.OrionHeroMamboAnimInstance
// 0x0020 (0x11E0 - 0x11C0)
class UOrionHeroMamboAnimInstance final : public UOrionHeroAnimInstance
{
public:
	bool                                          ShouldHideDoll;                                    // 0x11B8(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11B9[0x3];                                     // 0x11B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HideDefaultDollAlpha;                              // 0x11BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnableIKWeaponRAlpha;                              // 0x11C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SnapDollToWeaponRAlpha;                            // 0x11C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DollHolderDynamicsAlpha;                           // 0x11C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FacialOverrideAlpha;                               // 0x11CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAttacking;                                      // 0x11D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11D1[0xF];                                     // 0x11D1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHeroMamboAnimInstance">();
	}
	static class UOrionHeroMamboAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHeroMamboAnimInstance>();
	}
};
static_assert(alignof(UOrionHeroMamboAnimInstance) == 0x000010, "Wrong alignment on UOrionHeroMamboAnimInstance");
static_assert(sizeof(UOrionHeroMamboAnimInstance) == 0x0011E0, "Wrong size on UOrionHeroMamboAnimInstance");
static_assert(offsetof(UOrionHeroMamboAnimInstance, ShouldHideDoll) == 0x0011B8, "Member 'UOrionHeroMamboAnimInstance::ShouldHideDoll' has a wrong offset!");
static_assert(offsetof(UOrionHeroMamboAnimInstance, HideDefaultDollAlpha) == 0x0011BC, "Member 'UOrionHeroMamboAnimInstance::HideDefaultDollAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroMamboAnimInstance, EnableIKWeaponRAlpha) == 0x0011C0, "Member 'UOrionHeroMamboAnimInstance::EnableIKWeaponRAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroMamboAnimInstance, SnapDollToWeaponRAlpha) == 0x0011C4, "Member 'UOrionHeroMamboAnimInstance::SnapDollToWeaponRAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroMamboAnimInstance, DollHolderDynamicsAlpha) == 0x0011C8, "Member 'UOrionHeroMamboAnimInstance::DollHolderDynamicsAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroMamboAnimInstance, FacialOverrideAlpha) == 0x0011CC, "Member 'UOrionHeroMamboAnimInstance::FacialOverrideAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroMamboAnimInstance, bIsAttacking) == 0x0011D0, "Member 'UOrionHeroMamboAnimInstance::bIsAttacking' has a wrong offset!");

// Class OrionGame.OrionMcpItemDefinition
// 0x0238 (0x0268 - 0x0030)
#pragma pack(push, 0x1)
class alignas(0x08) UOrionMcpItemDefinition : public UMcpItemDefinitionBase
{
public:
	uint8                                         Pad_30[0x118];                                     // 0x0030(0x0118)(Fixing Size After Last Property [ Dumper-7 ])
	EOrionItemType                                ItemType;                                          // 0x0148(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrionItemRarity                              ItemRarity;                                        // 0x0149(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14A[0x6];                                      // 0x014A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ItemDisplayName;                                   // 0x0150(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, AssetRegistrySearchable, Protected, NativeAccessSpecifierProtected)
	class FText                                   ItemCardinalDisplayName;                           // 0x0168(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   ItemDisplayDescription;                            // 0x0180(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	EOrionItemFlyLocation                         ItemFlyLocation;                                   // 0x0198(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_199[0x7];                                      // 0x0199(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayNamePrefix;                                 // 0x01A0(0x0018)(Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UObject>                 ItemDisplayAsset;                                  // 0x01B8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UObject>                 ItemTypeImageOverrideAsset;                        // 0x01E0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   TypeNameOverride;                                  // 0x0208(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FOrionMcpItemDefinitionRewardDisplay> RewardDisplayItems;                                // 0x0220(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UOrionCustomStoreContentWidget> CustomStoreContentWidget;                          // 0x0230(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAllowMultipleStacks : 1;                          // 0x0238(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_239[0x3];                                      // 0x0239(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxStackSize;                                      // 0x023C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FOrionMcpTranslateTokenMapping> TranslateTokenMapping;                             // 0x0240(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_250[0x10];                                     // 0x0250(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LoadedGameplayCueNotifyHandle;                     // 0x0260(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LoadedFrontEndGameplayCueNotifyHandle;             // 0x0264(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	TSubclassOf<class UOrionCustomStoreContentWidget> GetCustomStoreContentWidget() const;
	class UTexture2D* GetIcon() const;
	const TSoftObjectPtr<class UObject> GetIconAsset() const;
	class UMaterialInterface* GetIconMaterial() const;
	class FString GetPersistentName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpItemDefinition">();
	}
	static class UOrionMcpItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpItemDefinition>();
	}
};
#pragma pack(pop)
static_assert(alignof(UOrionMcpItemDefinition) == 0x000008, "Wrong alignment on UOrionMcpItemDefinition");
static_assert(sizeof(UOrionMcpItemDefinition) == 0x000268, "Wrong size on UOrionMcpItemDefinition");
static_assert(offsetof(UOrionMcpItemDefinition, ItemType) == 0x000148, "Member 'UOrionMcpItemDefinition::ItemType' has a wrong offset!");
static_assert(offsetof(UOrionMcpItemDefinition, ItemRarity) == 0x000149, "Member 'UOrionMcpItemDefinition::ItemRarity' has a wrong offset!");
static_assert(offsetof(UOrionMcpItemDefinition, ItemDisplayName) == 0x000150, "Member 'UOrionMcpItemDefinition::ItemDisplayName' has a wrong offset!");
static_assert(offsetof(UOrionMcpItemDefinition, ItemCardinalDisplayName) == 0x000168, "Member 'UOrionMcpItemDefinition::ItemCardinalDisplayName' has a wrong offset!");
static_assert(offsetof(UOrionMcpItemDefinition, ItemDisplayDescription) == 0x000180, "Member 'UOrionMcpItemDefinition::ItemDisplayDescription' has a wrong offset!");
static_assert(offsetof(UOrionMcpItemDefinition, ItemFlyLocation) == 0x000198, "Member 'UOrionMcpItemDefinition::ItemFlyLocation' has a wrong offset!");
static_assert(offsetof(UOrionMcpItemDefinition, DisplayNamePrefix) == 0x0001A0, "Member 'UOrionMcpItemDefinition::DisplayNamePrefix' has a wrong offset!");
static_assert(offsetof(UOrionMcpItemDefinition, ItemDisplayAsset) == 0x0001B8, "Member 'UOrionMcpItemDefinition::ItemDisplayAsset' has a wrong offset!");
static_assert(offsetof(UOrionMcpItemDefinition, ItemTypeImageOverrideAsset) == 0x0001E0, "Member 'UOrionMcpItemDefinition::ItemTypeImageOverrideAsset' has a wrong offset!");
static_assert(offsetof(UOrionMcpItemDefinition, TypeNameOverride) == 0x000208, "Member 'UOrionMcpItemDefinition::TypeNameOverride' has a wrong offset!");
static_assert(offsetof(UOrionMcpItemDefinition, RewardDisplayItems) == 0x000220, "Member 'UOrionMcpItemDefinition::RewardDisplayItems' has a wrong offset!");
static_assert(offsetof(UOrionMcpItemDefinition, CustomStoreContentWidget) == 0x000230, "Member 'UOrionMcpItemDefinition::CustomStoreContentWidget' has a wrong offset!");
static_assert(offsetof(UOrionMcpItemDefinition, MaxStackSize) == 0x00023C, "Member 'UOrionMcpItemDefinition::MaxStackSize' has a wrong offset!");
static_assert(offsetof(UOrionMcpItemDefinition, TranslateTokenMapping) == 0x000240, "Member 'UOrionMcpItemDefinition::TranslateTokenMapping' has a wrong offset!");
static_assert(offsetof(UOrionMcpItemDefinition, LoadedGameplayCueNotifyHandle) == 0x000260, "Member 'UOrionMcpItemDefinition::LoadedGameplayCueNotifyHandle' has a wrong offset!");
static_assert(offsetof(UOrionMcpItemDefinition, LoadedFrontEndGameplayCueNotifyHandle) == 0x000264, "Member 'UOrionMcpItemDefinition::LoadedFrontEndGameplayCueNotifyHandle' has a wrong offset!");

// Class OrionGame.OrionBTTask_TriggerAttack
// 0x0000 (0x0098 - 0x0098)
class UOrionBTTask_TriggerAttack final : public UBTTask_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionBTTask_TriggerAttack">();
	}
	static class UOrionBTTask_TriggerAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionBTTask_TriggerAttack>();
	}
};
static_assert(alignof(UOrionBTTask_TriggerAttack) == 0x000008, "Wrong alignment on UOrionBTTask_TriggerAttack");
static_assert(sizeof(UOrionBTTask_TriggerAttack) == 0x000098, "Wrong size on UOrionBTTask_TriggerAttack");

// Class OrionGame.OrionCharacterData
// 0x00C0 (0x0328 - 0x0268)
#pragma pack(push, 0x1)
class alignas(0x08) UOrionCharacterData : public UOrionMcpItemDefinition
{
public:
	struct FGameplayTagContainer                  CharacterTags;                                     // 0x0268(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  LootSourceTags;                                    // 0x0288(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  LootAssetTags;                                     // 0x02A8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PawnClassWeakRef;                                  // 0x02C8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UOrionAbilitySet>> AbilitiesWeakRef;                                  // 0x02F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class FName                                   CharacterData;                                     // 0x0300(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionVisionDef*                        VisionData;                                        // 0x0308(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AOrionChar>                 LoadedPawnClass;                                   // 0x0310(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UOrionAbilitySet*>               LoadedAbilities;                                   // 0x0318(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void OnAbilityDataLoaded__DelegateSignature(const TArray<class UOrionAbilitySet*>& Abilities);

	bool LoadAbilityData(TDelegate<void(TArray<class UOrionAbilitySet*>& Abilities)> Callback) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCharacterData">();
	}
	static class UOrionCharacterData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionCharacterData>();
	}
};
#pragma pack(pop)
static_assert(alignof(UOrionCharacterData) == 0x000008, "Wrong alignment on UOrionCharacterData");
static_assert(sizeof(UOrionCharacterData) == 0x000328, "Wrong size on UOrionCharacterData");
static_assert(offsetof(UOrionCharacterData, CharacterTags) == 0x000268, "Member 'UOrionCharacterData::CharacterTags' has a wrong offset!");
static_assert(offsetof(UOrionCharacterData, LootSourceTags) == 0x000288, "Member 'UOrionCharacterData::LootSourceTags' has a wrong offset!");
static_assert(offsetof(UOrionCharacterData, LootAssetTags) == 0x0002A8, "Member 'UOrionCharacterData::LootAssetTags' has a wrong offset!");
static_assert(offsetof(UOrionCharacterData, PawnClassWeakRef) == 0x0002C8, "Member 'UOrionCharacterData::PawnClassWeakRef' has a wrong offset!");
static_assert(offsetof(UOrionCharacterData, AbilitiesWeakRef) == 0x0002F0, "Member 'UOrionCharacterData::AbilitiesWeakRef' has a wrong offset!");
static_assert(offsetof(UOrionCharacterData, CharacterData) == 0x000300, "Member 'UOrionCharacterData::CharacterData' has a wrong offset!");
static_assert(offsetof(UOrionCharacterData, VisionData) == 0x000308, "Member 'UOrionCharacterData::VisionData' has a wrong offset!");
static_assert(offsetof(UOrionCharacterData, LoadedPawnClass) == 0x000310, "Member 'UOrionCharacterData::LoadedPawnClass' has a wrong offset!");
static_assert(offsetof(UOrionCharacterData, LoadedAbilities) == 0x000318, "Member 'UOrionCharacterData::LoadedAbilities' has a wrong offset!");

// Class OrionGame.OrionAIData
// 0x0058 (0x0380 - 0x0328)
class UOrionAIData final : public UOrionCharacterData
{
public:
	bool                                          PreloadWithMap;                                    // 0x0328(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_329[0x3];                                      // 0x0329(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AttackDelayOnTargetChange;                         // 0x032C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBehaviorTree>           BehaviorTreeWeakPtr;                               // 0x0330(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   KillCampText;                                      // 0x0358(0x0018)(Protected, NativeAccessSpecifierProtected)
	class UBehaviorTree*                          BehaviorTree;                                      // 0x0370(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_378[0x8];                                      // 0x0378(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAIData">();
	}
	static class UOrionAIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAIData>();
	}
};
static_assert(alignof(UOrionAIData) == 0x000008, "Wrong alignment on UOrionAIData");
static_assert(sizeof(UOrionAIData) == 0x000380, "Wrong size on UOrionAIData");
static_assert(offsetof(UOrionAIData, PreloadWithMap) == 0x000328, "Member 'UOrionAIData::PreloadWithMap' has a wrong offset!");
static_assert(offsetof(UOrionAIData, AttackDelayOnTargetChange) == 0x00032C, "Member 'UOrionAIData::AttackDelayOnTargetChange' has a wrong offset!");
static_assert(offsetof(UOrionAIData, BehaviorTreeWeakPtr) == 0x000330, "Member 'UOrionAIData::BehaviorTreeWeakPtr' has a wrong offset!");
static_assert(offsetof(UOrionAIData, KillCampText) == 0x000358, "Member 'UOrionAIData::KillCampText' has a wrong offset!");
static_assert(offsetof(UOrionAIData, BehaviorTree) == 0x000370, "Member 'UOrionAIData::BehaviorTree' has a wrong offset!");

// Class OrionGame.OrionCameraComponent
// 0x0060 (0x0880 - 0x0820)
class UOrionCameraComponent final : public UCameraComponent
{
public:
	TArray<class UOrionCameraMode*>               CameraModeInstances;                               // 0x0820(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UOrionCameraMode*>               CameraModeStack;                                   // 0x0830(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UOrionCameraMode>           AbilityCameraModeClass;                            // 0x0840(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_848[0x8];                                      // 0x0848(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCameraModeView                        BlendedCameraModeView;                             // 0x0850(0x0028)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_878[0x8];                                      // 0x0878(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCameraComponent">();
	}
	static class UOrionCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionCameraComponent>();
	}
};
static_assert(alignof(UOrionCameraComponent) == 0x000010, "Wrong alignment on UOrionCameraComponent");
static_assert(sizeof(UOrionCameraComponent) == 0x000880, "Wrong size on UOrionCameraComponent");
static_assert(offsetof(UOrionCameraComponent, CameraModeInstances) == 0x000820, "Member 'UOrionCameraComponent::CameraModeInstances' has a wrong offset!");
static_assert(offsetof(UOrionCameraComponent, CameraModeStack) == 0x000830, "Member 'UOrionCameraComponent::CameraModeStack' has a wrong offset!");
static_assert(offsetof(UOrionCameraComponent, AbilityCameraModeClass) == 0x000840, "Member 'UOrionCameraComponent::AbilityCameraModeClass' has a wrong offset!");
static_assert(offsetof(UOrionCameraComponent, BlendedCameraModeView) == 0x000850, "Member 'UOrionCameraComponent::BlendedCameraModeView' has a wrong offset!");

// Class OrionGame.OrionAIDataProvider_CurrentAbility
// 0x0048 (0x0088 - 0x0040)
class UOrionAIDataProvider_CurrentAbility final : public UAIDataProvider_QueryParams
{
public:
	struct FBlackboardKeySelector                 AbilityBBKey;                                      // 0x0040(0x0028)(Protected, NativeAccessSpecifierProtected)
	float                                         MaxRange;                                          // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RecommendedRange;                                  // 0x006C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PrimaryAbilityRecommendedRange;                    // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PrimaryAbilityMaxRange;                            // 0x0074(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EnemySelectionRange;                               // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveTetherDistance;                                // 0x007C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SafeDistance;                                      // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Aggression;                                        // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAIDataProvider_CurrentAbility">();
	}
	static class UOrionAIDataProvider_CurrentAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAIDataProvider_CurrentAbility>();
	}
};
static_assert(alignof(UOrionAIDataProvider_CurrentAbility) == 0x000008, "Wrong alignment on UOrionAIDataProvider_CurrentAbility");
static_assert(sizeof(UOrionAIDataProvider_CurrentAbility) == 0x000088, "Wrong size on UOrionAIDataProvider_CurrentAbility");
static_assert(offsetof(UOrionAIDataProvider_CurrentAbility, AbilityBBKey) == 0x000040, "Member 'UOrionAIDataProvider_CurrentAbility::AbilityBBKey' has a wrong offset!");
static_assert(offsetof(UOrionAIDataProvider_CurrentAbility, MaxRange) == 0x000068, "Member 'UOrionAIDataProvider_CurrentAbility::MaxRange' has a wrong offset!");
static_assert(offsetof(UOrionAIDataProvider_CurrentAbility, RecommendedRange) == 0x00006C, "Member 'UOrionAIDataProvider_CurrentAbility::RecommendedRange' has a wrong offset!");
static_assert(offsetof(UOrionAIDataProvider_CurrentAbility, PrimaryAbilityRecommendedRange) == 0x000070, "Member 'UOrionAIDataProvider_CurrentAbility::PrimaryAbilityRecommendedRange' has a wrong offset!");
static_assert(offsetof(UOrionAIDataProvider_CurrentAbility, PrimaryAbilityMaxRange) == 0x000074, "Member 'UOrionAIDataProvider_CurrentAbility::PrimaryAbilityMaxRange' has a wrong offset!");
static_assert(offsetof(UOrionAIDataProvider_CurrentAbility, EnemySelectionRange) == 0x000078, "Member 'UOrionAIDataProvider_CurrentAbility::EnemySelectionRange' has a wrong offset!");
static_assert(offsetof(UOrionAIDataProvider_CurrentAbility, MoveTetherDistance) == 0x00007C, "Member 'UOrionAIDataProvider_CurrentAbility::MoveTetherDistance' has a wrong offset!");
static_assert(offsetof(UOrionAIDataProvider_CurrentAbility, SafeDistance) == 0x000080, "Member 'UOrionAIDataProvider_CurrentAbility::SafeDistance' has a wrong offset!");
static_assert(offsetof(UOrionAIDataProvider_CurrentAbility, Aggression) == 0x000084, "Member 'UOrionAIDataProvider_CurrentAbility::Aggression' has a wrong offset!");

// Class OrionGame.OrionAIDataProvider_LaneGoal
// 0x0008 (0x0048 - 0x0040)
class UOrionAIDataProvider_LaneGoal final : public UAIDataProvider_QueryParams
{
public:
	float                                         AttackRange;                                       // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Health;                                            // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAIDataProvider_LaneGoal">();
	}
	static class UOrionAIDataProvider_LaneGoal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAIDataProvider_LaneGoal>();
	}
};
static_assert(alignof(UOrionAIDataProvider_LaneGoal) == 0x000008, "Wrong alignment on UOrionAIDataProvider_LaneGoal");
static_assert(sizeof(UOrionAIDataProvider_LaneGoal) == 0x000048, "Wrong size on UOrionAIDataProvider_LaneGoal");
static_assert(offsetof(UOrionAIDataProvider_LaneGoal, AttackRange) == 0x000040, "Member 'UOrionAIDataProvider_LaneGoal::AttackRange' has a wrong offset!");
static_assert(offsetof(UOrionAIDataProvider_LaneGoal, Health) == 0x000044, "Member 'UOrionAIDataProvider_LaneGoal::Health' has a wrong offset!");

// Class OrionGame.OrionBTTask_ReassignLane
// 0x0000 (0x0070 - 0x0070)
class UOrionBTTask_ReassignLane final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionBTTask_ReassignLane">();
	}
	static class UOrionBTTask_ReassignLane* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionBTTask_ReassignLane>();
	}
};
static_assert(alignof(UOrionBTTask_ReassignLane) == 0x000008, "Wrong alignment on UOrionBTTask_ReassignLane");
static_assert(sizeof(UOrionBTTask_ReassignLane) == 0x000070, "Wrong size on UOrionBTTask_ReassignLane");

// Class OrionGame.OrionHeroKwangAnimInstance
// 0x0050 (0x1210 - 0x11C0)
class UOrionHeroKwangAnimInstance final : public UOrionHeroAnimInstance
{
public:
	class FName                                   EnableLeftHandIKCurveName;                         // 0x11B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DisableLeftHandIKCurveName;                        // 0x11C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SwordVisibilityOverrideCurveName;                  // 0x11C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SwordHideAlphaCurveName;                           // 0x11D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DisableSwordSnappingToBackCurveName;               // 0x11D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DisableFacialAnimOverrideCurveName;                // 0x11E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftHandIKAlpha;                                   // 0x11E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HideSwordAlpha;                                    // 0x11EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SnapSwordToBackAlpha;                              // 0x11F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FacialAnimAlpha;                                   // 0x11F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TravelModeAlpha;                                   // 0x11F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecallingWhileSwordInWorld;                       // 0x11FC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11FD[0x3];                                     // 0x11FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         QTargetingJogAlpha;                                // 0x1200(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QTargetingSwordDirection;                          // 0x1204(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1208[0x8];                                     // 0x1208(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHeroKwangAnimInstance">();
	}
	static class UOrionHeroKwangAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHeroKwangAnimInstance>();
	}
};
static_assert(alignof(UOrionHeroKwangAnimInstance) == 0x000010, "Wrong alignment on UOrionHeroKwangAnimInstance");
static_assert(sizeof(UOrionHeroKwangAnimInstance) == 0x001210, "Wrong size on UOrionHeroKwangAnimInstance");
static_assert(offsetof(UOrionHeroKwangAnimInstance, EnableLeftHandIKCurveName) == 0x0011B8, "Member 'UOrionHeroKwangAnimInstance::EnableLeftHandIKCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroKwangAnimInstance, DisableLeftHandIKCurveName) == 0x0011C0, "Member 'UOrionHeroKwangAnimInstance::DisableLeftHandIKCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroKwangAnimInstance, SwordVisibilityOverrideCurveName) == 0x0011C8, "Member 'UOrionHeroKwangAnimInstance::SwordVisibilityOverrideCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroKwangAnimInstance, SwordHideAlphaCurveName) == 0x0011D0, "Member 'UOrionHeroKwangAnimInstance::SwordHideAlphaCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroKwangAnimInstance, DisableSwordSnappingToBackCurveName) == 0x0011D8, "Member 'UOrionHeroKwangAnimInstance::DisableSwordSnappingToBackCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroKwangAnimInstance, DisableFacialAnimOverrideCurveName) == 0x0011E0, "Member 'UOrionHeroKwangAnimInstance::DisableFacialAnimOverrideCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroKwangAnimInstance, LeftHandIKAlpha) == 0x0011E8, "Member 'UOrionHeroKwangAnimInstance::LeftHandIKAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroKwangAnimInstance, HideSwordAlpha) == 0x0011EC, "Member 'UOrionHeroKwangAnimInstance::HideSwordAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroKwangAnimInstance, SnapSwordToBackAlpha) == 0x0011F0, "Member 'UOrionHeroKwangAnimInstance::SnapSwordToBackAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroKwangAnimInstance, FacialAnimAlpha) == 0x0011F4, "Member 'UOrionHeroKwangAnimInstance::FacialAnimAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroKwangAnimInstance, TravelModeAlpha) == 0x0011F8, "Member 'UOrionHeroKwangAnimInstance::TravelModeAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroKwangAnimInstance, bRecallingWhileSwordInWorld) == 0x0011FC, "Member 'UOrionHeroKwangAnimInstance::bRecallingWhileSwordInWorld' has a wrong offset!");
static_assert(offsetof(UOrionHeroKwangAnimInstance, QTargetingJogAlpha) == 0x001200, "Member 'UOrionHeroKwangAnimInstance::QTargetingJogAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroKwangAnimInstance, QTargetingSwordDirection) == 0x001204, "Member 'UOrionHeroKwangAnimInstance::QTargetingSwordDirection' has a wrong offset!");

// Class OrionGame.OrionAIFormation
// 0x0020 (0x0048 - 0x0028)
class UOrionAIFormation final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EOrionTeam                                    TeamNum;                                           // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x17];                                      // 0x0031(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleFormationMemberDeath(class AOrionChar* DeadChar, class AController* Killer, class AActor* DamageCauser);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAIFormation">();
	}
	static class UOrionAIFormation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAIFormation>();
	}
};
static_assert(alignof(UOrionAIFormation) == 0x000008, "Wrong alignment on UOrionAIFormation");
static_assert(sizeof(UOrionAIFormation) == 0x000048, "Wrong size on UOrionAIFormation");
static_assert(offsetof(UOrionAIFormation, TeamNum) == 0x000030, "Member 'UOrionAIFormation::TeamNum' has a wrong offset!");

// Class OrionGame.OrionToggleableNavLinkProxy
// 0x0020 (0x0388 - 0x0368)
class AOrionToggleableNavLinkProxy final : public ANavLinkProxy
{
public:
	TSubclassOf<class UNavArea>                   DisabledAreaClass;                                 // 0x0368(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FCachedToggleableNavLinkData>   ToggleableLinkData;                                // 0x0370(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_380[0x8];                                      // 0x0380(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ServerSetEnabled(bool bNewEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionToggleableNavLinkProxy">();
	}
	static class AOrionToggleableNavLinkProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionToggleableNavLinkProxy>();
	}
};
static_assert(alignof(AOrionToggleableNavLinkProxy) == 0x000008, "Wrong alignment on AOrionToggleableNavLinkProxy");
static_assert(sizeof(AOrionToggleableNavLinkProxy) == 0x000388, "Wrong size on AOrionToggleableNavLinkProxy");
static_assert(offsetof(AOrionToggleableNavLinkProxy, DisabledAreaClass) == 0x000368, "Member 'AOrionToggleableNavLinkProxy::DisabledAreaClass' has a wrong offset!");
static_assert(offsetof(AOrionToggleableNavLinkProxy, ToggleableLinkData) == 0x000370, "Member 'AOrionToggleableNavLinkProxy::ToggleableLinkData' has a wrong offset!");

// Class OrionGame.OrionAIFormationData
// 0x00E0 (0x0110 - 0x0030)
class UOrionAIFormationData final : public UDataAsset
{
public:
	EAICampType                                   CampType;                                          // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UOrionAIData*>                   Formation;                                         // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UOrionAIData*>                   Formation_V2;                                      // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   DefaultInitalSpawnDelay;                           // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   DefaultSpawnDelay;                                 // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 SpawnTimeOffsets;                                  // 0x0078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 PreferredSpawnPointIndex;                          // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         SpawnReminderLeadTime;                             // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowInMapMessageFeed;                             // 0x009C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           MiniMapDisplayTag;                                 // 0x00A0(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideDisplayInfo;                              // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x00B0(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UObject>                 DisplayAsset;                                      // 0x00C8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                   KillCampText;                                      // 0x00F0(0x0018)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAIFormationData">();
	}
	static class UOrionAIFormationData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAIFormationData>();
	}
};
static_assert(alignof(UOrionAIFormationData) == 0x000008, "Wrong alignment on UOrionAIFormationData");
static_assert(sizeof(UOrionAIFormationData) == 0x000110, "Wrong size on UOrionAIFormationData");
static_assert(offsetof(UOrionAIFormationData, CampType) == 0x000030, "Member 'UOrionAIFormationData::CampType' has a wrong offset!");
static_assert(offsetof(UOrionAIFormationData, Formation) == 0x000038, "Member 'UOrionAIFormationData::Formation' has a wrong offset!");
static_assert(offsetof(UOrionAIFormationData, Formation_V2) == 0x000048, "Member 'UOrionAIFormationData::Formation_V2' has a wrong offset!");
static_assert(offsetof(UOrionAIFormationData, DefaultInitalSpawnDelay) == 0x000058, "Member 'UOrionAIFormationData::DefaultInitalSpawnDelay' has a wrong offset!");
static_assert(offsetof(UOrionAIFormationData, DefaultSpawnDelay) == 0x000068, "Member 'UOrionAIFormationData::DefaultSpawnDelay' has a wrong offset!");
static_assert(offsetof(UOrionAIFormationData, SpawnTimeOffsets) == 0x000078, "Member 'UOrionAIFormationData::SpawnTimeOffsets' has a wrong offset!");
static_assert(offsetof(UOrionAIFormationData, PreferredSpawnPointIndex) == 0x000088, "Member 'UOrionAIFormationData::PreferredSpawnPointIndex' has a wrong offset!");
static_assert(offsetof(UOrionAIFormationData, SpawnReminderLeadTime) == 0x000098, "Member 'UOrionAIFormationData::SpawnReminderLeadTime' has a wrong offset!");
static_assert(offsetof(UOrionAIFormationData, bShowInMapMessageFeed) == 0x00009C, "Member 'UOrionAIFormationData::bShowInMapMessageFeed' has a wrong offset!");
static_assert(offsetof(UOrionAIFormationData, MiniMapDisplayTag) == 0x0000A0, "Member 'UOrionAIFormationData::MiniMapDisplayTag' has a wrong offset!");
static_assert(offsetof(UOrionAIFormationData, bOverrideDisplayInfo) == 0x0000A8, "Member 'UOrionAIFormationData::bOverrideDisplayInfo' has a wrong offset!");
static_assert(offsetof(UOrionAIFormationData, DisplayName) == 0x0000B0, "Member 'UOrionAIFormationData::DisplayName' has a wrong offset!");
static_assert(offsetof(UOrionAIFormationData, DisplayAsset) == 0x0000C8, "Member 'UOrionAIFormationData::DisplayAsset' has a wrong offset!");
static_assert(offsetof(UOrionAIFormationData, KillCampText) == 0x0000F0, "Member 'UOrionAIFormationData::KillCampText' has a wrong offset!");

// Class OrionGame.OrionAIGenerigWorldQuerying
// 0x0000 (0x0028 - 0x0028)
class UOrionAIGenerigWorldQuerying final : public UBlueprintFunctionLibrary
{
public:
	static struct FOrionGenericAITest CompareToFloat(EOrionAISymbolicItem LHS, EGenericAICheck Op, float RHS);
	static struct FOrionGenericAITest CompareToNumber(EOrionAISymbolicItem LHS, EGenericAICheck Op, int32 RHS);
	static struct FOrionGenericAITest CompareToSymbol(EOrionAISymbolicItem LHS, EGenericAICheck Op, EOrionAISymbolicItem RHS);
	static bool Evaluate(class UObject* WorldContextObject, const struct FOrionGenericAITest& Condition);
	static struct FOrionGenericAITest FactCheck(EOrionAISymbolicItem LHS, bool bIsTrue);
	static struct FOrionGenericAITest IsDead(EOrionAISymbolicItem LHS, bool bIsTrue);
	static struct FOrionGenericAITest IsTowerDead(EAITowerClassification Tower, EAIOwnership Ownership, EAIGenericLocation Location, bool bIsTrue);
	static struct FOrionGenericAITest LongestDistanceTo(EOrionAISymbolicItem From, EOrionAISymbolicItem To, EGenericAICheck Op, float Distance);
	static struct FOrionGenericAITest ShortestDistanceTo(EOrionAISymbolicItem From, EOrionAISymbolicItem To, EGenericAICheck Op, float Distance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAIGenerigWorldQuerying">();
	}
	static class UOrionAIGenerigWorldQuerying* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAIGenerigWorldQuerying>();
	}
};
static_assert(alignof(UOrionAIGenerigWorldQuerying) == 0x000008, "Wrong alignment on UOrionAIGenerigWorldQuerying");
static_assert(sizeof(UOrionAIGenerigWorldQuerying) == 0x000028, "Wrong size on UOrionAIGenerigWorldQuerying");

// Class OrionGame.OrionAIInfluenceMapManager
// 0x00F0 (0x0408 - 0x0318)
class AOrionAIInfluenceMapManager final : public AActor
{
public:
	class UInfluenceMapRenderingComponent*        RenderingComp;                                     // 0x0318(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABotObjectiveGraph*                     ObjectiveGraph;                                    // 0x0320(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_328[0xE0];                                     // 0x0328(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnNavDataGenerationFinished(class ANavigationData* NavData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAIInfluenceMapManager">();
	}
	static class AOrionAIInfluenceMapManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionAIInfluenceMapManager>();
	}
};
static_assert(alignof(AOrionAIInfluenceMapManager) == 0x000008, "Wrong alignment on AOrionAIInfluenceMapManager");
static_assert(sizeof(AOrionAIInfluenceMapManager) == 0x000408, "Wrong size on AOrionAIInfluenceMapManager");
static_assert(offsetof(AOrionAIInfluenceMapManager, RenderingComp) == 0x000318, "Member 'AOrionAIInfluenceMapManager::RenderingComp' has a wrong offset!");
static_assert(offsetof(AOrionAIInfluenceMapManager, ObjectiveGraph) == 0x000320, "Member 'AOrionAIInfluenceMapManager::ObjectiveGraph' has a wrong offset!");

// Class OrionGame.OrionTowerSet
// 0x0010 (0x0040 - 0x0030)
class UOrionTowerSet final : public UOrionAttributeSet
{
public:
	float                                         AttackSpeed;                                       // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargettingDelayTime;                               // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackRadius;                                      // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackHeight;                                      // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTowerSet">();
	}
	static class UOrionTowerSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionTowerSet>();
	}
};
static_assert(alignof(UOrionTowerSet) == 0x000008, "Wrong alignment on UOrionTowerSet");
static_assert(sizeof(UOrionTowerSet) == 0x000040, "Wrong size on UOrionTowerSet");
static_assert(offsetof(UOrionTowerSet, AttackSpeed) == 0x000030, "Member 'UOrionTowerSet::AttackSpeed' has a wrong offset!");
static_assert(offsetof(UOrionTowerSet, TargettingDelayTime) == 0x000034, "Member 'UOrionTowerSet::TargettingDelayTime' has a wrong offset!");
static_assert(offsetof(UOrionTowerSet, AttackRadius) == 0x000038, "Member 'UOrionTowerSet::AttackRadius' has a wrong offset!");
static_assert(offsetof(UOrionTowerSet, AttackHeight) == 0x00003C, "Member 'UOrionTowerSet::AttackHeight' has a wrong offset!");

// Class OrionGame.OrionAIKismetLibrary
// 0x0000 (0x0028 - 0x0028)
class UOrionAIKismetLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FGameplayAbilitySpecHandle GetBlackboardValueAsAbilitySpecHandle(class UBTNode* NodeOwner, const struct FBlackboardKeySelector& Key);
	static class AOrionCharAISpawner_Jungle* GetClosestJungleCamp(class AOrionAIBot* Bot, EAICampType Camp, int32 MinCreepsAlive);
	static float GetInfluenceValueAt(class UObject* WorldContextObject, const struct FVector& WorldLocation, EOrionTeam QuerierTeam);
	static class AOrionDamageableObjective_Base* GetOwnTower(class UObject* WorldContextObject, int32 LaneID, EOrionTeam TeamNum, int32 TowerIndex);
	static void K2_ClearTimerByHandle(const struct FTimerHandle& TimerHandle, class UObject* WorldContext);
	static void K2_FillWithBots(class UObject* WorldContextObject, int32 BotsToAddToEachTeam, const class FString& HeroListName);
	static class AOrionAILevelMarkup* K2_GetAIMarkup(class AActor* WorldContext);
	static void K2_GetTeamBots(class UObject* WorldContextObject, const EOrionTeam TeamNum, TArray<class AOrionAIBot*>* OutBots);
	static struct FTimerHandle K2_SetTimerDelegate(TDelegate<void()> Delegate, float Time, bool bLooping, class UObject* WorldContext);
	static void RemoveInfluenceSource(class UObject* WorldContextObject, TScriptInterface<class IOrionTeamActorInterface> InfluenceSource, bool bForceUpdate);
	static void UpdateInfluenceSurce(class UObject* WorldContextObject, TScriptInterface<class IOrionTeamActorInterface> InfluenceSource, EAIActorClassification SourceType, float Radius, float Strength, bool bForceUpdate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAIKismetLibrary">();
	}
	static class UOrionAIKismetLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAIKismetLibrary>();
	}
};
static_assert(alignof(UOrionAIKismetLibrary) == 0x000008, "Wrong alignment on UOrionAIKismetLibrary");
static_assert(sizeof(UOrionAIKismetLibrary) == 0x000028, "Wrong size on UOrionAIKismetLibrary");

// Class OrionGame.OrionArenaCamera
// 0x0050 (0x0368 - 0x0318)
class AOrionArenaCamera : public AActor
{
public:
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bEnabled : 1;                                      // 0x0320(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_321[0x7];                                      // 0x0321(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionSpectatorCamComp_Arena*           TemplateCameraComponent;                           // 0x0328(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        TransformComponent;                                // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrionTeam                                    TeamNum;                                           // 0x0338(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStartingSpot;                                     // 0x0339(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEndMatchSpot;                                     // 0x033A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33B[0x5];                                      // 0x033B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  CameraVisionTags;                                  // 0x0340(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_360[0x8];                                      // 0x0360(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionArenaCamera">();
	}
	static class AOrionArenaCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionArenaCamera>();
	}
};
static_assert(alignof(AOrionArenaCamera) == 0x000008, "Wrong alignment on AOrionArenaCamera");
static_assert(sizeof(AOrionArenaCamera) == 0x000368, "Wrong size on AOrionArenaCamera");
static_assert(offsetof(AOrionArenaCamera, TemplateCameraComponent) == 0x000328, "Member 'AOrionArenaCamera::TemplateCameraComponent' has a wrong offset!");
static_assert(offsetof(AOrionArenaCamera, TransformComponent) == 0x000330, "Member 'AOrionArenaCamera::TransformComponent' has a wrong offset!");
static_assert(offsetof(AOrionArenaCamera, TeamNum) == 0x000338, "Member 'AOrionArenaCamera::TeamNum' has a wrong offset!");
static_assert(offsetof(AOrionArenaCamera, bStartingSpot) == 0x000339, "Member 'AOrionArenaCamera::bStartingSpot' has a wrong offset!");
static_assert(offsetof(AOrionArenaCamera, bEndMatchSpot) == 0x00033A, "Member 'AOrionArenaCamera::bEndMatchSpot' has a wrong offset!");
static_assert(offsetof(AOrionArenaCamera, CameraVisionTags) == 0x000340, "Member 'AOrionArenaCamera::CameraVisionTags' has a wrong offset!");

// Class OrionGame.OrionArenaRailCamera
// 0x0020 (0x0388 - 0x0368)
class AOrionArenaRailCamera final : public AOrionArenaCamera
{
public:
	float                                         InitialSplinePosition;                             // 0x0368(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCameraSpeed;                                    // 0x036C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraAcceleration;                                // 0x0370(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraDeceleration;                                // 0x0374(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIgnoreTimeDilation : 1;                           // 0x0378(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_379[0x7];                                      // 0x0379(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USplineComponent*                       RailSplineComponent;                               // 0x0380(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionArenaRailCamera">();
	}
	static class AOrionArenaRailCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionArenaRailCamera>();
	}
};
static_assert(alignof(AOrionArenaRailCamera) == 0x000008, "Wrong alignment on AOrionArenaRailCamera");
static_assert(sizeof(AOrionArenaRailCamera) == 0x000388, "Wrong size on AOrionArenaRailCamera");
static_assert(offsetof(AOrionArenaRailCamera, InitialSplinePosition) == 0x000368, "Member 'AOrionArenaRailCamera::InitialSplinePosition' has a wrong offset!");
static_assert(offsetof(AOrionArenaRailCamera, MaxCameraSpeed) == 0x00036C, "Member 'AOrionArenaRailCamera::MaxCameraSpeed' has a wrong offset!");
static_assert(offsetof(AOrionArenaRailCamera, CameraAcceleration) == 0x000370, "Member 'AOrionArenaRailCamera::CameraAcceleration' has a wrong offset!");
static_assert(offsetof(AOrionArenaRailCamera, CameraDeceleration) == 0x000374, "Member 'AOrionArenaRailCamera::CameraDeceleration' has a wrong offset!");
static_assert(offsetof(AOrionArenaRailCamera, RailSplineComponent) == 0x000380, "Member 'AOrionArenaRailCamera::RailSplineComponent' has a wrong offset!");

// Class OrionGame.OrionAILevelMarkup
// 0x0080 (0x0398 - 0x0318)
class AOrionAILevelMarkup final : public AActor
{
public:
	class UBillboardComponent*                    SpriteComponent;                                   // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AOrionDamageableObjective_Base*         CoreActors[0x2];                                   // 0x0320(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FAILaneMarkup>                  Lanes;                                             // 0x0330(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FAIRouteMarkup>                 CustomRoutes;                                      // 0x0340(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AAIWardPlacement*>               WardPlacementLocations;                            // 0x0350(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	class UAILevelMarkupRenderingComponent*       RenderComp;                                        // 0x0360(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBotPlaybook>               DefaultPlaybooks[0x5];                             // 0x0368(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DebugDrawLane;                                     // 0x0390(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DebugDrawWardLocations : 1;                        // 0x0394(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDebugDraw : 1;                                    // 0x0394(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseForFlowfield : 1;                              // 0x0394(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_395[0x3];                                      // 0x0395(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAILevelMarkup">();
	}
	static class AOrionAILevelMarkup* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionAILevelMarkup>();
	}
};
static_assert(alignof(AOrionAILevelMarkup) == 0x000008, "Wrong alignment on AOrionAILevelMarkup");
static_assert(sizeof(AOrionAILevelMarkup) == 0x000398, "Wrong size on AOrionAILevelMarkup");
static_assert(offsetof(AOrionAILevelMarkup, SpriteComponent) == 0x000318, "Member 'AOrionAILevelMarkup::SpriteComponent' has a wrong offset!");
static_assert(offsetof(AOrionAILevelMarkup, CoreActors) == 0x000320, "Member 'AOrionAILevelMarkup::CoreActors' has a wrong offset!");
static_assert(offsetof(AOrionAILevelMarkup, Lanes) == 0x000330, "Member 'AOrionAILevelMarkup::Lanes' has a wrong offset!");
static_assert(offsetof(AOrionAILevelMarkup, CustomRoutes) == 0x000340, "Member 'AOrionAILevelMarkup::CustomRoutes' has a wrong offset!");
static_assert(offsetof(AOrionAILevelMarkup, WardPlacementLocations) == 0x000350, "Member 'AOrionAILevelMarkup::WardPlacementLocations' has a wrong offset!");
static_assert(offsetof(AOrionAILevelMarkup, RenderComp) == 0x000360, "Member 'AOrionAILevelMarkup::RenderComp' has a wrong offset!");
static_assert(offsetof(AOrionAILevelMarkup, DefaultPlaybooks) == 0x000368, "Member 'AOrionAILevelMarkup::DefaultPlaybooks' has a wrong offset!");
static_assert(offsetof(AOrionAILevelMarkup, DebugDrawLane) == 0x000390, "Member 'AOrionAILevelMarkup::DebugDrawLane' has a wrong offset!");

// Class OrionGame.AILevelMarkupRenderingComponent
// 0x0000 (0x0690 - 0x0690)
class UAILevelMarkupRenderingComponent final : public UPrimitiveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AILevelMarkupRenderingComponent">();
	}
	static class UAILevelMarkupRenderingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAILevelMarkupRenderingComponent>();
	}
};
static_assert(alignof(UAILevelMarkupRenderingComponent) == 0x000010, "Wrong alignment on UAILevelMarkupRenderingComponent");
static_assert(sizeof(UAILevelMarkupRenderingComponent) == 0x000690, "Wrong size on UAILevelMarkupRenderingComponent");

// Class OrionGame.OrionArcadeEffectData
// 0x0010 (0x0040 - 0x0030)
class UOrionArcadeEffectData final : public UDataAsset
{
public:
	TArray<struct FArcadeEffectData>              GameplayEffects;                                   // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionArcadeEffectData">();
	}
	static class UOrionArcadeEffectData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionArcadeEffectData>();
	}
};
static_assert(alignof(UOrionArcadeEffectData) == 0x000008, "Wrong alignment on UOrionArcadeEffectData");
static_assert(sizeof(UOrionArcadeEffectData) == 0x000040, "Wrong size on UOrionArcadeEffectData");
static_assert(offsetof(UOrionArcadeEffectData, GameplayEffects) == 0x000030, "Member 'UOrionArcadeEffectData::GameplayEffects' has a wrong offset!");

// Class OrionGame.OrionAIMinionAggroManager
// 0x0278 (0x02A0 - 0x0028)
class UOrionAIMinionAggroManager final : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrionAIInfluenceMapManager*            InfluenceMap;                                      // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FMinionSightData>               LineOfSightQueue;                                  // 0x0060(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMinionAuxAggroSet                     DamageableActorList[0x2];                          // 0x0078(0x0010)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_98[0x208];                                     // 0x0098(0x0208)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAIMinionAggroManager">();
	}
	static class UOrionAIMinionAggroManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAIMinionAggroManager>();
	}
};
static_assert(alignof(UOrionAIMinionAggroManager) == 0x000008, "Wrong alignment on UOrionAIMinionAggroManager");
static_assert(sizeof(UOrionAIMinionAggroManager) == 0x0002A0, "Wrong size on UOrionAIMinionAggroManager");
static_assert(offsetof(UOrionAIMinionAggroManager, InfluenceMap) == 0x000058, "Member 'UOrionAIMinionAggroManager::InfluenceMap' has a wrong offset!");
static_assert(offsetof(UOrionAIMinionAggroManager, LineOfSightQueue) == 0x000060, "Member 'UOrionAIMinionAggroManager::LineOfSightQueue' has a wrong offset!");
static_assert(offsetof(UOrionAIMinionAggroManager, DamageableActorList) == 0x000078, "Member 'UOrionAIMinionAggroManager::DamageableActorList' has a wrong offset!");

// Class OrionGame.OrionTutorialPath
// 0x0090 (0x0478 - 0x03E8)
class AOrionTutorialPath : public AOrionBaseActor
{
public:
	TArray<struct FTutorialDecalInfo>             DecalInfos;                                        // 0x03E8(0x0010)(BlueprintVisible, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FLerpingPath                           LerpingPath;                                       // 0x03F8(0x0040)(Protected, NativeAccessSpecifierProtected)
	class UMaterial*                              LineMaterial;                                      // 0x0438(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterial*                              NodeMaterial;                                      // 0x0440(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        PoofEffect;                                        // 0x0448(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Depth;                                             // 0x0450(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Width;                                             // 0x0454(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LerpTime;                                          // 0x0458(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxNumberOfNodeDecalsDrawn;                        // 0x045C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPathLerpType                                 LerpType;                                          // 0x0460(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_461[0x3];                                      // 0x0461(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CollapseDistance;                                  // 0x0464(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SegmentDistance;                                   // 0x0468(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeBetweenRequests;                               // 0x046C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RefreshDistance;                                   // 0x0470(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_474[0x4];                                      // 0x0474(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayPoof(const struct FVector& Location);
	void UpdateLineDecalComponent(class UDecalComponent* Decal, class UMaterialInstanceDynamic* Mid, const struct FVector& SourceVec, const struct FVector& TargetVec);
	void UpdateNodeDecalComponent(class UDecalComponent* Decal, class UMaterialInstanceDynamic* Mid, const struct FVector& Location, const int32 Index_0);
	void UpdateVisuals();

	int32 GetNumOfPoints() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTutorialPath">();
	}
	static class AOrionTutorialPath* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionTutorialPath>();
	}
};
static_assert(alignof(AOrionTutorialPath) == 0x000008, "Wrong alignment on AOrionTutorialPath");
static_assert(sizeof(AOrionTutorialPath) == 0x000478, "Wrong size on AOrionTutorialPath");
static_assert(offsetof(AOrionTutorialPath, DecalInfos) == 0x0003E8, "Member 'AOrionTutorialPath::DecalInfos' has a wrong offset!");
static_assert(offsetof(AOrionTutorialPath, LerpingPath) == 0x0003F8, "Member 'AOrionTutorialPath::LerpingPath' has a wrong offset!");
static_assert(offsetof(AOrionTutorialPath, LineMaterial) == 0x000438, "Member 'AOrionTutorialPath::LineMaterial' has a wrong offset!");
static_assert(offsetof(AOrionTutorialPath, NodeMaterial) == 0x000440, "Member 'AOrionTutorialPath::NodeMaterial' has a wrong offset!");
static_assert(offsetof(AOrionTutorialPath, PoofEffect) == 0x000448, "Member 'AOrionTutorialPath::PoofEffect' has a wrong offset!");
static_assert(offsetof(AOrionTutorialPath, Depth) == 0x000450, "Member 'AOrionTutorialPath::Depth' has a wrong offset!");
static_assert(offsetof(AOrionTutorialPath, Width) == 0x000454, "Member 'AOrionTutorialPath::Width' has a wrong offset!");
static_assert(offsetof(AOrionTutorialPath, LerpTime) == 0x000458, "Member 'AOrionTutorialPath::LerpTime' has a wrong offset!");
static_assert(offsetof(AOrionTutorialPath, MaxNumberOfNodeDecalsDrawn) == 0x00045C, "Member 'AOrionTutorialPath::MaxNumberOfNodeDecalsDrawn' has a wrong offset!");
static_assert(offsetof(AOrionTutorialPath, LerpType) == 0x000460, "Member 'AOrionTutorialPath::LerpType' has a wrong offset!");
static_assert(offsetof(AOrionTutorialPath, CollapseDistance) == 0x000464, "Member 'AOrionTutorialPath::CollapseDistance' has a wrong offset!");
static_assert(offsetof(AOrionTutorialPath, SegmentDistance) == 0x000468, "Member 'AOrionTutorialPath::SegmentDistance' has a wrong offset!");
static_assert(offsetof(AOrionTutorialPath, TimeBetweenRequests) == 0x00046C, "Member 'AOrionTutorialPath::TimeBetweenRequests' has a wrong offset!");
static_assert(offsetof(AOrionTutorialPath, RefreshDistance) == 0x000470, "Member 'AOrionTutorialPath::RefreshDistance' has a wrong offset!");

// Class OrionGame.OrionAIMinionProjectileManager
// 0x00C8 (0x03E0 - 0x0318)
class AOrionAIMinionProjectileManager final : public AActor
{
public:
	TArray<struct FMinionProjectileData>          ActiveProjectiles;                                 // 0x0318(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UParticleSystemComponent*>       InactivePSC;                                       // 0x0328(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class UNiagaraSystem*, struct FOrionProjectileNiagaraComponentArray> InactiveNC;                                        // 0x0338(0x0050)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_388[0x58];                                     // 0x0388(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAIMinionProjectileManager">();
	}
	static class AOrionAIMinionProjectileManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionAIMinionProjectileManager>();
	}
};
static_assert(alignof(AOrionAIMinionProjectileManager) == 0x000008, "Wrong alignment on AOrionAIMinionProjectileManager");
static_assert(sizeof(AOrionAIMinionProjectileManager) == 0x0003E0, "Wrong size on AOrionAIMinionProjectileManager");
static_assert(offsetof(AOrionAIMinionProjectileManager, ActiveProjectiles) == 0x000318, "Member 'AOrionAIMinionProjectileManager::ActiveProjectiles' has a wrong offset!");
static_assert(offsetof(AOrionAIMinionProjectileManager, InactivePSC) == 0x000328, "Member 'AOrionAIMinionProjectileManager::InactivePSC' has a wrong offset!");
static_assert(offsetof(AOrionAIMinionProjectileManager, InactiveNC) == 0x000338, "Member 'AOrionAIMinionProjectileManager::InactiveNC' has a wrong offset!");

// Class OrionGame.OrionCarriedObjective
// 0x00C8 (0x06A8 - 0x05E0)
class AOrionCarriedObjective : public AOrionPickup
{
public:
	uint8                                         Pad_5E0[0x8];                                      // 0x05E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ObjectiveAnalyticName;                             // 0x05E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionPlayerState_Game*                 CurrentHolder;                                     // 0x05F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AOrionChar*                             CurrentHoldingPawn;                                // 0x05F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AttachSocketName;                                  // 0x0600(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttachLocation                               AttachType;                                        // 0x0608(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttachmentRule                               AttachLocationRule;                                // 0x0609(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttachmentRule                               AttachRotationRule;                                // 0x060A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttachmentRule                               AttachScaleRule;                                   // 0x060B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                OldScale;                                          // 0x060C(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FScalableFloat                         ObjectiveLifespanTimer;                            // 0x0618(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         TimeFromDropToReturn;                              // 0x0640(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         TeleportationDelayTimer;                           // 0x0668(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_66C[0x4];                                      // 0x066C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 SpawnBaseActor;                                    // 0x0670(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SpawnOffset;                                       // 0x0678(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRemoveWhenReturnToBase;                           // 0x0684(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_685[0x3];                                      // 0x0685(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DropLocation;                                      // 0x0688(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTryToReturnToBaseOnDrop;                          // 0x0694(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOnDropUseInitalTimeOnReset;                       // 0x0695(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_696[0x12];                                     // 0x0696(0x0012)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DropObjective();
	void HandleCurrentHoldersDeath(class AOrionChar* DeadChar);
	void HandleCurrentHoldersDestroyed(class AActor* DestroyedActor);
	void HandleHomingDeath(class AOrionChar* DeadChar);
	void HandleHomingEnterPhaseShift(class AOrionChar* PhaseShifedChar);
	bool IsHeld();
	void OnObjectiveDropped();
	void OnScoredObjective();
	void SetCurrentHolder(class AOrionPlayerState_Game* InHolder);
	void TryToReturnToBase();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCarriedObjective">();
	}
	static class AOrionCarriedObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionCarriedObjective>();
	}
};
static_assert(alignof(AOrionCarriedObjective) == 0x000008, "Wrong alignment on AOrionCarriedObjective");
static_assert(sizeof(AOrionCarriedObjective) == 0x0006A8, "Wrong size on AOrionCarriedObjective");
static_assert(offsetof(AOrionCarriedObjective, ObjectiveAnalyticName) == 0x0005E8, "Member 'AOrionCarriedObjective::ObjectiveAnalyticName' has a wrong offset!");
static_assert(offsetof(AOrionCarriedObjective, CurrentHolder) == 0x0005F0, "Member 'AOrionCarriedObjective::CurrentHolder' has a wrong offset!");
static_assert(offsetof(AOrionCarriedObjective, CurrentHoldingPawn) == 0x0005F8, "Member 'AOrionCarriedObjective::CurrentHoldingPawn' has a wrong offset!");
static_assert(offsetof(AOrionCarriedObjective, AttachSocketName) == 0x000600, "Member 'AOrionCarriedObjective::AttachSocketName' has a wrong offset!");
static_assert(offsetof(AOrionCarriedObjective, AttachType) == 0x000608, "Member 'AOrionCarriedObjective::AttachType' has a wrong offset!");
static_assert(offsetof(AOrionCarriedObjective, AttachLocationRule) == 0x000609, "Member 'AOrionCarriedObjective::AttachLocationRule' has a wrong offset!");
static_assert(offsetof(AOrionCarriedObjective, AttachRotationRule) == 0x00060A, "Member 'AOrionCarriedObjective::AttachRotationRule' has a wrong offset!");
static_assert(offsetof(AOrionCarriedObjective, AttachScaleRule) == 0x00060B, "Member 'AOrionCarriedObjective::AttachScaleRule' has a wrong offset!");
static_assert(offsetof(AOrionCarriedObjective, OldScale) == 0x00060C, "Member 'AOrionCarriedObjective::OldScale' has a wrong offset!");
static_assert(offsetof(AOrionCarriedObjective, ObjectiveLifespanTimer) == 0x000618, "Member 'AOrionCarriedObjective::ObjectiveLifespanTimer' has a wrong offset!");
static_assert(offsetof(AOrionCarriedObjective, TimeFromDropToReturn) == 0x000640, "Member 'AOrionCarriedObjective::TimeFromDropToReturn' has a wrong offset!");
static_assert(offsetof(AOrionCarriedObjective, TeleportationDelayTimer) == 0x000668, "Member 'AOrionCarriedObjective::TeleportationDelayTimer' has a wrong offset!");
static_assert(offsetof(AOrionCarriedObjective, SpawnBaseActor) == 0x000670, "Member 'AOrionCarriedObjective::SpawnBaseActor' has a wrong offset!");
static_assert(offsetof(AOrionCarriedObjective, SpawnOffset) == 0x000678, "Member 'AOrionCarriedObjective::SpawnOffset' has a wrong offset!");
static_assert(offsetof(AOrionCarriedObjective, bRemoveWhenReturnToBase) == 0x000684, "Member 'AOrionCarriedObjective::bRemoveWhenReturnToBase' has a wrong offset!");
static_assert(offsetof(AOrionCarriedObjective, DropLocation) == 0x000688, "Member 'AOrionCarriedObjective::DropLocation' has a wrong offset!");
static_assert(offsetof(AOrionCarriedObjective, bTryToReturnToBaseOnDrop) == 0x000694, "Member 'AOrionCarriedObjective::bTryToReturnToBaseOnDrop' has a wrong offset!");
static_assert(offsetof(AOrionCarriedObjective, bOnDropUseInitalTimeOnReset) == 0x000695, "Member 'AOrionCarriedObjective::bOnDropUseInitalTimeOnReset' has a wrong offset!");

// Class OrionGame.OrionAimTargetInterface
// 0x0000 (0x0028 - 0x0028)
class IOrionAimTargetInterface final : public IInterface
{
public:
	void AddedToHiddennActorArray();
	void ApplyShadowPlaneMaterials();
	void GetAimTargetExtent(struct FVector* Center, float* Width, float* Height);
	void GetAimTargetSensingLocation(struct FVector* AimPosition);
	EOrionTargetType GetMyTargetType();
	struct FVector GetNumberPopLocation(const struct FVector& HitLocation);
	void GetTargetingLocation(struct FVector* OutPosition);
	bool IsValidDirectHit(const struct FHitResult& HitResult);
	void RemovedFromHiddenActorArray();
	void RemoveShadowPlaneMaterials();
	bool ShouldIgnoreCollisionWithTeam(EOrionTeam Team, bool bPassedFilter);
	void UpdateOccludedVision(bool bShouldShowWhenOccluded);

	bool CanBeHitWhileInShadowPlane() const;
	EOrionVisionType CanSee(const class AActor* TargetActor) const;
	bool IsTargetable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAimTargetInterface">();
	}
	static class IOrionAimTargetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOrionAimTargetInterface>();
	}
};
static_assert(alignof(IOrionAimTargetInterface) == 0x000008, "Wrong alignment on IOrionAimTargetInterface");
static_assert(sizeof(IOrionAimTargetInterface) == 0x000028, "Wrong size on IOrionAimTargetInterface");

// Class OrionGame.OrionCharAISpawner
// 0x02F8 (0x06E0 - 0x03E8)
class AOrionCharAISpawner : public AOrionBaseActor
{
public:
	int32                                         MaxAISpawned;                                      // 0x03E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionCharAISpawnerCategory                   SpawnerCategory;                                   // 0x03EC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3ED[0x3];                                      // 0x03ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AOrionAIWaypoint*>               WayPoints;                                         // 0x03F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFormationFinishedSpawning;                       // 0x0400(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFormationKilled;                                 // 0x0410(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_420[0x10];                                     // 0x0420(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDisableSpawner;                                   // 0x0430(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_431[0x3];                                      // 0x0431(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bOverrideFormationTimings : 1;                     // 0x0434(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_435[0x3];                                      // 0x0435(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SecondsForPendingSpawnNotify;                      // 0x0438(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bRelevantToStrategicAI : 1;                        // 0x043C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_43D[0x3];                                      // 0x043D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EOrionCharAISpawnerType                       SpawnerType;                                       // 0x0440(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_441[0x7];                                      // 0x0441(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AActor>>          SpawnPoints;                                       // 0x0448(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_458[0x8];                                      // 0x0458(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnRadius;                                       // 0x0460(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_464[0x4];                                      // 0x0464(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAIFormationData*                  FormationData;                                     // 0x0468(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStartGameWithVision;                              // 0x0470(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bGrantVisionOnRespawn;                             // 0x0471(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAlwaysGrantVision;                                // 0x0472(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_473[0x5];                                      // 0x0473(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  SpawnerIndicatorTagRequirements;                   // 0x0478(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  SpawnerVisionTags;                                 // 0x0498(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         InitialSpawnDelay;                                 // 0x04B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReplenishDelayTimer;                               // 0x04BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IntroSpawnTimer;                                   // 0x04C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AISpawnedInStartingLevel;                          // 0x04C4(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReplicatedSpawnTime;                               // 0x04C8(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReplicatedSpawnTimeTotal;                          // 0x04CC(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SpawnedAICount;                                    // 0x04D0(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D4[0x4];                                      // 0x04D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           CurrentBuffTypeTag;                                // 0x04D8(0x0008)(Edit, BlueprintVisible, Net, DisableEditOnInstance, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4E0[0xC];                                      // 0x04E0(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUpdateVisibilityOnLOSGain;                        // 0x04EC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4ED[0x3];                                      // 0x04ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LaneID;                                            // 0x04F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrionTeam                                    KillingTeamNum;                                    // 0x04F4(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F5[0x6B];                                     // 0x04F5(0x006B)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UOrionAIData*>                   AIToSpawnNextWave;                                 // 0x0560(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FAIWaveBeingSpawned                    CurrentFormationBeingSpawned;                      // 0x0570(0x0050)(Protected, NativeAccessSpecifierProtected)
	int32                                         CurrentSpawnedAIIndex;                             // 0x05C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C4[0x4];                                      // 0x05C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAISystem*                         AISystem;                                          // 0x05C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D0[0x110];                                    // 0x05D0(0x0110)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAIToNextWave(class UOrionAIData* InAIData);
	void ApplyAggroEffectForHero(class AActor* Hero, TSubclassOf<class UGameplayEffect> AggroEffect);
	void ChangeTeamOldVisionManagerOnly(EOrionTeam NewTeam);
	void DisableSpawner();
	void EnableSpawner();
	void FinishSpawningNextAIFormation();
	void ForceRestartSpawner(EOrionCharAISpawnerType InType);
	int32 GetSpawnerAICount();
	void HandleMatchEnded();
	void HandleMatchStarted();
	void HandleSpawnedAIDeath(class AOrionChar* DeadChar, class AController* Killer, class AActor* DamageCauser);
	void HandleSpawnedAIDestroyed(class AActor* DestroyedActor);
	bool IsSpawningAnAIFormation();
	void NotifyPendingAIFormation(const class UOrionAIFormationData* InFormationData);
	void OnAggroResetFinished();
	void OnAggroResetStarted();
	void OnAIFormationPending();
	void OnAIFormationSpawned(class UOrionAIFormation* NewFormation);
	void OnHandleMatchStart();
	void OnIntroSpawnForAI(class AOrionCharAI* SpawnedAI);
	void OnPostRemovedAI(class AOrionCharAI* RemovedAI);
	void OnPostSpawnedAI(class AOrionCharAI* SpawnedAI);
	void OnPreSpawnAI(class UOrionAIData* InAIData);
	void OnRep_CurrentBuffTypeTag(const struct FGameplayTag& OldColor);
	void OnRep_ReplicatedSpawnTime();
	void OnRep_SpawnedAICount();
	void OnReplenishWaveTimerStart(float InReplenishDelayTimer, class AController* Killer, class AActor* DamageCauser);
	void OnSpawnerBuffTypeChanged(const struct FGameplayTag& NewColorTag, const EOrionTeam TeamChanged);
	void OnStartSpawningAIFormation();
	void OnWishesToStartSpawningAIFormation();
	void RemoveAggroEffectForHero(class AActor* Hero);
	void SelectSpawnLocation(struct FVector* OutLocation, struct FRotator* OutRotation);
	void SendAggroManagerMessage(EAIMessageFromSpawner MESSAGE, class AActor* MessageInstigator);
	void SetSpawnerType(EOrionCharAISpawnerType InType);
	class AOrionCharAI* SpawnAI(class UOrionAIData* InAIData);
	void SpawnNextAIFromPool();
	void StartSpawningNextAIFormation(const class UOrionAIFormationData* InFormationData);
	void WaveSpawnManager();
	void WaveSpawnPending();

	void GetAggroManagerHeroesInRange(TArray<class AOrionChar*>* HeroesInRange) const;
	void GetAggroManagerHeroesWithAggro(TArray<class AOrionChar*>* HeroesWithAggro) const;
	void GetAggroManagerSpawnedList(TArray<class AOrionCharAI*>* SpawnedPawns) const;
	bool IsAggroManagerStateInCombat() const;
	bool IsAggroManagerStateResetting() const;
	bool IsAggroManagerStateRespawning() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCharAISpawner">();
	}
	static class AOrionCharAISpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionCharAISpawner>();
	}
};
static_assert(alignof(AOrionCharAISpawner) == 0x000008, "Wrong alignment on AOrionCharAISpawner");
static_assert(sizeof(AOrionCharAISpawner) == 0x0006E0, "Wrong size on AOrionCharAISpawner");
static_assert(offsetof(AOrionCharAISpawner, MaxAISpawned) == 0x0003E8, "Member 'AOrionCharAISpawner::MaxAISpawned' has a wrong offset!");
static_assert(offsetof(AOrionCharAISpawner, SpawnerCategory) == 0x0003EC, "Member 'AOrionCharAISpawner::SpawnerCategory' has a wrong offset!");
static_assert(offsetof(AOrionCharAISpawner, WayPoints) == 0x0003F0, "Member 'AOrionCharAISpawner::WayPoints' has a wrong offset!");
static_assert(offsetof(AOrionCharAISpawner, OnFormationFinishedSpawning) == 0x000400, "Member 'AOrionCharAISpawner::OnFormationFinishedSpawning' has a wrong offset!");
static_assert(offsetof(AOrionCharAISpawner, OnFormationKilled) == 0x000410, "Member 'AOrionCharAISpawner::OnFormationKilled' has a wrong offset!");
static_assert(offsetof(AOrionCharAISpawner, bDisableSpawner) == 0x000430, "Member 'AOrionCharAISpawner::bDisableSpawner' has a wrong offset!");
static_assert(offsetof(AOrionCharAISpawner, SecondsForPendingSpawnNotify) == 0x000438, "Member 'AOrionCharAISpawner::SecondsForPendingSpawnNotify' has a wrong offset!");
static_assert(offsetof(AOrionCharAISpawner, SpawnerType) == 0x000440, "Member 'AOrionCharAISpawner::SpawnerType' has a wrong offset!");
static_assert(offsetof(AOrionCharAISpawner, SpawnPoints) == 0x000448, "Member 'AOrionCharAISpawner::SpawnPoints' has a wrong offset!");
static_assert(offsetof(AOrionCharAISpawner, SpawnRadius) == 0x000460, "Member 'AOrionCharAISpawner::SpawnRadius' has a wrong offset!");
static_assert(offsetof(AOrionCharAISpawner, FormationData) == 0x000468, "Member 'AOrionCharAISpawner::FormationData' has a wrong offset!");
static_assert(offsetof(AOrionCharAISpawner, bStartGameWithVision) == 0x000470, "Member 'AOrionCharAISpawner::bStartGameWithVision' has a wrong offset!");
static_assert(offsetof(AOrionCharAISpawner, bGrantVisionOnRespawn) == 0x000471, "Member 'AOrionCharAISpawner::bGrantVisionOnRespawn' has a wrong offset!");
static_assert(offsetof(AOrionCharAISpawner, bAlwaysGrantVision) == 0x000472, "Member 'AOrionCharAISpawner::bAlwaysGrantVision' has a wrong offset!");
static_assert(offsetof(AOrionCharAISpawner, SpawnerIndicatorTagRequirements) == 0x000478, "Member 'AOrionCharAISpawner::SpawnerIndicatorTagRequirements' has a wrong offset!");
static_assert(offsetof(AOrionCharAISpawner, SpawnerVisionTags) == 0x000498, "Member 'AOrionCharAISpawner::SpawnerVisionTags' has a wrong offset!");
static_assert(offsetof(AOrionCharAISpawner, InitialSpawnDelay) == 0x0004B8, "Member 'AOrionCharAISpawner::InitialSpawnDelay' has a wrong offset!");
static_assert(offsetof(AOrionCharAISpawner, ReplenishDelayTimer) == 0x0004BC, "Member 'AOrionCharAISpawner::ReplenishDelayTimer' has a wrong offset!");
static_assert(offsetof(AOrionCharAISpawner, IntroSpawnTimer) == 0x0004C0, "Member 'AOrionCharAISpawner::IntroSpawnTimer' has a wrong offset!");
static_assert(offsetof(AOrionCharAISpawner, AISpawnedInStartingLevel) == 0x0004C4, "Member 'AOrionCharAISpawner::AISpawnedInStartingLevel' has a wrong offset!");
static_assert(offsetof(AOrionCharAISpawner, ReplicatedSpawnTime) == 0x0004C8, "Member 'AOrionCharAISpawner::ReplicatedSpawnTime' has a wrong offset!");
static_assert(offsetof(AOrionCharAISpawner, ReplicatedSpawnTimeTotal) == 0x0004CC, "Member 'AOrionCharAISpawner::ReplicatedSpawnTimeTotal' has a wrong offset!");
static_assert(offsetof(AOrionCharAISpawner, SpawnedAICount) == 0x0004D0, "Member 'AOrionCharAISpawner::SpawnedAICount' has a wrong offset!");
static_assert(offsetof(AOrionCharAISpawner, CurrentBuffTypeTag) == 0x0004D8, "Member 'AOrionCharAISpawner::CurrentBuffTypeTag' has a wrong offset!");
static_assert(offsetof(AOrionCharAISpawner, bUpdateVisibilityOnLOSGain) == 0x0004EC, "Member 'AOrionCharAISpawner::bUpdateVisibilityOnLOSGain' has a wrong offset!");
static_assert(offsetof(AOrionCharAISpawner, LaneID) == 0x0004F0, "Member 'AOrionCharAISpawner::LaneID' has a wrong offset!");
static_assert(offsetof(AOrionCharAISpawner, KillingTeamNum) == 0x0004F4, "Member 'AOrionCharAISpawner::KillingTeamNum' has a wrong offset!");
static_assert(offsetof(AOrionCharAISpawner, AIToSpawnNextWave) == 0x000560, "Member 'AOrionCharAISpawner::AIToSpawnNextWave' has a wrong offset!");
static_assert(offsetof(AOrionCharAISpawner, CurrentFormationBeingSpawned) == 0x000570, "Member 'AOrionCharAISpawner::CurrentFormationBeingSpawned' has a wrong offset!");
static_assert(offsetof(AOrionCharAISpawner, CurrentSpawnedAIIndex) == 0x0005C0, "Member 'AOrionCharAISpawner::CurrentSpawnedAIIndex' has a wrong offset!");
static_assert(offsetof(AOrionCharAISpawner, AISystem) == 0x0005C8, "Member 'AOrionCharAISpawner::AISystem' has a wrong offset!");

// Class OrionGame.OrionAIPerceptionSystem
// 0x0008 (0x0138 - 0x0130)
class UOrionAIPerceptionSystem final : public UAIPerceptionSystem
{
public:
	uint8                                         Pad_130[0x8];                                      // 0x0130(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleCallForHelp(class AActor* DamagedActor, class AActor* AttackingActor, const struct FGameplayEffectSpec& EffectSpec);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAIPerceptionSystem">();
	}
	static class UOrionAIPerceptionSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAIPerceptionSystem>();
	}
};
static_assert(alignof(UOrionAIPerceptionSystem) == 0x000008, "Wrong alignment on UOrionAIPerceptionSystem");
static_assert(sizeof(UOrionAIPerceptionSystem) == 0x000138, "Wrong size on UOrionAIPerceptionSystem");

// Class OrionGame.OrionChar
// 0x03D0 (0x0AF0 - 0x0720)
class AOrionChar : public ACharacter
{
public:
	uint8                                         Pad_720[0x58];                                     // 0x0720(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrionPlayerState_Game*                 OrionPlayerState;                                  // 0x0778(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionAbilitySystemComponent*           AbilitySystemComponent;                            // 0x0780(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionHealthSet*                        HealthSetRef;                                      // 0x0788(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionCombatSet*                        CombatSetRef;                                      // 0x0790(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionMoveSet*                          MoveSetRef;                                        // 0x0798(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionXPSet*                            XPSetRef;                                          // 0x07A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionVisionSet*                        VisionSetRef;                                      // 0x07A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanWideTick;                                      // 0x07B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B1[0x7];                                      // 0x07B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrionPlayerState_Game*                 WinningActorPlayerState;                           // 0x07B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FNormalAppearanceComponentMaterials> NormalAppearanceComponentMaterials;                // 0x07C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FOrionReplicatedVisionData             ReplicatedVisionData;                              // 0x07D0(0x0004)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	struct FOrionReplicatedVisibleToEnemy         VisibleToEnemy;                                    // 0x07D4(0x0004)(Net, IsPlainOldData, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsJumpProvidingForce;                             // 0x07D8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCurrentlyUsingFlowField;                        // 0x07D9(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7DA[0x2];                                      // 0x07DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bReplayHasRootMotionSouceTakingOverLocomotionAnims : 1; // 0x07DC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_7DD[0x3];                                      // 0x07DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APawn*>                          DisabledMovementCollisionPawns;                    // 0x07E0(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_7F0[0x40];                                     // 0x07F0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bManageSignificance;                               // 0x0830(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrionSignificanceType                        SignificanceType;                                  // 0x0831(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_832[0x6];                                      // 0x0832(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnDeath;                                           // 0x0838(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_848[0x88];                                     // 0x0848(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	EProjectileCustomHitResponseType              ProjectileCustomHitResponseType;                   // 0x08D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D1[0x7];                                      // 0x08D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagRequirements               TargetingTagRequirements;                          // 0x08D8(0x0040)(Net, Transient, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEnteredPhaseShift;                               // 0x0918(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnChangedDimension;                                // 0x0928(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_938[0x88];                                     // 0x0938(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnTeamChangedDelegate;                             // 0x09C0(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                LimboHiddenComponentList;                          // 0x09D0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_9E0[0x8];                                      // 0x09E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         BitPad_9E8_0 : 2;                                  // 0x09E8(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bIsDying : 1;                                      // 0x09E8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_9E9[0x3];                                      // 0x09E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EOrionTeam                                    TeamNum;                                           // 0x09EC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrionTargetType                              TargetType;                                        // 0x09ED(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldIgnoreCollisionWithTeamTargeting;           // 0x09EE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanBeHitWhileInShadowPlane;                       // 0x09EF(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TargetingSocketName;                               // 0x09F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   NumberPopSocketName;                               // 0x09F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A00[0x8];                                      // 0x0A00(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           LeaveVisionZoneTimerHandle;                        // 0x0A08(0x0008)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           CantSeeVisionZoneTimerHandle;                      // 0x0A10(0x0008)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A18[0x18];                                     // 0x0A18(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageFlashDuration;                               // 0x0A30(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageFlashMaterialUpdateRate;                     // 0x0A34(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DamageFlashIntensityMaterialParameterName;         // 0x0A38(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DamageFlashDirectionMaterialParameterName;         // 0x0A40(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            DamageFlashIntensityCurve;                         // 0x0A48(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A50[0x20];                                     // 0x0A50(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BaseNonRenderedAnimUpdateRate;                     // 0x0A70(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A74[0x4];                                      // 0x0A74(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 AnimUpdateRateVisibleMaxDistanceFactor;            // 0x0A78(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            LODToFrameSkipMap;                                 // 0x0A88(0x0050)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	EUpdateRateShiftBucket                        UroShiftBucket;                                    // 0x0AD8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD9[0x3];                                      // 0x0AD9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxEvalRateForInterpolation;                       // 0x0ADC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQuat                                  AnimInstanceRotationOffset;                        // 0x0AE0(0x0010)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	void ApplyAlternateAppearance(class UMaterialInterface* Material, bool bDisableShadowCasting);
	void ChangeLocalStatus(EOrionCharLocalStatusTypes OrionCharLocalStatusType, bool bSetTo);
	bool CustomMatch_RemoveOnDeath(const struct FActiveGameplayEffect& Effect);
	void DimensionChangeTimeOut();
	void ForceNextZoneChangeImmediate();
	bool GetCurrentTargetIsLocalHero();
	const float GetEstimatedCXPBounty();
	bool GetLocalStatus(EOrionCharLocalStatusTypes OrionCharLocalStatusType);
	void ImmediateZoneChangeTimeOut();
	bool IsInShadowPlane();
	bool IsSuspended();
	bool IsWorldDirectionABackPedalAnimation(const struct FVector& InWorldDirectionVector);
	void OnAllMontageInstancesEnded();
	void OnCustomHit(const struct FHitResult& Hit, EProjectileCustomHitResponseType ProjectileCustomHitResponseType_0, float Magnitude);
	void OnFinishedDying();
	void OnMontageStarted(class UAnimMontage* Montage);
	void OnRep_DisabledMovementCollisionPawns();
	void OnRep_ReplicatedVisionData(const struct FOrionReplicatedVisionData& OldData);
	void OnRep_TeamNum();
	void OnRep_VisibleToEnemy(const struct FOrionReplicatedVisibleToEnemy& OldValue);
	void PlayDying();
	class UAudioComponent* PlaySoundOnActor(class USoundBase* SoundToPlay, bool bAttached, bool bStopWhenAttachedToDestroyed);
	class UAudioComponent* PlaySoundTeamAdjustedForSelf(class USoundBase* SoundToPlay, bool Attached, bool bStopWhenAttachedToDestroyed);
	void RemoveAlternateAppearance();
	void SetTargetingTagRequirements(const struct FGameplayTagRequirements& InTargetingTagRequirements);
	void UpdateMultipleScalarParametersOnMaterials(class USkeletalMeshComponent* Component, float ParameterValue, const TArray<class FName>& ParameterNames);
	void UpdateMultipleVectorParametersOnMaterials(class USkeletalMeshComponent* Component, const struct FLinearColor& ParameterValue, const TArray<class FName>& ParameterNames);
	void UpdateScalarParameterValueOnMaterials(class USkeletalMeshComponent* Component, class FName ParameterName, float ParameterValue);
	void UpdateVectorParameterValueOnMaterials(class USkeletalMeshComponent* Component, class FName ParameterName, const struct FLinearColor& ParameterValue);

	float GetHealth() const;
	float GetHealthPercent() const;
	float GetHealthRegen() const;
	float GetMaxHealth() const;
	EOrionTeam GetTeamNum() const;
	float GetTotalTimeToAttack() const;
	bool IsAbilityUseDisabled() const;
	bool IsBasicAttackDisabled() const;
	bool IsJumpProvidingForce() const;
	bool IsMovementDisabled() const;
	bool IsSilenced() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionChar">();
	}
	static class AOrionChar* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionChar>();
	}
};
static_assert(alignof(AOrionChar) == 0x000010, "Wrong alignment on AOrionChar");
static_assert(sizeof(AOrionChar) == 0x000AF0, "Wrong size on AOrionChar");
static_assert(offsetof(AOrionChar, OrionPlayerState) == 0x000778, "Member 'AOrionChar::OrionPlayerState' has a wrong offset!");
static_assert(offsetof(AOrionChar, AbilitySystemComponent) == 0x000780, "Member 'AOrionChar::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(AOrionChar, HealthSetRef) == 0x000788, "Member 'AOrionChar::HealthSetRef' has a wrong offset!");
static_assert(offsetof(AOrionChar, CombatSetRef) == 0x000790, "Member 'AOrionChar::CombatSetRef' has a wrong offset!");
static_assert(offsetof(AOrionChar, MoveSetRef) == 0x000798, "Member 'AOrionChar::MoveSetRef' has a wrong offset!");
static_assert(offsetof(AOrionChar, XPSetRef) == 0x0007A0, "Member 'AOrionChar::XPSetRef' has a wrong offset!");
static_assert(offsetof(AOrionChar, VisionSetRef) == 0x0007A8, "Member 'AOrionChar::VisionSetRef' has a wrong offset!");
static_assert(offsetof(AOrionChar, bCanWideTick) == 0x0007B0, "Member 'AOrionChar::bCanWideTick' has a wrong offset!");
static_assert(offsetof(AOrionChar, WinningActorPlayerState) == 0x0007B8, "Member 'AOrionChar::WinningActorPlayerState' has a wrong offset!");
static_assert(offsetof(AOrionChar, NormalAppearanceComponentMaterials) == 0x0007C0, "Member 'AOrionChar::NormalAppearanceComponentMaterials' has a wrong offset!");
static_assert(offsetof(AOrionChar, ReplicatedVisionData) == 0x0007D0, "Member 'AOrionChar::ReplicatedVisionData' has a wrong offset!");
static_assert(offsetof(AOrionChar, VisibleToEnemy) == 0x0007D4, "Member 'AOrionChar::VisibleToEnemy' has a wrong offset!");
static_assert(offsetof(AOrionChar, bIsJumpProvidingForce) == 0x0007D8, "Member 'AOrionChar::bIsJumpProvidingForce' has a wrong offset!");
static_assert(offsetof(AOrionChar, bIsCurrentlyUsingFlowField) == 0x0007D9, "Member 'AOrionChar::bIsCurrentlyUsingFlowField' has a wrong offset!");
static_assert(offsetof(AOrionChar, DisabledMovementCollisionPawns) == 0x0007E0, "Member 'AOrionChar::DisabledMovementCollisionPawns' has a wrong offset!");
static_assert(offsetof(AOrionChar, bManageSignificance) == 0x000830, "Member 'AOrionChar::bManageSignificance' has a wrong offset!");
static_assert(offsetof(AOrionChar, SignificanceType) == 0x000831, "Member 'AOrionChar::SignificanceType' has a wrong offset!");
static_assert(offsetof(AOrionChar, OnDeath) == 0x000838, "Member 'AOrionChar::OnDeath' has a wrong offset!");
static_assert(offsetof(AOrionChar, ProjectileCustomHitResponseType) == 0x0008D0, "Member 'AOrionChar::ProjectileCustomHitResponseType' has a wrong offset!");
static_assert(offsetof(AOrionChar, TargetingTagRequirements) == 0x0008D8, "Member 'AOrionChar::TargetingTagRequirements' has a wrong offset!");
static_assert(offsetof(AOrionChar, OnEnteredPhaseShift) == 0x000918, "Member 'AOrionChar::OnEnteredPhaseShift' has a wrong offset!");
static_assert(offsetof(AOrionChar, OnChangedDimension) == 0x000928, "Member 'AOrionChar::OnChangedDimension' has a wrong offset!");
static_assert(offsetof(AOrionChar, OnTeamChangedDelegate) == 0x0009C0, "Member 'AOrionChar::OnTeamChangedDelegate' has a wrong offset!");
static_assert(offsetof(AOrionChar, LimboHiddenComponentList) == 0x0009D0, "Member 'AOrionChar::LimboHiddenComponentList' has a wrong offset!");
static_assert(offsetof(AOrionChar, TeamNum) == 0x0009EC, "Member 'AOrionChar::TeamNum' has a wrong offset!");
static_assert(offsetof(AOrionChar, TargetType) == 0x0009ED, "Member 'AOrionChar::TargetType' has a wrong offset!");
static_assert(offsetof(AOrionChar, bShouldIgnoreCollisionWithTeamTargeting) == 0x0009EE, "Member 'AOrionChar::bShouldIgnoreCollisionWithTeamTargeting' has a wrong offset!");
static_assert(offsetof(AOrionChar, bCanBeHitWhileInShadowPlane) == 0x0009EF, "Member 'AOrionChar::bCanBeHitWhileInShadowPlane' has a wrong offset!");
static_assert(offsetof(AOrionChar, TargetingSocketName) == 0x0009F0, "Member 'AOrionChar::TargetingSocketName' has a wrong offset!");
static_assert(offsetof(AOrionChar, NumberPopSocketName) == 0x0009F8, "Member 'AOrionChar::NumberPopSocketName' has a wrong offset!");
static_assert(offsetof(AOrionChar, LeaveVisionZoneTimerHandle) == 0x000A08, "Member 'AOrionChar::LeaveVisionZoneTimerHandle' has a wrong offset!");
static_assert(offsetof(AOrionChar, CantSeeVisionZoneTimerHandle) == 0x000A10, "Member 'AOrionChar::CantSeeVisionZoneTimerHandle' has a wrong offset!");
static_assert(offsetof(AOrionChar, DamageFlashDuration) == 0x000A30, "Member 'AOrionChar::DamageFlashDuration' has a wrong offset!");
static_assert(offsetof(AOrionChar, DamageFlashMaterialUpdateRate) == 0x000A34, "Member 'AOrionChar::DamageFlashMaterialUpdateRate' has a wrong offset!");
static_assert(offsetof(AOrionChar, DamageFlashIntensityMaterialParameterName) == 0x000A38, "Member 'AOrionChar::DamageFlashIntensityMaterialParameterName' has a wrong offset!");
static_assert(offsetof(AOrionChar, DamageFlashDirectionMaterialParameterName) == 0x000A40, "Member 'AOrionChar::DamageFlashDirectionMaterialParameterName' has a wrong offset!");
static_assert(offsetof(AOrionChar, DamageFlashIntensityCurve) == 0x000A48, "Member 'AOrionChar::DamageFlashIntensityCurve' has a wrong offset!");
static_assert(offsetof(AOrionChar, BaseNonRenderedAnimUpdateRate) == 0x000A70, "Member 'AOrionChar::BaseNonRenderedAnimUpdateRate' has a wrong offset!");
static_assert(offsetof(AOrionChar, AnimUpdateRateVisibleMaxDistanceFactor) == 0x000A78, "Member 'AOrionChar::AnimUpdateRateVisibleMaxDistanceFactor' has a wrong offset!");
static_assert(offsetof(AOrionChar, LODToFrameSkipMap) == 0x000A88, "Member 'AOrionChar::LODToFrameSkipMap' has a wrong offset!");
static_assert(offsetof(AOrionChar, UroShiftBucket) == 0x000AD8, "Member 'AOrionChar::UroShiftBucket' has a wrong offset!");
static_assert(offsetof(AOrionChar, MaxEvalRateForInterpolation) == 0x000ADC, "Member 'AOrionChar::MaxEvalRateForInterpolation' has a wrong offset!");
static_assert(offsetof(AOrionChar, AnimInstanceRotationOffset) == 0x000AE0, "Member 'AOrionChar::AnimInstanceRotationOffset' has a wrong offset!");

// Class OrionGame.OrionCharAI
// 0x00E0 (0x0BD0 - 0x0AF0)
class AOrionCharAI : public AOrionChar
{
public:
	uint8                                         Pad_AF0[0x11];                                     // 0x0AF0(0x0011)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bUseTeamCollisions : 1;                            // 0x0B01(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHitReactionOnlyOnPlayerHit : 1;                   // 0x0B01(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_B02[0x6];                                      // 0x0B02(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	EAIMinionType                                 MinionType;                                        // 0x0B08(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B09[0x3];                                      // 0x0B09(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        ImplementationVersion;                             // 0x0B0C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   MinHealthForHeroExecuteCurve;                      // 0x0B10(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOrionAbilitySystemComponent*           AI_AbilitySystemComponent;                         // 0x0B20(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionHealthSet*                        HealthSet;                                         // 0x0B28(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionCombatSet*                        CombatSet;                                         // 0x0B30(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionMoveSet*                          MoveSet;                                           // 0x0B38(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionXPSet*                            XPSet;                                             // 0x0B40(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionVisionSet*                        VisionSet;                                         // 0x0B48(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionAIData*                           AIData;                                            // 0x0B50(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   AttackRange;                                       // 0x0B58(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   AttackRangeObjectives;                             // 0x0B60(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   CheckTargetRangeFrequency;                         // 0x0B68(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundBase*                             ImpactSoundCue;                                    // 0x0B70(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGameplayEffect>            CombatEffect;                                      // 0x0B78(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B80[0x8];                                      // 0x0B80(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CachedDefaultLastHitHealthMin;                     // 0x0B88(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SpawnCoinDelayTimer;                               // 0x0B8C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FOrionCharDeathData                    DeathData;                                         // 0x0B90(0x0018)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        AggroAlertEffect;                                  // 0x0BA8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundBase*                             AggroAlertSoundCue;                                // 0x0BB0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SpawnID;                                           // 0x0BB8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         TeamSpawnID;                                       // 0x0BBC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BC0[0x10];                                     // 0x0BC0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FActiveGameplayEffectHandle ApplyGameplayEffectToSelf(class UGameplayEffect* GameplayEffect, float GameplayEffectLevel);
	void CancelAnimation(EOrionMinionPrioritizedBehavior Behavior);
	void GameplayCue_Damage(EGameplayCueEvent EventType, const struct FGameplayCueParameters& Parameters);
	bool GetCurrentTargetIsLocalHero();
	void OnNewTargetAcquired(class AActor* NewTarget);
	void OnRep_AIData(const class UOrionAIData* OldAIData);
	void OnRep_DeathData();
	void PlayHeroAggroAlert(class AOrionCharHero* HeroTarget);
	void RequestAnimation(EOrionMinionPrioritizedBehavior Behavior, int32 PlayIndex, bool bLooping);
	void SetUpMeshShadows(class USkeletalMeshComponent* SkeletalMeshComponent);

	float GetExecuteHealthThreshold(class UOrionAbilitySystemComponent* DamagerASC) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCharAI">();
	}
	static class AOrionCharAI* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionCharAI>();
	}
};
static_assert(alignof(AOrionCharAI) == 0x000010, "Wrong alignment on AOrionCharAI");
static_assert(sizeof(AOrionCharAI) == 0x000BD0, "Wrong size on AOrionCharAI");
static_assert(offsetof(AOrionCharAI, MinionType) == 0x000B08, "Member 'AOrionCharAI::MinionType' has a wrong offset!");
static_assert(offsetof(AOrionCharAI, ImplementationVersion) == 0x000B0C, "Member 'AOrionCharAI::ImplementationVersion' has a wrong offset!");
static_assert(offsetof(AOrionCharAI, MinHealthForHeroExecuteCurve) == 0x000B10, "Member 'AOrionCharAI::MinHealthForHeroExecuteCurve' has a wrong offset!");
static_assert(offsetof(AOrionCharAI, AI_AbilitySystemComponent) == 0x000B20, "Member 'AOrionCharAI::AI_AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(AOrionCharAI, HealthSet) == 0x000B28, "Member 'AOrionCharAI::HealthSet' has a wrong offset!");
static_assert(offsetof(AOrionCharAI, CombatSet) == 0x000B30, "Member 'AOrionCharAI::CombatSet' has a wrong offset!");
static_assert(offsetof(AOrionCharAI, MoveSet) == 0x000B38, "Member 'AOrionCharAI::MoveSet' has a wrong offset!");
static_assert(offsetof(AOrionCharAI, XPSet) == 0x000B40, "Member 'AOrionCharAI::XPSet' has a wrong offset!");
static_assert(offsetof(AOrionCharAI, VisionSet) == 0x000B48, "Member 'AOrionCharAI::VisionSet' has a wrong offset!");
static_assert(offsetof(AOrionCharAI, AIData) == 0x000B50, "Member 'AOrionCharAI::AIData' has a wrong offset!");
static_assert(offsetof(AOrionCharAI, AttackRange) == 0x000B58, "Member 'AOrionCharAI::AttackRange' has a wrong offset!");
static_assert(offsetof(AOrionCharAI, AttackRangeObjectives) == 0x000B60, "Member 'AOrionCharAI::AttackRangeObjectives' has a wrong offset!");
static_assert(offsetof(AOrionCharAI, CheckTargetRangeFrequency) == 0x000B68, "Member 'AOrionCharAI::CheckTargetRangeFrequency' has a wrong offset!");
static_assert(offsetof(AOrionCharAI, ImpactSoundCue) == 0x000B70, "Member 'AOrionCharAI::ImpactSoundCue' has a wrong offset!");
static_assert(offsetof(AOrionCharAI, CombatEffect) == 0x000B78, "Member 'AOrionCharAI::CombatEffect' has a wrong offset!");
static_assert(offsetof(AOrionCharAI, CachedDefaultLastHitHealthMin) == 0x000B88, "Member 'AOrionCharAI::CachedDefaultLastHitHealthMin' has a wrong offset!");
static_assert(offsetof(AOrionCharAI, SpawnCoinDelayTimer) == 0x000B8C, "Member 'AOrionCharAI::SpawnCoinDelayTimer' has a wrong offset!");
static_assert(offsetof(AOrionCharAI, DeathData) == 0x000B90, "Member 'AOrionCharAI::DeathData' has a wrong offset!");
static_assert(offsetof(AOrionCharAI, AggroAlertEffect) == 0x000BA8, "Member 'AOrionCharAI::AggroAlertEffect' has a wrong offset!");
static_assert(offsetof(AOrionCharAI, AggroAlertSoundCue) == 0x000BB0, "Member 'AOrionCharAI::AggroAlertSoundCue' has a wrong offset!");
static_assert(offsetof(AOrionCharAI, SpawnID) == 0x000BB8, "Member 'AOrionCharAI::SpawnID' has a wrong offset!");
static_assert(offsetof(AOrionCharAI, TeamSpawnID) == 0x000BBC, "Member 'AOrionCharAI::TeamSpawnID' has a wrong offset!");

// Class OrionGame.OrionAIResource_AbilityExecution
// 0x0000 (0x0038 - 0x0038)
class UOrionAIResource_AbilityExecution final : public UGameplayTaskResource
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAIResource_AbilityExecution">();
	}
	static class UOrionAIResource_AbilityExecution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAIResource_AbilityExecution>();
	}
};
static_assert(alignof(UOrionAIResource_AbilityExecution) == 0x000008, "Wrong alignment on UOrionAIResource_AbilityExecution");
static_assert(sizeof(UOrionAIResource_AbilityExecution) == 0x000038, "Wrong size on UOrionAIResource_AbilityExecution");

// Class OrionGame.OrionCardLevelingInfo
// 0x0010 (0x0040 - 0x0030)
class UOrionCardLevelingInfo final : public UDataAsset
{
public:
	TArray<struct FOrionLevelChainByRarity>       LevelChains;                                       // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCardLevelingInfo">();
	}
	static class UOrionCardLevelingInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionCardLevelingInfo>();
	}
};
static_assert(alignof(UOrionCardLevelingInfo) == 0x000008, "Wrong alignment on UOrionCardLevelingInfo");
static_assert(sizeof(UOrionCardLevelingInfo) == 0x000040, "Wrong size on UOrionCardLevelingInfo");
static_assert(offsetof(UOrionCardLevelingInfo, LevelChains) == 0x000030, "Member 'UOrionCardLevelingInfo::LevelChains' has a wrong offset!");

// Class OrionGame.OrionAISense_MapVision
// 0x0040 (0x0160 - 0x0120)
class UOrionAISense_MapVision final : public UAISense
{
public:
	uint8                                         Pad_120[0x40];                                     // 0x0120(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAISense_MapVision">();
	}
	static class UOrionAISense_MapVision* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAISense_MapVision>();
	}
};
static_assert(alignof(UOrionAISense_MapVision) == 0x000008, "Wrong alignment on UOrionAISense_MapVision");
static_assert(sizeof(UOrionAISense_MapVision) == 0x000160, "Wrong size on UOrionAISense_MapVision");

// Class OrionGame.OrionCharAI_Minion
// 0x0210 (0x0DE0 - 0x0BD0)
#pragma pack(push, 0x1)
class alignas(0x10) AOrionCharAI_Minion : public AOrionCharAI
{
public:
	struct FOrionMinionNudgeInfo                  NudgeInfo;                                         // 0x0BD0(0x0040)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C10[0x8];                                      // 0x0C10(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     FriendlyTeamMaterial;                              // 0x0C18(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     EnemyTeamMaterial;                                 // 0x0C20(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bUseTeamMaterials : 1;                             // 0x0C28(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bShouldDeathEffectCastShadow : 1;                  // 0x0C28(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPlayDeathSoundAttached : 1;                       // 0x0C28(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUsePiecewiseDeathFX : 1;                          // 0x0C28(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUseAdditiveAttackAnim : 1;                        // 0x0C28(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_C29[0x7];                                      // 0x0C29(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 CurrentTarget;                                     // 0x0C30(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        RangedAttackMuzzleFlash;                           // 0x0C38(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         RangedAttackMuzzleFlash_Niagara;                   // 0x0C40(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RangedAttackMuzzleSocket;                          // 0x0C48(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             RangedAttackSoundCue;                              // 0x0C50(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        RangedAttackBeamAAttack;                           // 0x0C58(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        RangedAttackProjectileAttack;                      // 0x0C60(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         RangedAttackProjectileAttack_Niagara;              // 0x0C68(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        RangedAttackImpactEffect;                          // 0x0C70(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         RangedAttackImpactEffect_Niagara;                  // 0x0C78(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RangedAttackTravelSpeed;                           // 0x0C80(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C84[0x4];                                      // 0x0C84(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            RangedDamageGameplayEffect;                        // 0x0C88(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            MeleeDamageGameplayEffect;                         // 0x0C90(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        MeleeAttackImpactEffect;                           // 0x0C98(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         MeleeAttackImpactEffect_Niagara;                   // 0x0CA0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MeleeAttackImpactEffectName;                       // 0x0CA8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                MeleeImpactFXSpawnLocation;                        // 0x0CB0(0x000C)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MeleeImpactDelayTime;                              // 0x0CBC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             DeathSoundCue;                                     // 0x0CC0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        DeathEffect;                                       // 0x0CC8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         DeathEffect_Niagara;                               // 0x0CD0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DeathEffectSocketName;                             // 0x0CD8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DeathAnimDuration;                                 // 0x0CE0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CE4[0x4];                                      // 0x0CE4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        PiecewiseDeathEffect;                              // 0x0CE8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         PiecewiseDeathEffect_Niagara;                      // 0x0CF0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            PiecewiseDeathDamageToVelocityCurve;               // 0x0CF8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PiecewiseDeathDamageToVelocityPercentVariance;     // 0x0D00(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D04[0x4];                                      // 0x0D04(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            PiecewiseDeathVelocityPitchCurve;                  // 0x0D08(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PiecewiseDeathVelocityPitchVariance;               // 0x0D10(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PiecewiseDeathVelocityYawVariance;                 // 0x0D14(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PiecewiseDeathVelocitySourceDistance;              // 0x0D18(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PiecewiseDeathVelocitySourceDistanceVariance;      // 0x0D1C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            SelfDestructGameplayEffect;                        // 0x0D20(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           SpawningGameplayCue;                               // 0x0D28(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             SpawningSoundCue;                                  // 0x0D30(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 DamageTarget;                                      // 0x0D38(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 LastMeleeTarget;                                   // 0x0D40(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AOrionAIMinionProjectileManager*        ProjectileManager;                                 // 0x0D48(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               NativeMeleeImpactEffectPSC;                        // 0x0D50(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               NativeRangedAttackMuzzleFlashPSC;                  // 0x0D58(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               NativeRangedAttackBeamPSC;                         // 0x0D60(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               NativeRangedImpactEffectPSC;                       // 0x0D68(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               NativeDeathEffectPSC;                              // 0x0D70(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            BonusDamageVsMinions;                              // 0x0D78(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            BonusDamageVsHeroes;                               // 0x0D80(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            BonusDamageVsTowers;                               // 0x0D88(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            BonusDamageVsInhib;                                // 0x0D90(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            BonusDamageVsCore;                                 // 0x0D98(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            BonusResistVsMinions;                              // 0x0DA0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            BonusResistVsHeroes;                               // 0x0DA8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            BonusResistVsTowers;                               // 0x0DB0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            BonusResistVsInhib;                                // 0x0DB8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            BonusResistVsCore;                                 // 0x0DC0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            BonusDamageFromHeroes;                             // 0x0DC8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RangedMinnionMaxDistanceForMeleeAttack;            // 0x0DD0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DD4[0x4];                                      // 0x0DD4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Debug_OverrideTeamVisuals(EOrionTeam NewTeamVisuals);
	void MinionBeginOverlap(class AActor* SelfActor, class AActor* OtherActor);
	void Native_DoMeleeAttack(class AActor* TargetActor);
	void Native_DoRangedAttack(class AActor* TargetActor);
	void Native_MulticastDoRangedAttack(const struct FOrionMinionAttackInfo& RangedAttackInfo);
	void OnPlayDeathAnim(float PlaybackTime, bool bAllowedToRagdoll);
	void PlaySpawning();
	void RequestSelfDestruct(float Delay);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCharAI_Minion">();
	}
	static class AOrionCharAI_Minion* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionCharAI_Minion>();
	}
};
#pragma pack(pop)
static_assert(alignof(AOrionCharAI_Minion) == 0x000010, "Wrong alignment on AOrionCharAI_Minion");
static_assert(sizeof(AOrionCharAI_Minion) == 0x000DE0, "Wrong size on AOrionCharAI_Minion");
static_assert(offsetof(AOrionCharAI_Minion, NudgeInfo) == 0x000BD0, "Member 'AOrionCharAI_Minion::NudgeInfo' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, FriendlyTeamMaterial) == 0x000C18, "Member 'AOrionCharAI_Minion::FriendlyTeamMaterial' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, EnemyTeamMaterial) == 0x000C20, "Member 'AOrionCharAI_Minion::EnemyTeamMaterial' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, CurrentTarget) == 0x000C30, "Member 'AOrionCharAI_Minion::CurrentTarget' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, RangedAttackMuzzleFlash) == 0x000C38, "Member 'AOrionCharAI_Minion::RangedAttackMuzzleFlash' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, RangedAttackMuzzleFlash_Niagara) == 0x000C40, "Member 'AOrionCharAI_Minion::RangedAttackMuzzleFlash_Niagara' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, RangedAttackMuzzleSocket) == 0x000C48, "Member 'AOrionCharAI_Minion::RangedAttackMuzzleSocket' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, RangedAttackSoundCue) == 0x000C50, "Member 'AOrionCharAI_Minion::RangedAttackSoundCue' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, RangedAttackBeamAAttack) == 0x000C58, "Member 'AOrionCharAI_Minion::RangedAttackBeamAAttack' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, RangedAttackProjectileAttack) == 0x000C60, "Member 'AOrionCharAI_Minion::RangedAttackProjectileAttack' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, RangedAttackProjectileAttack_Niagara) == 0x000C68, "Member 'AOrionCharAI_Minion::RangedAttackProjectileAttack_Niagara' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, RangedAttackImpactEffect) == 0x000C70, "Member 'AOrionCharAI_Minion::RangedAttackImpactEffect' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, RangedAttackImpactEffect_Niagara) == 0x000C78, "Member 'AOrionCharAI_Minion::RangedAttackImpactEffect_Niagara' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, RangedAttackTravelSpeed) == 0x000C80, "Member 'AOrionCharAI_Minion::RangedAttackTravelSpeed' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, RangedDamageGameplayEffect) == 0x000C88, "Member 'AOrionCharAI_Minion::RangedDamageGameplayEffect' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, MeleeDamageGameplayEffect) == 0x000C90, "Member 'AOrionCharAI_Minion::MeleeDamageGameplayEffect' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, MeleeAttackImpactEffect) == 0x000C98, "Member 'AOrionCharAI_Minion::MeleeAttackImpactEffect' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, MeleeAttackImpactEffect_Niagara) == 0x000CA0, "Member 'AOrionCharAI_Minion::MeleeAttackImpactEffect_Niagara' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, MeleeAttackImpactEffectName) == 0x000CA8, "Member 'AOrionCharAI_Minion::MeleeAttackImpactEffectName' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, MeleeImpactFXSpawnLocation) == 0x000CB0, "Member 'AOrionCharAI_Minion::MeleeImpactFXSpawnLocation' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, MeleeImpactDelayTime) == 0x000CBC, "Member 'AOrionCharAI_Minion::MeleeImpactDelayTime' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, DeathSoundCue) == 0x000CC0, "Member 'AOrionCharAI_Minion::DeathSoundCue' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, DeathEffect) == 0x000CC8, "Member 'AOrionCharAI_Minion::DeathEffect' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, DeathEffect_Niagara) == 0x000CD0, "Member 'AOrionCharAI_Minion::DeathEffect_Niagara' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, DeathEffectSocketName) == 0x000CD8, "Member 'AOrionCharAI_Minion::DeathEffectSocketName' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, DeathAnimDuration) == 0x000CE0, "Member 'AOrionCharAI_Minion::DeathAnimDuration' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, PiecewiseDeathEffect) == 0x000CE8, "Member 'AOrionCharAI_Minion::PiecewiseDeathEffect' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, PiecewiseDeathEffect_Niagara) == 0x000CF0, "Member 'AOrionCharAI_Minion::PiecewiseDeathEffect_Niagara' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, PiecewiseDeathDamageToVelocityCurve) == 0x000CF8, "Member 'AOrionCharAI_Minion::PiecewiseDeathDamageToVelocityCurve' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, PiecewiseDeathDamageToVelocityPercentVariance) == 0x000D00, "Member 'AOrionCharAI_Minion::PiecewiseDeathDamageToVelocityPercentVariance' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, PiecewiseDeathVelocityPitchCurve) == 0x000D08, "Member 'AOrionCharAI_Minion::PiecewiseDeathVelocityPitchCurve' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, PiecewiseDeathVelocityPitchVariance) == 0x000D10, "Member 'AOrionCharAI_Minion::PiecewiseDeathVelocityPitchVariance' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, PiecewiseDeathVelocityYawVariance) == 0x000D14, "Member 'AOrionCharAI_Minion::PiecewiseDeathVelocityYawVariance' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, PiecewiseDeathVelocitySourceDistance) == 0x000D18, "Member 'AOrionCharAI_Minion::PiecewiseDeathVelocitySourceDistance' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, PiecewiseDeathVelocitySourceDistanceVariance) == 0x000D1C, "Member 'AOrionCharAI_Minion::PiecewiseDeathVelocitySourceDistanceVariance' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, SelfDestructGameplayEffect) == 0x000D20, "Member 'AOrionCharAI_Minion::SelfDestructGameplayEffect' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, SpawningGameplayCue) == 0x000D28, "Member 'AOrionCharAI_Minion::SpawningGameplayCue' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, SpawningSoundCue) == 0x000D30, "Member 'AOrionCharAI_Minion::SpawningSoundCue' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, DamageTarget) == 0x000D38, "Member 'AOrionCharAI_Minion::DamageTarget' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, LastMeleeTarget) == 0x000D40, "Member 'AOrionCharAI_Minion::LastMeleeTarget' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, ProjectileManager) == 0x000D48, "Member 'AOrionCharAI_Minion::ProjectileManager' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, NativeMeleeImpactEffectPSC) == 0x000D50, "Member 'AOrionCharAI_Minion::NativeMeleeImpactEffectPSC' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, NativeRangedAttackMuzzleFlashPSC) == 0x000D58, "Member 'AOrionCharAI_Minion::NativeRangedAttackMuzzleFlashPSC' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, NativeRangedAttackBeamPSC) == 0x000D60, "Member 'AOrionCharAI_Minion::NativeRangedAttackBeamPSC' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, NativeRangedImpactEffectPSC) == 0x000D68, "Member 'AOrionCharAI_Minion::NativeRangedImpactEffectPSC' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, NativeDeathEffectPSC) == 0x000D70, "Member 'AOrionCharAI_Minion::NativeDeathEffectPSC' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, BonusDamageVsMinions) == 0x000D78, "Member 'AOrionCharAI_Minion::BonusDamageVsMinions' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, BonusDamageVsHeroes) == 0x000D80, "Member 'AOrionCharAI_Minion::BonusDamageVsHeroes' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, BonusDamageVsTowers) == 0x000D88, "Member 'AOrionCharAI_Minion::BonusDamageVsTowers' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, BonusDamageVsInhib) == 0x000D90, "Member 'AOrionCharAI_Minion::BonusDamageVsInhib' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, BonusDamageVsCore) == 0x000D98, "Member 'AOrionCharAI_Minion::BonusDamageVsCore' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, BonusResistVsMinions) == 0x000DA0, "Member 'AOrionCharAI_Minion::BonusResistVsMinions' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, BonusResistVsHeroes) == 0x000DA8, "Member 'AOrionCharAI_Minion::BonusResistVsHeroes' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, BonusResistVsTowers) == 0x000DB0, "Member 'AOrionCharAI_Minion::BonusResistVsTowers' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, BonusResistVsInhib) == 0x000DB8, "Member 'AOrionCharAI_Minion::BonusResistVsInhib' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, BonusResistVsCore) == 0x000DC0, "Member 'AOrionCharAI_Minion::BonusResistVsCore' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, BonusDamageFromHeroes) == 0x000DC8, "Member 'AOrionCharAI_Minion::BonusDamageFromHeroes' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_Minion, RangedMinnionMaxDistanceForMeleeAttack) == 0x000DD0, "Member 'AOrionCharAI_Minion::RangedMinnionMaxDistanceForMeleeAttack' has a wrong offset!");

// Class OrionGame.OrionCharAI_MinionLaneJoiner
// 0x00A0 (0x0E80 - 0x0DE0)
class AOrionCharAI_MinionLaneJoiner final : public AOrionCharAI_Minion
{
public:
	class UAnimMontage*                           DeathAnim;                                         // 0x0DD8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DeathMaterialFadeDelay;                            // 0x0DE0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DE4[0x4];                                      // 0x0DE4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     DeathMaterial;                                     // 0x0DE8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            CharacterMaterialFadeCurve;                        // 0x0DF0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            DeathMaterialFadeCurve;                            // 0x0DF8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DeathMaterialParameterName;                        // 0x0E00(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               DeathEffectMID;                                    // 0x0E08(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E10[0x70];                                     // 0x0E10(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCharAI_MinionLaneJoiner">();
	}
	static class AOrionCharAI_MinionLaneJoiner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionCharAI_MinionLaneJoiner>();
	}
};
static_assert(alignof(AOrionCharAI_MinionLaneJoiner) == 0x000010, "Wrong alignment on AOrionCharAI_MinionLaneJoiner");
static_assert(sizeof(AOrionCharAI_MinionLaneJoiner) == 0x000E80, "Wrong size on AOrionCharAI_MinionLaneJoiner");
static_assert(offsetof(AOrionCharAI_MinionLaneJoiner, DeathAnim) == 0x000DD8, "Member 'AOrionCharAI_MinionLaneJoiner::DeathAnim' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_MinionLaneJoiner, DeathMaterialFadeDelay) == 0x000DE0, "Member 'AOrionCharAI_MinionLaneJoiner::DeathMaterialFadeDelay' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_MinionLaneJoiner, DeathMaterial) == 0x000DE8, "Member 'AOrionCharAI_MinionLaneJoiner::DeathMaterial' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_MinionLaneJoiner, CharacterMaterialFadeCurve) == 0x000DF0, "Member 'AOrionCharAI_MinionLaneJoiner::CharacterMaterialFadeCurve' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_MinionLaneJoiner, DeathMaterialFadeCurve) == 0x000DF8, "Member 'AOrionCharAI_MinionLaneJoiner::DeathMaterialFadeCurve' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_MinionLaneJoiner, DeathMaterialParameterName) == 0x000E00, "Member 'AOrionCharAI_MinionLaneJoiner::DeathMaterialParameterName' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_MinionLaneJoiner, DeathEffectMID) == 0x000E08, "Member 'AOrionCharAI_MinionLaneJoiner::DeathEffectMID' has a wrong offset!");

// Class OrionGame.OrionAISenseConfig_MapVision
// 0x0000 (0x0048 - 0x0048)
class UOrionAISenseConfig_MapVision final : public UAISenseConfig
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAISenseConfig_MapVision">();
	}
	static class UOrionAISenseConfig_MapVision* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAISenseConfig_MapVision>();
	}
};
static_assert(alignof(UOrionAISenseConfig_MapVision) == 0x000008, "Wrong alignment on UOrionAISenseConfig_MapVision");
static_assert(sizeof(UOrionAISenseConfig_MapVision) == 0x000048, "Wrong size on UOrionAISenseConfig_MapVision");

// Class OrionGame.OrionStatManager
// 0x0088 (0x00B0 - 0x0028)
class UOrionStatManager final : public UObject
{
public:
	uint8                                         Pad_28[0x88];                                      // 0x0028(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionStatManager">();
	}
	static class UOrionStatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionStatManager>();
	}
};
static_assert(alignof(UOrionStatManager) == 0x000008, "Wrong alignment on UOrionStatManager");
static_assert(sizeof(UOrionStatManager) == 0x0000B0, "Wrong size on UOrionStatManager");

// Class OrionGame.OrionAISystem
// 0x01A8 (0x02D0 - 0x0128)
class UOrionAISystem final : public UAISystem
{
public:
	class UOrionWorldStateMonitor*                WorldStateMonitor;                                 // 0x0128(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionAICommander*                      AICommander;                                       // 0x0130(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AOrionAIInfluenceMapManager*            InfluenceMapManager;                               // 0x0138(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionBotAbilityPicker*                 AbilityPicker;                                     // 0x0140(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionAIMinionAggroManager*             MinionAggroManager;                                // 0x0148(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AOrionAIMinionProjectileManager*        MinionProjectileManager;                           // 0x0150(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABotObjectiveGraph*                     ObjectiveGraph;                                    // 0x0158(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AOrionAILevelMarkup*                    LevelMarkup;                                       // 0x0160(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABotLoSCache*                           BotLoSCache;                                       // 0x0168(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AOrionNavigationGraph*                  NavigationGraph;                                   // 0x0170(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBotKnowledgeHub                       KnowledgeHub;                                      // 0x0180(0x0110)(Transient, NativeAccessSpecifierPrivate)
	TArray<class AOrionAIBot*>                    BotControllers;                                    // 0x0290(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UAITeamComm*                            AITeamComms[0x2];                                  // 0x02A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B0[0x20];                                     // 0x02B0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ConfigureAsBotOnlyGame(class UObject* WorldContextObject);

	void OnMatchEnded();
	void OnMatchStarted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAISystem">();
	}
	static class UOrionAISystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAISystem>();
	}
};
static_assert(alignof(UOrionAISystem) == 0x000010, "Wrong alignment on UOrionAISystem");
static_assert(sizeof(UOrionAISystem) == 0x0002D0, "Wrong size on UOrionAISystem");
static_assert(offsetof(UOrionAISystem, WorldStateMonitor) == 0x000128, "Member 'UOrionAISystem::WorldStateMonitor' has a wrong offset!");
static_assert(offsetof(UOrionAISystem, AICommander) == 0x000130, "Member 'UOrionAISystem::AICommander' has a wrong offset!");
static_assert(offsetof(UOrionAISystem, InfluenceMapManager) == 0x000138, "Member 'UOrionAISystem::InfluenceMapManager' has a wrong offset!");
static_assert(offsetof(UOrionAISystem, AbilityPicker) == 0x000140, "Member 'UOrionAISystem::AbilityPicker' has a wrong offset!");
static_assert(offsetof(UOrionAISystem, MinionAggroManager) == 0x000148, "Member 'UOrionAISystem::MinionAggroManager' has a wrong offset!");
static_assert(offsetof(UOrionAISystem, MinionProjectileManager) == 0x000150, "Member 'UOrionAISystem::MinionProjectileManager' has a wrong offset!");
static_assert(offsetof(UOrionAISystem, ObjectiveGraph) == 0x000158, "Member 'UOrionAISystem::ObjectiveGraph' has a wrong offset!");
static_assert(offsetof(UOrionAISystem, LevelMarkup) == 0x000160, "Member 'UOrionAISystem::LevelMarkup' has a wrong offset!");
static_assert(offsetof(UOrionAISystem, BotLoSCache) == 0x000168, "Member 'UOrionAISystem::BotLoSCache' has a wrong offset!");
static_assert(offsetof(UOrionAISystem, NavigationGraph) == 0x000170, "Member 'UOrionAISystem::NavigationGraph' has a wrong offset!");
static_assert(offsetof(UOrionAISystem, KnowledgeHub) == 0x000180, "Member 'UOrionAISystem::KnowledgeHub' has a wrong offset!");
static_assert(offsetof(UOrionAISystem, BotControllers) == 0x000290, "Member 'UOrionAISystem::BotControllers' has a wrong offset!");
static_assert(offsetof(UOrionAISystem, AITeamComms) == 0x0002A0, "Member 'UOrionAISystem::AITeamComms' has a wrong offset!");

// Class OrionGame.OrionCharAISpawner_Jungle
// 0x0020 (0x0700 - 0x06E0)
class AOrionCharAISpawner_Jungle final : public AOrionCharAISpawner
{
public:
	TArray<TSubclassOf<class UGameplayEffect>>    ImmunityEffects;                                   // 0x06E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGameplayEffect>>    ResetEffects;                                      // 0x06F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCharAISpawner_Jungle">();
	}
	static class AOrionCharAISpawner_Jungle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionCharAISpawner_Jungle>();
	}
};
static_assert(alignof(AOrionCharAISpawner_Jungle) == 0x000008, "Wrong alignment on AOrionCharAISpawner_Jungle");
static_assert(sizeof(AOrionCharAISpawner_Jungle) == 0x000700, "Wrong size on AOrionCharAISpawner_Jungle");
static_assert(offsetof(AOrionCharAISpawner_Jungle, ImmunityEffects) == 0x0006E0, "Member 'AOrionCharAISpawner_Jungle::ImmunityEffects' has a wrong offset!");
static_assert(offsetof(AOrionCharAISpawner_Jungle, ResetEffects) == 0x0006F0, "Member 'AOrionCharAISpawner_Jungle::ResetEffects' has a wrong offset!");

// Class OrionGame.OrionAITask_FlowFieldMove
// 0x0038 (0x00A8 - 0x0070)
class UOrionAITask_FlowFieldMove final : public UAITask
{
public:
	UMulticastDelegateProperty_                   OnRequestFailed;                                   // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnMoveFinished;                                    // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_90[0x18];                                      // 0x0090(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOrionAITask_FlowFieldMove* FlowFieldMove(class AOrionAIController* Controller, bool bLockAILogic);

	void MoveTaskCompletedSignature__DelegateSignature(EPathFollowingResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAITask_FlowFieldMove">();
	}
	static class UOrionAITask_FlowFieldMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAITask_FlowFieldMove>();
	}
};
static_assert(alignof(UOrionAITask_FlowFieldMove) == 0x000008, "Wrong alignment on UOrionAITask_FlowFieldMove");
static_assert(sizeof(UOrionAITask_FlowFieldMove) == 0x0000A8, "Wrong size on UOrionAITask_FlowFieldMove");
static_assert(offsetof(UOrionAITask_FlowFieldMove, OnRequestFailed) == 0x000070, "Member 'UOrionAITask_FlowFieldMove::OnRequestFailed' has a wrong offset!");
static_assert(offsetof(UOrionAITask_FlowFieldMove, OnMoveFinished) == 0x000080, "Member 'UOrionAITask_FlowFieldMove::OnMoveFinished' has a wrong offset!");

// Class OrionGame.OrionAITask_MoveTo
// 0x0000 (0x0110 - 0x0110)
class UOrionAITask_MoveTo final : public UAITask_MoveTo
{
public:
	static class UAITask_MoveTo* OrionGraphAIMoveTo(class AAIController* Controller, const struct FVector& GoalLocation, class AActor* GoalActor, float AcceptanceRadius, EAIOptionFlag StopOnOverlap, EAIOptionFlag AcceptPartialPath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAITask_MoveTo">();
	}
	static class UOrionAITask_MoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAITask_MoveTo>();
	}
};
static_assert(alignof(UOrionAITask_MoveTo) == 0x000008, "Wrong alignment on UOrionAITask_MoveTo");
static_assert(sizeof(UOrionAITask_MoveTo) == 0x000110, "Wrong size on UOrionAITask_MoveTo");

// Class OrionGame.OrionStoreDisplayLibrary
// 0x0000 (0x0028 - 0x0028)
class UOrionStoreDisplayLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void GetStorefrontDisplayInfo(EOrionStoreFront Storefront, struct FOrionStorefrontInfo* StorefrontInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionStoreDisplayLibrary">();
	}
	static class UOrionStoreDisplayLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionStoreDisplayLibrary>();
	}
};
static_assert(alignof(UOrionStoreDisplayLibrary) == 0x000008, "Wrong alignment on UOrionStoreDisplayLibrary");
static_assert(sizeof(UOrionStoreDisplayLibrary) == 0x000028, "Wrong size on UOrionStoreDisplayLibrary");

// Class OrionGame.OrionAIWaypoint
// 0x0008 (0x0320 - 0x0318)
class AOrionAIWaypoint final : public AActor
{
public:
	class AOrionDamageableObjective_Base*         GoalActor;                                         // 0x0318(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAIWaypoint">();
	}
	static class AOrionAIWaypoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionAIWaypoint>();
	}
};
static_assert(alignof(AOrionAIWaypoint) == 0x000008, "Wrong alignment on AOrionAIWaypoint");
static_assert(sizeof(AOrionAIWaypoint) == 0x000320, "Wrong size on AOrionAIWaypoint");
static_assert(offsetof(AOrionAIWaypoint, GoalActor) == 0x000318, "Member 'AOrionAIWaypoint::GoalActor' has a wrong offset!");

// Class OrionGame.OrionCheatManagerGame
// 0x0020 (0x00E0 - 0x00C0)
class UOrionCheatManagerGame final : public UOrionCheatManagerBase
{
public:
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayEffect*                        LastAppliedGameplayEffect;                         // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x10];                                      // 0x00D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAfkPeriod(int32 NewAfkPeriod);
	void AddBotEnemy(const class FString& DataAssetName);
	void AddBotFriend(const class FString& DataAssetName);
	void AddTag(const class FString& TagName);
	void AI_AttackNow();
	void AllowCardMenuAnywhere(int32 Enable);
	void ApplyGameplayEffectToCharacter(const class FString& CharacterObjectName, const class FString& GameplayEffectName, float Level);
	void ApplyGameplayEffectToSelf(const class FString& GameplayEffectName, float Level);
	void BadAss(int32 State);
	void CoreUnlimitedHealth(int32 State);
	void DamageSelf(float DamageAmount);
	void DestroyAllNonPlayerPawns();
	void DestroyAllPlaceableObjects();
	void DisableRework(const class FString& HeroName);
	void DisplayFacialPreview();
	void DrawDamageNumbers(bool bDrawNumbers);
	void DumpGameStats(const class FString& FilterName);
	void EnableFixedTimeStep(int32 AsIfItWasFPS);
	void EnableRework(const class FString& HeroName);
	void EndSurrenderVoteTimer(uint8 TeamNum);
	void ExecuteOrionDevMenuHistory(int32 Idx);
	void FillWithBots(int32 BotsToAddToEachTeam, const class FString& HeroList);
	void ForceAISpawnerStartingLevelTo(int32 Level);
	void ForceAllPlayersToLevel(int32 Level);
	void ForceAllPlayersToMaxLevel();
	void ForceBotDifficulty(const class FString& DifficultyName);
	void ForceBotLane(int32 LaneIndex);
	void ForceEndgame(int32 TeamNumber, int32 MoveDoomedTeamSpawnPoints);
	void ForceEquipCard(int32 Slot, const class FString& CardName, int32 CardLevel);
	void ForceEquipCardForAll(int32 Slot, const class FString& CardName, int32 CardLevel);
	void ForceLossScreen();
	void ForcePlayerMaxLevel();
	void ForcePlayerToMaxStats();
	void ForcePlayerToMinStats();
	void ForceRefineryFill(int32 Amount);
	void ForceRefineryFillForTeam(int32 TeamNumber, int32 Amount);
	void ForceRoundStart();
	void ForceSpawnPrimeHelix();
	void ForceVictoryScreen();
	void ForceWinMatch(uint8 WinningTeamNum, int32 NumSeconds);
	void GiveGold(int32 Gold);
	void GiveTeamXP(int32 TeamIndex, int32 XP);
	void GiveXP(int32 XP);
	void God();
	void HealSelf(float HealAmount);
	void HideAFKWarning();
	void HideHeroSelect();
	void HideMatchInfoText();
	void HideVictoryScreen();
	void InterruptCurrentAbility();
	void InvertMouse();
	void KillAI(int32 DisableAISpawning);
	void KillAllNonPlayerPawns();
	void KillJungleAI();
	void KillMinionAI();
	void KillTeamBots(int32 TeamIndex);
	void KnockbackSelf(float Distance);
	void KnockupSelf(float Distance);
	void ListAvailableHeroes();
	void ModifyMaxMoveSpeed(float MoveAmount);
	void NextHero();
	void OrionDevMenu();
	void PauseAI();
	void PlayAmbientEventWithId(const class FString& EventID);
	void PrintAbilitySystemComponent();
	void PrintBotDifficulty();
	void RemoveCooldowns(int32 State);
	void RemoveCosts(int32 State);
	void RemoveGameplayEffectFromCharacter(const class FString& CharacterObjectName, const class FString& GameplayEffectName);
	void RemoveGameplayEffectFromSelf(const class FString& GameplayEffectName);
	void RemoveGameplayEffectLastApplied();
	void RemoveRespawnTime(int32 State);
	void RemoveRespawnTimeAll(int32 State);
	void RemoveTag(const class FString& TagName);
	void ReselectHero();
	void ResetCards();
	void ResetCooldowns();
	void ResetSurrenderVoteCooldown(uint8 TeamNum);
	void ResumeAI();
	void SetAllAbilityLevels(int32 NewLevel);
	void SetAllMinionWaveData(const class FString& DataAssetName);
	void SetEnemyMinionWaveData(const class FString& DataAssetName);
	void SetEnergyPercent(float NewPercent);
	void SetFriendlyMinionWaveData(const class FString& DataAssetName);
	void SetHealthPercent(float NewPercent);
	void SetHero(const class FString& HeroName);
	void SetHeroStat(const class FString& HeroName, const class FString& StatName, int32 Amount);
	void SetMinionTeamDifficulty(int32 TeamIndex, const class FString& DifficultyName);
	void SetMouseSensitivityToDefault();
	void SetMyAbilityLevels(int32 NewLevel);
	void SetPlayerDeckInstance(const class FString& DeckName);
	void SetPlayerPosition(EOrionPosition Position);
	void SetPlayerStat(const class FString& StatName, int32 Amount);
	void SetShouldAbortMatchStartWhenPlayersMissing(bool bShouldAbort, bool bShouldPenalize);
	void SetTeamNum(int32 TeamIndex);
	void SetVisionManagerDebug(uint8 DebugMode, uint8 Filter, int32 FilterIndex, int32 SingleFilterType);
	void ShieldSelf(float ShieldAmount);
	void ShowAFKWarning();
	void ShowMatchInfoText(const class FString& Text);
	void SimulateCheatDetected(bool bRevokeAuthToken, bool bKickFromMatch, const class FString& ReasonStr);
	void SkipMatinee();
	void SpawnCreepMinion(const class FString& DataAssetName);
	void SpawnCreepMinionAtPos(const class FString& DataAssetName, float X, float Y, float Z);
	void SpawnCreepMinionAtPosAndRotation(const class FString& DataAssetName, float X, float Y, float Z, float InVerticalRotation);
	void SpawnEnemyHero(const class FString& DataAssetName);
	void SpawnEnemyHeroAtPos(const class FString& DataAssetName, float X, float Y, float Z);
	void SpawnEnemyHeroAtPosAndRotation(const class FString& DataAssetName, float X, float Y, float Z, float InVerticalRotation, bool bWithBotController);
	void SpawnEnemyHeroWithSkinAtPosAndRotation(const class FString& DataAssetName, const class FString& SkinName, float X, float Y, float Z, float InVerticalRotation, bool bWithBotController);
	void SpawnEnemyMinion(const class FString& DataAssetName);
	void SpawnEnemyMinionAtPos(const class FString& DataAssetName, float X, float Y, float Z);
	void SpawnEnemyMinionAtPosAndRotation(const class FString& DataAssetName, float X, float Y, float Z, float InVerticalRotation);
	void SpawnFriendlyHero(const class FString& DataAssetName);
	void SpawnFriendlyHeroAtPos(const class FString& DataAssetName, float X, float Y, float Z);
	void SpawnFriendlyHeroAtPosAndRotation(const class FString& DataAssetName, float X, float Y, float Z, float InVerticalRotation);
	void SpawnFriendlyHeroWithSkinAtPosAndRotation(const class FString& DataAssetName, const class FString& SkinName, float X, float Y, float Z, float InVerticalRotation);
	void SpawnFriendlyMinion(const class FString& DataAssetName);
	void SpawnFriendlyMinionAtPos(const class FString& DataAssetName, float X, float Y, float Z);
	void SpawnFriendlyMinionAtPosAndRotation(const class FString& DataAssetName, float X, float Y, float Z, float InVerticalRotation);
	void SpawnTargetDummyHero(const class FString& DataAssetName);
	void SpawnTargetDummyHeroAtPos(const class FString& DataAssetName, float X, float Y, float Z);
	void SpawnTargetDummyHeroAtPosAndRotation(const class FString& DataAssetName, float X, float Y, float Z, float InVerticalRotation);
	void StopCoinSpawning(int32 Value);
	void SurrenderVote(bool bVoteYes, int32 Reason);
	void ToggleAbilityLevelEnforcement();
	void ToggleAbilityWidgets();
	void ToggleAIAttack();
	void ToggleAIWaveSpawning();
	void ToggleBotsGod();
	void ToggleDamageLog();
	void ToggleDebugXP();
	void ToggleEnableRootMotionSources();
	void ToggleEnemyInfoWidget();
	void ToggleFixedCamera();
	void ToggleHealthAndStatusWidget();
	void ToggleIndicatorWidgets();
	void ToggleIsUsingGamepad();
	void ToggleJuggernaut();
	void ToggleLimbo();
	void ToggleMiniMapWidget();
	void ToggleOverheadHealth();
	void ToggleRoot();
	void ToggleScoreboardUpdating();
	void ToggleSilence();
	void ToggleStun();
	void ToggleStunStressTest(float Duration);
	void ToggleTeamInfoWidget();
	void ToggleUnselectable();
	void TowerGod(bool bTowerGod);
	void TravelModeMode(int32 NewValue);
	void UnlimitedHealth(int32 State);
	void VisionManagerDebugLog();
	void VLogAIEvent(const class FString& EventLabel);
	void WhyItemsBroke();
	void WhyStuck();
	void WhyTargetingBroken(float DebugDuration);
	void WTF(int32 Enable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCheatManagerGame">();
	}
	static class UOrionCheatManagerGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionCheatManagerGame>();
	}
};
static_assert(alignof(UOrionCheatManagerGame) == 0x000008, "Wrong alignment on UOrionCheatManagerGame");
static_assert(sizeof(UOrionCheatManagerGame) == 0x0000E0, "Wrong size on UOrionCheatManagerGame");
static_assert(offsetof(UOrionCheatManagerGame, LastAppliedGameplayEffect) == 0x0000C8, "Member 'UOrionCheatManagerGame::LastAppliedGameplayEffect' has a wrong offset!");

// Class OrionGame.OrionAmbientEventComponent
// 0x0000 (0x0108 - 0x0108)
class UOrionAmbientEventComponent final : public UAmbientEventComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAmbientEventComponent">();
	}
	static class UOrionAmbientEventComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAmbientEventComponent>();
	}
};
static_assert(alignof(UOrionAmbientEventComponent) == 0x000008, "Wrong alignment on UOrionAmbientEventComponent");
static_assert(sizeof(UOrionAmbientEventComponent) == 0x000108, "Wrong size on UOrionAmbientEventComponent");

// Class OrionGame.OrionAmbientEventScheduler_MOBA
// 0x0010 (0x03D8 - 0x03C8)
class AOrionAmbientEventScheduler_MOBA final : public AAmbientEventScheduler
{
public:
	uint8                                         Pad_3C8[0x10];                                     // 0x03C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FireIntroEventCues(class AOrionCharHero* LocalHero);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAmbientEventScheduler_MOBA">();
	}
	static class AOrionAmbientEventScheduler_MOBA* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionAmbientEventScheduler_MOBA>();
	}
};
static_assert(alignof(AOrionAmbientEventScheduler_MOBA) == 0x000008, "Wrong alignment on AOrionAmbientEventScheduler_MOBA");
static_assert(sizeof(AOrionAmbientEventScheduler_MOBA) == 0x0003D8, "Wrong size on AOrionAmbientEventScheduler_MOBA");

// Class OrionGame.OrionAnalytics
// 0x0000 (0x0028 - 0x0028)
class UOrionAnalytics final : public UBlueprintFunctionLibrary
{
public:
	static void FireEvent_InitialLoadComplete(class UUserWidget* UserContext);
	static void FireEvent_ModifiedSettings(class UUserWidget* UserContext, const class UOrionGameUserSettings* UserSettings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAnalytics">();
	}
	static class UOrionAnalytics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAnalytics>();
	}
};
static_assert(alignof(UOrionAnalytics) == 0x000008, "Wrong alignment on UOrionAnalytics");
static_assert(sizeof(UOrionAnalytics) == 0x000028, "Wrong size on UOrionAnalytics");

// Class OrionGame.OrionCharHero
// 0x06B0 (0x11A0 - 0x0AF0)
class AOrionCharHero : public AOrionChar
{
public:
	uint8                                         Pad_AF0[0x10];                                     // 0x0AF0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionEnergySet*                        EnergySetRef;                                      // 0x0B00(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionGameplaySet*                      GameplaySetRef;                                    // 0x0B08(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOrion2DReticleSourceData>      ReticleMaterialData;                               // 0x0B10(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FOrion2DReticleSourceData              InstigatedDamageReticleData;                       // 0x0B20(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LastInstigatedDamageNotifyTime;                    // 0x0B38(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B3C[0x4];                                      // 0x0B3C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             AudioDeath;                                        // 0x0B40(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             AudioTravelIdle;                                   // 0x0B48(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             AudioTravelMove;                                   // 0x0B50(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             AudioMoveNormalIdle;                               // 0x0B58(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             AudioMoveNormalMove;                               // 0x0B60(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             AudioMoveCue;                                      // 0x0B68(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementFadeTime;                                  // 0x0B70(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B74[0x4];                                      // 0x0B74(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AudioMoveParamName;                                // 0x0B78(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioTravelModeParamName;                          // 0x0B80(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOrionTagTranslate>             GamplayTagTranslation;                             // 0x0B88(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         PercentSmallPain;                                  // 0x0B98(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9C[0x4];                                      // 0x0B9C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             AudioSmallPain;                                    // 0x0BA0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PercentLargePain;                                  // 0x0BA8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BAC[0x4];                                      // 0x0BAC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             AudioLargePain;                                    // 0x0BB0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionCharReplicatedStatus             ReplicatedStatusInfo;                              // 0x0BB8(0x0020)(Net, RepNotify, NativeAccessSpecifierPublic)
	bool                                          DisplayReticleByDefault;                           // 0x0BD8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BD9[0x117];                                    // 0x0BD9(0x0117)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOrionLandingEffectEntry>       LandingGameplayCues;                               // 0x0CF0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bTriggerLandingGCsInTravelMode;                    // 0x0D00(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipNextLandingGC;                                // 0x0D01(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScaleLandingMinImpactSpeedByCharacterDownwardGravity; // 0x0D02(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D03[0x5];                                      // 0x0D03(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           DeathAnim;                                         // 0x0D08(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   RecallAnim;                                        // 0x0D10(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UAnimMontage*                           RecallFinishedAnim;                                // 0x0D20(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FirstSpawnAnim;                                    // 0x0D28(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           RespawnAnim;                                       // 0x0D30(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           EmoteTauntAnim;                                    // 0x0D38(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           VictoryAnim;                                       // 0x0D40(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           JumpPadAnim;                                       // 0x0D48(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ItemSlotUsedAnim;                                  // 0x0D50(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseFixedSkeletalBounds;                           // 0x0D58(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFreeCameraRotationActive;                         // 0x0D59(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D5A[0x2];                                      // 0x0D5A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseLookYawRate;                                   // 0x0D5C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseLookPitchRate;                                 // 0x0D60(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D64[0x4];                                      // 0x0D64(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     DeathMaterial;                                     // 0x0D68(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DeathMaterialParameterName;                        // 0x0D70(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            CharacterMaterialFadeCurve;                        // 0x0D78(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DeathMaterialFadeCurve;                            // 0x0D80(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOrion2DReticle>                ReticleDynamicMaterial;                            // 0x0D88(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	struct FOrion2DReticle                        InstigatedDamageReticle;                           // 0x0D98(0x0018)(Edit, BlueprintVisible, DisableEditOnTemplate, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSkinChoices                           CurrentSkinChoices;                                // 0x0DB0(0x0018)(Net, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UOrionSkinItemDefinition*               PreviewSkin;                                       // 0x0DC8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DefaultAbilityStartSocket;                         // 0x0DD0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AGameplayAbilityTargetActor> DefaultTargetActorClass;                           // 0x0DD8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FOrionAbilityTargetDataFilter          DefaultTargetDataFilter;                           // 0x0DE0(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UAmbientEventComponent*                 AmbientEventComponent;                             // 0x0E10(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioCurveSourceComponent*             FacialAnimationComponent;                          // 0x0E18(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionCameraComponent*                  CameraComponent;                                   // 0x0E20(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionCameraComponent_DeathCam*         DeathCamCameraComponent;                           // 0x0E28(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E30[0x10];                                     // 0x0E30(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionHeroDialogAudioControl           HeroDialogControl;                                 // 0x0E40(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EC0[0x20];                                     // 0x0EC0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         BitPad_EE0_0 : 3;                                  // 0x0EE0(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bIsInTravelMode : 1;                               // 0x0EE0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_EE1[0x7];                                      // 0x0EE1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTexture*>                       TexturesForcedToBeResident;                        // 0x0EE8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EF8[0x8];                                      // 0x0EF8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionCharDeathData                    DeathData;                                         // 0x0F00(0x0018)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F18[0x18];                                     // 0x0F18(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               DeathEffectMID;                                    // 0x0F30(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EOrionHeroMovementProfile                     HeroDefaultMovementProfile;                        // 0x0F38(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionHeroMovementProfile                     HeroTravelModeMovementProfile;                     // 0x0F39(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F3A[0x2];                                      // 0x0F3A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CharacterVisiblityThreshold;                       // 0x0F3C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionHeroMovementProfile                     CurrentMovementProfile;                            // 0x0F40(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F41[0x257];                                    // 0x0F41(0x0257)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionReplicatedAcceleration           OrionReplicatedAcceleration;                       // 0x1198(0x0002)(Net, Transient, IsPlainOldData, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_119A[0x6];                                     // 0x119A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplySkinToMesh(class USkeletalMeshComponent* MeshToApplySkinTo, const class UOrionSkinVariationItemDefinition* SkinVariation);
	void DrawReticle(const struct FOrion2DReticle& ReticleMaterial);
	void DrawReticle_Setup(class UCanvas* Canvas, class AOrionUI_Base* CallingUI);
	void DrawReticleByIndex(int32 ReticleIndex);
	void GameplayCue_Damage(EGameplayCueEvent EventType, const struct FGameplayCueParameters& Parameters);
	class UOrionMcpCrownItemDefinition* GetCurrentCrown();
	class UOrionSkinItemDefinition* GetCurrentSkin();
	class UOrionSkinVariationItemDefinition* GetCurrentSkinVariation();
	void GetDecalAttachmentBone(class FName DecalName, class FName* Out_AttachmentBoneName);
	void GetDecalFudgeFactor(class FName DecalName, struct FVector* Out_FudgeFactorScaleVec);
	struct FRecordedIntervalsData GetLerpedRewindData(float AlphaFactor, float TotalSeconds, bool bGetTweenedValueOnInitialTime, float* OutTotalAmountMoved);
	struct FRecordedIntervalsData GetRewindData(float NumSeconds, bool bGetTweenedValues);
	struct FVector GetRewindPosition(float NumSeconds, bool bGetTweenedValues);
	void HeroMovementUpdated(float DeltaSeconds, const struct FVector& OldLocation, const struct FVector& OldVelocity);
	void HideReticle();
	void OnCrownReady();
	void OnDeathAnimFinished();
	void OnDeathMaterialFadeTick();
	void OnMeshReady();
	void OnRep_CurrentSkinChoices();
	void OnRep_DeathData();
	void OnRep_OrionReplicatedAcceleration();
	void OnRep_StatusInfo();
	void OnRep_UseFixedSkeletalBounds();
	void RequestServerRewind(float NumSeconds);
	void ReticleMaterialTick(class UCanvas* Canvas, class AOrionUI_Base* CallingUI);
	void SetSkipNextLandingGC(bool bSkip);
	void ShowReticle();
	class AGameplayAbilityTargetActor* SpawnDefaultTargetActor();
	bool TestActivateBanner(bool bUseRandomProto, bool bUseDefaultProto);
	bool TestActivateGraveMarker(bool bForEnemy);
	void UpdateDamageInstigatedTime();

	struct FVector GetBaseAimLocation() const;
	float GetEnergy() const;
	float GetEnergyPercent() const;
	float GetEnergyRegen() const;
	float GetMaxEnergy() const;
	bool IsDecoy() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCharHero">();
	}
	static class AOrionCharHero* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionCharHero>();
	}
};
static_assert(alignof(AOrionCharHero) == 0x000010, "Wrong alignment on AOrionCharHero");
static_assert(sizeof(AOrionCharHero) == 0x0011A0, "Wrong size on AOrionCharHero");
static_assert(offsetof(AOrionCharHero, EnergySetRef) == 0x000B00, "Member 'AOrionCharHero::EnergySetRef' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, GameplaySetRef) == 0x000B08, "Member 'AOrionCharHero::GameplaySetRef' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, ReticleMaterialData) == 0x000B10, "Member 'AOrionCharHero::ReticleMaterialData' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, InstigatedDamageReticleData) == 0x000B20, "Member 'AOrionCharHero::InstigatedDamageReticleData' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, LastInstigatedDamageNotifyTime) == 0x000B38, "Member 'AOrionCharHero::LastInstigatedDamageNotifyTime' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, AudioDeath) == 0x000B40, "Member 'AOrionCharHero::AudioDeath' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, AudioTravelIdle) == 0x000B48, "Member 'AOrionCharHero::AudioTravelIdle' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, AudioTravelMove) == 0x000B50, "Member 'AOrionCharHero::AudioTravelMove' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, AudioMoveNormalIdle) == 0x000B58, "Member 'AOrionCharHero::AudioMoveNormalIdle' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, AudioMoveNormalMove) == 0x000B60, "Member 'AOrionCharHero::AudioMoveNormalMove' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, AudioMoveCue) == 0x000B68, "Member 'AOrionCharHero::AudioMoveCue' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, MovementFadeTime) == 0x000B70, "Member 'AOrionCharHero::MovementFadeTime' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, AudioMoveParamName) == 0x000B78, "Member 'AOrionCharHero::AudioMoveParamName' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, AudioTravelModeParamName) == 0x000B80, "Member 'AOrionCharHero::AudioTravelModeParamName' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, GamplayTagTranslation) == 0x000B88, "Member 'AOrionCharHero::GamplayTagTranslation' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, PercentSmallPain) == 0x000B98, "Member 'AOrionCharHero::PercentSmallPain' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, AudioSmallPain) == 0x000BA0, "Member 'AOrionCharHero::AudioSmallPain' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, PercentLargePain) == 0x000BA8, "Member 'AOrionCharHero::PercentLargePain' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, AudioLargePain) == 0x000BB0, "Member 'AOrionCharHero::AudioLargePain' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, ReplicatedStatusInfo) == 0x000BB8, "Member 'AOrionCharHero::ReplicatedStatusInfo' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, DisplayReticleByDefault) == 0x000BD8, "Member 'AOrionCharHero::DisplayReticleByDefault' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, LandingGameplayCues) == 0x000CF0, "Member 'AOrionCharHero::LandingGameplayCues' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, bTriggerLandingGCsInTravelMode) == 0x000D00, "Member 'AOrionCharHero::bTriggerLandingGCsInTravelMode' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, bSkipNextLandingGC) == 0x000D01, "Member 'AOrionCharHero::bSkipNextLandingGC' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, bScaleLandingMinImpactSpeedByCharacterDownwardGravity) == 0x000D02, "Member 'AOrionCharHero::bScaleLandingMinImpactSpeedByCharacterDownwardGravity' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, DeathAnim) == 0x000D08, "Member 'AOrionCharHero::DeathAnim' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, RecallAnim) == 0x000D10, "Member 'AOrionCharHero::RecallAnim' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, RecallFinishedAnim) == 0x000D20, "Member 'AOrionCharHero::RecallFinishedAnim' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, FirstSpawnAnim) == 0x000D28, "Member 'AOrionCharHero::FirstSpawnAnim' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, RespawnAnim) == 0x000D30, "Member 'AOrionCharHero::RespawnAnim' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, EmoteTauntAnim) == 0x000D38, "Member 'AOrionCharHero::EmoteTauntAnim' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, VictoryAnim) == 0x000D40, "Member 'AOrionCharHero::VictoryAnim' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, JumpPadAnim) == 0x000D48, "Member 'AOrionCharHero::JumpPadAnim' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, ItemSlotUsedAnim) == 0x000D50, "Member 'AOrionCharHero::ItemSlotUsedAnim' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, bUseFixedSkeletalBounds) == 0x000D58, "Member 'AOrionCharHero::bUseFixedSkeletalBounds' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, bFreeCameraRotationActive) == 0x000D59, "Member 'AOrionCharHero::bFreeCameraRotationActive' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, BaseLookYawRate) == 0x000D5C, "Member 'AOrionCharHero::BaseLookYawRate' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, BaseLookPitchRate) == 0x000D60, "Member 'AOrionCharHero::BaseLookPitchRate' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, DeathMaterial) == 0x000D68, "Member 'AOrionCharHero::DeathMaterial' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, DeathMaterialParameterName) == 0x000D70, "Member 'AOrionCharHero::DeathMaterialParameterName' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, CharacterMaterialFadeCurve) == 0x000D78, "Member 'AOrionCharHero::CharacterMaterialFadeCurve' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, DeathMaterialFadeCurve) == 0x000D80, "Member 'AOrionCharHero::DeathMaterialFadeCurve' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, ReticleDynamicMaterial) == 0x000D88, "Member 'AOrionCharHero::ReticleDynamicMaterial' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, InstigatedDamageReticle) == 0x000D98, "Member 'AOrionCharHero::InstigatedDamageReticle' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, CurrentSkinChoices) == 0x000DB0, "Member 'AOrionCharHero::CurrentSkinChoices' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, PreviewSkin) == 0x000DC8, "Member 'AOrionCharHero::PreviewSkin' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, DefaultAbilityStartSocket) == 0x000DD0, "Member 'AOrionCharHero::DefaultAbilityStartSocket' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, DefaultTargetActorClass) == 0x000DD8, "Member 'AOrionCharHero::DefaultTargetActorClass' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, DefaultTargetDataFilter) == 0x000DE0, "Member 'AOrionCharHero::DefaultTargetDataFilter' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, AmbientEventComponent) == 0x000E10, "Member 'AOrionCharHero::AmbientEventComponent' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, FacialAnimationComponent) == 0x000E18, "Member 'AOrionCharHero::FacialAnimationComponent' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, CameraComponent) == 0x000E20, "Member 'AOrionCharHero::CameraComponent' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, DeathCamCameraComponent) == 0x000E28, "Member 'AOrionCharHero::DeathCamCameraComponent' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, HeroDialogControl) == 0x000E40, "Member 'AOrionCharHero::HeroDialogControl' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, TexturesForcedToBeResident) == 0x000EE8, "Member 'AOrionCharHero::TexturesForcedToBeResident' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, DeathData) == 0x000F00, "Member 'AOrionCharHero::DeathData' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, DeathEffectMID) == 0x000F30, "Member 'AOrionCharHero::DeathEffectMID' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, HeroDefaultMovementProfile) == 0x000F38, "Member 'AOrionCharHero::HeroDefaultMovementProfile' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, HeroTravelModeMovementProfile) == 0x000F39, "Member 'AOrionCharHero::HeroTravelModeMovementProfile' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, CharacterVisiblityThreshold) == 0x000F3C, "Member 'AOrionCharHero::CharacterVisiblityThreshold' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, CurrentMovementProfile) == 0x000F40, "Member 'AOrionCharHero::CurrentMovementProfile' has a wrong offset!");
static_assert(offsetof(AOrionCharHero, OrionReplicatedAcceleration) == 0x001198, "Member 'AOrionCharHero::OrionReplicatedAcceleration' has a wrong offset!");

// Class OrionGame.OrionCharHero_Decoy
// 0x0050 (0x11F0 - 0x11A0)
class AOrionCharHero_Decoy final : public AOrionCharHero
{
public:
	class AOrionCharHero*                         OrionCharHeroSpawner;                              // 0x11A0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionVisionDef*                        VisionDataOverride;                                // 0x11A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           DecoyTag;                                          // 0x11B0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11B8[0x38];                                    // 0x11B8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class UMeshComponent*> GetHighlightableMeshes();
	void OnRep_OrionCharHeroSpawner();
	void OnRep_StatusInfo();

	bool IsDecoy() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCharHero_Decoy">();
	}
	static class AOrionCharHero_Decoy* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionCharHero_Decoy>();
	}
};
static_assert(alignof(AOrionCharHero_Decoy) == 0x000010, "Wrong alignment on AOrionCharHero_Decoy");
static_assert(sizeof(AOrionCharHero_Decoy) == 0x0011F0, "Wrong size on AOrionCharHero_Decoy");
static_assert(offsetof(AOrionCharHero_Decoy, OrionCharHeroSpawner) == 0x0011A0, "Member 'AOrionCharHero_Decoy::OrionCharHeroSpawner' has a wrong offset!");
static_assert(offsetof(AOrionCharHero_Decoy, VisionDataOverride) == 0x0011A8, "Member 'AOrionCharHero_Decoy::VisionDataOverride' has a wrong offset!");
static_assert(offsetof(AOrionCharHero_Decoy, DecoyTag) == 0x0011B0, "Member 'AOrionCharHero_Decoy::DecoyTag' has a wrong offset!");

// Class OrionGame.OrionAnimInstanceDamageableCore
// 0x0028 (0x03E0 - 0x03B8)
class UOrionAnimInstanceDamageableCore : public UAnimInstance
{
public:
	bool                                          bCoreExposed;                                      // 0x03B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B9[0x3];                                      // 0x03B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LookAtPoint;                                       // 0x03BC(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtAndLayeredBlendAlpha;                        // 0x03C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PyramidPlayRate;                                   // 0x03CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtAlphaInterpSpeed;                            // 0x03D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtVectorInterpSpeed;                           // 0x03D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D8[0x8];                                      // 0x03D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAnimInstanceDamageableCore">();
	}
	static class UOrionAnimInstanceDamageableCore* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAnimInstanceDamageableCore>();
	}
};
static_assert(alignof(UOrionAnimInstanceDamageableCore) == 0x000008, "Wrong alignment on UOrionAnimInstanceDamageableCore");
static_assert(sizeof(UOrionAnimInstanceDamageableCore) == 0x0003E0, "Wrong size on UOrionAnimInstanceDamageableCore");
static_assert(offsetof(UOrionAnimInstanceDamageableCore, bCoreExposed) == 0x0003B8, "Member 'UOrionAnimInstanceDamageableCore::bCoreExposed' has a wrong offset!");
static_assert(offsetof(UOrionAnimInstanceDamageableCore, LookAtPoint) == 0x0003BC, "Member 'UOrionAnimInstanceDamageableCore::LookAtPoint' has a wrong offset!");
static_assert(offsetof(UOrionAnimInstanceDamageableCore, LookAtAndLayeredBlendAlpha) == 0x0003C8, "Member 'UOrionAnimInstanceDamageableCore::LookAtAndLayeredBlendAlpha' has a wrong offset!");
static_assert(offsetof(UOrionAnimInstanceDamageableCore, PyramidPlayRate) == 0x0003CC, "Member 'UOrionAnimInstanceDamageableCore::PyramidPlayRate' has a wrong offset!");
static_assert(offsetof(UOrionAnimInstanceDamageableCore, LookAtAlphaInterpSpeed) == 0x0003D0, "Member 'UOrionAnimInstanceDamageableCore::LookAtAlphaInterpSpeed' has a wrong offset!");
static_assert(offsetof(UOrionAnimInstanceDamageableCore, LookAtVectorInterpSpeed) == 0x0003D4, "Member 'UOrionAnimInstanceDamageableCore::LookAtVectorInterpSpeed' has a wrong offset!");

// Class OrionGame.OrionAnimInstanceDamageableCoreRings
// 0x0008 (0x0420 - 0x0418)
class UOrionAnimInstanceDamageableCoreRings final : public UOrionAnimInstance
{
public:
	bool                                          bCoreExposed;                                      // 0x0418(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_419[0x7];                                      // 0x0419(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAnimInstanceDamageableCoreRings">();
	}
	static class UOrionAnimInstanceDamageableCoreRings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAnimInstanceDamageableCoreRings>();
	}
};
static_assert(alignof(UOrionAnimInstanceDamageableCoreRings) == 0x000008, "Wrong alignment on UOrionAnimInstanceDamageableCoreRings");
static_assert(sizeof(UOrionAnimInstanceDamageableCoreRings) == 0x000420, "Wrong size on UOrionAnimInstanceDamageableCoreRings");
static_assert(offsetof(UOrionAnimInstanceDamageableCoreRings, bCoreExposed) == 0x000418, "Member 'UOrionAnimInstanceDamageableCoreRings::bCoreExposed' has a wrong offset!");

// Class OrionGame.OrionNavMeshSubdivisionVolume
// 0x0000 (0x0360 - 0x0360)
class AOrionNavMeshSubdivisionVolume final : public ANavModifierVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionNavMeshSubdivisionVolume">();
	}
	static class AOrionNavMeshSubdivisionVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionNavMeshSubdivisionVolume>();
	}
};
static_assert(alignof(AOrionNavMeshSubdivisionVolume) == 0x000008, "Wrong alignment on AOrionNavMeshSubdivisionVolume");
static_assert(sizeof(AOrionNavMeshSubdivisionVolume) == 0x000360, "Wrong size on AOrionNavMeshSubdivisionVolume");

// Class OrionGame.OrionAnimMotionRecorder
// 0x0000 (0x0028 - 0x0028)
class UOrionAnimMotionRecorder final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAnimMotionRecorder">();
	}
	static class UOrionAnimMotionRecorder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAnimMotionRecorder>();
	}
};
static_assert(alignof(UOrionAnimMotionRecorder) == 0x000008, "Wrong alignment on UOrionAnimMotionRecorder");
static_assert(sizeof(UOrionAnimMotionRecorder) == 0x000028, "Wrong size on UOrionAnimMotionRecorder");

// Class OrionGame.OrionAnimNotify_AbilityNotify
// 0x0008 (0x0040 - 0x0038)
class UOrionAnimNotify_AbilityNotify final : public UAnimNotify
{
public:
	class FName                                   AbilityNotifyName;                                 // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAnimNotify_AbilityNotify">();
	}
	static class UOrionAnimNotify_AbilityNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAnimNotify_AbilityNotify>();
	}
};
static_assert(alignof(UOrionAnimNotify_AbilityNotify) == 0x000008, "Wrong alignment on UOrionAnimNotify_AbilityNotify");
static_assert(sizeof(UOrionAnimNotify_AbilityNotify) == 0x000040, "Wrong size on UOrionAnimNotify_AbilityNotify");
static_assert(offsetof(UOrionAnimNotify_AbilityNotify, AbilityNotifyName) == 0x000038, "Member 'UOrionAnimNotify_AbilityNotify::AbilityNotifyName' has a wrong offset!");

// Class OrionGame.OrionAnimNotify_AbilityNotifyWindow
// 0x0008 (0x0038 - 0x0030)
class UOrionAnimNotify_AbilityNotifyWindow final : public UAnimNotifyState
{
public:
	class FName                                   AbilityNotifyName;                                 // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAnimNotify_AbilityNotifyWindow">();
	}
	static class UOrionAnimNotify_AbilityNotifyWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAnimNotify_AbilityNotifyWindow>();
	}
};
static_assert(alignof(UOrionAnimNotify_AbilityNotifyWindow) == 0x000008, "Wrong alignment on UOrionAnimNotify_AbilityNotifyWindow");
static_assert(sizeof(UOrionAnimNotify_AbilityNotifyWindow) == 0x000038, "Wrong size on UOrionAnimNotify_AbilityNotifyWindow");
static_assert(offsetof(UOrionAnimNotify_AbilityNotifyWindow, AbilityNotifyName) == 0x000030, "Member 'UOrionAnimNotify_AbilityNotifyWindow::AbilityNotifyName' has a wrong offset!");

// Class OrionGame.OrionAnimNotify_Footstep
// 0x00B8 (0x00F0 - 0x0038)
class UOrionAnimNotify_Footstep : public UAnimNotify
{
public:
	class FName                                   FootBoneName;                                      // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSkipTraces : 1;                                   // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreTraceMiss : 1;                              // 0x0040(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayCueTag                        FootstepGameplayCue;                               // 0x0048(0x0008)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TraceStartOffset;                                  // 0x0050(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceEndOffset;                                    // 0x0054(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x98];                                      // 0x0058(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAnimNotify_Footstep">();
	}
	static class UOrionAnimNotify_Footstep* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAnimNotify_Footstep>();
	}
};
static_assert(alignof(UOrionAnimNotify_Footstep) == 0x000008, "Wrong alignment on UOrionAnimNotify_Footstep");
static_assert(sizeof(UOrionAnimNotify_Footstep) == 0x0000F0, "Wrong size on UOrionAnimNotify_Footstep");
static_assert(offsetof(UOrionAnimNotify_Footstep, FootBoneName) == 0x000038, "Member 'UOrionAnimNotify_Footstep::FootBoneName' has a wrong offset!");
static_assert(offsetof(UOrionAnimNotify_Footstep, FootstepGameplayCue) == 0x000048, "Member 'UOrionAnimNotify_Footstep::FootstepGameplayCue' has a wrong offset!");
static_assert(offsetof(UOrionAnimNotify_Footstep, TraceStartOffset) == 0x000050, "Member 'UOrionAnimNotify_Footstep::TraceStartOffset' has a wrong offset!");
static_assert(offsetof(UOrionAnimNotify_Footstep, TraceEndOffset) == 0x000054, "Member 'UOrionAnimNotify_Footstep::TraceEndOffset' has a wrong offset!");

// Class OrionGame.OrionAnimNotify_GameplayCue
// 0x0018 (0x0050 - 0x0038)
class UOrionAnimNotify_GameplayCue final : public UAnimNotify
{
public:
	struct FGameplayCueTag                        Cue;                                               // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayCue;                                       // 0x0040(0x0008)(BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VolumeMultiplier;                                  // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PitchMultiplier;                                   // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAnimNotify_GameplayCue">();
	}
	static class UOrionAnimNotify_GameplayCue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAnimNotify_GameplayCue>();
	}
};
static_assert(alignof(UOrionAnimNotify_GameplayCue) == 0x000008, "Wrong alignment on UOrionAnimNotify_GameplayCue");
static_assert(sizeof(UOrionAnimNotify_GameplayCue) == 0x000050, "Wrong size on UOrionAnimNotify_GameplayCue");
static_assert(offsetof(UOrionAnimNotify_GameplayCue, Cue) == 0x000038, "Member 'UOrionAnimNotify_GameplayCue::Cue' has a wrong offset!");
static_assert(offsetof(UOrionAnimNotify_GameplayCue, GameplayCue) == 0x000040, "Member 'UOrionAnimNotify_GameplayCue::GameplayCue' has a wrong offset!");
static_assert(offsetof(UOrionAnimNotify_GameplayCue, VolumeMultiplier) == 0x000048, "Member 'UOrionAnimNotify_GameplayCue::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(UOrionAnimNotify_GameplayCue, PitchMultiplier) == 0x00004C, "Member 'UOrionAnimNotify_GameplayCue::PitchMultiplier' has a wrong offset!");

// Class OrionGame.OrionObjectiveCapturePoint
// 0x0018 (0x0400 - 0x03E8)
class AOrionObjectiveCapturePoint final : public AOrionBaseActor
{
public:
	class UCapsuleComponent*                      Collision;                                         // 0x03E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FOrionObjectivesToCapture>      ObjectivesToHandle;                                // 0x03F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void OnCaptureHandle(const struct FOrionObjectivesToCapture& CapturedObjectiveData);
	void OnManuallyHandleCapture(class AActor* OtherActor, EOrionTeam OtherActorTeamNum, const struct FOrionObjectivesToCapture& CapturedObjectiveData);
	void OnObjectiveCaptured();
	void OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionObjectiveCapturePoint">();
	}
	static class AOrionObjectiveCapturePoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionObjectiveCapturePoint>();
	}
};
static_assert(alignof(AOrionObjectiveCapturePoint) == 0x000008, "Wrong alignment on AOrionObjectiveCapturePoint");
static_assert(sizeof(AOrionObjectiveCapturePoint) == 0x000400, "Wrong size on AOrionObjectiveCapturePoint");
static_assert(offsetof(AOrionObjectiveCapturePoint, Collision) == 0x0003E8, "Member 'AOrionObjectiveCapturePoint::Collision' has a wrong offset!");
static_assert(offsetof(AOrionObjectiveCapturePoint, ObjectivesToHandle) == 0x0003F0, "Member 'AOrionObjectiveCapturePoint::ObjectivesToHandle' has a wrong offset!");

// Class OrionGame.OrionAnimNotify_GameplayCueState
// 0x0018 (0x0048 - 0x0030)
class UOrionAnimNotify_GameplayCueState final : public UAnimNotifyState
{
public:
	struct FGameplayCueTag                        Cue;                                               // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayCue;                                       // 0x0038(0x0008)(BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VolumeMultiplier;                                  // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PitchMultiplier;                                   // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAnimNotify_GameplayCueState">();
	}
	static class UOrionAnimNotify_GameplayCueState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAnimNotify_GameplayCueState>();
	}
};
static_assert(alignof(UOrionAnimNotify_GameplayCueState) == 0x000008, "Wrong alignment on UOrionAnimNotify_GameplayCueState");
static_assert(sizeof(UOrionAnimNotify_GameplayCueState) == 0x000048, "Wrong size on UOrionAnimNotify_GameplayCueState");
static_assert(offsetof(UOrionAnimNotify_GameplayCueState, Cue) == 0x000030, "Member 'UOrionAnimNotify_GameplayCueState::Cue' has a wrong offset!");
static_assert(offsetof(UOrionAnimNotify_GameplayCueState, GameplayCue) == 0x000038, "Member 'UOrionAnimNotify_GameplayCueState::GameplayCue' has a wrong offset!");
static_assert(offsetof(UOrionAnimNotify_GameplayCueState, VolumeMultiplier) == 0x000040, "Member 'UOrionAnimNotify_GameplayCueState::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(UOrionAnimNotify_GameplayCueState, PitchMultiplier) == 0x000044, "Member 'UOrionAnimNotify_GameplayCueState::PitchMultiplier' has a wrong offset!");

// Class OrionGame.OrionAnimNotify_Landed
// 0x0000 (0x00F0 - 0x00F0)
class UOrionAnimNotify_Landed final : public UOrionAnimNotify_Footstep
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAnimNotify_Landed">();
	}
	static class UOrionAnimNotify_Landed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAnimNotify_Landed>();
	}
};
static_assert(alignof(UOrionAnimNotify_Landed) == 0x000008, "Wrong alignment on UOrionAnimNotify_Landed");
static_assert(sizeof(UOrionAnimNotify_Landed) == 0x0000F0, "Wrong size on UOrionAnimNotify_Landed");

// Class OrionGame.OrionAnimNotify_MeleeCancel
// 0x0028 (0x0060 - 0x0038)
class UOrionAnimNotify_MeleeCancel final : public UAnimNotify
{
public:
	struct FGameplayTagContainer                  UnBlockAbilitiesWithTag;                           // 0x0038(0x0020)(Edit, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bCancelByMovement;                                 // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAnimNotify_MeleeCancel">();
	}
	static class UOrionAnimNotify_MeleeCancel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAnimNotify_MeleeCancel>();
	}
};
static_assert(alignof(UOrionAnimNotify_MeleeCancel) == 0x000008, "Wrong alignment on UOrionAnimNotify_MeleeCancel");
static_assert(sizeof(UOrionAnimNotify_MeleeCancel) == 0x000060, "Wrong size on UOrionAnimNotify_MeleeCancel");
static_assert(offsetof(UOrionAnimNotify_MeleeCancel, UnBlockAbilitiesWithTag) == 0x000038, "Member 'UOrionAnimNotify_MeleeCancel::UnBlockAbilitiesWithTag' has a wrong offset!");
static_assert(offsetof(UOrionAnimNotify_MeleeCancel, bCancelByMovement) == 0x000058, "Member 'UOrionAnimNotify_MeleeCancel::bCancelByMovement' has a wrong offset!");

// Class OrionGame.OrionAnimNotify_MeleeCharge
// 0x0000 (0x0038 - 0x0038)
class UOrionAnimNotify_MeleeCharge final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAnimNotify_MeleeCharge">();
	}
	static class UOrionAnimNotify_MeleeCharge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAnimNotify_MeleeCharge>();
	}
};
static_assert(alignof(UOrionAnimNotify_MeleeCharge) == 0x000008, "Wrong alignment on UOrionAnimNotify_MeleeCharge");
static_assert(sizeof(UOrionAnimNotify_MeleeCharge) == 0x000038, "Wrong size on UOrionAnimNotify_MeleeCharge");

// Class OrionGame.OrionAnimNotify_PlaySoundTeamAdjusted
// 0x0008 (0x0040 - 0x0038)
class UOrionAnimNotify_PlaySoundTeamAdjusted final : public UAnimNotify
{
public:
	class USoundBase*                             SoundCue;                                          // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAnimNotify_PlaySoundTeamAdjusted">();
	}
	static class UOrionAnimNotify_PlaySoundTeamAdjusted* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAnimNotify_PlaySoundTeamAdjusted>();
	}
};
static_assert(alignof(UOrionAnimNotify_PlaySoundTeamAdjusted) == 0x000008, "Wrong alignment on UOrionAnimNotify_PlaySoundTeamAdjusted");
static_assert(sizeof(UOrionAnimNotify_PlaySoundTeamAdjusted) == 0x000040, "Wrong size on UOrionAnimNotify_PlaySoundTeamAdjusted");
static_assert(offsetof(UOrionAnimNotify_PlaySoundTeamAdjusted, SoundCue) == 0x000038, "Member 'UOrionAnimNotify_PlaySoundTeamAdjusted::SoundCue' has a wrong offset!");

// Class OrionGame.OrionAnimNotifyState_AbilityQueueWindow
// 0x0000 (0x0030 - 0x0030)
class UOrionAnimNotifyState_AbilityQueueWindow final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAnimNotifyState_AbilityQueueWindow">();
	}
	static class UOrionAnimNotifyState_AbilityQueueWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAnimNotifyState_AbilityQueueWindow>();
	}
};
static_assert(alignof(UOrionAnimNotifyState_AbilityQueueWindow) == 0x000008, "Wrong alignment on UOrionAnimNotifyState_AbilityQueueWindow");
static_assert(sizeof(UOrionAnimNotifyState_AbilityQueueWindow) == 0x000030, "Wrong size on UOrionAnimNotifyState_AbilityQueueWindow");

// Class OrionGame.OrionAnimNotifyState_ForceFacingForward
// 0x0000 (0x0030 - 0x0030)
class UOrionAnimNotifyState_ForceFacingForward final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAnimNotifyState_ForceFacingForward">();
	}
	static class UOrionAnimNotifyState_ForceFacingForward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAnimNotifyState_ForceFacingForward>();
	}
};
static_assert(alignof(UOrionAnimNotifyState_ForceFacingForward) == 0x000008, "Wrong alignment on UOrionAnimNotifyState_ForceFacingForward");
static_assert(sizeof(UOrionAnimNotifyState_ForceFacingForward) == 0x000030, "Wrong size on UOrionAnimNotifyState_ForceFacingForward");

// Class OrionGame.OrionMcpProfile
// 0x0010 (0x02B0 - 0x02A0)
class UOrionMcpProfile : public UMcpProfile
{
public:
	uint8                                         Pad_2A0[0x10];                                     // 0x02A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpProfile">();
	}
	static class UOrionMcpProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpProfile>();
	}
};
static_assert(alignof(UOrionMcpProfile) == 0x000008, "Wrong alignment on UOrionMcpProfile");
static_assert(sizeof(UOrionMcpProfile) == 0x0002B0, "Wrong size on UOrionMcpProfile");

// Class OrionGame.OrionAnimNotifyState_ForceFullBodyMontage
// 0x0008 (0x0038 - 0x0030)
class UOrionAnimNotifyState_ForceFullBodyMontage final : public UAnimNotifyState
{
public:
	struct FForceFullBodyMontageParams            Params_0;                                          // 0x0030(0x0004)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAnimNotifyState_ForceFullBodyMontage">();
	}
	static class UOrionAnimNotifyState_ForceFullBodyMontage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAnimNotifyState_ForceFullBodyMontage>();
	}
};
static_assert(alignof(UOrionAnimNotifyState_ForceFullBodyMontage) == 0x000008, "Wrong alignment on UOrionAnimNotifyState_ForceFullBodyMontage");
static_assert(sizeof(UOrionAnimNotifyState_ForceFullBodyMontage) == 0x000038, "Wrong size on UOrionAnimNotifyState_ForceFullBodyMontage");
static_assert(offsetof(UOrionAnimNotifyState_ForceFullBodyMontage, Params_0) == 0x000030, "Member 'UOrionAnimNotifyState_ForceFullBodyMontage::Params_0' has a wrong offset!");

// Class OrionGame.OrionAnimNotifyState_MeleeDamageWindow
// 0x0008 (0x0038 - 0x0030)
class UOrionAnimNotifyState_MeleeDamageWindow final : public UAnimNotifyState
{
public:
	class FName                                   CollisionComponentName;                            // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAnimNotifyState_MeleeDamageWindow">();
	}
	static class UOrionAnimNotifyState_MeleeDamageWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAnimNotifyState_MeleeDamageWindow>();
	}
};
static_assert(alignof(UOrionAnimNotifyState_MeleeDamageWindow) == 0x000008, "Wrong alignment on UOrionAnimNotifyState_MeleeDamageWindow");
static_assert(sizeof(UOrionAnimNotifyState_MeleeDamageWindow) == 0x000038, "Wrong size on UOrionAnimNotifyState_MeleeDamageWindow");
static_assert(offsetof(UOrionAnimNotifyState_MeleeDamageWindow, CollisionComponentName) == 0x000030, "Member 'UOrionAnimNotifyState_MeleeDamageWindow::CollisionComponentName' has a wrong offset!");

// Class OrionGame.OrionAnimNotifyState_MovementWindow
// 0x0008 (0x0038 - 0x0030)
class UOrionAnimNotifyState_MovementWindow final : public UAnimNotifyState
{
public:
	float                                         MovementDistance;                                  // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAnimNotifyState_MovementWindow">();
	}
	static class UOrionAnimNotifyState_MovementWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAnimNotifyState_MovementWindow>();
	}
};
static_assert(alignof(UOrionAnimNotifyState_MovementWindow) == 0x000008, "Wrong alignment on UOrionAnimNotifyState_MovementWindow");
static_assert(sizeof(UOrionAnimNotifyState_MovementWindow) == 0x000038, "Wrong size on UOrionAnimNotifyState_MovementWindow");
static_assert(offsetof(UOrionAnimNotifyState_MovementWindow, MovementDistance) == 0x000030, "Member 'UOrionAnimNotifyState_MovementWindow::MovementDistance' has a wrong offset!");

// Class OrionGame.OrionAnimTypes
// 0x0000 (0x0028 - 0x0028)
class UOrionAnimTypes final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAnimTypes">();
	}
	static class UOrionAnimTypes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAnimTypes>();
	}
};
static_assert(alignof(UOrionAnimTypes) == 0x000008, "Wrong alignment on UOrionAnimTypes");
static_assert(sizeof(UOrionAnimTypes) == 0x000028, "Wrong size on UOrionAnimTypes");

// Class OrionGame.OrionMcpItem
// 0x0050 (0x0078 - 0x0028)
class UOrionMcpItem : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionMcpItemDefinition*                ItemDefinition;                                    // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 InstanceId;                                        // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 TemplateId;                                        // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Quantity;                                          // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnOrionMcpItemAttributeChanged;                    // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOrionMcpItemAttributeChanged__DelegateSignature();

	class FText GetDescription() const;
	class FText GetDisplayName() const;
	int32 GetNumInStack() const;
	EOrionItemType GetType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpItem">();
	}
	static class UOrionMcpItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpItem>();
	}
};
static_assert(alignof(UOrionMcpItem) == 0x000008, "Wrong alignment on UOrionMcpItem");
static_assert(sizeof(UOrionMcpItem) == 0x000078, "Wrong size on UOrionMcpItem");
static_assert(offsetof(UOrionMcpItem, ItemDefinition) == 0x000030, "Member 'UOrionMcpItem::ItemDefinition' has a wrong offset!");
static_assert(offsetof(UOrionMcpItem, InstanceId) == 0x000038, "Member 'UOrionMcpItem::InstanceId' has a wrong offset!");
static_assert(offsetof(UOrionMcpItem, TemplateId) == 0x000048, "Member 'UOrionMcpItem::TemplateId' has a wrong offset!");
static_assert(offsetof(UOrionMcpItem, Quantity) == 0x000058, "Member 'UOrionMcpItem::Quantity' has a wrong offset!");
static_assert(offsetof(UOrionMcpItem, OnOrionMcpItemAttributeChanged) == 0x000060, "Member 'UOrionMcpItem::OnOrionMcpItemAttributeChanged' has a wrong offset!");

// Class OrionGame.OrionMcpSkinVariationItem
// 0x0000 (0x0078 - 0x0078)
class UOrionMcpSkinVariationItem final : public UOrionMcpItem
{
public:
	class UOrionSkinVariationItemDefinition* GetInternalData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpSkinVariationItem">();
	}
	static class UOrionMcpSkinVariationItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpSkinVariationItem>();
	}
};
static_assert(alignof(UOrionMcpSkinVariationItem) == 0x000008, "Wrong alignment on UOrionMcpSkinVariationItem");
static_assert(sizeof(UOrionMcpSkinVariationItem) == 0x000078, "Wrong size on UOrionMcpSkinVariationItem");

// Class OrionGame.OrionArcadeLadderSetupData
// 0x0058 (0x0088 - 0x0030)
class UOrionArcadeLadderSetupData final : public UDataAsset
{
public:
	class FText                                   LadderTitle;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   LadderDescription;                                 // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UTexture2D*                             LadderIcon;                                        // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionHeroData*                         HeroData;                                          // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumOfRounds;                                       // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoundLength;                                       // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FStageEntry>                    Stages;                                            // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	class UTexture2D* GetHeroIcon() const;
	class FText GetHeroName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionArcadeLadderSetupData">();
	}
	static class UOrionArcadeLadderSetupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionArcadeLadderSetupData>();
	}
};
static_assert(alignof(UOrionArcadeLadderSetupData) == 0x000008, "Wrong alignment on UOrionArcadeLadderSetupData");
static_assert(sizeof(UOrionArcadeLadderSetupData) == 0x000088, "Wrong size on UOrionArcadeLadderSetupData");
static_assert(offsetof(UOrionArcadeLadderSetupData, LadderTitle) == 0x000030, "Member 'UOrionArcadeLadderSetupData::LadderTitle' has a wrong offset!");
static_assert(offsetof(UOrionArcadeLadderSetupData, LadderDescription) == 0x000048, "Member 'UOrionArcadeLadderSetupData::LadderDescription' has a wrong offset!");
static_assert(offsetof(UOrionArcadeLadderSetupData, LadderIcon) == 0x000060, "Member 'UOrionArcadeLadderSetupData::LadderIcon' has a wrong offset!");
static_assert(offsetof(UOrionArcadeLadderSetupData, HeroData) == 0x000068, "Member 'UOrionArcadeLadderSetupData::HeroData' has a wrong offset!");
static_assert(offsetof(UOrionArcadeLadderSetupData, NumOfRounds) == 0x000070, "Member 'UOrionArcadeLadderSetupData::NumOfRounds' has a wrong offset!");
static_assert(offsetof(UOrionArcadeLadderSetupData, RoundLength) == 0x000074, "Member 'UOrionArcadeLadderSetupData::RoundLength' has a wrong offset!");
static_assert(offsetof(UOrionArcadeLadderSetupData, Stages) == 0x000078, "Member 'UOrionArcadeLadderSetupData::Stages' has a wrong offset!");

// Class OrionGame.OrionMcpTranslateTokenItemDefinition
// 0x0028 (0x0290 - 0x0268)
class UOrionMcpTranslateTokenItemDefinition final : public UOrionMcpItemDefinition
{
public:
	TArray<TSubclassOf<class UOrionMcpItemDefinition>> AllowedTranslators;                                // 0x0268(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UOrionMcpItemDefinition>> AllowedTranslationTypes;                           // 0x0278(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_288[0x8];                                      // 0x0288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpTranslateTokenItemDefinition">();
	}
	static class UOrionMcpTranslateTokenItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpTranslateTokenItemDefinition>();
	}
};
static_assert(alignof(UOrionMcpTranslateTokenItemDefinition) == 0x000008, "Wrong alignment on UOrionMcpTranslateTokenItemDefinition");
static_assert(sizeof(UOrionMcpTranslateTokenItemDefinition) == 0x000290, "Wrong size on UOrionMcpTranslateTokenItemDefinition");
static_assert(offsetof(UOrionMcpTranslateTokenItemDefinition, AllowedTranslators) == 0x000268, "Member 'UOrionMcpTranslateTokenItemDefinition::AllowedTranslators' has a wrong offset!");
static_assert(offsetof(UOrionMcpTranslateTokenItemDefinition, AllowedTranslationTypes) == 0x000278, "Member 'UOrionMcpTranslateTokenItemDefinition::AllowedTranslationTypes' has a wrong offset!");

// Class OrionGame.OrionAsyncLoadInterface
// 0x0000 (0x0028 - 0x0028)
class IOrionAsyncLoadInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAsyncLoadInterface">();
	}
	static class IOrionAsyncLoadInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOrionAsyncLoadInterface>();
	}
};
static_assert(alignof(IOrionAsyncLoadInterface) == 0x000008, "Wrong alignment on IOrionAsyncLoadInterface");
static_assert(sizeof(IOrionAsyncLoadInterface) == 0x000028, "Wrong size on IOrionAsyncLoadInterface");

// Class OrionGame.OrionAttributeView
// 0x0070 (0x00A0 - 0x0030)
class UOrionAttributeView final : public UDataAsset
{
public:
	class FText                                   CategoryDisplayNames[0x4];                         // 0x0030(0x0018)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FOrionAttributeViewItem>        Attributes;                                        // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAttributeView">();
	}
	static class UOrionAttributeView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionAttributeView>();
	}
};
static_assert(alignof(UOrionAttributeView) == 0x000008, "Wrong alignment on UOrionAttributeView");
static_assert(sizeof(UOrionAttributeView) == 0x0000A0, "Wrong size on UOrionAttributeView");
static_assert(offsetof(UOrionAttributeView, CategoryDisplayNames) == 0x000030, "Member 'UOrionAttributeView::CategoryDisplayNames' has a wrong offset!");
static_assert(offsetof(UOrionAttributeView, Attributes) == 0x000090, "Member 'UOrionAttributeView::Attributes' has a wrong offset!");

// Class OrionGame.OrionAuraManager
// 0x0040 (0x0358 - 0x0318)
class AOrionAuraManager final : public AActor
{
public:
	TArray<struct FActiveAuraInfo>                ActiveAuras;                                       // 0x0318(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_328[0x30];                                     // 0x0328(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionAuraManager">();
	}
	static class AOrionAuraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionAuraManager>();
	}
};
static_assert(alignof(AOrionAuraManager) == 0x000008, "Wrong alignment on AOrionAuraManager");
static_assert(sizeof(AOrionAuraManager) == 0x000358, "Wrong size on AOrionAuraManager");
static_assert(offsetof(AOrionAuraManager, ActiveAuras) == 0x000318, "Member 'AOrionAuraManager::ActiveAuras' has a wrong offset!");

// Class OrionGame.OrionLocalPlayer
// 0x05C0 (0x0920 - 0x0360)
class UOrionLocalPlayer final : public ULocalPlayerCommon
{
public:
	uint8                                         Pad_360[0x10];                                     // 0x0360(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionKillcamPlayback*                  KillcamPlayback;                                   // 0x0370(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionYouTubeUpload*                    YouTubeUpload;                                     // 0x0378(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionCmsManager*                       CMSManager;                                        // 0x0380(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_388[0x4B8];                                    // 0x0388(0x04B8)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UOrionMcpTokenItem*>             TokensToClearNextMatch;                            // 0x0840(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_850[0xD0];                                     // 0x0850(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionLocalPlayer">();
	}
	static class UOrionLocalPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionLocalPlayer>();
	}
};
static_assert(alignof(UOrionLocalPlayer) == 0x000008, "Wrong alignment on UOrionLocalPlayer");
static_assert(sizeof(UOrionLocalPlayer) == 0x000920, "Wrong size on UOrionLocalPlayer");
static_assert(offsetof(UOrionLocalPlayer, KillcamPlayback) == 0x000370, "Member 'UOrionLocalPlayer::KillcamPlayback' has a wrong offset!");
static_assert(offsetof(UOrionLocalPlayer, YouTubeUpload) == 0x000378, "Member 'UOrionLocalPlayer::YouTubeUpload' has a wrong offset!");
static_assert(offsetof(UOrionLocalPlayer, CMSManager) == 0x000380, "Member 'UOrionLocalPlayer::CMSManager' has a wrong offset!");
static_assert(offsetof(UOrionLocalPlayer, TokensToClearNextMatch) == 0x000840, "Member 'UOrionLocalPlayer::TokensToClearNextMatch' has a wrong offset!");

// Class OrionGame.OrionBalanceTweaker
// 0x0010 (0x0038 - 0x0028)
class UOrionBalanceTweaker final : public UObject
{
public:
	struct FBalanceTweakerData                    Data;                                              // 0x0028(0x0010)(Edit, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionBalanceTweaker">();
	}
	static class UOrionBalanceTweaker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionBalanceTweaker>();
	}
};
static_assert(alignof(UOrionBalanceTweaker) == 0x000008, "Wrong alignment on UOrionBalanceTweaker");
static_assert(sizeof(UOrionBalanceTweaker) == 0x000038, "Wrong size on UOrionBalanceTweaker");
static_assert(offsetof(UOrionBalanceTweaker, Data) == 0x000028, "Member 'UOrionBalanceTweaker::Data' has a wrong offset!");

// Class OrionGame.OrionBanner
// 0x05C8 (0x09B0 - 0x03E8)
class AOrionBanner : public AOrionBaseActor
{
public:
	class UMaterial*                              PortraitMaterial;                                  // 0x03E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFont*                                  Font;                                              // 0x03F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            PortraitBrush;                                     // 0x03F8(0x0078)(NativeAccessSpecifierPublic)
	class FName                                   DerezParameterName;                                // 0x0470(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TeamColorParameter;                                // 0x0478(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DecalOpacityParameterName;                         // 0x0480(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Texture2DParameterName;                            // 0x0488(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActivateDurationParameterName;                     // 0x0490(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_498[0x48];                                     // 0x0498(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBannerSpec                            CurrentBannerSpec;                                 // 0x04E0(0x0068)(Net, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 ActivationPos;                                     // 0x0548(0x000C)(Net, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               ActivationRotation;                                // 0x0554(0x000C)(Net, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ActivationScale;                                   // 0x0560(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoActivate;                                     // 0x0564(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBannerEntrance                               ActivationBannerEntranceType;                      // 0x0565(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Activation_bCreatedLocallyByClient;                // 0x0566(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableActivation;                                // 0x0567(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPortraitInfo                          PortraitInfo;                                      // 0x0568(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_580[0x4];                                      // 0x0580(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EntranceDelay;                                     // 0x0584(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBannerEntrance                               DefaultBannerEntranceType;                         // 0x0588(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_589[0x7];                                      // 0x0589(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBannerEntranceData                    Landing;                                           // 0x0590(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FBannerEntranceData                    Rising;                                            // 0x05F0(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FBannerEntranceData                    PostRising;                                        // 0x0650(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FBannerEntranceData                    InAir;                                             // 0x06B0(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_710[0x8];                                      // 0x0710(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DecalFadeInDuration;                               // 0x0718(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBlocksMovement;                                   // 0x071C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_71D[0x3];                                      // 0x071D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionBannerCues                       BannerGameplayCues;                                // 0x0720(0x0058)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         BannerFadeDuration;                                // 0x0778(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_77C[0x4];                                      // 0x077C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UOrionMcpBannerItemDefinition> DefaultDeactivationDefinition;                     // 0x0780(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A8[0x10];                                     // 0x07A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           TransCurve;                                        // 0x07B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           ScaleCurve;                                        // 0x07C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           RotCurve;                                          // 0x07C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBannerActivationData                  ActivationData;                                    // 0x07D0(0x00B8)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	bool                                          bHasSetUpBannerFromDef;                            // 0x0888(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_889[0x87];                                     // 0x0889(0x0087)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0910(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_918[0x80];                                     // 0x0918(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             ActivateAudio;                                     // 0x0998(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             LandImpactAudio;                                   // 0x09A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             DeactivateAudio;                                   // 0x09A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool ActivateBanner(const struct FVector& EndPos, const struct FRotator& TargetRot, const float& Scale, const EBannerEntrance& BannerEntranceType);
	bool ActivateTestBanner(const struct FVector& InSpawnLocation, const struct FRotator& InSpawnRotation, const float& InSpawnScale);
	void AddGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Parameters);
	void BannerLanded();
	void ExecuteGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Parameters);
	void OnBannerLanded();
	void OnRep_BannerActivation();
	void RemoveAndFadeBannerNow(float InFadeTime);
	void RemoveGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Parameters);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionBanner">();
	}
	static class AOrionBanner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionBanner>();
	}
};
static_assert(alignof(AOrionBanner) == 0x000008, "Wrong alignment on AOrionBanner");
static_assert(sizeof(AOrionBanner) == 0x0009B0, "Wrong size on AOrionBanner");
static_assert(offsetof(AOrionBanner, PortraitMaterial) == 0x0003E8, "Member 'AOrionBanner::PortraitMaterial' has a wrong offset!");
static_assert(offsetof(AOrionBanner, Font) == 0x0003F0, "Member 'AOrionBanner::Font' has a wrong offset!");
static_assert(offsetof(AOrionBanner, PortraitBrush) == 0x0003F8, "Member 'AOrionBanner::PortraitBrush' has a wrong offset!");
static_assert(offsetof(AOrionBanner, DerezParameterName) == 0x000470, "Member 'AOrionBanner::DerezParameterName' has a wrong offset!");
static_assert(offsetof(AOrionBanner, TeamColorParameter) == 0x000478, "Member 'AOrionBanner::TeamColorParameter' has a wrong offset!");
static_assert(offsetof(AOrionBanner, DecalOpacityParameterName) == 0x000480, "Member 'AOrionBanner::DecalOpacityParameterName' has a wrong offset!");
static_assert(offsetof(AOrionBanner, Texture2DParameterName) == 0x000488, "Member 'AOrionBanner::Texture2DParameterName' has a wrong offset!");
static_assert(offsetof(AOrionBanner, ActivateDurationParameterName) == 0x000490, "Member 'AOrionBanner::ActivateDurationParameterName' has a wrong offset!");
static_assert(offsetof(AOrionBanner, CurrentBannerSpec) == 0x0004E0, "Member 'AOrionBanner::CurrentBannerSpec' has a wrong offset!");
static_assert(offsetof(AOrionBanner, ActivationPos) == 0x000548, "Member 'AOrionBanner::ActivationPos' has a wrong offset!");
static_assert(offsetof(AOrionBanner, ActivationRotation) == 0x000554, "Member 'AOrionBanner::ActivationRotation' has a wrong offset!");
static_assert(offsetof(AOrionBanner, ActivationScale) == 0x000560, "Member 'AOrionBanner::ActivationScale' has a wrong offset!");
static_assert(offsetof(AOrionBanner, bAutoActivate) == 0x000564, "Member 'AOrionBanner::bAutoActivate' has a wrong offset!");
static_assert(offsetof(AOrionBanner, ActivationBannerEntranceType) == 0x000565, "Member 'AOrionBanner::ActivationBannerEntranceType' has a wrong offset!");
static_assert(offsetof(AOrionBanner, Activation_bCreatedLocallyByClient) == 0x000566, "Member 'AOrionBanner::Activation_bCreatedLocallyByClient' has a wrong offset!");
static_assert(offsetof(AOrionBanner, bDisableActivation) == 0x000567, "Member 'AOrionBanner::bDisableActivation' has a wrong offset!");
static_assert(offsetof(AOrionBanner, PortraitInfo) == 0x000568, "Member 'AOrionBanner::PortraitInfo' has a wrong offset!");
static_assert(offsetof(AOrionBanner, EntranceDelay) == 0x000584, "Member 'AOrionBanner::EntranceDelay' has a wrong offset!");
static_assert(offsetof(AOrionBanner, DefaultBannerEntranceType) == 0x000588, "Member 'AOrionBanner::DefaultBannerEntranceType' has a wrong offset!");
static_assert(offsetof(AOrionBanner, Landing) == 0x000590, "Member 'AOrionBanner::Landing' has a wrong offset!");
static_assert(offsetof(AOrionBanner, Rising) == 0x0005F0, "Member 'AOrionBanner::Rising' has a wrong offset!");
static_assert(offsetof(AOrionBanner, PostRising) == 0x000650, "Member 'AOrionBanner::PostRising' has a wrong offset!");
static_assert(offsetof(AOrionBanner, InAir) == 0x0006B0, "Member 'AOrionBanner::InAir' has a wrong offset!");
static_assert(offsetof(AOrionBanner, DecalFadeInDuration) == 0x000718, "Member 'AOrionBanner::DecalFadeInDuration' has a wrong offset!");
static_assert(offsetof(AOrionBanner, bBlocksMovement) == 0x00071C, "Member 'AOrionBanner::bBlocksMovement' has a wrong offset!");
static_assert(offsetof(AOrionBanner, BannerGameplayCues) == 0x000720, "Member 'AOrionBanner::BannerGameplayCues' has a wrong offset!");
static_assert(offsetof(AOrionBanner, BannerFadeDuration) == 0x000778, "Member 'AOrionBanner::BannerFadeDuration' has a wrong offset!");
static_assert(offsetof(AOrionBanner, DefaultDeactivationDefinition) == 0x000780, "Member 'AOrionBanner::DefaultDeactivationDefinition' has a wrong offset!");
static_assert(offsetof(AOrionBanner, TransCurve) == 0x0007B8, "Member 'AOrionBanner::TransCurve' has a wrong offset!");
static_assert(offsetof(AOrionBanner, ScaleCurve) == 0x0007C0, "Member 'AOrionBanner::ScaleCurve' has a wrong offset!");
static_assert(offsetof(AOrionBanner, RotCurve) == 0x0007C8, "Member 'AOrionBanner::RotCurve' has a wrong offset!");
static_assert(offsetof(AOrionBanner, ActivationData) == 0x0007D0, "Member 'AOrionBanner::ActivationData' has a wrong offset!");
static_assert(offsetof(AOrionBanner, bHasSetUpBannerFromDef) == 0x000888, "Member 'AOrionBanner::bHasSetUpBannerFromDef' has a wrong offset!");
static_assert(offsetof(AOrionBanner, StaticMeshComponent) == 0x000910, "Member 'AOrionBanner::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AOrionBanner, ActivateAudio) == 0x000998, "Member 'AOrionBanner::ActivateAudio' has a wrong offset!");
static_assert(offsetof(AOrionBanner, LandImpactAudio) == 0x0009A0, "Member 'AOrionBanner::LandImpactAudio' has a wrong offset!");
static_assert(offsetof(AOrionBanner, DeactivateAudio) == 0x0009A8, "Member 'AOrionBanner::DeactivateAudio' has a wrong offset!");

// Class OrionGame.OrionMatchHeartbeatManager
// 0x0018 (0x0040 - 0x0028)
class UOrionMatchHeartbeatManager final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ServerMetricsLOD;                                  // 0x0038(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMatchHeartbeatManager">();
	}
	static class UOrionMatchHeartbeatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMatchHeartbeatManager>();
	}
};
static_assert(alignof(UOrionMatchHeartbeatManager) == 0x000008, "Wrong alignment on UOrionMatchHeartbeatManager");
static_assert(sizeof(UOrionMatchHeartbeatManager) == 0x000040, "Wrong size on UOrionMatchHeartbeatManager");
static_assert(offsetof(UOrionMatchHeartbeatManager, ServerMetricsLOD) == 0x000038, "Member 'UOrionMatchHeartbeatManager::ServerMetricsLOD' has a wrong offset!");

// Class OrionGame.OrionBaseButton
// 0x0728 (0x09E0 - 0x02B8)
class UOrionBaseButton : public UOrionUserWidgetBase
{
public:
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinWidth;                                          // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinHeight;                                         // 0x02C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UOrionButtonStyle>          Style;                                             // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrionWidgetStyleSize                         StyleSize;                                         // 0x02D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplyAlphaOnDisable;                              // 0x02D1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D2[0x6];                                      // 0x02D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateSound                            PressedSlateSoundOverride;                         // 0x02D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSlateSound                            HoveredSlateSoundOverride;                         // 0x02F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bSelectable;                                       // 0x0308(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bToggleable;                                       // 0x0309(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EButtonClickMethod                            ClickMethod;                                       // 0x030A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30B[0x5];                                      // 0x030B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   BoundKey;                                          // 0x0310(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bListenForInput;                                   // 0x0328(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrionUIAnalyticsTrackingLevel                ClickedTrackingLevel;                              // 0x0329(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrionUIAnalyticsTrackingLevel                SelectionChangedTrackingLevel;                     // 0x032A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisableInteractionWhenSelected;                   // 0x032B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32C[0x4];                                      // 0x032C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnButtonSelectedChanged;                           // 0x0330(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnButtonClicked;                                   // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnButtonHovered;                                   // 0x0350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnButtonUnhovered;                                 // 0x0360(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_370[0x670];                                    // 0x0370(0x0670)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnClicked();
	void BP_OnDeselected();
	void BP_OnDisabled();
	void BP_OnEnabled();
	void BP_OnHovered();
	void BP_OnSelected();
	void BP_OnUnhovered();
	void ClearSelection();
	void DisableButton();
	void DisableButtonWithReason(const class FText& DisabledReason);
	void EnableButton();
	void HandleButtonClicked();
	void OnStyleSizeChanged();
	void SetIsSelectable(bool bInIsSelectable);
	void SetIsSelected(bool InSelected, bool bFromClick);
	void SetMinDimensions(int32 InMinWidth, int32 InMinHeight);
	void SetSelectedInternal(bool bInSelected, bool bAllowSound, bool bBroadcast);
	void SetStyle(TSubclassOf<class UOrionButtonStyle> InStyle);
	void SetStyleSize(EOrionWidgetStyleSize InSize);

	void GetCurrentButtonPadding(struct FMargin* OutButtonPadding) const;
	void GetCurrentCustomPadding(struct FMargin* OutCustomPadding) const;
	class UOrionTextStyle* GetCurrentTextStyle() const;
	TSubclassOf<class UOrionTextStyle> GetCurrentTextStyleClass() const;
	bool GetSelected() const;
	class UOrionButtonStyle* GetStyle() const;
	bool IsHovered() const;
	bool IsInteractionEnabled() const;
	bool IsPressed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionBaseButton">();
	}
	static class UOrionBaseButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionBaseButton>();
	}
};
static_assert(alignof(UOrionBaseButton) == 0x000008, "Wrong alignment on UOrionBaseButton");
static_assert(sizeof(UOrionBaseButton) == 0x0009E0, "Wrong size on UOrionBaseButton");
static_assert(offsetof(UOrionBaseButton, MinWidth) == 0x0002C0, "Member 'UOrionBaseButton::MinWidth' has a wrong offset!");
static_assert(offsetof(UOrionBaseButton, MinHeight) == 0x0002C4, "Member 'UOrionBaseButton::MinHeight' has a wrong offset!");
static_assert(offsetof(UOrionBaseButton, Style) == 0x0002C8, "Member 'UOrionBaseButton::Style' has a wrong offset!");
static_assert(offsetof(UOrionBaseButton, StyleSize) == 0x0002D0, "Member 'UOrionBaseButton::StyleSize' has a wrong offset!");
static_assert(offsetof(UOrionBaseButton, bApplyAlphaOnDisable) == 0x0002D1, "Member 'UOrionBaseButton::bApplyAlphaOnDisable' has a wrong offset!");
static_assert(offsetof(UOrionBaseButton, PressedSlateSoundOverride) == 0x0002D8, "Member 'UOrionBaseButton::PressedSlateSoundOverride' has a wrong offset!");
static_assert(offsetof(UOrionBaseButton, HoveredSlateSoundOverride) == 0x0002F0, "Member 'UOrionBaseButton::HoveredSlateSoundOverride' has a wrong offset!");
static_assert(offsetof(UOrionBaseButton, bSelectable) == 0x000308, "Member 'UOrionBaseButton::bSelectable' has a wrong offset!");
static_assert(offsetof(UOrionBaseButton, bToggleable) == 0x000309, "Member 'UOrionBaseButton::bToggleable' has a wrong offset!");
static_assert(offsetof(UOrionBaseButton, ClickMethod) == 0x00030A, "Member 'UOrionBaseButton::ClickMethod' has a wrong offset!");
static_assert(offsetof(UOrionBaseButton, BoundKey) == 0x000310, "Member 'UOrionBaseButton::BoundKey' has a wrong offset!");
static_assert(offsetof(UOrionBaseButton, bListenForInput) == 0x000328, "Member 'UOrionBaseButton::bListenForInput' has a wrong offset!");
static_assert(offsetof(UOrionBaseButton, ClickedTrackingLevel) == 0x000329, "Member 'UOrionBaseButton::ClickedTrackingLevel' has a wrong offset!");
static_assert(offsetof(UOrionBaseButton, SelectionChangedTrackingLevel) == 0x00032A, "Member 'UOrionBaseButton::SelectionChangedTrackingLevel' has a wrong offset!");
static_assert(offsetof(UOrionBaseButton, bDisableInteractionWhenSelected) == 0x00032B, "Member 'UOrionBaseButton::bDisableInteractionWhenSelected' has a wrong offset!");
static_assert(offsetof(UOrionBaseButton, OnButtonSelectedChanged) == 0x000330, "Member 'UOrionBaseButton::OnButtonSelectedChanged' has a wrong offset!");
static_assert(offsetof(UOrionBaseButton, OnButtonClicked) == 0x000340, "Member 'UOrionBaseButton::OnButtonClicked' has a wrong offset!");
static_assert(offsetof(UOrionBaseButton, OnButtonHovered) == 0x000350, "Member 'UOrionBaseButton::OnButtonHovered' has a wrong offset!");
static_assert(offsetof(UOrionBaseButton, OnButtonUnhovered) == 0x000360, "Member 'UOrionBaseButton::OnButtonUnhovered' has a wrong offset!");

// Class OrionGame.OrionTooltipBase
// 0x0078 (0x0330 - 0x02B8)
class UOrionTooltipBase : public UOrionUserWidgetBase
{
public:
	bool                                          bUseFadeSequence;                                  // 0x02B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBorder*                                Border_Contents;                                   // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOrionQuickChatWrapper*                 MyQuickChatWrapper;                                // 0x02C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D0[0x60];                                     // 0x02D0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Hide();
	void OnHide();
	void OnShow();
	void Show();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTooltipBase">();
	}
	static class UOrionTooltipBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionTooltipBase>();
	}
};
static_assert(alignof(UOrionTooltipBase) == 0x000008, "Wrong alignment on UOrionTooltipBase");
static_assert(sizeof(UOrionTooltipBase) == 0x000330, "Wrong size on UOrionTooltipBase");
static_assert(offsetof(UOrionTooltipBase, bUseFadeSequence) == 0x0002B8, "Member 'UOrionTooltipBase::bUseFadeSequence' has a wrong offset!");
static_assert(offsetof(UOrionTooltipBase, Border_Contents) == 0x0002C0, "Member 'UOrionTooltipBase::Border_Contents' has a wrong offset!");
static_assert(offsetof(UOrionTooltipBase, MyQuickChatWrapper) == 0x0002C8, "Member 'UOrionTooltipBase::MyQuickChatWrapper' has a wrong offset!");

// Class OrionGame.OrionNavArea_Jump
// 0x0000 (0x0040 - 0x0040)
class UOrionNavArea_Jump final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionNavArea_Jump">();
	}
	static class UOrionNavArea_Jump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionNavArea_Jump>();
	}
};
static_assert(alignof(UOrionNavArea_Jump) == 0x000008, "Wrong alignment on UOrionNavArea_Jump");
static_assert(sizeof(UOrionNavArea_Jump) == 0x000040, "Wrong size on UOrionNavArea_Jump");

// Class OrionGame.OrionBasicTooltipWidget
// 0x0010 (0x0340 - 0x0330)
class UOrionBasicTooltipWidget : public UOrionTooltipBase
{
public:
	class UOrionTextBlock*                        Text_Title;                                        // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionTextBlock*                        Text_Body;                                         // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionBasicTooltipWidget">();
	}
	static class UOrionBasicTooltipWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionBasicTooltipWidget>();
	}
};
static_assert(alignof(UOrionBasicTooltipWidget) == 0x000008, "Wrong alignment on UOrionBasicTooltipWidget");
static_assert(sizeof(UOrionBasicTooltipWidget) == 0x000340, "Wrong size on UOrionBasicTooltipWidget");
static_assert(offsetof(UOrionBasicTooltipWidget, Text_Title) == 0x000330, "Member 'UOrionBasicTooltipWidget::Text_Title' has a wrong offset!");
static_assert(offsetof(UOrionBasicTooltipWidget, Text_Body) == 0x000338, "Member 'UOrionBasicTooltipWidget::Text_Body' has a wrong offset!");

// Class OrionGame.OrionNavFilter_TeamRed
// 0x0000 (0x0048 - 0x0048)
class UOrionNavFilter_TeamRed final : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionNavFilter_TeamRed">();
	}
	static class UOrionNavFilter_TeamRed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionNavFilter_TeamRed>();
	}
};
static_assert(alignof(UOrionNavFilter_TeamRed) == 0x000008, "Wrong alignment on UOrionNavFilter_TeamRed");
static_assert(sizeof(UOrionNavFilter_TeamRed) == 0x000048, "Wrong size on UOrionNavFilter_TeamRed");

// Class OrionGame.OrionBotAbilityPicker
// 0x0000 (0x0028 - 0x0028)
class UOrionBotAbilityPicker final : public UObject
{
public:
	static bool PickAbilityAgainstActor(class AOrionAIBot* BotAI, class AActor* TargetActor, struct FGameplayAbilitySpec* AbilitySpec);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionBotAbilityPicker">();
	}
	static class UOrionBotAbilityPicker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionBotAbilityPicker>();
	}
};
static_assert(alignof(UOrionBotAbilityPicker) == 0x000008, "Wrong alignment on UOrionBotAbilityPicker");
static_assert(sizeof(UOrionBotAbilityPicker) == 0x000028, "Wrong size on UOrionBotAbilityPicker");

// Class OrionGame.OrionBotAISpawner
// 0x0050 (0x0438 - 0x03E8)
class AOrionBotAISpawner final : public AOrionBaseActor
{
public:
	bool                                          bEnabled;                                          // 0x03E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E9[0x3];                                      // 0x03E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnDelay;                                        // 0x03EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxSpawns;                                         // 0x03F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F4[0x4];                                      // 0x03F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AOrionChar*>                     SpawnedList;                                       // 0x03F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class UOrionHeroData*>                 HeroOverrides;                                     // 0x0408(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UOrionHeroData*>                 AllowedHeroList;                                   // 0x0418(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class AOrionAIController>         AIControllerClass;                                 // 0x0428(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBehaviorTree*                          Behavior;                                          // 0x0430(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleSpawnedAIDeath(class AOrionChar* DeadChar, class AController* Killer, class AActor* DamageCauser);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionBotAISpawner">();
	}
	static class AOrionBotAISpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionBotAISpawner>();
	}
};
static_assert(alignof(AOrionBotAISpawner) == 0x000008, "Wrong alignment on AOrionBotAISpawner");
static_assert(sizeof(AOrionBotAISpawner) == 0x000438, "Wrong size on AOrionBotAISpawner");
static_assert(offsetof(AOrionBotAISpawner, bEnabled) == 0x0003E8, "Member 'AOrionBotAISpawner::bEnabled' has a wrong offset!");
static_assert(offsetof(AOrionBotAISpawner, SpawnDelay) == 0x0003EC, "Member 'AOrionBotAISpawner::SpawnDelay' has a wrong offset!");
static_assert(offsetof(AOrionBotAISpawner, MaxSpawns) == 0x0003F0, "Member 'AOrionBotAISpawner::MaxSpawns' has a wrong offset!");
static_assert(offsetof(AOrionBotAISpawner, SpawnedList) == 0x0003F8, "Member 'AOrionBotAISpawner::SpawnedList' has a wrong offset!");
static_assert(offsetof(AOrionBotAISpawner, HeroOverrides) == 0x000408, "Member 'AOrionBotAISpawner::HeroOverrides' has a wrong offset!");
static_assert(offsetof(AOrionBotAISpawner, AllowedHeroList) == 0x000418, "Member 'AOrionBotAISpawner::AllowedHeroList' has a wrong offset!");
static_assert(offsetof(AOrionBotAISpawner, AIControllerClass) == 0x000428, "Member 'AOrionBotAISpawner::AIControllerClass' has a wrong offset!");
static_assert(offsetof(AOrionBotAISpawner, Behavior) == 0x000430, "Member 'AOrionBotAISpawner::Behavior' has a wrong offset!");

// Class OrionGame.OrionBTContext_Behavior
// 0x0008 (0x0078 - 0x0070)
class UOrionBTContext_Behavior final : public UBTService
{
public:
	EOrionAIBotBehaviorContext                    BehaviorContext;                                   // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionBTContext_Behavior">();
	}
	static class UOrionBTContext_Behavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionBTContext_Behavior>();
	}
};
static_assert(alignof(UOrionBTContext_Behavior) == 0x000008, "Wrong alignment on UOrionBTContext_Behavior");
static_assert(sizeof(UOrionBTContext_Behavior) == 0x000078, "Wrong size on UOrionBTContext_Behavior");
static_assert(offsetof(UOrionBTContext_Behavior, BehaviorContext) == 0x000070, "Member 'UOrionBTContext_Behavior::BehaviorContext' has a wrong offset!");

// Class OrionGame.OrionPlayerState_Game
// 0x0AF0 (0x1400 - 0x0910)
class AOrionPlayerState_Game : public AOrionPlayerState_Base
{
public:
	uint8                                         Pad_910[0x548];                                    // 0x0910(0x0548)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionItemizationComponent*             ItemizationComponent;                              // 0x0E58(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         TotalAfkTime;                                      // 0x0E60(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastDisconnectWorldTime;                           // 0x0E64(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FNameplateAndPortrait>          BannerNameplateAndPortraitArray;                   // 0x0E68(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E78[0x4];                                      // 0x0E78(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DeathStreakCount;                                  // 0x0E7C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         KillStreakCount;                                   // 0x0E80(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E84[0x4];                                      // 0x0E84(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AOrionPlayerState_Game*>         MultiKillTargets;                                  // 0x0E88(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E98[0x4];                                      // 0x0E98(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastMultiKillTimestamp;                            // 0x0E9C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EA0[0x80];                                     // 0x0EA0(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ThrottleCount;                                     // 0x0F20(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F24[0x4];                                      // 0x0F24(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionAbilitySystemComponent*           AbilitySystemComponent;                            // 0x0F28(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionHealthSet*                        HealthSet;                                         // 0x0F30(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionCombatSet*                        CombatSet;                                         // 0x0F38(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionEnergySet*                        EnergySet;                                         // 0x0F40(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionMoveSet*                          MoveSet;                                           // 0x0F48(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionGameplaySet*                      GameplaySet;                                       // 0x0F50(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionXPSet*                            XPSet;                                             // 0x0F58(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionVisionSet*                        VisionSet;                                         // 0x0F60(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F68[0x8];                                      // 0x0F68(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayStats                         GameplayStats;                                     // 0x0F70(0x0108)(Protected, NativeAccessSpecifierProtected)
	bool                                          bCreatedForDecoy;                                  // 0x1078(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1079[0x3];                                     // 0x1079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PlayerDeathLocation;                               // 0x107C(0x000C)(Net, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TeamXPGained;                                      // 0x1088(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToRespawn;                                     // 0x108C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToSpawnPawn;                                   // 0x1090(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeSpectatorInputAllowed;                         // 0x1094(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1098[0x4];                                     // 0x1098(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AbilityPointsSpent;                                // 0x109C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AbilityPointsUnspent;                              // 0x10A0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsABadAss;                                        // 0x10A4(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasUnlimitedHealth;                               // 0x10A5(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAGod;                                           // 0x10A6(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10A7[0x1];                                     // 0x10A7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumRejoins;                                        // 0x10A8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESurrenderVote                                SurrenderVote;                                     // 0x10AC(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10AD[0x3];                                     // 0x10AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CardActivationPointsSpent;                         // 0x10B0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CardActivationPointsMax;                           // 0x10B4(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsUltimateReady;                                  // 0x10B8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAIBotDifficulty                              BotDifficultyLevelIndication;                      // 0x10B9(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10BA[0x16];                                    // 0x10BA(0x0016)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrionChar*                             CachedPawn;                                        // 0x10D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10D8[0x10];                                    // 0x10D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerStatContainer                   ReplicatedStats;                                   // 0x10E8(0x00D0)(Net, NativeAccessSpecifierPublic)
	TArray<struct FHeroDamageLogEntry>            ServerDamageLog;                                   // 0x11B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FHeroDamageLogEntry>            ClientDamageLog;                                   // 0x11C8(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11D8[0x14];                                    // 0x11D8(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LastKillerLocation;                                // 0x11EC(0x000C)(Net, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                LastDeathLocationForReplays;                       // 0x11F8(0x000C)(Net, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               LastDeathRotationForReplays;                       // 0x1204(0x000C)(Net, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	class AOrionPlayerState_Game*                 LastKiller;                                        // 0x1210(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1218[0x1D8];                                   // 0x1218(0x01D8)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AOrionTraversablePathway> OrionTraversablePathway;                           // 0x13F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugPathwayUpdateState;                           // 0x13F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13FC[0x4];                                     // 0x13FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AOrionTraversablePathway* CreatePlayerPathway(TSubclassOf<class AOrionTraversablePathway> OrionTraversablePathwayClass, const struct FVector& StartingLocation, const struct FVector& EndingLocation, class AOrionCharHero* OptBreadCrumbActor);
	TArray<class AOrionCarriedObjective*> GetAttachedBuffs();
	void GivePlayerCardActivationPoints(int32 PointsEarned);
	void OnRep_AbilityPointsUnspent();
	void OnRep_CardActivationPointsMax();
	void OnRep_CardActivationPointsSpent();
	void OnRep_ClientDamageLog();
	void OnRep_DidRejoin();
	void OnRep_IsUltimateReady();
	void OnRep_MultiKillTargets();
	void OnRep_SurrenderVote(ESurrenderVote OldVote);
	void RequestServerPathWay(const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation);
	void ServerAbilityLevelUp(int32 InputID);
	void ServerTryToSetPlayerHeroDataSpecFromTeamSelection(const struct FOrionHeroDataSpec& InHeroDataSpec);
	void SetCardActivationPointsMax(int32 NewMaxTotal);
	void TickRecorder();
	void UpdateIsUltimateReady();

	EAIBotDifficulty GetBotDifficultyLevelIndication() const;
	int32 GetCardActivationPointsLeft() const;
	int32 GetCardActivationPointsMax() const;
	int32 GetCardActivationPointsSpent() const;
	class AOrionChar* GetCurrentPawn() const;
	ESurrenderVote GetSurrenderVote() const;
	float GetTimeLeftToRespawn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPlayerState_Game">();
	}
	static class AOrionPlayerState_Game* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionPlayerState_Game>();
	}
};
static_assert(alignof(AOrionPlayerState_Game) == 0x000008, "Wrong alignment on AOrionPlayerState_Game");
static_assert(sizeof(AOrionPlayerState_Game) == 0x001400, "Wrong size on AOrionPlayerState_Game");
static_assert(offsetof(AOrionPlayerState_Game, ItemizationComponent) == 0x000E58, "Member 'AOrionPlayerState_Game::ItemizationComponent' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, TotalAfkTime) == 0x000E60, "Member 'AOrionPlayerState_Game::TotalAfkTime' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, LastDisconnectWorldTime) == 0x000E64, "Member 'AOrionPlayerState_Game::LastDisconnectWorldTime' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, BannerNameplateAndPortraitArray) == 0x000E68, "Member 'AOrionPlayerState_Game::BannerNameplateAndPortraitArray' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, DeathStreakCount) == 0x000E7C, "Member 'AOrionPlayerState_Game::DeathStreakCount' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, KillStreakCount) == 0x000E80, "Member 'AOrionPlayerState_Game::KillStreakCount' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, MultiKillTargets) == 0x000E88, "Member 'AOrionPlayerState_Game::MultiKillTargets' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, LastMultiKillTimestamp) == 0x000E9C, "Member 'AOrionPlayerState_Game::LastMultiKillTimestamp' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, ThrottleCount) == 0x000F20, "Member 'AOrionPlayerState_Game::ThrottleCount' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, AbilitySystemComponent) == 0x000F28, "Member 'AOrionPlayerState_Game::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, HealthSet) == 0x000F30, "Member 'AOrionPlayerState_Game::HealthSet' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, CombatSet) == 0x000F38, "Member 'AOrionPlayerState_Game::CombatSet' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, EnergySet) == 0x000F40, "Member 'AOrionPlayerState_Game::EnergySet' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, MoveSet) == 0x000F48, "Member 'AOrionPlayerState_Game::MoveSet' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, GameplaySet) == 0x000F50, "Member 'AOrionPlayerState_Game::GameplaySet' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, XPSet) == 0x000F58, "Member 'AOrionPlayerState_Game::XPSet' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, VisionSet) == 0x000F60, "Member 'AOrionPlayerState_Game::VisionSet' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, GameplayStats) == 0x000F70, "Member 'AOrionPlayerState_Game::GameplayStats' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, bCreatedForDecoy) == 0x001078, "Member 'AOrionPlayerState_Game::bCreatedForDecoy' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, PlayerDeathLocation) == 0x00107C, "Member 'AOrionPlayerState_Game::PlayerDeathLocation' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, TeamXPGained) == 0x001088, "Member 'AOrionPlayerState_Game::TeamXPGained' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, TimeToRespawn) == 0x00108C, "Member 'AOrionPlayerState_Game::TimeToRespawn' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, TimeToSpawnPawn) == 0x001090, "Member 'AOrionPlayerState_Game::TimeToSpawnPawn' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, TimeSpectatorInputAllowed) == 0x001094, "Member 'AOrionPlayerState_Game::TimeSpectatorInputAllowed' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, AbilityPointsSpent) == 0x00109C, "Member 'AOrionPlayerState_Game::AbilityPointsSpent' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, AbilityPointsUnspent) == 0x0010A0, "Member 'AOrionPlayerState_Game::AbilityPointsUnspent' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, bIsABadAss) == 0x0010A4, "Member 'AOrionPlayerState_Game::bIsABadAss' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, bHasUnlimitedHealth) == 0x0010A5, "Member 'AOrionPlayerState_Game::bHasUnlimitedHealth' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, bIsAGod) == 0x0010A6, "Member 'AOrionPlayerState_Game::bIsAGod' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, NumRejoins) == 0x0010A8, "Member 'AOrionPlayerState_Game::NumRejoins' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, SurrenderVote) == 0x0010AC, "Member 'AOrionPlayerState_Game::SurrenderVote' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, CardActivationPointsSpent) == 0x0010B0, "Member 'AOrionPlayerState_Game::CardActivationPointsSpent' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, CardActivationPointsMax) == 0x0010B4, "Member 'AOrionPlayerState_Game::CardActivationPointsMax' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, bIsUltimateReady) == 0x0010B8, "Member 'AOrionPlayerState_Game::bIsUltimateReady' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, BotDifficultyLevelIndication) == 0x0010B9, "Member 'AOrionPlayerState_Game::BotDifficultyLevelIndication' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, CachedPawn) == 0x0010D0, "Member 'AOrionPlayerState_Game::CachedPawn' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, ReplicatedStats) == 0x0010E8, "Member 'AOrionPlayerState_Game::ReplicatedStats' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, ServerDamageLog) == 0x0011B8, "Member 'AOrionPlayerState_Game::ServerDamageLog' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, ClientDamageLog) == 0x0011C8, "Member 'AOrionPlayerState_Game::ClientDamageLog' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, LastKillerLocation) == 0x0011EC, "Member 'AOrionPlayerState_Game::LastKillerLocation' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, LastDeathLocationForReplays) == 0x0011F8, "Member 'AOrionPlayerState_Game::LastDeathLocationForReplays' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, LastDeathRotationForReplays) == 0x001204, "Member 'AOrionPlayerState_Game::LastDeathRotationForReplays' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, LastKiller) == 0x001210, "Member 'AOrionPlayerState_Game::LastKiller' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, OrionTraversablePathway) == 0x0013F0, "Member 'AOrionPlayerState_Game::OrionTraversablePathway' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Game, DebugPathwayUpdateState) == 0x0013F8, "Member 'AOrionPlayerState_Game::DebugPathwayUpdateState' has a wrong offset!");

// Class OrionGame.OrionPlayerState_Arcade
// 0x01C0 (0x15C0 - 0x1400)
class AOrionPlayerState_Arcade final : public AOrionPlayerState_Game
{
public:
	class UOrionArcadeEffectData*                 ArcadeEffect;                                      // 0x1400(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FArcadeBuffContainer                   Buffs;                                             // 0x1408(0x00D0)(Net, Protected, NativeAccessSpecifierProtected)
	struct FArcadeBuffContainer                   Nerfs;                                             // 0x14D8(0x00D0)(Net, Protected, NativeAccessSpecifierProtected)
	TArray<class UGameplayEffect*>                BuffEffects;                                       // 0x15A8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_15B8[0x8];                                     // 0x15B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRoundState_PostRound();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPlayerState_Arcade">();
	}
	static class AOrionPlayerState_Arcade* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionPlayerState_Arcade>();
	}
};
static_assert(alignof(AOrionPlayerState_Arcade) == 0x000008, "Wrong alignment on AOrionPlayerState_Arcade");
static_assert(sizeof(AOrionPlayerState_Arcade) == 0x0015C0, "Wrong size on AOrionPlayerState_Arcade");
static_assert(offsetof(AOrionPlayerState_Arcade, ArcadeEffect) == 0x001400, "Member 'AOrionPlayerState_Arcade::ArcadeEffect' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Arcade, Buffs) == 0x001408, "Member 'AOrionPlayerState_Arcade::Buffs' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Arcade, Nerfs) == 0x0014D8, "Member 'AOrionPlayerState_Arcade::Nerfs' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_Arcade, BuffEffects) == 0x0015A8, "Member 'AOrionPlayerState_Arcade::BuffEffects' has a wrong offset!");

// Class OrionGame.OrionBTDecorator_LoopExecution
// 0x0010 (0x0078 - 0x0068)
class UOrionBTDecorator_LoopExecution final : public UBTDecorator
{
public:
	int32                                         NumLoops;                                          // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InfiniteLoopTimeout;                               // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bInfiniteLoop : 1;                                 // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLoopOnFail : 1;                                   // 0x0070(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseTimeout : 1;                                   // 0x0070(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionBTDecorator_LoopExecution">();
	}
	static class UOrionBTDecorator_LoopExecution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionBTDecorator_LoopExecution>();
	}
};
static_assert(alignof(UOrionBTDecorator_LoopExecution) == 0x000008, "Wrong alignment on UOrionBTDecorator_LoopExecution");
static_assert(sizeof(UOrionBTDecorator_LoopExecution) == 0x000078, "Wrong size on UOrionBTDecorator_LoopExecution");
static_assert(offsetof(UOrionBTDecorator_LoopExecution, NumLoops) == 0x000068, "Member 'UOrionBTDecorator_LoopExecution::NumLoops' has a wrong offset!");
static_assert(offsetof(UOrionBTDecorator_LoopExecution, InfiniteLoopTimeout) == 0x00006C, "Member 'UOrionBTDecorator_LoopExecution::InfiniteLoopTimeout' has a wrong offset!");

// Class OrionGame.OrionBTService_GetEnemy
// 0x0030 (0x00A0 - 0x0070)
class UOrionBTService_GetEnemy final : public UBTService
{
public:
	struct FBlackboardKeySelector                 StoreInKey;                                        // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)
	float                                         MaxTimeSincePerceived;                             // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReceiveTick(class AActor* OwnerActor, float DeltaSeconds);
	float ScoreTargetEnemy(class AOrionAIController* OwnerAIController, class AActor* Enemy);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionBTService_GetEnemy">();
	}
	static class UOrionBTService_GetEnemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionBTService_GetEnemy>();
	}
};
static_assert(alignof(UOrionBTService_GetEnemy) == 0x000008, "Wrong alignment on UOrionBTService_GetEnemy");
static_assert(sizeof(UOrionBTService_GetEnemy) == 0x0000A0, "Wrong size on UOrionBTService_GetEnemy");
static_assert(offsetof(UOrionBTService_GetEnemy, StoreInKey) == 0x000070, "Member 'UOrionBTService_GetEnemy::StoreInKey' has a wrong offset!");
static_assert(offsetof(UOrionBTService_GetEnemy, MaxTimeSincePerceived) == 0x000098, "Member 'UOrionBTService_GetEnemy::MaxTimeSincePerceived' has a wrong offset!");

// Class OrionGame.OrionBTTask_GetLaneWaypoint
// 0x0000 (0x0098 - 0x0098)
class UOrionBTTask_GetLaneWaypoint final : public UBTTask_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionBTTask_GetLaneWaypoint">();
	}
	static class UOrionBTTask_GetLaneWaypoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionBTTask_GetLaneWaypoint>();
	}
};
static_assert(alignof(UOrionBTTask_GetLaneWaypoint) == 0x000008, "Wrong alignment on UOrionBTTask_GetLaneWaypoint");
static_assert(sizeof(UOrionBTTask_GetLaneWaypoint) == 0x000098, "Wrong size on UOrionBTTask_GetLaneWaypoint");

// Class OrionGame.OrionPlaylistInfoSetupData
// 0x00C0 (0x00F0 - 0x0030)
class UOrionPlaylistInfoSetupData final : public UDataAsset
{
public:
	struct FOrionPlaylistInfo                     PlaylistInfo;                                      // 0x0030(0x00C0)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPlaylistInfoSetupData">();
	}
	static class UOrionPlaylistInfoSetupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionPlaylistInfoSetupData>();
	}
};
static_assert(alignof(UOrionPlaylistInfoSetupData) == 0x000008, "Wrong alignment on UOrionPlaylistInfoSetupData");
static_assert(sizeof(UOrionPlaylistInfoSetupData) == 0x0000F0, "Wrong size on UOrionPlaylistInfoSetupData");
static_assert(offsetof(UOrionPlaylistInfoSetupData, PlaylistInfo) == 0x000030, "Member 'UOrionPlaylistInfoSetupData::PlaylistInfo' has a wrong offset!");

// Class OrionGame.OrionBTTask_MarkJungleReset
// 0x0000 (0x0070 - 0x0070)
class UOrionBTTask_MarkJungleReset final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionBTTask_MarkJungleReset">();
	}
	static class UOrionBTTask_MarkJungleReset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionBTTask_MarkJungleReset>();
	}
};
static_assert(alignof(UOrionBTTask_MarkJungleReset) == 0x000008, "Wrong alignment on UOrionBTTask_MarkJungleReset");
static_assert(sizeof(UOrionBTTask_MarkJungleReset) == 0x000070, "Wrong size on UOrionBTTask_MarkJungleReset");

// Class OrionGame.OrionBTTask_ObjectiveBehaviorResult
// 0x0008 (0x0078 - 0x0070)
class UOrionBTTask_ObjectiveBehaviorResult final : public UBTTaskNode
{
public:
	EBotObjectiveBehaviorResult                   BehaviorResult;                                    // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionBTTask_ObjectiveBehaviorResult">();
	}
	static class UOrionBTTask_ObjectiveBehaviorResult* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionBTTask_ObjectiveBehaviorResult>();
	}
};
static_assert(alignof(UOrionBTTask_ObjectiveBehaviorResult) == 0x000008, "Wrong alignment on UOrionBTTask_ObjectiveBehaviorResult");
static_assert(sizeof(UOrionBTTask_ObjectiveBehaviorResult) == 0x000078, "Wrong size on UOrionBTTask_ObjectiveBehaviorResult");
static_assert(offsetof(UOrionBTTask_ObjectiveBehaviorResult, BehaviorResult) == 0x000070, "Member 'UOrionBTTask_ObjectiveBehaviorResult::BehaviorResult' has a wrong offset!");

// Class OrionGame.OrionBTTask_ObjectiveGraphMove
// 0x0000 (0x00E8 - 0x00E8)
class UOrionBTTask_ObjectiveGraphMove final : public UOrionBTTask_ParametrizedMoveTo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionBTTask_ObjectiveGraphMove">();
	}
	static class UOrionBTTask_ObjectiveGraphMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionBTTask_ObjectiveGraphMove>();
	}
};
static_assert(alignof(UOrionBTTask_ObjectiveGraphMove) == 0x000008, "Wrong alignment on UOrionBTTask_ObjectiveGraphMove");
static_assert(sizeof(UOrionBTTask_ObjectiveGraphMove) == 0x0000E8, "Wrong size on UOrionBTTask_ObjectiveGraphMove");

// Class OrionGame.OrionBTTask_StopMovement
// 0x0000 (0x0070 - 0x0070)
class UOrionBTTask_StopMovement final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionBTTask_StopMovement">();
	}
	static class UOrionBTTask_StopMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionBTTask_StopMovement>();
	}
};
static_assert(alignof(UOrionBTTask_StopMovement) == 0x000008, "Wrong alignment on UOrionBTTask_StopMovement");
static_assert(sizeof(UOrionBTTask_StopMovement) == 0x000070, "Wrong size on UOrionBTTask_StopMovement");

// Class OrionGame.OrionCameraComponent_DeathCam
// 0x0140 (0x0960 - 0x0820)
class UOrionCameraComponent_DeathCam final : public UCameraComponent
{
public:
	struct FOrionChaseCameraHelper                ChaseImplementation;                               // 0x0820(0x0120)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_940[0x20];                                     // 0x0940(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAutoFollow(bool bNewAutoFollow);
	void SetLazyAutoFollow(bool bNewLazyAutoFollow);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCameraComponent_DeathCam">();
	}
	static class UOrionCameraComponent_DeathCam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionCameraComponent_DeathCam>();
	}
};
static_assert(alignof(UOrionCameraComponent_DeathCam) == 0x000010, "Wrong alignment on UOrionCameraComponent_DeathCam");
static_assert(sizeof(UOrionCameraComponent_DeathCam) == 0x000960, "Wrong size on UOrionCameraComponent_DeathCam");
static_assert(offsetof(UOrionCameraComponent_DeathCam, ChaseImplementation) == 0x000820, "Member 'UOrionCameraComponent_DeathCam::ChaseImplementation' has a wrong offset!");

// Class OrionGame.OrionCameraMode
// 0x0120 (0x0148 - 0x0028)
class UOrionCameraMode : public UObject
{
public:
	class UOrionCameraComponent*                  OwnerComponent;                                    // 0x0028(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCameraModeView                        View;                                              // 0x0030(0x0028)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	ECameraModeType                               CameraType;                                        // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FieldOfView;                                       // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ViewPitchMin;                                      // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ViewPitchMax;                                      // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlendTime;                                         // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECameraModeBlendFunction                      BlendFunction;                                     // 0x006C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendExponent;                                     // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlendAlpha;                                        // 0x0074(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlendWeight;                                       // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCameraViewOffset                      ThirdPersonOffsets;                                // 0x0080(0x0040)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FCameraAutoCharacterOffsets            AutoThirdPersonOffsets;                            // 0x00C0(0x0014)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCameraDragSettings                    ThirdPersonDragSettings;                           // 0x00D4(0x0038)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCameraSpeedFovSettings                ThirdPersonSpeedFovSettings;                       // 0x010C(0x0018)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_124[0x10];                                     // 0x0124(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDetachedMaintainsTargetHeight;                    // 0x0134(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_135[0x3];                                      // 0x0135(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DetachedHeightOffset;                              // 0x0138(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DetachedHeightInterpSpeed;                         // 0x013C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDetachedRotatesToTarget;                          // 0x0140(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_141[0x3];                                      // 0x0141(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DetachedRotationInterpSpeed;                       // 0x0144(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCameraMode">();
	}
	static class UOrionCameraMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionCameraMode>();
	}
};
static_assert(alignof(UOrionCameraMode) == 0x000008, "Wrong alignment on UOrionCameraMode");
static_assert(sizeof(UOrionCameraMode) == 0x000148, "Wrong size on UOrionCameraMode");
static_assert(offsetof(UOrionCameraMode, OwnerComponent) == 0x000028, "Member 'UOrionCameraMode::OwnerComponent' has a wrong offset!");
static_assert(offsetof(UOrionCameraMode, View) == 0x000030, "Member 'UOrionCameraMode::View' has a wrong offset!");
static_assert(offsetof(UOrionCameraMode, CameraType) == 0x000058, "Member 'UOrionCameraMode::CameraType' has a wrong offset!");
static_assert(offsetof(UOrionCameraMode, FieldOfView) == 0x00005C, "Member 'UOrionCameraMode::FieldOfView' has a wrong offset!");
static_assert(offsetof(UOrionCameraMode, ViewPitchMin) == 0x000060, "Member 'UOrionCameraMode::ViewPitchMin' has a wrong offset!");
static_assert(offsetof(UOrionCameraMode, ViewPitchMax) == 0x000064, "Member 'UOrionCameraMode::ViewPitchMax' has a wrong offset!");
static_assert(offsetof(UOrionCameraMode, BlendTime) == 0x000068, "Member 'UOrionCameraMode::BlendTime' has a wrong offset!");
static_assert(offsetof(UOrionCameraMode, BlendFunction) == 0x00006C, "Member 'UOrionCameraMode::BlendFunction' has a wrong offset!");
static_assert(offsetof(UOrionCameraMode, BlendExponent) == 0x000070, "Member 'UOrionCameraMode::BlendExponent' has a wrong offset!");
static_assert(offsetof(UOrionCameraMode, BlendAlpha) == 0x000074, "Member 'UOrionCameraMode::BlendAlpha' has a wrong offset!");
static_assert(offsetof(UOrionCameraMode, BlendWeight) == 0x000078, "Member 'UOrionCameraMode::BlendWeight' has a wrong offset!");
static_assert(offsetof(UOrionCameraMode, ThirdPersonOffsets) == 0x000080, "Member 'UOrionCameraMode::ThirdPersonOffsets' has a wrong offset!");
static_assert(offsetof(UOrionCameraMode, AutoThirdPersonOffsets) == 0x0000C0, "Member 'UOrionCameraMode::AutoThirdPersonOffsets' has a wrong offset!");
static_assert(offsetof(UOrionCameraMode, ThirdPersonDragSettings) == 0x0000D4, "Member 'UOrionCameraMode::ThirdPersonDragSettings' has a wrong offset!");
static_assert(offsetof(UOrionCameraMode, ThirdPersonSpeedFovSettings) == 0x00010C, "Member 'UOrionCameraMode::ThirdPersonSpeedFovSettings' has a wrong offset!");
static_assert(offsetof(UOrionCameraMode, bDetachedMaintainsTargetHeight) == 0x000134, "Member 'UOrionCameraMode::bDetachedMaintainsTargetHeight' has a wrong offset!");
static_assert(offsetof(UOrionCameraMode, DetachedHeightOffset) == 0x000138, "Member 'UOrionCameraMode::DetachedHeightOffset' has a wrong offset!");
static_assert(offsetof(UOrionCameraMode, DetachedHeightInterpSpeed) == 0x00013C, "Member 'UOrionCameraMode::DetachedHeightInterpSpeed' has a wrong offset!");
static_assert(offsetof(UOrionCameraMode, bDetachedRotatesToTarget) == 0x000140, "Member 'UOrionCameraMode::bDetachedRotatesToTarget' has a wrong offset!");
static_assert(offsetof(UOrionCameraMode, DetachedRotationInterpSpeed) == 0x000144, "Member 'UOrionCameraMode::DetachedRotationInterpSpeed' has a wrong offset!");

// Class OrionGame.OrionHeroRevenantAnimInstance
// 0x0000 (0x11C0 - 0x11C0)
class UOrionHeroRevenantAnimInstance final : public UOrionHeroAnimInstance
{
public:
	float                                         TargetingHandScaleAlpha;                           // 0x11B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AbilityHandScaleAlpha;                             // 0x11BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHeroRevenantAnimInstance">();
	}
	static class UOrionHeroRevenantAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHeroRevenantAnimInstance>();
	}
};
static_assert(alignof(UOrionHeroRevenantAnimInstance) == 0x000010, "Wrong alignment on UOrionHeroRevenantAnimInstance");
static_assert(sizeof(UOrionHeroRevenantAnimInstance) == 0x0011C0, "Wrong size on UOrionHeroRevenantAnimInstance");
static_assert(offsetof(UOrionHeroRevenantAnimInstance, TargetingHandScaleAlpha) == 0x0011B8, "Member 'UOrionHeroRevenantAnimInstance::TargetingHandScaleAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroRevenantAnimInstance, AbilityHandScaleAlpha) == 0x0011BC, "Member 'UOrionHeroRevenantAnimInstance::AbilityHandScaleAlpha' has a wrong offset!");

// Class OrionGame.OrionPartyBeaconHost
// 0x0100 (0x05A0 - 0x04A0)
class AOrionPartyBeaconHost final : public APartyBeaconHost
{
public:
	class UOrionPartyBeaconState*                 OrionState;                                        // 0x04A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReservationsLocked;                               // 0x04A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A9[0xD7];                                     // 0x04A9(0x00D7)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VerifyAllTeamsReadyDelay;                          // 0x0580(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_584[0x1C];                                     // 0x0584(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPartyBeaconHost">();
	}
	static class AOrionPartyBeaconHost* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionPartyBeaconHost>();
	}
};
static_assert(alignof(AOrionPartyBeaconHost) == 0x000008, "Wrong alignment on AOrionPartyBeaconHost");
static_assert(sizeof(AOrionPartyBeaconHost) == 0x0005A0, "Wrong size on AOrionPartyBeaconHost");
static_assert(offsetof(AOrionPartyBeaconHost, OrionState) == 0x0004A0, "Member 'AOrionPartyBeaconHost::OrionState' has a wrong offset!");
static_assert(offsetof(AOrionPartyBeaconHost, bReservationsLocked) == 0x0004A8, "Member 'AOrionPartyBeaconHost::bReservationsLocked' has a wrong offset!");
static_assert(offsetof(AOrionPartyBeaconHost, VerifyAllTeamsReadyDelay) == 0x000580, "Member 'AOrionPartyBeaconHost::VerifyAllTeamsReadyDelay' has a wrong offset!");

// Class OrionGame.OrionViewKick
// 0x0028 (0x0050 - 0x0028)
class UOrionViewKick : public UObject
{
public:
	struct FOrionViewKickRangedValue              DirectionalKickAngle;                              // 0x0028(0x0008)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FOrionViewKickRangedValue              DirectionalKickMagnitude;                          // 0x0030(0x0008)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EOrionViewKickRotationalDirection             RollKickDirection;                                 // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionViewKickRangedValue              RollKickMagnitude;                                 // 0x003C(0x0008)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_44[0xC];                                       // 0x0044(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionViewKick">();
	}
	static class UOrionViewKick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionViewKick>();
	}
};
static_assert(alignof(UOrionViewKick) == 0x000008, "Wrong alignment on UOrionViewKick");
static_assert(sizeof(UOrionViewKick) == 0x000050, "Wrong size on UOrionViewKick");
static_assert(offsetof(UOrionViewKick, DirectionalKickAngle) == 0x000028, "Member 'UOrionViewKick::DirectionalKickAngle' has a wrong offset!");
static_assert(offsetof(UOrionViewKick, DirectionalKickMagnitude) == 0x000030, "Member 'UOrionViewKick::DirectionalKickMagnitude' has a wrong offset!");
static_assert(offsetof(UOrionViewKick, RollKickDirection) == 0x000038, "Member 'UOrionViewKick::RollKickDirection' has a wrong offset!");
static_assert(offsetof(UOrionViewKick, RollKickMagnitude) == 0x00003C, "Member 'UOrionViewKick::RollKickMagnitude' has a wrong offset!");

// Class OrionGame.OrionViewKick_Spring
// 0x0048 (0x0098 - 0x0050)
class UOrionViewKick_Spring : public UOrionViewKick
{
public:
	float                                         SpringDampeningRatio;                              // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpringStiffness;                                   // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x40];                                      // 0x0058(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionViewKick_Spring">();
	}
	static class UOrionViewKick_Spring* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionViewKick_Spring>();
	}
};
static_assert(alignof(UOrionViewKick_Spring) == 0x000008, "Wrong alignment on UOrionViewKick_Spring");
static_assert(sizeof(UOrionViewKick_Spring) == 0x000098, "Wrong size on UOrionViewKick_Spring");
static_assert(offsetof(UOrionViewKick_Spring, SpringDampeningRatio) == 0x000050, "Member 'UOrionViewKick_Spring::SpringDampeningRatio' has a wrong offset!");
static_assert(offsetof(UOrionViewKick_Spring, SpringStiffness) == 0x000054, "Member 'UOrionViewKick_Spring::SpringStiffness' has a wrong offset!");

// Class OrionGame.OrionViewKick_Interpolated
// 0x0028 (0x0078 - 0x0050)
class UOrionViewKick_Interpolated final : public UOrionViewKick
{
public:
	float                                         InterpKickSpeed;                                   // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InterpReturnSpeed;                                 // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x20];                                      // 0x0058(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionViewKick_Interpolated">();
	}
	static class UOrionViewKick_Interpolated* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionViewKick_Interpolated>();
	}
};
static_assert(alignof(UOrionViewKick_Interpolated) == 0x000008, "Wrong alignment on UOrionViewKick_Interpolated");
static_assert(sizeof(UOrionViewKick_Interpolated) == 0x000078, "Wrong size on UOrionViewKick_Interpolated");
static_assert(offsetof(UOrionViewKick_Interpolated, InterpKickSpeed) == 0x000050, "Member 'UOrionViewKick_Interpolated::InterpKickSpeed' has a wrong offset!");
static_assert(offsetof(UOrionViewKick_Interpolated, InterpReturnSpeed) == 0x000054, "Member 'UOrionViewKick_Interpolated::InterpReturnSpeed' has a wrong offset!");

// Class OrionGame.OrionPartyGameState
// 0x0088 (0x0660 - 0x05D8)
class UOrionPartyGameState : public UPartyGameState
{
public:
	class UEnum*                                  DirtyFlagEnum;                                     // 0x05D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E0[0x80];                                     // 0x05E0(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPartyGameState">();
	}
	static class UOrionPartyGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionPartyGameState>();
	}
};
static_assert(alignof(UOrionPartyGameState) == 0x000008, "Wrong alignment on UOrionPartyGameState");
static_assert(sizeof(UOrionPartyGameState) == 0x000660, "Wrong size on UOrionPartyGameState");
static_assert(offsetof(UOrionPartyGameState, DirtyFlagEnum) == 0x0005D8, "Member 'UOrionPartyGameState::DirtyFlagEnum' has a wrong offset!");

// Class OrionGame.OrionCameraModifier_ViewKick
// 0x0010 (0x0058 - 0x0048)
class UOrionCameraModifier_ViewKick final : public UCameraModifier
{
public:
	TArray<class UOrionViewKick*>                 ViewKicksInstances;                                // 0x0048(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCameraModifier_ViewKick">();
	}
	static class UOrionCameraModifier_ViewKick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionCameraModifier_ViewKick>();
	}
};
static_assert(alignof(UOrionCameraModifier_ViewKick) == 0x000008, "Wrong alignment on UOrionCameraModifier_ViewKick");
static_assert(sizeof(UOrionCameraModifier_ViewKick) == 0x000058, "Wrong size on UOrionCameraModifier_ViewKick");
static_assert(offsetof(UOrionCameraModifier_ViewKick, ViewKicksInstances) == 0x000048, "Member 'UOrionCameraModifier_ViewKick::ViewKicksInstances' has a wrong offset!");

// Class OrionGame.OrionCardAbility
// 0x0030 (0x0BA0 - 0x0B70)
class UOrionCardAbility : public UOrionAbility
{
public:
	bool                                          bIsEventTriggered;                                 // 0x0B70(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B71[0x7];                                      // 0x0B71(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityTargetDataHandle       AbilityTargets;                                    // 0x0B78(0x0020)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_B98[0x8];                                      // 0x0B98(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const struct FGameplayAbilityTargetDataHandle GetCardTargets() const;
	bool WasTriggeredFromEvent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCardAbility">();
	}
	static class UOrionCardAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionCardAbility>();
	}
};
static_assert(alignof(UOrionCardAbility) == 0x000010, "Wrong alignment on UOrionCardAbility");
static_assert(sizeof(UOrionCardAbility) == 0x000BA0, "Wrong size on UOrionCardAbility");
static_assert(offsetof(UOrionCardAbility, bIsEventTriggered) == 0x000B70, "Member 'UOrionCardAbility::bIsEventTriggered' has a wrong offset!");
static_assert(offsetof(UOrionCardAbility, AbilityTargets) == 0x000B78, "Member 'UOrionCardAbility::AbilityTargets' has a wrong offset!");

// Class OrionGame.OrionCardDisplayData
// 0x0E18 (0x0E48 - 0x0030)
class UOrionCardDisplayData final : public UDataAsset
{
public:
	class UTexture2D*                             DefaultCardArt;                                    // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            VignetteBrush;                                     // 0x0038(0x0078)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrush                            GlossBrush;                                        // 0x00B0(0x0078)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FVector2D                              FullCardSize;                                      // 0x0128(0x0008)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              InnerCardContentSize;                              // 0x0130(0x0008)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinScaleForShowingText;                            // 0x0138(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCardAffinityDisplayInfo               Affinities[0x6];                                   // 0x0140(0x00D8)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrush                            CostVignetteBrush;                                 // 0x0650(0x0078)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     GoldIconMaterial;                                  // 0x06C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     CostPipIconMaterials[0x3];                         // 0x06D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionTextFormatInfo                   CostEntryTextFormat;                               // 0x06E8(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FMargin                                CostInfoPadding;                                   // 0x06F8(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              CostIconSize;                                      // 0x0708(0x0008)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PipCostIconRenderScale;                            // 0x0710(0x0008)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             NameBannerMaterial;                                // 0x0718(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMargin                                NamePadding;                                       // 0x0720(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         NameBannerWidth;                                   // 0x0730(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_734[0x4];                                      // 0x0734(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionTextFormatInfo                   NameTextFormat;                                    // 0x0738(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FMargin                                LevelPadding;                                      // 0x0748(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FOrionTextFormatInfo                   LevelTextFormat;                                   // 0x0758(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     RetainerFoilMaterial;                              // 0x0768(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              BigFlareBrushSize;                                 // 0x0770(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SmallFlareBrushSize;                               // 0x0778(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionCardLevelTierFlareLayout         TopFlareLayout;                                    // 0x0780(0x0038)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FOrionCardLevelTierFlareLayout         BottomFlareLayout;                                 // 0x07B8(0x0038)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FOrionCardLevelTierInfo                LevelTiers[0x4];                                   // 0x07F0(0x0040)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              StatEntryIconSize;                                 // 0x08F0(0x0008)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMargin                                StatsPadding;                                      // 0x08F8(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FOrionTextFormatInfo                   StatEntryTextFormat;                               // 0x0908(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class UTexture2D*                             ActivatableAbilityIcon;                            // 0x0918(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             PassiveAbilityIcon;                                // 0x0920(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             GenericCardTraitIcon;                              // 0x0928(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCardTraitInfo                         CardTraits[0x6];                                   // 0x0930(0x0040)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_AB0[0x398];                                    // 0x0AB0(0x0398)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCardDisplayData">();
	}
	static class UOrionCardDisplayData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionCardDisplayData>();
	}
};
static_assert(alignof(UOrionCardDisplayData) == 0x000008, "Wrong alignment on UOrionCardDisplayData");
static_assert(sizeof(UOrionCardDisplayData) == 0x000E48, "Wrong size on UOrionCardDisplayData");
static_assert(offsetof(UOrionCardDisplayData, DefaultCardArt) == 0x000030, "Member 'UOrionCardDisplayData::DefaultCardArt' has a wrong offset!");
static_assert(offsetof(UOrionCardDisplayData, VignetteBrush) == 0x000038, "Member 'UOrionCardDisplayData::VignetteBrush' has a wrong offset!");
static_assert(offsetof(UOrionCardDisplayData, GlossBrush) == 0x0000B0, "Member 'UOrionCardDisplayData::GlossBrush' has a wrong offset!");
static_assert(offsetof(UOrionCardDisplayData, FullCardSize) == 0x000128, "Member 'UOrionCardDisplayData::FullCardSize' has a wrong offset!");
static_assert(offsetof(UOrionCardDisplayData, InnerCardContentSize) == 0x000130, "Member 'UOrionCardDisplayData::InnerCardContentSize' has a wrong offset!");
static_assert(offsetof(UOrionCardDisplayData, MinScaleForShowingText) == 0x000138, "Member 'UOrionCardDisplayData::MinScaleForShowingText' has a wrong offset!");
static_assert(offsetof(UOrionCardDisplayData, Affinities) == 0x000140, "Member 'UOrionCardDisplayData::Affinities' has a wrong offset!");
static_assert(offsetof(UOrionCardDisplayData, CostVignetteBrush) == 0x000650, "Member 'UOrionCardDisplayData::CostVignetteBrush' has a wrong offset!");
static_assert(offsetof(UOrionCardDisplayData, GoldIconMaterial) == 0x0006C8, "Member 'UOrionCardDisplayData::GoldIconMaterial' has a wrong offset!");
static_assert(offsetof(UOrionCardDisplayData, CostPipIconMaterials) == 0x0006D0, "Member 'UOrionCardDisplayData::CostPipIconMaterials' has a wrong offset!");
static_assert(offsetof(UOrionCardDisplayData, CostEntryTextFormat) == 0x0006E8, "Member 'UOrionCardDisplayData::CostEntryTextFormat' has a wrong offset!");
static_assert(offsetof(UOrionCardDisplayData, CostInfoPadding) == 0x0006F8, "Member 'UOrionCardDisplayData::CostInfoPadding' has a wrong offset!");
static_assert(offsetof(UOrionCardDisplayData, CostIconSize) == 0x000708, "Member 'UOrionCardDisplayData::CostIconSize' has a wrong offset!");
static_assert(offsetof(UOrionCardDisplayData, PipCostIconRenderScale) == 0x000710, "Member 'UOrionCardDisplayData::PipCostIconRenderScale' has a wrong offset!");
static_assert(offsetof(UOrionCardDisplayData, NameBannerMaterial) == 0x000718, "Member 'UOrionCardDisplayData::NameBannerMaterial' has a wrong offset!");
static_assert(offsetof(UOrionCardDisplayData, NamePadding) == 0x000720, "Member 'UOrionCardDisplayData::NamePadding' has a wrong offset!");
static_assert(offsetof(UOrionCardDisplayData, NameBannerWidth) == 0x000730, "Member 'UOrionCardDisplayData::NameBannerWidth' has a wrong offset!");
static_assert(offsetof(UOrionCardDisplayData, NameTextFormat) == 0x000738, "Member 'UOrionCardDisplayData::NameTextFormat' has a wrong offset!");
static_assert(offsetof(UOrionCardDisplayData, LevelPadding) == 0x000748, "Member 'UOrionCardDisplayData::LevelPadding' has a wrong offset!");
static_assert(offsetof(UOrionCardDisplayData, LevelTextFormat) == 0x000758, "Member 'UOrionCardDisplayData::LevelTextFormat' has a wrong offset!");
static_assert(offsetof(UOrionCardDisplayData, RetainerFoilMaterial) == 0x000768, "Member 'UOrionCardDisplayData::RetainerFoilMaterial' has a wrong offset!");
static_assert(offsetof(UOrionCardDisplayData, BigFlareBrushSize) == 0x000770, "Member 'UOrionCardDisplayData::BigFlareBrushSize' has a wrong offset!");
static_assert(offsetof(UOrionCardDisplayData, SmallFlareBrushSize) == 0x000778, "Member 'UOrionCardDisplayData::SmallFlareBrushSize' has a wrong offset!");
static_assert(offsetof(UOrionCardDisplayData, TopFlareLayout) == 0x000780, "Member 'UOrionCardDisplayData::TopFlareLayout' has a wrong offset!");
static_assert(offsetof(UOrionCardDisplayData, BottomFlareLayout) == 0x0007B8, "Member 'UOrionCardDisplayData::BottomFlareLayout' has a wrong offset!");
static_assert(offsetof(UOrionCardDisplayData, LevelTiers) == 0x0007F0, "Member 'UOrionCardDisplayData::LevelTiers' has a wrong offset!");
static_assert(offsetof(UOrionCardDisplayData, StatEntryIconSize) == 0x0008F0, "Member 'UOrionCardDisplayData::StatEntryIconSize' has a wrong offset!");
static_assert(offsetof(UOrionCardDisplayData, StatsPadding) == 0x0008F8, "Member 'UOrionCardDisplayData::StatsPadding' has a wrong offset!");
static_assert(offsetof(UOrionCardDisplayData, StatEntryTextFormat) == 0x000908, "Member 'UOrionCardDisplayData::StatEntryTextFormat' has a wrong offset!");
static_assert(offsetof(UOrionCardDisplayData, ActivatableAbilityIcon) == 0x000918, "Member 'UOrionCardDisplayData::ActivatableAbilityIcon' has a wrong offset!");
static_assert(offsetof(UOrionCardDisplayData, PassiveAbilityIcon) == 0x000920, "Member 'UOrionCardDisplayData::PassiveAbilityIcon' has a wrong offset!");
static_assert(offsetof(UOrionCardDisplayData, GenericCardTraitIcon) == 0x000928, "Member 'UOrionCardDisplayData::GenericCardTraitIcon' has a wrong offset!");
static_assert(offsetof(UOrionCardDisplayData, CardTraits) == 0x000930, "Member 'UOrionCardDisplayData::CardTraits' has a wrong offset!");

// Class OrionGame.OrionMiniMapDisplayData
// 0x00F0 (0x0120 - 0x0030)
class UOrionMiniMapDisplayData final : public UDataAsset
{
public:
	struct FLinearColor                           JungleCampColors[0xA];                             // 0x0030(0x0010)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FLinearColor> JungleCampColorsMap;                               // 0x00D0(0x0050)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMiniMapDisplayData">();
	}
	static class UOrionMiniMapDisplayData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMiniMapDisplayData>();
	}
};
static_assert(alignof(UOrionMiniMapDisplayData) == 0x000008, "Wrong alignment on UOrionMiniMapDisplayData");
static_assert(sizeof(UOrionMiniMapDisplayData) == 0x000120, "Wrong size on UOrionMiniMapDisplayData");
static_assert(offsetof(UOrionMiniMapDisplayData, JungleCampColors) == 0x000030, "Member 'UOrionMiniMapDisplayData::JungleCampColors' has a wrong offset!");
static_assert(offsetof(UOrionMiniMapDisplayData, JungleCampColorsMap) == 0x0000D0, "Member 'UOrionMiniMapDisplayData::JungleCampColorsMap' has a wrong offset!");

// Class OrionGame.OrionCarriedObjectiveInterface
// 0x0000 (0x0028 - 0x0028)
class IOrionCarriedObjectiveInterface final : public IInterface
{
public:
	void ObjectiveScored(class AActor* ScoringActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCarriedObjectiveInterface">();
	}
	static class IOrionCarriedObjectiveInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOrionCarriedObjectiveInterface>();
	}
};
static_assert(alignof(IOrionCarriedObjectiveInterface) == 0x000008, "Wrong alignment on IOrionCarriedObjectiveInterface");
static_assert(sizeof(IOrionCarriedObjectiveInterface) == 0x000028, "Wrong size on IOrionCarriedObjectiveInterface");

// Class OrionGame.OrionMinionAnimInstance
// 0x0818 (0x0C30 - 0x0418)
class UOrionMinionAnimInstance : public UOrionAnimInstance
{
public:
	bool                                          bHasKnockBackTag;                                  // 0x0418(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasKnockUpTag;                                    // 0x0419(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasStunTag;                                       // 0x041A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasCombatTag;                                     // 0x041B(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasLastHitVulnerableTag;                          // 0x041C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41D[0x3];                                      // 0x041D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastAggroTime;                                     // 0x0420(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AggroNotifyCooldown;                               // 0x0424(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastHitReactTime;                                  // 0x0428(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitReactCooldown;                                  // 0x042C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPoseTimeOffset;                                 // 0x0430(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPoseIndex;                                      // 0x0434(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LookAtOffset;                                      // 0x0438(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EAxisOption                                   ForwardAimingAxis;                                 // 0x0444(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_445[0x3];                                      // 0x0445(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoneReference                         SplitBodyBone;                                     // 0x0448(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsPlayingDeath;                                   // 0x0460(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_461[0xF];                                      // 0x0461(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionMinionAnimInstanceProxy          Proxy;                                             // 0x0470(0x0760)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BD0[0x60];                                     // 0x0BD0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelBehavior(EOrionMinionPrioritizedBehavior Behavior);
	void RequestBehavior(EOrionMinionPrioritizedBehavior Behavior, int32 PlayIndex, bool bLooping);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMinionAnimInstance">();
	}
	static class UOrionMinionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMinionAnimInstance>();
	}
};
static_assert(alignof(UOrionMinionAnimInstance) == 0x000010, "Wrong alignment on UOrionMinionAnimInstance");
static_assert(sizeof(UOrionMinionAnimInstance) == 0x000C30, "Wrong size on UOrionMinionAnimInstance");
static_assert(offsetof(UOrionMinionAnimInstance, bHasKnockBackTag) == 0x000418, "Member 'UOrionMinionAnimInstance::bHasKnockBackTag' has a wrong offset!");
static_assert(offsetof(UOrionMinionAnimInstance, bHasKnockUpTag) == 0x000419, "Member 'UOrionMinionAnimInstance::bHasKnockUpTag' has a wrong offset!");
static_assert(offsetof(UOrionMinionAnimInstance, bHasStunTag) == 0x00041A, "Member 'UOrionMinionAnimInstance::bHasStunTag' has a wrong offset!");
static_assert(offsetof(UOrionMinionAnimInstance, bHasCombatTag) == 0x00041B, "Member 'UOrionMinionAnimInstance::bHasCombatTag' has a wrong offset!");
static_assert(offsetof(UOrionMinionAnimInstance, bHasLastHitVulnerableTag) == 0x00041C, "Member 'UOrionMinionAnimInstance::bHasLastHitVulnerableTag' has a wrong offset!");
static_assert(offsetof(UOrionMinionAnimInstance, LastAggroTime) == 0x000420, "Member 'UOrionMinionAnimInstance::LastAggroTime' has a wrong offset!");
static_assert(offsetof(UOrionMinionAnimInstance, AggroNotifyCooldown) == 0x000424, "Member 'UOrionMinionAnimInstance::AggroNotifyCooldown' has a wrong offset!");
static_assert(offsetof(UOrionMinionAnimInstance, LastHitReactTime) == 0x000428, "Member 'UOrionMinionAnimInstance::LastHitReactTime' has a wrong offset!");
static_assert(offsetof(UOrionMinionAnimInstance, HitReactCooldown) == 0x00042C, "Member 'UOrionMinionAnimInstance::HitReactCooldown' has a wrong offset!");
static_assert(offsetof(UOrionMinionAnimInstance, MaxPoseTimeOffset) == 0x000430, "Member 'UOrionMinionAnimInstance::MaxPoseTimeOffset' has a wrong offset!");
static_assert(offsetof(UOrionMinionAnimInstance, MaxPoseIndex) == 0x000434, "Member 'UOrionMinionAnimInstance::MaxPoseIndex' has a wrong offset!");
static_assert(offsetof(UOrionMinionAnimInstance, LookAtOffset) == 0x000438, "Member 'UOrionMinionAnimInstance::LookAtOffset' has a wrong offset!");
static_assert(offsetof(UOrionMinionAnimInstance, ForwardAimingAxis) == 0x000444, "Member 'UOrionMinionAnimInstance::ForwardAimingAxis' has a wrong offset!");
static_assert(offsetof(UOrionMinionAnimInstance, SplitBodyBone) == 0x000448, "Member 'UOrionMinionAnimInstance::SplitBodyBone' has a wrong offset!");
static_assert(offsetof(UOrionMinionAnimInstance, bIsPlayingDeath) == 0x000460, "Member 'UOrionMinionAnimInstance::bIsPlayingDeath' has a wrong offset!");
static_assert(offsetof(UOrionMinionAnimInstance, Proxy) == 0x000470, "Member 'UOrionMinionAnimInstance::Proxy' has a wrong offset!");

// Class OrionGame.OrionCharAI_JungleBoss
// 0x01B0 (0x0D80 - 0x0BD0)
class AOrionCharAI_JungleBoss : public AOrionCharAI
{
public:
	uint8                                         Pad_BD0[0x8];                                      // 0x0BD0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrionChar*                             CachedBestTarget;                                  // 0x0BD8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumBasicAttacksBetweenSpecial;                     // 0x0BE0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BE4[0x4];                                      // 0x0BE4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 SpecialAttackPattern;                              // 0x0BE8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         bGlobalRelevanceOnSpawn : 1;                       // 0x0BF8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAutoPlaySpawning : 1;                             // 0x0BF8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bRegisterInVisionManager : 1;                      // 0x0BF8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         BitPad_BF8_3 : 2;                                  // 0x0BF8(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bFinishedSpawning : 1;                             // 0x0BF8(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         BitPad_BF8_6 : 1;                                  // 0x0BF8(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bIsDoingSpawnAbility : 1;                          // 0x0BF8(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_BF9[0x3];                                      // 0x0BF9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PackedAnimRequest;                                 // 0x0BFC(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class AOrionPickup>>       CarriedBuffPerLevel;                               // 0x0C00(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	float                                         MaxDropBoxRadius;                                  // 0x0C10(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECarriedBuffType                              CarriedBuffTypeOverride;                           // 0x0C14(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C15[0x3];                                      // 0x0C15(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeathMaterialFadeDelay;                            // 0x0C18(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DeathAnimDuration;                                 // 0x0C1C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           DeathAnim;                                         // 0x0C20(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     DeathMaterial;                                     // 0x0C28(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DeathMaterialParameterName;                        // 0x0C30(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            CharacterMaterialFadeCurve;                        // 0x0C38(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            DeathMaterialFadeCurve;                            // 0x0C40(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               DeathEffectMID;                                    // 0x0C48(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C50[0x120];                                    // 0x0C50(0x0120)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasDependencies;                                  // 0x0D70(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDependenciesDead;                                 // 0x0D71(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDependenciesChecked;                              // 0x0D72(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D73[0xD];                                      // 0x0D73(0x000D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnableIndicators();
	void HandleCallForHelp(class AActor* DamagedActor, class AActor* AttackingActor, const struct FGameplayEffectSpec& EffectSpec);
	void MarkFailedAttackAttempt();
	void OnRep_PackedAnimRequest();
	void PlayExpandingKnockback(TSubclassOf<class UGameplayEffect> AppliedEffect, float RadiusStart, float RadiusEnd, float ExpansionTime);
	void PlaySpawningAbility();
	void RequestReplicatedAnimation(EOrionMinionPrioritizedBehavior Animation, int32 AttackId);
	void SetDependency(const struct FObjectiveDependency& Dependecy);

	class AOrionChar* GetBestTarget(EOrionJungleTarget Mode) const;
	class AOrionChar* GetCurrentTarget() const;
	bool HasFinishedSpawning() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCharAI_JungleBoss">();
	}
	static class AOrionCharAI_JungleBoss* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionCharAI_JungleBoss>();
	}
};
static_assert(alignof(AOrionCharAI_JungleBoss) == 0x000010, "Wrong alignment on AOrionCharAI_JungleBoss");
static_assert(sizeof(AOrionCharAI_JungleBoss) == 0x000D80, "Wrong size on AOrionCharAI_JungleBoss");
static_assert(offsetof(AOrionCharAI_JungleBoss, CachedBestTarget) == 0x000BD8, "Member 'AOrionCharAI_JungleBoss::CachedBestTarget' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_JungleBoss, NumBasicAttacksBetweenSpecial) == 0x000BE0, "Member 'AOrionCharAI_JungleBoss::NumBasicAttacksBetweenSpecial' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_JungleBoss, SpecialAttackPattern) == 0x000BE8, "Member 'AOrionCharAI_JungleBoss::SpecialAttackPattern' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_JungleBoss, PackedAnimRequest) == 0x000BFC, "Member 'AOrionCharAI_JungleBoss::PackedAnimRequest' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_JungleBoss, CarriedBuffPerLevel) == 0x000C00, "Member 'AOrionCharAI_JungleBoss::CarriedBuffPerLevel' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_JungleBoss, MaxDropBoxRadius) == 0x000C10, "Member 'AOrionCharAI_JungleBoss::MaxDropBoxRadius' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_JungleBoss, CarriedBuffTypeOverride) == 0x000C14, "Member 'AOrionCharAI_JungleBoss::CarriedBuffTypeOverride' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_JungleBoss, DeathMaterialFadeDelay) == 0x000C18, "Member 'AOrionCharAI_JungleBoss::DeathMaterialFadeDelay' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_JungleBoss, DeathAnimDuration) == 0x000C1C, "Member 'AOrionCharAI_JungleBoss::DeathAnimDuration' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_JungleBoss, DeathAnim) == 0x000C20, "Member 'AOrionCharAI_JungleBoss::DeathAnim' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_JungleBoss, DeathMaterial) == 0x000C28, "Member 'AOrionCharAI_JungleBoss::DeathMaterial' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_JungleBoss, DeathMaterialParameterName) == 0x000C30, "Member 'AOrionCharAI_JungleBoss::DeathMaterialParameterName' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_JungleBoss, CharacterMaterialFadeCurve) == 0x000C38, "Member 'AOrionCharAI_JungleBoss::CharacterMaterialFadeCurve' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_JungleBoss, DeathMaterialFadeCurve) == 0x000C40, "Member 'AOrionCharAI_JungleBoss::DeathMaterialFadeCurve' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_JungleBoss, DeathEffectMID) == 0x000C48, "Member 'AOrionCharAI_JungleBoss::DeathEffectMID' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_JungleBoss, bHasDependencies) == 0x000D70, "Member 'AOrionCharAI_JungleBoss::bHasDependencies' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_JungleBoss, bDependenciesDead) == 0x000D71, "Member 'AOrionCharAI_JungleBoss::bDependenciesDead' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_JungleBoss, bDependenciesChecked) == 0x000D72, "Member 'AOrionCharAI_JungleBoss::bDependenciesChecked' has a wrong offset!");

// Class OrionGame.OrionNavArea_TowerObstacle
// 0x0000 (0x0040 - 0x0040)
class UOrionNavArea_TowerObstacle final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionNavArea_TowerObstacle">();
	}
	static class UOrionNavArea_TowerObstacle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionNavArea_TowerObstacle>();
	}
};
static_assert(alignof(UOrionNavArea_TowerObstacle) == 0x000008, "Wrong alignment on UOrionNavArea_TowerObstacle");
static_assert(sizeof(UOrionNavArea_TowerObstacle) == 0x000040, "Wrong size on UOrionNavArea_TowerObstacle");

// Class OrionGame.OrionCharAI_JungleOld
// 0x0010 (0x0DF0 - 0x0DE0)
class AOrionCharAI_JungleOld final : public AOrionCharAI_Minion
{
public:
	TArray<TSubclassOf<class AOrionCarriedObjective>> CarriedBuffPerLevel;                               // 0x0DD8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         MaxDropBoxRadius;                                  // 0x0DE8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DEC[0x4];                                      // 0x0DEC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCharAI_JungleOld">();
	}
	static class AOrionCharAI_JungleOld* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionCharAI_JungleOld>();
	}
};
static_assert(alignof(AOrionCharAI_JungleOld) == 0x000010, "Wrong alignment on AOrionCharAI_JungleOld");
static_assert(sizeof(AOrionCharAI_JungleOld) == 0x000DF0, "Wrong size on AOrionCharAI_JungleOld");
static_assert(offsetof(AOrionCharAI_JungleOld, CarriedBuffPerLevel) == 0x000DD8, "Member 'AOrionCharAI_JungleOld::CarriedBuffPerLevel' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_JungleOld, MaxDropBoxRadius) == 0x000DE8, "Member 'AOrionCharAI_JungleOld::MaxDropBoxRadius' has a wrong offset!");

// Class OrionGame.OrionCharAI_PrimeHelixOld
// 0x0140 (0x0F20 - 0x0DE0)
class AOrionCharAI_PrimeHelixOld final : public AOrionCharAI_Minion
{
public:
	uint8                                         Pad_DD8[0x18];                                     // 0x0DD8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         BitPad_DF0_0 : 1;                                  // 0x0DF0(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bAutoPlayKnockback : 1;                            // 0x0DF0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_DF1[0x3];                                      // 0x0DF1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumNormalAttacksBetweenSpecial;                    // 0x0DF4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UGameplayAbility>>   SpecialAttackAbilities;                            // 0x0DF8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_E08[0x10];                                     // 0x0E08(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        ConeAttackLocations;                               // 0x0E18(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            KnockbackAttackEffect;                             // 0x0E28(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        KnockbackParticleEffect;                           // 0x0E30(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KnockbackRadiusInitial;                            // 0x0E38(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KnockbackRadiusExpanded;                           // 0x0E3C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KnockbackRadiusExpandDuration;                     // 0x0E40(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E44[0xC];                                      // 0x0E44(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        SpawnPrimeBuffEffect;                              // 0x0E50(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DelayTimeToSpawnPrimeBuff;                         // 0x0E58(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E5C[0x4];                                      // 0x0E5C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AOrionCarriedObjective>     CarriedBuffPrimeHelix;                             // 0x0E60(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 LockOnTarget;                                      // 0x0E68(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PackedAnimRequest;                                 // 0x0E70(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E74[0x4C];                                     // 0x0E74(0x004C)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrionCharAISpawner*                    CachedSpawner;                                     // 0x0EC0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EC8[0x58];                                     // 0x0EC8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_AttackAnimRequest();
	void PlayExpandingKnockback();
	void RequestReplicatedAttackAnimation(int32 SpecialAttackId);
	void SpawnPrimeBuff();

	TArray<struct FVector> GetConeAttackLocations() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCharAI_PrimeHelixOld">();
	}
	static class AOrionCharAI_PrimeHelixOld* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionCharAI_PrimeHelixOld>();
	}
};
static_assert(alignof(AOrionCharAI_PrimeHelixOld) == 0x000010, "Wrong alignment on AOrionCharAI_PrimeHelixOld");
static_assert(sizeof(AOrionCharAI_PrimeHelixOld) == 0x000F20, "Wrong size on AOrionCharAI_PrimeHelixOld");
static_assert(offsetof(AOrionCharAI_PrimeHelixOld, NumNormalAttacksBetweenSpecial) == 0x000DF4, "Member 'AOrionCharAI_PrimeHelixOld::NumNormalAttacksBetweenSpecial' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_PrimeHelixOld, SpecialAttackAbilities) == 0x000DF8, "Member 'AOrionCharAI_PrimeHelixOld::SpecialAttackAbilities' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_PrimeHelixOld, ConeAttackLocations) == 0x000E18, "Member 'AOrionCharAI_PrimeHelixOld::ConeAttackLocations' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_PrimeHelixOld, KnockbackAttackEffect) == 0x000E28, "Member 'AOrionCharAI_PrimeHelixOld::KnockbackAttackEffect' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_PrimeHelixOld, KnockbackParticleEffect) == 0x000E30, "Member 'AOrionCharAI_PrimeHelixOld::KnockbackParticleEffect' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_PrimeHelixOld, KnockbackRadiusInitial) == 0x000E38, "Member 'AOrionCharAI_PrimeHelixOld::KnockbackRadiusInitial' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_PrimeHelixOld, KnockbackRadiusExpanded) == 0x000E3C, "Member 'AOrionCharAI_PrimeHelixOld::KnockbackRadiusExpanded' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_PrimeHelixOld, KnockbackRadiusExpandDuration) == 0x000E40, "Member 'AOrionCharAI_PrimeHelixOld::KnockbackRadiusExpandDuration' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_PrimeHelixOld, SpawnPrimeBuffEffect) == 0x000E50, "Member 'AOrionCharAI_PrimeHelixOld::SpawnPrimeBuffEffect' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_PrimeHelixOld, DelayTimeToSpawnPrimeBuff) == 0x000E58, "Member 'AOrionCharAI_PrimeHelixOld::DelayTimeToSpawnPrimeBuff' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_PrimeHelixOld, CarriedBuffPrimeHelix) == 0x000E60, "Member 'AOrionCharAI_PrimeHelixOld::CarriedBuffPrimeHelix' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_PrimeHelixOld, LockOnTarget) == 0x000E68, "Member 'AOrionCharAI_PrimeHelixOld::LockOnTarget' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_PrimeHelixOld, PackedAnimRequest) == 0x000E70, "Member 'AOrionCharAI_PrimeHelixOld::PackedAnimRequest' has a wrong offset!");
static_assert(offsetof(AOrionCharAI_PrimeHelixOld, CachedSpawner) == 0x000EC0, "Member 'AOrionCharAI_PrimeHelixOld::CachedSpawner' has a wrong offset!");

// Class OrionGame.OrionNavFieldVolume
// 0x0008 (0x0358 - 0x0350)
class AOrionNavFieldVolume final : public AVolume
{
public:
	ENavFieldDistanceClass                        ForceLaneDistance;                                 // 0x0350(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_351[0x3];                                      // 0x0351(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bForceLaneDistance : 1;                            // 0x0354(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForceNoAggroZone : 1;                             // 0x0354(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_355[0x3];                                      // 0x0355(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionNavFieldVolume">();
	}
	static class AOrionNavFieldVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionNavFieldVolume>();
	}
};
static_assert(alignof(AOrionNavFieldVolume) == 0x000008, "Wrong alignment on AOrionNavFieldVolume");
static_assert(sizeof(AOrionNavFieldVolume) == 0x000358, "Wrong size on AOrionNavFieldVolume");
static_assert(offsetof(AOrionNavFieldVolume, ForceLaneDistance) == 0x000350, "Member 'AOrionNavFieldVolume::ForceLaneDistance' has a wrong offset!");

// Class OrionGame.OrionCharAISpawner_CoreBoss
// 0x0020 (0x0700 - 0x06E0)
class AOrionCharAISpawner_CoreBoss final : public AOrionCharAISpawner
{
public:
	TArray<TSubclassOf<class UGameplayEffect>>    ImmunityEffects;                                   // 0x06E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGameplayEffect>>    ResetEffects;                                      // 0x06F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCharAISpawner_CoreBoss">();
	}
	static class AOrionCharAISpawner_CoreBoss* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionCharAISpawner_CoreBoss>();
	}
};
static_assert(alignof(AOrionCharAISpawner_CoreBoss) == 0x000008, "Wrong alignment on AOrionCharAISpawner_CoreBoss");
static_assert(sizeof(AOrionCharAISpawner_CoreBoss) == 0x000700, "Wrong size on AOrionCharAISpawner_CoreBoss");
static_assert(offsetof(AOrionCharAISpawner_CoreBoss, ImmunityEffects) == 0x0006E0, "Member 'AOrionCharAISpawner_CoreBoss::ImmunityEffects' has a wrong offset!");
static_assert(offsetof(AOrionCharAISpawner_CoreBoss, ResetEffects) == 0x0006F0, "Member 'AOrionCharAISpawner_CoreBoss::ResetEffects' has a wrong offset!");

// Class OrionGame.OrionCharMovementComponent
// 0x0180 (0x08C0 - 0x0740)
class UOrionCharMovementComponent final : public UCharacterMovementComponent
{
public:
	bool                                          bHasReplicatedAcceleration;                        // 0x0738(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_739[0x3];                                      // 0x0739(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RequestedMoveAcceleration;                         // 0x073C(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_748[0x10];                                     // 0x0748(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NetFrequencyDistanceThresholdMeters;               // 0x0758(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NetFrequencyThrottled;                             // 0x075C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_760[0x8];                                      // 0x0760(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentNetworkSmoothingLod;                        // 0x0768(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                NudgeVector;                                       // 0x076C(0x000C)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNudged;                                           // 0x0778(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_779[0x3];                                      // 0x0779(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NetworkSmoothingVisibilityThreshold;               // 0x077C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_780[0x4];                                      // 0x0780(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionCharNetworkSmoothingLod          NetworkSmoothingLods[0x4];                         // 0x0784(0x0014)(Edit, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_7D4[0x74];                                     // 0x07D4(0x0074)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrionNavField*                         CachedNavField;                                    // 0x0848(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_850[0x30];                                     // 0x0850(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bFlyWalk : 1;                                      // 0x0880(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_881[0x3];                                      // 0x0881(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionCharHoverData                    HoverData;                                         // 0x0884(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_8BC[0x4];                                      // 0x08BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyKnockback(const struct FVector& Direction, float DistanceXY);
	void ApplyKnockup(float Distance);
	void BeginHover(ECharHoverMovement InHoverMovementType, float InDesiredHeightOffFloor, float InInitialZOffsetMinimum, float InUpwardStrength, float InUpwardMaxSpeed, float InDownwardStrength, float InDownwardMaxSpeed, float InHoverTraceDistance, float InTraceResultNormalZThreshold, bool bInDisplayDebug);
	void EndHover();
	bool GetHover_bDisplayDebug();
	float GetHover_DesiredHeightOffFloor();
	float GetHover_DownwardMaxSpeed();
	float GetHover_DownwardStrength();
	float GetHover_HoverTraceDistance();
	ECharHoverMovement GetHover_MovementType();
	float GetHover_TraceResultNormalZThreshold();
	float GetHover_UpwardMaxSpeed();
	float GetHover_UpwardStrength();
	float GetHover_VelocityLeadTimeStepMult();
	void LaunchInDirection(const struct FVector& Direction, float LaunchVelocity, bool bLockAirControl);
	void LaunchInDirectionFromTargetData(const struct FGameplayAbilityTargetDataHandle& TargetDataHandle, float LaunchVelocity, bool bLockAirControl);
	void LaunchToPoint(const struct FVector& EndPoint, float LaunchVelocityXY, bool bLockAirControl);
	void LaunchToPointFromTargetData(const struct FGameplayAbilityTargetDataHandle& TargetDataHandle, float LaunchVelocityXY, bool bLockAirControl);
	void NudgeMovement(const struct FVector& ImpulseToAdd);
	void OrionServerMove(float Timestamp, const struct FVector_NetQuantize10& InAccel, const struct FVector_NetQuantize100& ClientLoc, uint8 CompressedMoveFlags, uint8 ClientRoll, uint32 View, class UPrimitiveComponent* ClientMovementBase, class FName ClientBaseBoneName, uint8 ClientMovementMode, const struct FMovementAbilitySyncKey& MovementAbilitySyncKey);
	void OrionServerMoveDual(float TimeStamp0, const struct FVector_NetQuantize10& InAccel0, uint8 PendingFlags, uint32 View0, float Timestamp, const struct FVector_NetQuantize10& InAccel, const struct FVector_NetQuantize100& ClientLoc, uint8 NewFlags, uint8 ClientRoll, uint32 View, class UPrimitiveComponent* ClientMovementBase, class FName ClientBaseBoneName, uint8 ClientMovementMode, const struct FMovementAbilitySyncKey& MovementAbilitySyncKey);
	void OrionServerMoveDualHybridRootMotion(float TimeStamp0, const struct FVector_NetQuantize10& InAccel0, uint8 PendingFlags, uint32 View0, float Timestamp, const struct FVector_NetQuantize10& InAccel, const struct FVector_NetQuantize100& ClientLoc, uint8 NewFlags, uint8 ClientRoll, uint32 View, class UPrimitiveComponent* ClientMovementBase, class FName ClientBaseBoneName, uint8 ClientMovementMode, const struct FMovementAbilitySyncKey& MovementAbilitySyncKey);
	void OrionServerMoveOld(float OldTimeStamp, const struct FVector_NetQuantize10& OldAccel, uint8 OldMoveFlags, const struct FMovementAbilitySyncKey& MovementAbilitySyncKey);
	void SetHover_bDisplayDebug(bool bValue);
	void SetHover_DesiredHeightOffFloor(float FValue);
	void SetHover_DownwardMaxSpeed(float FValue);
	void SetHover_DownwardStrength(float FValue);
	void SetHover_HoverTraceDistance(float FValue);
	void SetHover_MovementType(ECharHoverMovement Value);
	void SetHover_TraceResultNormalZThreshold(float FValue);
	void SetHover_UpwardMaxSpeed(float FValue);
	void SetHover_UpwardStrength(float FValue);
	void SetHover_VelocityLeadTimeStepMult(float FValue);
	struct FVector SimulateBasicFlight(const struct FVector& StartPoint, const struct FVector& Distance, float MaxDistancePerIncrement, int32 MaxIncrements);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCharMovementComponent">();
	}
	static class UOrionCharMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionCharMovementComponent>();
	}
};
static_assert(alignof(UOrionCharMovementComponent) == 0x000010, "Wrong alignment on UOrionCharMovementComponent");
static_assert(sizeof(UOrionCharMovementComponent) == 0x0008C0, "Wrong size on UOrionCharMovementComponent");
static_assert(offsetof(UOrionCharMovementComponent, bHasReplicatedAcceleration) == 0x000738, "Member 'UOrionCharMovementComponent::bHasReplicatedAcceleration' has a wrong offset!");
static_assert(offsetof(UOrionCharMovementComponent, RequestedMoveAcceleration) == 0x00073C, "Member 'UOrionCharMovementComponent::RequestedMoveAcceleration' has a wrong offset!");
static_assert(offsetof(UOrionCharMovementComponent, NetFrequencyDistanceThresholdMeters) == 0x000758, "Member 'UOrionCharMovementComponent::NetFrequencyDistanceThresholdMeters' has a wrong offset!");
static_assert(offsetof(UOrionCharMovementComponent, NetFrequencyThrottled) == 0x00075C, "Member 'UOrionCharMovementComponent::NetFrequencyThrottled' has a wrong offset!");
static_assert(offsetof(UOrionCharMovementComponent, CurrentNetworkSmoothingLod) == 0x000768, "Member 'UOrionCharMovementComponent::CurrentNetworkSmoothingLod' has a wrong offset!");
static_assert(offsetof(UOrionCharMovementComponent, NudgeVector) == 0x00076C, "Member 'UOrionCharMovementComponent::NudgeVector' has a wrong offset!");
static_assert(offsetof(UOrionCharMovementComponent, bNudged) == 0x000778, "Member 'UOrionCharMovementComponent::bNudged' has a wrong offset!");
static_assert(offsetof(UOrionCharMovementComponent, NetworkSmoothingVisibilityThreshold) == 0x00077C, "Member 'UOrionCharMovementComponent::NetworkSmoothingVisibilityThreshold' has a wrong offset!");
static_assert(offsetof(UOrionCharMovementComponent, NetworkSmoothingLods) == 0x000784, "Member 'UOrionCharMovementComponent::NetworkSmoothingLods' has a wrong offset!");
static_assert(offsetof(UOrionCharMovementComponent, CachedNavField) == 0x000848, "Member 'UOrionCharMovementComponent::CachedNavField' has a wrong offset!");
static_assert(offsetof(UOrionCharMovementComponent, HoverData) == 0x000884, "Member 'UOrionCharMovementComponent::HoverData' has a wrong offset!");

// Class OrionGame.OrionPlayerController_Game
// 0x0480 (0x0DD0 - 0x0950)
class AOrionPlayerController_Game : public AOrionPlayerController_Base
{
public:
	uint8                                         Pad_950[0x4];                                      // 0x0950(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumActiveVelocity;                             // 0x0954(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HeroName;                                          // 0x0958(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SkinName;                                          // 0x0968(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_978[0x78];                                     // 0x0978(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxConcurrentMapPings;                             // 0x09F0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MapPingLifetime;                                   // 0x09F4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MapPingBanTime;                                    // 0x09F8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9FC[0x1C];                                     // 0x09FC(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrionCharHero*                         MyOrionChar;                                       // 0x0A18(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AOrionDamageNumberManager*              DamageNumberManager;                               // 0x0A20(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FOrionLookAtTarget                     LookAtTarget;                                      // 0x0A28(0x0030)(NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               FreeLookLockRotation;                              // 0x0A58(0x000C)(IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               FreeReleaseRotation;                               // 0x0A64(0x000C)(IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         StartFreeLookInterpTime;                           // 0x0A70(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndFreeLookInterpTime;                             // 0x0A74(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A78[0x8];                                      // 0x0A78(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrionChar*                             FocusedOrionChar;                                  // 0x0A80(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A88[0x8];                                      // 0x0A88(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionStatManager*                      StatManager;                                       // 0x0A90(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSubmitLogsOnMatchEnd;                             // 0x0A98(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A99[0x7F];                                     // 0x0A99(0x007F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSavedViewTargetInfo                   SavedServerViewTarget;                             // 0x0B18(0x0018)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B30[0x2A0];                                    // 0x0B30(0x02A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void GetLocationRotationForSpawnActor(class AOrionPlayerController_Game* PlayerController, struct FVector* OutLocation, struct FRotator* OutRotation);

	void AbilityCancelPress();
	void ActivateAbilityForPawnCheat(class AOrionChar* InChar, const EOrionAbilityBinding InputID, const bool bPressed);
	void ActivateAIAbility(class AOrionChar* InChar, const EOrionAbilityBinding InputID);
	void AddPawnMovementInput(class AOrionChar* InChar, const struct FVector& WorldDirection, float ScaleValue, bool bForce);
	void CancelAbilityForPawnCheat(class AOrionChar* InChar);
	void CancelAllAbilitiesCheat(class AOrionChar* InChar);
	void ClientAddMinimapPing(const struct FVector& PingWorldPosition);
	void ClientDisableKillcam();
	void ClientHandleMatchIsWaitingToStart();
	void ClientHandlePostLogin();
	void ClientKilledBy(class AOrionPlayerState_Game* Killer, class AActor* DamageCauser, class AActor* KilledActor);
	void ClientMatchComplete(const struct FMatchCompleteNotification& MatchCompleteNotification, class FName SurveyQuestionGroupName);
	void ClientMatchHasEnded();
	void ClientPlayKillcam(class APawn* PawnToFocus);
	void ClientReceiveTeamCommMessage(const struct FOrionTeamCommMessage& MESSAGE);
	void ClientSetGravesiteCameraState(EGravesiteCameraState GravesiteCameraState, const struct FVector& PositionOfKiller, const struct FVector& PositionOfDeath, const struct FVector& FacingDir, class AActor* OptKillerActor);
	void ClientSurrender(bool bSurrender, bool bSuccess);
	void ClientTransitionToSpectating(const struct FVector& PositionOfKiller, const struct FVector& PositionOfDeath, const struct FVector& ViewerDir, class AActor* OptKillerActor);
	void ClientTriggerHighlight(class FName HighlightEvent);
	void ClientWardPing(const struct FVector& PingLocation);
	void CloseScoreboard();
	void CloseTeamCommsMenu();
	void CloseUpgradePanel();
	void ConfirmAbilityForPawnCheat(class AOrionChar* InChar);
	void DestroyTeamCommsActor(class ATeamCommunicationsActor* TeamCommsActor);
	void EndFreeLookCameraRestrictions();
	void OnFreeCameraModePressed();
	void OnFreeCameraModeReleased();
	void OnFreeCursorModePressed();
	void OnFreeCursorModeReleased();
	void OnHUDCursorModePress();
	void OnHUDCursorModeRelease();
	void OnHUDCursorModeToggle();
	void OpenScoreboard();
	void OpenUpgradePanel();
	void OrionPause();
	void ReportClientHitch(const struct FVector& CameraLocation, const struct FQuat& CameraRotation, float Duration);
	void ScriptAIBehaviorCheat(class AOrionChar* InChar, class FName ScriptedBehaviorName);
	void ServerActivateCardInSlot(int32 EquipSlotIdx);
	void ServerApplyGameplayEffect(class AActor* Target, class UGameplayEffect* GameplayEffect, float EffectsLevel);
	void ServerBroadcastTeamComm(const class UPCTeamCommunicationsData* TeamCommData);
	void ServerEquipCard(int32 HandIdx, int32 EquipSlotIdx);
	void ServerForceStartCountdown();
	void ServerForceStartGame();
	void ServerNotifyDeathCamEnded();
	void ServerNotifyDeathCamStarted();
	void ServerResetDeck();
	void ServerSendMinimapPing(const struct FVector& WorldPosition);
	void ServerSetIsUsingGamepad(bool bNewIsUsingGamepad);
	void ServerSetSelectedDeckItem(const class FString& DeckInstanceId);
	void ServerSuicide();
	void ServerSurrender(bool bSurrender, int32 Reason);
	void ServerSwapCards(int32 EquipSlotIdxOne, int32 EquipSlotIdxTwo);
	void ServerTransitionToSpectating();
	void ServerUnequipCard(int32 EquipSlotIdx);
	void ServerUnlockGemTreePip(EOrionGemBranchType Branch);
	void ServerUpdateCameraFreeLook(bool bStartFreeLook);
	void SetHealthCheat(class AOrionChar* InChar, const float InPercent);
	void SetLastZoneVisionMask(uint8 In_InMask, uint8 In_CanSeeMask);
	bool ShouldDisplayCardOverLocalPlayer();
	void StartUpgradePanelTimer();
	void Suicide();
	void TeleportCharTo(class AOrionChar* InChar, const struct FVector& WorldDirection, const struct FRotator& DestRotation);
	void ToggleCardMenu();
	void ToggleEmoteMenu();
	void ToggleEscapeMenu();
	void ToggleLargeMinimap();
	void ToggleScoreboard();
	void ToggleTeamCommsMenu();
	void UpgradeAbilityModeRelease();

	bool IsUpgradePanelOpen() const;
	bool OrionIsPaused() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPlayerController_Game">();
	}
	static class AOrionPlayerController_Game* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionPlayerController_Game>();
	}
};
static_assert(alignof(AOrionPlayerController_Game) == 0x000008, "Wrong alignment on AOrionPlayerController_Game");
static_assert(sizeof(AOrionPlayerController_Game) == 0x000DD0, "Wrong size on AOrionPlayerController_Game");
static_assert(offsetof(AOrionPlayerController_Game, MinimumActiveVelocity) == 0x000954, "Member 'AOrionPlayerController_Game::MinimumActiveVelocity' has a wrong offset!");
static_assert(offsetof(AOrionPlayerController_Game, HeroName) == 0x000958, "Member 'AOrionPlayerController_Game::HeroName' has a wrong offset!");
static_assert(offsetof(AOrionPlayerController_Game, SkinName) == 0x000968, "Member 'AOrionPlayerController_Game::SkinName' has a wrong offset!");
static_assert(offsetof(AOrionPlayerController_Game, MaxConcurrentMapPings) == 0x0009F0, "Member 'AOrionPlayerController_Game::MaxConcurrentMapPings' has a wrong offset!");
static_assert(offsetof(AOrionPlayerController_Game, MapPingLifetime) == 0x0009F4, "Member 'AOrionPlayerController_Game::MapPingLifetime' has a wrong offset!");
static_assert(offsetof(AOrionPlayerController_Game, MapPingBanTime) == 0x0009F8, "Member 'AOrionPlayerController_Game::MapPingBanTime' has a wrong offset!");
static_assert(offsetof(AOrionPlayerController_Game, MyOrionChar) == 0x000A18, "Member 'AOrionPlayerController_Game::MyOrionChar' has a wrong offset!");
static_assert(offsetof(AOrionPlayerController_Game, DamageNumberManager) == 0x000A20, "Member 'AOrionPlayerController_Game::DamageNumberManager' has a wrong offset!");
static_assert(offsetof(AOrionPlayerController_Game, LookAtTarget) == 0x000A28, "Member 'AOrionPlayerController_Game::LookAtTarget' has a wrong offset!");
static_assert(offsetof(AOrionPlayerController_Game, FreeLookLockRotation) == 0x000A58, "Member 'AOrionPlayerController_Game::FreeLookLockRotation' has a wrong offset!");
static_assert(offsetof(AOrionPlayerController_Game, FreeReleaseRotation) == 0x000A64, "Member 'AOrionPlayerController_Game::FreeReleaseRotation' has a wrong offset!");
static_assert(offsetof(AOrionPlayerController_Game, StartFreeLookInterpTime) == 0x000A70, "Member 'AOrionPlayerController_Game::StartFreeLookInterpTime' has a wrong offset!");
static_assert(offsetof(AOrionPlayerController_Game, EndFreeLookInterpTime) == 0x000A74, "Member 'AOrionPlayerController_Game::EndFreeLookInterpTime' has a wrong offset!");
static_assert(offsetof(AOrionPlayerController_Game, FocusedOrionChar) == 0x000A80, "Member 'AOrionPlayerController_Game::FocusedOrionChar' has a wrong offset!");
static_assert(offsetof(AOrionPlayerController_Game, StatManager) == 0x000A90, "Member 'AOrionPlayerController_Game::StatManager' has a wrong offset!");
static_assert(offsetof(AOrionPlayerController_Game, bSubmitLogsOnMatchEnd) == 0x000A98, "Member 'AOrionPlayerController_Game::bSubmitLogsOnMatchEnd' has a wrong offset!");
static_assert(offsetof(AOrionPlayerController_Game, SavedServerViewTarget) == 0x000B18, "Member 'AOrionPlayerController_Game::SavedServerViewTarget' has a wrong offset!");

// Class OrionGame.OrionPlayerController_Arcade
// 0x0000 (0x0DD0 - 0x0DD0)
class AOrionPlayerController_Arcade final : public AOrionPlayerController_Game
{
public:
	void ServerForceStartGame();
	void ServerPlayerHasConfirmed();
	void ServerRestartRounds(bool bWithBuff);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPlayerController_Arcade">();
	}
	static class AOrionPlayerController_Arcade* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionPlayerController_Arcade>();
	}
};
static_assert(alignof(AOrionPlayerController_Arcade) == 0x000008, "Wrong alignment on AOrionPlayerController_Arcade");
static_assert(sizeof(AOrionPlayerController_Arcade) == 0x000DD0, "Wrong size on AOrionPlayerController_Arcade");

// Class OrionGame.OrionChat
// 0x0000 (0x0058 - 0x0058)
class UOrionChat final : public UChatroom
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionChat">();
	}
	static class UOrionChat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionChat>();
	}
};
static_assert(alignof(UOrionChat) == 0x000008, "Wrong alignment on UOrionChat");
static_assert(sizeof(UOrionChat) == 0x000058, "Wrong size on UOrionChat");

// Class OrionGame.OrionPlayerInputSettings
// 0x0108 (0x0138 - 0x0030)
class UOrionPlayerInputSettings final : public UDataAsset
{
public:
	TArray<class UOrionPlayerInput_GamepadConfig*> GamepadConfigs;                                    // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UCurveFloat*                            GamepadLookYawCurves[0xA];                         // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            GamepadLookPitchCurves[0xA];                       // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            GamepadMovementCurve;                              // 0x00E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadLookAccelTime;                              // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadLookDecelTime;                              // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionAimAssistSettings                GamepadAimAssist;                                  // 0x00F0(0x0048)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPlayerInputSettings">();
	}
	static class UOrionPlayerInputSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionPlayerInputSettings>();
	}
};
static_assert(alignof(UOrionPlayerInputSettings) == 0x000008, "Wrong alignment on UOrionPlayerInputSettings");
static_assert(sizeof(UOrionPlayerInputSettings) == 0x000138, "Wrong size on UOrionPlayerInputSettings");
static_assert(offsetof(UOrionPlayerInputSettings, GamepadConfigs) == 0x000030, "Member 'UOrionPlayerInputSettings::GamepadConfigs' has a wrong offset!");
static_assert(offsetof(UOrionPlayerInputSettings, GamepadLookYawCurves) == 0x000040, "Member 'UOrionPlayerInputSettings::GamepadLookYawCurves' has a wrong offset!");
static_assert(offsetof(UOrionPlayerInputSettings, GamepadLookPitchCurves) == 0x000090, "Member 'UOrionPlayerInputSettings::GamepadLookPitchCurves' has a wrong offset!");
static_assert(offsetof(UOrionPlayerInputSettings, GamepadMovementCurve) == 0x0000E0, "Member 'UOrionPlayerInputSettings::GamepadMovementCurve' has a wrong offset!");
static_assert(offsetof(UOrionPlayerInputSettings, GamepadLookAccelTime) == 0x0000E8, "Member 'UOrionPlayerInputSettings::GamepadLookAccelTime' has a wrong offset!");
static_assert(offsetof(UOrionPlayerInputSettings, GamepadLookDecelTime) == 0x0000EC, "Member 'UOrionPlayerInputSettings::GamepadLookDecelTime' has a wrong offset!");
static_assert(offsetof(UOrionPlayerInputSettings, GamepadAimAssist) == 0x0000F0, "Member 'UOrionPlayerInputSettings::GamepadAimAssist' has a wrong offset!");

// Class OrionGame.OrionClientBotManager_CorePerf
// 0x0008 (0x0478 - 0x0470)
class UOrionClientBotManager_CorePerf final : public UOrionClientBotManager_Game
{
public:
	uint8                                         Pad_470[0x8];                                      // 0x0470(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionClientBotManager_CorePerf">();
	}
	static class UOrionClientBotManager_CorePerf* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionClientBotManager_CorePerf>();
	}
};
static_assert(alignof(UOrionClientBotManager_CorePerf) == 0x000008, "Wrong alignment on UOrionClientBotManager_CorePerf");
static_assert(sizeof(UOrionClientBotManager_CorePerf) == 0x000478, "Wrong size on UOrionClientBotManager_CorePerf");

// Class OrionGame.OrionClientBotManager_LanePerf
// 0x0008 (0x0478 - 0x0470)
class UOrionClientBotManager_LanePerf final : public UOrionClientBotManager_Game
{
public:
	uint8                                         Pad_470[0x8];                                      // 0x0470(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionClientBotManager_LanePerf">();
	}
	static class UOrionClientBotManager_LanePerf* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionClientBotManager_LanePerf>();
	}
};
static_assert(alignof(UOrionClientBotManager_LanePerf) == 0x000008, "Wrong alignment on UOrionClientBotManager_LanePerf");
static_assert(sizeof(UOrionClientBotManager_LanePerf) == 0x000478, "Wrong size on UOrionClientBotManager_LanePerf");

// Class OrionGame.OrionHeartbeatManager
// 0x0068 (0x0090 - 0x0028)
class UOrionHeartbeatManager final : public UObject
{
public:
	uint8                                         Pad_28[0x60];                                      // 0x0028(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PacketHistogramSendRate;                           // 0x0088(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsLocationEventEnabled;                           // 0x008C(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHeartbeatManager">();
	}
	static class UOrionHeartbeatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHeartbeatManager>();
	}
};
static_assert(alignof(UOrionHeartbeatManager) == 0x000008, "Wrong alignment on UOrionHeartbeatManager");
static_assert(sizeof(UOrionHeartbeatManager) == 0x000090, "Wrong size on UOrionHeartbeatManager");
static_assert(offsetof(UOrionHeartbeatManager, PacketHistogramSendRate) == 0x000088, "Member 'UOrionHeartbeatManager::PacketHistogramSendRate' has a wrong offset!");
static_assert(offsetof(UOrionHeartbeatManager, bIsLocationEventEnabled) == 0x00008C, "Member 'UOrionHeartbeatManager::bIsLocationEventEnabled' has a wrong offset!");

// Class OrionGame.OrionGemDisplayData
// 0x0170 (0x01A0 - 0x0030)
class UOrionGemDisplayData final : public UDataAsset
{
public:
	class UMaterialInterface*                     BaseGemMaterial;                                   // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               DefaultGemMaterialInstance;                        // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGemBranchImageData>            BranchImages;                                      // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGemRankImageData>              SocketImages;                                      // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGemRarityInfo>                 GemRarities;                                       // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGemRankNames>                  RankNames;                                         // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGemBranchDisplayInfo                  GemBranchDisplayInfo[0x3];                         // 0x0080(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGemDisplayData">();
	}
	static class UOrionGemDisplayData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionGemDisplayData>();
	}
};
static_assert(alignof(UOrionGemDisplayData) == 0x000008, "Wrong alignment on UOrionGemDisplayData");
static_assert(sizeof(UOrionGemDisplayData) == 0x0001A0, "Wrong size on UOrionGemDisplayData");
static_assert(offsetof(UOrionGemDisplayData, BaseGemMaterial) == 0x000030, "Member 'UOrionGemDisplayData::BaseGemMaterial' has a wrong offset!");
static_assert(offsetof(UOrionGemDisplayData, DefaultGemMaterialInstance) == 0x000038, "Member 'UOrionGemDisplayData::DefaultGemMaterialInstance' has a wrong offset!");
static_assert(offsetof(UOrionGemDisplayData, BranchImages) == 0x000040, "Member 'UOrionGemDisplayData::BranchImages' has a wrong offset!");
static_assert(offsetof(UOrionGemDisplayData, SocketImages) == 0x000050, "Member 'UOrionGemDisplayData::SocketImages' has a wrong offset!");
static_assert(offsetof(UOrionGemDisplayData, GemRarities) == 0x000060, "Member 'UOrionGemDisplayData::GemRarities' has a wrong offset!");
static_assert(offsetof(UOrionGemDisplayData, RankNames) == 0x000070, "Member 'UOrionGemDisplayData::RankNames' has a wrong offset!");
static_assert(offsetof(UOrionGemDisplayData, GemBranchDisplayInfo) == 0x000080, "Member 'UOrionGemDisplayData::GemBranchDisplayInfo' has a wrong offset!");

// Class OrionGame.OrionClientBotManager_SimpleSoak
// 0x00A0 (0x0510 - 0x0470)
class UOrionClientBotManager_SimpleSoak final : public UOrionClientBotManager_Game
{
public:
	uint8                                         Pad_470[0xA0];                                     // 0x0470(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionClientBotManager_SimpleSoak">();
	}
	static class UOrionClientBotManager_SimpleSoak* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionClientBotManager_SimpleSoak>();
	}
};
static_assert(alignof(UOrionClientBotManager_SimpleSoak) == 0x000008, "Wrong alignment on UOrionClientBotManager_SimpleSoak");
static_assert(sizeof(UOrionClientBotManager_SimpleSoak) == 0x000510, "Wrong size on UOrionClientBotManager_SimpleSoak");

// Class OrionGame.OrionClientBotManager_Smoke
// 0x0160 (0x05D0 - 0x0470)
class UOrionClientBotManager_Smoke final : public UOrionClientBotManager_Game
{
public:
	uint8                                         Pad_470[0x160];                                    // 0x0470(0x0160)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBuffGained(const struct FOrionJungleBuffInfo& BuffInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionClientBotManager_Smoke">();
	}
	static class UOrionClientBotManager_Smoke* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionClientBotManager_Smoke>();
	}
};
static_assert(alignof(UOrionClientBotManager_Smoke) == 0x000008, "Wrong alignment on UOrionClientBotManager_Smoke");
static_assert(sizeof(UOrionClientBotManager_Smoke) == 0x0005D0, "Wrong size on UOrionClientBotManager_Smoke");

// Class OrionGame.OrionClientBotManager_Social
// 0x0068 (0x0148 - 0x00E0)
class UOrionClientBotManager_Social final : public UOrionClientBotManager_Base
{
public:
	uint8                                         Pad_E0[0x68];                                      // 0x00E0(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionClientBotManager_Social">();
	}
	static class UOrionClientBotManager_Social* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionClientBotManager_Social>();
	}
};
static_assert(alignof(UOrionClientBotManager_Social) == 0x000008, "Wrong alignment on UOrionClientBotManager_Social");
static_assert(sizeof(UOrionClientBotManager_Social) == 0x000148, "Wrong size on UOrionClientBotManager_Social");

// Class OrionGame.OrionHeroCoilAnimInstance
// 0x00B0 (0x1270 - 0x11C0)
class UOrionHeroCoilAnimInstance final : public UOrionHeroAnimInstance
{
public:
	bool                                          bIsDeployed;                                       // 0x11B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSpellShieldActive;                              // 0x11B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11BA[0x2];                                     // 0x11BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatRK4SpringInterpolator            GoblinAttachAlphaInterpolator;                     // 0x11BC(0x0008)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C4[0x1C];                                    // 0x11C4(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GoblinAttachAlpha;                                 // 0x11E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRK4SpringInterpolator            GoblinPelvisAnimDynamicsAlphaInterpolator;         // 0x11E4(0x0008)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11EC[0x1C];                                    // 0x11EC(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GoblinPelvisAnimDynamicsAlpha;                     // 0x1208(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_120C[0x4];                                     // 0x120C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DisableGoblinRightHandIKCurveName;                 // 0x1210(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisableGoblinRightHandIKCurveValue;                // 0x1218(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GoblinRightHandIKAlpha;                            // 0x121C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoilHandIKAlpha;                                   // 0x1220(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1224[0x4];                                     // 0x1224(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedAnimStateArray                  DeployedCachedStates;                              // 0x1228(0x0018)(Edit, NativeAccessSpecifierPublic)
	bool                                          bIsSlowOnHitActive;                                // 0x1240(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1241[0x3];                                     // 0x1241(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatRK4SpringInterpolator            SlowOnHitAlphaInterpolator;                        // 0x1244(0x0008)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124C[0x1C];                                    // 0x124C(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlowOnHitAlpha;                                    // 0x1268(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_126C[0x4];                                     // 0x126C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHeroCoilAnimInstance">();
	}
	static class UOrionHeroCoilAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHeroCoilAnimInstance>();
	}
};
static_assert(alignof(UOrionHeroCoilAnimInstance) == 0x000010, "Wrong alignment on UOrionHeroCoilAnimInstance");
static_assert(sizeof(UOrionHeroCoilAnimInstance) == 0x001270, "Wrong size on UOrionHeroCoilAnimInstance");
static_assert(offsetof(UOrionHeroCoilAnimInstance, bIsDeployed) == 0x0011B8, "Member 'UOrionHeroCoilAnimInstance::bIsDeployed' has a wrong offset!");
static_assert(offsetof(UOrionHeroCoilAnimInstance, bIsSpellShieldActive) == 0x0011B9, "Member 'UOrionHeroCoilAnimInstance::bIsSpellShieldActive' has a wrong offset!");
static_assert(offsetof(UOrionHeroCoilAnimInstance, GoblinAttachAlphaInterpolator) == 0x0011BC, "Member 'UOrionHeroCoilAnimInstance::GoblinAttachAlphaInterpolator' has a wrong offset!");
static_assert(offsetof(UOrionHeroCoilAnimInstance, GoblinAttachAlpha) == 0x0011E0, "Member 'UOrionHeroCoilAnimInstance::GoblinAttachAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroCoilAnimInstance, GoblinPelvisAnimDynamicsAlphaInterpolator) == 0x0011E4, "Member 'UOrionHeroCoilAnimInstance::GoblinPelvisAnimDynamicsAlphaInterpolator' has a wrong offset!");
static_assert(offsetof(UOrionHeroCoilAnimInstance, GoblinPelvisAnimDynamicsAlpha) == 0x001208, "Member 'UOrionHeroCoilAnimInstance::GoblinPelvisAnimDynamicsAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroCoilAnimInstance, DisableGoblinRightHandIKCurveName) == 0x001210, "Member 'UOrionHeroCoilAnimInstance::DisableGoblinRightHandIKCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroCoilAnimInstance, DisableGoblinRightHandIKCurveValue) == 0x001218, "Member 'UOrionHeroCoilAnimInstance::DisableGoblinRightHandIKCurveValue' has a wrong offset!");
static_assert(offsetof(UOrionHeroCoilAnimInstance, GoblinRightHandIKAlpha) == 0x00121C, "Member 'UOrionHeroCoilAnimInstance::GoblinRightHandIKAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroCoilAnimInstance, CoilHandIKAlpha) == 0x001220, "Member 'UOrionHeroCoilAnimInstance::CoilHandIKAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroCoilAnimInstance, DeployedCachedStates) == 0x001228, "Member 'UOrionHeroCoilAnimInstance::DeployedCachedStates' has a wrong offset!");
static_assert(offsetof(UOrionHeroCoilAnimInstance, bIsSlowOnHitActive) == 0x001240, "Member 'UOrionHeroCoilAnimInstance::bIsSlowOnHitActive' has a wrong offset!");
static_assert(offsetof(UOrionHeroCoilAnimInstance, SlowOnHitAlphaInterpolator) == 0x001244, "Member 'UOrionHeroCoilAnimInstance::SlowOnHitAlphaInterpolator' has a wrong offset!");
static_assert(offsetof(UOrionHeroCoilAnimInstance, SlowOnHitAlpha) == 0x001268, "Member 'UOrionHeroCoilAnimInstance::SlowOnHitAlpha' has a wrong offset!");

// Class OrionGame.OrionHealthPCT
// 0x0000 (0x0040 - 0x0040)
class UOrionHealthPCT final : public UGameplayModMagnitudeCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHealthPCT">();
	}
	static class UOrionHealthPCT* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHealthPCT>();
	}
};
static_assert(alignof(UOrionHealthPCT) == 0x000008, "Wrong alignment on UOrionHealthPCT");
static_assert(sizeof(UOrionHealthPCT) == 0x000040, "Wrong size on UOrionHealthPCT");

// Class OrionGame.OrionPlayerController_DraftLobby
// 0x01D0 (0x0B20 - 0x0950)
class AOrionPlayerController_DraftLobby final : public AOrionPlayerController_Base
{
public:
	double                                        LastQuickChatMessageSentTime;                      // 0x0950(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_958[0x1C8];                                    // 0x0958(0x01C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientBeginDraftTutorial();
	void ClientCreateTeamChatRoom(const class FString& ChatRoomId);
	void ClientHeroSelectionStatus(bool bWasSuccessful);
	void ClientJoinTeamChatRoom(const class FString& ChatRoomId);
	void ClientPickNotification();
	void ClientReceiveQuickChatMessage(const struct FUniqueNetIdRepl& SenderId, const struct FOrionQuickChatPayload& MessagePayload);
	void ClientUpNextNotification();
	void ServerAttemptLockInHeroChoice(const class FString& HeroName);
	void ServerNotifyTutorialComplete();
	void ServerRequestDraftTutorial();
	void ServerSendQuickChatMessage(const struct FOrionQuickChatPayload& QuickChatPayload);
	void ServerSetDesiredPosition(EOrionPosition Position);
	void ServerSetDesiredRole(EOrionRole DesiredRole);
	void ServerSetMapOverride(const class FString& InMapURL);
	void ServerSetSelectedHero(const class UOrionHeroData* HeroData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPlayerController_DraftLobby">();
	}
	static class AOrionPlayerController_DraftLobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionPlayerController_DraftLobby>();
	}
};
static_assert(alignof(AOrionPlayerController_DraftLobby) == 0x000008, "Wrong alignment on AOrionPlayerController_DraftLobby");
static_assert(sizeof(AOrionPlayerController_DraftLobby) == 0x000B20, "Wrong size on AOrionPlayerController_DraftLobby");
static_assert(offsetof(AOrionPlayerController_DraftLobby, LastQuickChatMessageSentTime) == 0x000950, "Member 'AOrionPlayerController_DraftLobby::LastQuickChatMessageSentTime' has a wrong offset!");

// Class OrionGame.OrionClientPilotComponent_FrontEnd
// 0x0018 (0x0098 - 0x0080)
class UOrionClientPilotComponent_FrontEnd final : public UOrionClientPilotComponent_Base
{
public:
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlaylistId;                                        // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumPlayersInQueue;                                 // 0x008C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AccountMmr;                                        // 0x0090(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionClientPilotComponent_FrontEnd">();
	}
	static class UOrionClientPilotComponent_FrontEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionClientPilotComponent_FrontEnd>();
	}
};
static_assert(alignof(UOrionClientPilotComponent_FrontEnd) == 0x000008, "Wrong alignment on UOrionClientPilotComponent_FrontEnd");
static_assert(sizeof(UOrionClientPilotComponent_FrontEnd) == 0x000098, "Wrong size on UOrionClientPilotComponent_FrontEnd");
static_assert(offsetof(UOrionClientPilotComponent_FrontEnd, PlaylistId) == 0x000088, "Member 'UOrionClientPilotComponent_FrontEnd::PlaylistId' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_FrontEnd, NumPlayersInQueue) == 0x00008C, "Member 'UOrionClientPilotComponent_FrontEnd::NumPlayersInQueue' has a wrong offset!");
static_assert(offsetof(UOrionClientPilotComponent_FrontEnd, AccountMmr) == 0x000090, "Member 'UOrionClientPilotComponent_FrontEnd::AccountMmr' has a wrong offset!");

// Class OrionGame.OrionHeroGhostAnimInstance
// 0x0030 (0x11F0 - 0x11C0)
class UOrionHeroGhostAnimInstance final : public UOrionHeroAnimInstance
{
public:
	class FName                                   DisableFingersOverrideCurveName;                   // 0x11B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisableFingersAlpha;                               // 0x11C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C4[0x4];                                     // 0x11C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttackCurveName;                                   // 0x11C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttackCurveRelevant;                              // 0x11D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11D1[0x7];                                     // 0x11D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   WeaponIKCurveName;                                 // 0x11D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponIKCurveAlpha;                                // 0x11E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HandIKAlpha;                                       // 0x11E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11E8[0x8];                                     // 0x11E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHeroGhostAnimInstance">();
	}
	static class UOrionHeroGhostAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHeroGhostAnimInstance>();
	}
};
static_assert(alignof(UOrionHeroGhostAnimInstance) == 0x000010, "Wrong alignment on UOrionHeroGhostAnimInstance");
static_assert(sizeof(UOrionHeroGhostAnimInstance) == 0x0011F0, "Wrong size on UOrionHeroGhostAnimInstance");
static_assert(offsetof(UOrionHeroGhostAnimInstance, DisableFingersOverrideCurveName) == 0x0011B8, "Member 'UOrionHeroGhostAnimInstance::DisableFingersOverrideCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroGhostAnimInstance, DisableFingersAlpha) == 0x0011C0, "Member 'UOrionHeroGhostAnimInstance::DisableFingersAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroGhostAnimInstance, AttackCurveName) == 0x0011C8, "Member 'UOrionHeroGhostAnimInstance::AttackCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroGhostAnimInstance, bAttackCurveRelevant) == 0x0011D0, "Member 'UOrionHeroGhostAnimInstance::bAttackCurveRelevant' has a wrong offset!");
static_assert(offsetof(UOrionHeroGhostAnimInstance, WeaponIKCurveName) == 0x0011D8, "Member 'UOrionHeroGhostAnimInstance::WeaponIKCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroGhostAnimInstance, WeaponIKCurveAlpha) == 0x0011E0, "Member 'UOrionHeroGhostAnimInstance::WeaponIKCurveAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroGhostAnimInstance, HandIKAlpha) == 0x0011E4, "Member 'UOrionHeroGhostAnimInstance::HandIKAlpha' has a wrong offset!");

// Class OrionGame.OrionGameUserSettings
// 0x0100 (0x0230 - 0x0130)
class UOrionGameUserSettings final : public UGameUserSettingsCommon
{
public:
	UMulticastDelegateProperty_                   OnBenchmarkCompleted;                              // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	bool                                          bIsCompetitiveMode;                                // 0x0140(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bApplyFastOrPrettySettingsAtStartup;               // 0x0141(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_142[0x2];                                      // 0x0142(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OrionGameplayQuality;                              // 0x0144(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         OrionVersion;                                      // 0x0148(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         InputType;                                         // 0x014C(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14D[0x73];                                     // 0x014D(0x0073)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InitialBenchmarkState;                             // 0x01C0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         OrionBenchmarkVersion;                             // 0x01C4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MenuFrameRateLimit;                                // 0x01C8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DeathcamFrameRateLimit;                            // 0x01CC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<int32>                                 SupportedHDRNitLevels;                             // 0x01D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E0[0x50];                                     // 0x01E0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOrionGameUserSettings* GetOrionGameUserSettings();
	static bool IsRunningOnUnsupportedGraphicsCard();

	bool GetForceAutomaticSettingsAtStartup();
	void SetCompetitiveMode(bool bInCompMode);
	void SetForceAutomaticSettingsAtStartup(bool bShouldForceSettings);
	void SetMenuFrameRateLimit(float NewLimit);
	void SetOrionGameplayQuality(int32 Value);
	void TriggerRenderingBenchmark(class UObject* WorldContextObject);

	bool GetCompetitiveMode() const;
	class FText GetGPUDisplayString() const;
	int32 GetInitialBenchmarkState() const;
	float GetMenuFrameRateLimit() const;
	int32 GetOrionGameplayQuality() const;
	TArray<int32> GetSupportedHDRNitLevels() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameUserSettings">();
	}
	static class UOrionGameUserSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionGameUserSettings>();
	}
};
static_assert(alignof(UOrionGameUserSettings) == 0x000008, "Wrong alignment on UOrionGameUserSettings");
static_assert(sizeof(UOrionGameUserSettings) == 0x000230, "Wrong size on UOrionGameUserSettings");
static_assert(offsetof(UOrionGameUserSettings, OnBenchmarkCompleted) == 0x000130, "Member 'UOrionGameUserSettings::OnBenchmarkCompleted' has a wrong offset!");
static_assert(offsetof(UOrionGameUserSettings, bIsCompetitiveMode) == 0x000140, "Member 'UOrionGameUserSettings::bIsCompetitiveMode' has a wrong offset!");
static_assert(offsetof(UOrionGameUserSettings, bApplyFastOrPrettySettingsAtStartup) == 0x000141, "Member 'UOrionGameUserSettings::bApplyFastOrPrettySettingsAtStartup' has a wrong offset!");
static_assert(offsetof(UOrionGameUserSettings, OrionGameplayQuality) == 0x000144, "Member 'UOrionGameUserSettings::OrionGameplayQuality' has a wrong offset!");
static_assert(offsetof(UOrionGameUserSettings, OrionVersion) == 0x000148, "Member 'UOrionGameUserSettings::OrionVersion' has a wrong offset!");
static_assert(offsetof(UOrionGameUserSettings, InputType) == 0x00014C, "Member 'UOrionGameUserSettings::InputType' has a wrong offset!");
static_assert(offsetof(UOrionGameUserSettings, InitialBenchmarkState) == 0x0001C0, "Member 'UOrionGameUserSettings::InitialBenchmarkState' has a wrong offset!");
static_assert(offsetof(UOrionGameUserSettings, OrionBenchmarkVersion) == 0x0001C4, "Member 'UOrionGameUserSettings::OrionBenchmarkVersion' has a wrong offset!");
static_assert(offsetof(UOrionGameUserSettings, MenuFrameRateLimit) == 0x0001C8, "Member 'UOrionGameUserSettings::MenuFrameRateLimit' has a wrong offset!");
static_assert(offsetof(UOrionGameUserSettings, DeathcamFrameRateLimit) == 0x0001CC, "Member 'UOrionGameUserSettings::DeathcamFrameRateLimit' has a wrong offset!");
static_assert(offsetof(UOrionGameUserSettings, SupportedHDRNitLevels) == 0x0001D0, "Member 'UOrionGameUserSettings::SupportedHDRNitLevels' has a wrong offset!");

// Class OrionGame.OrionClientPilotComponent_GameSmoke
// 0x0160 (0x0398 - 0x0238)
class UOrionClientPilotComponent_GameSmoke final : public UOrionClientPilotComponent_Game
{
public:
	uint8                                         Pad_238[0x160];                                    // 0x0238(0x0160)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBuffGained(const struct FOrionJungleBuffInfo& BuffInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionClientPilotComponent_GameSmoke">();
	}
	static class UOrionClientPilotComponent_GameSmoke* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionClientPilotComponent_GameSmoke>();
	}
};
static_assert(alignof(UOrionClientPilotComponent_GameSmoke) == 0x000008, "Wrong alignment on UOrionClientPilotComponent_GameSmoke");
static_assert(sizeof(UOrionClientPilotComponent_GameSmoke) == 0x000398, "Wrong size on UOrionClientPilotComponent_GameSmoke");

// Class OrionGame.OrionClientPilotComponent_LanePerf
// 0x0008 (0x0240 - 0x0238)
class UOrionClientPilotComponent_LanePerf final : public UOrionClientPilotComponent_Game
{
public:
	uint8                                         Pad_238[0x8];                                      // 0x0238(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionClientPilotComponent_LanePerf">();
	}
	static class UOrionClientPilotComponent_LanePerf* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionClientPilotComponent_LanePerf>();
	}
};
static_assert(alignof(UOrionClientPilotComponent_LanePerf) == 0x000008, "Wrong alignment on UOrionClientPilotComponent_LanePerf");
static_assert(sizeof(UOrionClientPilotComponent_LanePerf) == 0x000240, "Wrong size on UOrionClientPilotComponent_LanePerf");

// Class OrionGame.OrionClientPilotComponent_MatchPerf
// 0x0090 (0x02C8 - 0x0238)
class UOrionClientPilotComponent_MatchPerf final : public UOrionClientPilotComponent_Game
{
public:
	uint8                                         Pad_238[0x90];                                     // 0x0238(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionClientPilotComponent_MatchPerf">();
	}
	static class UOrionClientPilotComponent_MatchPerf* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionClientPilotComponent_MatchPerf>();
	}
};
static_assert(alignof(UOrionClientPilotComponent_MatchPerf) == 0x000008, "Wrong alignment on UOrionClientPilotComponent_MatchPerf");
static_assert(sizeof(UOrionClientPilotComponent_MatchPerf) == 0x0002C8, "Wrong size on UOrionClientPilotComponent_MatchPerf");

// Class OrionGame.OrionMcpBannerAlterationItemDefinition
// 0x00D8 (0x0340 - 0x0268)
class UOrionMcpBannerAlterationItemDefinition final : public UOrionMcpItemDefinition
{
public:
	struct FBannerMaterialDesc                    MaterialDesc;                                      // 0x0268(0x00D8)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	struct FBannerMaterialDesc GetBannerMaterialDesc() const;
	class UTexture* GetDiffuse() const;
	class UTexture* GetNormal() const;
	class UTexture* GetTexture() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpBannerAlterationItemDefinition">();
	}
	static class UOrionMcpBannerAlterationItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpBannerAlterationItemDefinition>();
	}
};
static_assert(alignof(UOrionMcpBannerAlterationItemDefinition) == 0x000008, "Wrong alignment on UOrionMcpBannerAlterationItemDefinition");
static_assert(sizeof(UOrionMcpBannerAlterationItemDefinition) == 0x000340, "Wrong size on UOrionMcpBannerAlterationItemDefinition");
static_assert(offsetof(UOrionMcpBannerAlterationItemDefinition, MaterialDesc) == 0x000268, "Member 'UOrionMcpBannerAlterationItemDefinition::MaterialDesc' has a wrong offset!");

// Class OrionGame.OrionClientSettingsRecord
// 0x0090 (0x02F0 - 0x0260)
class UOrionClientSettingsRecord final : public UClientSettingsRecord
{
public:
	TArray<struct FOrionHeroSaveSettings>         HeroSettings;                                      // 0x0260(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         EnableDeathcam;                                    // 0x0270(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ShowAbilityConfirmWidget;                          // 0x0274(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          EnableCardOverLocalPlayer;                         // 0x0278(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_279[0x3];                                      // 0x0279(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ShowBasicAttackRangeIndicator;                     // 0x027C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         EnableSuggestionMode;                              // 0x0280(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         EnableAutoOpen;                                    // 0x0284(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         EnableAutoBuy;                                     // 0x0288(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ShowAddedItemsInChat;                              // 0x028C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ShowCompletedItemsInChat;                          // 0x0290(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ShowDiscardedItemsInChat;                          // 0x0294(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LastPickedAIDifficulty;                            // 0x0298(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNewDawnVideoSeen;                                 // 0x029C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSovereignNewUserUpdateSeen;                       // 0x029D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNewCardsUpdateSeen;                               // 0x029E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29F[0x1];                                      // 0x029F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LastGameModeSelection;                             // 0x02A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoPlayInstantReplay;                            // 0x02A4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A5[0x3];                                      // 0x02A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              LastPopupSeenModifiedDate;                         // 0x02A8(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDateTime                              LastDailyQuestSeen;                                // 0x02B0(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoOpenCardShop;                                 // 0x02B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFrontEndPvPMode;                                  // 0x02B9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowHUDHotkeys;                                   // 0x02BA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCardOnboardShown;                                 // 0x02BB(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDeckBuilderDialogShown;                           // 0x02BC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BD[0x3];                                      // 0x02BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HUDUIScale;                                        // 0x02C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerOverheadHealthBarPosition              MeleeHeroHealthBarPosition;                        // 0x02C4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerOverheadHealthBarPosition              RangeHeroHealthBarPosition;                        // 0x02C5(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHealthIndicatorVisibility                    IndicatorVisibility_FriendlyMinion;                // 0x02C6(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHealthIndicatorVisibility                    IndicatorVisibility_EnemyMinion;                   // 0x02C7(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHealthIndicatorVisibility                    IndicatorVisibility_FriendlyHero;                  // 0x02C8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHealthIndicatorVisibility                    IndicatorVisibility_EnemyHero;                     // 0x02C9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReverseEnemyHealthBarDirection;                   // 0x02CA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisplayMeleeHeroReticle;                          // 0x02CB(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisplayNumericalValues;                           // 0x02CC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisplayDetailedStatsPanel;                        // 0x02CD(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFadeHealthBarWhenOutOfCombat;                     // 0x02CE(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOffScreenIndicatorVisibility                 OffScreenIndicatorVisibility;                      // 0x02CF(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOffScreenIndicatorPortraits;                      // 0x02D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOffScreenIndicatorHealthBars;                     // 0x02D1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnemyCombatText;                                  // 0x02D2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFloatingCombatText;                               // 0x02D3(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDetailedStatsPanelPortrait;                       // 0x02D4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTeamFrames;                                       // 0x02D5(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCardsAndGems;                                     // 0x02D6(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCardHotkeys;                                      // 0x02D7(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAbilities;                                        // 0x02D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAbilityHotkeys;                                   // 0x02D9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStatsPanel;                                       // 0x02DA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMiniMap;                                          // 0x02DB(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReticle;                                          // 0x02DC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBuffs;                                            // 0x02DD(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bChat;                                             // 0x02DE(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHotkeys;                                          // 0x02DF(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bKillFeed;                                         // 0x02E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAnnouncements;                                    // 0x02E1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTeamComms;                                        // 0x02E2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTeamCoreHP;                                       // 0x02E3(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLowHPRecallWarning;                               // 0x02E4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowLaneGuides;                                   // 0x02E5(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EStaticHealthBarPosition                      StaticHealthBarPosition;                           // 0x02E6(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EStatusAreaDisplayType                        StatusAreaDisplayType;                             // 0x02E7(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAbilities(bool bNewValue);
	void SetAbilityHotkeys(bool bNewValue);
	void SetAnnouncements(bool bNewValue);
	void SetAutoOpenCardShop(bool NewValue);
	void SetAutoPlayInstantReplay(bool NewValue);
	void SetBuffs(bool bNewValue);
	void SetCardHotKeys(bool bNewValue);
	void SetCardOnboardShown(bool InCardOnboardLastShownGame);
	void SetCardsAndGems(bool bNewValue);
	void SetChat(bool bNewValue);
	void SetDeckBuilderDialogShown(bool bInDeckBuilderDialogShow);
	void SetDetailedStatsPanelPortrait(bool bNewValue);
	void SetDisplayDetailedStatsPanel(bool bNewValue);
	void SetDisplayMeleeHeroReticle(bool bNewValue);
	void SetDisplayNumericalValues(bool bNewValue);
	void SetEnableCardOverLocalPlayer(bool NewValue);
	void SetEnableDeathcam(int32 NewValue);
	void SetEnemyHeroIndicatorRule(EHealthIndicatorVisibility NewValue);
	void SetEnemyMinionIndicatorRule(EHealthIndicatorVisibility NewValue);
	void SetFadeHealthBarWhenOutOfCombat(bool bNewValue);
	void SetFloatingCombatText(bool bNewValue);
	void SetFriendlyHeroIndicatorRule(EHealthIndicatorVisibility NewValue);
	void SetFriendlyMinionIndicatorRule(EHealthIndicatorVisibility NewValue);
	void SetFrontEndPvpMode(bool bNewValue);
	void SetHotkeys(bool bNewValue);
	void SetHUDUIScale(float InHUDUIScale);
	void SetKillFeed(bool bNewValue);
	void SetLowHPRecallWarning(bool bNewValue);
	void SetMeleeHeroHealthBarPosition(EPlayerOverheadHealthBarPosition NewValue);
	void SetMiniMap(bool bNewValue);
	void SetOffScreenIndicatorHealthBars(bool bNewValue);
	void SetOffScreenIndicatorPortraits(bool bNewValue);
	void SetOffScreenIndicatorVisibility(EOffScreenIndicatorVisibility NewValue);
	void SetRangeHeroHealthBarPosition(EPlayerOverheadHealthBarPosition NewValue);
	void SetReticle(bool bNewValue);
	void SetReverseEnemyHealthBarDirection(bool bNewValue);
	void SetShowAbilityConfirmWidget(int32 NewValue);
	void SetShowAddedItemsInChat(int32 NewValue);
	void SetShowBasicAttackRangeIndicator(int32 NewValue);
	void SetShowCompletedItemsInChat(int32 NewValue);
	void SetShowDiscardedItemsInChat(int32 NewValue);
	void SetShowHUDHotkeys(bool bNewValue);
	void SetShowLaneGuides(bool NewValue);
	void SetStaticHealthBarPosition(EStaticHealthBarPosition NewValue);
	void SetStatsPanel(bool bNewValue);
	void SetStatusAreaDisplayType(EStatusAreaDisplayType NewValue);
	void SetTeamComms(bool bNewValue);
	void SetTeamCoreHP(bool bNewValue);
	void SetTeamFrames(bool bNewValue);

	bool GetAbilities() const;
	bool GetAbilityHotkeys() const;
	bool GetAnnouncements() const;
	bool GetAutoOpenCardShop() const;
	bool GetAutoPlayInstantReplay() const;
	bool GetBuffs() const;
	bool GetCardHotkeys() const;
	bool GetCardsAndGems() const;
	bool GetChat() const;
	bool GetDetailedStatsPanelPortrait() const;
	bool GetDisplayDetailedStatsPanel() const;
	bool GetDisplayMeleeHeroReticle() const;
	bool GetDisplayNumericalValues() const;
	bool GetEnableCardOverLocalPlayer() const;
	int32 GetEnableDeathcam() const;
	EHealthIndicatorVisibility GetEnemyHeroIndicatorRule() const;
	EHealthIndicatorVisibility GetEnemyMinionIndicatorRule() const;
	bool GetFadeHealthBarWhenOutOfCombat() const;
	bool GetFloatingCombatText() const;
	EHealthIndicatorVisibility GetFriendlyHeroIndicatorRule() const;
	EHealthIndicatorVisibility GetFriendlyMinionIndicatorRule() const;
	bool GetFrontEndPvpMode() const;
	bool GetHotkeys() const;
	float GetHUDUIScale() const;
	bool GetKillFeed() const;
	bool GetLowHPRecallWarning() const;
	EPlayerOverheadHealthBarPosition GetMeleeHeroHealthBarPosition() const;
	bool GetMiniMap() const;
	bool GetOffScreenIndicatorHealthBars() const;
	bool GetOffScreenIndicatorPortraits() const;
	EOffScreenIndicatorVisibility GetOffScreenIndicatorVisibility() const;
	EPlayerOverheadHealthBarPosition GetRangeHeroHealthBarPosition() const;
	bool GetReticle() const;
	bool GetReverseEnemyHealthBarDirection() const;
	int32 GetShowAbilityConfirmWidget() const;
	int32 GetShowAddedItemsInChat() const;
	int32 GetShowBasicAttackRangeIndicator() const;
	int32 GetShowCompletedItemsInChat() const;
	int32 GetShowDiscardedItemsInChat() const;
	bool GetShowHUDHotkeys() const;
	bool GetShowLaneGuides() const;
	EStaticHealthBarPosition GetStaticHealthBarPosition() const;
	bool GetStatsPanel() const;
	EStatusAreaDisplayType GetStatusAreaDisplayType() const;
	bool GetTeamComms() const;
	bool GetTeamCoreHP() const;
	bool GetTeamFrames() const;
	bool HasShownCardOnboard() const;
	bool HasShownDeckBuilderDialog() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionClientSettingsRecord">();
	}
	static class UOrionClientSettingsRecord* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionClientSettingsRecord>();
	}
};
static_assert(alignof(UOrionClientSettingsRecord) == 0x000008, "Wrong alignment on UOrionClientSettingsRecord");
static_assert(sizeof(UOrionClientSettingsRecord) == 0x0002F0, "Wrong size on UOrionClientSettingsRecord");
static_assert(offsetof(UOrionClientSettingsRecord, HeroSettings) == 0x000260, "Member 'UOrionClientSettingsRecord::HeroSettings' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, EnableDeathcam) == 0x000270, "Member 'UOrionClientSettingsRecord::EnableDeathcam' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, ShowAbilityConfirmWidget) == 0x000274, "Member 'UOrionClientSettingsRecord::ShowAbilityConfirmWidget' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, EnableCardOverLocalPlayer) == 0x000278, "Member 'UOrionClientSettingsRecord::EnableCardOverLocalPlayer' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, ShowBasicAttackRangeIndicator) == 0x00027C, "Member 'UOrionClientSettingsRecord::ShowBasicAttackRangeIndicator' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, EnableSuggestionMode) == 0x000280, "Member 'UOrionClientSettingsRecord::EnableSuggestionMode' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, EnableAutoOpen) == 0x000284, "Member 'UOrionClientSettingsRecord::EnableAutoOpen' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, EnableAutoBuy) == 0x000288, "Member 'UOrionClientSettingsRecord::EnableAutoBuy' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, ShowAddedItemsInChat) == 0x00028C, "Member 'UOrionClientSettingsRecord::ShowAddedItemsInChat' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, ShowCompletedItemsInChat) == 0x000290, "Member 'UOrionClientSettingsRecord::ShowCompletedItemsInChat' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, ShowDiscardedItemsInChat) == 0x000294, "Member 'UOrionClientSettingsRecord::ShowDiscardedItemsInChat' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, LastPickedAIDifficulty) == 0x000298, "Member 'UOrionClientSettingsRecord::LastPickedAIDifficulty' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, bNewDawnVideoSeen) == 0x00029C, "Member 'UOrionClientSettingsRecord::bNewDawnVideoSeen' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, bSovereignNewUserUpdateSeen) == 0x00029D, "Member 'UOrionClientSettingsRecord::bSovereignNewUserUpdateSeen' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, bNewCardsUpdateSeen) == 0x00029E, "Member 'UOrionClientSettingsRecord::bNewCardsUpdateSeen' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, LastGameModeSelection) == 0x0002A0, "Member 'UOrionClientSettingsRecord::LastGameModeSelection' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, bAutoPlayInstantReplay) == 0x0002A4, "Member 'UOrionClientSettingsRecord::bAutoPlayInstantReplay' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, LastPopupSeenModifiedDate) == 0x0002A8, "Member 'UOrionClientSettingsRecord::LastPopupSeenModifiedDate' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, LastDailyQuestSeen) == 0x0002B0, "Member 'UOrionClientSettingsRecord::LastDailyQuestSeen' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, bAutoOpenCardShop) == 0x0002B8, "Member 'UOrionClientSettingsRecord::bAutoOpenCardShop' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, bFrontEndPvPMode) == 0x0002B9, "Member 'UOrionClientSettingsRecord::bFrontEndPvPMode' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, bShowHUDHotkeys) == 0x0002BA, "Member 'UOrionClientSettingsRecord::bShowHUDHotkeys' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, bCardOnboardShown) == 0x0002BB, "Member 'UOrionClientSettingsRecord::bCardOnboardShown' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, bDeckBuilderDialogShown) == 0x0002BC, "Member 'UOrionClientSettingsRecord::bDeckBuilderDialogShown' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, HUDUIScale) == 0x0002C0, "Member 'UOrionClientSettingsRecord::HUDUIScale' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, MeleeHeroHealthBarPosition) == 0x0002C4, "Member 'UOrionClientSettingsRecord::MeleeHeroHealthBarPosition' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, RangeHeroHealthBarPosition) == 0x0002C5, "Member 'UOrionClientSettingsRecord::RangeHeroHealthBarPosition' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, IndicatorVisibility_FriendlyMinion) == 0x0002C6, "Member 'UOrionClientSettingsRecord::IndicatorVisibility_FriendlyMinion' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, IndicatorVisibility_EnemyMinion) == 0x0002C7, "Member 'UOrionClientSettingsRecord::IndicatorVisibility_EnemyMinion' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, IndicatorVisibility_FriendlyHero) == 0x0002C8, "Member 'UOrionClientSettingsRecord::IndicatorVisibility_FriendlyHero' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, IndicatorVisibility_EnemyHero) == 0x0002C9, "Member 'UOrionClientSettingsRecord::IndicatorVisibility_EnemyHero' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, bReverseEnemyHealthBarDirection) == 0x0002CA, "Member 'UOrionClientSettingsRecord::bReverseEnemyHealthBarDirection' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, bDisplayMeleeHeroReticle) == 0x0002CB, "Member 'UOrionClientSettingsRecord::bDisplayMeleeHeroReticle' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, bDisplayNumericalValues) == 0x0002CC, "Member 'UOrionClientSettingsRecord::bDisplayNumericalValues' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, bDisplayDetailedStatsPanel) == 0x0002CD, "Member 'UOrionClientSettingsRecord::bDisplayDetailedStatsPanel' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, bFadeHealthBarWhenOutOfCombat) == 0x0002CE, "Member 'UOrionClientSettingsRecord::bFadeHealthBarWhenOutOfCombat' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, OffScreenIndicatorVisibility) == 0x0002CF, "Member 'UOrionClientSettingsRecord::OffScreenIndicatorVisibility' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, bOffScreenIndicatorPortraits) == 0x0002D0, "Member 'UOrionClientSettingsRecord::bOffScreenIndicatorPortraits' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, bOffScreenIndicatorHealthBars) == 0x0002D1, "Member 'UOrionClientSettingsRecord::bOffScreenIndicatorHealthBars' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, bEnemyCombatText) == 0x0002D2, "Member 'UOrionClientSettingsRecord::bEnemyCombatText' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, bFloatingCombatText) == 0x0002D3, "Member 'UOrionClientSettingsRecord::bFloatingCombatText' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, bDetailedStatsPanelPortrait) == 0x0002D4, "Member 'UOrionClientSettingsRecord::bDetailedStatsPanelPortrait' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, bTeamFrames) == 0x0002D5, "Member 'UOrionClientSettingsRecord::bTeamFrames' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, bCardsAndGems) == 0x0002D6, "Member 'UOrionClientSettingsRecord::bCardsAndGems' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, bCardHotkeys) == 0x0002D7, "Member 'UOrionClientSettingsRecord::bCardHotkeys' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, bAbilities) == 0x0002D8, "Member 'UOrionClientSettingsRecord::bAbilities' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, bAbilityHotkeys) == 0x0002D9, "Member 'UOrionClientSettingsRecord::bAbilityHotkeys' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, bStatsPanel) == 0x0002DA, "Member 'UOrionClientSettingsRecord::bStatsPanel' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, bMiniMap) == 0x0002DB, "Member 'UOrionClientSettingsRecord::bMiniMap' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, bReticle) == 0x0002DC, "Member 'UOrionClientSettingsRecord::bReticle' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, bBuffs) == 0x0002DD, "Member 'UOrionClientSettingsRecord::bBuffs' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, bChat) == 0x0002DE, "Member 'UOrionClientSettingsRecord::bChat' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, bHotkeys) == 0x0002DF, "Member 'UOrionClientSettingsRecord::bHotkeys' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, bKillFeed) == 0x0002E0, "Member 'UOrionClientSettingsRecord::bKillFeed' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, bAnnouncements) == 0x0002E1, "Member 'UOrionClientSettingsRecord::bAnnouncements' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, bTeamComms) == 0x0002E2, "Member 'UOrionClientSettingsRecord::bTeamComms' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, bTeamCoreHP) == 0x0002E3, "Member 'UOrionClientSettingsRecord::bTeamCoreHP' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, bLowHPRecallWarning) == 0x0002E4, "Member 'UOrionClientSettingsRecord::bLowHPRecallWarning' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, bShowLaneGuides) == 0x0002E5, "Member 'UOrionClientSettingsRecord::bShowLaneGuides' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, StaticHealthBarPosition) == 0x0002E6, "Member 'UOrionClientSettingsRecord::StaticHealthBarPosition' has a wrong offset!");
static_assert(offsetof(UOrionClientSettingsRecord, StatusAreaDisplayType) == 0x0002E7, "Member 'UOrionClientSettingsRecord::StatusAreaDisplayType' has a wrong offset!");

// Class OrionGame.OrionHeroData
// 0x02E8 (0x0610 - 0x0328)
class UOrionHeroData final : public UOrionCharacterData
{
public:
	TSoftClassPtr<class UClass>                   CameraClassWeakRef;                                // 0x0328(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   FreeLookCameraClassWeakRef;                        // 0x0350(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionSkinItemDefinition*               DefaultSkin;                                       // 0x0378(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAmbientEventContainer*                 AmbientEvents;                                     // 0x0380(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogueVoice*                         Voice;                                             // 0x0388(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           HeroPrimaryColor;                                  // 0x0390(0x0010)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           HeroSecondaryColor;                                // 0x03A0(0x0010)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UOrionUserWidget_Reticle>   ReticleWidgetClass;                                // 0x03B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRecommended;                                    // 0x03B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayOnWelcomeScreen;                           // 0x03B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowInUI;                                         // 0x03BA(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayEnabled;                                      // 0x03BB(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeverUnlock;                                      // 0x03BC(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3BD[0x3];                                      // 0x03BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionLoreData                         LoreData;                                          // 0x03C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	EOrionHeroTier                                HeroTier;                                          // 0x03D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D1[0x7];                                      // 0x03D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TutorialVideoURL;                                  // 0x03D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              TutorialImage;                                     // 0x03E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionHeroRoles                        Roles;                                             // 0x0410(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FOrionHeroTraitEntry>           Traits;                                            // 0x0428(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EOrionPosition>                        Positions;                                         // 0x0438(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         HeroStats[0x4];                                    // 0x0448(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionAffinityStruct                   Affinities;                                        // 0x0458(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_45C[0x4];                                      // 0x045C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  HeroDescriptionTags;                               // 0x0460(0x0020)(Edit, NativeAccessSpecifierPublic)
	TArray<class FString>                         RecommendedStatTags;                               // 0x0480(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         NotRecommendedStatTags;                            // 0x0490(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FOrionStarterDecks                     StarterDecks;                                      // 0x04A0(0x0038)(Edit, NativeAccessSpecifierPublic)
	class UBehaviorTree*                          BehaviorTree;                                      // 0x04D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UOrionMcpCuratedDeckItemDefinition> BotCardDeck;                                       // 0x04E0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionAbilityBinding                          AbilityLevelingUpPriority[0x4];                    // 0x0508(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BotEyeHeight;                                      // 0x050C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionGemBranchType                           AttributePriority[0x3];                            // 0x0510(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIBotDifficulty                              MinAllowedDifficulty;                              // 0x0513(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIBotDifficulty                              MaxAllowedDifficulty;                              // 0x0514(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_515[0x3];                                      // 0x0515(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionMcpRankUpRecipeItemDefinition*    MasteryRecipe;                                     // 0x0518(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bCanBeUsedByBots : 1;                              // 0x0520(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_521[0x1];                                      // 0x0521(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bPrototypeHero;                                    // 0x0522(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_523[0x5];                                      // 0x0523(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   SimpleActor;                                       // 0x0528(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReworkVersionEnabled;                             // 0x0550(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_551[0x7];                                      // 0x0551(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UOrionAbilitySet>> ReworkAbilitiesWeakRef;                            // 0x0558(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class FName                                   ReworkCharacterData;                               // 0x0568(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UOrionCameraMode>           CameraModeClass;                                   // 0x0570(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_578[0x98];                                     // 0x0578(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSimpleActorLoaded__DelegateSignature(class UClass* Result);
	void OnSimpleActorLoadedMulti__DelegateSignature(class UClass* Result);

	bool IsHeroRecommended() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHeroData">();
	}
	static class UOrionHeroData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHeroData>();
	}
};
static_assert(alignof(UOrionHeroData) == 0x000008, "Wrong alignment on UOrionHeroData");
static_assert(sizeof(UOrionHeroData) == 0x000610, "Wrong size on UOrionHeroData");
static_assert(offsetof(UOrionHeroData, CameraClassWeakRef) == 0x000328, "Member 'UOrionHeroData::CameraClassWeakRef' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, FreeLookCameraClassWeakRef) == 0x000350, "Member 'UOrionHeroData::FreeLookCameraClassWeakRef' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, DefaultSkin) == 0x000378, "Member 'UOrionHeroData::DefaultSkin' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, AmbientEvents) == 0x000380, "Member 'UOrionHeroData::AmbientEvents' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, Voice) == 0x000388, "Member 'UOrionHeroData::Voice' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, HeroPrimaryColor) == 0x000390, "Member 'UOrionHeroData::HeroPrimaryColor' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, HeroSecondaryColor) == 0x0003A0, "Member 'UOrionHeroData::HeroSecondaryColor' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, ReticleWidgetClass) == 0x0003B0, "Member 'UOrionHeroData::ReticleWidgetClass' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, bIsRecommended) == 0x0003B8, "Member 'UOrionHeroData::bIsRecommended' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, bDisplayOnWelcomeScreen) == 0x0003B9, "Member 'UOrionHeroData::bDisplayOnWelcomeScreen' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, bShowInUI) == 0x0003BA, "Member 'UOrionHeroData::bShowInUI' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, bPlayEnabled) == 0x0003BB, "Member 'UOrionHeroData::bPlayEnabled' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, bNeverUnlock) == 0x0003BC, "Member 'UOrionHeroData::bNeverUnlock' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, LoreData) == 0x0003C0, "Member 'UOrionHeroData::LoreData' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, HeroTier) == 0x0003D0, "Member 'UOrionHeroData::HeroTier' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, TutorialVideoURL) == 0x0003D8, "Member 'UOrionHeroData::TutorialVideoURL' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, TutorialImage) == 0x0003E8, "Member 'UOrionHeroData::TutorialImage' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, Roles) == 0x000410, "Member 'UOrionHeroData::Roles' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, Traits) == 0x000428, "Member 'UOrionHeroData::Traits' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, Positions) == 0x000438, "Member 'UOrionHeroData::Positions' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, HeroStats) == 0x000448, "Member 'UOrionHeroData::HeroStats' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, Affinities) == 0x000458, "Member 'UOrionHeroData::Affinities' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, HeroDescriptionTags) == 0x000460, "Member 'UOrionHeroData::HeroDescriptionTags' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, RecommendedStatTags) == 0x000480, "Member 'UOrionHeroData::RecommendedStatTags' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, NotRecommendedStatTags) == 0x000490, "Member 'UOrionHeroData::NotRecommendedStatTags' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, StarterDecks) == 0x0004A0, "Member 'UOrionHeroData::StarterDecks' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, BehaviorTree) == 0x0004D8, "Member 'UOrionHeroData::BehaviorTree' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, BotCardDeck) == 0x0004E0, "Member 'UOrionHeroData::BotCardDeck' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, AbilityLevelingUpPriority) == 0x000508, "Member 'UOrionHeroData::AbilityLevelingUpPriority' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, BotEyeHeight) == 0x00050C, "Member 'UOrionHeroData::BotEyeHeight' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, AttributePriority) == 0x000510, "Member 'UOrionHeroData::AttributePriority' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, MinAllowedDifficulty) == 0x000513, "Member 'UOrionHeroData::MinAllowedDifficulty' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, MaxAllowedDifficulty) == 0x000514, "Member 'UOrionHeroData::MaxAllowedDifficulty' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, MasteryRecipe) == 0x000518, "Member 'UOrionHeroData::MasteryRecipe' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, bPrototypeHero) == 0x000522, "Member 'UOrionHeroData::bPrototypeHero' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, SimpleActor) == 0x000528, "Member 'UOrionHeroData::SimpleActor' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, bReworkVersionEnabled) == 0x000550, "Member 'UOrionHeroData::bReworkVersionEnabled' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, ReworkAbilitiesWeakRef) == 0x000558, "Member 'UOrionHeroData::ReworkAbilitiesWeakRef' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, ReworkCharacterData) == 0x000568, "Member 'UOrionHeroData::ReworkCharacterData' has a wrong offset!");
static_assert(offsetof(UOrionHeroData, CameraModeClass) == 0x000570, "Member 'UOrionHeroData::CameraModeClass' has a wrong offset!");

// Class OrionGame.OrionCmsManager
// 0x00B8 (0x00E0 - 0x0028)
class UOrionCmsManager final : public UObject
{
public:
	uint8                                         Pad_28[0x78];                                      // 0x0028(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CmsEndpointOverride;                               // 0x00A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRefreshing;                                       // 0x00B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B1[0x2F];                                      // 0x00B1(0x002F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCmsManager">();
	}
	static class UOrionCmsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionCmsManager>();
	}
};
static_assert(alignof(UOrionCmsManager) == 0x000008, "Wrong alignment on UOrionCmsManager");
static_assert(sizeof(UOrionCmsManager) == 0x0000E0, "Wrong size on UOrionCmsManager");
static_assert(offsetof(UOrionCmsManager, CmsEndpointOverride) == 0x0000A0, "Member 'UOrionCmsManager::CmsEndpointOverride' has a wrong offset!");
static_assert(offsetof(UOrionCmsManager, bRefreshing) == 0x0000B0, "Member 'UOrionCmsManager::bRefreshing' has a wrong offset!");

// Class OrionGame.OrionCombatSet
// 0x0068 (0x0098 - 0x0030)
class UOrionCombatSet final : public UOrionAttributeSet
{
public:
	float                                         BasePower;                                         // 0x0030(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftClickBasePower;                                // 0x0034(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftClickARC;                                      // 0x0038(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackRating;                                      // 0x003C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackRatingCoeffecient;                           // 0x0040(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageBonusSource;                                 // 0x0044(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldPenetration;                                 // 0x0048(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlatDamageBonus;                                   // 0x004C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BasicPenetrationRating;                            // 0x0050(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AbilityPenetrationRating;                          // 0x0054(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BasicPenetrationPCT;                               // 0x0058(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AbilityPenetrationPCT;                             // 0x005C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicalPenetrationRating;                         // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnergyPenetrationRating;                           // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealingBonusSource;                                // 0x0068(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackSpeedRating;                                 // 0x006C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseAttackTime;                                    // 0x0070(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeStealRating;                                   // 0x0074(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeGrantRating;                                   // 0x0078(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerseveranceRating;                                // 0x007C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageToEnergyConversionRating;                    // 0x0080(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AoERating;                                         // 0x0084(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CleaveRating;                                      // 0x0088(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalDamageChance;                              // 0x008C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalDamageBonus;                               // 0x0090(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_AbilityPenetrationPCT();
	void OnRep_AbilityPenetrationRating();
	void OnRep_AoERating();
	void OnRep_AttackRating();
	void OnRep_AttackRatingCoeffecient();
	void OnRep_AttackSpeedRating();
	void OnRep_BaseAttackTime();
	void OnRep_BasePower();
	void OnRep_BasicPenetrationPCT();
	void OnRep_BasicPenetrationRating();
	void OnRep_CleaveRating();
	void OnRep_CriticalDamageBonus();
	void OnRep_CriticalDamageChance();
	void OnRep_DamageBonusSource();
	void OnRep_DamageToEnergyConversionRating();
	void OnRep_FlatDamageBonus();
	void OnRep_HealingBonusSource();
	void OnRep_LeftClickARC();
	void OnRep_LeftClickBasePower();
	void OnRep_LifeGrantRating();
	void OnRep_LifeStealRating();
	void OnRep_PerseveranceRating();
	void OnRep_ShieldPenetration();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCombatSet">();
	}
	static class UOrionCombatSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionCombatSet>();
	}
};
static_assert(alignof(UOrionCombatSet) == 0x000008, "Wrong alignment on UOrionCombatSet");
static_assert(sizeof(UOrionCombatSet) == 0x000098, "Wrong size on UOrionCombatSet");
static_assert(offsetof(UOrionCombatSet, BasePower) == 0x000030, "Member 'UOrionCombatSet::BasePower' has a wrong offset!");
static_assert(offsetof(UOrionCombatSet, LeftClickBasePower) == 0x000034, "Member 'UOrionCombatSet::LeftClickBasePower' has a wrong offset!");
static_assert(offsetof(UOrionCombatSet, LeftClickARC) == 0x000038, "Member 'UOrionCombatSet::LeftClickARC' has a wrong offset!");
static_assert(offsetof(UOrionCombatSet, AttackRating) == 0x00003C, "Member 'UOrionCombatSet::AttackRating' has a wrong offset!");
static_assert(offsetof(UOrionCombatSet, AttackRatingCoeffecient) == 0x000040, "Member 'UOrionCombatSet::AttackRatingCoeffecient' has a wrong offset!");
static_assert(offsetof(UOrionCombatSet, DamageBonusSource) == 0x000044, "Member 'UOrionCombatSet::DamageBonusSource' has a wrong offset!");
static_assert(offsetof(UOrionCombatSet, ShieldPenetration) == 0x000048, "Member 'UOrionCombatSet::ShieldPenetration' has a wrong offset!");
static_assert(offsetof(UOrionCombatSet, FlatDamageBonus) == 0x00004C, "Member 'UOrionCombatSet::FlatDamageBonus' has a wrong offset!");
static_assert(offsetof(UOrionCombatSet, BasicPenetrationRating) == 0x000050, "Member 'UOrionCombatSet::BasicPenetrationRating' has a wrong offset!");
static_assert(offsetof(UOrionCombatSet, AbilityPenetrationRating) == 0x000054, "Member 'UOrionCombatSet::AbilityPenetrationRating' has a wrong offset!");
static_assert(offsetof(UOrionCombatSet, BasicPenetrationPCT) == 0x000058, "Member 'UOrionCombatSet::BasicPenetrationPCT' has a wrong offset!");
static_assert(offsetof(UOrionCombatSet, AbilityPenetrationPCT) == 0x00005C, "Member 'UOrionCombatSet::AbilityPenetrationPCT' has a wrong offset!");
static_assert(offsetof(UOrionCombatSet, PhysicalPenetrationRating) == 0x000060, "Member 'UOrionCombatSet::PhysicalPenetrationRating' has a wrong offset!");
static_assert(offsetof(UOrionCombatSet, EnergyPenetrationRating) == 0x000064, "Member 'UOrionCombatSet::EnergyPenetrationRating' has a wrong offset!");
static_assert(offsetof(UOrionCombatSet, HealingBonusSource) == 0x000068, "Member 'UOrionCombatSet::HealingBonusSource' has a wrong offset!");
static_assert(offsetof(UOrionCombatSet, AttackSpeedRating) == 0x00006C, "Member 'UOrionCombatSet::AttackSpeedRating' has a wrong offset!");
static_assert(offsetof(UOrionCombatSet, BaseAttackTime) == 0x000070, "Member 'UOrionCombatSet::BaseAttackTime' has a wrong offset!");
static_assert(offsetof(UOrionCombatSet, LifeStealRating) == 0x000074, "Member 'UOrionCombatSet::LifeStealRating' has a wrong offset!");
static_assert(offsetof(UOrionCombatSet, LifeGrantRating) == 0x000078, "Member 'UOrionCombatSet::LifeGrantRating' has a wrong offset!");
static_assert(offsetof(UOrionCombatSet, PerseveranceRating) == 0x00007C, "Member 'UOrionCombatSet::PerseveranceRating' has a wrong offset!");
static_assert(offsetof(UOrionCombatSet, DamageToEnergyConversionRating) == 0x000080, "Member 'UOrionCombatSet::DamageToEnergyConversionRating' has a wrong offset!");
static_assert(offsetof(UOrionCombatSet, AoERating) == 0x000084, "Member 'UOrionCombatSet::AoERating' has a wrong offset!");
static_assert(offsetof(UOrionCombatSet, CleaveRating) == 0x000088, "Member 'UOrionCombatSet::CleaveRating' has a wrong offset!");
static_assert(offsetof(UOrionCombatSet, CriticalDamageChance) == 0x00008C, "Member 'UOrionCombatSet::CriticalDamageChance' has a wrong offset!");
static_assert(offsetof(UOrionCombatSet, CriticalDamageBonus) == 0x000090, "Member 'UOrionCombatSet::CriticalDamageBonus' has a wrong offset!");

// Class OrionGame.OrionBoostItemDefinition
// 0x0008 (0x0270 - 0x0268)
class UOrionBoostItemDefinition final : public UOrionMcpItemDefinition
{
public:
	EOrionBoostType                               BoostType;                                         // 0x0268(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_269[0x3];                                      // 0x0269(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DurationInHours;                                   // 0x026C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionBoostItemDefinition">();
	}
	static class UOrionBoostItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionBoostItemDefinition>();
	}
};
static_assert(alignof(UOrionBoostItemDefinition) == 0x000008, "Wrong alignment on UOrionBoostItemDefinition");
static_assert(sizeof(UOrionBoostItemDefinition) == 0x000270, "Wrong size on UOrionBoostItemDefinition");
static_assert(offsetof(UOrionBoostItemDefinition, BoostType) == 0x000268, "Member 'UOrionBoostItemDefinition::BoostType' has a wrong offset!");
static_assert(offsetof(UOrionBoostItemDefinition, DurationInHours) == 0x00026C, "Member 'UOrionBoostItemDefinition::DurationInHours' has a wrong offset!");

// Class OrionGame.OrionCooldown
// 0x0000 (0x0040 - 0x0040)
class UOrionCooldown final : public UGameplayEffectExecutionCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCooldown">();
	}
	static class UOrionCooldown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionCooldown>();
	}
};
static_assert(alignof(UOrionCooldown) == 0x000008, "Wrong alignment on UOrionCooldown");
static_assert(sizeof(UOrionCooldown) == 0x000040, "Wrong size on UOrionCooldown");

// Class OrionGame.OrionCoreBaseAnimInstance
// 0x0518 (0x0930 - 0x0418)
class UOrionCoreBaseAnimInstance final : public UOrionAnimInstance
{
public:
	uint8                                         Pad_418[0x8];                                      // 0x0418(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionCoreBaseAnimInstanceProxy        Proxy;                                             // 0x0420(0x0510)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCoreBaseAnimInstance">();
	}
	static class UOrionCoreBaseAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionCoreBaseAnimInstance>();
	}
};
static_assert(alignof(UOrionCoreBaseAnimInstance) == 0x000010, "Wrong alignment on UOrionCoreBaseAnimInstance");
static_assert(sizeof(UOrionCoreBaseAnimInstance) == 0x000930, "Wrong size on UOrionCoreBaseAnimInstance");
static_assert(offsetof(UOrionCoreBaseAnimInstance, Proxy) == 0x000420, "Member 'UOrionCoreBaseAnimInstance::Proxy' has a wrong offset!");

// Class OrionGame.OrionMcpCardPackItemDefinition
// 0x0138 (0x03A0 - 0x0268)
class UOrionMcpCardPackItemDefinition final : public UOrionMcpItemDefinition
{
public:
	TArray<struct FOrionMcpCardPackLoot>          Loot;                                              // 0x0268(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EOrionCardPackType                            CardPackType;                                      // 0x0278(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ShortName;                                         // 0x0280(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bAutoOpen;                                         // 0x0298(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 OptionalSubcategory;                               // 0x02A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UOrionMcpItemDefinition>> ExplicitItems;                                     // 0x02B0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FOrionMcpCardPackPreviewItem>   PreviewItems;                                      // 0x02C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOrionMcpCardPackCalloutItem>   StandardItems;                                     // 0x02D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UObject>                 OpenScreenDisplayAsset;                            // 0x02E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DisplayActor;                                      // 0x0308(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_330[0x70];                                     // 0x0330(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetExplicitCards(TArray<class UOrionLegacyCardItemDefinition*>* Cards) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpCardPackItemDefinition">();
	}
	static class UOrionMcpCardPackItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpCardPackItemDefinition>();
	}
};
static_assert(alignof(UOrionMcpCardPackItemDefinition) == 0x000008, "Wrong alignment on UOrionMcpCardPackItemDefinition");
static_assert(sizeof(UOrionMcpCardPackItemDefinition) == 0x0003A0, "Wrong size on UOrionMcpCardPackItemDefinition");
static_assert(offsetof(UOrionMcpCardPackItemDefinition, Loot) == 0x000268, "Member 'UOrionMcpCardPackItemDefinition::Loot' has a wrong offset!");
static_assert(offsetof(UOrionMcpCardPackItemDefinition, CardPackType) == 0x000278, "Member 'UOrionMcpCardPackItemDefinition::CardPackType' has a wrong offset!");
static_assert(offsetof(UOrionMcpCardPackItemDefinition, ShortName) == 0x000280, "Member 'UOrionMcpCardPackItemDefinition::ShortName' has a wrong offset!");
static_assert(offsetof(UOrionMcpCardPackItemDefinition, bAutoOpen) == 0x000298, "Member 'UOrionMcpCardPackItemDefinition::bAutoOpen' has a wrong offset!");
static_assert(offsetof(UOrionMcpCardPackItemDefinition, OptionalSubcategory) == 0x0002A0, "Member 'UOrionMcpCardPackItemDefinition::OptionalSubcategory' has a wrong offset!");
static_assert(offsetof(UOrionMcpCardPackItemDefinition, ExplicitItems) == 0x0002B0, "Member 'UOrionMcpCardPackItemDefinition::ExplicitItems' has a wrong offset!");
static_assert(offsetof(UOrionMcpCardPackItemDefinition, PreviewItems) == 0x0002C0, "Member 'UOrionMcpCardPackItemDefinition::PreviewItems' has a wrong offset!");
static_assert(offsetof(UOrionMcpCardPackItemDefinition, StandardItems) == 0x0002D0, "Member 'UOrionMcpCardPackItemDefinition::StandardItems' has a wrong offset!");
static_assert(offsetof(UOrionMcpCardPackItemDefinition, OpenScreenDisplayAsset) == 0x0002E0, "Member 'UOrionMcpCardPackItemDefinition::OpenScreenDisplayAsset' has a wrong offset!");
static_assert(offsetof(UOrionMcpCardPackItemDefinition, DisplayActor) == 0x000308, "Member 'UOrionMcpCardPackItemDefinition::DisplayActor' has a wrong offset!");

// Class OrionGame.OrionHeroIceAnimInstance
// 0x0000 (0x11C0 - 0x11C0)
class UOrionHeroIceAnimInstance final : public UOrionHeroAnimInstance
{
public:
	float                                         RootWeaponConstraintAlpha;                         // 0x11B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11BC[0x4];                                     // 0x11BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHeroIceAnimInstance">();
	}
	static class UOrionHeroIceAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHeroIceAnimInstance>();
	}
};
static_assert(alignof(UOrionHeroIceAnimInstance) == 0x000010, "Wrong alignment on UOrionHeroIceAnimInstance");
static_assert(sizeof(UOrionHeroIceAnimInstance) == 0x0011C0, "Wrong size on UOrionHeroIceAnimInstance");
static_assert(offsetof(UOrionHeroIceAnimInstance, RootWeaponConstraintAlpha) == 0x0011B8, "Member 'UOrionHeroIceAnimInstance::RootWeaponConstraintAlpha' has a wrong offset!");

// Class OrionGame.OrionCraftingDeviceGlyph
// 0x0008 (0x03F0 - 0x03E8)
class AOrionCraftingDeviceGlyph final : public AOrionBaseActor
{
public:
	uint8                                         Pad_3E8[0x8];                                      // 0x03E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActivationChanged(bool bActivated);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCraftingDeviceGlyph">();
	}
	static class AOrionCraftingDeviceGlyph* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionCraftingDeviceGlyph>();
	}
};
static_assert(alignof(AOrionCraftingDeviceGlyph) == 0x000008, "Wrong alignment on AOrionCraftingDeviceGlyph");
static_assert(sizeof(AOrionCraftingDeviceGlyph) == 0x0003F0, "Wrong size on AOrionCraftingDeviceGlyph");

// Class OrionGame.OrionCraftingDeviceNode
// 0x0020 (0x0408 - 0x03E8)
class AOrionCraftingDeviceNode final : public AOrionBaseActor
{
public:
	class UWidgetComponent*                       QuantityWidgetComponent;                           // 0x03E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTimelineComponent*                     SlotComponentTimeline;                             // 0x03F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F8[0x10];                                     // 0x03F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UTimelineComponent* GetSlotComponentTimelineDirectly();
	void OnActivationChanged(bool bActivated);
	void OnComponentSlotted(class UOrionComponentItemDefinition* SlottedComponent, class UMaterialInterface* ComponentIconMaterial, int32 Weight);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCraftingDeviceNode">();
	}
	static class AOrionCraftingDeviceNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionCraftingDeviceNode>();
	}
};
static_assert(alignof(AOrionCraftingDeviceNode) == 0x000008, "Wrong alignment on AOrionCraftingDeviceNode");
static_assert(sizeof(AOrionCraftingDeviceNode) == 0x000408, "Wrong size on AOrionCraftingDeviceNode");
static_assert(offsetof(AOrionCraftingDeviceNode, QuantityWidgetComponent) == 0x0003E8, "Member 'AOrionCraftingDeviceNode::QuantityWidgetComponent' has a wrong offset!");
static_assert(offsetof(AOrionCraftingDeviceNode, SlotComponentTimeline) == 0x0003F0, "Member 'AOrionCraftingDeviceNode::SlotComponentTimeline' has a wrong offset!");

// Class OrionGame.OrionMcpComponentItem
// 0x0000 (0x0078 - 0x0078)
class UOrionMcpComponentItem final : public UOrionMcpItem
{
public:
	class UOrionComponentItemDefinition* GetInternalData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpComponentItem">();
	}
	static class UOrionMcpComponentItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpComponentItem>();
	}
};
static_assert(alignof(UOrionMcpComponentItem) == 0x000008, "Wrong alignment on UOrionMcpComponentItem");
static_assert(sizeof(UOrionMcpComponentItem) == 0x000078, "Wrong size on UOrionMcpComponentItem");

// Class OrionGame.OrionHeroArcBladeAnimInstance
// 0x0010 (0x11D0 - 0x11C0)
class UOrionHeroArcBladeAnimInstance final : public UOrionHeroAnimInstance
{
public:
	float                                         RHandIKAlpha;                                      // 0x11B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RHandIKTravelModeAlpha;                            // 0x11BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CopyWeaponBoneAlpha;                               // 0x11C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C4[0xC];                                     // 0x11C4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHeroArcBladeAnimInstance">();
	}
	static class UOrionHeroArcBladeAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHeroArcBladeAnimInstance>();
	}
};
static_assert(alignof(UOrionHeroArcBladeAnimInstance) == 0x000010, "Wrong alignment on UOrionHeroArcBladeAnimInstance");
static_assert(sizeof(UOrionHeroArcBladeAnimInstance) == 0x0011D0, "Wrong size on UOrionHeroArcBladeAnimInstance");
static_assert(offsetof(UOrionHeroArcBladeAnimInstance, RHandIKAlpha) == 0x0011B8, "Member 'UOrionHeroArcBladeAnimInstance::RHandIKAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroArcBladeAnimInstance, RHandIKTravelModeAlpha) == 0x0011BC, "Member 'UOrionHeroArcBladeAnimInstance::RHandIKTravelModeAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroArcBladeAnimInstance, CopyWeaponBoneAlpha) == 0x0011C0, "Member 'UOrionHeroArcBladeAnimInstance::CopyWeaponBoneAlpha' has a wrong offset!");

// Class OrionGame.OrionCraftingConstellation
// 0x0060 (0x0090 - 0x0030)
class UOrionCraftingConstellation final : public UDataAsset
{
public:
	TArray<struct FConstellationDrawPhase>        DrawPhases;                                        // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<int32, struct FConstellationNodeWeight>  NodeWeightsByIndex;                                // 0x0040(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCraftingConstellation">();
	}
	static class UOrionCraftingConstellation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionCraftingConstellation>();
	}
};
static_assert(alignof(UOrionCraftingConstellation) == 0x000008, "Wrong alignment on UOrionCraftingConstellation");
static_assert(sizeof(UOrionCraftingConstellation) == 0x000090, "Wrong size on UOrionCraftingConstellation");
static_assert(offsetof(UOrionCraftingConstellation, DrawPhases) == 0x000030, "Member 'UOrionCraftingConstellation::DrawPhases' has a wrong offset!");
static_assert(offsetof(UOrionCraftingConstellation, NodeWeightsByIndex) == 0x000040, "Member 'UOrionCraftingConstellation::NodeWeightsByIndex' has a wrong offset!");

// Class OrionGame.OrionCustomProjectileHitInterface
// 0x0000 (0x0028 - 0x0028)
class IOrionCustomProjectileHitInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCustomProjectileHitInterface">();
	}
	static class IOrionCustomProjectileHitInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOrionCustomProjectileHitInterface>();
	}
};
static_assert(alignof(IOrionCustomProjectileHitInterface) == 0x000008, "Wrong alignment on IOrionCustomProjectileHitInterface");
static_assert(sizeof(IOrionCustomProjectileHitInterface) == 0x000028, "Wrong size on IOrionCustomProjectileHitInterface");

// Class OrionGame.OrionCustomStoreContentWidget
// 0x0138 (0x03F0 - 0x02B8)
class UOrionCustomStoreContentWidget : public UOrionUserWidgetBase
{
public:
	struct FStoreOfferBP                          StoreOffer;                                        // 0x02B8(0x0130)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E8[0x8];                                      // 0x03E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOfferSet(const struct FStoreOfferBP& InOffer);
	void SetOffer(const struct FStoreOfferBP& InOffer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionCustomStoreContentWidget">();
	}
	static class UOrionCustomStoreContentWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionCustomStoreContentWidget>();
	}
};
static_assert(alignof(UOrionCustomStoreContentWidget) == 0x000008, "Wrong alignment on UOrionCustomStoreContentWidget");
static_assert(sizeof(UOrionCustomStoreContentWidget) == 0x0003F0, "Wrong size on UOrionCustomStoreContentWidget");
static_assert(offsetof(UOrionCustomStoreContentWidget, StoreOffer) == 0x0002B8, "Member 'UOrionCustomStoreContentWidget::StoreOffer' has a wrong offset!");

// Class OrionGame.OrionHeroTwinblastAnimInstance
// 0x0090 (0x1250 - 0x11C0)
class UOrionHeroTwinblastAnimInstance final : public UOrionHeroAnimInstance
{
public:
	float                                         NitroAdditiveWeight;                               // 0x11B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11BC[0x4];                                     // 0x11BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedAnimStateData                   NitroAdditiveIdleCachedState;                      // 0x11C0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 UltimateGunSkelMeshComp;                           // 0x11E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UltimateGunVisibleCurveName;                       // 0x11E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UltimateGunVisibleCurveWeight;                     // 0x11F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UltimateHitReactMaxAlpha;                          // 0x11F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UltimateActiveAlpha;                               // 0x11F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUltimateFiringCurveRelevant;                      // 0x11FC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11FD[0x3];                                     // 0x11FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TravelModeCorrectiveOverrideCurveName;             // 0x1200(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TravelModeCorrectiveTargetWeight;                  // 0x1208(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TravelModeCorrectiveAlpha;                         // 0x120C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TravelModeCorrectiveWeight;                        // 0x1210(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldTransitionToUpperBodyMSA_PrimaryWeapons;    // 0x1214(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1215[0x3];                                     // 0x1215(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAnimMontage*>                   PrimaryWeaponRightFireMontage;                     // 0x1218(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   PrimaryWeaponLeftFireMontage;                      // 0x1228(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bPrimaryFireLeftIsOnCooldown;                      // 0x1238(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1239[0x3];                                     // 0x1239(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PrimaryFireBlendWeight;                            // 0x123C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrimaryFireTurnAlpha;                              // 0x1240(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOpenArmVents;                                     // 0x1244(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1245[0x3];                                     // 0x1245(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ArmVentOpenCountDown;                              // 0x1248(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124C[0x4];                                     // 0x124C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OpenArmVent(float OpenTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHeroTwinblastAnimInstance">();
	}
	static class UOrionHeroTwinblastAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHeroTwinblastAnimInstance>();
	}
};
static_assert(alignof(UOrionHeroTwinblastAnimInstance) == 0x000010, "Wrong alignment on UOrionHeroTwinblastAnimInstance");
static_assert(sizeof(UOrionHeroTwinblastAnimInstance) == 0x001250, "Wrong size on UOrionHeroTwinblastAnimInstance");
static_assert(offsetof(UOrionHeroTwinblastAnimInstance, NitroAdditiveWeight) == 0x0011B8, "Member 'UOrionHeroTwinblastAnimInstance::NitroAdditiveWeight' has a wrong offset!");
static_assert(offsetof(UOrionHeroTwinblastAnimInstance, NitroAdditiveIdleCachedState) == 0x0011C0, "Member 'UOrionHeroTwinblastAnimInstance::NitroAdditiveIdleCachedState' has a wrong offset!");
static_assert(offsetof(UOrionHeroTwinblastAnimInstance, UltimateGunSkelMeshComp) == 0x0011E0, "Member 'UOrionHeroTwinblastAnimInstance::UltimateGunSkelMeshComp' has a wrong offset!");
static_assert(offsetof(UOrionHeroTwinblastAnimInstance, UltimateGunVisibleCurveName) == 0x0011E8, "Member 'UOrionHeroTwinblastAnimInstance::UltimateGunVisibleCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroTwinblastAnimInstance, UltimateGunVisibleCurveWeight) == 0x0011F0, "Member 'UOrionHeroTwinblastAnimInstance::UltimateGunVisibleCurveWeight' has a wrong offset!");
static_assert(offsetof(UOrionHeroTwinblastAnimInstance, UltimateHitReactMaxAlpha) == 0x0011F4, "Member 'UOrionHeroTwinblastAnimInstance::UltimateHitReactMaxAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroTwinblastAnimInstance, UltimateActiveAlpha) == 0x0011F8, "Member 'UOrionHeroTwinblastAnimInstance::UltimateActiveAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroTwinblastAnimInstance, bUltimateFiringCurveRelevant) == 0x0011FC, "Member 'UOrionHeroTwinblastAnimInstance::bUltimateFiringCurveRelevant' has a wrong offset!");
static_assert(offsetof(UOrionHeroTwinblastAnimInstance, TravelModeCorrectiveOverrideCurveName) == 0x001200, "Member 'UOrionHeroTwinblastAnimInstance::TravelModeCorrectiveOverrideCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroTwinblastAnimInstance, TravelModeCorrectiveTargetWeight) == 0x001208, "Member 'UOrionHeroTwinblastAnimInstance::TravelModeCorrectiveTargetWeight' has a wrong offset!");
static_assert(offsetof(UOrionHeroTwinblastAnimInstance, TravelModeCorrectiveAlpha) == 0x00120C, "Member 'UOrionHeroTwinblastAnimInstance::TravelModeCorrectiveAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroTwinblastAnimInstance, TravelModeCorrectiveWeight) == 0x001210, "Member 'UOrionHeroTwinblastAnimInstance::TravelModeCorrectiveWeight' has a wrong offset!");
static_assert(offsetof(UOrionHeroTwinblastAnimInstance, bShouldTransitionToUpperBodyMSA_PrimaryWeapons) == 0x001214, "Member 'UOrionHeroTwinblastAnimInstance::bShouldTransitionToUpperBodyMSA_PrimaryWeapons' has a wrong offset!");
static_assert(offsetof(UOrionHeroTwinblastAnimInstance, PrimaryWeaponRightFireMontage) == 0x001218, "Member 'UOrionHeroTwinblastAnimInstance::PrimaryWeaponRightFireMontage' has a wrong offset!");
static_assert(offsetof(UOrionHeroTwinblastAnimInstance, PrimaryWeaponLeftFireMontage) == 0x001228, "Member 'UOrionHeroTwinblastAnimInstance::PrimaryWeaponLeftFireMontage' has a wrong offset!");
static_assert(offsetof(UOrionHeroTwinblastAnimInstance, bPrimaryFireLeftIsOnCooldown) == 0x001238, "Member 'UOrionHeroTwinblastAnimInstance::bPrimaryFireLeftIsOnCooldown' has a wrong offset!");
static_assert(offsetof(UOrionHeroTwinblastAnimInstance, PrimaryFireBlendWeight) == 0x00123C, "Member 'UOrionHeroTwinblastAnimInstance::PrimaryFireBlendWeight' has a wrong offset!");
static_assert(offsetof(UOrionHeroTwinblastAnimInstance, PrimaryFireTurnAlpha) == 0x001240, "Member 'UOrionHeroTwinblastAnimInstance::PrimaryFireTurnAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroTwinblastAnimInstance, bOpenArmVents) == 0x001244, "Member 'UOrionHeroTwinblastAnimInstance::bOpenArmVents' has a wrong offset!");
static_assert(offsetof(UOrionHeroTwinblastAnimInstance, ArmVentOpenCountDown) == 0x001248, "Member 'UOrionHeroTwinblastAnimInstance::ArmVentOpenCountDown' has a wrong offset!");

// Class OrionGame.OrionDamage
// 0x0030 (0x0070 - 0x0040)
class UOrionDamage : public UGameplayEffectExecutionCalculation
{
public:
	TSubclassOf<class UGameplayEffect>            LifeStealGameplayEffect;                           // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            PerseveranceShieldGameplayEffect;                  // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            DamageToEnergyConversionGameplayEffect;            // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x18];                                      // 0x0058(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionDamage">();
	}
	static class UOrionDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionDamage>();
	}
};
static_assert(alignof(UOrionDamage) == 0x000008, "Wrong alignment on UOrionDamage");
static_assert(sizeof(UOrionDamage) == 0x000070, "Wrong size on UOrionDamage");
static_assert(offsetof(UOrionDamage, LifeStealGameplayEffect) == 0x000040, "Member 'UOrionDamage::LifeStealGameplayEffect' has a wrong offset!");
static_assert(offsetof(UOrionDamage, PerseveranceShieldGameplayEffect) == 0x000048, "Member 'UOrionDamage::PerseveranceShieldGameplayEffect' has a wrong offset!");
static_assert(offsetof(UOrionDamage, DamageToEnergyConversionGameplayEffect) == 0x000050, "Member 'UOrionDamage::DamageToEnergyConversionGameplayEffect' has a wrong offset!");

// Class OrionGame.OrionHeroPyroAnimInstance
// 0x0080 (0x1240 - 0x11C0)
class UOrionHeroPyroAnimInstance final : public UOrionHeroAnimInstance
{
public:
	struct FOrionHeroAllowedTransitions           UltimateAllowedTransitionFlags;                    // 0x11B8(0x0007)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsUltimateActive;                                 // 0x11BF(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUltimateAnimationActive;                        // 0x11C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOilTrailAnimationActive;                        // 0x11C1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C2[0x2];                                     // 0x11C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurretLockToDispencerAlpha;                        // 0x11C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurretAnimDynamicsAlpha;                           // 0x11C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11CC[0x4];                                     // 0x11CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   UnlockTurretFromDispencerCurveName;                // 0x11D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockBottleToPelvisCurveAlpha;                      // 0x11D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11DC[0x4];                                     // 0x11DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LockBottleToPelvisCurveName;                       // 0x11E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpperBodyMSA_R_ExitCancel_EarlyOut;               // 0x11E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceSimpleIdleBreak;                             // 0x11E9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11EA[0x6];                                     // 0x11EA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BottleScaleCurveName;                              // 0x11F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BottleScaleCurveAlpha;                             // 0x11F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftHandIKAlpha;                                   // 0x11FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightHandIKAlpha;                                  // 0x1200(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UltimateIdleToTurningInPlaceAlpha;                 // 0x1204(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UltimateSmoothedTurnSpeed;                         // 0x1208(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UltimateTurnSign;                                  // 0x120C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRK4SpringInterpolator            UltimateRotationRateInterpolator;                  // 0x1210(0x0008)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1218[0x28];                                    // 0x1218(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHeroPyroAnimInstance">();
	}
	static class UOrionHeroPyroAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHeroPyroAnimInstance>();
	}
};
static_assert(alignof(UOrionHeroPyroAnimInstance) == 0x000010, "Wrong alignment on UOrionHeroPyroAnimInstance");
static_assert(sizeof(UOrionHeroPyroAnimInstance) == 0x001240, "Wrong size on UOrionHeroPyroAnimInstance");
static_assert(offsetof(UOrionHeroPyroAnimInstance, UltimateAllowedTransitionFlags) == 0x0011B8, "Member 'UOrionHeroPyroAnimInstance::UltimateAllowedTransitionFlags' has a wrong offset!");
static_assert(offsetof(UOrionHeroPyroAnimInstance, bIsUltimateActive) == 0x0011BF, "Member 'UOrionHeroPyroAnimInstance::bIsUltimateActive' has a wrong offset!");
static_assert(offsetof(UOrionHeroPyroAnimInstance, bIsUltimateAnimationActive) == 0x0011C0, "Member 'UOrionHeroPyroAnimInstance::bIsUltimateAnimationActive' has a wrong offset!");
static_assert(offsetof(UOrionHeroPyroAnimInstance, bIsOilTrailAnimationActive) == 0x0011C1, "Member 'UOrionHeroPyroAnimInstance::bIsOilTrailAnimationActive' has a wrong offset!");
static_assert(offsetof(UOrionHeroPyroAnimInstance, TurretLockToDispencerAlpha) == 0x0011C4, "Member 'UOrionHeroPyroAnimInstance::TurretLockToDispencerAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroPyroAnimInstance, TurretAnimDynamicsAlpha) == 0x0011C8, "Member 'UOrionHeroPyroAnimInstance::TurretAnimDynamicsAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroPyroAnimInstance, UnlockTurretFromDispencerCurveName) == 0x0011D0, "Member 'UOrionHeroPyroAnimInstance::UnlockTurretFromDispencerCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroPyroAnimInstance, LockBottleToPelvisCurveAlpha) == 0x0011D8, "Member 'UOrionHeroPyroAnimInstance::LockBottleToPelvisCurveAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroPyroAnimInstance, LockBottleToPelvisCurveName) == 0x0011E0, "Member 'UOrionHeroPyroAnimInstance::LockBottleToPelvisCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroPyroAnimInstance, bUpperBodyMSA_R_ExitCancel_EarlyOut) == 0x0011E8, "Member 'UOrionHeroPyroAnimInstance::bUpperBodyMSA_R_ExitCancel_EarlyOut' has a wrong offset!");
static_assert(offsetof(UOrionHeroPyroAnimInstance, bForceSimpleIdleBreak) == 0x0011E9, "Member 'UOrionHeroPyroAnimInstance::bForceSimpleIdleBreak' has a wrong offset!");
static_assert(offsetof(UOrionHeroPyroAnimInstance, BottleScaleCurveName) == 0x0011F0, "Member 'UOrionHeroPyroAnimInstance::BottleScaleCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroPyroAnimInstance, BottleScaleCurveAlpha) == 0x0011F8, "Member 'UOrionHeroPyroAnimInstance::BottleScaleCurveAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroPyroAnimInstance, LeftHandIKAlpha) == 0x0011FC, "Member 'UOrionHeroPyroAnimInstance::LeftHandIKAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroPyroAnimInstance, RightHandIKAlpha) == 0x001200, "Member 'UOrionHeroPyroAnimInstance::RightHandIKAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroPyroAnimInstance, UltimateIdleToTurningInPlaceAlpha) == 0x001204, "Member 'UOrionHeroPyroAnimInstance::UltimateIdleToTurningInPlaceAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroPyroAnimInstance, UltimateSmoothedTurnSpeed) == 0x001208, "Member 'UOrionHeroPyroAnimInstance::UltimateSmoothedTurnSpeed' has a wrong offset!");
static_assert(offsetof(UOrionHeroPyroAnimInstance, UltimateTurnSign) == 0x00120C, "Member 'UOrionHeroPyroAnimInstance::UltimateTurnSign' has a wrong offset!");
static_assert(offsetof(UOrionHeroPyroAnimInstance, UltimateRotationRateInterpolator) == 0x001210, "Member 'UOrionHeroPyroAnimInstance::UltimateRotationRateInterpolator' has a wrong offset!");

// Class OrionGame.OrionExecute
// 0x0000 (0x0070 - 0x0070)
class UOrionExecute final : public UOrionDamage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionExecute">();
	}
	static class UOrionExecute* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionExecute>();
	}
};
static_assert(alignof(UOrionExecute) == 0x000008, "Wrong alignment on UOrionExecute");
static_assert(sizeof(UOrionExecute) == 0x000070, "Wrong size on UOrionExecute");

// Class OrionGame.OrionHeroWukongAnimInstance
// 0x0080 (0x1240 - 0x11C0)
class UOrionHeroWukongAnimInstance final : public UOrionHeroAnimInstance
{
public:
	bool                                          bIsAirWalking;                                     // 0x11B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOffensiveMode;                                  // 0x11B9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoingAimedArmsAndHeadMontage;                     // 0x11BA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11BB[0x1];                                     // 0x11BB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ArmsAndHeadWeight_Up;                              // 0x11BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmsAndHeadWeight_Mid;                             // 0x11C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmsAndHeadWeight_Down;                            // 0x11C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmsAndHeadLimit_Up;                               // 0x11C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmsAndHeadLimit_Down;                             // 0x11CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EvadeStaffPivot;                                   // 0x11D0(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EvadeStaffPivotInvalidLocation;                    // 0x11DC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EvadeStaffPitch;                                   // 0x11E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EvadeStaffRoll;                                    // 0x11EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TailControlAlpha;                                  // 0x11F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EvadeAlpha;                                        // 0x11F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponWorldAlpha;                                  // 0x11F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisableIKAlpha;                                    // 0x11FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StaffPlantAlpha;                                   // 0x1200(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1204[0x4];                                     // 0x1204(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SlotArmsAndHeadUpName;                             // 0x1208(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SlotArmsAndHeadDownName;                           // 0x1210(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FullBodyActingCurveName;                           // 0x1218(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponWorldCurveName;                              // 0x1220(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DisableIKCurveName;                                // 0x1228(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StaffPlantCurveName;                               // 0x1230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1238[0x8];                                     // 0x1238(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHeroWukongAnimInstance">();
	}
	static class UOrionHeroWukongAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHeroWukongAnimInstance>();
	}
};
static_assert(alignof(UOrionHeroWukongAnimInstance) == 0x000010, "Wrong alignment on UOrionHeroWukongAnimInstance");
static_assert(sizeof(UOrionHeroWukongAnimInstance) == 0x001240, "Wrong size on UOrionHeroWukongAnimInstance");
static_assert(offsetof(UOrionHeroWukongAnimInstance, bIsAirWalking) == 0x0011B8, "Member 'UOrionHeroWukongAnimInstance::bIsAirWalking' has a wrong offset!");
static_assert(offsetof(UOrionHeroWukongAnimInstance, bIsOffensiveMode) == 0x0011B9, "Member 'UOrionHeroWukongAnimInstance::bIsOffensiveMode' has a wrong offset!");
static_assert(offsetof(UOrionHeroWukongAnimInstance, bDoingAimedArmsAndHeadMontage) == 0x0011BA, "Member 'UOrionHeroWukongAnimInstance::bDoingAimedArmsAndHeadMontage' has a wrong offset!");
static_assert(offsetof(UOrionHeroWukongAnimInstance, ArmsAndHeadWeight_Up) == 0x0011BC, "Member 'UOrionHeroWukongAnimInstance::ArmsAndHeadWeight_Up' has a wrong offset!");
static_assert(offsetof(UOrionHeroWukongAnimInstance, ArmsAndHeadWeight_Mid) == 0x0011C0, "Member 'UOrionHeroWukongAnimInstance::ArmsAndHeadWeight_Mid' has a wrong offset!");
static_assert(offsetof(UOrionHeroWukongAnimInstance, ArmsAndHeadWeight_Down) == 0x0011C4, "Member 'UOrionHeroWukongAnimInstance::ArmsAndHeadWeight_Down' has a wrong offset!");
static_assert(offsetof(UOrionHeroWukongAnimInstance, ArmsAndHeadLimit_Up) == 0x0011C8, "Member 'UOrionHeroWukongAnimInstance::ArmsAndHeadLimit_Up' has a wrong offset!");
static_assert(offsetof(UOrionHeroWukongAnimInstance, ArmsAndHeadLimit_Down) == 0x0011CC, "Member 'UOrionHeroWukongAnimInstance::ArmsAndHeadLimit_Down' has a wrong offset!");
static_assert(offsetof(UOrionHeroWukongAnimInstance, EvadeStaffPivot) == 0x0011D0, "Member 'UOrionHeroWukongAnimInstance::EvadeStaffPivot' has a wrong offset!");
static_assert(offsetof(UOrionHeroWukongAnimInstance, EvadeStaffPivotInvalidLocation) == 0x0011DC, "Member 'UOrionHeroWukongAnimInstance::EvadeStaffPivotInvalidLocation' has a wrong offset!");
static_assert(offsetof(UOrionHeroWukongAnimInstance, EvadeStaffPitch) == 0x0011E8, "Member 'UOrionHeroWukongAnimInstance::EvadeStaffPitch' has a wrong offset!");
static_assert(offsetof(UOrionHeroWukongAnimInstance, EvadeStaffRoll) == 0x0011EC, "Member 'UOrionHeroWukongAnimInstance::EvadeStaffRoll' has a wrong offset!");
static_assert(offsetof(UOrionHeroWukongAnimInstance, TailControlAlpha) == 0x0011F0, "Member 'UOrionHeroWukongAnimInstance::TailControlAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroWukongAnimInstance, EvadeAlpha) == 0x0011F4, "Member 'UOrionHeroWukongAnimInstance::EvadeAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroWukongAnimInstance, WeaponWorldAlpha) == 0x0011F8, "Member 'UOrionHeroWukongAnimInstance::WeaponWorldAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroWukongAnimInstance, DisableIKAlpha) == 0x0011FC, "Member 'UOrionHeroWukongAnimInstance::DisableIKAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroWukongAnimInstance, StaffPlantAlpha) == 0x001200, "Member 'UOrionHeroWukongAnimInstance::StaffPlantAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroWukongAnimInstance, SlotArmsAndHeadUpName) == 0x001208, "Member 'UOrionHeroWukongAnimInstance::SlotArmsAndHeadUpName' has a wrong offset!");
static_assert(offsetof(UOrionHeroWukongAnimInstance, SlotArmsAndHeadDownName) == 0x001210, "Member 'UOrionHeroWukongAnimInstance::SlotArmsAndHeadDownName' has a wrong offset!");
static_assert(offsetof(UOrionHeroWukongAnimInstance, FullBodyActingCurveName) == 0x001218, "Member 'UOrionHeroWukongAnimInstance::FullBodyActingCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroWukongAnimInstance, WeaponWorldCurveName) == 0x001220, "Member 'UOrionHeroWukongAnimInstance::WeaponWorldCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroWukongAnimInstance, DisableIKCurveName) == 0x001228, "Member 'UOrionHeroWukongAnimInstance::DisableIKCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroWukongAnimInstance, StaffPlantCurveName) == 0x001230, "Member 'UOrionHeroWukongAnimInstance::StaffPlantCurveName' has a wrong offset!");

// Class OrionGame.OrionPedestalHero
// 0x0048 (0x0430 - 0x03E8)
class AOrionPedestalHero : public AOrionBaseActor
{
public:
	uint8                                         Pad_3E8[0x10];                                     // 0x03E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 HeroMeshComponent;                                 // 0x03F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          HeroMesh;                                          // 0x0400(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                MeshScale;                                         // 0x0408(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_414[0x4];                                      // 0x0414(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UOrionHeroPedestalAnimInstance> PedestalAnimBP;                                    // 0x0418(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_420[0x10];                                     // 0x0420(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPedestalActorTypeSet(EPedestalActorType PedestalActorType);
	void OnSkinChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPedestalHero">();
	}
	static class AOrionPedestalHero* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionPedestalHero>();
	}
};
static_assert(alignof(AOrionPedestalHero) == 0x000008, "Wrong alignment on AOrionPedestalHero");
static_assert(sizeof(AOrionPedestalHero) == 0x000430, "Wrong size on AOrionPedestalHero");
static_assert(offsetof(AOrionPedestalHero, HeroMeshComponent) == 0x0003F8, "Member 'AOrionPedestalHero::HeroMeshComponent' has a wrong offset!");
static_assert(offsetof(AOrionPedestalHero, HeroMesh) == 0x000400, "Member 'AOrionPedestalHero::HeroMesh' has a wrong offset!");
static_assert(offsetof(AOrionPedestalHero, MeshScale) == 0x000408, "Member 'AOrionPedestalHero::MeshScale' has a wrong offset!");
static_assert(offsetof(AOrionPedestalHero, PedestalAnimBP) == 0x000418, "Member 'AOrionPedestalHero::PedestalAnimBP' has a wrong offset!");

// Class OrionGame.OrionDamageableObjective_Core
// 0x0008 (0x09C0 - 0x09B8)
class AOrionDamageableObjective_Core : public AOrionDamageableObjective_Base
{
public:
	bool                                          bExposed;                                          // 0x09B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9B9[0x7];                                      // 0x09B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionDamageableObjective_Core">();
	}
	static class AOrionDamageableObjective_Core* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionDamageableObjective_Core>();
	}
};
static_assert(alignof(AOrionDamageableObjective_Core) == 0x000008, "Wrong alignment on AOrionDamageableObjective_Core");
static_assert(sizeof(AOrionDamageableObjective_Core) == 0x0009C0, "Wrong size on AOrionDamageableObjective_Core");
static_assert(offsetof(AOrionDamageableObjective_Core, bExposed) == 0x0009B8, "Member 'AOrionDamageableObjective_Core::bExposed' has a wrong offset!");

// Class OrionGame.OrionDamageableObjective_CoreAOE
// 0x0000 (0x09C0 - 0x09C0)
class AOrionDamageableObjective_CoreAOE : public AOrionDamageableObjective_Core
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionDamageableObjective_CoreAOE">();
	}
	static class AOrionDamageableObjective_CoreAOE* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionDamageableObjective_CoreAOE>();
	}
};
static_assert(alignof(AOrionDamageableObjective_CoreAOE) == 0x000008, "Wrong alignment on AOrionDamageableObjective_CoreAOE");
static_assert(sizeof(AOrionDamageableObjective_CoreAOE) == 0x0009C0, "Wrong size on AOrionDamageableObjective_CoreAOE");

// Class OrionGame.OrionDamageableObjective_CoreSingleTarget
// 0x0000 (0x09C0 - 0x09C0)
class AOrionDamageableObjective_CoreSingleTarget : public AOrionDamageableObjective_Core
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionDamageableObjective_CoreSingleTarget">();
	}
	static class AOrionDamageableObjective_CoreSingleTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionDamageableObjective_CoreSingleTarget>();
	}
};
static_assert(alignof(AOrionDamageableObjective_CoreSingleTarget) == 0x000008, "Wrong alignment on AOrionDamageableObjective_CoreSingleTarget");
static_assert(sizeof(AOrionDamageableObjective_CoreSingleTarget) == 0x0009C0, "Wrong size on AOrionDamageableObjective_CoreSingleTarget");

// Class OrionGame.OrionHeroTomahawkAnimInstance
// 0x0020 (0x11E0 - 0x11C0)
class UOrionHeroTomahawkAnimInstance final : public UOrionHeroAnimInstance
{
public:
	float                                         FeathersAlpha;                                     // 0x11B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GhostBeastPositionFixAlpha;                        // 0x11BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceSimpleIdleBreak;                             // 0x11C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C1[0x7];                                     // 0x11C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BeastScaleCurveName;                               // 0x11C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DisableBeastPositionLockCurveName;                 // 0x11D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BeastScaleAlpha;                                   // 0x11D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11DC[0x4];                                     // 0x11DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHeroTomahawkAnimInstance">();
	}
	static class UOrionHeroTomahawkAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHeroTomahawkAnimInstance>();
	}
};
static_assert(alignof(UOrionHeroTomahawkAnimInstance) == 0x000010, "Wrong alignment on UOrionHeroTomahawkAnimInstance");
static_assert(sizeof(UOrionHeroTomahawkAnimInstance) == 0x0011E0, "Wrong size on UOrionHeroTomahawkAnimInstance");
static_assert(offsetof(UOrionHeroTomahawkAnimInstance, FeathersAlpha) == 0x0011B8, "Member 'UOrionHeroTomahawkAnimInstance::FeathersAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroTomahawkAnimInstance, GhostBeastPositionFixAlpha) == 0x0011BC, "Member 'UOrionHeroTomahawkAnimInstance::GhostBeastPositionFixAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroTomahawkAnimInstance, bForceSimpleIdleBreak) == 0x0011C0, "Member 'UOrionHeroTomahawkAnimInstance::bForceSimpleIdleBreak' has a wrong offset!");
static_assert(offsetof(UOrionHeroTomahawkAnimInstance, BeastScaleCurveName) == 0x0011C8, "Member 'UOrionHeroTomahawkAnimInstance::BeastScaleCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroTomahawkAnimInstance, DisableBeastPositionLockCurveName) == 0x0011D0, "Member 'UOrionHeroTomahawkAnimInstance::DisableBeastPositionLockCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroTomahawkAnimInstance, BeastScaleAlpha) == 0x0011D8, "Member 'UOrionHeroTomahawkAnimInstance::BeastScaleAlpha' has a wrong offset!");

// Class OrionGame.OrionDamageIndicatorDisplayData
// 0x0010 (0x0040 - 0x0030)
class UOrionDamageIndicatorDisplayData final : public UDataAsset
{
public:
	class UCurveFloat*                            OpacityCurveOverTime;                              // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            IntensityCurveOverTime;                            // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionDamageIndicatorDisplayData">();
	}
	static class UOrionDamageIndicatorDisplayData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionDamageIndicatorDisplayData>();
	}
};
static_assert(alignof(UOrionDamageIndicatorDisplayData) == 0x000008, "Wrong alignment on UOrionDamageIndicatorDisplayData");
static_assert(sizeof(UOrionDamageIndicatorDisplayData) == 0x000040, "Wrong size on UOrionDamageIndicatorDisplayData");
static_assert(offsetof(UOrionDamageIndicatorDisplayData, OpacityCurveOverTime) == 0x000030, "Member 'UOrionDamageIndicatorDisplayData::OpacityCurveOverTime' has a wrong offset!");
static_assert(offsetof(UOrionDamageIndicatorDisplayData, IntensityCurveOverTime) == 0x000038, "Member 'UOrionDamageIndicatorDisplayData::IntensityCurveOverTime' has a wrong offset!");

// Class OrionGame.OrionHeroPedestalAnimInstance
// 0x0018 (0x0430 - 0x0418)
class UOrionHeroPedestalAnimInstance : public UOrionAnimInstance
{
public:
	bool                                          bTriggerCharacterResIn;                            // 0x0418(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerIdleBreak;                                 // 0x0419(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41A[0x2];                                      // 0x041A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponScaleCurveAlpha;                             // 0x041C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFeatured;                                         // 0x0420(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_421[0xF];                                      // 0x0421(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHeroPedestalAnimInstance">();
	}
	static class UOrionHeroPedestalAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHeroPedestalAnimInstance>();
	}
};
static_assert(alignof(UOrionHeroPedestalAnimInstance) == 0x000008, "Wrong alignment on UOrionHeroPedestalAnimInstance");
static_assert(sizeof(UOrionHeroPedestalAnimInstance) == 0x000430, "Wrong size on UOrionHeroPedestalAnimInstance");
static_assert(offsetof(UOrionHeroPedestalAnimInstance, bTriggerCharacterResIn) == 0x000418, "Member 'UOrionHeroPedestalAnimInstance::bTriggerCharacterResIn' has a wrong offset!");
static_assert(offsetof(UOrionHeroPedestalAnimInstance, bTriggerIdleBreak) == 0x000419, "Member 'UOrionHeroPedestalAnimInstance::bTriggerIdleBreak' has a wrong offset!");
static_assert(offsetof(UOrionHeroPedestalAnimInstance, WeaponScaleCurveAlpha) == 0x00041C, "Member 'UOrionHeroPedestalAnimInstance::WeaponScaleCurveAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroPedestalAnimInstance, bFeatured) == 0x000420, "Member 'UOrionHeroPedestalAnimInstance::bFeatured' has a wrong offset!");

// Class OrionGame.OrionDecalLibrary
// 0x0010 (0x0040 - 0x0030)
class UOrionDecalLibrary final : public UDataAsset
{
public:
	TArray<struct FOrionDecalLibraryEntry>        Decals;                                            // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionDecalLibrary">();
	}
	static class UOrionDecalLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionDecalLibrary>();
	}
};
static_assert(alignof(UOrionDecalLibrary) == 0x000008, "Wrong alignment on UOrionDecalLibrary");
static_assert(sizeof(UOrionDecalLibrary) == 0x000040, "Wrong size on UOrionDecalLibrary");
static_assert(offsetof(UOrionDecalLibrary, Decals) == 0x000030, "Member 'UOrionDecalLibrary::Decals' has a wrong offset!");

// Class OrionGame.OrionDecorBanner
// 0x00A8 (0x03C0 - 0x0318)
class AOrionDecorBanner final : public AActor
{
public:
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStartVisible;                                     // 0x0320(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWantActivationFX;                                 // 0x0321(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActivateOnCreation;                               // 0x0322(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldDeactivate;                                 // 0x0323(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_324[0x4];                                      // 0x0324(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AOrionBanner>            CreatedBanner;                                     // 0x0330(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AOrionPlayerState_Game>  OwnerPlayerState;                                  // 0x0338(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWasActivated;                                     // 0x0340(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBannerCreated;                                    // 0x0341(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrionTeam                                    TeamIndex;                                         // 0x0342(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_343[0x1];                                      // 0x0343(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayerSlot;                                        // 0x0344(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnabled;                                          // 0x0348(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_349[0x7];                                      // 0x0349(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AOrionBanner>               BannerClass;                                       // 0x0350(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBannerSpec                            CurrentBannerSpec;                                 // 0x0358(0x0068)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	void ActivateNow();
	bool CreateDecorBanner(class AOrionPlayerState_Game* InPlayerState, struct FBannerSpec* BannerSpec, bool bShowPortrait, bool bRecreateIfExists, bool bRemoveAtOnce);
	void DisableDecorBanner();
	void EnableDecorBanner();
	void RemoveDecorBanner(bool bRemoveAtOnce);
	void SetBannerVisibility(const bool bIsVisible);

	int32 GetSlot() const;
	EOrionTeam GetTeamNum() const;
	bool IsEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionDecorBanner">();
	}
	static class AOrionDecorBanner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionDecorBanner>();
	}
};
static_assert(alignof(AOrionDecorBanner) == 0x000008, "Wrong alignment on AOrionDecorBanner");
static_assert(sizeof(AOrionDecorBanner) == 0x0003C0, "Wrong size on AOrionDecorBanner");
static_assert(offsetof(AOrionDecorBanner, CapsuleComponent) == 0x000318, "Member 'AOrionDecorBanner::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(AOrionDecorBanner, bStartVisible) == 0x000320, "Member 'AOrionDecorBanner::bStartVisible' has a wrong offset!");
static_assert(offsetof(AOrionDecorBanner, bWantActivationFX) == 0x000321, "Member 'AOrionDecorBanner::bWantActivationFX' has a wrong offset!");
static_assert(offsetof(AOrionDecorBanner, bActivateOnCreation) == 0x000322, "Member 'AOrionDecorBanner::bActivateOnCreation' has a wrong offset!");
static_assert(offsetof(AOrionDecorBanner, bShouldDeactivate) == 0x000323, "Member 'AOrionDecorBanner::bShouldDeactivate' has a wrong offset!");
static_assert(offsetof(AOrionDecorBanner, StaticMeshComponent) == 0x000328, "Member 'AOrionDecorBanner::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AOrionDecorBanner, CreatedBanner) == 0x000330, "Member 'AOrionDecorBanner::CreatedBanner' has a wrong offset!");
static_assert(offsetof(AOrionDecorBanner, OwnerPlayerState) == 0x000338, "Member 'AOrionDecorBanner::OwnerPlayerState' has a wrong offset!");
static_assert(offsetof(AOrionDecorBanner, bWasActivated) == 0x000340, "Member 'AOrionDecorBanner::bWasActivated' has a wrong offset!");
static_assert(offsetof(AOrionDecorBanner, bBannerCreated) == 0x000341, "Member 'AOrionDecorBanner::bBannerCreated' has a wrong offset!");
static_assert(offsetof(AOrionDecorBanner, TeamIndex) == 0x000342, "Member 'AOrionDecorBanner::TeamIndex' has a wrong offset!");
static_assert(offsetof(AOrionDecorBanner, PlayerSlot) == 0x000344, "Member 'AOrionDecorBanner::PlayerSlot' has a wrong offset!");
static_assert(offsetof(AOrionDecorBanner, bEnabled) == 0x000348, "Member 'AOrionDecorBanner::bEnabled' has a wrong offset!");
static_assert(offsetof(AOrionDecorBanner, BannerClass) == 0x000350, "Member 'AOrionDecorBanner::BannerClass' has a wrong offset!");
static_assert(offsetof(AOrionDecorBanner, CurrentBannerSpec) == 0x000358, "Member 'AOrionDecorBanner::CurrentBannerSpec' has a wrong offset!");

// Class OrionGame.OrionGameTipsData
// 0x0030 (0x0060 - 0x0030)
class UOrionGameTipsData final : public UDataAsset
{
public:
	TArray<class FText>                           NewPlayerTips;                                     // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FText>                           LearningTips;                                      // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FText>                           ToxicityTips;                                      // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameTipsData">();
	}
	static class UOrionGameTipsData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionGameTipsData>();
	}
};
static_assert(alignof(UOrionGameTipsData) == 0x000008, "Wrong alignment on UOrionGameTipsData");
static_assert(sizeof(UOrionGameTipsData) == 0x000060, "Wrong size on UOrionGameTipsData");
static_assert(offsetof(UOrionGameTipsData, NewPlayerTips) == 0x000030, "Member 'UOrionGameTipsData::NewPlayerTips' has a wrong offset!");
static_assert(offsetof(UOrionGameTipsData, LearningTips) == 0x000040, "Member 'UOrionGameTipsData::LearningTips' has a wrong offset!");
static_assert(offsetof(UOrionGameTipsData, ToxicityTips) == 0x000050, "Member 'UOrionGameTipsData::ToxicityTips' has a wrong offset!");

// Class OrionGame.OrionDialogueEvent
// 0x0008 (0x0180 - 0x0178)
class UOrionDialogueEvent final : public UAmbientDialogueEvent
{
public:
	EWitnessRelationship                          WitnessedBy;                                       // 0x0178(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_179[0x7];                                      // 0x0179(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionDialogueEvent">();
	}
	static class UOrionDialogueEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionDialogueEvent>();
	}
};
static_assert(alignof(UOrionDialogueEvent) == 0x000008, "Wrong alignment on UOrionDialogueEvent");
static_assert(sizeof(UOrionDialogueEvent) == 0x000180, "Wrong size on UOrionDialogueEvent");
static_assert(offsetof(UOrionDialogueEvent, WitnessedBy) == 0x000178, "Member 'UOrionDialogueEvent::WitnessedBy' has a wrong offset!");

// Class OrionGame.OrionDialogWidget
// 0x00B8 (0x0500 - 0x0448)
class UOrionDialogWidget : public UOrionActivatableWidget
{
public:
	uint8                                         Pad_448[0x8];                                      // 0x0448(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionDialogDescription                CurrentDescription;                                // 0x0450(0x00B0)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)

public:
	void KillDialog();
	void OnKill();
	void OnShow();
	void ProcessResult(EOrionDialogResult DialogResult);
	void ShowDialog(const struct FOrionDialogDescription& Description);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionDialogWidget">();
	}
	static class UOrionDialogWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionDialogWidget>();
	}
};
static_assert(alignof(UOrionDialogWidget) == 0x000010, "Wrong alignment on UOrionDialogWidget");
static_assert(sizeof(UOrionDialogWidget) == 0x000500, "Wrong size on UOrionDialogWidget");
static_assert(offsetof(UOrionDialogWidget, CurrentDescription) == 0x000450, "Member 'UOrionDialogWidget::CurrentDescription' has a wrong offset!");

// Class OrionGame.OrionHeroShrapnelAnimInstance
// 0x0010 (0x11D0 - 0x11C0)
class UOrionHeroShrapnelAnimInstance final : public UOrionHeroAnimInstance
{
public:
	bool                                          bShouldPlayWeaponAimingPose;                       // 0x11B8(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPlayingWeaponAimingPose;                        // 0x11B9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayCombatPose;                                   // 0x11BA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableUpperBodyMask;                              // 0x11BB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayUpperBodyPrimaryFire;                         // 0x11BC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11BD[0x3];                                     // 0x11BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AttachGrenadeToHandAlpha;                          // 0x11C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BazookaPhysicsAlpha;                               // 0x11C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DisableBazookaPhysicsCurveName;                    // 0x11C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHeroShrapnelAnimInstance">();
	}
	static class UOrionHeroShrapnelAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHeroShrapnelAnimInstance>();
	}
};
static_assert(alignof(UOrionHeroShrapnelAnimInstance) == 0x000010, "Wrong alignment on UOrionHeroShrapnelAnimInstance");
static_assert(sizeof(UOrionHeroShrapnelAnimInstance) == 0x0011D0, "Wrong size on UOrionHeroShrapnelAnimInstance");
static_assert(offsetof(UOrionHeroShrapnelAnimInstance, bShouldPlayWeaponAimingPose) == 0x0011B8, "Member 'UOrionHeroShrapnelAnimInstance::bShouldPlayWeaponAimingPose' has a wrong offset!");
static_assert(offsetof(UOrionHeroShrapnelAnimInstance, bIsPlayingWeaponAimingPose) == 0x0011B9, "Member 'UOrionHeroShrapnelAnimInstance::bIsPlayingWeaponAimingPose' has a wrong offset!");
static_assert(offsetof(UOrionHeroShrapnelAnimInstance, bPlayCombatPose) == 0x0011BA, "Member 'UOrionHeroShrapnelAnimInstance::bPlayCombatPose' has a wrong offset!");
static_assert(offsetof(UOrionHeroShrapnelAnimInstance, bEnableUpperBodyMask) == 0x0011BB, "Member 'UOrionHeroShrapnelAnimInstance::bEnableUpperBodyMask' has a wrong offset!");
static_assert(offsetof(UOrionHeroShrapnelAnimInstance, bPlayUpperBodyPrimaryFire) == 0x0011BC, "Member 'UOrionHeroShrapnelAnimInstance::bPlayUpperBodyPrimaryFire' has a wrong offset!");
static_assert(offsetof(UOrionHeroShrapnelAnimInstance, AttachGrenadeToHandAlpha) == 0x0011C0, "Member 'UOrionHeroShrapnelAnimInstance::AttachGrenadeToHandAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroShrapnelAnimInstance, BazookaPhysicsAlpha) == 0x0011C4, "Member 'UOrionHeroShrapnelAnimInstance::BazookaPhysicsAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroShrapnelAnimInstance, DisableBazookaPhysicsCurveName) == 0x0011C8, "Member 'UOrionHeroShrapnelAnimInstance::DisableBazookaPhysicsCurveName' has a wrong offset!");

// Class OrionGame.OrionDynamicWall_Segment
// 0x0080 (0x0468 - 0x03E8)
class AOrionDynamicWall_Segment final : public AOrionBaseActor
{
public:
	TSubclassOf<class AOrionDynamicWall>          WallClass;                                         // 0x03E8(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FOrionDynamicWall_SegmentProperties    Properties;                                        // 0x03F0(0x002C)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_41C[0x1C];                                     // 0x041C(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   CollisionBaseMeshComponent;                        // 0x0438(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   CollisionCapMeshComponent;                         // 0x0440(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          CollisionOverlapComponent;                         // 0x0448(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        VisualRootComponent;                               // 0x0450(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   VisualBaseMeshComponent;                           // 0x0458(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   VisualCapMeshComponent;                            // 0x0460(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void EndOverlapCallback(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnSegmentConstruction(float ConstructionTime, float BaseMinHeight, float BaseMaxHeight);
	void OnSegmentDeconstruction(float DeconstructionTime);
	void OnSegmentOverlapCharacter(const class AOrionChar* Character, const struct FVector& PushDirection, float PushDistance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionDynamicWall_Segment">();
	}
	static class AOrionDynamicWall_Segment* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionDynamicWall_Segment>();
	}
};
static_assert(alignof(AOrionDynamicWall_Segment) == 0x000008, "Wrong alignment on AOrionDynamicWall_Segment");
static_assert(sizeof(AOrionDynamicWall_Segment) == 0x000468, "Wrong size on AOrionDynamicWall_Segment");
static_assert(offsetof(AOrionDynamicWall_Segment, WallClass) == 0x0003E8, "Member 'AOrionDynamicWall_Segment::WallClass' has a wrong offset!");
static_assert(offsetof(AOrionDynamicWall_Segment, Properties) == 0x0003F0, "Member 'AOrionDynamicWall_Segment::Properties' has a wrong offset!");
static_assert(offsetof(AOrionDynamicWall_Segment, CollisionBaseMeshComponent) == 0x000438, "Member 'AOrionDynamicWall_Segment::CollisionBaseMeshComponent' has a wrong offset!");
static_assert(offsetof(AOrionDynamicWall_Segment, CollisionCapMeshComponent) == 0x000440, "Member 'AOrionDynamicWall_Segment::CollisionCapMeshComponent' has a wrong offset!");
static_assert(offsetof(AOrionDynamicWall_Segment, CollisionOverlapComponent) == 0x000448, "Member 'AOrionDynamicWall_Segment::CollisionOverlapComponent' has a wrong offset!");
static_assert(offsetof(AOrionDynamicWall_Segment, VisualRootComponent) == 0x000450, "Member 'AOrionDynamicWall_Segment::VisualRootComponent' has a wrong offset!");
static_assert(offsetof(AOrionDynamicWall_Segment, VisualBaseMeshComponent) == 0x000458, "Member 'AOrionDynamicWall_Segment::VisualBaseMeshComponent' has a wrong offset!");
static_assert(offsetof(AOrionDynamicWall_Segment, VisualCapMeshComponent) == 0x000460, "Member 'AOrionDynamicWall_Segment::VisualCapMeshComponent' has a wrong offset!");

// Class OrionGame.OrionEarnedCXP
// 0x0000 (0x0040 - 0x0040)
class UOrionEarnedCXP final : public UGameplayEffectExecutionCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionEarnedCXP">();
	}
	static class UOrionEarnedCXP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionEarnedCXP>();
	}
};
static_assert(alignof(UOrionEarnedCXP) == 0x000008, "Wrong alignment on UOrionEarnedCXP");
static_assert(sizeof(UOrionEarnedCXP) == 0x000040, "Wrong size on UOrionEarnedCXP");

// Class OrionGame.OrionGlobals
// 0x16E8 (0x1710 - 0x0028)
class UOrionGlobals final : public UObject
{
public:
	uint8                                         Pad_28[0x88];                                      // 0x0028(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMapPreloadList*>                MapPreloadLists;                                   // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UMapPreloadList*>                TemporaryMapPreloadLists;                          // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D0[0x110];                                     // 0x00D0(0x0110)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOrionLoadedDataCache>          LoadedDataCache;                                   // 0x01E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F0[0xB0];                                     // 0x01F0(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOrionWorldGlobals>             WorldGlobalList;                                   // 0x02A0(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FOrionWorldGlobals                     GWorldGlobals;                                     // 0x02B0(0x09F0)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UOrionHeroData*                         ForceHeroData;                                     // 0x0CA0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             MilestoneRewardsTable;                             // 0x0CA8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             ReachRewardsTable;                                 // 0x0CB0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             DailyLoginRewardsTable;                            // 0x0CB8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             XPAccountLevelsTable;                              // 0x0CC0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             XPHeroLevelsTable;                                 // 0x0CC8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             HeroRewardLevelsTable;                             // 0x0CD0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionMasteryInfo*                      MasteryInfo;                                       // 0x0CD8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionCardLevelingInfo*                 CardLevelingInfo;                                  // 0x0CE0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             TeamOwnershipXPBonusTable;                         // 0x0CE8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             RewardToSourceTable;                               // 0x0CF0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             RewardSourceLocTable;                              // 0x0CF8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             TemplateOverridesTable;                            // 0x0D00(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             CardPropertiesTable;                               // 0x0D08(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             GemPropertiesTable;                                // 0x0D10(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D18[0xD0];                                     // 0x0D18(0x00D0)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionObjectLibraryEntry               ObjectLibraries[0x1B];                             // 0x0DE8(0x0020)(NativeAccessSpecifierPublic)
	class UOrionGameData*                         GameData;                                          // 0x1148(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionGameUIData*                       GameUIData;                                        // 0x1150(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           TeamColorCollection;                               // 0x1158(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  InVisionZoneTags;                                  // 0x1160(0x0020)(NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  CanSeeVisionZoneTags;                              // 0x1180(0x0020)(NativeAccessSpecifierPublic)
	TArray<class UOrionHeroDataCollection*>       DevModeHeroCollections;                            // 0x11A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UOrionWidgetData*                       WidgetData;                                        // 0x11B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UOrionHeroData*>                 LoadedHeroData;                                    // 0x11B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ShouldAggregateHeroData;                           // 0x11C8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C9[0x7];                                     // 0x11C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     LocalPlayerMiniMapMaterial;                        // 0x11D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionCurveTableSetManager*             CurveTableManager;                                 // 0x11D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ForceHeroDataRef;                                  // 0x11E0(0x0018)(Edit, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOrionDeveloperAttributeOverride> AttributeOverrides;                                // 0x11F8(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FOrionAbilityBindInfo>          AbilityOverrides;                                  // 0x1208(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	bool                                          bHeroReworksEnabled;                               // 0x1218(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1219[0x7];                                     // 0x1219(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UGameplayEffect>>    GameplayEffectOverrides;                           // 0x1220(0x0010)(Edit, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FOrionDeveloperMenuCommand>     DeveloperCommands;                                 // 0x1230(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                DevModeHeroCollectionRefs;                         // 0x1240(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	bool                                          bLevelUpAbilitiesToMax;                            // 0x1250(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DevMode;                                           // 0x1251(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDemoMode;                                         // 0x1252(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowFPS;                                          // 0x1253(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowWatermark;                                    // 0x1254(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowCardMenuAnywhere;                            // 0x1255(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreCardLock;                                   // 0x1256(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreDeckLock;                                   // 0x1257(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllSkinsUnlocked;                                 // 0x1258(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1259[0x3];                                     // 0x1259(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OrionQuestPlayListIdOverride;                      // 0x125C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UOrionMcpQuestItemDefinition*>   GrantedQuestOverride;                              // 0x1260(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  RotationalContentOverrides;                        // 0x1270(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        GameDataRef;                                       // 0x1290(0x0018)(Edit, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        GameUIDataRef;                                     // 0x12A8(0x0018)(Edit, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LoadPIEAssetsAtStartup;                            // 0x12C0(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LoadAllHeroesAtStartup;                            // 0x12C1(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LoadLastPIEHeroDataAtStartup;                      // 0x12C2(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12C3[0x5];                                     // 0x12C3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UOrionHeroData*>                 HeroDataLoadingQueue;                              // 0x12C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        LastPIEHeroData;                                   // 0x12D8(0x0018)(Edit, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                EditorOptionalAsyncLoadAssetsAtStartup;            // 0x12F0(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                EditorOptionalSyncLoadAssetsAtStartup;             // 0x1300(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	class FString                                 DailyLoginRewardsName;                             // 0x1310(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MilestoneRewardsName;                              // 0x1320(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReachRewardsName;                                  // 0x1330(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 XPAccountLevelsName;                               // 0x1340(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 XPHeroLevelsName;                                  // 0x1350(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HeroRewardLevelsName;                              // 0x1360(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TeamOwnershipXPBonusName;                          // 0x1370(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RewardToSourceTableName;                           // 0x1380(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RewardSourceLocTableName;                          // 0x1390(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TemplateOverridesTableName;                        // 0x13A0(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MasteryInfoName;                                   // 0x13B0(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CardLevelingInfoName;                              // 0x13C0(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CardPropertiesTableName;                           // 0x13D0(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GemPropertiesTableName;                            // 0x13E0(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FastCook;                                          // 0x13F0(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCookingRegionDLC;                               // 0x13F1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13F2[0x6];                                     // 0x13F2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RegionDLCName;                                     // 0x13F8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FastLoad;                                          // 0x1408(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1409[0x7];                                     // 0x1409(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSoftObjectPath>                FastCookHeroList;                                  // 0x1410(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	bool                                          bDebugGestureInfo;                                 // 0x1420(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConstantGestureDebugging;                         // 0x1421(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1422[0x2];                                     // 0x1422(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SmallestRawDeltaSize;                              // 0x1424(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmallestFilteredDeltaSize;                         // 0x1428(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GestureAnalogCursorSpeed;                          // 0x142C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MouseSensitivity;                                  // 0x1430(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugHitTestGrid;                                 // 0x1434(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugXP;                                          // 0x1435(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableAbilityLeveling;                           // 0x1436(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1437[0x1];                                     // 0x1437(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GravesiteTriggerVolumeRadius;                      // 0x1438(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGravesiteData                         GraveSiteDataForEnemies;                           // 0x143C(0x0014)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	struct FGravesiteData                         GraveSiteDataForFriends;                           // 0x1450(0x0014)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         GravesiteMinMultiKillForSpawn;                     // 0x1464(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GravesiteMinKillStreakForSpawn;                    // 0x1468(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GravesiteMinOpposingTeamHeroesDeadAtOnceForSpawn;  // 0x146C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBannerSpawnsOnKilling_Rig;                        // 0x1470(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBannerSpawnsOnKilling_Tower;                      // 0x1471(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBannerSpawnsOnKilling_Inhibitor;                  // 0x1472(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBannerSpawnsOnKilling_Core;                       // 0x1473(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBannerSpawnsOnKilling_Hero;                       // 0x1474(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBannerSpawnsOnKilling_Minion;                     // 0x1475(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1476[0x2];                                     // 0x1476(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBannerGravesiteCameraData             BannerGravesiteCameraData;                         // 0x1478(0x0078)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TeamCommsTraceDistance;                            // 0x14F0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScorePerMessage;                                   // 0x14F4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxScore;                                          // 0x14F8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecayPerSecond;                                    // 0x14FC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableScoreboardUpdating;                        // 0x1500(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUsingGamepad;                                   // 0x1501(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawDamageNumbers;                                // 0x1502(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawLocalPlayerHealthIndicator;                   // 0x1503(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthPipValue;                                    // 0x1504(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionDeveloperUIToggles               UIToggles;                                         // 0x1508(0x0007)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_150F[0x1];                                     // 0x150F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        TeamColorDataRef;                                  // 0x1510(0x0018)(Edit, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        WidgetDataNameRef;                                 // 0x1528(0x0018)(Edit, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        LocalPlayerMiniMapMaterialRef;                     // 0x1540(0x0018)(Edit, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalPlayerMiniMapIconScalar;                      // 0x1558(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemotePlayerMiniMapIconScalar;                     // 0x155C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionLatencyPreset                           SimulatedLatency;                                  // 0x1560(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1561[0x3];                                     // 0x1561(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPacketSimulationSettings              LatencyPresets[0x6];                               // 0x1564(0x0014)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_15DC[0x4];                                     // 0x15DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        PlaylistLedger;                                    // 0x15E0(0x0018)(Edit, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ForcedArcadeAssetRef;                              // 0x15F8(0x0018)(Edit, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ForcedStageIndex;                                  // 0x1610(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1614[0x4];                                     // 0x1614(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionArcadeLadderSetupData*            ForcedArcadeAsset;                                 // 0x1618(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1620[0xE0];                                    // 0x1620(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ActiveRotationalContentStreamingLevelsForMap;      // 0x1700(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void ReclaimWorldNiagaraSystem(class UNiagaraComponent* PSC);
	void ReclaimWorldParticleSystem(class UParticleSystemComponent* PSC);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGlobals">();
	}
	static class UOrionGlobals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionGlobals>();
	}
};
static_assert(alignof(UOrionGlobals) == 0x000010, "Wrong alignment on UOrionGlobals");
static_assert(sizeof(UOrionGlobals) == 0x001710, "Wrong size on UOrionGlobals");
static_assert(offsetof(UOrionGlobals, MapPreloadLists) == 0x0000B0, "Member 'UOrionGlobals::MapPreloadLists' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, TemporaryMapPreloadLists) == 0x0000C0, "Member 'UOrionGlobals::TemporaryMapPreloadLists' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, LoadedDataCache) == 0x0001E0, "Member 'UOrionGlobals::LoadedDataCache' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, WorldGlobalList) == 0x0002A0, "Member 'UOrionGlobals::WorldGlobalList' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, GWorldGlobals) == 0x0002B0, "Member 'UOrionGlobals::GWorldGlobals' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, ForceHeroData) == 0x000CA0, "Member 'UOrionGlobals::ForceHeroData' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, MilestoneRewardsTable) == 0x000CA8, "Member 'UOrionGlobals::MilestoneRewardsTable' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, ReachRewardsTable) == 0x000CB0, "Member 'UOrionGlobals::ReachRewardsTable' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, DailyLoginRewardsTable) == 0x000CB8, "Member 'UOrionGlobals::DailyLoginRewardsTable' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, XPAccountLevelsTable) == 0x000CC0, "Member 'UOrionGlobals::XPAccountLevelsTable' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, XPHeroLevelsTable) == 0x000CC8, "Member 'UOrionGlobals::XPHeroLevelsTable' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, HeroRewardLevelsTable) == 0x000CD0, "Member 'UOrionGlobals::HeroRewardLevelsTable' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, MasteryInfo) == 0x000CD8, "Member 'UOrionGlobals::MasteryInfo' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, CardLevelingInfo) == 0x000CE0, "Member 'UOrionGlobals::CardLevelingInfo' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, TeamOwnershipXPBonusTable) == 0x000CE8, "Member 'UOrionGlobals::TeamOwnershipXPBonusTable' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, RewardToSourceTable) == 0x000CF0, "Member 'UOrionGlobals::RewardToSourceTable' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, RewardSourceLocTable) == 0x000CF8, "Member 'UOrionGlobals::RewardSourceLocTable' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, TemplateOverridesTable) == 0x000D00, "Member 'UOrionGlobals::TemplateOverridesTable' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, CardPropertiesTable) == 0x000D08, "Member 'UOrionGlobals::CardPropertiesTable' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, GemPropertiesTable) == 0x000D10, "Member 'UOrionGlobals::GemPropertiesTable' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, ObjectLibraries) == 0x000DE8, "Member 'UOrionGlobals::ObjectLibraries' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, GameData) == 0x001148, "Member 'UOrionGlobals::GameData' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, GameUIData) == 0x001150, "Member 'UOrionGlobals::GameUIData' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, TeamColorCollection) == 0x001158, "Member 'UOrionGlobals::TeamColorCollection' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, InVisionZoneTags) == 0x001160, "Member 'UOrionGlobals::InVisionZoneTags' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, CanSeeVisionZoneTags) == 0x001180, "Member 'UOrionGlobals::CanSeeVisionZoneTags' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, DevModeHeroCollections) == 0x0011A0, "Member 'UOrionGlobals::DevModeHeroCollections' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, WidgetData) == 0x0011B0, "Member 'UOrionGlobals::WidgetData' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, LoadedHeroData) == 0x0011B8, "Member 'UOrionGlobals::LoadedHeroData' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, ShouldAggregateHeroData) == 0x0011C8, "Member 'UOrionGlobals::ShouldAggregateHeroData' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, LocalPlayerMiniMapMaterial) == 0x0011D0, "Member 'UOrionGlobals::LocalPlayerMiniMapMaterial' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, CurveTableManager) == 0x0011D8, "Member 'UOrionGlobals::CurveTableManager' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, ForceHeroDataRef) == 0x0011E0, "Member 'UOrionGlobals::ForceHeroDataRef' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, AttributeOverrides) == 0x0011F8, "Member 'UOrionGlobals::AttributeOverrides' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, AbilityOverrides) == 0x001208, "Member 'UOrionGlobals::AbilityOverrides' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, bHeroReworksEnabled) == 0x001218, "Member 'UOrionGlobals::bHeroReworksEnabled' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, GameplayEffectOverrides) == 0x001220, "Member 'UOrionGlobals::GameplayEffectOverrides' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, DeveloperCommands) == 0x001230, "Member 'UOrionGlobals::DeveloperCommands' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, DevModeHeroCollectionRefs) == 0x001240, "Member 'UOrionGlobals::DevModeHeroCollectionRefs' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, bLevelUpAbilitiesToMax) == 0x001250, "Member 'UOrionGlobals::bLevelUpAbilitiesToMax' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, DevMode) == 0x001251, "Member 'UOrionGlobals::DevMode' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, bDemoMode) == 0x001252, "Member 'UOrionGlobals::bDemoMode' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, bShowFPS) == 0x001253, "Member 'UOrionGlobals::bShowFPS' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, bShowWatermark) == 0x001254, "Member 'UOrionGlobals::bShowWatermark' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, bAllowCardMenuAnywhere) == 0x001255, "Member 'UOrionGlobals::bAllowCardMenuAnywhere' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, bIgnoreCardLock) == 0x001256, "Member 'UOrionGlobals::bIgnoreCardLock' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, bIgnoreDeckLock) == 0x001257, "Member 'UOrionGlobals::bIgnoreDeckLock' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, bAllSkinsUnlocked) == 0x001258, "Member 'UOrionGlobals::bAllSkinsUnlocked' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, OrionQuestPlayListIdOverride) == 0x00125C, "Member 'UOrionGlobals::OrionQuestPlayListIdOverride' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, GrantedQuestOverride) == 0x001260, "Member 'UOrionGlobals::GrantedQuestOverride' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, RotationalContentOverrides) == 0x001270, "Member 'UOrionGlobals::RotationalContentOverrides' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, GameDataRef) == 0x001290, "Member 'UOrionGlobals::GameDataRef' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, GameUIDataRef) == 0x0012A8, "Member 'UOrionGlobals::GameUIDataRef' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, LoadPIEAssetsAtStartup) == 0x0012C0, "Member 'UOrionGlobals::LoadPIEAssetsAtStartup' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, LoadAllHeroesAtStartup) == 0x0012C1, "Member 'UOrionGlobals::LoadAllHeroesAtStartup' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, LoadLastPIEHeroDataAtStartup) == 0x0012C2, "Member 'UOrionGlobals::LoadLastPIEHeroDataAtStartup' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, HeroDataLoadingQueue) == 0x0012C8, "Member 'UOrionGlobals::HeroDataLoadingQueue' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, LastPIEHeroData) == 0x0012D8, "Member 'UOrionGlobals::LastPIEHeroData' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, EditorOptionalAsyncLoadAssetsAtStartup) == 0x0012F0, "Member 'UOrionGlobals::EditorOptionalAsyncLoadAssetsAtStartup' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, EditorOptionalSyncLoadAssetsAtStartup) == 0x001300, "Member 'UOrionGlobals::EditorOptionalSyncLoadAssetsAtStartup' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, DailyLoginRewardsName) == 0x001310, "Member 'UOrionGlobals::DailyLoginRewardsName' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, MilestoneRewardsName) == 0x001320, "Member 'UOrionGlobals::MilestoneRewardsName' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, ReachRewardsName) == 0x001330, "Member 'UOrionGlobals::ReachRewardsName' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, XPAccountLevelsName) == 0x001340, "Member 'UOrionGlobals::XPAccountLevelsName' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, XPHeroLevelsName) == 0x001350, "Member 'UOrionGlobals::XPHeroLevelsName' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, HeroRewardLevelsName) == 0x001360, "Member 'UOrionGlobals::HeroRewardLevelsName' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, TeamOwnershipXPBonusName) == 0x001370, "Member 'UOrionGlobals::TeamOwnershipXPBonusName' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, RewardToSourceTableName) == 0x001380, "Member 'UOrionGlobals::RewardToSourceTableName' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, RewardSourceLocTableName) == 0x001390, "Member 'UOrionGlobals::RewardSourceLocTableName' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, TemplateOverridesTableName) == 0x0013A0, "Member 'UOrionGlobals::TemplateOverridesTableName' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, MasteryInfoName) == 0x0013B0, "Member 'UOrionGlobals::MasteryInfoName' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, CardLevelingInfoName) == 0x0013C0, "Member 'UOrionGlobals::CardLevelingInfoName' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, CardPropertiesTableName) == 0x0013D0, "Member 'UOrionGlobals::CardPropertiesTableName' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, GemPropertiesTableName) == 0x0013E0, "Member 'UOrionGlobals::GemPropertiesTableName' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, FastCook) == 0x0013F0, "Member 'UOrionGlobals::FastCook' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, bIsCookingRegionDLC) == 0x0013F1, "Member 'UOrionGlobals::bIsCookingRegionDLC' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, RegionDLCName) == 0x0013F8, "Member 'UOrionGlobals::RegionDLCName' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, FastLoad) == 0x001408, "Member 'UOrionGlobals::FastLoad' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, FastCookHeroList) == 0x001410, "Member 'UOrionGlobals::FastCookHeroList' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, bDebugGestureInfo) == 0x001420, "Member 'UOrionGlobals::bDebugGestureInfo' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, bConstantGestureDebugging) == 0x001421, "Member 'UOrionGlobals::bConstantGestureDebugging' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, SmallestRawDeltaSize) == 0x001424, "Member 'UOrionGlobals::SmallestRawDeltaSize' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, SmallestFilteredDeltaSize) == 0x001428, "Member 'UOrionGlobals::SmallestFilteredDeltaSize' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, GestureAnalogCursorSpeed) == 0x00142C, "Member 'UOrionGlobals::GestureAnalogCursorSpeed' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, MouseSensitivity) == 0x001430, "Member 'UOrionGlobals::MouseSensitivity' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, bDebugHitTestGrid) == 0x001434, "Member 'UOrionGlobals::bDebugHitTestGrid' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, bDebugXP) == 0x001435, "Member 'UOrionGlobals::bDebugXP' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, bDisableAbilityLeveling) == 0x001436, "Member 'UOrionGlobals::bDisableAbilityLeveling' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, GravesiteTriggerVolumeRadius) == 0x001438, "Member 'UOrionGlobals::GravesiteTriggerVolumeRadius' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, GraveSiteDataForEnemies) == 0x00143C, "Member 'UOrionGlobals::GraveSiteDataForEnemies' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, GraveSiteDataForFriends) == 0x001450, "Member 'UOrionGlobals::GraveSiteDataForFriends' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, GravesiteMinMultiKillForSpawn) == 0x001464, "Member 'UOrionGlobals::GravesiteMinMultiKillForSpawn' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, GravesiteMinKillStreakForSpawn) == 0x001468, "Member 'UOrionGlobals::GravesiteMinKillStreakForSpawn' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, GravesiteMinOpposingTeamHeroesDeadAtOnceForSpawn) == 0x00146C, "Member 'UOrionGlobals::GravesiteMinOpposingTeamHeroesDeadAtOnceForSpawn' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, bBannerSpawnsOnKilling_Rig) == 0x001470, "Member 'UOrionGlobals::bBannerSpawnsOnKilling_Rig' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, bBannerSpawnsOnKilling_Tower) == 0x001471, "Member 'UOrionGlobals::bBannerSpawnsOnKilling_Tower' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, bBannerSpawnsOnKilling_Inhibitor) == 0x001472, "Member 'UOrionGlobals::bBannerSpawnsOnKilling_Inhibitor' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, bBannerSpawnsOnKilling_Core) == 0x001473, "Member 'UOrionGlobals::bBannerSpawnsOnKilling_Core' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, bBannerSpawnsOnKilling_Hero) == 0x001474, "Member 'UOrionGlobals::bBannerSpawnsOnKilling_Hero' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, bBannerSpawnsOnKilling_Minion) == 0x001475, "Member 'UOrionGlobals::bBannerSpawnsOnKilling_Minion' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, BannerGravesiteCameraData) == 0x001478, "Member 'UOrionGlobals::BannerGravesiteCameraData' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, TeamCommsTraceDistance) == 0x0014F0, "Member 'UOrionGlobals::TeamCommsTraceDistance' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, ScorePerMessage) == 0x0014F4, "Member 'UOrionGlobals::ScorePerMessage' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, MaxScore) == 0x0014F8, "Member 'UOrionGlobals::MaxScore' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, DecayPerSecond) == 0x0014FC, "Member 'UOrionGlobals::DecayPerSecond' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, bDisableScoreboardUpdating) == 0x001500, "Member 'UOrionGlobals::bDisableScoreboardUpdating' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, bIsUsingGamepad) == 0x001501, "Member 'UOrionGlobals::bIsUsingGamepad' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, bDrawDamageNumbers) == 0x001502, "Member 'UOrionGlobals::bDrawDamageNumbers' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, bDrawLocalPlayerHealthIndicator) == 0x001503, "Member 'UOrionGlobals::bDrawLocalPlayerHealthIndicator' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, HealthPipValue) == 0x001504, "Member 'UOrionGlobals::HealthPipValue' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, UIToggles) == 0x001508, "Member 'UOrionGlobals::UIToggles' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, TeamColorDataRef) == 0x001510, "Member 'UOrionGlobals::TeamColorDataRef' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, WidgetDataNameRef) == 0x001528, "Member 'UOrionGlobals::WidgetDataNameRef' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, LocalPlayerMiniMapMaterialRef) == 0x001540, "Member 'UOrionGlobals::LocalPlayerMiniMapMaterialRef' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, LocalPlayerMiniMapIconScalar) == 0x001558, "Member 'UOrionGlobals::LocalPlayerMiniMapIconScalar' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, RemotePlayerMiniMapIconScalar) == 0x00155C, "Member 'UOrionGlobals::RemotePlayerMiniMapIconScalar' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, SimulatedLatency) == 0x001560, "Member 'UOrionGlobals::SimulatedLatency' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, LatencyPresets) == 0x001564, "Member 'UOrionGlobals::LatencyPresets' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, PlaylistLedger) == 0x0015E0, "Member 'UOrionGlobals::PlaylistLedger' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, ForcedArcadeAssetRef) == 0x0015F8, "Member 'UOrionGlobals::ForcedArcadeAssetRef' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, ForcedStageIndex) == 0x001610, "Member 'UOrionGlobals::ForcedStageIndex' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, ForcedArcadeAsset) == 0x001618, "Member 'UOrionGlobals::ForcedArcadeAsset' has a wrong offset!");
static_assert(offsetof(UOrionGlobals, ActiveRotationalContentStreamingLevelsForMap) == 0x001700, "Member 'UOrionGlobals::ActiveRotationalContentStreamingLevelsForMap' has a wrong offset!");

// Class OrionGame.OrionEarnedXP
// 0x0000 (0x0040 - 0x0040)
class UOrionEarnedXP final : public UGameplayEffectExecutionCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionEarnedXP">();
	}
	static class UOrionEarnedXP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionEarnedXP>();
	}
};
static_assert(alignof(UOrionEarnedXP) == 0x000008, "Wrong alignment on UOrionEarnedXP");
static_assert(sizeof(UOrionEarnedXP) == 0x000040, "Wrong size on UOrionEarnedXP");

// Class OrionGame.OrionHUDWidgetBase
// 0x0038 (0x02F0 - 0x02B8)
class UOrionHUDWidgetBase : public UOrionUserWidgetBase
{
public:
	uint8                                         Pad_2B8[0x31];                                     // 0x02B8(0x0031)(Fixing Size After Last Property [ Dumper-7 ])
	EHUDTutorialVisibilityState                   StartingState;                                     // 0x02E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2EA[0x6];                                      // 0x02EA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHUDWidgetBase">();
	}
	static class UOrionHUDWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHUDWidgetBase>();
	}
};
static_assert(alignof(UOrionHUDWidgetBase) == 0x000008, "Wrong alignment on UOrionHUDWidgetBase");
static_assert(sizeof(UOrionHUDWidgetBase) == 0x0002F0, "Wrong size on UOrionHUDWidgetBase");
static_assert(offsetof(UOrionHUDWidgetBase, StartingState) == 0x0002E9, "Member 'UOrionHUDWidgetBase::StartingState' has a wrong offset!");

// Class OrionGame.OrionEditorOnlyDisplayData
// 0x0000 (0x0030 - 0x0030)
class UOrionEditorOnlyDisplayData final : public UDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionEditorOnlyDisplayData">();
	}
	static class UOrionEditorOnlyDisplayData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionEditorOnlyDisplayData>();
	}
};
static_assert(alignof(UOrionEditorOnlyDisplayData) == 0x000008, "Wrong alignment on UOrionEditorOnlyDisplayData");
static_assert(sizeof(UOrionEditorOnlyDisplayData) == 0x000030, "Wrong size on UOrionEditorOnlyDisplayData");

// Class OrionGame.OrionEnergyMissing
// 0x0000 (0x0040 - 0x0040)
class UOrionEnergyMissing final : public UGameplayModMagnitudeCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionEnergyMissing">();
	}
	static class UOrionEnergyMissing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionEnergyMissing>();
	}
};
static_assert(alignof(UOrionEnergyMissing) == 0x000008, "Wrong alignment on UOrionEnergyMissing");
static_assert(sizeof(UOrionEnergyMissing) == 0x000040, "Wrong size on UOrionEnergyMissing");

// Class OrionGame.OrionHealthMissing
// 0x0000 (0x0040 - 0x0040)
class UOrionHealthMissing final : public UGameplayModMagnitudeCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHealthMissing">();
	}
	static class UOrionHealthMissing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHealthMissing>();
	}
};
static_assert(alignof(UOrionHealthMissing) == 0x000008, "Wrong alignment on UOrionHealthMissing");
static_assert(sizeof(UOrionHealthMissing) == 0x000040, "Wrong size on UOrionHealthMissing");

// Class OrionGame.OrionHeroVenusAnimInstance
// 0x0030 (0x11F0 - 0x11C0)
class UOrionHeroVenusAnimInstance final : public UOrionHeroAnimInstance
{
public:
	class FName                                   DisableWingBlurAnimCurveName;                      // 0x11B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisableWingBlurAnimAlpha;                          // 0x11C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C4[0x4];                                     // 0x11C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DisableLegAnimDynamicsCurveName;                   // 0x11C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisableLegAnimDynamicsAlpha;                       // 0x11D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisableLegAnimDynamicsScale;                       // 0x11D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NotTargetingUltimateAlpha;                         // 0x11D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11DC[0x4];                                     // 0x11DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LeftHandIKCurveName;                               // 0x11E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftHandIKAlpha;                                   // 0x11E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11EC[0x4];                                     // 0x11EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHeroVenusAnimInstance">();
	}
	static class UOrionHeroVenusAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHeroVenusAnimInstance>();
	}
};
static_assert(alignof(UOrionHeroVenusAnimInstance) == 0x000010, "Wrong alignment on UOrionHeroVenusAnimInstance");
static_assert(sizeof(UOrionHeroVenusAnimInstance) == 0x0011F0, "Wrong size on UOrionHeroVenusAnimInstance");
static_assert(offsetof(UOrionHeroVenusAnimInstance, DisableWingBlurAnimCurveName) == 0x0011B8, "Member 'UOrionHeroVenusAnimInstance::DisableWingBlurAnimCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroVenusAnimInstance, DisableWingBlurAnimAlpha) == 0x0011C0, "Member 'UOrionHeroVenusAnimInstance::DisableWingBlurAnimAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroVenusAnimInstance, DisableLegAnimDynamicsCurveName) == 0x0011C8, "Member 'UOrionHeroVenusAnimInstance::DisableLegAnimDynamicsCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroVenusAnimInstance, DisableLegAnimDynamicsAlpha) == 0x0011D0, "Member 'UOrionHeroVenusAnimInstance::DisableLegAnimDynamicsAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroVenusAnimInstance, DisableLegAnimDynamicsScale) == 0x0011D4, "Member 'UOrionHeroVenusAnimInstance::DisableLegAnimDynamicsScale' has a wrong offset!");
static_assert(offsetof(UOrionHeroVenusAnimInstance, NotTargetingUltimateAlpha) == 0x0011D8, "Member 'UOrionHeroVenusAnimInstance::NotTargetingUltimateAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroVenusAnimInstance, LeftHandIKCurveName) == 0x0011E0, "Member 'UOrionHeroVenusAnimInstance::LeftHandIKCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroVenusAnimInstance, LeftHandIKAlpha) == 0x0011E8, "Member 'UOrionHeroVenusAnimInstance::LeftHandIKAlpha' has a wrong offset!");

// Class OrionGame.OrionEnergyPCT
// 0x0000 (0x0040 - 0x0040)
class UOrionEnergyPCT final : public UGameplayModMagnitudeCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionEnergyPCT">();
	}
	static class UOrionEnergyPCT* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionEnergyPCT>();
	}
};
static_assert(alignof(UOrionEnergyPCT) == 0x000008, "Wrong alignment on UOrionEnergyPCT");
static_assert(sizeof(UOrionEnergyPCT) == 0x000040, "Wrong size on UOrionEnergyPCT");

// Class OrionGame.OrionEngine
// 0x0028 (0x0E60 - 0x0E38)
class UOrionEngine final : public UGameEngine
{
public:
	float                                         SmoothedDeltaTime;                                 // 0x0E38(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitchTimeThreshold;                                // 0x0E3C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitchScaleThreshold;                               // 0x0E40(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitchSmoothingRate;                                // 0x0E44(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalSmoothingRate;                               // 0x0E48(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumSmoothedTime;                               // 0x0E4C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E50[0x10];                                     // 0x0E50(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionEngine">();
	}
	static class UOrionEngine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionEngine>();
	}
};
static_assert(alignof(UOrionEngine) == 0x000008, "Wrong alignment on UOrionEngine");
static_assert(sizeof(UOrionEngine) == 0x000E60, "Wrong size on UOrionEngine");
static_assert(offsetof(UOrionEngine, SmoothedDeltaTime) == 0x000E38, "Member 'UOrionEngine::SmoothedDeltaTime' has a wrong offset!");
static_assert(offsetof(UOrionEngine, HitchTimeThreshold) == 0x000E3C, "Member 'UOrionEngine::HitchTimeThreshold' has a wrong offset!");
static_assert(offsetof(UOrionEngine, HitchScaleThreshold) == 0x000E40, "Member 'UOrionEngine::HitchScaleThreshold' has a wrong offset!");
static_assert(offsetof(UOrionEngine, HitchSmoothingRate) == 0x000E44, "Member 'UOrionEngine::HitchSmoothingRate' has a wrong offset!");
static_assert(offsetof(UOrionEngine, NormalSmoothingRate) == 0x000E48, "Member 'UOrionEngine::NormalSmoothingRate' has a wrong offset!");
static_assert(offsetof(UOrionEngine, MaximumSmoothedTime) == 0x000E4C, "Member 'UOrionEngine::MaximumSmoothedTime' has a wrong offset!");

// Class OrionGame.OrionLocationTagManager
// 0x01F8 (0x0510 - 0x0318)
class AOrionLocationTagManager final : public AActor
{
public:
	TArray<class AOrionDamageableObjective_Base*> CachedObjectives;                                  // 0x0318(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_328[0x1D8];                                    // 0x0328(0x01D8)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            LocationUnderGE;                                   // 0x0500(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_508[0x8];                                      // 0x0508(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionLocationTagManager">();
	}
	static class AOrionLocationTagManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionLocationTagManager>();
	}
};
static_assert(alignof(AOrionLocationTagManager) == 0x000008, "Wrong alignment on AOrionLocationTagManager");
static_assert(sizeof(AOrionLocationTagManager) == 0x000510, "Wrong size on AOrionLocationTagManager");
static_assert(offsetof(AOrionLocationTagManager, CachedObjectives) == 0x000318, "Member 'AOrionLocationTagManager::CachedObjectives' has a wrong offset!");
static_assert(offsetof(AOrionLocationTagManager, LocationUnderGE) == 0x000500, "Member 'AOrionLocationTagManager::LocationUnderGE' has a wrong offset!");

// Class OrionGame.OrionMcpGlyphItemDefinition
// 0x0088 (0x02F0 - 0x0268)
class UOrionMcpGlyphItemDefinition final : public UOrionMcpItemDefinition
{
public:
	class FString                                 EventName;                                         // 0x0268(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 HeroName;                                          // 0x0278(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UStaticMesh>             Mesh;                                              // 0x0288(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMaterialInterface>      Material;                                          // 0x02B8(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x10];                                     // 0x02E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UMaterialInterface* GetMaterial() const;
	class UStaticMesh* GetMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpGlyphItemDefinition">();
	}
	static class UOrionMcpGlyphItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpGlyphItemDefinition>();
	}
};
static_assert(alignof(UOrionMcpGlyphItemDefinition) == 0x000008, "Wrong alignment on UOrionMcpGlyphItemDefinition");
static_assert(sizeof(UOrionMcpGlyphItemDefinition) == 0x0002F0, "Wrong size on UOrionMcpGlyphItemDefinition");
static_assert(offsetof(UOrionMcpGlyphItemDefinition, EventName) == 0x000268, "Member 'UOrionMcpGlyphItemDefinition::EventName' has a wrong offset!");
static_assert(offsetof(UOrionMcpGlyphItemDefinition, HeroName) == 0x000278, "Member 'UOrionMcpGlyphItemDefinition::HeroName' has a wrong offset!");
static_assert(offsetof(UOrionMcpGlyphItemDefinition, Mesh) == 0x000288, "Member 'UOrionMcpGlyphItemDefinition::Mesh' has a wrong offset!");
static_assert(offsetof(UOrionMcpGlyphItemDefinition, Material) == 0x0002B8, "Member 'UOrionMcpGlyphItemDefinition::Material' has a wrong offset!");

// Class OrionGame.OrionFriendItem
// 0x0030 (0x0058 - 0x0028)
class UOrionFriendItem final : public UObject
{
public:
	UMulticastDelegateProperty_                   OnPresenceUpdated;                                 // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetDisplayName(class FText* FriendName) const;
	void GetUniqueNetID(struct FUniqueNetIdRepl* FriendNetID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionFriendItem">();
	}
	static class UOrionFriendItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionFriendItem>();
	}
};
static_assert(alignof(UOrionFriendItem) == 0x000008, "Wrong alignment on UOrionFriendItem");
static_assert(sizeof(UOrionFriendItem) == 0x000058, "Wrong size on UOrionFriendItem");
static_assert(offsetof(UOrionFriendItem, OnPresenceUpdated) == 0x000028, "Member 'UOrionFriendItem::OnPresenceUpdated' has a wrong offset!");

// Class OrionGame.OrionGameData
// 0x06C0 (0x06F0 - 0x0030)
class UOrionGameData final : public UDataAsset
{
public:
	class UCurveTable*                            GlobalCurveTable;                                  // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveTable*                            HeroBalanceCurveTable;                             // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveTable*                            EconomyDataCurveTable;                             // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveTable*                            DamageResistanceRatingTable;                       // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveTable*                            DifficultySettingsTable;                           // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveTable*                            RespawnTimeTable;                                  // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveTable*                            CardScalingTable;                                  // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UCurveTable*>                    AlwaysLoadedCurveTables;                           // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UDataTable*                             HighlightEventTable;                               // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   XPSplitCurveName;                                  // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FScalableFloat                         ResistanceSumCurve;                                // 0x0088(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                   HeroCXPSplitCurveName;                             // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ConsolationCXPSplitCurveName;                      // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CXPSplitCurveName;                                 // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CardPointsPerLevel;                                // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MaxCardLevelName;                                  // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CardXPToLevelName;                                 // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CardXPBountyName;                                  // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UOrionHeroDataCollection*>       SelectableHeroes;                                  // 0x00E8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class UOrionHeroDataCollection*>       ShippingHeroes;                                    // 0x00F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UOrionHeroDataCollection*>       DevelopmentHeroes;                                 // 0x0108(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FOrionEmoteAbilityMapping>      EmoteAbilityMappings;                              // 0x0118(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UOrionPlayerInputSettings*              PlayerInputSettings;                               // 0x0128(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AOrionVisionManager2>       VisionManagerClass;                                // 0x0130(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionRotationalContentPreloadData*     RotationalContentPreloadData;                      // 0x0138(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         DebugRotationalContentKnownTagRoots;               // 0x0140(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         CharacterGravityScale;                             // 0x0150(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterDownwardGravityScale;                     // 0x0154(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileGravityScale;                            // 0x0158(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            MoveInputCurve;                                    // 0x0160(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintMinForwardInput;                             // 0x0168(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOrionMovementProfileData>      MovementProfileData;                               // 0x0170(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	class UOrionDecalLibrary*                     DecalLibraryData;                                  // 0x0180(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               DefaultTargetingTagRequirements;                   // 0x0188(0x0040)(Edit, NativeAccessSpecifierPublic)
	TSubclassOf<class AOrionGravesite>            GraveSiteRef;                                      // 0x01C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AOrionBanner>               BannerRef;                                         // 0x01D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AOrionBanner>               BannerFrontEndRef;                                 // 0x01D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AOrionTraversablePathway>   OrionTraversablePathwayRef;                        // 0x01E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOrionPickupInfo>               OrionUniversalPickupInfo;                          // 0x01E8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class AOrionCoin>                 CoinDataRef;                                       // 0x01F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            CoinCxpDataRef;                                    // 0x0200(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultCoinsToSpawn;                               // 0x0208(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultAssistDeathStreakResetCount;                // 0x020C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayStatsManager*                  GameplayStatsManager;                              // 0x0210(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PrimeHelixBuffDataRef;                             // 0x0218(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   BadAssDataRef;                                     // 0x0240(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   GodDataRef;                                        // 0x0268(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   MaxStatsDataRef;                                   // 0x0290(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   MinStatsDataRef;                                   // 0x02B8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   GameplayEffectMap[0x14];                           // 0x02E0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AOrionDamageNumberManager>  DamageNumberManagerClass;                          // 0x0600(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            NegativeResistanceCurve;                           // 0x0608(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            StandardInterrupt;                                 // 0x0610(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            StandardJuggernaut;                                // 0x0618(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            StandardIgnorePawnCollision;                       // 0x0620(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            StandardLimbo;                                     // 0x0628(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            StandardUnselectable;                              // 0x0630(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            StandardStun;                                      // 0x0638(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            StandardRoot;                                      // 0x0640(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            StandardSilence;                                   // 0x0648(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            StandardAbilityBlockMovement;                      // 0x0650(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            KillStreakGameplayEffect;                          // 0x0658(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            DeathStreakGameplayEffect;                         // 0x0660(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            CheatDamage;                                       // 0x0668(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            CardTraitElevateGameplayEffect;                    // 0x0670(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AOrionTutorialPath>         TutorialPathClass;                                 // 0x0678(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AEmitterCameraLensEffectBase> LowHealthScreenEffect;                             // 0x0680(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionGestureData*                      GestureData;                                       // 0x0688(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FScalableFloat                         ZoneVisionTimeOut;                                 // 0x0690(0x0028)(Edit, NativeAccessSpecifierPublic)
	class UGameplayTagTableManager*               TagTableManager;                                   // 0x06B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionItemizationSystemSettings*        ItemizationSystemSettings;                         // 0x06C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOrionGoldTagMarkupData>        GoldMarkupTagLookup;                               // 0x06C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   CullTheWeakExecuteThresholdBenefitCurve;           // 0x06D8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E8[0x8];                                      // 0x06E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameData">();
	}
	static class UOrionGameData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionGameData>();
	}
};
static_assert(alignof(UOrionGameData) == 0x000008, "Wrong alignment on UOrionGameData");
static_assert(sizeof(UOrionGameData) == 0x0006F0, "Wrong size on UOrionGameData");
static_assert(offsetof(UOrionGameData, GlobalCurveTable) == 0x000030, "Member 'UOrionGameData::GlobalCurveTable' has a wrong offset!");
static_assert(offsetof(UOrionGameData, HeroBalanceCurveTable) == 0x000038, "Member 'UOrionGameData::HeroBalanceCurveTable' has a wrong offset!");
static_assert(offsetof(UOrionGameData, EconomyDataCurveTable) == 0x000040, "Member 'UOrionGameData::EconomyDataCurveTable' has a wrong offset!");
static_assert(offsetof(UOrionGameData, DamageResistanceRatingTable) == 0x000048, "Member 'UOrionGameData::DamageResistanceRatingTable' has a wrong offset!");
static_assert(offsetof(UOrionGameData, DifficultySettingsTable) == 0x000050, "Member 'UOrionGameData::DifficultySettingsTable' has a wrong offset!");
static_assert(offsetof(UOrionGameData, RespawnTimeTable) == 0x000058, "Member 'UOrionGameData::RespawnTimeTable' has a wrong offset!");
static_assert(offsetof(UOrionGameData, CardScalingTable) == 0x000060, "Member 'UOrionGameData::CardScalingTable' has a wrong offset!");
static_assert(offsetof(UOrionGameData, AlwaysLoadedCurveTables) == 0x000068, "Member 'UOrionGameData::AlwaysLoadedCurveTables' has a wrong offset!");
static_assert(offsetof(UOrionGameData, HighlightEventTable) == 0x000078, "Member 'UOrionGameData::HighlightEventTable' has a wrong offset!");
static_assert(offsetof(UOrionGameData, XPSplitCurveName) == 0x000080, "Member 'UOrionGameData::XPSplitCurveName' has a wrong offset!");
static_assert(offsetof(UOrionGameData, ResistanceSumCurve) == 0x000088, "Member 'UOrionGameData::ResistanceSumCurve' has a wrong offset!");
static_assert(offsetof(UOrionGameData, HeroCXPSplitCurveName) == 0x0000B0, "Member 'UOrionGameData::HeroCXPSplitCurveName' has a wrong offset!");
static_assert(offsetof(UOrionGameData, ConsolationCXPSplitCurveName) == 0x0000B8, "Member 'UOrionGameData::ConsolationCXPSplitCurveName' has a wrong offset!");
static_assert(offsetof(UOrionGameData, CXPSplitCurveName) == 0x0000C0, "Member 'UOrionGameData::CXPSplitCurveName' has a wrong offset!");
static_assert(offsetof(UOrionGameData, CardPointsPerLevel) == 0x0000C8, "Member 'UOrionGameData::CardPointsPerLevel' has a wrong offset!");
static_assert(offsetof(UOrionGameData, MaxCardLevelName) == 0x0000D0, "Member 'UOrionGameData::MaxCardLevelName' has a wrong offset!");
static_assert(offsetof(UOrionGameData, CardXPToLevelName) == 0x0000D8, "Member 'UOrionGameData::CardXPToLevelName' has a wrong offset!");
static_assert(offsetof(UOrionGameData, CardXPBountyName) == 0x0000E0, "Member 'UOrionGameData::CardXPBountyName' has a wrong offset!");
static_assert(offsetof(UOrionGameData, SelectableHeroes) == 0x0000E8, "Member 'UOrionGameData::SelectableHeroes' has a wrong offset!");
static_assert(offsetof(UOrionGameData, ShippingHeroes) == 0x0000F8, "Member 'UOrionGameData::ShippingHeroes' has a wrong offset!");
static_assert(offsetof(UOrionGameData, DevelopmentHeroes) == 0x000108, "Member 'UOrionGameData::DevelopmentHeroes' has a wrong offset!");
static_assert(offsetof(UOrionGameData, EmoteAbilityMappings) == 0x000118, "Member 'UOrionGameData::EmoteAbilityMappings' has a wrong offset!");
static_assert(offsetof(UOrionGameData, PlayerInputSettings) == 0x000128, "Member 'UOrionGameData::PlayerInputSettings' has a wrong offset!");
static_assert(offsetof(UOrionGameData, VisionManagerClass) == 0x000130, "Member 'UOrionGameData::VisionManagerClass' has a wrong offset!");
static_assert(offsetof(UOrionGameData, RotationalContentPreloadData) == 0x000138, "Member 'UOrionGameData::RotationalContentPreloadData' has a wrong offset!");
static_assert(offsetof(UOrionGameData, DebugRotationalContentKnownTagRoots) == 0x000140, "Member 'UOrionGameData::DebugRotationalContentKnownTagRoots' has a wrong offset!");
static_assert(offsetof(UOrionGameData, CharacterGravityScale) == 0x000150, "Member 'UOrionGameData::CharacterGravityScale' has a wrong offset!");
static_assert(offsetof(UOrionGameData, CharacterDownwardGravityScale) == 0x000154, "Member 'UOrionGameData::CharacterDownwardGravityScale' has a wrong offset!");
static_assert(offsetof(UOrionGameData, ProjectileGravityScale) == 0x000158, "Member 'UOrionGameData::ProjectileGravityScale' has a wrong offset!");
static_assert(offsetof(UOrionGameData, MoveInputCurve) == 0x000160, "Member 'UOrionGameData::MoveInputCurve' has a wrong offset!");
static_assert(offsetof(UOrionGameData, SprintMinForwardInput) == 0x000168, "Member 'UOrionGameData::SprintMinForwardInput' has a wrong offset!");
static_assert(offsetof(UOrionGameData, MovementProfileData) == 0x000170, "Member 'UOrionGameData::MovementProfileData' has a wrong offset!");
static_assert(offsetof(UOrionGameData, DecalLibraryData) == 0x000180, "Member 'UOrionGameData::DecalLibraryData' has a wrong offset!");
static_assert(offsetof(UOrionGameData, DefaultTargetingTagRequirements) == 0x000188, "Member 'UOrionGameData::DefaultTargetingTagRequirements' has a wrong offset!");
static_assert(offsetof(UOrionGameData, GraveSiteRef) == 0x0001C8, "Member 'UOrionGameData::GraveSiteRef' has a wrong offset!");
static_assert(offsetof(UOrionGameData, BannerRef) == 0x0001D0, "Member 'UOrionGameData::BannerRef' has a wrong offset!");
static_assert(offsetof(UOrionGameData, BannerFrontEndRef) == 0x0001D8, "Member 'UOrionGameData::BannerFrontEndRef' has a wrong offset!");
static_assert(offsetof(UOrionGameData, OrionTraversablePathwayRef) == 0x0001E0, "Member 'UOrionGameData::OrionTraversablePathwayRef' has a wrong offset!");
static_assert(offsetof(UOrionGameData, OrionUniversalPickupInfo) == 0x0001E8, "Member 'UOrionGameData::OrionUniversalPickupInfo' has a wrong offset!");
static_assert(offsetof(UOrionGameData, CoinDataRef) == 0x0001F8, "Member 'UOrionGameData::CoinDataRef' has a wrong offset!");
static_assert(offsetof(UOrionGameData, CoinCxpDataRef) == 0x000200, "Member 'UOrionGameData::CoinCxpDataRef' has a wrong offset!");
static_assert(offsetof(UOrionGameData, DefaultCoinsToSpawn) == 0x000208, "Member 'UOrionGameData::DefaultCoinsToSpawn' has a wrong offset!");
static_assert(offsetof(UOrionGameData, DefaultAssistDeathStreakResetCount) == 0x00020C, "Member 'UOrionGameData::DefaultAssistDeathStreakResetCount' has a wrong offset!");
static_assert(offsetof(UOrionGameData, GameplayStatsManager) == 0x000210, "Member 'UOrionGameData::GameplayStatsManager' has a wrong offset!");
static_assert(offsetof(UOrionGameData, PrimeHelixBuffDataRef) == 0x000218, "Member 'UOrionGameData::PrimeHelixBuffDataRef' has a wrong offset!");
static_assert(offsetof(UOrionGameData, BadAssDataRef) == 0x000240, "Member 'UOrionGameData::BadAssDataRef' has a wrong offset!");
static_assert(offsetof(UOrionGameData, GodDataRef) == 0x000268, "Member 'UOrionGameData::GodDataRef' has a wrong offset!");
static_assert(offsetof(UOrionGameData, MaxStatsDataRef) == 0x000290, "Member 'UOrionGameData::MaxStatsDataRef' has a wrong offset!");
static_assert(offsetof(UOrionGameData, MinStatsDataRef) == 0x0002B8, "Member 'UOrionGameData::MinStatsDataRef' has a wrong offset!");
static_assert(offsetof(UOrionGameData, GameplayEffectMap) == 0x0002E0, "Member 'UOrionGameData::GameplayEffectMap' has a wrong offset!");
static_assert(offsetof(UOrionGameData, DamageNumberManagerClass) == 0x000600, "Member 'UOrionGameData::DamageNumberManagerClass' has a wrong offset!");
static_assert(offsetof(UOrionGameData, NegativeResistanceCurve) == 0x000608, "Member 'UOrionGameData::NegativeResistanceCurve' has a wrong offset!");
static_assert(offsetof(UOrionGameData, StandardInterrupt) == 0x000610, "Member 'UOrionGameData::StandardInterrupt' has a wrong offset!");
static_assert(offsetof(UOrionGameData, StandardJuggernaut) == 0x000618, "Member 'UOrionGameData::StandardJuggernaut' has a wrong offset!");
static_assert(offsetof(UOrionGameData, StandardIgnorePawnCollision) == 0x000620, "Member 'UOrionGameData::StandardIgnorePawnCollision' has a wrong offset!");
static_assert(offsetof(UOrionGameData, StandardLimbo) == 0x000628, "Member 'UOrionGameData::StandardLimbo' has a wrong offset!");
static_assert(offsetof(UOrionGameData, StandardUnselectable) == 0x000630, "Member 'UOrionGameData::StandardUnselectable' has a wrong offset!");
static_assert(offsetof(UOrionGameData, StandardStun) == 0x000638, "Member 'UOrionGameData::StandardStun' has a wrong offset!");
static_assert(offsetof(UOrionGameData, StandardRoot) == 0x000640, "Member 'UOrionGameData::StandardRoot' has a wrong offset!");
static_assert(offsetof(UOrionGameData, StandardSilence) == 0x000648, "Member 'UOrionGameData::StandardSilence' has a wrong offset!");
static_assert(offsetof(UOrionGameData, StandardAbilityBlockMovement) == 0x000650, "Member 'UOrionGameData::StandardAbilityBlockMovement' has a wrong offset!");
static_assert(offsetof(UOrionGameData, KillStreakGameplayEffect) == 0x000658, "Member 'UOrionGameData::KillStreakGameplayEffect' has a wrong offset!");
static_assert(offsetof(UOrionGameData, DeathStreakGameplayEffect) == 0x000660, "Member 'UOrionGameData::DeathStreakGameplayEffect' has a wrong offset!");
static_assert(offsetof(UOrionGameData, CheatDamage) == 0x000668, "Member 'UOrionGameData::CheatDamage' has a wrong offset!");
static_assert(offsetof(UOrionGameData, CardTraitElevateGameplayEffect) == 0x000670, "Member 'UOrionGameData::CardTraitElevateGameplayEffect' has a wrong offset!");
static_assert(offsetof(UOrionGameData, TutorialPathClass) == 0x000678, "Member 'UOrionGameData::TutorialPathClass' has a wrong offset!");
static_assert(offsetof(UOrionGameData, LowHealthScreenEffect) == 0x000680, "Member 'UOrionGameData::LowHealthScreenEffect' has a wrong offset!");
static_assert(offsetof(UOrionGameData, GestureData) == 0x000688, "Member 'UOrionGameData::GestureData' has a wrong offset!");
static_assert(offsetof(UOrionGameData, ZoneVisionTimeOut) == 0x000690, "Member 'UOrionGameData::ZoneVisionTimeOut' has a wrong offset!");
static_assert(offsetof(UOrionGameData, TagTableManager) == 0x0006B8, "Member 'UOrionGameData::TagTableManager' has a wrong offset!");
static_assert(offsetof(UOrionGameData, ItemizationSystemSettings) == 0x0006C0, "Member 'UOrionGameData::ItemizationSystemSettings' has a wrong offset!");
static_assert(offsetof(UOrionGameData, GoldMarkupTagLookup) == 0x0006C8, "Member 'UOrionGameData::GoldMarkupTagLookup' has a wrong offset!");
static_assert(offsetof(UOrionGameData, CullTheWeakExecuteThresholdBenefitCurve) == 0x0006D8, "Member 'UOrionGameData::CullTheWeakExecuteThresholdBenefitCurve' has a wrong offset!");

// Class OrionGame.OrionMatchmaker
// 0x02F8 (0x0320 - 0x0028)
class UOrionMatchmaker final : public UObject
{
public:
	class UOrionMatchmakingSearchPass*            SearchPass;                                        // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AOrionPartyBeaconClient*                PartyBeaconClient;                                 // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionSessionHelper*                    SessionHelper;                                     // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SearchPolicyIdx;                                   // 0x0040(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CurrentAttemptNum;                                 // 0x0044(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FMatchmakingParams                     CurrentParams;                                     // 0x0048(0x0098)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x228];                                     // 0x00E0(0x0228)(Fixing Size After Last Property [ Dumper-7 ])
	EMatchmakingUpdateStatus                      CurrentStatus;                                     // 0x0308(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_309[0x17];                                     // 0x0309(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMatchmaker">();
	}
	static class UOrionMatchmaker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMatchmaker>();
	}
};
static_assert(alignof(UOrionMatchmaker) == 0x000008, "Wrong alignment on UOrionMatchmaker");
static_assert(sizeof(UOrionMatchmaker) == 0x000320, "Wrong size on UOrionMatchmaker");
static_assert(offsetof(UOrionMatchmaker, SearchPass) == 0x000028, "Member 'UOrionMatchmaker::SearchPass' has a wrong offset!");
static_assert(offsetof(UOrionMatchmaker, PartyBeaconClient) == 0x000030, "Member 'UOrionMatchmaker::PartyBeaconClient' has a wrong offset!");
static_assert(offsetof(UOrionMatchmaker, SessionHelper) == 0x000038, "Member 'UOrionMatchmaker::SessionHelper' has a wrong offset!");
static_assert(offsetof(UOrionMatchmaker, SearchPolicyIdx) == 0x000040, "Member 'UOrionMatchmaker::SearchPolicyIdx' has a wrong offset!");
static_assert(offsetof(UOrionMatchmaker, CurrentAttemptNum) == 0x000044, "Member 'UOrionMatchmaker::CurrentAttemptNum' has a wrong offset!");
static_assert(offsetof(UOrionMatchmaker, CurrentParams) == 0x000048, "Member 'UOrionMatchmaker::CurrentParams' has a wrong offset!");
static_assert(offsetof(UOrionMatchmaker, CurrentStatus) == 0x000308, "Member 'UOrionMatchmaker::CurrentStatus' has a wrong offset!");

// Class OrionGame.OrionLightBox
// 0x0158 (0x0410 - 0x02B8)
class UOrionLightBox : public UOrionUserWidgetBase
{
public:
	uint8                                         Pad_2B8[0x48];                                     // 0x02B8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            BackgroundBrush;                                   // 0x0300(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FMargin                                ContentPadding;                                    // 0x0378(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EHorizontalAlignment                          ContentHAlign;                                     // 0x0388(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EVerticalAlignment                            ContentVAlign;                                     // 0x0389(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38A[0x2];                                      // 0x038A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeDuration;                                      // 0x038C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOrionActivatableWidget*                ActivatableContent;                                // 0x0390(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_398[0x60];                                     // 0x0398(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 Image_Background;                                  // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNamedSlot*                             Slot_Content;                                      // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_408[0x8];                                      // 0x0408(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EstablishActivatableContent(class UOrionActivatableWidget* NewContent);
	void OnContentActivationChanged(bool bActivated);
	void OverrideContentActivation(bool bActivate);

	bool IsContentActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionLightBox">();
	}
	static class UOrionLightBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionLightBox>();
	}
};
static_assert(alignof(UOrionLightBox) == 0x000008, "Wrong alignment on UOrionLightBox");
static_assert(sizeof(UOrionLightBox) == 0x000410, "Wrong size on UOrionLightBox");
static_assert(offsetof(UOrionLightBox, BackgroundBrush) == 0x000300, "Member 'UOrionLightBox::BackgroundBrush' has a wrong offset!");
static_assert(offsetof(UOrionLightBox, ContentPadding) == 0x000378, "Member 'UOrionLightBox::ContentPadding' has a wrong offset!");
static_assert(offsetof(UOrionLightBox, ContentHAlign) == 0x000388, "Member 'UOrionLightBox::ContentHAlign' has a wrong offset!");
static_assert(offsetof(UOrionLightBox, ContentVAlign) == 0x000389, "Member 'UOrionLightBox::ContentVAlign' has a wrong offset!");
static_assert(offsetof(UOrionLightBox, FadeDuration) == 0x00038C, "Member 'UOrionLightBox::FadeDuration' has a wrong offset!");
static_assert(offsetof(UOrionLightBox, ActivatableContent) == 0x000390, "Member 'UOrionLightBox::ActivatableContent' has a wrong offset!");
static_assert(offsetof(UOrionLightBox, Image_Background) == 0x0003F8, "Member 'UOrionLightBox::Image_Background' has a wrong offset!");
static_assert(offsetof(UOrionLightBox, Slot_Content) == 0x000400, "Member 'UOrionLightBox::Slot_Content' has a wrong offset!");

// Class OrionGame.EventKeywordCollection
// 0x0010 (0x0038 - 0x0028)
class UEventKeywordCollection final : public UObject
{
public:
	TArray<struct FEventKeywordCollectionItem>    Events;                                            // 0x0028(0x0010)(Edit, ZeroConstructor, Config, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventKeywordCollection">();
	}
	static class UEventKeywordCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventKeywordCollection>();
	}
};
static_assert(alignof(UEventKeywordCollection) == 0x000008, "Wrong alignment on UEventKeywordCollection");
static_assert(sizeof(UEventKeywordCollection) == 0x000038, "Wrong size on UEventKeywordCollection");
static_assert(offsetof(UEventKeywordCollection, Events) == 0x000028, "Member 'UEventKeywordCollection::Events' has a wrong offset!");

// Class OrionGame.OrionMatchmakingSearchPass
// 0x01A8 (0x01D0 - 0x0028)
class UOrionMatchmakingSearchPass final : public UObject
{
public:
	bool                                          bIsRunningSearch;                                  // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentControllerId;                               // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SearchResultIdx;                                   // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x19C];                                     // 0x0034(0x019C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMatchmakingSearchPass">();
	}
	static class UOrionMatchmakingSearchPass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMatchmakingSearchPass>();
	}
};
static_assert(alignof(UOrionMatchmakingSearchPass) == 0x000008, "Wrong alignment on UOrionMatchmakingSearchPass");
static_assert(sizeof(UOrionMatchmakingSearchPass) == 0x0001D0, "Wrong size on UOrionMatchmakingSearchPass");
static_assert(offsetof(UOrionMatchmakingSearchPass, bIsRunningSearch) == 0x000028, "Member 'UOrionMatchmakingSearchPass::bIsRunningSearch' has a wrong offset!");
static_assert(offsetof(UOrionMatchmakingSearchPass, CurrentControllerId) == 0x00002C, "Member 'UOrionMatchmakingSearchPass::CurrentControllerId' has a wrong offset!");
static_assert(offsetof(UOrionMatchmakingSearchPass, SearchResultIdx) == 0x000030, "Member 'UOrionMatchmakingSearchPass::SearchResultIdx' has a wrong offset!");

// Class OrionGame.OrionGameMode_Arcade_Base
// 0x0080 (0x0E70 - 0x0DF0)
class AOrionGameMode_Arcade_Base final : public AOrionGameMode_MOBA
{
public:
	class AOrionGameState_Arcade*                 GameStateArcade;                                   // 0x0DF0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLadderURLData                         LadderData;                                        // 0x0DF8(0x0038)(Protected, NativeAccessSpecifierProtected)
	struct FArcadeRoundState                      RoundState;                                        // 0x0E30(0x0018)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AOrionPlayerState_Arcade*>       PlayersNeedingRecall;                              // 0x0E48(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E58[0x18];                                     // 0x0E58(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_InitArcadePlayerState(class AOrionPlayerState_Arcade* PlayerState, bool bIsBot, bool bIsFriendly);
	void OnRoundState_InRound();
	void OnRoundState_Overtime();
	void OnRoundState_PostRound();
	void OnRoundState_PreMatch();
	void OnRoundState_PreRound();
	void OnRoundState_Restarting();
	void OnRoundState_RoundsOver();
	void OnRoundState_WaitingForRecall();
	void OnRoundStateChange(EArcadeRoundPhase NewRoundState);
	void PausePlayer(class AOrionPlayerState_Arcade* PlayerState, bool bShouldPause);

	class AOrionGameState_Arcade* GetGameStateArcade() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameMode_Arcade_Base">();
	}
	static class AOrionGameMode_Arcade_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionGameMode_Arcade_Base>();
	}
};
static_assert(alignof(AOrionGameMode_Arcade_Base) == 0x000008, "Wrong alignment on AOrionGameMode_Arcade_Base");
static_assert(sizeof(AOrionGameMode_Arcade_Base) == 0x000E70, "Wrong size on AOrionGameMode_Arcade_Base");
static_assert(offsetof(AOrionGameMode_Arcade_Base, GameStateArcade) == 0x000DF0, "Member 'AOrionGameMode_Arcade_Base::GameStateArcade' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_Arcade_Base, LadderData) == 0x000DF8, "Member 'AOrionGameMode_Arcade_Base::LadderData' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_Arcade_Base, RoundState) == 0x000E30, "Member 'AOrionGameMode_Arcade_Base::RoundState' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_Arcade_Base, PlayersNeedingRecall) == 0x000E48, "Member 'AOrionGameMode_Arcade_Base::PlayersNeedingRecall' has a wrong offset!");

// Class OrionGame.OrionNavArea_JumpPad
// 0x0000 (0x0040 - 0x0040)
class UOrionNavArea_JumpPad final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionNavArea_JumpPad">();
	}
	static class UOrionNavArea_JumpPad* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionNavArea_JumpPad>();
	}
};
static_assert(alignof(UOrionNavArea_JumpPad) == 0x000008, "Wrong alignment on UOrionNavArea_JumpPad");
static_assert(sizeof(UOrionNavArea_JumpPad) == 0x000040, "Wrong size on UOrionNavArea_JumpPad");

// Class OrionGame.OrionGameMode_DraftLobby
// 0x00E8 (0x05C8 - 0x04E0)
class AOrionGameMode_DraftLobby final : public AOrionGameMode_Base
{
public:
	uint8                                         Pad_4E0[0x8];                                      // 0x04E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionReplayDetailsManager*             ReplayDetailsManager;                              // 0x04E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F0[0x50];                                     // 0x04F0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionDraftTimings                     DefaultTiming;                                     // 0x0540(0x0014)(Config, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FOrionDraftTimings                     VeteranTiming;                                     // 0x0554(0x0014)(Config, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bVeteranTimingEnabled;                             // 0x0568(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_569[0x3];                                      // 0x0569(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AccountLevelForVeteranTiming;                      // 0x056C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GracePeriodDuration;                               // 0x0570(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoLockInSoftSelectedHeroOnTimeout;              // 0x0574(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPenaltiesEnabled;                                 // 0x0575(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPenalizeNeverJoins;                               // 0x0576(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPenalizeAssociates;                               // 0x0577(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOnlyPenalizeMissingPlayers;                       // 0x0578(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPenalizeInCustomGames;                            // 0x0579(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_57A[0x2];                                      // 0x057A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AbortingDraftCountdownSeconds;                     // 0x057C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FinishAsyncLoadTimeout;                            // 0x0580(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNeverAbort;                                       // 0x0584(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugShouldTravel;                                // 0x0585(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_586[0x42];                                     // 0x0586(0x0042)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameMode_DraftLobby">();
	}
	static class AOrionGameMode_DraftLobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionGameMode_DraftLobby>();
	}
};
static_assert(alignof(AOrionGameMode_DraftLobby) == 0x000008, "Wrong alignment on AOrionGameMode_DraftLobby");
static_assert(sizeof(AOrionGameMode_DraftLobby) == 0x0005C8, "Wrong size on AOrionGameMode_DraftLobby");
static_assert(offsetof(AOrionGameMode_DraftLobby, ReplayDetailsManager) == 0x0004E8, "Member 'AOrionGameMode_DraftLobby::ReplayDetailsManager' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_DraftLobby, DefaultTiming) == 0x000540, "Member 'AOrionGameMode_DraftLobby::DefaultTiming' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_DraftLobby, VeteranTiming) == 0x000554, "Member 'AOrionGameMode_DraftLobby::VeteranTiming' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_DraftLobby, bVeteranTimingEnabled) == 0x000568, "Member 'AOrionGameMode_DraftLobby::bVeteranTimingEnabled' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_DraftLobby, AccountLevelForVeteranTiming) == 0x00056C, "Member 'AOrionGameMode_DraftLobby::AccountLevelForVeteranTiming' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_DraftLobby, GracePeriodDuration) == 0x000570, "Member 'AOrionGameMode_DraftLobby::GracePeriodDuration' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_DraftLobby, bAutoLockInSoftSelectedHeroOnTimeout) == 0x000574, "Member 'AOrionGameMode_DraftLobby::bAutoLockInSoftSelectedHeroOnTimeout' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_DraftLobby, bPenaltiesEnabled) == 0x000575, "Member 'AOrionGameMode_DraftLobby::bPenaltiesEnabled' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_DraftLobby, bPenalizeNeverJoins) == 0x000576, "Member 'AOrionGameMode_DraftLobby::bPenalizeNeverJoins' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_DraftLobby, bPenalizeAssociates) == 0x000577, "Member 'AOrionGameMode_DraftLobby::bPenalizeAssociates' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_DraftLobby, bOnlyPenalizeMissingPlayers) == 0x000578, "Member 'AOrionGameMode_DraftLobby::bOnlyPenalizeMissingPlayers' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_DraftLobby, bPenalizeInCustomGames) == 0x000579, "Member 'AOrionGameMode_DraftLobby::bPenalizeInCustomGames' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_DraftLobby, AbortingDraftCountdownSeconds) == 0x00057C, "Member 'AOrionGameMode_DraftLobby::AbortingDraftCountdownSeconds' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_DraftLobby, FinishAsyncLoadTimeout) == 0x000580, "Member 'AOrionGameMode_DraftLobby::FinishAsyncLoadTimeout' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_DraftLobby, bNeverAbort) == 0x000584, "Member 'AOrionGameMode_DraftLobby::bNeverAbort' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_DraftLobby, bDebugShouldTravel) == 0x000585, "Member 'AOrionGameMode_DraftLobby::bDebugShouldTravel' has a wrong offset!");

// Class OrionGame.OrionMatchDataLoader
// 0x00B8 (0x00E0 - 0x0028)
class UOrionMatchDataLoader final : public UObject
{
public:
	TArray<struct FOrionHeroDataSpec>             HeroDataToLoad;                                    // 0x0028(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	double                                        TotalHeroLoadTime;                                 // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	double                                        TotalLoadTime;                                     // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NumHeroDataLoaded;                                 // 0x0048(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsLoadingMatchData;                               // 0x004C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D[0x93];                                      // 0x004D(0x0093)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void TimerCallback();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMatchDataLoader">();
	}
	static class UOrionMatchDataLoader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMatchDataLoader>();
	}
};
static_assert(alignof(UOrionMatchDataLoader) == 0x000008, "Wrong alignment on UOrionMatchDataLoader");
static_assert(sizeof(UOrionMatchDataLoader) == 0x0000E0, "Wrong size on UOrionMatchDataLoader");
static_assert(offsetof(UOrionMatchDataLoader, HeroDataToLoad) == 0x000028, "Member 'UOrionMatchDataLoader::HeroDataToLoad' has a wrong offset!");
static_assert(offsetof(UOrionMatchDataLoader, TotalHeroLoadTime) == 0x000038, "Member 'UOrionMatchDataLoader::TotalHeroLoadTime' has a wrong offset!");
static_assert(offsetof(UOrionMatchDataLoader, TotalLoadTime) == 0x000040, "Member 'UOrionMatchDataLoader::TotalLoadTime' has a wrong offset!");
static_assert(offsetof(UOrionMatchDataLoader, NumHeroDataLoaded) == 0x000048, "Member 'UOrionMatchDataLoader::NumHeroDataLoaded' has a wrong offset!");
static_assert(offsetof(UOrionMatchDataLoader, bIsLoadingMatchData) == 0x00004C, "Member 'UOrionMatchDataLoader::bIsLoadingMatchData' has a wrong offset!");

// Class OrionGame.OrionGameMode_Main
// 0x00E8 (0x05C8 - 0x04E0)
class AOrionGameMode_Main final : public AOrionGameMode_Base
{
public:
	bool                                          bIsInitialized;                                    // 0x04E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E1[0x7];                                      // 0x04E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnFeaturedHeroChange;                              // 0x04E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EUpdateCompletionStatus                       UpdateCompletionStatus;                            // 0x04F8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F9[0xCF];                                     // 0x04F9(0x00CF)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameMode_Main">();
	}
	static class AOrionGameMode_Main* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionGameMode_Main>();
	}
};
static_assert(alignof(AOrionGameMode_Main) == 0x000008, "Wrong alignment on AOrionGameMode_Main");
static_assert(sizeof(AOrionGameMode_Main) == 0x0005C8, "Wrong size on AOrionGameMode_Main");
static_assert(offsetof(AOrionGameMode_Main, bIsInitialized) == 0x0004E0, "Member 'AOrionGameMode_Main::bIsInitialized' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_Main, OnFeaturedHeroChange) == 0x0004E8, "Member 'AOrionGameMode_Main::OnFeaturedHeroChange' has a wrong offset!");
static_assert(offsetof(AOrionGameMode_Main, UpdateCompletionStatus) == 0x0004F8, "Member 'AOrionGameMode_Main::UpdateCompletionStatus' has a wrong offset!");

// Class OrionGame.OrionNavFilter_TeamBlue
// 0x0000 (0x0048 - 0x0048)
class UOrionNavFilter_TeamBlue final : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionNavFilter_TeamBlue">();
	}
	static class UOrionNavFilter_TeamBlue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionNavFilter_TeamBlue>();
	}
};
static_assert(alignof(UOrionNavFilter_TeamBlue) == 0x000008, "Wrong alignment on UOrionNavFilter_TeamBlue");
static_assert(sizeof(UOrionNavFilter_TeamBlue) == 0x000048, "Wrong size on UOrionNavFilter_TeamBlue");

// Class OrionGame.OrionGameMode_PreGame
// 0x0000 (0x04E0 - 0x04E0)
class AOrionGameMode_PreGame final : public AOrionGameMode_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameMode_PreGame">();
	}
	static class AOrionGameMode_PreGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionGameMode_PreGame>();
	}
};
static_assert(alignof(AOrionGameMode_PreGame) == 0x000008, "Wrong alignment on AOrionGameMode_PreGame");
static_assert(sizeof(AOrionGameMode_PreGame) == 0x0004E0, "Wrong size on AOrionGameMode_PreGame");

// Class OrionGame.OrionNavFilter_IgnoreTowerCost
// 0x0000 (0x0048 - 0x0048)
class UOrionNavFilter_IgnoreTowerCost : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionNavFilter_IgnoreTowerCost">();
	}
	static class UOrionNavFilter_IgnoreTowerCost* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionNavFilter_IgnoreTowerCost>();
	}
};
static_assert(alignof(UOrionNavFilter_IgnoreTowerCost) == 0x000008, "Wrong alignment on UOrionNavFilter_IgnoreTowerCost");
static_assert(sizeof(UOrionNavFilter_IgnoreTowerCost) == 0x000048, "Wrong size on UOrionNavFilter_IgnoreTowerCost");

// Class OrionGame.OrionGameplayCard
// 0x00D0 (0x0280 - 0x01B0)
class UOrionGameplayCard final : public UOrionGameplayItem
{
public:
	uint8                                         Pad_1B0[0x40];                                     // 0x01B0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HandIndex;                                         // 0x01F0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CardLevel;                                         // 0x01F4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F8[0x4];                                      // 0x01F8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayCurrencyBundle                AdjustedCardCost;                                  // 0x01FC(0x0010)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_20C[0x74];                                     // 0x020C(0x0074)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_AdjustedCardCost();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameplayCard">();
	}
	static class UOrionGameplayCard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionGameplayCard>();
	}
};
static_assert(alignof(UOrionGameplayCard) == 0x000008, "Wrong alignment on UOrionGameplayCard");
static_assert(sizeof(UOrionGameplayCard) == 0x000280, "Wrong size on UOrionGameplayCard");
static_assert(offsetof(UOrionGameplayCard, HandIndex) == 0x0001F0, "Member 'UOrionGameplayCard::HandIndex' has a wrong offset!");
static_assert(offsetof(UOrionGameplayCard, CardLevel) == 0x0001F4, "Member 'UOrionGameplayCard::CardLevel' has a wrong offset!");
static_assert(offsetof(UOrionGameplayCard, AdjustedCardCost) == 0x0001FC, "Member 'UOrionGameplayCard::AdjustedCardCost' has a wrong offset!");

// Class OrionGame.OrionLobbyBuilder
// 0x0238 (0x0260 - 0x0028)
class UOrionLobbyBuilder final : public UObject
{
public:
	float                                         CheckForOtherLobbiesInterval;                      // 0x0028(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MMRSearchEquivalence;                              // 0x002C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPreferSamePartySize;                              // 0x0030(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionMMRExpansion                     MMRCurve;                                          // 0x0038(0x0030)(Config, NativeAccessSpecifierPrivate)
	TArray<struct FOrionMMRExpansion>             PlaylistMMRCurves;                                 // 0x0068(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	int32                                         HighMMRBucketThreshold;                            // 0x0078(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HighMMRBucketExpansionDelay;                       // 0x007C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MidMMRBucketThreshold;                             // 0x0080(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MidMMRBucketExpansionFactor;                       // 0x0084(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LowMMRBucketThreshold;                             // 0x0088(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LowMMRBucketExpansionDelay;                        // 0x008C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RetrySearchDelay;                                  // 0x0090(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MMNumAttempts;                                     // 0x0094(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MMNextResultDelay;                                 // 0x0098(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MMRerunSearchDelay;                                // 0x009C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MMRerunNoCreateDelay;                              // 0x00A0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MMCreateGameChance;                                // 0x00A4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         UpdateEstWaitTimesInterval;                        // 0x00A8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MMRBucketIncr;                                     // 0x00AC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RecordHeartbeatInterval;                           // 0x00B0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LogTailLengthKb;                                   // 0x00B4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FOrionLobbyBuilderParams               Params_0;                                          // 0x00B8(0x0058)(Transient, NativeAccessSpecifierPrivate)
	EOrionLobbyBuilderState                       CurrentState;                                      // 0x0110(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        StartTime;                                         // 0x0118(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PartyMMR;                                          // 0x0120(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMMRWaitTime                           EstWaitTime;                                       // 0x0128(0x0010)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	class AOrionPartyBeaconClient*                LobbyBeaconClient;                                 // 0x0138(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LobbyBeaconNumRemainingPlayers;                    // 0x0140(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EOrionLobbyBuilderResult                      PendingResult;                                     // 0x0144(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_145[0xC3];                                     // 0x0145(0x00C3)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              LastUpdateCheck;                                   // 0x0208(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SecondsBetweenUpdateChecks;                        // 0x0210(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PatchCheckCompleteDelay;                           // 0x0214(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCancelDuringPatchCheck;                           // 0x0218(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_219[0x3];                                      // 0x0219(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DebugMaxMMRDelta;                                  // 0x021C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         DebugMinMMRDelta;                                  // 0x0220(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DebugCurrentWaitTime;                              // 0x0224(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FUniqueNetIdRepl                       DebugCurrentSessionId;                             // 0x0228(0x0018)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ReadyCheckCount;                                   // 0x0240(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  MatchmakingGuid;                                   // 0x0244(0x0010)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_254[0x4];                                      // 0x0254(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              StartTimeUtc;                                      // 0x0258(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnEnterState_CancelSearchPass();
	void OnEnterState_Finished();
	void OnEnterState_HandlingError();
	void OnEnterState_LeavingLobby();
	void OnEnterState_PatchCheck();
	void OnEnterState_ReadyingUp();
	void OnEnterState_ReconnectToBeacon();
	void OnEnterState_RetrySearch();
	void OnEnterState_Searching();
	void OnEnterState_Starting();
	void OnEnterState_TravellingToMatch();
	void OnEnterState_WaitingForPlayers();
	void OnExitState_CancelSearchPass();
	void OnExitState_Finished();
	void OnExitState_HandlingError();
	void OnExitState_LeavingLobby();
	void OnExitState_PatchCheck();
	void OnExitState_ReadyingUp();
	void OnExitState_ReconnectToBeacon();
	void OnExitState_RetrySearch();
	void OnExitState_Searching();
	void OnExitState_Starting();
	void OnExitState_TravellingToMatch();
	void OnExitState_WaitingForPlayers();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionLobbyBuilder">();
	}
	static class UOrionLobbyBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionLobbyBuilder>();
	}
};
static_assert(alignof(UOrionLobbyBuilder) == 0x000008, "Wrong alignment on UOrionLobbyBuilder");
static_assert(sizeof(UOrionLobbyBuilder) == 0x000260, "Wrong size on UOrionLobbyBuilder");
static_assert(offsetof(UOrionLobbyBuilder, CheckForOtherLobbiesInterval) == 0x000028, "Member 'UOrionLobbyBuilder::CheckForOtherLobbiesInterval' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, MMRSearchEquivalence) == 0x00002C, "Member 'UOrionLobbyBuilder::MMRSearchEquivalence' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, bPreferSamePartySize) == 0x000030, "Member 'UOrionLobbyBuilder::bPreferSamePartySize' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, MMRCurve) == 0x000038, "Member 'UOrionLobbyBuilder::MMRCurve' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, PlaylistMMRCurves) == 0x000068, "Member 'UOrionLobbyBuilder::PlaylistMMRCurves' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, HighMMRBucketThreshold) == 0x000078, "Member 'UOrionLobbyBuilder::HighMMRBucketThreshold' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, HighMMRBucketExpansionDelay) == 0x00007C, "Member 'UOrionLobbyBuilder::HighMMRBucketExpansionDelay' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, MidMMRBucketThreshold) == 0x000080, "Member 'UOrionLobbyBuilder::MidMMRBucketThreshold' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, MidMMRBucketExpansionFactor) == 0x000084, "Member 'UOrionLobbyBuilder::MidMMRBucketExpansionFactor' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, LowMMRBucketThreshold) == 0x000088, "Member 'UOrionLobbyBuilder::LowMMRBucketThreshold' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, LowMMRBucketExpansionDelay) == 0x00008C, "Member 'UOrionLobbyBuilder::LowMMRBucketExpansionDelay' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, RetrySearchDelay) == 0x000090, "Member 'UOrionLobbyBuilder::RetrySearchDelay' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, MMNumAttempts) == 0x000094, "Member 'UOrionLobbyBuilder::MMNumAttempts' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, MMNextResultDelay) == 0x000098, "Member 'UOrionLobbyBuilder::MMNextResultDelay' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, MMRerunSearchDelay) == 0x00009C, "Member 'UOrionLobbyBuilder::MMRerunSearchDelay' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, MMRerunNoCreateDelay) == 0x0000A0, "Member 'UOrionLobbyBuilder::MMRerunNoCreateDelay' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, MMCreateGameChance) == 0x0000A4, "Member 'UOrionLobbyBuilder::MMCreateGameChance' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, UpdateEstWaitTimesInterval) == 0x0000A8, "Member 'UOrionLobbyBuilder::UpdateEstWaitTimesInterval' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, MMRBucketIncr) == 0x0000AC, "Member 'UOrionLobbyBuilder::MMRBucketIncr' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, RecordHeartbeatInterval) == 0x0000B0, "Member 'UOrionLobbyBuilder::RecordHeartbeatInterval' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, LogTailLengthKb) == 0x0000B4, "Member 'UOrionLobbyBuilder::LogTailLengthKb' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, Params_0) == 0x0000B8, "Member 'UOrionLobbyBuilder::Params_0' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, CurrentState) == 0x000110, "Member 'UOrionLobbyBuilder::CurrentState' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, StartTime) == 0x000118, "Member 'UOrionLobbyBuilder::StartTime' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, PartyMMR) == 0x000120, "Member 'UOrionLobbyBuilder::PartyMMR' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, EstWaitTime) == 0x000128, "Member 'UOrionLobbyBuilder::EstWaitTime' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, LobbyBeaconClient) == 0x000138, "Member 'UOrionLobbyBuilder::LobbyBeaconClient' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, LobbyBeaconNumRemainingPlayers) == 0x000140, "Member 'UOrionLobbyBuilder::LobbyBeaconNumRemainingPlayers' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, PendingResult) == 0x000144, "Member 'UOrionLobbyBuilder::PendingResult' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, LastUpdateCheck) == 0x000208, "Member 'UOrionLobbyBuilder::LastUpdateCheck' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, SecondsBetweenUpdateChecks) == 0x000210, "Member 'UOrionLobbyBuilder::SecondsBetweenUpdateChecks' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, PatchCheckCompleteDelay) == 0x000214, "Member 'UOrionLobbyBuilder::PatchCheckCompleteDelay' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, bCancelDuringPatchCheck) == 0x000218, "Member 'UOrionLobbyBuilder::bCancelDuringPatchCheck' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, DebugMaxMMRDelta) == 0x00021C, "Member 'UOrionLobbyBuilder::DebugMaxMMRDelta' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, DebugMinMMRDelta) == 0x000220, "Member 'UOrionLobbyBuilder::DebugMinMMRDelta' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, DebugCurrentWaitTime) == 0x000224, "Member 'UOrionLobbyBuilder::DebugCurrentWaitTime' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, DebugCurrentSessionId) == 0x000228, "Member 'UOrionLobbyBuilder::DebugCurrentSessionId' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, ReadyCheckCount) == 0x000240, "Member 'UOrionLobbyBuilder::ReadyCheckCount' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, MatchmakingGuid) == 0x000244, "Member 'UOrionLobbyBuilder::MatchmakingGuid' has a wrong offset!");
static_assert(offsetof(UOrionLobbyBuilder, StartTimeUtc) == 0x000258, "Member 'UOrionLobbyBuilder::StartTimeUtc' has a wrong offset!");

// Class OrionGame.OrionGameplayCue_ItemizationOverHead
// 0x0130 (0x0970 - 0x0840)
class AOrionGameplayCue_ItemizationOverHead : public AOrionGameplayCueNotify_Looping
{
public:
	class USceneComponent*                        CardRootComp;                                      // 0x0840(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   CardFrontMesh;                                     // 0x0848(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     CardFrontMaterial;                                 // 0x0850(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               CardFrontDMI;                                      // 0x0858(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   CardBackMesh;                                      // 0x0860(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     CardBackMaterial;                                  // 0x0868(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               CardBackDMI;                                       // 0x0870(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorSequenceComponent*                CardEquippedSequence;                              // 0x0878(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorSequenceComponent*                CardStartActivationSequence;                       // 0x0880(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorSequenceComponent*                CardEndActivationSequence;                         // 0x0888(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorSequenceComponent*                CardConsumedSequence;                              // 0x0890(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorSequenceComponent*                CardCombustedSequence;                             // 0x0898(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        RootGemComp;                                       // 0x08A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   GemMesh;                                           // 0x08A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     GemMaterial;                                       // 0x08B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               GemDMI;                                            // 0x08B8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorSequenceComponent*                GemEquippedSequence;                               // 0x08C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorSequenceComponent*                GemStartActivationSequence;                        // 0x08C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorSequenceComponent*                GemEndActivationSequence;                          // 0x08D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CardHeadZOffset;                                   // 0x08D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTimeInIdle;                                     // 0x08DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleTimeToAddOnRetrigger;                          // 0x08E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartConsumeEffectPct;                             // 0x08E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndConsumeEffectPct;                               // 0x08E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8EC[0x4];                                      // 0x08EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TextureParamName;                                  // 0x08F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BorderParamName;                                   // 0x08F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UICardMatBorderParamName;                          // 0x0900(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DiamondSwitchParamName;                            // 0x0908(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ComsumtionEffectParamName;                         // 0x0910(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CombustionEffectParamName;                         // 0x0918(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBoundToTarget;                                    // 0x0920(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHiddenByShadowplane;                              // 0x0921(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_922[0x6];                                      // 0x0922(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrionCharHero*                         CurrentBoundTarget;                                // 0x0928(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionGameplayCard*                     CurrentCard;                                       // 0x0930(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionItemEvent                               CurrentCardEventExecuting;                         // 0x0938(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionItemState                               CardSequencerPlaying;                              // 0x0939(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_93A[0x1E];                                     // 0x093A(0x001E)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionGameplayGem*                      CurrentGem;                                        // 0x0958(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionItemEvent                               CurrentGemEventExecuting;                          // 0x0960(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionItemState                               GemSequencerPlaying;                               // 0x0961(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_962[0xE];                                      // 0x0962(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UActorSequencePlayer* GetSequencerForCardInteraction(EOrionItemState SequencerType);
	void HandleSequencerEnded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameplayCue_ItemizationOverHead">();
	}
	static class AOrionGameplayCue_ItemizationOverHead* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionGameplayCue_ItemizationOverHead>();
	}
};
static_assert(alignof(AOrionGameplayCue_ItemizationOverHead) == 0x000010, "Wrong alignment on AOrionGameplayCue_ItemizationOverHead");
static_assert(sizeof(AOrionGameplayCue_ItemizationOverHead) == 0x000970, "Wrong size on AOrionGameplayCue_ItemizationOverHead");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, CardRootComp) == 0x000840, "Member 'AOrionGameplayCue_ItemizationOverHead::CardRootComp' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, CardFrontMesh) == 0x000848, "Member 'AOrionGameplayCue_ItemizationOverHead::CardFrontMesh' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, CardFrontMaterial) == 0x000850, "Member 'AOrionGameplayCue_ItemizationOverHead::CardFrontMaterial' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, CardFrontDMI) == 0x000858, "Member 'AOrionGameplayCue_ItemizationOverHead::CardFrontDMI' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, CardBackMesh) == 0x000860, "Member 'AOrionGameplayCue_ItemizationOverHead::CardBackMesh' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, CardBackMaterial) == 0x000868, "Member 'AOrionGameplayCue_ItemizationOverHead::CardBackMaterial' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, CardBackDMI) == 0x000870, "Member 'AOrionGameplayCue_ItemizationOverHead::CardBackDMI' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, CardEquippedSequence) == 0x000878, "Member 'AOrionGameplayCue_ItemizationOverHead::CardEquippedSequence' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, CardStartActivationSequence) == 0x000880, "Member 'AOrionGameplayCue_ItemizationOverHead::CardStartActivationSequence' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, CardEndActivationSequence) == 0x000888, "Member 'AOrionGameplayCue_ItemizationOverHead::CardEndActivationSequence' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, CardConsumedSequence) == 0x000890, "Member 'AOrionGameplayCue_ItemizationOverHead::CardConsumedSequence' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, CardCombustedSequence) == 0x000898, "Member 'AOrionGameplayCue_ItemizationOverHead::CardCombustedSequence' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, RootGemComp) == 0x0008A0, "Member 'AOrionGameplayCue_ItemizationOverHead::RootGemComp' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, GemMesh) == 0x0008A8, "Member 'AOrionGameplayCue_ItemizationOverHead::GemMesh' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, GemMaterial) == 0x0008B0, "Member 'AOrionGameplayCue_ItemizationOverHead::GemMaterial' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, GemDMI) == 0x0008B8, "Member 'AOrionGameplayCue_ItemizationOverHead::GemDMI' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, GemEquippedSequence) == 0x0008C0, "Member 'AOrionGameplayCue_ItemizationOverHead::GemEquippedSequence' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, GemStartActivationSequence) == 0x0008C8, "Member 'AOrionGameplayCue_ItemizationOverHead::GemStartActivationSequence' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, GemEndActivationSequence) == 0x0008D0, "Member 'AOrionGameplayCue_ItemizationOverHead::GemEndActivationSequence' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, CardHeadZOffset) == 0x0008D8, "Member 'AOrionGameplayCue_ItemizationOverHead::CardHeadZOffset' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, MinTimeInIdle) == 0x0008DC, "Member 'AOrionGameplayCue_ItemizationOverHead::MinTimeInIdle' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, IdleTimeToAddOnRetrigger) == 0x0008E0, "Member 'AOrionGameplayCue_ItemizationOverHead::IdleTimeToAddOnRetrigger' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, StartConsumeEffectPct) == 0x0008E4, "Member 'AOrionGameplayCue_ItemizationOverHead::StartConsumeEffectPct' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, EndConsumeEffectPct) == 0x0008E8, "Member 'AOrionGameplayCue_ItemizationOverHead::EndConsumeEffectPct' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, TextureParamName) == 0x0008F0, "Member 'AOrionGameplayCue_ItemizationOverHead::TextureParamName' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, BorderParamName) == 0x0008F8, "Member 'AOrionGameplayCue_ItemizationOverHead::BorderParamName' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, UICardMatBorderParamName) == 0x000900, "Member 'AOrionGameplayCue_ItemizationOverHead::UICardMatBorderParamName' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, DiamondSwitchParamName) == 0x000908, "Member 'AOrionGameplayCue_ItemizationOverHead::DiamondSwitchParamName' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, ComsumtionEffectParamName) == 0x000910, "Member 'AOrionGameplayCue_ItemizationOverHead::ComsumtionEffectParamName' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, CombustionEffectParamName) == 0x000918, "Member 'AOrionGameplayCue_ItemizationOverHead::CombustionEffectParamName' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, bBoundToTarget) == 0x000920, "Member 'AOrionGameplayCue_ItemizationOverHead::bBoundToTarget' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, bHiddenByShadowplane) == 0x000921, "Member 'AOrionGameplayCue_ItemizationOverHead::bHiddenByShadowplane' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, CurrentBoundTarget) == 0x000928, "Member 'AOrionGameplayCue_ItemizationOverHead::CurrentBoundTarget' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, CurrentCard) == 0x000930, "Member 'AOrionGameplayCue_ItemizationOverHead::CurrentCard' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, CurrentCardEventExecuting) == 0x000938, "Member 'AOrionGameplayCue_ItemizationOverHead::CurrentCardEventExecuting' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, CardSequencerPlaying) == 0x000939, "Member 'AOrionGameplayCue_ItemizationOverHead::CardSequencerPlaying' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, CurrentGem) == 0x000958, "Member 'AOrionGameplayCue_ItemizationOverHead::CurrentGem' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, CurrentGemEventExecuting) == 0x000960, "Member 'AOrionGameplayCue_ItemizationOverHead::CurrentGemEventExecuting' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCue_ItemizationOverHead, GemSequencerPlaying) == 0x000961, "Member 'AOrionGameplayCue_ItemizationOverHead::GemSequencerPlaying' has a wrong offset!");

// Class OrionGame.OrionGameplayCueManager
// 0x0090 (0x0520 - 0x0490)
class UOrionGameplayCueManager final : public UGameplayCueManager
{
public:
	TArray<class FString>                         NeverLoadGCTags;                                   // 0x0490(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A0[0x58];                                     // 0x04A0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayCueNotifySubset>       GameplayCueNotifySubsets;                          // 0x04F8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_508[0x18];                                     // 0x0508(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameplayCueManager">();
	}
	static class UOrionGameplayCueManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionGameplayCueManager>();
	}
};
static_assert(alignof(UOrionGameplayCueManager) == 0x000010, "Wrong alignment on UOrionGameplayCueManager");
static_assert(sizeof(UOrionGameplayCueManager) == 0x000520, "Wrong size on UOrionGameplayCueManager");
static_assert(offsetof(UOrionGameplayCueManager, NeverLoadGCTags) == 0x000490, "Member 'UOrionGameplayCueManager::NeverLoadGCTags' has a wrong offset!");
static_assert(offsetof(UOrionGameplayCueManager, GameplayCueNotifySubsets) == 0x0004F8, "Member 'UOrionGameplayCueManager::GameplayCueNotifySubsets' has a wrong offset!");

// Class OrionGame.OrionMcpDeckItem
// 0x0098 (0x0110 - 0x0078)
class UOrionMcpDeckItem final : public UOrionMcpItem
{
public:
	class FText                                   Name_0;                                            // 0x0078(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FOrionAffinityStruct                   AffinityStruct;                                    // 0x0090(0x0004)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUserCreatedDeck                       Details;                                           // 0x0098(0x0048)(NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  CardBlockTags;                                     // 0x00E0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UOrionMcpCuratedDeckItemDefinition*     SourceCuratedDeckDefinition;                       // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpDeckItem">();
	}
	static class UOrionMcpDeckItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpDeckItem>();
	}
};
static_assert(alignof(UOrionMcpDeckItem) == 0x000008, "Wrong alignment on UOrionMcpDeckItem");
static_assert(sizeof(UOrionMcpDeckItem) == 0x000110, "Wrong size on UOrionMcpDeckItem");
static_assert(offsetof(UOrionMcpDeckItem, Name_0) == 0x000078, "Member 'UOrionMcpDeckItem::Name_0' has a wrong offset!");
static_assert(offsetof(UOrionMcpDeckItem, AffinityStruct) == 0x000090, "Member 'UOrionMcpDeckItem::AffinityStruct' has a wrong offset!");
static_assert(offsetof(UOrionMcpDeckItem, Details) == 0x000098, "Member 'UOrionMcpDeckItem::Details' has a wrong offset!");
static_assert(offsetof(UOrionMcpDeckItem, CardBlockTags) == 0x0000E0, "Member 'UOrionMcpDeckItem::CardBlockTags' has a wrong offset!");
static_assert(offsetof(UOrionMcpDeckItem, SourceCuratedDeckDefinition) == 0x000100, "Member 'UOrionMcpDeckItem::SourceCuratedDeckDefinition' has a wrong offset!");

// Class OrionGame.OrionGameplayCueNotify_Static
// 0x0010 (0x0090 - 0x0080)
#pragma pack(push, 0x1)
class alignas(0x10) UOrionGameplayCueNotify_Static : public UGameplayCueNotify_Static
{
public:
	struct FOrionGameplayCueSignificanceSettings  SignificanceSettings;                              // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameplayCueNotify_Static">();
	}
	static class UOrionGameplayCueNotify_Static* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionGameplayCueNotify_Static>();
	}
};
#pragma pack(pop)
static_assert(alignof(UOrionGameplayCueNotify_Static) == 0x000010, "Wrong alignment on UOrionGameplayCueNotify_Static");
static_assert(sizeof(UOrionGameplayCueNotify_Static) == 0x000090, "Wrong size on UOrionGameplayCueNotify_Static");
static_assert(offsetof(UOrionGameplayCueNotify_Static, SignificanceSettings) == 0x000080, "Member 'UOrionGameplayCueNotify_Static::SignificanceSettings' has a wrong offset!");

// Class OrionGame.OrionGameplayCueNotify_Burst
// 0x05B0 (0x0640 - 0x0090)
class UOrionGameplayCueNotify_Burst : public UOrionGameplayCueNotify_Static
{
public:
	struct FOrionBurstEffectData                  BurstEffectData_Default;                           // 0x0088(0x0140)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOrionBurstEffectData                  BurstEffectData_Stone;                             // 0x01C8(0x0140)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOrionBurstEffectData                  BurstEffectData_Grass;                             // 0x0308(0x0140)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FOrionBurstEffectData                  BurstEffectData_ShallowWater;                      // 0x0448(0x0140)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         bMovedEffectDataToStructFormat : 1;                // 0x0588(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_589[0x7];                                      // 0x0589(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayCueParticleInfo               BurstParticleEffect;                               // 0x0590(0x0040)(Deprecated, NativeAccessSpecifierPrivate)
	struct FGameplayCueAudioInfo                  BurstSound;                                        // 0x05D0(0x0018)(Deprecated, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGameplayCueCameraShakeInfo            BurstCameraShake;                                  // 0x05E8(0x0028)(Deprecated, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGameplayCueCameraLensEffectInfo       BurstCameraLensEffect;                             // 0x0610(0x0018)(Deprecated, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGameplayCueForceFeedbackInfo          BurstForceFeedbackEffect;                          // 0x0628(0x0018)(Deprecated, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void OnBurst(class AActor* MyTarget, const struct FGameplayCueParameters& Parameters, class UParticleSystemComponent* BurstParticleSystem, const TArray<class UParticleSystemComponent*>& AdditionalParticleSystems, class UCameraShake* BurstCameraShakeInstance, class ADecalActor* BurstDecalInstance, class UNiagaraComponent* BurstNiagaraParticleSystem, const TArray<class UNiagaraComponent*>& AdditionalNiagaraParticleSystems) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameplayCueNotify_Burst">();
	}
	static class UOrionGameplayCueNotify_Burst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionGameplayCueNotify_Burst>();
	}
};
static_assert(alignof(UOrionGameplayCueNotify_Burst) == 0x000010, "Wrong alignment on UOrionGameplayCueNotify_Burst");
static_assert(sizeof(UOrionGameplayCueNotify_Burst) == 0x000640, "Wrong size on UOrionGameplayCueNotify_Burst");
static_assert(offsetof(UOrionGameplayCueNotify_Burst, BurstEffectData_Default) == 0x000088, "Member 'UOrionGameplayCueNotify_Burst::BurstEffectData_Default' has a wrong offset!");
static_assert(offsetof(UOrionGameplayCueNotify_Burst, BurstEffectData_Stone) == 0x0001C8, "Member 'UOrionGameplayCueNotify_Burst::BurstEffectData_Stone' has a wrong offset!");
static_assert(offsetof(UOrionGameplayCueNotify_Burst, BurstEffectData_Grass) == 0x000308, "Member 'UOrionGameplayCueNotify_Burst::BurstEffectData_Grass' has a wrong offset!");
static_assert(offsetof(UOrionGameplayCueNotify_Burst, BurstEffectData_ShallowWater) == 0x000448, "Member 'UOrionGameplayCueNotify_Burst::BurstEffectData_ShallowWater' has a wrong offset!");
static_assert(offsetof(UOrionGameplayCueNotify_Burst, BurstParticleEffect) == 0x000590, "Member 'UOrionGameplayCueNotify_Burst::BurstParticleEffect' has a wrong offset!");
static_assert(offsetof(UOrionGameplayCueNotify_Burst, BurstSound) == 0x0005D0, "Member 'UOrionGameplayCueNotify_Burst::BurstSound' has a wrong offset!");
static_assert(offsetof(UOrionGameplayCueNotify_Burst, BurstCameraShake) == 0x0005E8, "Member 'UOrionGameplayCueNotify_Burst::BurstCameraShake' has a wrong offset!");
static_assert(offsetof(UOrionGameplayCueNotify_Burst, BurstCameraLensEffect) == 0x000610, "Member 'UOrionGameplayCueNotify_Burst::BurstCameraLensEffect' has a wrong offset!");
static_assert(offsetof(UOrionGameplayCueNotify_Burst, BurstForceFeedbackEffect) == 0x000628, "Member 'UOrionGameplayCueNotify_Burst::BurstForceFeedbackEffect' has a wrong offset!");

// Class OrionGame.OrionMcpGemItem
// 0x0018 (0x0090 - 0x0078)
class UOrionMcpGemItem final : public UOrionMcpItem
{
public:
	TArray<struct FGemAbilityPropertyLevels>      AllGemAbilityPropertyLevels;                       // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpGemItem">();
	}
	static class UOrionMcpGemItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpGemItem>();
	}
};
static_assert(alignof(UOrionMcpGemItem) == 0x000008, "Wrong alignment on UOrionMcpGemItem");
static_assert(sizeof(UOrionMcpGemItem) == 0x000090, "Wrong size on UOrionMcpGemItem");
static_assert(offsetof(UOrionMcpGemItem, AllGemAbilityPropertyLevels) == 0x000078, "Member 'UOrionMcpGemItem::AllGemAbilityPropertyLevels' has a wrong offset!");

// Class OrionGame.OrionHeroFallenAngelAnimInstance
// 0x0040 (0x1200 - 0x11C0)
class UOrionHeroFallenAngelAnimInstance final : public UOrionHeroAnimInstance
{
public:
	bool                                          bWingsOut;                                         // 0x11B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRMBJumpAnimSet;                                // 0x11B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11BA[0x6];                                     // 0x11BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionHeroJumpAnimSet                  RMBOverrideJumpAnimSet;                            // 0x11C0(0x0028)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         WingsDynamicsAlpha;                                // 0x11E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UltActiveAlpha;                                    // 0x11EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WingOverrideAlpha;                                 // 0x11F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11F4[0xC];                                     // 0x11F4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHeroFallenAngelAnimInstance">();
	}
	static class UOrionHeroFallenAngelAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHeroFallenAngelAnimInstance>();
	}
};
static_assert(alignof(UOrionHeroFallenAngelAnimInstance) == 0x000010, "Wrong alignment on UOrionHeroFallenAngelAnimInstance");
static_assert(sizeof(UOrionHeroFallenAngelAnimInstance) == 0x001200, "Wrong size on UOrionHeroFallenAngelAnimInstance");
static_assert(offsetof(UOrionHeroFallenAngelAnimInstance, bWingsOut) == 0x0011B8, "Member 'UOrionHeroFallenAngelAnimInstance::bWingsOut' has a wrong offset!");
static_assert(offsetof(UOrionHeroFallenAngelAnimInstance, bUseRMBJumpAnimSet) == 0x0011B9, "Member 'UOrionHeroFallenAngelAnimInstance::bUseRMBJumpAnimSet' has a wrong offset!");
static_assert(offsetof(UOrionHeroFallenAngelAnimInstance, RMBOverrideJumpAnimSet) == 0x0011C0, "Member 'UOrionHeroFallenAngelAnimInstance::RMBOverrideJumpAnimSet' has a wrong offset!");
static_assert(offsetof(UOrionHeroFallenAngelAnimInstance, WingsDynamicsAlpha) == 0x0011E8, "Member 'UOrionHeroFallenAngelAnimInstance::WingsDynamicsAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroFallenAngelAnimInstance, UltActiveAlpha) == 0x0011EC, "Member 'UOrionHeroFallenAngelAnimInstance::UltActiveAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroFallenAngelAnimInstance, WingOverrideAlpha) == 0x0011F0, "Member 'UOrionHeroFallenAngelAnimInstance::WingOverrideAlpha' has a wrong offset!");

// Class OrionGame.OrionGameplayCueNotify_ObjectiveWarningRing
// 0x0000 (0x03D0 - 0x03D0)
class AOrionGameplayCueNotify_ObjectiveWarningRing : public AOrionGameplayCueNotify_Actor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameplayCueNotify_ObjectiveWarningRing">();
	}
	static class AOrionGameplayCueNotify_ObjectiveWarningRing* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionGameplayCueNotify_ObjectiveWarningRing>();
	}
};
static_assert(alignof(AOrionGameplayCueNotify_ObjectiveWarningRing) == 0x000010, "Wrong alignment on AOrionGameplayCueNotify_ObjectiveWarningRing");
static_assert(sizeof(AOrionGameplayCueNotify_ObjectiveWarningRing) == 0x0003D0, "Wrong size on AOrionGameplayCueNotify_ObjectiveWarningRing");

// Class OrionGame.OrionGameplayCueNotify_StandardAttachedSoundAndFX
// 0x0030 (0x0400 - 0x03D0)
class AOrionGameplayCueNotify_StandardAttachedSoundAndFX : public AOrionGameplayCueNotify_Actor
{
public:
	class FName                                   OrionChar_Mesh_SocketName;                         // 0x03C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AudioLoopFadeOutDuration;                          // 0x03D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AudioLoopFadeVolumeLevel;                          // 0x03D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              Audio_OnActive_Loop;                               // 0x03D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        PS_OnActive;                                       // 0x03E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPS_OnActive_Reset;                                // 0x03E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E9[0x7];                                      // 0x03E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystemComponent*               PS_Start;                                          // 0x03F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAudioComponent*                        Audio_Start;                                       // 0x03F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameplayCueNotify_StandardAttachedSoundAndFX">();
	}
	static class AOrionGameplayCueNotify_StandardAttachedSoundAndFX* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionGameplayCueNotify_StandardAttachedSoundAndFX>();
	}
};
static_assert(alignof(AOrionGameplayCueNotify_StandardAttachedSoundAndFX) == 0x000010, "Wrong alignment on AOrionGameplayCueNotify_StandardAttachedSoundAndFX");
static_assert(sizeof(AOrionGameplayCueNotify_StandardAttachedSoundAndFX) == 0x000400, "Wrong size on AOrionGameplayCueNotify_StandardAttachedSoundAndFX");
static_assert(offsetof(AOrionGameplayCueNotify_StandardAttachedSoundAndFX, OrionChar_Mesh_SocketName) == 0x0003C8, "Member 'AOrionGameplayCueNotify_StandardAttachedSoundAndFX::OrionChar_Mesh_SocketName' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_StandardAttachedSoundAndFX, AudioLoopFadeOutDuration) == 0x0003D0, "Member 'AOrionGameplayCueNotify_StandardAttachedSoundAndFX::AudioLoopFadeOutDuration' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_StandardAttachedSoundAndFX, AudioLoopFadeVolumeLevel) == 0x0003D4, "Member 'AOrionGameplayCueNotify_StandardAttachedSoundAndFX::AudioLoopFadeVolumeLevel' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_StandardAttachedSoundAndFX, Audio_OnActive_Loop) == 0x0003D8, "Member 'AOrionGameplayCueNotify_StandardAttachedSoundAndFX::Audio_OnActive_Loop' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_StandardAttachedSoundAndFX, PS_OnActive) == 0x0003E0, "Member 'AOrionGameplayCueNotify_StandardAttachedSoundAndFX::PS_OnActive' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_StandardAttachedSoundAndFX, bPS_OnActive_Reset) == 0x0003E8, "Member 'AOrionGameplayCueNotify_StandardAttachedSoundAndFX::bPS_OnActive_Reset' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_StandardAttachedSoundAndFX, PS_Start) == 0x0003F0, "Member 'AOrionGameplayCueNotify_StandardAttachedSoundAndFX::PS_Start' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_StandardAttachedSoundAndFX, Audio_Start) == 0x0003F8, "Member 'AOrionGameplayCueNotify_StandardAttachedSoundAndFX::Audio_Start' has a wrong offset!");

// Class OrionGame.OrionMcpGiftBoxItemDefinition
// 0x0008 (0x0270 - 0x0268)
class UOrionMcpGiftBoxItemDefinition final : public UOrionMcpItemDefinition
{
public:
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpGiftBoxItemDefinition">();
	}
	static class UOrionMcpGiftBoxItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpGiftBoxItemDefinition>();
	}
};
static_assert(alignof(UOrionMcpGiftBoxItemDefinition) == 0x000008, "Wrong alignment on UOrionMcpGiftBoxItemDefinition");
static_assert(sizeof(UOrionMcpGiftBoxItemDefinition) == 0x000270, "Wrong size on UOrionMcpGiftBoxItemDefinition");

// Class OrionGame.OrionGameplayCueNotify_StandardAttachedMultiSoundAndFX
// 0x0020 (0x0420 - 0x0400)
class AOrionGameplayCueNotify_StandardAttachedMultiSoundAndFX final : public AOrionGameplayCueNotify_StandardAttachedSoundAndFX
{
public:
	class USoundBase*                             Audio_OnRemove;                                    // 0x0400(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        PS_OnRemove;                                       // 0x0408(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               PS_End;                                            // 0x0410(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAudioComponent*                        Audio_End;                                         // 0x0418(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameplayCueNotify_StandardAttachedMultiSoundAndFX">();
	}
	static class AOrionGameplayCueNotify_StandardAttachedMultiSoundAndFX* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionGameplayCueNotify_StandardAttachedMultiSoundAndFX>();
	}
};
static_assert(alignof(AOrionGameplayCueNotify_StandardAttachedMultiSoundAndFX) == 0x000010, "Wrong alignment on AOrionGameplayCueNotify_StandardAttachedMultiSoundAndFX");
static_assert(sizeof(AOrionGameplayCueNotify_StandardAttachedMultiSoundAndFX) == 0x000420, "Wrong size on AOrionGameplayCueNotify_StandardAttachedMultiSoundAndFX");
static_assert(offsetof(AOrionGameplayCueNotify_StandardAttachedMultiSoundAndFX, Audio_OnRemove) == 0x000400, "Member 'AOrionGameplayCueNotify_StandardAttachedMultiSoundAndFX::Audio_OnRemove' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_StandardAttachedMultiSoundAndFX, PS_OnRemove) == 0x000408, "Member 'AOrionGameplayCueNotify_StandardAttachedMultiSoundAndFX::PS_OnRemove' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_StandardAttachedMultiSoundAndFX, PS_End) == 0x000410, "Member 'AOrionGameplayCueNotify_StandardAttachedMultiSoundAndFX::PS_End' has a wrong offset!");
static_assert(offsetof(AOrionGameplayCueNotify_StandardAttachedMultiSoundAndFX, Audio_End) == 0x000418, "Member 'AOrionGameplayCueNotify_StandardAttachedMultiSoundAndFX::Audio_End' has a wrong offset!");

// Class OrionGame.OrionGameplayCueTranslator_Hero
// 0x0000 (0x0028 - 0x0028)
class UOrionGameplayCueTranslator_Hero final : public UGameplayCueTranslator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameplayCueTranslator_Hero">();
	}
	static class UOrionGameplayCueTranslator_Hero* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionGameplayCueTranslator_Hero>();
	}
};
static_assert(alignof(UOrionGameplayCueTranslator_Hero) == 0x000008, "Wrong alignment on UOrionGameplayCueTranslator_Hero");
static_assert(sizeof(UOrionGameplayCueTranslator_Hero) == 0x000028, "Wrong size on UOrionGameplayCueTranslator_Hero");

// Class OrionGame.OrionSimpleMcpItemDefinition
// 0x0018 (0x0280 - 0x0268)
class UOrionSimpleMcpItemDefinition final : public UOrionMcpItemDefinition
{
public:
	bool                                          bManuallyDefinedJson;                              // 0x0268(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_269[0x7];                                      // 0x0269(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TemplateId;                                        // 0x0270(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionSimpleMcpItemDefinition">();
	}
	static class UOrionSimpleMcpItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionSimpleMcpItemDefinition>();
	}
};
static_assert(alignof(UOrionSimpleMcpItemDefinition) == 0x000008, "Wrong alignment on UOrionSimpleMcpItemDefinition");
static_assert(sizeof(UOrionSimpleMcpItemDefinition) == 0x000280, "Wrong size on UOrionSimpleMcpItemDefinition");
static_assert(offsetof(UOrionSimpleMcpItemDefinition, bManuallyDefinedJson) == 0x000268, "Member 'UOrionSimpleMcpItemDefinition::bManuallyDefinedJson' has a wrong offset!");
static_assert(offsetof(UOrionSimpleMcpItemDefinition, TemplateId) == 0x000270, "Member 'UOrionSimpleMcpItemDefinition::TemplateId' has a wrong offset!");

// Class OrionGame.OrionGameplayCueTranslator_Skins
// 0x0000 (0x0028 - 0x0028)
class UOrionGameplayCueTranslator_Skins final : public UGameplayCueTranslator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameplayCueTranslator_Skins">();
	}
	static class UOrionGameplayCueTranslator_Skins* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionGameplayCueTranslator_Skins>();
	}
};
static_assert(alignof(UOrionGameplayCueTranslator_Skins) == 0x000008, "Wrong alignment on UOrionGameplayCueTranslator_Skins");
static_assert(sizeof(UOrionGameplayCueTranslator_Skins) == 0x000028, "Wrong size on UOrionGameplayCueTranslator_Skins");

// Class OrionGame.OrionGameplayGem
// 0x0020 (0x01D0 - 0x01B0)
class UOrionGameplayGem final : public UOrionGameplayItem
{
public:
	TArray<struct FGemAbilityPropertyLevels>      AllGemAbilityLevels;                               // 0x01B0(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         GemDisplayLevel;                                   // 0x01C0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C4[0xC];                                      // 0x01C4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameplayGem">();
	}
	static class UOrionGameplayGem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionGameplayGem>();
	}
};
static_assert(alignof(UOrionGameplayGem) == 0x000008, "Wrong alignment on UOrionGameplayGem");
static_assert(sizeof(UOrionGameplayGem) == 0x0001D0, "Wrong size on UOrionGameplayGem");
static_assert(offsetof(UOrionGameplayGem, AllGemAbilityLevels) == 0x0001B0, "Member 'UOrionGameplayGem::AllGemAbilityLevels' has a wrong offset!");
static_assert(offsetof(UOrionGameplayGem, GemDisplayLevel) == 0x0001C0, "Member 'UOrionGameplayGem::GemDisplayLevel' has a wrong offset!");

// Class OrionGame.OrionMcpBannerItemDefinition
// 0x0108 (0x0370 - 0x0268)
class UOrionMcpBannerItemDefinition final : public UOrionMcpItemDefinition
{
public:
	EOrionBannerType                              BannerType;                                        // 0x0268(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_269[0x7];                                      // 0x0269(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UStaticMesh>             StaticMesh;                                        // 0x0270(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBannerSocketEntry>             Sockets;                                           // 0x0298(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              FXSound;                                           // 0x02A8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      FXMaterial;                                        // 0x02D0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DecalSize;                                         // 0x02F8(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UParticleSystem>         FXParticle;                                        // 0x0308(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachToParent;                                   // 0x0330(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_331[0x7];                                      // 0x0331(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            StaticMeshLoaded;                                  // 0x0338(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FString>                         DefaultAlterationLootTables;                       // 0x0340(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class USoundBase*                             FXSoundLoaded;                                     // 0x0350(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     FXMaterialLoaded;                                  // 0x0358(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        FXParticleLoaded;                                  // 0x0360(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_368[0x8];                                      // 0x0368(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetAttachToParent() const;
	const EOrionBannerType GetBannerType() const;
	const struct FVector GetDecalSize() const;
	class UMaterialInterface* GetFXMaterial() const;
	class UParticleSystem* GetFXParticle() const;
	class USoundBase* GetFXSound() const;
	const TArray<struct FBannerSocketEntry> GetSockets() const;
	class UStaticMesh* GetStaticMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpBannerItemDefinition">();
	}
	static class UOrionMcpBannerItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpBannerItemDefinition>();
	}
};
static_assert(alignof(UOrionMcpBannerItemDefinition) == 0x000008, "Wrong alignment on UOrionMcpBannerItemDefinition");
static_assert(sizeof(UOrionMcpBannerItemDefinition) == 0x000370, "Wrong size on UOrionMcpBannerItemDefinition");
static_assert(offsetof(UOrionMcpBannerItemDefinition, BannerType) == 0x000268, "Member 'UOrionMcpBannerItemDefinition::BannerType' has a wrong offset!");
static_assert(offsetof(UOrionMcpBannerItemDefinition, StaticMesh) == 0x000270, "Member 'UOrionMcpBannerItemDefinition::StaticMesh' has a wrong offset!");
static_assert(offsetof(UOrionMcpBannerItemDefinition, Sockets) == 0x000298, "Member 'UOrionMcpBannerItemDefinition::Sockets' has a wrong offset!");
static_assert(offsetof(UOrionMcpBannerItemDefinition, FXSound) == 0x0002A8, "Member 'UOrionMcpBannerItemDefinition::FXSound' has a wrong offset!");
static_assert(offsetof(UOrionMcpBannerItemDefinition, FXMaterial) == 0x0002D0, "Member 'UOrionMcpBannerItemDefinition::FXMaterial' has a wrong offset!");
static_assert(offsetof(UOrionMcpBannerItemDefinition, DecalSize) == 0x0002F8, "Member 'UOrionMcpBannerItemDefinition::DecalSize' has a wrong offset!");
static_assert(offsetof(UOrionMcpBannerItemDefinition, FXParticle) == 0x000308, "Member 'UOrionMcpBannerItemDefinition::FXParticle' has a wrong offset!");
static_assert(offsetof(UOrionMcpBannerItemDefinition, bAttachToParent) == 0x000330, "Member 'UOrionMcpBannerItemDefinition::bAttachToParent' has a wrong offset!");
static_assert(offsetof(UOrionMcpBannerItemDefinition, StaticMeshLoaded) == 0x000338, "Member 'UOrionMcpBannerItemDefinition::StaticMeshLoaded' has a wrong offset!");
static_assert(offsetof(UOrionMcpBannerItemDefinition, DefaultAlterationLootTables) == 0x000340, "Member 'UOrionMcpBannerItemDefinition::DefaultAlterationLootTables' has a wrong offset!");
static_assert(offsetof(UOrionMcpBannerItemDefinition, FXSoundLoaded) == 0x000350, "Member 'UOrionMcpBannerItemDefinition::FXSoundLoaded' has a wrong offset!");
static_assert(offsetof(UOrionMcpBannerItemDefinition, FXMaterialLoaded) == 0x000358, "Member 'UOrionMcpBannerItemDefinition::FXMaterialLoaded' has a wrong offset!");
static_assert(offsetof(UOrionMcpBannerItemDefinition, FXParticleLoaded) == 0x000360, "Member 'UOrionMcpBannerItemDefinition::FXParticleLoaded' has a wrong offset!");

// Class OrionGame.OrionGameplaySet
// 0x0020 (0x0050 - 0x0030)
class UOrionGameplaySet final : public UOrionAttributeSet
{
public:
	float                                         IntellectPips;                                     // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ReservedIntellectPips;                             // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         VitalityPips;                                      // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ReservedVitalityPips;                              // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DexterityPips;                                     // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ReservedDexterityPips;                             // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TotalPips;                                         // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TotalReservedPips;                                 // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_DexterityPips();
	void OnRep_IntellectPips();
	void OnRep_ReservedDexterityPips();
	void OnRep_ReservedIntellectPips();
	void OnRep_ReservedVitalityPips();
	void OnRep_VitalityPips();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameplaySet">();
	}
	static class UOrionGameplaySet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionGameplaySet>();
	}
};
static_assert(alignof(UOrionGameplaySet) == 0x000008, "Wrong alignment on UOrionGameplaySet");
static_assert(sizeof(UOrionGameplaySet) == 0x000050, "Wrong size on UOrionGameplaySet");
static_assert(offsetof(UOrionGameplaySet, IntellectPips) == 0x000030, "Member 'UOrionGameplaySet::IntellectPips' has a wrong offset!");
static_assert(offsetof(UOrionGameplaySet, ReservedIntellectPips) == 0x000034, "Member 'UOrionGameplaySet::ReservedIntellectPips' has a wrong offset!");
static_assert(offsetof(UOrionGameplaySet, VitalityPips) == 0x000038, "Member 'UOrionGameplaySet::VitalityPips' has a wrong offset!");
static_assert(offsetof(UOrionGameplaySet, ReservedVitalityPips) == 0x00003C, "Member 'UOrionGameplaySet::ReservedVitalityPips' has a wrong offset!");
static_assert(offsetof(UOrionGameplaySet, DexterityPips) == 0x000040, "Member 'UOrionGameplaySet::DexterityPips' has a wrong offset!");
static_assert(offsetof(UOrionGameplaySet, ReservedDexterityPips) == 0x000044, "Member 'UOrionGameplaySet::ReservedDexterityPips' has a wrong offset!");
static_assert(offsetof(UOrionGameplaySet, TotalPips) == 0x000048, "Member 'UOrionGameplaySet::TotalPips' has a wrong offset!");
static_assert(offsetof(UOrionGameplaySet, TotalReservedPips) == 0x00004C, "Member 'UOrionGameplaySet::TotalReservedPips' has a wrong offset!");

// Class OrionGame.BlueprintGameplayStatsLibrary
// 0x0000 (0x0028 - 0x0028)
class UBlueprintGameplayStatsLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool EqualEqual_GameplayStatTagGameplayStatTag(const struct FGameplayStatTag& A, const struct FGameplayStatTag& B);
	static bool NotEqual_GameplayStatTagGameplayStatTag(const struct FGameplayStatTag& A, const struct FGameplayStatTag& B);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlueprintGameplayStatsLibrary">();
	}
	static class UBlueprintGameplayStatsLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlueprintGameplayStatsLibrary>();
	}
};
static_assert(alignof(UBlueprintGameplayStatsLibrary) == 0x000008, "Wrong alignment on UBlueprintGameplayStatsLibrary");
static_assert(sizeof(UBlueprintGameplayStatsLibrary) == 0x000028, "Wrong size on UBlueprintGameplayStatsLibrary");

// Class OrionGame.OrionHyperBreachAnimInstance
// 0x00E0 (0x0850 - 0x0770)
class UOrionHyperBreachAnimInstance final : public UOrionBaseHeroAnimInstance
{
public:
	class UAnimMontage*                           DetChargeMontage;                                  // 0x0770(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DetChargeAdditiveAlpha;                            // 0x0778(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TravelModeCastingAdditiveAlpha;                    // 0x077C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CannonScaleAlpha;                                  // 0x0780(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDetChargeCooling;                                 // 0x0784(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDetChargeFired;                                   // 0x0785(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDetChargeActive;                                  // 0x0786(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotDetChargeActiveAndDetChargeCooling;            // 0x0787(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMovingInTravelMode;                               // 0x0788(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotMovingInTravelMode;                            // 0x0789(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78A[0x2];                                      // 0x078A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RootBoneRotationYaw;                               // 0x078C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DomeOpenAlpha;                                     // 0x0790(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeWarpingAlpha;                                 // 0x0794(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedAnimAssetPlayerData             DetChargeCooldownEndPlayer;                        // 0x0798(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedAnimRelevancyData               BaseIdleTurnInPlacePlayer;                         // 0x07B0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedAnimTransitionData              BaseIdleTurnInPlaceToIdleTransition;               // 0x07D0(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedAnimRelevancyData               LocomotionJumpPlayer;                              // 0x07F8(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedAnimTransitionData              LocomotionJumpToFallTransition;                    // 0x0818(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bTransition_DetChargeCooldown_Ready_To_Cooldown;   // 0x0840(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_DetChargeCooldown_Cooldown_To_CooldownEnd; // 0x0841(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_DetChargeCooldown_CooldownEnd_To_Ready; // 0x0842(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_Locomotion_TravelMode_To_JogRun;       // 0x0843(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_Locomotion_Jump_To_Fall;               // 0x0844(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_Locomotion_IdlesAndTurns_To_Fall;      // 0x0845(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_846[0xA];                                      // 0x0846(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHyperBreachAnimInstance">();
	}
	static class UOrionHyperBreachAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHyperBreachAnimInstance>();
	}
};
static_assert(alignof(UOrionHyperBreachAnimInstance) == 0x000008, "Wrong alignment on UOrionHyperBreachAnimInstance");
static_assert(sizeof(UOrionHyperBreachAnimInstance) == 0x000850, "Wrong size on UOrionHyperBreachAnimInstance");
static_assert(offsetof(UOrionHyperBreachAnimInstance, DetChargeMontage) == 0x000770, "Member 'UOrionHyperBreachAnimInstance::DetChargeMontage' has a wrong offset!");
static_assert(offsetof(UOrionHyperBreachAnimInstance, DetChargeAdditiveAlpha) == 0x000778, "Member 'UOrionHyperBreachAnimInstance::DetChargeAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHyperBreachAnimInstance, TravelModeCastingAdditiveAlpha) == 0x00077C, "Member 'UOrionHyperBreachAnimInstance::TravelModeCastingAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHyperBreachAnimInstance, CannonScaleAlpha) == 0x000780, "Member 'UOrionHyperBreachAnimInstance::CannonScaleAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHyperBreachAnimInstance, bDetChargeCooling) == 0x000784, "Member 'UOrionHyperBreachAnimInstance::bDetChargeCooling' has a wrong offset!");
static_assert(offsetof(UOrionHyperBreachAnimInstance, bDetChargeFired) == 0x000785, "Member 'UOrionHyperBreachAnimInstance::bDetChargeFired' has a wrong offset!");
static_assert(offsetof(UOrionHyperBreachAnimInstance, bDetChargeActive) == 0x000786, "Member 'UOrionHyperBreachAnimInstance::bDetChargeActive' has a wrong offset!");
static_assert(offsetof(UOrionHyperBreachAnimInstance, bNotDetChargeActiveAndDetChargeCooling) == 0x000787, "Member 'UOrionHyperBreachAnimInstance::bNotDetChargeActiveAndDetChargeCooling' has a wrong offset!");
static_assert(offsetof(UOrionHyperBreachAnimInstance, bMovingInTravelMode) == 0x000788, "Member 'UOrionHyperBreachAnimInstance::bMovingInTravelMode' has a wrong offset!");
static_assert(offsetof(UOrionHyperBreachAnimInstance, bNotMovingInTravelMode) == 0x000789, "Member 'UOrionHyperBreachAnimInstance::bNotMovingInTravelMode' has a wrong offset!");
static_assert(offsetof(UOrionHyperBreachAnimInstance, RootBoneRotationYaw) == 0x00078C, "Member 'UOrionHyperBreachAnimInstance::RootBoneRotationYaw' has a wrong offset!");
static_assert(offsetof(UOrionHyperBreachAnimInstance, DomeOpenAlpha) == 0x000790, "Member 'UOrionHyperBreachAnimInstance::DomeOpenAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHyperBreachAnimInstance, SlopeWarpingAlpha) == 0x000794, "Member 'UOrionHyperBreachAnimInstance::SlopeWarpingAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHyperBreachAnimInstance, DetChargeCooldownEndPlayer) == 0x000798, "Member 'UOrionHyperBreachAnimInstance::DetChargeCooldownEndPlayer' has a wrong offset!");
static_assert(offsetof(UOrionHyperBreachAnimInstance, BaseIdleTurnInPlacePlayer) == 0x0007B0, "Member 'UOrionHyperBreachAnimInstance::BaseIdleTurnInPlacePlayer' has a wrong offset!");
static_assert(offsetof(UOrionHyperBreachAnimInstance, BaseIdleTurnInPlaceToIdleTransition) == 0x0007D0, "Member 'UOrionHyperBreachAnimInstance::BaseIdleTurnInPlaceToIdleTransition' has a wrong offset!");
static_assert(offsetof(UOrionHyperBreachAnimInstance, LocomotionJumpPlayer) == 0x0007F8, "Member 'UOrionHyperBreachAnimInstance::LocomotionJumpPlayer' has a wrong offset!");
static_assert(offsetof(UOrionHyperBreachAnimInstance, LocomotionJumpToFallTransition) == 0x000818, "Member 'UOrionHyperBreachAnimInstance::LocomotionJumpToFallTransition' has a wrong offset!");
static_assert(offsetof(UOrionHyperBreachAnimInstance, bTransition_DetChargeCooldown_Ready_To_Cooldown) == 0x000840, "Member 'UOrionHyperBreachAnimInstance::bTransition_DetChargeCooldown_Ready_To_Cooldown' has a wrong offset!");
static_assert(offsetof(UOrionHyperBreachAnimInstance, bTransition_DetChargeCooldown_Cooldown_To_CooldownEnd) == 0x000841, "Member 'UOrionHyperBreachAnimInstance::bTransition_DetChargeCooldown_Cooldown_To_CooldownEnd' has a wrong offset!");
static_assert(offsetof(UOrionHyperBreachAnimInstance, bTransition_DetChargeCooldown_CooldownEnd_To_Ready) == 0x000842, "Member 'UOrionHyperBreachAnimInstance::bTransition_DetChargeCooldown_CooldownEnd_To_Ready' has a wrong offset!");
static_assert(offsetof(UOrionHyperBreachAnimInstance, bTransition_Locomotion_TravelMode_To_JogRun) == 0x000843, "Member 'UOrionHyperBreachAnimInstance::bTransition_Locomotion_TravelMode_To_JogRun' has a wrong offset!");
static_assert(offsetof(UOrionHyperBreachAnimInstance, bTransition_Locomotion_Jump_To_Fall) == 0x000844, "Member 'UOrionHyperBreachAnimInstance::bTransition_Locomotion_Jump_To_Fall' has a wrong offset!");
static_assert(offsetof(UOrionHyperBreachAnimInstance, bTransition_Locomotion_IdlesAndTurns_To_Fall) == 0x000845, "Member 'UOrionHyperBreachAnimInstance::bTransition_Locomotion_IdlesAndTurns_To_Fall' has a wrong offset!");

// Class OrionGame.GameplayStatsManager
// 0x0010 (0x0040 - 0x0030)
class UGameplayStatsManager final : public UDataAsset
{
public:
	class UDataTable*                             GameplayStatsTable;                                // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             LegacySource;                                      // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayStatsManager">();
	}
	static class UGameplayStatsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayStatsManager>();
	}
};
static_assert(alignof(UGameplayStatsManager) == 0x000008, "Wrong alignment on UGameplayStatsManager");
static_assert(sizeof(UGameplayStatsManager) == 0x000040, "Wrong size on UGameplayStatsManager");
static_assert(offsetof(UGameplayStatsManager, GameplayStatsTable) == 0x000030, "Member 'UGameplayStatsManager::GameplayStatsTable' has a wrong offset!");
static_assert(offsetof(UGameplayStatsManager, LegacySource) == 0x000038, "Member 'UGameplayStatsManager::LegacySource' has a wrong offset!");

// Class OrionGame.OrionMcpGemKeywordBucketItemDefinition
// 0x0018 (0x0280 - 0x0268)
class UOrionMcpGemKeywordBucketItemDefinition final : public UOrionMcpItemDefinition
{
public:
	TArray<struct FKeywordBucketEntry>            BucketEntries;                                     // 0x0268(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpGemKeywordBucketItemDefinition">();
	}
	static class UOrionMcpGemKeywordBucketItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpGemKeywordBucketItemDefinition>();
	}
};
static_assert(alignof(UOrionMcpGemKeywordBucketItemDefinition) == 0x000008, "Wrong alignment on UOrionMcpGemKeywordBucketItemDefinition");
static_assert(sizeof(UOrionMcpGemKeywordBucketItemDefinition) == 0x000280, "Wrong size on UOrionMcpGemKeywordBucketItemDefinition");
static_assert(offsetof(UOrionMcpGemKeywordBucketItemDefinition, BucketEntries) == 0x000268, "Member 'UOrionMcpGemKeywordBucketItemDefinition::BucketEntries' has a wrong offset!");

// Class OrionGame.OrionGameplayVolume
// 0x0108 (0x04F0 - 0x03E8)
class AOrionGameplayVolume : public AOrionBaseActor
{
public:
	TWeakObjectPtr<class AOrionDamageableObjective_Base> DefaultSourceActor;                                // 0x03E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionFilterAndEffectsContainer        FilterAndEffectsContainers;                        // 0x03F0(0x0020)(Edit, BlueprintVisible, ExposeOnSpawn, NativeAccessSpecifierPublic)
	struct FOrionFilterAndEffectsContainer        PersistentFilterAndEffectsContainers;              // 0x0410(0x0020)(Edit, BlueprintVisible, ExposeOnSpawn, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0430(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Net, IsPlainOldData, RepNotify, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43C[0x4];                                      // 0x043C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AVolume*>                        LinkedVolumes;                                     // 0x0440(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, ExposeOnSpawn, NativeAccessSpecifierPublic)
	bool                                          bEffectRemainsAfterLeavingVolume;                  // 0x0450(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEffectsHandledManually;                           // 0x0451(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReapplyOnRemoval;                                 // 0x0452(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnablePrdictiveClientcollision;                   // 0x0453(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyEverApplyOnce;                                // 0x0454(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_455[0x3];                                      // 0x0455(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumTargetsToApplyEffectsTo;                        // 0x0458(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumGameplayEffectsApplied;                         // 0x045C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            CooldownEffectToApply;                             // 0x0460(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_468[0x88];                                     // 0x0468(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyEffects();
	bool CanStillApplyEffectsToTargets();
	int32 GetNumAppliedEffectsLeftToApply();
	void HandleMatchStarted();
	void K2_OnBeginOverlapCallback(class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void K2_OnEndOverlapCallback(class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnBeginOverlapCallback(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlapCallback(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnRep_Scale();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameplayVolume">();
	}
	static class AOrionGameplayVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionGameplayVolume>();
	}
};
static_assert(alignof(AOrionGameplayVolume) == 0x000008, "Wrong alignment on AOrionGameplayVolume");
static_assert(sizeof(AOrionGameplayVolume) == 0x0004F0, "Wrong size on AOrionGameplayVolume");
static_assert(offsetof(AOrionGameplayVolume, DefaultSourceActor) == 0x0003E8, "Member 'AOrionGameplayVolume::DefaultSourceActor' has a wrong offset!");
static_assert(offsetof(AOrionGameplayVolume, FilterAndEffectsContainers) == 0x0003F0, "Member 'AOrionGameplayVolume::FilterAndEffectsContainers' has a wrong offset!");
static_assert(offsetof(AOrionGameplayVolume, PersistentFilterAndEffectsContainers) == 0x000410, "Member 'AOrionGameplayVolume::PersistentFilterAndEffectsContainers' has a wrong offset!");
static_assert(offsetof(AOrionGameplayVolume, Scale) == 0x000430, "Member 'AOrionGameplayVolume::Scale' has a wrong offset!");
static_assert(offsetof(AOrionGameplayVolume, LinkedVolumes) == 0x000440, "Member 'AOrionGameplayVolume::LinkedVolumes' has a wrong offset!");
static_assert(offsetof(AOrionGameplayVolume, bEffectRemainsAfterLeavingVolume) == 0x000450, "Member 'AOrionGameplayVolume::bEffectRemainsAfterLeavingVolume' has a wrong offset!");
static_assert(offsetof(AOrionGameplayVolume, bEffectsHandledManually) == 0x000451, "Member 'AOrionGameplayVolume::bEffectsHandledManually' has a wrong offset!");
static_assert(offsetof(AOrionGameplayVolume, bReapplyOnRemoval) == 0x000452, "Member 'AOrionGameplayVolume::bReapplyOnRemoval' has a wrong offset!");
static_assert(offsetof(AOrionGameplayVolume, bEnablePrdictiveClientcollision) == 0x000453, "Member 'AOrionGameplayVolume::bEnablePrdictiveClientcollision' has a wrong offset!");
static_assert(offsetof(AOrionGameplayVolume, bOnlyEverApplyOnce) == 0x000454, "Member 'AOrionGameplayVolume::bOnlyEverApplyOnce' has a wrong offset!");
static_assert(offsetof(AOrionGameplayVolume, NumTargetsToApplyEffectsTo) == 0x000458, "Member 'AOrionGameplayVolume::NumTargetsToApplyEffectsTo' has a wrong offset!");
static_assert(offsetof(AOrionGameplayVolume, NumGameplayEffectsApplied) == 0x00045C, "Member 'AOrionGameplayVolume::NumGameplayEffectsApplied' has a wrong offset!");
static_assert(offsetof(AOrionGameplayVolume, CooldownEffectToApply) == 0x000460, "Member 'AOrionGameplayVolume::CooldownEffectToApply' has a wrong offset!");

// Class OrionGame.OrionGameResults
// 0x00A0 (0x00C8 - 0x0028)
class UOrionGameResults final : public UObject
{
public:
	struct FOrionScoreboardUIInfo                 ScoreboardInfo;                                    // 0x0028(0x0088)(Protected, NativeAccessSpecifierProtected)
	class UOrionHeroData*                         PlayerHeroData;                                    // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameResults">();
	}
	static class UOrionGameResults* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionGameResults>();
	}
};
static_assert(alignof(UOrionGameResults) == 0x000008, "Wrong alignment on UOrionGameResults");
static_assert(sizeof(UOrionGameResults) == 0x0000C8, "Wrong size on UOrionGameResults");
static_assert(offsetof(UOrionGameResults, ScoreboardInfo) == 0x000028, "Member 'UOrionGameResults::ScoreboardInfo' has a wrong offset!");
static_assert(offsetof(UOrionGameResults, PlayerHeroData) == 0x0000B0, "Member 'UOrionGameResults::PlayerHeroData' has a wrong offset!");

// Class OrionGame.OrionInputVisualizer
// 0x0048 (0x0140 - 0x00F8)
class UOrionInputVisualizer final : public UWidget
{
public:
	EOrionWidgetStyleSize                         StyleSize;                                         // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ActionName;                                        // 0x0100(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   AxisName;                                          // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FKey                                   SpecificKey;                                       // 0x0110(0x0018)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShowKeyBorder;                                    // 0x0128(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPreferSecondaryIcon;                              // 0x0129(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12A[0x2];                                      // 0x012A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DesiredHeight;                                     // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_130[0x10];                                     // 0x0130(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSize(EOrionWidgetStyleSize InSize);
	void ShowAbilityBinding(EOrionAbilityBinding AbilityBinding);
	void ShowInputAction(class FName InActionName);
	void ShowInputAxis(class FName InAxisName);
	void ShowSpecificKey(const struct FKey& Key);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionInputVisualizer">();
	}
	static class UOrionInputVisualizer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionInputVisualizer>();
	}
};
static_assert(alignof(UOrionInputVisualizer) == 0x000008, "Wrong alignment on UOrionInputVisualizer");
static_assert(sizeof(UOrionInputVisualizer) == 0x000140, "Wrong size on UOrionInputVisualizer");
static_assert(offsetof(UOrionInputVisualizer, StyleSize) == 0x0000F8, "Member 'UOrionInputVisualizer::StyleSize' has a wrong offset!");
static_assert(offsetof(UOrionInputVisualizer, ActionName) == 0x000100, "Member 'UOrionInputVisualizer::ActionName' has a wrong offset!");
static_assert(offsetof(UOrionInputVisualizer, AxisName) == 0x000108, "Member 'UOrionInputVisualizer::AxisName' has a wrong offset!");
static_assert(offsetof(UOrionInputVisualizer, SpecificKey) == 0x000110, "Member 'UOrionInputVisualizer::SpecificKey' has a wrong offset!");
static_assert(offsetof(UOrionInputVisualizer, bShowKeyBorder) == 0x000128, "Member 'UOrionInputVisualizer::bShowKeyBorder' has a wrong offset!");
static_assert(offsetof(UOrionInputVisualizer, bPreferSecondaryIcon) == 0x000129, "Member 'UOrionInputVisualizer::bPreferSecondaryIcon' has a wrong offset!");
static_assert(offsetof(UOrionInputVisualizer, DesiredHeight) == 0x00012C, "Member 'UOrionInputVisualizer::DesiredHeight' has a wrong offset!");

// Class OrionGame.OrionGameSession
// 0x0060 (0x0590 - 0x0530)
class AOrionGameSession final : public AGameSessionCommon
{
public:
	uint8                                         Pad_530[0x4];                                      // 0x0530(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HotfixCheckTimer;                                  // 0x0534(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HotfixCheckVariance;                               // 0x0538(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_53C[0xC];                                      // 0x053C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrionPartyBeaconHost*                  OrionReservationBeaconHost;                        // 0x0548(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSessionRegistrationLocked;                        // 0x0550(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_551[0x1F];                                     // 0x0551(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReconnectToMMSDelay;                               // 0x0570(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxReconnectToMMSDelay;                            // 0x0574(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_578[0x18];                                     // 0x0578(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameSession">();
	}
	static class AOrionGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionGameSession>();
	}
};
static_assert(alignof(AOrionGameSession) == 0x000008, "Wrong alignment on AOrionGameSession");
static_assert(sizeof(AOrionGameSession) == 0x000590, "Wrong size on AOrionGameSession");
static_assert(offsetof(AOrionGameSession, HotfixCheckTimer) == 0x000534, "Member 'AOrionGameSession::HotfixCheckTimer' has a wrong offset!");
static_assert(offsetof(AOrionGameSession, HotfixCheckVariance) == 0x000538, "Member 'AOrionGameSession::HotfixCheckVariance' has a wrong offset!");
static_assert(offsetof(AOrionGameSession, OrionReservationBeaconHost) == 0x000548, "Member 'AOrionGameSession::OrionReservationBeaconHost' has a wrong offset!");
static_assert(offsetof(AOrionGameSession, bSessionRegistrationLocked) == 0x000550, "Member 'AOrionGameSession::bSessionRegistrationLocked' has a wrong offset!");
static_assert(offsetof(AOrionGameSession, ReconnectToMMSDelay) == 0x000570, "Member 'AOrionGameSession::ReconnectToMMSDelay' has a wrong offset!");
static_assert(offsetof(AOrionGameSession, MaxReconnectToMMSDelay) == 0x000574, "Member 'AOrionGameSession::MaxReconnectToMMSDelay' has a wrong offset!");

// Class OrionGame.OrionJungleRefinery
// 0x00F8 (0x0620 - 0x0528)
class AOrionJungleRefinery final : public AOrionDamageableActor
{
public:
	struct FOrionJungleRefineryCues               JungleRefineryGameplayCues;                        // 0x0528(0x0010)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         CollectorProgressMaximumAmount;                    // 0x0538(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_53C[0x4];                                      // 0x053C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            VisualFillCurve;                                   // 0x0540(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               CollectorMID;                                      // 0x0548(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReplicatedRefimentTime;                            // 0x0550(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_554[0x4];                                      // 0x0554(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AOrionCharAISpawner*>            JungleSpawners;                                    // 0x0558(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_568[0x18];                                     // 0x0568(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  CXPTags;                                           // 0x0580(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A0[0x70];                                     // 0x05A0(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionJungleRefinerySet*                JungleRefinerySet;                                 // 0x0610(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_618[0x8];                                      // 0x0618(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GatherResources(int32 Amount);
	float GetCurrentCachedResources();
	float GetCurrentResources();
	float GetNextRefinmentTimeLeft();
	void HandleJungleCampDeath(class AOrionChar* DeadChar, class AController* Killer, class AActor* DamageCauser);
	void HandleMatchEnded();
	void HandleMatchStarted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionJungleRefinery">();
	}
	static class AOrionJungleRefinery* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionJungleRefinery>();
	}
};
static_assert(alignof(AOrionJungleRefinery) == 0x000008, "Wrong alignment on AOrionJungleRefinery");
static_assert(sizeof(AOrionJungleRefinery) == 0x000620, "Wrong size on AOrionJungleRefinery");
static_assert(offsetof(AOrionJungleRefinery, JungleRefineryGameplayCues) == 0x000528, "Member 'AOrionJungleRefinery::JungleRefineryGameplayCues' has a wrong offset!");
static_assert(offsetof(AOrionJungleRefinery, CollectorProgressMaximumAmount) == 0x000538, "Member 'AOrionJungleRefinery::CollectorProgressMaximumAmount' has a wrong offset!");
static_assert(offsetof(AOrionJungleRefinery, VisualFillCurve) == 0x000540, "Member 'AOrionJungleRefinery::VisualFillCurve' has a wrong offset!");
static_assert(offsetof(AOrionJungleRefinery, CollectorMID) == 0x000548, "Member 'AOrionJungleRefinery::CollectorMID' has a wrong offset!");
static_assert(offsetof(AOrionJungleRefinery, ReplicatedRefimentTime) == 0x000550, "Member 'AOrionJungleRefinery::ReplicatedRefimentTime' has a wrong offset!");
static_assert(offsetof(AOrionJungleRefinery, JungleSpawners) == 0x000558, "Member 'AOrionJungleRefinery::JungleSpawners' has a wrong offset!");
static_assert(offsetof(AOrionJungleRefinery, CXPTags) == 0x000580, "Member 'AOrionJungleRefinery::CXPTags' has a wrong offset!");
static_assert(offsetof(AOrionJungleRefinery, JungleRefinerySet) == 0x000610, "Member 'AOrionJungleRefinery::JungleRefinerySet' has a wrong offset!");

// Class OrionGame.OrionGameState_MOBA
// 0x02C0 (0x0890 - 0x05D0)
#pragma pack(push, 0x1)
class alignas(0x10) AOrionGameState_MOBA : public AOrionGameState_Base
{
public:
	UMulticastDelegateProperty_                   OnHandleEndMatchSequence;                          // 0x05D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMatchCountdownSecondsUpdated;                    // 0x05E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F0[0x8];                                      // 0x05F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EGameModeType                                 GameModeType;                                      // 0x05F8(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F9[0x3];                                      // 0x05F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MatchTimeLimit;                                    // 0x05FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MatchScoreLimit;                                   // 0x0600(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MatchStartingScore;                                // 0x0604(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 MatchTeamScore;                                    // 0x0608(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_618[0x8];                                      // 0x0618(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MatchScoreUpdateTick;                              // 0x0620(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MatchUpdateScoreOnTickValue;                       // 0x0624(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReplicatedSlomo;                                   // 0x0628(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_62C[0x4];                                      // 0x062C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ShadowPlaneActors;                                 // 0x0630(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FOccludedShadowplaneTest>       ShadowOccludedActors;                              // 0x0640(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         HiddenActors;                                      // 0x0650(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FAlwaysVisibleComponenets>      AlwaysVisibleComponents;                           // 0x0660(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AOrionChar*>                     AttributeRegenOrionChars;                          // 0x0670(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AOrionPlayerState_Game*>         AccumulatedXPTargets;                              // 0x0680(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_690[0x40];                                     // 0x0690(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	EOrionTeam                                    WinningTeamNum;                                    // 0x06D0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6D1[0x3];                                      // 0x06D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UnplayableHitchThresholdInMs;                      // 0x06D4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxUnplayableHitchesToTolerate;                    // 0x06D8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6DC[0x4];                                      // 0x06DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVictoryPlayerTracker>          EndMatchRankedPlayers;                             // 0x06E0(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class ULevelSequencePlayer*                   EndMatchSequencer;                                 // 0x06F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeDilationLength;                                // 0x06F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VictoryTimeDilation;                               // 0x06FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_700[0x4];                                      // 0x0700(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VictoryFadeDelayTimer;                             // 0x0704(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_708[0x148];                                    // 0x0708(0x0148)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrionVisionManager2*                   VisionManager;                                     // 0x0850(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AOrionPickupManager*                    PickupManager;                                     // 0x0858(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AOrionGameEventManager*                 GameEventManager;                                  // 0x0860(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETravelModeModes                              TravelModeMode;                                    // 0x0868(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSprintEnabled;                                    // 0x0869(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_86A[0x2];                                      // 0x086A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RecallTime;                                        // 0x086C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_870[0x18];                                     // 0x0870(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DebugCapsuleSendToAll(const struct FVector& Center, float HalfHeight, float Radius, const struct FQuat& Rotation, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness);
	void DebugLineSendToAll(const struct FVector& LineStart, const struct FVector& LineEnd, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness);
	void DebugSphereSendToAll(const struct FVector& Center, float Radius, int32 Segments, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness);
	void DecrementMatchTeamScore(EOrionTeam TeamNum, int32 Value);
	bool DoesMatchDisplayScore();
	bool DoesMatchDisplayTime();
	void EndMatchClearPlaySpace();
	float GetGameModeRecallTime();
	EGameModeType GetGameModeType();
	bool GetIsMatchScoreBased();
	bool GetIsMatchTimeBased();
	int32 GetMatchScoreLimit();
	float GetMatchScoreUpdateTick();
	int32 GetMatchStartingScore();
	int32 GetMatchTeamScore(EOrionTeam TeamNum);
	float GetMatchTimeLimit();
	int32 GetMatchUpdateScoreOnTickValue();
	EOrionTeam GetTeamWithHighestScore();
	class UAbilitySystemComponent* GetVictoryAbilitySystemFor(EMatchEndTeamPlacement VictoryPlayerIndex);
	class APawn* GetVictoryPawnFor(EMatchEndTeamPlacement VictoryPlayerIndex);
	void GiveTeamCardXP(EOrionTeam InTeam, float XP, class AOrionPlayerState_Game* Earner, const struct FGameplayTagContainer& GrantedTags);
	void HideVictoryActor(EMatchEndTeamPlacement VictoryPlayerIndex);
	void HideVictoryBanner();
	void IncrementMatchTeamScore(EOrionTeam TeamNum, int32 Value);
	void MatchEndSequenceStopped(class AActor* ViewTarget);
	void MatchVictoryEventHasEnded();
	void MulticastNotifyAIKilled(class AOrionCharAI* KilledAI, class AOrionPlayerState_Game* KillerPlayer);
	void MulticastNotifyPlayerKilled(class AOrionPlayerState_Game* KilledPlayer, class AActor* KillerActor);
	void OnGameReady();
	void OnRep_MatchTeamScore();
	void OnRep_Slomo();
	void OnRep_VisionManger();
	void OnRep_WinningTeam();
	void PlaceWinningActor(class AActor* PlacementSpot, EMatchEndTeamPlacement VictoryPlayerIndex);
	void PlayVictoryAnimOn(EMatchEndTeamPlacement VictoryPlayerIndex);
	void SetEndMatchSequence(class ULevelSequencePlayer* InSequence);
	void SetMatchTeamScore(EOrionTeam TeamNum, int32 NewScore);
	void StopVictoryAnimOn(EMatchEndTeamPlacement VictoryPlayerIndex);
	void UpdatePlayerRecorder();

	EOrionTeam GetWinningTeam() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameState_MOBA">();
	}
	static class AOrionGameState_MOBA* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionGameState_MOBA>();
	}
};
#pragma pack(pop)
static_assert(alignof(AOrionGameState_MOBA) == 0x000010, "Wrong alignment on AOrionGameState_MOBA");
static_assert(sizeof(AOrionGameState_MOBA) == 0x000890, "Wrong size on AOrionGameState_MOBA");
static_assert(offsetof(AOrionGameState_MOBA, OnHandleEndMatchSequence) == 0x0005D0, "Member 'AOrionGameState_MOBA::OnHandleEndMatchSequence' has a wrong offset!");
static_assert(offsetof(AOrionGameState_MOBA, OnMatchCountdownSecondsUpdated) == 0x0005E0, "Member 'AOrionGameState_MOBA::OnMatchCountdownSecondsUpdated' has a wrong offset!");
static_assert(offsetof(AOrionGameState_MOBA, GameModeType) == 0x0005F8, "Member 'AOrionGameState_MOBA::GameModeType' has a wrong offset!");
static_assert(offsetof(AOrionGameState_MOBA, MatchTimeLimit) == 0x0005FC, "Member 'AOrionGameState_MOBA::MatchTimeLimit' has a wrong offset!");
static_assert(offsetof(AOrionGameState_MOBA, MatchScoreLimit) == 0x000600, "Member 'AOrionGameState_MOBA::MatchScoreLimit' has a wrong offset!");
static_assert(offsetof(AOrionGameState_MOBA, MatchStartingScore) == 0x000604, "Member 'AOrionGameState_MOBA::MatchStartingScore' has a wrong offset!");
static_assert(offsetof(AOrionGameState_MOBA, MatchTeamScore) == 0x000608, "Member 'AOrionGameState_MOBA::MatchTeamScore' has a wrong offset!");
static_assert(offsetof(AOrionGameState_MOBA, MatchScoreUpdateTick) == 0x000620, "Member 'AOrionGameState_MOBA::MatchScoreUpdateTick' has a wrong offset!");
static_assert(offsetof(AOrionGameState_MOBA, MatchUpdateScoreOnTickValue) == 0x000624, "Member 'AOrionGameState_MOBA::MatchUpdateScoreOnTickValue' has a wrong offset!");
static_assert(offsetof(AOrionGameState_MOBA, ReplicatedSlomo) == 0x000628, "Member 'AOrionGameState_MOBA::ReplicatedSlomo' has a wrong offset!");
static_assert(offsetof(AOrionGameState_MOBA, ShadowPlaneActors) == 0x000630, "Member 'AOrionGameState_MOBA::ShadowPlaneActors' has a wrong offset!");
static_assert(offsetof(AOrionGameState_MOBA, ShadowOccludedActors) == 0x000640, "Member 'AOrionGameState_MOBA::ShadowOccludedActors' has a wrong offset!");
static_assert(offsetof(AOrionGameState_MOBA, HiddenActors) == 0x000650, "Member 'AOrionGameState_MOBA::HiddenActors' has a wrong offset!");
static_assert(offsetof(AOrionGameState_MOBA, AlwaysVisibleComponents) == 0x000660, "Member 'AOrionGameState_MOBA::AlwaysVisibleComponents' has a wrong offset!");
static_assert(offsetof(AOrionGameState_MOBA, AttributeRegenOrionChars) == 0x000670, "Member 'AOrionGameState_MOBA::AttributeRegenOrionChars' has a wrong offset!");
static_assert(offsetof(AOrionGameState_MOBA, AccumulatedXPTargets) == 0x000680, "Member 'AOrionGameState_MOBA::AccumulatedXPTargets' has a wrong offset!");
static_assert(offsetof(AOrionGameState_MOBA, WinningTeamNum) == 0x0006D0, "Member 'AOrionGameState_MOBA::WinningTeamNum' has a wrong offset!");
static_assert(offsetof(AOrionGameState_MOBA, UnplayableHitchThresholdInMs) == 0x0006D4, "Member 'AOrionGameState_MOBA::UnplayableHitchThresholdInMs' has a wrong offset!");
static_assert(offsetof(AOrionGameState_MOBA, MaxUnplayableHitchesToTolerate) == 0x0006D8, "Member 'AOrionGameState_MOBA::MaxUnplayableHitchesToTolerate' has a wrong offset!");
static_assert(offsetof(AOrionGameState_MOBA, EndMatchRankedPlayers) == 0x0006E0, "Member 'AOrionGameState_MOBA::EndMatchRankedPlayers' has a wrong offset!");
static_assert(offsetof(AOrionGameState_MOBA, EndMatchSequencer) == 0x0006F0, "Member 'AOrionGameState_MOBA::EndMatchSequencer' has a wrong offset!");
static_assert(offsetof(AOrionGameState_MOBA, TimeDilationLength) == 0x0006F8, "Member 'AOrionGameState_MOBA::TimeDilationLength' has a wrong offset!");
static_assert(offsetof(AOrionGameState_MOBA, VictoryTimeDilation) == 0x0006FC, "Member 'AOrionGameState_MOBA::VictoryTimeDilation' has a wrong offset!");
static_assert(offsetof(AOrionGameState_MOBA, VictoryFadeDelayTimer) == 0x000704, "Member 'AOrionGameState_MOBA::VictoryFadeDelayTimer' has a wrong offset!");
static_assert(offsetof(AOrionGameState_MOBA, VisionManager) == 0x000850, "Member 'AOrionGameState_MOBA::VisionManager' has a wrong offset!");
static_assert(offsetof(AOrionGameState_MOBA, PickupManager) == 0x000858, "Member 'AOrionGameState_MOBA::PickupManager' has a wrong offset!");
static_assert(offsetof(AOrionGameState_MOBA, GameEventManager) == 0x000860, "Member 'AOrionGameState_MOBA::GameEventManager' has a wrong offset!");
static_assert(offsetof(AOrionGameState_MOBA, TravelModeMode) == 0x000868, "Member 'AOrionGameState_MOBA::TravelModeMode' has a wrong offset!");
static_assert(offsetof(AOrionGameState_MOBA, bSprintEnabled) == 0x000869, "Member 'AOrionGameState_MOBA::bSprintEnabled' has a wrong offset!");
static_assert(offsetof(AOrionGameState_MOBA, RecallTime) == 0x00086C, "Member 'AOrionGameState_MOBA::RecallTime' has a wrong offset!");

// Class OrionGame.OrionGameState_Arcade
// 0x0060 (0x08F0 - 0x0890)
class AOrionGameState_Arcade final : public AOrionGameState_MOBA
{
public:
	struct FArcadeRoundState                      RoundState;                                        // 0x0888(0x0018)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	int32                                         StageIndex;                                        // 0x08A0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8A4[0x4];                                      // 0x08A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionArcadeLadderSetupData*            LadderDataAsset;                                   // 0x08A8(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLadderURLData                         LadderData;                                        // 0x08B0(0x0038)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_8E8[0x8];                                      // 0x08E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_RoundState(const struct FArcadeRoundState& OldStateRoundState);
	void OnRep_StageIndex();
	void OnRoundState_InRound();
	void OnRoundState_Overtime();
	void OnRoundState_PostRound();
	void OnRoundState_PreMatch();
	void OnRoundState_PreRound();
	void OnRoundState_Restarting();
	void OnRoundState_RoundsOver();
	void OnRoundState_WaitingForRecall();
	void OnRoundStateChange(EArcadeRoundPhase NewRoundState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameState_Arcade">();
	}
	static class AOrionGameState_Arcade* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionGameState_Arcade>();
	}
};
static_assert(alignof(AOrionGameState_Arcade) == 0x000010, "Wrong alignment on AOrionGameState_Arcade");
static_assert(sizeof(AOrionGameState_Arcade) == 0x0008F0, "Wrong size on AOrionGameState_Arcade");
static_assert(offsetof(AOrionGameState_Arcade, RoundState) == 0x000888, "Member 'AOrionGameState_Arcade::RoundState' has a wrong offset!");
static_assert(offsetof(AOrionGameState_Arcade, StageIndex) == 0x0008A0, "Member 'AOrionGameState_Arcade::StageIndex' has a wrong offset!");
static_assert(offsetof(AOrionGameState_Arcade, LadderDataAsset) == 0x0008A8, "Member 'AOrionGameState_Arcade::LadderDataAsset' has a wrong offset!");
static_assert(offsetof(AOrionGameState_Arcade, LadderData) == 0x0008B0, "Member 'AOrionGameState_Arcade::LadderData' has a wrong offset!");

// Class OrionGame.OrionGameState_DraftLobby
// 0x0420 (0x09F0 - 0x05D0)
class AOrionGameState_DraftLobby final : public AOrionGameState_Base
{
public:
	TArray<struct FDraftLobbyPhase>               Phases;                                            // 0x05D0(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	int32                                         CurrentPhaseIdx;                                   // 0x05E0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDraftLobbyState                              CurrentDraftState;                                 // 0x05E4(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E5[0x3];                                      // 0x05E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UOrionHeroData*>                 LockedInHeroes;                                    // 0x05E8(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	int32                                         CurrentStateMaxDuration;                           // 0x05F8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CurrentStateCountdown;                             // 0x05FC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EReturnToMainMenuReason                       AbortReason;                                       // 0x0600(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_601[0x3];                                      // 0x0601(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         QuickChatCooldown;                                 // 0x0604(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShowOpponentPlayerNames;                          // 0x0608(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_609[0x57];                                     // 0x0609(0x0057)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableDraftTutorial;                              // 0x0660(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_661[0x38F];                                    // 0x0661(0x038F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_AbortReason();
	void OnRep_CurrentPhaseIdx();
	void OnRep_CurrentPhaseState();
	void OnRep_LockedInHeroes();
	void OnRep_Phases();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameState_DraftLobby">();
	}
	static class AOrionGameState_DraftLobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionGameState_DraftLobby>();
	}
};
static_assert(alignof(AOrionGameState_DraftLobby) == 0x000010, "Wrong alignment on AOrionGameState_DraftLobby");
static_assert(sizeof(AOrionGameState_DraftLobby) == 0x0009F0, "Wrong size on AOrionGameState_DraftLobby");
static_assert(offsetof(AOrionGameState_DraftLobby, Phases) == 0x0005D0, "Member 'AOrionGameState_DraftLobby::Phases' has a wrong offset!");
static_assert(offsetof(AOrionGameState_DraftLobby, CurrentPhaseIdx) == 0x0005E0, "Member 'AOrionGameState_DraftLobby::CurrentPhaseIdx' has a wrong offset!");
static_assert(offsetof(AOrionGameState_DraftLobby, CurrentDraftState) == 0x0005E4, "Member 'AOrionGameState_DraftLobby::CurrentDraftState' has a wrong offset!");
static_assert(offsetof(AOrionGameState_DraftLobby, LockedInHeroes) == 0x0005E8, "Member 'AOrionGameState_DraftLobby::LockedInHeroes' has a wrong offset!");
static_assert(offsetof(AOrionGameState_DraftLobby, CurrentStateMaxDuration) == 0x0005F8, "Member 'AOrionGameState_DraftLobby::CurrentStateMaxDuration' has a wrong offset!");
static_assert(offsetof(AOrionGameState_DraftLobby, CurrentStateCountdown) == 0x0005FC, "Member 'AOrionGameState_DraftLobby::CurrentStateCountdown' has a wrong offset!");
static_assert(offsetof(AOrionGameState_DraftLobby, AbortReason) == 0x000600, "Member 'AOrionGameState_DraftLobby::AbortReason' has a wrong offset!");
static_assert(offsetof(AOrionGameState_DraftLobby, QuickChatCooldown) == 0x000604, "Member 'AOrionGameState_DraftLobby::QuickChatCooldown' has a wrong offset!");
static_assert(offsetof(AOrionGameState_DraftLobby, bShowOpponentPlayerNames) == 0x000608, "Member 'AOrionGameState_DraftLobby::bShowOpponentPlayerNames' has a wrong offset!");
static_assert(offsetof(AOrionGameState_DraftLobby, bEnableDraftTutorial) == 0x000660, "Member 'AOrionGameState_DraftLobby::bEnableDraftTutorial' has a wrong offset!");

// Class OrionGame.OrionKnockback
// 0x0008 (0x0048 - 0x0040)
class UOrionKnockback final : public UGameplayEffectExecutionCalculation
{
public:
	TSubclassOf<class UGameplayEffect>            KnockBackTagGameplayEffect;                        // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionKnockback">();
	}
	static class UOrionKnockback* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionKnockback>();
	}
};
static_assert(alignof(UOrionKnockback) == 0x000008, "Wrong alignment on UOrionKnockback");
static_assert(sizeof(UOrionKnockback) == 0x000048, "Wrong size on UOrionKnockback");
static_assert(offsetof(UOrionKnockback, KnockBackTagGameplayEffect) == 0x000040, "Member 'UOrionKnockback::KnockBackTagGameplayEffect' has a wrong offset!");

// Class OrionGame.OrionMcpEmoteItem
// 0x0000 (0x0078 - 0x0078)
class UOrionMcpEmoteItem final : public UOrionMcpItem
{
public:
	class UOrionEmoteItemDefinition* GetInternalData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpEmoteItem">();
	}
	static class UOrionMcpEmoteItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpEmoteItem>();
	}
};
static_assert(alignof(UOrionMcpEmoteItem) == 0x000008, "Wrong alignment on UOrionMcpEmoteItem");
static_assert(sizeof(UOrionMcpEmoteItem) == 0x000078, "Wrong size on UOrionMcpEmoteItem");

// Class OrionGame.OrionGameState_MOBA_Tutorial
// 0x0000 (0x0890 - 0x0890)
class AOrionGameState_MOBA_Tutorial final : public AOrionGameState_MOBA
{
public:
	class AOrionPlayerController_Tutorial* BP_GetTutorialPlayerController();
	class AOrionPlayerState_Tutorial* BP_GetTutorialPlayerState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameState_MOBA_Tutorial">();
	}
	static class AOrionGameState_MOBA_Tutorial* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionGameState_MOBA_Tutorial>();
	}
};
static_assert(alignof(AOrionGameState_MOBA_Tutorial) == 0x000010, "Wrong alignment on AOrionGameState_MOBA_Tutorial");
static_assert(sizeof(AOrionGameState_MOBA_Tutorial) == 0x000890, "Wrong size on AOrionGameState_MOBA_Tutorial");

// Class OrionGame.OrionGameState_PreGame
// 0x0000 (0x05D0 - 0x05D0)
class AOrionGameState_PreGame final : public AOrionGameState_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameState_PreGame">();
	}
	static class AOrionGameState_PreGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionGameState_PreGame>();
	}
};
static_assert(alignof(AOrionGameState_PreGame) == 0x000010, "Wrong alignment on AOrionGameState_PreGame");
static_assert(sizeof(AOrionGameState_PreGame) == 0x0005D0, "Wrong size on AOrionGameState_PreGame");

// Class OrionGame.OrionGameState_Sandbox
// 0x0000 (0x0890 - 0x0890)
class AOrionGameState_Sandbox final : public AOrionGameState_MOBA
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameState_Sandbox">();
	}
	static class AOrionGameState_Sandbox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionGameState_Sandbox>();
	}
};
static_assert(alignof(AOrionGameState_Sandbox) == 0x000010, "Wrong alignment on AOrionGameState_Sandbox");
static_assert(sizeof(AOrionGameState_Sandbox) == 0x000890, "Wrong size on AOrionGameState_Sandbox");

// Class OrionGame.OrionGameUIData
// 0x0200 (0x0230 - 0x0030)
class UOrionGameUIData final : public UDataAsset
{
public:
	float                                         ParallaxScaleFactor;                               // 0x0030(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParallaxLerpSpeed;                                 // 0x0034(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             DefaultIcon;                                       // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UOrionBasicTooltipWidget>   DefaultTooltipClass;                               // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UOrionStyleData>         StyleData;                                         // 0x0048(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            LoadingSpinner;                                    // 0x0070(0x0078)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            TutorialGlowBrush;                                 // 0x00E8(0x0078)(Edit, NativeAccessSpecifierPublic)
	struct FOrionAnalogCursorSettings             AnalogCursorSettings;                              // 0x0160(0x0038)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	class UOrionRichTextStyleData*                RichTextStyleData;                                 // 0x0198(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionCardDisplayData*                  CardDisplayData;                                   // 0x01A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionAttributeView*                    AttributeView;                                     // 0x01A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionGameTipsData*                     LoadingScreenTips;                                 // 0x01B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionInputDisplayData*                 InputDisplayData;                                  // 0x01B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionStatusEffectData*                 StatusEffectDisplayData;                           // 0x01C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionRewardDisplayData*                RewardDisplayData;                                 // 0x01C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionHeroDisplayData*                  HeroDisplayData;                                   // 0x01D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionMatchmakingDisplayData*           MatchmakingDisplayData;                            // 0x01D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionStoreDisplayData*                 StoreDisplayData;                                  // 0x01E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionSurveyDisplayData*                SurveyDisplayData;                                 // 0x01E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionPostGameDisplayData*              PostGameDisplayData;                               // 0x01F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionProfanityData*                    ChatProfanityData;                                 // 0x01F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionMiniMapDisplayData*               MiniMapDisplayData;                                // 0x0200(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionGemDisplayData*                   GemDisplayData;                                    // 0x0208(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionHUDDisplayData*                   HUDDisplayData;                                    // 0x0210(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionVideoDisplayData*                 VideoDisplayData;                                  // 0x0218(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionDamageIndicatorDisplayData*       DamageIndicatorDisplayData;                        // 0x0220(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionRotationalEventDisplayData*       RotationalEventDisplayData;                        // 0x0228(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameUIData">();
	}
	static class UOrionGameUIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionGameUIData>();
	}
};
static_assert(alignof(UOrionGameUIData) == 0x000008, "Wrong alignment on UOrionGameUIData");
static_assert(sizeof(UOrionGameUIData) == 0x000230, "Wrong size on UOrionGameUIData");
static_assert(offsetof(UOrionGameUIData, ParallaxScaleFactor) == 0x000030, "Member 'UOrionGameUIData::ParallaxScaleFactor' has a wrong offset!");
static_assert(offsetof(UOrionGameUIData, ParallaxLerpSpeed) == 0x000034, "Member 'UOrionGameUIData::ParallaxLerpSpeed' has a wrong offset!");
static_assert(offsetof(UOrionGameUIData, DefaultIcon) == 0x000038, "Member 'UOrionGameUIData::DefaultIcon' has a wrong offset!");
static_assert(offsetof(UOrionGameUIData, DefaultTooltipClass) == 0x000040, "Member 'UOrionGameUIData::DefaultTooltipClass' has a wrong offset!");
static_assert(offsetof(UOrionGameUIData, StyleData) == 0x000048, "Member 'UOrionGameUIData::StyleData' has a wrong offset!");
static_assert(offsetof(UOrionGameUIData, LoadingSpinner) == 0x000070, "Member 'UOrionGameUIData::LoadingSpinner' has a wrong offset!");
static_assert(offsetof(UOrionGameUIData, TutorialGlowBrush) == 0x0000E8, "Member 'UOrionGameUIData::TutorialGlowBrush' has a wrong offset!");
static_assert(offsetof(UOrionGameUIData, AnalogCursorSettings) == 0x000160, "Member 'UOrionGameUIData::AnalogCursorSettings' has a wrong offset!");
static_assert(offsetof(UOrionGameUIData, RichTextStyleData) == 0x000198, "Member 'UOrionGameUIData::RichTextStyleData' has a wrong offset!");
static_assert(offsetof(UOrionGameUIData, CardDisplayData) == 0x0001A0, "Member 'UOrionGameUIData::CardDisplayData' has a wrong offset!");
static_assert(offsetof(UOrionGameUIData, AttributeView) == 0x0001A8, "Member 'UOrionGameUIData::AttributeView' has a wrong offset!");
static_assert(offsetof(UOrionGameUIData, LoadingScreenTips) == 0x0001B0, "Member 'UOrionGameUIData::LoadingScreenTips' has a wrong offset!");
static_assert(offsetof(UOrionGameUIData, InputDisplayData) == 0x0001B8, "Member 'UOrionGameUIData::InputDisplayData' has a wrong offset!");
static_assert(offsetof(UOrionGameUIData, StatusEffectDisplayData) == 0x0001C0, "Member 'UOrionGameUIData::StatusEffectDisplayData' has a wrong offset!");
static_assert(offsetof(UOrionGameUIData, RewardDisplayData) == 0x0001C8, "Member 'UOrionGameUIData::RewardDisplayData' has a wrong offset!");
static_assert(offsetof(UOrionGameUIData, HeroDisplayData) == 0x0001D0, "Member 'UOrionGameUIData::HeroDisplayData' has a wrong offset!");
static_assert(offsetof(UOrionGameUIData, MatchmakingDisplayData) == 0x0001D8, "Member 'UOrionGameUIData::MatchmakingDisplayData' has a wrong offset!");
static_assert(offsetof(UOrionGameUIData, StoreDisplayData) == 0x0001E0, "Member 'UOrionGameUIData::StoreDisplayData' has a wrong offset!");
static_assert(offsetof(UOrionGameUIData, SurveyDisplayData) == 0x0001E8, "Member 'UOrionGameUIData::SurveyDisplayData' has a wrong offset!");
static_assert(offsetof(UOrionGameUIData, PostGameDisplayData) == 0x0001F0, "Member 'UOrionGameUIData::PostGameDisplayData' has a wrong offset!");
static_assert(offsetof(UOrionGameUIData, ChatProfanityData) == 0x0001F8, "Member 'UOrionGameUIData::ChatProfanityData' has a wrong offset!");
static_assert(offsetof(UOrionGameUIData, MiniMapDisplayData) == 0x000200, "Member 'UOrionGameUIData::MiniMapDisplayData' has a wrong offset!");
static_assert(offsetof(UOrionGameUIData, GemDisplayData) == 0x000208, "Member 'UOrionGameUIData::GemDisplayData' has a wrong offset!");
static_assert(offsetof(UOrionGameUIData, HUDDisplayData) == 0x000210, "Member 'UOrionGameUIData::HUDDisplayData' has a wrong offset!");
static_assert(offsetof(UOrionGameUIData, VideoDisplayData) == 0x000218, "Member 'UOrionGameUIData::VideoDisplayData' has a wrong offset!");
static_assert(offsetof(UOrionGameUIData, DamageIndicatorDisplayData) == 0x000220, "Member 'UOrionGameUIData::DamageIndicatorDisplayData' has a wrong offset!");
static_assert(offsetof(UOrionGameUIData, RotationalEventDisplayData) == 0x000228, "Member 'UOrionGameUIData::RotationalEventDisplayData' has a wrong offset!");

// Class OrionGame.OrionGameViewportClient
// 0x0050 (0x0670 - 0x0620)
class UOrionGameViewportClient final : public UGameViewportClient
{
public:
	uint8                                         Pad_620[0x50];                                     // 0x0620(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAnalogCursorEnabledToggle(bool bIsEnabled);
	void UpdateMenusOnFocusLost();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameViewportClient">();
	}
	static class UOrionGameViewportClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionGameViewportClient>();
	}
};
static_assert(alignof(UOrionGameViewportClient) == 0x000008, "Wrong alignment on UOrionGameViewportClient");
static_assert(sizeof(UOrionGameViewportClient) == 0x000670, "Wrong size on UOrionGameViewportClient");

// Class OrionGame.OrionGestureData
// 0x0018 (0x0048 - 0x0030)
class UOrionGestureData final : public UDataAsset
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOrionGestureEntry>             Gestures;                                          // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	struct FOrionGestureEntry GetMatchingGestureEntry(EOrionGestureDirection Direction1, EOrionGestureDirection Direction2) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGestureData">();
	}
	static class UOrionGestureData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionGestureData>();
	}
};
static_assert(alignof(UOrionGestureData) == 0x000008, "Wrong alignment on UOrionGestureData");
static_assert(sizeof(UOrionGestureData) == 0x000048, "Wrong size on UOrionGestureData");
static_assert(offsetof(UOrionGestureData, Gestures) == 0x000038, "Member 'UOrionGestureData::Gestures' has a wrong offset!");

// Class OrionGame.OrionGravesite
// 0x0198 (0x0580 - 0x03E8)
class AOrionGravesite : public AOrionBaseActor
{
public:
	class FName                                   FadeParameterName;                                 // 0x03E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParticleColorParameter;                            // 0x03F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DecalColorParameter1;                              // 0x03F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DecalColorParameter2;                              // 0x0400(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OpacityParameterName;                              // 0x0408(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActivateDurationParameterName;                     // 0x0410(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_418[0x4];                                      // 0x0418(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize100                 ActivationPos;                                     // 0x041C(0x000C)(Net, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 ActivationTriggerPos;                              // 0x0428(0x000C)(Net, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bAutoActivate;                                     // 0x0434(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableActivation;                                // 0x0435(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_436[0x2];                                      // 0x0436(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GravesiteDecalSize;                                // 0x0438(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravesiteRadius;                                   // 0x043C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravesiteNearRadius;                               // 0x0440(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravesiteDistanceFromGround;                       // 0x0444(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravesiteTriggerOffsetDistance;                    // 0x0448(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravesiteLifespanForEnemies;                       // 0x044C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondsRequiredWithinRadiusForEnemies;             // 0x0450(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravesiteLifespanForFriends;                       // 0x0454(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondsRequiredWithinRadiusForFriends;             // 0x0458(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreActivateDelay;                                  // 0x045C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerInRange;                                    // 0x0460(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_461[0x7];                                      // 0x0461(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionGravesiteCues                    GravesiteGameplayCues;                             // 0x0468(0x0030)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	EOrionTeam                                    VictimTeam;                                        // 0x0498(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_499[0x3];                                      // 0x0499(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DecalFadeInDuration;                               // 0x049C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GravesiteLifeTime;                                 // 0x04A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GravesiteFadeDuration;                             // 0x04A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A8[0x14];                                     // 0x04A8(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGravesiteActivationData               ActivationData;                                    // 0x04BC(0x0020)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4DC[0x4];                                      // 0x04DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystemComponent*               ParticleSystemComponent;                           // 0x04E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        ParticleEffect;                                    // 0x04E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDecalComponent*                        DecalComponent;                                    // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     DecalMaterial;                                     // 0x04F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               DecalMaterialInstance;                             // 0x0500(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_508[0x78];                                     // 0x0508(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ActivateGravesite(const struct FVector& Pos, const struct FVector& TriggerPos);
	void AddGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Parameters);
	void ExecuteGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Parameters);
	void FadeOut(bool bBrightenFirst);
	void OnRep_bPlayerInRange();
	void OnRep_GravesiteActivation();
	void RemoveGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Parameters);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGravesite">();
	}
	static class AOrionGravesite* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionGravesite>();
	}
};
static_assert(alignof(AOrionGravesite) == 0x000008, "Wrong alignment on AOrionGravesite");
static_assert(sizeof(AOrionGravesite) == 0x000580, "Wrong size on AOrionGravesite");
static_assert(offsetof(AOrionGravesite, FadeParameterName) == 0x0003E8, "Member 'AOrionGravesite::FadeParameterName' has a wrong offset!");
static_assert(offsetof(AOrionGravesite, ParticleColorParameter) == 0x0003F0, "Member 'AOrionGravesite::ParticleColorParameter' has a wrong offset!");
static_assert(offsetof(AOrionGravesite, DecalColorParameter1) == 0x0003F8, "Member 'AOrionGravesite::DecalColorParameter1' has a wrong offset!");
static_assert(offsetof(AOrionGravesite, DecalColorParameter2) == 0x000400, "Member 'AOrionGravesite::DecalColorParameter2' has a wrong offset!");
static_assert(offsetof(AOrionGravesite, OpacityParameterName) == 0x000408, "Member 'AOrionGravesite::OpacityParameterName' has a wrong offset!");
static_assert(offsetof(AOrionGravesite, ActivateDurationParameterName) == 0x000410, "Member 'AOrionGravesite::ActivateDurationParameterName' has a wrong offset!");
static_assert(offsetof(AOrionGravesite, ActivationPos) == 0x00041C, "Member 'AOrionGravesite::ActivationPos' has a wrong offset!");
static_assert(offsetof(AOrionGravesite, ActivationTriggerPos) == 0x000428, "Member 'AOrionGravesite::ActivationTriggerPos' has a wrong offset!");
static_assert(offsetof(AOrionGravesite, bAutoActivate) == 0x000434, "Member 'AOrionGravesite::bAutoActivate' has a wrong offset!");
static_assert(offsetof(AOrionGravesite, bDisableActivation) == 0x000435, "Member 'AOrionGravesite::bDisableActivation' has a wrong offset!");
static_assert(offsetof(AOrionGravesite, GravesiteDecalSize) == 0x000438, "Member 'AOrionGravesite::GravesiteDecalSize' has a wrong offset!");
static_assert(offsetof(AOrionGravesite, GravesiteRadius) == 0x00043C, "Member 'AOrionGravesite::GravesiteRadius' has a wrong offset!");
static_assert(offsetof(AOrionGravesite, GravesiteNearRadius) == 0x000440, "Member 'AOrionGravesite::GravesiteNearRadius' has a wrong offset!");
static_assert(offsetof(AOrionGravesite, GravesiteDistanceFromGround) == 0x000444, "Member 'AOrionGravesite::GravesiteDistanceFromGround' has a wrong offset!");
static_assert(offsetof(AOrionGravesite, GravesiteTriggerOffsetDistance) == 0x000448, "Member 'AOrionGravesite::GravesiteTriggerOffsetDistance' has a wrong offset!");
static_assert(offsetof(AOrionGravesite, GravesiteLifespanForEnemies) == 0x00044C, "Member 'AOrionGravesite::GravesiteLifespanForEnemies' has a wrong offset!");
static_assert(offsetof(AOrionGravesite, SecondsRequiredWithinRadiusForEnemies) == 0x000450, "Member 'AOrionGravesite::SecondsRequiredWithinRadiusForEnemies' has a wrong offset!");
static_assert(offsetof(AOrionGravesite, GravesiteLifespanForFriends) == 0x000454, "Member 'AOrionGravesite::GravesiteLifespanForFriends' has a wrong offset!");
static_assert(offsetof(AOrionGravesite, SecondsRequiredWithinRadiusForFriends) == 0x000458, "Member 'AOrionGravesite::SecondsRequiredWithinRadiusForFriends' has a wrong offset!");
static_assert(offsetof(AOrionGravesite, PreActivateDelay) == 0x00045C, "Member 'AOrionGravesite::PreActivateDelay' has a wrong offset!");
static_assert(offsetof(AOrionGravesite, bPlayerInRange) == 0x000460, "Member 'AOrionGravesite::bPlayerInRange' has a wrong offset!");
static_assert(offsetof(AOrionGravesite, GravesiteGameplayCues) == 0x000468, "Member 'AOrionGravesite::GravesiteGameplayCues' has a wrong offset!");
static_assert(offsetof(AOrionGravesite, VictimTeam) == 0x000498, "Member 'AOrionGravesite::VictimTeam' has a wrong offset!");
static_assert(offsetof(AOrionGravesite, DecalFadeInDuration) == 0x00049C, "Member 'AOrionGravesite::DecalFadeInDuration' has a wrong offset!");
static_assert(offsetof(AOrionGravesite, GravesiteLifeTime) == 0x0004A0, "Member 'AOrionGravesite::GravesiteLifeTime' has a wrong offset!");
static_assert(offsetof(AOrionGravesite, GravesiteFadeDuration) == 0x0004A4, "Member 'AOrionGravesite::GravesiteFadeDuration' has a wrong offset!");
static_assert(offsetof(AOrionGravesite, ActivationData) == 0x0004BC, "Member 'AOrionGravesite::ActivationData' has a wrong offset!");
static_assert(offsetof(AOrionGravesite, ParticleSystemComponent) == 0x0004E0, "Member 'AOrionGravesite::ParticleSystemComponent' has a wrong offset!");
static_assert(offsetof(AOrionGravesite, ParticleEffect) == 0x0004E8, "Member 'AOrionGravesite::ParticleEffect' has a wrong offset!");
static_assert(offsetof(AOrionGravesite, DecalComponent) == 0x0004F0, "Member 'AOrionGravesite::DecalComponent' has a wrong offset!");
static_assert(offsetof(AOrionGravesite, DecalMaterial) == 0x0004F8, "Member 'AOrionGravesite::DecalMaterial' has a wrong offset!");
static_assert(offsetof(AOrionGravesite, DecalMaterialInstance) == 0x000500, "Member 'AOrionGravesite::DecalMaterialInstance' has a wrong offset!");

// Class OrionGame.OrionGruxAnimInstance
// 0x00A0 (0x0810 - 0x0770)
class UOrionGruxAnimInstance final : public UOrionBaseHeroAnimInstance
{
public:
	bool                                          bUltimateActive;                                   // 0x0770(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_771[0x3];                                      // 0x0771(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UltimateNoiseAdditiveAlpha;                        // 0x0774(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TravelModeWeaponOverrideAlpha;                     // 0x0778(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasInTravelModeLastFrame;                         // 0x077C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTravelModeTriggered;                              // 0x077D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_77E[0x2];                                      // 0x077E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpperBodyApplyMSAWeight;                           // 0x0780(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpperBodyMSAMaskWeight;                            // 0x0784(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmsAndHeadMaskWeight;                             // 0x0788(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78C[0x4];                                      // 0x078C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedAnimStateData                   ArmsAndHead_IdleCachedState;                       // 0x0790(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedAnimStateData                   UpperBodyMSA_IdleCachedState;                      // 0x07B0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         RShoulderAlphaPlugAlpha;                           // 0x07D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RShoulderPad_TranslationOverride;                  // 0x07D4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LShoulderPad_TranslationOverride;                  // 0x07E0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RShoulderPad_RotationOffset;                       // 0x07EC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               LShoulderPad_RotationOffset;                       // 0x07F8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_804[0xC];                                      // 0x0804(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGruxAnimInstance">();
	}
	static class UOrionGruxAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionGruxAnimInstance>();
	}
};
static_assert(alignof(UOrionGruxAnimInstance) == 0x000008, "Wrong alignment on UOrionGruxAnimInstance");
static_assert(sizeof(UOrionGruxAnimInstance) == 0x000810, "Wrong size on UOrionGruxAnimInstance");
static_assert(offsetof(UOrionGruxAnimInstance, bUltimateActive) == 0x000770, "Member 'UOrionGruxAnimInstance::bUltimateActive' has a wrong offset!");
static_assert(offsetof(UOrionGruxAnimInstance, UltimateNoiseAdditiveAlpha) == 0x000774, "Member 'UOrionGruxAnimInstance::UltimateNoiseAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UOrionGruxAnimInstance, TravelModeWeaponOverrideAlpha) == 0x000778, "Member 'UOrionGruxAnimInstance::TravelModeWeaponOverrideAlpha' has a wrong offset!");
static_assert(offsetof(UOrionGruxAnimInstance, bWasInTravelModeLastFrame) == 0x00077C, "Member 'UOrionGruxAnimInstance::bWasInTravelModeLastFrame' has a wrong offset!");
static_assert(offsetof(UOrionGruxAnimInstance, bTravelModeTriggered) == 0x00077D, "Member 'UOrionGruxAnimInstance::bTravelModeTriggered' has a wrong offset!");
static_assert(offsetof(UOrionGruxAnimInstance, UpperBodyApplyMSAWeight) == 0x000780, "Member 'UOrionGruxAnimInstance::UpperBodyApplyMSAWeight' has a wrong offset!");
static_assert(offsetof(UOrionGruxAnimInstance, UpperBodyMSAMaskWeight) == 0x000784, "Member 'UOrionGruxAnimInstance::UpperBodyMSAMaskWeight' has a wrong offset!");
static_assert(offsetof(UOrionGruxAnimInstance, ArmsAndHeadMaskWeight) == 0x000788, "Member 'UOrionGruxAnimInstance::ArmsAndHeadMaskWeight' has a wrong offset!");
static_assert(offsetof(UOrionGruxAnimInstance, ArmsAndHead_IdleCachedState) == 0x000790, "Member 'UOrionGruxAnimInstance::ArmsAndHead_IdleCachedState' has a wrong offset!");
static_assert(offsetof(UOrionGruxAnimInstance, UpperBodyMSA_IdleCachedState) == 0x0007B0, "Member 'UOrionGruxAnimInstance::UpperBodyMSA_IdleCachedState' has a wrong offset!");
static_assert(offsetof(UOrionGruxAnimInstance, RShoulderAlphaPlugAlpha) == 0x0007D0, "Member 'UOrionGruxAnimInstance::RShoulderAlphaPlugAlpha' has a wrong offset!");
static_assert(offsetof(UOrionGruxAnimInstance, RShoulderPad_TranslationOverride) == 0x0007D4, "Member 'UOrionGruxAnimInstance::RShoulderPad_TranslationOverride' has a wrong offset!");
static_assert(offsetof(UOrionGruxAnimInstance, LShoulderPad_TranslationOverride) == 0x0007E0, "Member 'UOrionGruxAnimInstance::LShoulderPad_TranslationOverride' has a wrong offset!");
static_assert(offsetof(UOrionGruxAnimInstance, RShoulderPad_RotationOffset) == 0x0007EC, "Member 'UOrionGruxAnimInstance::RShoulderPad_RotationOffset' has a wrong offset!");
static_assert(offsetof(UOrionGruxAnimInstance, LShoulderPad_RotationOffset) == 0x0007F8, "Member 'UOrionGruxAnimInstance::LShoulderPad_RotationOffset' has a wrong offset!");

// Class OrionGame.OrionHealing
// 0x0000 (0x0040 - 0x0040)
class UOrionHealing final : public UGameplayEffectExecutionCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHealing">();
	}
	static class UOrionHealing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHealing>();
	}
};
static_assert(alignof(UOrionHealing) == 0x000008, "Wrong alignment on UOrionHealing");
static_assert(sizeof(UOrionHealing) == 0x000040, "Wrong size on UOrionHealing");

// Class OrionGame.OrionHealthMissingPCT
// 0x0000 (0x0040 - 0x0040)
class UOrionHealthMissingPCT final : public UGameplayModMagnitudeCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHealthMissingPCT">();
	}
	static class UOrionHealthMissingPCT* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHealthMissingPCT>();
	}
};
static_assert(alignof(UOrionHealthMissingPCT) == 0x000008, "Wrong alignment on UOrionHealthMissingPCT");
static_assert(sizeof(UOrionHealthMissingPCT) == 0x000040, "Wrong size on UOrionHealthMissingPCT");

// Class OrionGame.OrionHealthSet
// 0x0078 (0x00A8 - 0x0030)
class UOrionHealthSet final : public UOrionAttributeSet
{
public:
	float                                         Health;                                            // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHealth;                                         // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinHealth;                                         // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthRegenRate;                                   // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticallyWoundedThresholdPCT;                     // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageBonusTarget;                                 // 0x0044(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageResistance;                                  // 0x0048(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealingBonusTarget;                                // 0x004C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetMaxDamage;                                   // 0x0050(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlatDamageBlock;                                   // 0x0054(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicalResistanceRating;                          // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnergyResistanceRating;                            // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BasicResistanceRating;                             // 0x0060(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AbilityResistanceRating;                           // 0x0064(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Shield;                                            // 0x0068(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxShield;                                         // 0x006C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            CriticallyWoundedGameplayEffect;                   // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x28];                                      // 0x0080(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_AbilityResistanceRating();
	void OnRep_BasicResistanceRating();
	void OnRep_DamageBonusTarget();
	void OnRep_DamageResistance();
	void OnRep_FlatDamageBlock();
	void OnRep_HealingBonusTarget();
	void OnRep_Health();
	void OnRep_HealthRegenRate();
	void OnRep_MaxHealth();
	void OnRep_MaxShield();
	void OnRep_MinHealth();
	void OnRep_Shield();
	void OnRep_TargetMaxDamage();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHealthSet">();
	}
	static class UOrionHealthSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHealthSet>();
	}
};
static_assert(alignof(UOrionHealthSet) == 0x000008, "Wrong alignment on UOrionHealthSet");
static_assert(sizeof(UOrionHealthSet) == 0x0000A8, "Wrong size on UOrionHealthSet");
static_assert(offsetof(UOrionHealthSet, Health) == 0x000030, "Member 'UOrionHealthSet::Health' has a wrong offset!");
static_assert(offsetof(UOrionHealthSet, MaxHealth) == 0x000034, "Member 'UOrionHealthSet::MaxHealth' has a wrong offset!");
static_assert(offsetof(UOrionHealthSet, MinHealth) == 0x000038, "Member 'UOrionHealthSet::MinHealth' has a wrong offset!");
static_assert(offsetof(UOrionHealthSet, HealthRegenRate) == 0x00003C, "Member 'UOrionHealthSet::HealthRegenRate' has a wrong offset!");
static_assert(offsetof(UOrionHealthSet, CriticallyWoundedThresholdPCT) == 0x000040, "Member 'UOrionHealthSet::CriticallyWoundedThresholdPCT' has a wrong offset!");
static_assert(offsetof(UOrionHealthSet, DamageBonusTarget) == 0x000044, "Member 'UOrionHealthSet::DamageBonusTarget' has a wrong offset!");
static_assert(offsetof(UOrionHealthSet, DamageResistance) == 0x000048, "Member 'UOrionHealthSet::DamageResistance' has a wrong offset!");
static_assert(offsetof(UOrionHealthSet, HealingBonusTarget) == 0x00004C, "Member 'UOrionHealthSet::HealingBonusTarget' has a wrong offset!");
static_assert(offsetof(UOrionHealthSet, TargetMaxDamage) == 0x000050, "Member 'UOrionHealthSet::TargetMaxDamage' has a wrong offset!");
static_assert(offsetof(UOrionHealthSet, FlatDamageBlock) == 0x000054, "Member 'UOrionHealthSet::FlatDamageBlock' has a wrong offset!");
static_assert(offsetof(UOrionHealthSet, PhysicalResistanceRating) == 0x000058, "Member 'UOrionHealthSet::PhysicalResistanceRating' has a wrong offset!");
static_assert(offsetof(UOrionHealthSet, EnergyResistanceRating) == 0x00005C, "Member 'UOrionHealthSet::EnergyResistanceRating' has a wrong offset!");
static_assert(offsetof(UOrionHealthSet, BasicResistanceRating) == 0x000060, "Member 'UOrionHealthSet::BasicResistanceRating' has a wrong offset!");
static_assert(offsetof(UOrionHealthSet, AbilityResistanceRating) == 0x000064, "Member 'UOrionHealthSet::AbilityResistanceRating' has a wrong offset!");
static_assert(offsetof(UOrionHealthSet, Shield) == 0x000068, "Member 'UOrionHealthSet::Shield' has a wrong offset!");
static_assert(offsetof(UOrionHealthSet, MaxShield) == 0x00006C, "Member 'UOrionHealthSet::MaxShield' has a wrong offset!");
static_assert(offsetof(UOrionHealthSet, CriticallyWoundedGameplayEffect) == 0x000078, "Member 'UOrionHealthSet::CriticallyWoundedGameplayEffect' has a wrong offset!");

// Class OrionGame.OrionHeroChainsAnimInstance
// 0x0170 (0x1330 - 0x11C0)
class UOrionHeroChainsAnimInstance final : public UOrionHeroAnimInstance
{
public:
	float                                         LeanLayerBlendWeight;                              // 0x11B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShockingPunchActive;                            // 0x11BC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11BD[0x3];                                     // 0x11BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TravelModeCastingCurveName;                        // 0x11C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TravelModeCorrectiveOverrideCurveName;             // 0x11C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TravelModeChainOverrideAlpha;                      // 0x11D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TravelModeCorrectiveAlpha;                         // 0x11D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightShoulderTrackLookAtAlpha;                     // 0x11D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftShoulderTrackLookAtAlpha;                      // 0x11DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightShoulderBoneName;                             // 0x11E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftShoulderBoneName;                              // 0x11E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultShoulderWheelPlayRate;                      // 0x11F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11F4[0x4];                                     // 0x11F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RightShoulderWheelPlayRateCurveName;               // 0x11F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftShoulderWheelPlayRateCurveName;                // 0x1200(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightShoulderWheelPlayRate;                        // 0x1208(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftShoulderWheelPlayRate;                         // 0x120C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OverrideDynamicsChainRightCurveName;               // 0x1210(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OverrideDynamicsChainLeftCurveName;                // 0x1218(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShortChainsAlphaScale;                             // 0x1220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightShortChainDynamicsAlpha;                      // 0x1224(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftShortChainDynamicsAlpha;                       // 0x1228(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_122C[0x4];                                     // 0x122C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HookActiveCurveName;                               // 0x1230(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHookCurveActive;                                // 0x1238(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1239[0x3];                                     // 0x1239(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HookCurveValue;                                    // 0x123C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRK4SpringInterpolator            HookActorTrackingInterpolator;                     // 0x1240(0x0008)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1248[0x1C];                                    // 0x1248(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HookActorTrackingBlendWeight;                      // 0x1264(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ActorHitByHook;                                    // 0x1268(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HookTargetWorldLocation;                           // 0x1270(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_127C[0x4];                                     // 0x127C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           HookVictimTargetLocationBoneNames;                 // 0x1280(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         HookThrowAimOffsetPitch;                           // 0x1290(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1294[0x4];                                     // 0x1294(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HookThrowAimOffsetOriginBoneName;                  // 0x1298(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HookChainMaxLength;                                // 0x12A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12A4[0x4];                                     // 0x12A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HookChainRootBoneName;                             // 0x12A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HookChainLengthAnimPos;                            // 0x12B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HookChainDistActorToActor;                         // 0x12B4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHookChainThrow;                                 // 0x12B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHookChainHit;                                   // 0x12B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHookChainPull;                                  // 0x12BA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHookChainPullingSomething;                      // 0x12BB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HookChainLookAtAlpha;                              // 0x12BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HookChainExtendedAlpha;                            // 0x12C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HookChainRetractedAlpha;                           // 0x12C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedAnimStateData                   HookChainRetractedCachedState;                     // 0x12C8(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         UltimateTraceForwardLength;                        // 0x12E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UltimateTraceDownwardLength;                       // 0x12EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UltimateTraceSideAngleDegrees;                     // 0x12F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UltimateTraceSphereSize;                           // 0x12F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               UltimateRotationWorldOffset;                       // 0x12F8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1304[0x4];                                     // 0x1304(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   UltimateAnimCurveName;                             // 0x1308(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UltimateAnimCurveValue;                            // 0x1310(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShockingGroundActive;                           // 0x1314(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1315[0x3];                                     // 0x1315(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DisableBackPanelOverrideCurveName;                 // 0x1318(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackPanelOverrideWeight;                           // 0x1320(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackPanelWeight;                                   // 0x1324(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1328[0x8];                                     // 0x1328(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetUpBellyChainOrientation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHeroChainsAnimInstance">();
	}
	static class UOrionHeroChainsAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHeroChainsAnimInstance>();
	}
};
static_assert(alignof(UOrionHeroChainsAnimInstance) == 0x000010, "Wrong alignment on UOrionHeroChainsAnimInstance");
static_assert(sizeof(UOrionHeroChainsAnimInstance) == 0x001330, "Wrong size on UOrionHeroChainsAnimInstance");
static_assert(offsetof(UOrionHeroChainsAnimInstance, LeanLayerBlendWeight) == 0x0011B8, "Member 'UOrionHeroChainsAnimInstance::LeanLayerBlendWeight' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, bIsShockingPunchActive) == 0x0011BC, "Member 'UOrionHeroChainsAnimInstance::bIsShockingPunchActive' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, TravelModeCastingCurveName) == 0x0011C0, "Member 'UOrionHeroChainsAnimInstance::TravelModeCastingCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, TravelModeCorrectiveOverrideCurveName) == 0x0011C8, "Member 'UOrionHeroChainsAnimInstance::TravelModeCorrectiveOverrideCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, TravelModeChainOverrideAlpha) == 0x0011D0, "Member 'UOrionHeroChainsAnimInstance::TravelModeChainOverrideAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, TravelModeCorrectiveAlpha) == 0x0011D4, "Member 'UOrionHeroChainsAnimInstance::TravelModeCorrectiveAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, RightShoulderTrackLookAtAlpha) == 0x0011D8, "Member 'UOrionHeroChainsAnimInstance::RightShoulderTrackLookAtAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, LeftShoulderTrackLookAtAlpha) == 0x0011DC, "Member 'UOrionHeroChainsAnimInstance::LeftShoulderTrackLookAtAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, RightShoulderBoneName) == 0x0011E0, "Member 'UOrionHeroChainsAnimInstance::RightShoulderBoneName' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, LeftShoulderBoneName) == 0x0011E8, "Member 'UOrionHeroChainsAnimInstance::LeftShoulderBoneName' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, DefaultShoulderWheelPlayRate) == 0x0011F0, "Member 'UOrionHeroChainsAnimInstance::DefaultShoulderWheelPlayRate' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, RightShoulderWheelPlayRateCurveName) == 0x0011F8, "Member 'UOrionHeroChainsAnimInstance::RightShoulderWheelPlayRateCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, LeftShoulderWheelPlayRateCurveName) == 0x001200, "Member 'UOrionHeroChainsAnimInstance::LeftShoulderWheelPlayRateCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, RightShoulderWheelPlayRate) == 0x001208, "Member 'UOrionHeroChainsAnimInstance::RightShoulderWheelPlayRate' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, LeftShoulderWheelPlayRate) == 0x00120C, "Member 'UOrionHeroChainsAnimInstance::LeftShoulderWheelPlayRate' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, OverrideDynamicsChainRightCurveName) == 0x001210, "Member 'UOrionHeroChainsAnimInstance::OverrideDynamicsChainRightCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, OverrideDynamicsChainLeftCurveName) == 0x001218, "Member 'UOrionHeroChainsAnimInstance::OverrideDynamicsChainLeftCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, ShortChainsAlphaScale) == 0x001220, "Member 'UOrionHeroChainsAnimInstance::ShortChainsAlphaScale' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, RightShortChainDynamicsAlpha) == 0x001224, "Member 'UOrionHeroChainsAnimInstance::RightShortChainDynamicsAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, LeftShortChainDynamicsAlpha) == 0x001228, "Member 'UOrionHeroChainsAnimInstance::LeftShortChainDynamicsAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, HookActiveCurveName) == 0x001230, "Member 'UOrionHeroChainsAnimInstance::HookActiveCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, bIsHookCurveActive) == 0x001238, "Member 'UOrionHeroChainsAnimInstance::bIsHookCurveActive' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, HookCurveValue) == 0x00123C, "Member 'UOrionHeroChainsAnimInstance::HookCurveValue' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, HookActorTrackingInterpolator) == 0x001240, "Member 'UOrionHeroChainsAnimInstance::HookActorTrackingInterpolator' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, HookActorTrackingBlendWeight) == 0x001264, "Member 'UOrionHeroChainsAnimInstance::HookActorTrackingBlendWeight' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, ActorHitByHook) == 0x001268, "Member 'UOrionHeroChainsAnimInstance::ActorHitByHook' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, HookTargetWorldLocation) == 0x001270, "Member 'UOrionHeroChainsAnimInstance::HookTargetWorldLocation' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, HookVictimTargetLocationBoneNames) == 0x001280, "Member 'UOrionHeroChainsAnimInstance::HookVictimTargetLocationBoneNames' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, HookThrowAimOffsetPitch) == 0x001290, "Member 'UOrionHeroChainsAnimInstance::HookThrowAimOffsetPitch' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, HookThrowAimOffsetOriginBoneName) == 0x001298, "Member 'UOrionHeroChainsAnimInstance::HookThrowAimOffsetOriginBoneName' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, HookChainMaxLength) == 0x0012A0, "Member 'UOrionHeroChainsAnimInstance::HookChainMaxLength' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, HookChainRootBoneName) == 0x0012A8, "Member 'UOrionHeroChainsAnimInstance::HookChainRootBoneName' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, HookChainLengthAnimPos) == 0x0012B0, "Member 'UOrionHeroChainsAnimInstance::HookChainLengthAnimPos' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, HookChainDistActorToActor) == 0x0012B4, "Member 'UOrionHeroChainsAnimInstance::HookChainDistActorToActor' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, bIsHookChainThrow) == 0x0012B8, "Member 'UOrionHeroChainsAnimInstance::bIsHookChainThrow' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, bIsHookChainHit) == 0x0012B9, "Member 'UOrionHeroChainsAnimInstance::bIsHookChainHit' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, bIsHookChainPull) == 0x0012BA, "Member 'UOrionHeroChainsAnimInstance::bIsHookChainPull' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, bIsHookChainPullingSomething) == 0x0012BB, "Member 'UOrionHeroChainsAnimInstance::bIsHookChainPullingSomething' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, HookChainLookAtAlpha) == 0x0012BC, "Member 'UOrionHeroChainsAnimInstance::HookChainLookAtAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, HookChainExtendedAlpha) == 0x0012C0, "Member 'UOrionHeroChainsAnimInstance::HookChainExtendedAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, HookChainRetractedAlpha) == 0x0012C4, "Member 'UOrionHeroChainsAnimInstance::HookChainRetractedAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, HookChainRetractedCachedState) == 0x0012C8, "Member 'UOrionHeroChainsAnimInstance::HookChainRetractedCachedState' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, UltimateTraceForwardLength) == 0x0012E8, "Member 'UOrionHeroChainsAnimInstance::UltimateTraceForwardLength' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, UltimateTraceDownwardLength) == 0x0012EC, "Member 'UOrionHeroChainsAnimInstance::UltimateTraceDownwardLength' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, UltimateTraceSideAngleDegrees) == 0x0012F0, "Member 'UOrionHeroChainsAnimInstance::UltimateTraceSideAngleDegrees' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, UltimateTraceSphereSize) == 0x0012F4, "Member 'UOrionHeroChainsAnimInstance::UltimateTraceSphereSize' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, UltimateRotationWorldOffset) == 0x0012F8, "Member 'UOrionHeroChainsAnimInstance::UltimateRotationWorldOffset' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, UltimateAnimCurveName) == 0x001308, "Member 'UOrionHeroChainsAnimInstance::UltimateAnimCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, UltimateAnimCurveValue) == 0x001310, "Member 'UOrionHeroChainsAnimInstance::UltimateAnimCurveValue' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, bIsShockingGroundActive) == 0x001314, "Member 'UOrionHeroChainsAnimInstance::bIsShockingGroundActive' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, DisableBackPanelOverrideCurveName) == 0x001318, "Member 'UOrionHeroChainsAnimInstance::DisableBackPanelOverrideCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, BackPanelOverrideWeight) == 0x001320, "Member 'UOrionHeroChainsAnimInstance::BackPanelOverrideWeight' has a wrong offset!");
static_assert(offsetof(UOrionHeroChainsAnimInstance, BackPanelWeight) == 0x001324, "Member 'UOrionHeroChainsAnimInstance::BackPanelWeight' has a wrong offset!");

// Class OrionGame.OrionHeroCrunchAnimInstance
// 0x0000 (0x11C0 - 0x11C0)
class UOrionHeroCrunchAnimInstance final : public UOrionHeroAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHeroCrunchAnimInstance">();
	}
	static class UOrionHeroCrunchAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHeroCrunchAnimInstance>();
	}
};
static_assert(alignof(UOrionHeroCrunchAnimInstance) == 0x000010, "Wrong alignment on UOrionHeroCrunchAnimInstance");
static_assert(sizeof(UOrionHeroCrunchAnimInstance) == 0x0011C0, "Wrong size on UOrionHeroCrunchAnimInstance");

// Class OrionGame.OrionHeroDataCollection
// 0x0030 (0x0060 - 0x0030)
class UOrionHeroDataCollection final : public UDataAsset
{
public:
	TArray<TSoftObjectPtr<class UOrionHeroData>>  AvailableHeroesWeakRef;                            // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UOrionAIData*>                   AlwaysLoadedAIData;                                // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UOrionHeroData*>                 AvailableHeroes;                                   // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHeroDataCollection">();
	}
	static class UOrionHeroDataCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHeroDataCollection>();
	}
};
static_assert(alignof(UOrionHeroDataCollection) == 0x000008, "Wrong alignment on UOrionHeroDataCollection");
static_assert(sizeof(UOrionHeroDataCollection) == 0x000060, "Wrong size on UOrionHeroDataCollection");
static_assert(offsetof(UOrionHeroDataCollection, AvailableHeroesWeakRef) == 0x000030, "Member 'UOrionHeroDataCollection::AvailableHeroesWeakRef' has a wrong offset!");
static_assert(offsetof(UOrionHeroDataCollection, AlwaysLoadedAIData) == 0x000040, "Member 'UOrionHeroDataCollection::AlwaysLoadedAIData' has a wrong offset!");
static_assert(offsetof(UOrionHeroDataCollection, AvailableHeroes) == 0x000050, "Member 'UOrionHeroDataCollection::AvailableHeroes' has a wrong offset!");

// Class OrionGame.OrionHeroDisplayData
// 0x09F0 (0x0A20 - 0x0030)
class UOrionHeroDisplayData final : public UDataAsset
{
public:
	class FText                                   SummaryStatNames[0x4];                             // 0x0030(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FOrionBasicDisplayInfo                 Roles[0x8];                                        // 0x0090(0x0048)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FOrionBasicDisplayInfo                 Positions[0x7];                                    // 0x02D0(0x0048)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FOrionBasicDisplayInfo                 Traits[0xE];                                       // 0x04C8(0x0048)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   BotDifficultyNames[0x6];                           // 0x08B8(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTexture2D*                             RecommendedHeroIcon;                               // 0x0948(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   RecommendedHeroMessage;                            // 0x0950(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTexture2D*                             LockedHeroIcon;                                    // 0x0968(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   LockedHeroMessageFormat;                           // 0x0970(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   DifficultyNames[0x5];                              // 0x0988(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         DifficultyUnlockLevels[0x5];                       // 0x0A00(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A14[0x4];                                      // 0x0A14(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionMcpItemDefinition*                FreeHeroTokenDefintion;                            // 0x0A18(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHeroDisplayData">();
	}
	static class UOrionHeroDisplayData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHeroDisplayData>();
	}
};
static_assert(alignof(UOrionHeroDisplayData) == 0x000008, "Wrong alignment on UOrionHeroDisplayData");
static_assert(sizeof(UOrionHeroDisplayData) == 0x000A20, "Wrong size on UOrionHeroDisplayData");
static_assert(offsetof(UOrionHeroDisplayData, SummaryStatNames) == 0x000030, "Member 'UOrionHeroDisplayData::SummaryStatNames' has a wrong offset!");
static_assert(offsetof(UOrionHeroDisplayData, Roles) == 0x000090, "Member 'UOrionHeroDisplayData::Roles' has a wrong offset!");
static_assert(offsetof(UOrionHeroDisplayData, Positions) == 0x0002D0, "Member 'UOrionHeroDisplayData::Positions' has a wrong offset!");
static_assert(offsetof(UOrionHeroDisplayData, Traits) == 0x0004C8, "Member 'UOrionHeroDisplayData::Traits' has a wrong offset!");
static_assert(offsetof(UOrionHeroDisplayData, BotDifficultyNames) == 0x0008B8, "Member 'UOrionHeroDisplayData::BotDifficultyNames' has a wrong offset!");
static_assert(offsetof(UOrionHeroDisplayData, RecommendedHeroIcon) == 0x000948, "Member 'UOrionHeroDisplayData::RecommendedHeroIcon' has a wrong offset!");
static_assert(offsetof(UOrionHeroDisplayData, RecommendedHeroMessage) == 0x000950, "Member 'UOrionHeroDisplayData::RecommendedHeroMessage' has a wrong offset!");
static_assert(offsetof(UOrionHeroDisplayData, LockedHeroIcon) == 0x000968, "Member 'UOrionHeroDisplayData::LockedHeroIcon' has a wrong offset!");
static_assert(offsetof(UOrionHeroDisplayData, LockedHeroMessageFormat) == 0x000970, "Member 'UOrionHeroDisplayData::LockedHeroMessageFormat' has a wrong offset!");
static_assert(offsetof(UOrionHeroDisplayData, DifficultyNames) == 0x000988, "Member 'UOrionHeroDisplayData::DifficultyNames' has a wrong offset!");
static_assert(offsetof(UOrionHeroDisplayData, DifficultyUnlockLevels) == 0x000A00, "Member 'UOrionHeroDisplayData::DifficultyUnlockLevels' has a wrong offset!");
static_assert(offsetof(UOrionHeroDisplayData, FreeHeroTokenDefintion) == 0x000A18, "Member 'UOrionHeroDisplayData::FreeHeroTokenDefintion' has a wrong offset!");

// Class OrionGame.OrionHeroDisplayLibrary
// 0x0000 (0x0028 - 0x0028)
class UOrionHeroDisplayLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void GetHeroLockedMessage(EOrionHeroTier Tier, class FText* MESSAGE);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHeroDisplayLibrary">();
	}
	static class UOrionHeroDisplayLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHeroDisplayLibrary>();
	}
};
static_assert(alignof(UOrionHeroDisplayLibrary) == 0x000008, "Wrong alignment on UOrionHeroDisplayLibrary");
static_assert(sizeof(UOrionHeroDisplayLibrary) == 0x000028, "Wrong size on UOrionHeroDisplayLibrary");

// Class OrionGame.OrionHeroFemmeAnimInstance
// 0x0020 (0x11E0 - 0x11C0)
class UOrionHeroFemmeAnimInstance final : public UOrionHeroAnimInstance
{
public:
	class AActor*                                 WhipAimTargetActor;                                // 0x11B8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WhipAimTargetLocation;                             // 0x11C0(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bValidAimTarget;                                   // 0x11CC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11CD[0x3];                                     // 0x11CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WhipAimingCurveValue;                              // 0x11D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WhipScaleCurveValue;                               // 0x11D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WhipDynamicsAlpha;                                 // 0x11D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11DC[0x4];                                     // 0x11DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHeroFemmeAnimInstance">();
	}
	static class UOrionHeroFemmeAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHeroFemmeAnimInstance>();
	}
};
static_assert(alignof(UOrionHeroFemmeAnimInstance) == 0x000010, "Wrong alignment on UOrionHeroFemmeAnimInstance");
static_assert(sizeof(UOrionHeroFemmeAnimInstance) == 0x0011E0, "Wrong size on UOrionHeroFemmeAnimInstance");
static_assert(offsetof(UOrionHeroFemmeAnimInstance, WhipAimTargetActor) == 0x0011B8, "Member 'UOrionHeroFemmeAnimInstance::WhipAimTargetActor' has a wrong offset!");
static_assert(offsetof(UOrionHeroFemmeAnimInstance, WhipAimTargetLocation) == 0x0011C0, "Member 'UOrionHeroFemmeAnimInstance::WhipAimTargetLocation' has a wrong offset!");
static_assert(offsetof(UOrionHeroFemmeAnimInstance, bValidAimTarget) == 0x0011CC, "Member 'UOrionHeroFemmeAnimInstance::bValidAimTarget' has a wrong offset!");
static_assert(offsetof(UOrionHeroFemmeAnimInstance, WhipAimingCurveValue) == 0x0011D0, "Member 'UOrionHeroFemmeAnimInstance::WhipAimingCurveValue' has a wrong offset!");
static_assert(offsetof(UOrionHeroFemmeAnimInstance, WhipScaleCurveValue) == 0x0011D4, "Member 'UOrionHeroFemmeAnimInstance::WhipScaleCurveValue' has a wrong offset!");
static_assert(offsetof(UOrionHeroFemmeAnimInstance, WhipDynamicsAlpha) == 0x0011D8, "Member 'UOrionHeroFemmeAnimInstance::WhipDynamicsAlpha' has a wrong offset!");

// Class OrionGame.OrionHeroHammerAnimInstance
// 0x0040 (0x1200 - 0x11C0)
class UOrionHeroHammerAnimInstance final : public UOrionHeroAnimInstance
{
public:
	int32                                         TransformationStageIndex;                          // 0x11B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReachedStage1;                                    // 0x11BC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReachedStage2;                                    // 0x11BD(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReachedStage3;                                    // 0x11BE(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReachedStage4;                                    // 0x11BF(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Swing2AnimCurveName;                               // 0x11C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Swing2AdditiveAlpha;                               // 0x11C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRK4SpringInterpolator            TravelModeRotationRateInterpolator;                // 0x11CC(0x0008)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11D4[0x1C];                                    // 0x11D4(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TravelModeMaxRotationRate;                         // 0x11F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TravelModeSmoothedRotationRate;                    // 0x11F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11F8[0x8];                                     // 0x11F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHeroHammerAnimInstance">();
	}
	static class UOrionHeroHammerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHeroHammerAnimInstance>();
	}
};
static_assert(alignof(UOrionHeroHammerAnimInstance) == 0x000010, "Wrong alignment on UOrionHeroHammerAnimInstance");
static_assert(sizeof(UOrionHeroHammerAnimInstance) == 0x001200, "Wrong size on UOrionHeroHammerAnimInstance");
static_assert(offsetof(UOrionHeroHammerAnimInstance, TransformationStageIndex) == 0x0011B8, "Member 'UOrionHeroHammerAnimInstance::TransformationStageIndex' has a wrong offset!");
static_assert(offsetof(UOrionHeroHammerAnimInstance, bReachedStage1) == 0x0011BC, "Member 'UOrionHeroHammerAnimInstance::bReachedStage1' has a wrong offset!");
static_assert(offsetof(UOrionHeroHammerAnimInstance, bReachedStage2) == 0x0011BD, "Member 'UOrionHeroHammerAnimInstance::bReachedStage2' has a wrong offset!");
static_assert(offsetof(UOrionHeroHammerAnimInstance, bReachedStage3) == 0x0011BE, "Member 'UOrionHeroHammerAnimInstance::bReachedStage3' has a wrong offset!");
static_assert(offsetof(UOrionHeroHammerAnimInstance, bReachedStage4) == 0x0011BF, "Member 'UOrionHeroHammerAnimInstance::bReachedStage4' has a wrong offset!");
static_assert(offsetof(UOrionHeroHammerAnimInstance, Swing2AnimCurveName) == 0x0011C0, "Member 'UOrionHeroHammerAnimInstance::Swing2AnimCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroHammerAnimInstance, Swing2AdditiveAlpha) == 0x0011C8, "Member 'UOrionHeroHammerAnimInstance::Swing2AdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroHammerAnimInstance, TravelModeRotationRateInterpolator) == 0x0011CC, "Member 'UOrionHeroHammerAnimInstance::TravelModeRotationRateInterpolator' has a wrong offset!");
static_assert(offsetof(UOrionHeroHammerAnimInstance, TravelModeMaxRotationRate) == 0x0011F0, "Member 'UOrionHeroHammerAnimInstance::TravelModeMaxRotationRate' has a wrong offset!");
static_assert(offsetof(UOrionHeroHammerAnimInstance, TravelModeSmoothedRotationRate) == 0x0011F4, "Member 'UOrionHeroHammerAnimInstance::TravelModeSmoothedRotationRate' has a wrong offset!");

// Class OrionGame.OrionHeroKurohaneAnimInstance
// 0x0060 (0x1220 - 0x11C0)
class UOrionHeroKurohaneAnimInstance final : public UOrionHeroAnimInstance
{
public:
	class FName                                   TravelModeCorrectiveOverrideCurveName;             // 0x11B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TravelModeCorrectiveTargetWeight;                  // 0x11C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TravelModeCorrectiveAlpha;                         // 0x11C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TravelModeSwordCorrectiveWeight;                   // 0x11C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUltimateCasting;                                // 0x11CC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUltimateTargeting;                              // 0x11CD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHoldingDagger;                                  // 0x11CE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11CF[0x1];                                     // 0x11CF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DeployJetsCurveName;                               // 0x11D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOpenBackJets;                                     // 0x11D8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11D9[0x7];                                     // 0x11D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedAnimStateData                   BackJetsIdleCachedState;                           // 0x11E0(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         BackJetsMaskWeight;                                // 0x1200(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_DaggerHoldStill_to_DaggerHoldMoving;   // 0x1204(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_DaggerHoldMoving_to_DaggerHoldStill;   // 0x1205(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1206[0x2];                                     // 0x1206(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DaggerHoldCorrectiveMaskWeight;                    // 0x1208(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_120C[0x4];                                     // 0x120C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DaggerHoldCorrectiveCurveName;                     // 0x1210(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1218[0x8];                                     // 0x1218(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHeroKurohaneAnimInstance">();
	}
	static class UOrionHeroKurohaneAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHeroKurohaneAnimInstance>();
	}
};
static_assert(alignof(UOrionHeroKurohaneAnimInstance) == 0x000010, "Wrong alignment on UOrionHeroKurohaneAnimInstance");
static_assert(sizeof(UOrionHeroKurohaneAnimInstance) == 0x001220, "Wrong size on UOrionHeroKurohaneAnimInstance");
static_assert(offsetof(UOrionHeroKurohaneAnimInstance, TravelModeCorrectiveOverrideCurveName) == 0x0011B8, "Member 'UOrionHeroKurohaneAnimInstance::TravelModeCorrectiveOverrideCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroKurohaneAnimInstance, TravelModeCorrectiveTargetWeight) == 0x0011C0, "Member 'UOrionHeroKurohaneAnimInstance::TravelModeCorrectiveTargetWeight' has a wrong offset!");
static_assert(offsetof(UOrionHeroKurohaneAnimInstance, TravelModeCorrectiveAlpha) == 0x0011C4, "Member 'UOrionHeroKurohaneAnimInstance::TravelModeCorrectiveAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroKurohaneAnimInstance, TravelModeSwordCorrectiveWeight) == 0x0011C8, "Member 'UOrionHeroKurohaneAnimInstance::TravelModeSwordCorrectiveWeight' has a wrong offset!");
static_assert(offsetof(UOrionHeroKurohaneAnimInstance, bIsUltimateCasting) == 0x0011CC, "Member 'UOrionHeroKurohaneAnimInstance::bIsUltimateCasting' has a wrong offset!");
static_assert(offsetof(UOrionHeroKurohaneAnimInstance, bIsUltimateTargeting) == 0x0011CD, "Member 'UOrionHeroKurohaneAnimInstance::bIsUltimateTargeting' has a wrong offset!");
static_assert(offsetof(UOrionHeroKurohaneAnimInstance, bIsHoldingDagger) == 0x0011CE, "Member 'UOrionHeroKurohaneAnimInstance::bIsHoldingDagger' has a wrong offset!");
static_assert(offsetof(UOrionHeroKurohaneAnimInstance, DeployJetsCurveName) == 0x0011D0, "Member 'UOrionHeroKurohaneAnimInstance::DeployJetsCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroKurohaneAnimInstance, bOpenBackJets) == 0x0011D8, "Member 'UOrionHeroKurohaneAnimInstance::bOpenBackJets' has a wrong offset!");
static_assert(offsetof(UOrionHeroKurohaneAnimInstance, BackJetsIdleCachedState) == 0x0011E0, "Member 'UOrionHeroKurohaneAnimInstance::BackJetsIdleCachedState' has a wrong offset!");
static_assert(offsetof(UOrionHeroKurohaneAnimInstance, BackJetsMaskWeight) == 0x001200, "Member 'UOrionHeroKurohaneAnimInstance::BackJetsMaskWeight' has a wrong offset!");
static_assert(offsetof(UOrionHeroKurohaneAnimInstance, bTransition_DaggerHoldStill_to_DaggerHoldMoving) == 0x001204, "Member 'UOrionHeroKurohaneAnimInstance::bTransition_DaggerHoldStill_to_DaggerHoldMoving' has a wrong offset!");
static_assert(offsetof(UOrionHeroKurohaneAnimInstance, bTransition_DaggerHoldMoving_to_DaggerHoldStill) == 0x001205, "Member 'UOrionHeroKurohaneAnimInstance::bTransition_DaggerHoldMoving_to_DaggerHoldStill' has a wrong offset!");
static_assert(offsetof(UOrionHeroKurohaneAnimInstance, DaggerHoldCorrectiveMaskWeight) == 0x001208, "Member 'UOrionHeroKurohaneAnimInstance::DaggerHoldCorrectiveMaskWeight' has a wrong offset!");
static_assert(offsetof(UOrionHeroKurohaneAnimInstance, DaggerHoldCorrectiveCurveName) == 0x001210, "Member 'UOrionHeroKurohaneAnimInstance::DaggerHoldCorrectiveCurveName' has a wrong offset!");

// Class OrionGame.OrionHeroPriceAnimInstance
// 0x00A0 (0x1260 - 0x11C0)
class UOrionHeroPriceAnimInstance final : public UOrionHeroAnimInstance
{
public:
	float                                         LeftHandIKAlpha;                                   // 0x11B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInSpreadShotMode;                               // 0x11BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSpreadShotFired;                               // 0x11BD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInShieldMode;                                   // 0x11BE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShieldKnockBack;                                // 0x11BF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUsingUltimate;                                  // 0x11C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTheElevenKneel;                                   // 0x11C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTheElevenFire;                                    // 0x11C2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C3[0x1];                                     // 0x11C3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RootBoneRotation;                                  // 0x11C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootIKAlpha;                                       // 0x11C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimDynamicsAlpha;                                 // 0x11CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplySpreadShotAdditive;                          // 0x11D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11D1[0x3];                                     // 0x11D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpreadShotAdditiveAlpha;                           // 0x11D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyShieldLocomotionAdditive;                    // 0x11D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11D9[0x3];                                     // 0x11D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShieldLocomotionAdditiveAlpha;                     // 0x11DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            AimOffsetBlendSpace;                               // 0x11E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShieldHitReactA;                                  // 0x11E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShieldHitReactB;                                  // 0x11E9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShotGunSpreadIKToggle;                            // 0x11EA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11EB[0x1];                                     // 0x11EB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeftHandShotGunIKAlpha;                            // 0x11EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_ShieldAdditives_Default_To_Shield_Locomotion; // 0x11F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_ShieldAdditives_Shield_Locomotion_To_Default; // 0x11F1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11F2[0x6];                                     // 0x11F2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DisableLeftHandIKCurveName;                        // 0x11F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ShieldMontage;                                     // 0x1200(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ShieldKnockBackMontage;                            // 0x1208(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FireSlowMontage;                                   // 0x1210(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FireMedMontage;                                    // 0x1218(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FireFastMontage;                                   // 0x1220(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           TheElevenMontage;                                  // 0x1228(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           TazerTrapMontage;                                  // 0x1230(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SpreadShotFireRecoilMontage;                       // 0x1238(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            SpreadShotBlendSpace;                              // 0x1240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            UltimateBlendSpace;                                // 0x1248(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            ShieldBlendSpace;                                  // 0x1250(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            IdleBlendSpace;                                    // 0x1258(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AnimNotify_IK_HndShotGun_Off(const class UAnimNotify* AnimNotify);
	void AnimNotify_IK_HndShotGun_On(const class UAnimNotify* AnimNotify);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHeroPriceAnimInstance">();
	}
	static class UOrionHeroPriceAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHeroPriceAnimInstance>();
	}
};
static_assert(alignof(UOrionHeroPriceAnimInstance) == 0x000010, "Wrong alignment on UOrionHeroPriceAnimInstance");
static_assert(sizeof(UOrionHeroPriceAnimInstance) == 0x001260, "Wrong size on UOrionHeroPriceAnimInstance");
static_assert(offsetof(UOrionHeroPriceAnimInstance, LeftHandIKAlpha) == 0x0011B8, "Member 'UOrionHeroPriceAnimInstance::LeftHandIKAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroPriceAnimInstance, bIsInSpreadShotMode) == 0x0011BC, "Member 'UOrionHeroPriceAnimInstance::bIsInSpreadShotMode' has a wrong offset!");
static_assert(offsetof(UOrionHeroPriceAnimInstance, bHasSpreadShotFired) == 0x0011BD, "Member 'UOrionHeroPriceAnimInstance::bHasSpreadShotFired' has a wrong offset!");
static_assert(offsetof(UOrionHeroPriceAnimInstance, bIsInShieldMode) == 0x0011BE, "Member 'UOrionHeroPriceAnimInstance::bIsInShieldMode' has a wrong offset!");
static_assert(offsetof(UOrionHeroPriceAnimInstance, bIsShieldKnockBack) == 0x0011BF, "Member 'UOrionHeroPriceAnimInstance::bIsShieldKnockBack' has a wrong offset!");
static_assert(offsetof(UOrionHeroPriceAnimInstance, bIsUsingUltimate) == 0x0011C0, "Member 'UOrionHeroPriceAnimInstance::bIsUsingUltimate' has a wrong offset!");
static_assert(offsetof(UOrionHeroPriceAnimInstance, bTheElevenKneel) == 0x0011C1, "Member 'UOrionHeroPriceAnimInstance::bTheElevenKneel' has a wrong offset!");
static_assert(offsetof(UOrionHeroPriceAnimInstance, bTheElevenFire) == 0x0011C2, "Member 'UOrionHeroPriceAnimInstance::bTheElevenFire' has a wrong offset!");
static_assert(offsetof(UOrionHeroPriceAnimInstance, RootBoneRotation) == 0x0011C4, "Member 'UOrionHeroPriceAnimInstance::RootBoneRotation' has a wrong offset!");
static_assert(offsetof(UOrionHeroPriceAnimInstance, FootIKAlpha) == 0x0011C8, "Member 'UOrionHeroPriceAnimInstance::FootIKAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroPriceAnimInstance, AnimDynamicsAlpha) == 0x0011CC, "Member 'UOrionHeroPriceAnimInstance::AnimDynamicsAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroPriceAnimInstance, bApplySpreadShotAdditive) == 0x0011D0, "Member 'UOrionHeroPriceAnimInstance::bApplySpreadShotAdditive' has a wrong offset!");
static_assert(offsetof(UOrionHeroPriceAnimInstance, SpreadShotAdditiveAlpha) == 0x0011D4, "Member 'UOrionHeroPriceAnimInstance::SpreadShotAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroPriceAnimInstance, bApplyShieldLocomotionAdditive) == 0x0011D8, "Member 'UOrionHeroPriceAnimInstance::bApplyShieldLocomotionAdditive' has a wrong offset!");
static_assert(offsetof(UOrionHeroPriceAnimInstance, ShieldLocomotionAdditiveAlpha) == 0x0011DC, "Member 'UOrionHeroPriceAnimInstance::ShieldLocomotionAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroPriceAnimInstance, AimOffsetBlendSpace) == 0x0011E0, "Member 'UOrionHeroPriceAnimInstance::AimOffsetBlendSpace' has a wrong offset!");
static_assert(offsetof(UOrionHeroPriceAnimInstance, bShieldHitReactA) == 0x0011E8, "Member 'UOrionHeroPriceAnimInstance::bShieldHitReactA' has a wrong offset!");
static_assert(offsetof(UOrionHeroPriceAnimInstance, bShieldHitReactB) == 0x0011E9, "Member 'UOrionHeroPriceAnimInstance::bShieldHitReactB' has a wrong offset!");
static_assert(offsetof(UOrionHeroPriceAnimInstance, bShotGunSpreadIKToggle) == 0x0011EA, "Member 'UOrionHeroPriceAnimInstance::bShotGunSpreadIKToggle' has a wrong offset!");
static_assert(offsetof(UOrionHeroPriceAnimInstance, LeftHandShotGunIKAlpha) == 0x0011EC, "Member 'UOrionHeroPriceAnimInstance::LeftHandShotGunIKAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroPriceAnimInstance, bTransition_ShieldAdditives_Default_To_Shield_Locomotion) == 0x0011F0, "Member 'UOrionHeroPriceAnimInstance::bTransition_ShieldAdditives_Default_To_Shield_Locomotion' has a wrong offset!");
static_assert(offsetof(UOrionHeroPriceAnimInstance, bTransition_ShieldAdditives_Shield_Locomotion_To_Default) == 0x0011F1, "Member 'UOrionHeroPriceAnimInstance::bTransition_ShieldAdditives_Shield_Locomotion_To_Default' has a wrong offset!");
static_assert(offsetof(UOrionHeroPriceAnimInstance, DisableLeftHandIKCurveName) == 0x0011F8, "Member 'UOrionHeroPriceAnimInstance::DisableLeftHandIKCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroPriceAnimInstance, ShieldMontage) == 0x001200, "Member 'UOrionHeroPriceAnimInstance::ShieldMontage' has a wrong offset!");
static_assert(offsetof(UOrionHeroPriceAnimInstance, ShieldKnockBackMontage) == 0x001208, "Member 'UOrionHeroPriceAnimInstance::ShieldKnockBackMontage' has a wrong offset!");
static_assert(offsetof(UOrionHeroPriceAnimInstance, FireSlowMontage) == 0x001210, "Member 'UOrionHeroPriceAnimInstance::FireSlowMontage' has a wrong offset!");
static_assert(offsetof(UOrionHeroPriceAnimInstance, FireMedMontage) == 0x001218, "Member 'UOrionHeroPriceAnimInstance::FireMedMontage' has a wrong offset!");
static_assert(offsetof(UOrionHeroPriceAnimInstance, FireFastMontage) == 0x001220, "Member 'UOrionHeroPriceAnimInstance::FireFastMontage' has a wrong offset!");
static_assert(offsetof(UOrionHeroPriceAnimInstance, TheElevenMontage) == 0x001228, "Member 'UOrionHeroPriceAnimInstance::TheElevenMontage' has a wrong offset!");
static_assert(offsetof(UOrionHeroPriceAnimInstance, TazerTrapMontage) == 0x001230, "Member 'UOrionHeroPriceAnimInstance::TazerTrapMontage' has a wrong offset!");
static_assert(offsetof(UOrionHeroPriceAnimInstance, SpreadShotFireRecoilMontage) == 0x001238, "Member 'UOrionHeroPriceAnimInstance::SpreadShotFireRecoilMontage' has a wrong offset!");
static_assert(offsetof(UOrionHeroPriceAnimInstance, SpreadShotBlendSpace) == 0x001240, "Member 'UOrionHeroPriceAnimInstance::SpreadShotBlendSpace' has a wrong offset!");
static_assert(offsetof(UOrionHeroPriceAnimInstance, UltimateBlendSpace) == 0x001248, "Member 'UOrionHeroPriceAnimInstance::UltimateBlendSpace' has a wrong offset!");
static_assert(offsetof(UOrionHeroPriceAnimInstance, ShieldBlendSpace) == 0x001250, "Member 'UOrionHeroPriceAnimInstance::ShieldBlendSpace' has a wrong offset!");
static_assert(offsetof(UOrionHeroPriceAnimInstance, IdleBlendSpace) == 0x001258, "Member 'UOrionHeroPriceAnimInstance::IdleBlendSpace' has a wrong offset!");

// Class OrionGame.OrionHeroRampageAnimInstance
// 0x0020 (0x11E0 - 0x11C0)
class UOrionHeroRampageAnimInstance final : public UOrionHeroAnimInstance
{
public:
	float                                         LeanLayerBlendWeight;                              // 0x11B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HandIKAlpha;                                       // 0x11BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDoingMeleeAttack;                               // 0x11C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDoingAirAttack;                                 // 0x11C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C2[0x2];                                     // 0x11C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FrillsOverrideWeight;                              // 0x11C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldBypassFrillsPostProcess;                     // 0x11C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRoarBuffed;                                     // 0x11C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDoingRipNToss;                                  // 0x11CA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRipNTossCasting;                                // 0x11CB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRipNTossPreCast;                                // 0x11CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRipNTossHold;                                   // 0x11CD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDoingUlt;                                       // 0x11CE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11CF[0x1];                                     // 0x11CF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                UltRootScale;                                      // 0x11D0(0x000C)(Edit, BlueprintVisible, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RootScaleAlpha;                                    // 0x11DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHeroRampageAnimInstance">();
	}
	static class UOrionHeroRampageAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHeroRampageAnimInstance>();
	}
};
static_assert(alignof(UOrionHeroRampageAnimInstance) == 0x000010, "Wrong alignment on UOrionHeroRampageAnimInstance");
static_assert(sizeof(UOrionHeroRampageAnimInstance) == 0x0011E0, "Wrong size on UOrionHeroRampageAnimInstance");
static_assert(offsetof(UOrionHeroRampageAnimInstance, LeanLayerBlendWeight) == 0x0011B8, "Member 'UOrionHeroRampageAnimInstance::LeanLayerBlendWeight' has a wrong offset!");
static_assert(offsetof(UOrionHeroRampageAnimInstance, HandIKAlpha) == 0x0011BC, "Member 'UOrionHeroRampageAnimInstance::HandIKAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroRampageAnimInstance, bIsDoingMeleeAttack) == 0x0011C0, "Member 'UOrionHeroRampageAnimInstance::bIsDoingMeleeAttack' has a wrong offset!");
static_assert(offsetof(UOrionHeroRampageAnimInstance, bIsDoingAirAttack) == 0x0011C1, "Member 'UOrionHeroRampageAnimInstance::bIsDoingAirAttack' has a wrong offset!");
static_assert(offsetof(UOrionHeroRampageAnimInstance, FrillsOverrideWeight) == 0x0011C4, "Member 'UOrionHeroRampageAnimInstance::FrillsOverrideWeight' has a wrong offset!");
static_assert(offsetof(UOrionHeroRampageAnimInstance, ShouldBypassFrillsPostProcess) == 0x0011C8, "Member 'UOrionHeroRampageAnimInstance::ShouldBypassFrillsPostProcess' has a wrong offset!");
static_assert(offsetof(UOrionHeroRampageAnimInstance, bIsRoarBuffed) == 0x0011C9, "Member 'UOrionHeroRampageAnimInstance::bIsRoarBuffed' has a wrong offset!");
static_assert(offsetof(UOrionHeroRampageAnimInstance, bIsDoingRipNToss) == 0x0011CA, "Member 'UOrionHeroRampageAnimInstance::bIsDoingRipNToss' has a wrong offset!");
static_assert(offsetof(UOrionHeroRampageAnimInstance, bIsRipNTossCasting) == 0x0011CB, "Member 'UOrionHeroRampageAnimInstance::bIsRipNTossCasting' has a wrong offset!");
static_assert(offsetof(UOrionHeroRampageAnimInstance, bIsRipNTossPreCast) == 0x0011CC, "Member 'UOrionHeroRampageAnimInstance::bIsRipNTossPreCast' has a wrong offset!");
static_assert(offsetof(UOrionHeroRampageAnimInstance, bIsRipNTossHold) == 0x0011CD, "Member 'UOrionHeroRampageAnimInstance::bIsRipNTossHold' has a wrong offset!");
static_assert(offsetof(UOrionHeroRampageAnimInstance, bIsDoingUlt) == 0x0011CE, "Member 'UOrionHeroRampageAnimInstance::bIsDoingUlt' has a wrong offset!");
static_assert(offsetof(UOrionHeroRampageAnimInstance, UltRootScale) == 0x0011D0, "Member 'UOrionHeroRampageAnimInstance::UltRootScale' has a wrong offset!");
static_assert(offsetof(UOrionHeroRampageAnimInstance, RootScaleAlpha) == 0x0011DC, "Member 'UOrionHeroRampageAnimInstance::RootScaleAlpha' has a wrong offset!");

// Class OrionGame.OrionHeroRiftmageAnimInstance
// 0x00D0 (0x1290 - 0x11C0)
class UOrionHeroRiftmageAnimInstance final : public UOrionHeroAnimInstance
{
public:
	struct FFloatRK4SpringInterpolator            UltimateRingInterpolator;                          // 0x11B8(0x0008)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C0[0x1C];                                    // 0x11C0(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UltimateRingAlpha;                                 // 0x11DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundSlopeWarpingAlpha;                           // 0x11E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TravelModeSlopeWarpingAlpha;                       // 0x11E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TravelModeHandLookAtTarget;                        // 0x11E8(0x000C)(Edit, BlueprintVisible, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVectorRK4SpringInterpolator           TravelModeHandLookAtTargetInterpolator;            // 0x11F4(0x0008)(Edit, BlueprintVisible, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11FC[0x34];                                    // 0x11FC(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TravelModeHandLookAtAlpha;                         // 0x1230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRK4SpringInterpolator            TravelModeHandLookAtAlphaInterpolator;             // 0x1234(0x0008)(Edit, BlueprintVisible, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_123C[0x1C];                                    // 0x123C(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TravelModeLookAtTargetMaxDistance;                 // 0x1258(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRK4SpringInterpolator            TravelModeRotationRateInterpolator;                // 0x125C(0x0008)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1264[0x1C];                                    // 0x1264(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TravelModeMaxRotationRate;                         // 0x1280(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TravelModeSmoothedRotationRate;                    // 0x1284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1288[0x8];                                     // 0x1288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHeroRiftmageAnimInstance">();
	}
	static class UOrionHeroRiftmageAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHeroRiftmageAnimInstance>();
	}
};
static_assert(alignof(UOrionHeroRiftmageAnimInstance) == 0x000010, "Wrong alignment on UOrionHeroRiftmageAnimInstance");
static_assert(sizeof(UOrionHeroRiftmageAnimInstance) == 0x001290, "Wrong size on UOrionHeroRiftmageAnimInstance");
static_assert(offsetof(UOrionHeroRiftmageAnimInstance, UltimateRingInterpolator) == 0x0011B8, "Member 'UOrionHeroRiftmageAnimInstance::UltimateRingInterpolator' has a wrong offset!");
static_assert(offsetof(UOrionHeroRiftmageAnimInstance, UltimateRingAlpha) == 0x0011DC, "Member 'UOrionHeroRiftmageAnimInstance::UltimateRingAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroRiftmageAnimInstance, GroundSlopeWarpingAlpha) == 0x0011E0, "Member 'UOrionHeroRiftmageAnimInstance::GroundSlopeWarpingAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroRiftmageAnimInstance, TravelModeSlopeWarpingAlpha) == 0x0011E4, "Member 'UOrionHeroRiftmageAnimInstance::TravelModeSlopeWarpingAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroRiftmageAnimInstance, TravelModeHandLookAtTarget) == 0x0011E8, "Member 'UOrionHeroRiftmageAnimInstance::TravelModeHandLookAtTarget' has a wrong offset!");
static_assert(offsetof(UOrionHeroRiftmageAnimInstance, TravelModeHandLookAtTargetInterpolator) == 0x0011F4, "Member 'UOrionHeroRiftmageAnimInstance::TravelModeHandLookAtTargetInterpolator' has a wrong offset!");
static_assert(offsetof(UOrionHeroRiftmageAnimInstance, TravelModeHandLookAtAlpha) == 0x001230, "Member 'UOrionHeroRiftmageAnimInstance::TravelModeHandLookAtAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroRiftmageAnimInstance, TravelModeHandLookAtAlphaInterpolator) == 0x001234, "Member 'UOrionHeroRiftmageAnimInstance::TravelModeHandLookAtAlphaInterpolator' has a wrong offset!");
static_assert(offsetof(UOrionHeroRiftmageAnimInstance, TravelModeLookAtTargetMaxDistance) == 0x001258, "Member 'UOrionHeroRiftmageAnimInstance::TravelModeLookAtTargetMaxDistance' has a wrong offset!");
static_assert(offsetof(UOrionHeroRiftmageAnimInstance, TravelModeRotationRateInterpolator) == 0x00125C, "Member 'UOrionHeroRiftmageAnimInstance::TravelModeRotationRateInterpolator' has a wrong offset!");
static_assert(offsetof(UOrionHeroRiftmageAnimInstance, TravelModeMaxRotationRate) == 0x001280, "Member 'UOrionHeroRiftmageAnimInstance::TravelModeMaxRotationRate' has a wrong offset!");
static_assert(offsetof(UOrionHeroRiftmageAnimInstance, TravelModeSmoothedRotationRate) == 0x001284, "Member 'UOrionHeroRiftmageAnimInstance::TravelModeSmoothedRotationRate' has a wrong offset!");

// Class OrionGame.OrionHeroSparrowAnimInstance
// 0x0030 (0x11F0 - 0x11C0)
class UOrionHeroSparrowAnimInstance final : public UOrionHeroAnimInstance
{
public:
	bool                                          bIsQTargetingActive;                               // 0x11B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUltimateActive;                                 // 0x11B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11BA[0x6];                                     // 0x11BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TravelModeCorrectiveOverrideCurveName;             // 0x11C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TravelModeCorrectiveTargetWeight;                  // 0x11C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TravelModeCorrectiveAlpha;                         // 0x11CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TravelModeCorrectiveWeight;                        // 0x11D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraveModeLocomotionDeltaAngle_E;                   // 0x11D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraveModeLocomotionDeltaAngle_W;                   // 0x11D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraveModeLocomotionYawAimOffset_E;                 // 0x11DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraveModeLocomotionYawAimOffset_W;                 // 0x11E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BowStringCopyBoneAlpha;                            // 0x11E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArrowLookAtAlpha;                                  // 0x11E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11EC[0x4];                                     // 0x11EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHeroSparrowAnimInstance">();
	}
	static class UOrionHeroSparrowAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHeroSparrowAnimInstance>();
	}
};
static_assert(alignof(UOrionHeroSparrowAnimInstance) == 0x000010, "Wrong alignment on UOrionHeroSparrowAnimInstance");
static_assert(sizeof(UOrionHeroSparrowAnimInstance) == 0x0011F0, "Wrong size on UOrionHeroSparrowAnimInstance");
static_assert(offsetof(UOrionHeroSparrowAnimInstance, bIsQTargetingActive) == 0x0011B8, "Member 'UOrionHeroSparrowAnimInstance::bIsQTargetingActive' has a wrong offset!");
static_assert(offsetof(UOrionHeroSparrowAnimInstance, bIsUltimateActive) == 0x0011B9, "Member 'UOrionHeroSparrowAnimInstance::bIsUltimateActive' has a wrong offset!");
static_assert(offsetof(UOrionHeroSparrowAnimInstance, TravelModeCorrectiveOverrideCurveName) == 0x0011C0, "Member 'UOrionHeroSparrowAnimInstance::TravelModeCorrectiveOverrideCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroSparrowAnimInstance, TravelModeCorrectiveTargetWeight) == 0x0011C8, "Member 'UOrionHeroSparrowAnimInstance::TravelModeCorrectiveTargetWeight' has a wrong offset!");
static_assert(offsetof(UOrionHeroSparrowAnimInstance, TravelModeCorrectiveAlpha) == 0x0011CC, "Member 'UOrionHeroSparrowAnimInstance::TravelModeCorrectiveAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroSparrowAnimInstance, TravelModeCorrectiveWeight) == 0x0011D0, "Member 'UOrionHeroSparrowAnimInstance::TravelModeCorrectiveWeight' has a wrong offset!");
static_assert(offsetof(UOrionHeroSparrowAnimInstance, TraveModeLocomotionDeltaAngle_E) == 0x0011D4, "Member 'UOrionHeroSparrowAnimInstance::TraveModeLocomotionDeltaAngle_E' has a wrong offset!");
static_assert(offsetof(UOrionHeroSparrowAnimInstance, TraveModeLocomotionDeltaAngle_W) == 0x0011D8, "Member 'UOrionHeroSparrowAnimInstance::TraveModeLocomotionDeltaAngle_W' has a wrong offset!");
static_assert(offsetof(UOrionHeroSparrowAnimInstance, TraveModeLocomotionYawAimOffset_E) == 0x0011DC, "Member 'UOrionHeroSparrowAnimInstance::TraveModeLocomotionYawAimOffset_E' has a wrong offset!");
static_assert(offsetof(UOrionHeroSparrowAnimInstance, TraveModeLocomotionYawAimOffset_W) == 0x0011E0, "Member 'UOrionHeroSparrowAnimInstance::TraveModeLocomotionYawAimOffset_W' has a wrong offset!");
static_assert(offsetof(UOrionHeroSparrowAnimInstance, BowStringCopyBoneAlpha) == 0x0011E4, "Member 'UOrionHeroSparrowAnimInstance::BowStringCopyBoneAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroSparrowAnimInstance, ArrowLookAtAlpha) == 0x0011E8, "Member 'UOrionHeroSparrowAnimInstance::ArrowLookAtAlpha' has a wrong offset!");

// Class OrionGame.OrionHeroSwordAnimInstance
// 0x0010 (0x11D0 - 0x11C0)
class UOrionHeroSwordAnimInstance final : public UOrionHeroAnimInstance
{
public:
	float                                         AnimDynamicsAlpha;                                 // 0x11B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimDynamicsAlpha_0_7;                             // 0x11BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimDynamicsAlpha_0_5;                             // 0x11C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C4[0x4];                                     // 0x11C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DisableAnimDynamicsCurveName;                      // 0x11C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHeroSwordAnimInstance">();
	}
	static class UOrionHeroSwordAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHeroSwordAnimInstance>();
	}
};
static_assert(alignof(UOrionHeroSwordAnimInstance) == 0x000010, "Wrong alignment on UOrionHeroSwordAnimInstance");
static_assert(sizeof(UOrionHeroSwordAnimInstance) == 0x0011D0, "Wrong size on UOrionHeroSwordAnimInstance");
static_assert(offsetof(UOrionHeroSwordAnimInstance, AnimDynamicsAlpha) == 0x0011B8, "Member 'UOrionHeroSwordAnimInstance::AnimDynamicsAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroSwordAnimInstance, AnimDynamicsAlpha_0_7) == 0x0011BC, "Member 'UOrionHeroSwordAnimInstance::AnimDynamicsAlpha_0_7' has a wrong offset!");
static_assert(offsetof(UOrionHeroSwordAnimInstance, AnimDynamicsAlpha_0_5) == 0x0011C0, "Member 'UOrionHeroSwordAnimInstance::AnimDynamicsAlpha_0_5' has a wrong offset!");
static_assert(offsetof(UOrionHeroSwordAnimInstance, DisableAnimDynamicsCurveName) == 0x0011C8, "Member 'UOrionHeroSwordAnimInstance::DisableAnimDynamicsCurveName' has a wrong offset!");

// Class OrionGame.OrionHeroTacticiaAnimInstance
// 0x0040 (0x1200 - 0x11C0)
class UOrionHeroTacticiaAnimInstance final : public UOrionHeroAnimInstance
{
public:
	class FName                                   DisableRightHandIKCurveName;                       // 0x11B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DisableLeftHandIKCurveName;                        // 0x11C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UltPistolOnCurveName;                              // 0x11C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HologramAlphaCurveName;                            // 0x11D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightHandIKAlpha;                                  // 0x11D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftHandIKAlpha;                                   // 0x11DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PistolInHolsterAlpha;                              // 0x11E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HologramHiddenAlpha;                               // 0x11E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinusAimOffsetPitch;                               // 0x11E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinusAimOffsetYaw;                                 // 0x11EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollarDynamicsAlpha;                               // 0x11F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShoulderDynamicsAlpha;                             // 0x11F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponThighAlpha;                                  // 0x11F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11FC[0x4];                                     // 0x11FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHeroTacticiaAnimInstance">();
	}
	static class UOrionHeroTacticiaAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHeroTacticiaAnimInstance>();
	}
};
static_assert(alignof(UOrionHeroTacticiaAnimInstance) == 0x000010, "Wrong alignment on UOrionHeroTacticiaAnimInstance");
static_assert(sizeof(UOrionHeroTacticiaAnimInstance) == 0x001200, "Wrong size on UOrionHeroTacticiaAnimInstance");
static_assert(offsetof(UOrionHeroTacticiaAnimInstance, DisableRightHandIKCurveName) == 0x0011B8, "Member 'UOrionHeroTacticiaAnimInstance::DisableRightHandIKCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroTacticiaAnimInstance, DisableLeftHandIKCurveName) == 0x0011C0, "Member 'UOrionHeroTacticiaAnimInstance::DisableLeftHandIKCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroTacticiaAnimInstance, UltPistolOnCurveName) == 0x0011C8, "Member 'UOrionHeroTacticiaAnimInstance::UltPistolOnCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroTacticiaAnimInstance, HologramAlphaCurveName) == 0x0011D0, "Member 'UOrionHeroTacticiaAnimInstance::HologramAlphaCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroTacticiaAnimInstance, RightHandIKAlpha) == 0x0011D8, "Member 'UOrionHeroTacticiaAnimInstance::RightHandIKAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroTacticiaAnimInstance, LeftHandIKAlpha) == 0x0011DC, "Member 'UOrionHeroTacticiaAnimInstance::LeftHandIKAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroTacticiaAnimInstance, PistolInHolsterAlpha) == 0x0011E0, "Member 'UOrionHeroTacticiaAnimInstance::PistolInHolsterAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroTacticiaAnimInstance, HologramHiddenAlpha) == 0x0011E4, "Member 'UOrionHeroTacticiaAnimInstance::HologramHiddenAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroTacticiaAnimInstance, MinusAimOffsetPitch) == 0x0011E8, "Member 'UOrionHeroTacticiaAnimInstance::MinusAimOffsetPitch' has a wrong offset!");
static_assert(offsetof(UOrionHeroTacticiaAnimInstance, MinusAimOffsetYaw) == 0x0011EC, "Member 'UOrionHeroTacticiaAnimInstance::MinusAimOffsetYaw' has a wrong offset!");
static_assert(offsetof(UOrionHeroTacticiaAnimInstance, CollarDynamicsAlpha) == 0x0011F0, "Member 'UOrionHeroTacticiaAnimInstance::CollarDynamicsAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroTacticiaAnimInstance, ShoulderDynamicsAlpha) == 0x0011F4, "Member 'UOrionHeroTacticiaAnimInstance::ShoulderDynamicsAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroTacticiaAnimInstance, WeaponThighAlpha) == 0x0011F8, "Member 'UOrionHeroTacticiaAnimInstance::WeaponThighAlpha' has a wrong offset!");

// Class OrionGame.OrionHeroTotemAnimInstance
// 0x0030 (0x11F0 - 0x11C0)
class UOrionHeroTotemAnimInstance final : public UOrionHeroAnimInstance
{
public:
	class FName                                   TravelModeCorrectiveOverrideCurveName;             // 0x11B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TravelModeCorrectiveTargetWeight;                  // 0x11C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TravelModeCorrectiveAlpha;                         // 0x11C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TravelModeCorrectiveWeight;                        // 0x11C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraveModeLocomotionDeltaAngle_E;                   // 0x11CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraveModeLocomotionDeltaAngle_W;                   // 0x11D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraveModeLocomotionYawAimOffset_E;                 // 0x11D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraveModeLocomotionYawAimOffset_W;                 // 0x11D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LHandIKAlpha;                                      // 0x11DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsQTargetingActive;                               // 0x11E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRocketBootsActive;                              // 0x11E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11E2[0xE];                                     // 0x11E2(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHeroTotemAnimInstance">();
	}
	static class UOrionHeroTotemAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHeroTotemAnimInstance>();
	}
};
static_assert(alignof(UOrionHeroTotemAnimInstance) == 0x000010, "Wrong alignment on UOrionHeroTotemAnimInstance");
static_assert(sizeof(UOrionHeroTotemAnimInstance) == 0x0011F0, "Wrong size on UOrionHeroTotemAnimInstance");
static_assert(offsetof(UOrionHeroTotemAnimInstance, TravelModeCorrectiveOverrideCurveName) == 0x0011B8, "Member 'UOrionHeroTotemAnimInstance::TravelModeCorrectiveOverrideCurveName' has a wrong offset!");
static_assert(offsetof(UOrionHeroTotemAnimInstance, TravelModeCorrectiveTargetWeight) == 0x0011C0, "Member 'UOrionHeroTotemAnimInstance::TravelModeCorrectiveTargetWeight' has a wrong offset!");
static_assert(offsetof(UOrionHeroTotemAnimInstance, TravelModeCorrectiveAlpha) == 0x0011C4, "Member 'UOrionHeroTotemAnimInstance::TravelModeCorrectiveAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroTotemAnimInstance, TravelModeCorrectiveWeight) == 0x0011C8, "Member 'UOrionHeroTotemAnimInstance::TravelModeCorrectiveWeight' has a wrong offset!");
static_assert(offsetof(UOrionHeroTotemAnimInstance, TraveModeLocomotionDeltaAngle_E) == 0x0011CC, "Member 'UOrionHeroTotemAnimInstance::TraveModeLocomotionDeltaAngle_E' has a wrong offset!");
static_assert(offsetof(UOrionHeroTotemAnimInstance, TraveModeLocomotionDeltaAngle_W) == 0x0011D0, "Member 'UOrionHeroTotemAnimInstance::TraveModeLocomotionDeltaAngle_W' has a wrong offset!");
static_assert(offsetof(UOrionHeroTotemAnimInstance, TraveModeLocomotionYawAimOffset_E) == 0x0011D4, "Member 'UOrionHeroTotemAnimInstance::TraveModeLocomotionYawAimOffset_E' has a wrong offset!");
static_assert(offsetof(UOrionHeroTotemAnimInstance, TraveModeLocomotionYawAimOffset_W) == 0x0011D8, "Member 'UOrionHeroTotemAnimInstance::TraveModeLocomotionYawAimOffset_W' has a wrong offset!");
static_assert(offsetof(UOrionHeroTotemAnimInstance, LHandIKAlpha) == 0x0011DC, "Member 'UOrionHeroTotemAnimInstance::LHandIKAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroTotemAnimInstance, bIsQTargetingActive) == 0x0011E0, "Member 'UOrionHeroTotemAnimInstance::bIsQTargetingActive' has a wrong offset!");
static_assert(offsetof(UOrionHeroTotemAnimInstance, bIsRocketBootsActive) == 0x0011E1, "Member 'UOrionHeroTotemAnimInstance::bIsRocketBootsActive' has a wrong offset!");

// Class OrionGame.OrionHeroVampAnimInstance
// 0x0010 (0x11D0 - 0x11C0)
class UOrionHeroVampAnimInstance final : public UOrionHeroAnimInstance
{
public:
	bool                                          bLocalSpaceUpperBodyLayer;                         // 0x11B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayingUltimateMontage;                           // 0x11B9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11BA[0x2];                                     // 0x11BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LockSwordsOnBackAlpha;                             // 0x11BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TravelModeLockCurveName;                           // 0x11C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C8[0x8];                                     // 0x11C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHeroVampAnimInstance">();
	}
	static class UOrionHeroVampAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHeroVampAnimInstance>();
	}
};
static_assert(alignof(UOrionHeroVampAnimInstance) == 0x000010, "Wrong alignment on UOrionHeroVampAnimInstance");
static_assert(sizeof(UOrionHeroVampAnimInstance) == 0x0011D0, "Wrong size on UOrionHeroVampAnimInstance");
static_assert(offsetof(UOrionHeroVampAnimInstance, bLocalSpaceUpperBodyLayer) == 0x0011B8, "Member 'UOrionHeroVampAnimInstance::bLocalSpaceUpperBodyLayer' has a wrong offset!");
static_assert(offsetof(UOrionHeroVampAnimInstance, bPlayingUltimateMontage) == 0x0011B9, "Member 'UOrionHeroVampAnimInstance::bPlayingUltimateMontage' has a wrong offset!");
static_assert(offsetof(UOrionHeroVampAnimInstance, LockSwordsOnBackAlpha) == 0x0011BC, "Member 'UOrionHeroVampAnimInstance::LockSwordsOnBackAlpha' has a wrong offset!");
static_assert(offsetof(UOrionHeroVampAnimInstance, TravelModeLockCurveName) == 0x0011C0, "Member 'UOrionHeroVampAnimInstance::TravelModeLockCurveName' has a wrong offset!");

// Class OrionGame.OrionHeroWardrumAnimInstance
// 0x0010 (0x11D0 - 0x11C0)
class UOrionHeroWardrumAnimInstance final : public UOrionHeroAnimInstance
{
public:
	bool                                          bTriggerEAbility;                                  // 0x11B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEarlyOutEAbility;                                 // 0x11B9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11BA[0x2];                                     // 0x11BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EAbilityCounter;                                   // 0x11BC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EAbilityDelayBetweenTriggers;                      // 0x11C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C4[0xC];                                     // 0x11C4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHeroWardrumAnimInstance">();
	}
	static class UOrionHeroWardrumAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHeroWardrumAnimInstance>();
	}
};
static_assert(alignof(UOrionHeroWardrumAnimInstance) == 0x000010, "Wrong alignment on UOrionHeroWardrumAnimInstance");
static_assert(sizeof(UOrionHeroWardrumAnimInstance) == 0x0011D0, "Wrong size on UOrionHeroWardrumAnimInstance");
static_assert(offsetof(UOrionHeroWardrumAnimInstance, bTriggerEAbility) == 0x0011B8, "Member 'UOrionHeroWardrumAnimInstance::bTriggerEAbility' has a wrong offset!");
static_assert(offsetof(UOrionHeroWardrumAnimInstance, bEarlyOutEAbility) == 0x0011B9, "Member 'UOrionHeroWardrumAnimInstance::bEarlyOutEAbility' has a wrong offset!");
static_assert(offsetof(UOrionHeroWardrumAnimInstance, EAbilityCounter) == 0x0011BC, "Member 'UOrionHeroWardrumAnimInstance::EAbilityCounter' has a wrong offset!");
static_assert(offsetof(UOrionHeroWardrumAnimInstance, EAbilityDelayBetweenTriggers) == 0x0011C0, "Member 'UOrionHeroWardrumAnimInstance::EAbilityDelayBetweenTriggers' has a wrong offset!");

// Class OrionGame.OrionHighlightsLibrary
// 0x0000 (0x0028 - 0x0028)
class UOrionHighlightsLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void GetNumHighlights(TDelegate<void(int32 NumHighlights)> Callback);
	static void OpenHighlightSummary(class UObject* Context);
	static void TriggerHighlight(class FName HighlightTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHighlightsLibrary">();
	}
	static class UOrionHighlightsLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHighlightsLibrary>();
	}
};
static_assert(alignof(UOrionHighlightsLibrary) == 0x000008, "Wrong alignment on UOrionHighlightsLibrary");
static_assert(sizeof(UOrionHighlightsLibrary) == 0x000028, "Wrong size on UOrionHighlightsLibrary");

// Class OrionGame.GetNumHighlightsUICallbackProxy
// 0x0010 (0x0038 - 0x0028)
class UGetNumHighlightsUICallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnComplete;                                        // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UGetNumHighlightsUICallbackProxy* GetNumHighlights();

	void OnGetNumHighlightsComplete(int32 Count);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GetNumHighlightsUICallbackProxy">();
	}
	static class UGetNumHighlightsUICallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGetNumHighlightsUICallbackProxy>();
	}
};
static_assert(alignof(UGetNumHighlightsUICallbackProxy) == 0x000008, "Wrong alignment on UGetNumHighlightsUICallbackProxy");
static_assert(sizeof(UGetNumHighlightsUICallbackProxy) == 0x000038, "Wrong size on UGetNumHighlightsUICallbackProxy");
static_assert(offsetof(UGetNumHighlightsUICallbackProxy, OnComplete) == 0x000028, "Member 'UGetNumHighlightsUICallbackProxy::OnComplete' has a wrong offset!");

// Class OrionGame.OrionHotfixManager
// 0x0000 (0x03D0 - 0x03D0)
class UOrionHotfixManager final : public UOnlineHotfixManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHotfixManager">();
	}
	static class UOrionHotfixManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHotfixManager>();
	}
};
static_assert(alignof(UOrionHotfixManager) == 0x000008, "Wrong alignment on UOrionHotfixManager");
static_assert(sizeof(UOrionHotfixManager) == 0x0003D0, "Wrong size on UOrionHotfixManager");

// Class OrionGame.OrionReplaySpectatorCameraComponent
// 0x0070 (0x0890 - 0x0820)
class UOrionReplaySpectatorCameraComponent : public UCameraComponent
{
public:
	class AOrionReplaySpectator*                  SpectatorController;                               // 0x0820(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrionPlayerController_Game*            DeadPlayerController;                              // 0x0828(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_830[0xC];                                      // 0x0830(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	EFocusMethod                                  FocusMethod;                                       // 0x083C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_83D[0x3];                                      // 0x083D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ManualFocusDistance;                               // 0x0840(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AutoFocusInterpSpeed;                              // 0x0844(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraApertureFStop;                               // 0x0848(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_84C[0x4];                                      // 0x084C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           ScreenFringeFOVCurve;                              // 0x0850(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ZoomRate;                                          // 0x0858(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FOVInterpSpeed;                                    // 0x085C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxFOV;                                            // 0x0860(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinFOV;                                            // 0x0864(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_868[0x28];                                     // 0x0868(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionReplaySpectatorCameraComponent">();
	}
	static class UOrionReplaySpectatorCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionReplaySpectatorCameraComponent>();
	}
};
static_assert(alignof(UOrionReplaySpectatorCameraComponent) == 0x000010, "Wrong alignment on UOrionReplaySpectatorCameraComponent");
static_assert(sizeof(UOrionReplaySpectatorCameraComponent) == 0x000890, "Wrong size on UOrionReplaySpectatorCameraComponent");
static_assert(offsetof(UOrionReplaySpectatorCameraComponent, SpectatorController) == 0x000820, "Member 'UOrionReplaySpectatorCameraComponent::SpectatorController' has a wrong offset!");
static_assert(offsetof(UOrionReplaySpectatorCameraComponent, DeadPlayerController) == 0x000828, "Member 'UOrionReplaySpectatorCameraComponent::DeadPlayerController' has a wrong offset!");
static_assert(offsetof(UOrionReplaySpectatorCameraComponent, FocusMethod) == 0x00083C, "Member 'UOrionReplaySpectatorCameraComponent::FocusMethod' has a wrong offset!");
static_assert(offsetof(UOrionReplaySpectatorCameraComponent, ManualFocusDistance) == 0x000840, "Member 'UOrionReplaySpectatorCameraComponent::ManualFocusDistance' has a wrong offset!");
static_assert(offsetof(UOrionReplaySpectatorCameraComponent, AutoFocusInterpSpeed) == 0x000844, "Member 'UOrionReplaySpectatorCameraComponent::AutoFocusInterpSpeed' has a wrong offset!");
static_assert(offsetof(UOrionReplaySpectatorCameraComponent, CameraApertureFStop) == 0x000848, "Member 'UOrionReplaySpectatorCameraComponent::CameraApertureFStop' has a wrong offset!");
static_assert(offsetof(UOrionReplaySpectatorCameraComponent, ScreenFringeFOVCurve) == 0x000850, "Member 'UOrionReplaySpectatorCameraComponent::ScreenFringeFOVCurve' has a wrong offset!");
static_assert(offsetof(UOrionReplaySpectatorCameraComponent, ZoomRate) == 0x000858, "Member 'UOrionReplaySpectatorCameraComponent::ZoomRate' has a wrong offset!");
static_assert(offsetof(UOrionReplaySpectatorCameraComponent, FOVInterpSpeed) == 0x00085C, "Member 'UOrionReplaySpectatorCameraComponent::FOVInterpSpeed' has a wrong offset!");
static_assert(offsetof(UOrionReplaySpectatorCameraComponent, MaxFOV) == 0x000860, "Member 'UOrionReplaySpectatorCameraComponent::MaxFOV' has a wrong offset!");
static_assert(offsetof(UOrionReplaySpectatorCameraComponent, MinFOV) == 0x000864, "Member 'UOrionReplaySpectatorCameraComponent::MinFOV' has a wrong offset!");

// Class OrionGame.OrionHoverDroneCameraComponent
// 0x0020 (0x08B0 - 0x0890)
class UOrionHoverDroneCameraComponent final : public UOrionReplaySpectatorCameraComponent
{
public:
	float                                         DroneTiltInterpSpeed_Accel;                        // 0x0890(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DroneTiltInterpSpeed_Decel;                        // 0x0894(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_898[0xC];                                      // 0x0898(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TiltUpVector;                                      // 0x08A4(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHoverDroneCameraComponent">();
	}
	static class UOrionHoverDroneCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHoverDroneCameraComponent>();
	}
};
static_assert(alignof(UOrionHoverDroneCameraComponent) == 0x000010, "Wrong alignment on UOrionHoverDroneCameraComponent");
static_assert(sizeof(UOrionHoverDroneCameraComponent) == 0x0008B0, "Wrong size on UOrionHoverDroneCameraComponent");
static_assert(offsetof(UOrionHoverDroneCameraComponent, DroneTiltInterpSpeed_Accel) == 0x000890, "Member 'UOrionHoverDroneCameraComponent::DroneTiltInterpSpeed_Accel' has a wrong offset!");
static_assert(offsetof(UOrionHoverDroneCameraComponent, DroneTiltInterpSpeed_Decel) == 0x000894, "Member 'UOrionHoverDroneCameraComponent::DroneTiltInterpSpeed_Decel' has a wrong offset!");
static_assert(offsetof(UOrionHoverDroneCameraComponent, TiltUpVector) == 0x0008A4, "Member 'UOrionHoverDroneCameraComponent::TiltUpVector' has a wrong offset!");

// Class OrionGame.OrionHUDDisplayData
// 0x0290 (0x02C0 - 0x0030)
class UOrionHUDDisplayData final : public UDataAsset
{
public:
	int32                                         PlayerDisparityRequiredForAdvantage;               // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumAdvantageDurationRequiredForNotification;   // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RequiredTimeWithoutAnyDeathsBeforeAdvantageMessage; // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             AdvantageIcon;                                     // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnerCountdownAlertThreshold;                    // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   OuterTowerName;                                    // 0x0050(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   OuterTowerTeamFormat;                              // 0x0068(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   OuterTowerDestroyedMessageFormat;                  // 0x0080(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   InnerTowerName;                                    // 0x0098(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   InnerTowerTeamFormat;                              // 0x00B0(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   InnerTowerDestroyedMessageFormat;                  // 0x00C8(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   InhibitorName;                                     // 0x00E0(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   InhibitorTeamFormat;                               // 0x00F8(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   InhibitorDestroyedMessageFormat;                   // 0x0110(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   CoreName;                                          // 0x0128(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   CoreTeamFormat;                                    // 0x0140(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   CoreDestroyedMessageFormat;                        // 0x0158(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   DefaultTowerName;                                  // 0x0170(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   OfflaneName;                                       // 0x0188(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   MidlaneName;                                       // 0x01A0(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   SafelaneName;                                      // 0x01B8(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTexture2D*                             InnerTowerIcon;                                    // 0x01D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             OuterTowerIcon;                                    // 0x01D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             InhibitorIcon;                                     // 0x01E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              OrbPrimePortrait;                                  // 0x01E8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   OrbPrimeKilledTitleText;                           // 0x0210(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   OrbPrimeKilledDescription;                         // 0x0228(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              DragonPortrait;                                    // 0x0240(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DragonKillTitleText;                               // 0x0268(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FText>                           DragonBuffDescriptions;                            // 0x0280(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class FText                                   FriendDescriptor;                                  // 0x0290(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class FText                                   EnemyDescriptor;                                   // 0x02A8(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHUDDisplayData">();
	}
	static class UOrionHUDDisplayData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHUDDisplayData>();
	}
};
static_assert(alignof(UOrionHUDDisplayData) == 0x000008, "Wrong alignment on UOrionHUDDisplayData");
static_assert(sizeof(UOrionHUDDisplayData) == 0x0002C0, "Wrong size on UOrionHUDDisplayData");
static_assert(offsetof(UOrionHUDDisplayData, PlayerDisparityRequiredForAdvantage) == 0x000030, "Member 'UOrionHUDDisplayData::PlayerDisparityRequiredForAdvantage' has a wrong offset!");
static_assert(offsetof(UOrionHUDDisplayData, MinimumAdvantageDurationRequiredForNotification) == 0x000034, "Member 'UOrionHUDDisplayData::MinimumAdvantageDurationRequiredForNotification' has a wrong offset!");
static_assert(offsetof(UOrionHUDDisplayData, RequiredTimeWithoutAnyDeathsBeforeAdvantageMessage) == 0x000038, "Member 'UOrionHUDDisplayData::RequiredTimeWithoutAnyDeathsBeforeAdvantageMessage' has a wrong offset!");
static_assert(offsetof(UOrionHUDDisplayData, AdvantageIcon) == 0x000040, "Member 'UOrionHUDDisplayData::AdvantageIcon' has a wrong offset!");
static_assert(offsetof(UOrionHUDDisplayData, SpawnerCountdownAlertThreshold) == 0x000048, "Member 'UOrionHUDDisplayData::SpawnerCountdownAlertThreshold' has a wrong offset!");
static_assert(offsetof(UOrionHUDDisplayData, OuterTowerName) == 0x000050, "Member 'UOrionHUDDisplayData::OuterTowerName' has a wrong offset!");
static_assert(offsetof(UOrionHUDDisplayData, OuterTowerTeamFormat) == 0x000068, "Member 'UOrionHUDDisplayData::OuterTowerTeamFormat' has a wrong offset!");
static_assert(offsetof(UOrionHUDDisplayData, OuterTowerDestroyedMessageFormat) == 0x000080, "Member 'UOrionHUDDisplayData::OuterTowerDestroyedMessageFormat' has a wrong offset!");
static_assert(offsetof(UOrionHUDDisplayData, InnerTowerName) == 0x000098, "Member 'UOrionHUDDisplayData::InnerTowerName' has a wrong offset!");
static_assert(offsetof(UOrionHUDDisplayData, InnerTowerTeamFormat) == 0x0000B0, "Member 'UOrionHUDDisplayData::InnerTowerTeamFormat' has a wrong offset!");
static_assert(offsetof(UOrionHUDDisplayData, InnerTowerDestroyedMessageFormat) == 0x0000C8, "Member 'UOrionHUDDisplayData::InnerTowerDestroyedMessageFormat' has a wrong offset!");
static_assert(offsetof(UOrionHUDDisplayData, InhibitorName) == 0x0000E0, "Member 'UOrionHUDDisplayData::InhibitorName' has a wrong offset!");
static_assert(offsetof(UOrionHUDDisplayData, InhibitorTeamFormat) == 0x0000F8, "Member 'UOrionHUDDisplayData::InhibitorTeamFormat' has a wrong offset!");
static_assert(offsetof(UOrionHUDDisplayData, InhibitorDestroyedMessageFormat) == 0x000110, "Member 'UOrionHUDDisplayData::InhibitorDestroyedMessageFormat' has a wrong offset!");
static_assert(offsetof(UOrionHUDDisplayData, CoreName) == 0x000128, "Member 'UOrionHUDDisplayData::CoreName' has a wrong offset!");
static_assert(offsetof(UOrionHUDDisplayData, CoreTeamFormat) == 0x000140, "Member 'UOrionHUDDisplayData::CoreTeamFormat' has a wrong offset!");
static_assert(offsetof(UOrionHUDDisplayData, CoreDestroyedMessageFormat) == 0x000158, "Member 'UOrionHUDDisplayData::CoreDestroyedMessageFormat' has a wrong offset!");
static_assert(offsetof(UOrionHUDDisplayData, DefaultTowerName) == 0x000170, "Member 'UOrionHUDDisplayData::DefaultTowerName' has a wrong offset!");
static_assert(offsetof(UOrionHUDDisplayData, OfflaneName) == 0x000188, "Member 'UOrionHUDDisplayData::OfflaneName' has a wrong offset!");
static_assert(offsetof(UOrionHUDDisplayData, MidlaneName) == 0x0001A0, "Member 'UOrionHUDDisplayData::MidlaneName' has a wrong offset!");
static_assert(offsetof(UOrionHUDDisplayData, SafelaneName) == 0x0001B8, "Member 'UOrionHUDDisplayData::SafelaneName' has a wrong offset!");
static_assert(offsetof(UOrionHUDDisplayData, InnerTowerIcon) == 0x0001D0, "Member 'UOrionHUDDisplayData::InnerTowerIcon' has a wrong offset!");
static_assert(offsetof(UOrionHUDDisplayData, OuterTowerIcon) == 0x0001D8, "Member 'UOrionHUDDisplayData::OuterTowerIcon' has a wrong offset!");
static_assert(offsetof(UOrionHUDDisplayData, InhibitorIcon) == 0x0001E0, "Member 'UOrionHUDDisplayData::InhibitorIcon' has a wrong offset!");
static_assert(offsetof(UOrionHUDDisplayData, OrbPrimePortrait) == 0x0001E8, "Member 'UOrionHUDDisplayData::OrbPrimePortrait' has a wrong offset!");
static_assert(offsetof(UOrionHUDDisplayData, OrbPrimeKilledTitleText) == 0x000210, "Member 'UOrionHUDDisplayData::OrbPrimeKilledTitleText' has a wrong offset!");
static_assert(offsetof(UOrionHUDDisplayData, OrbPrimeKilledDescription) == 0x000228, "Member 'UOrionHUDDisplayData::OrbPrimeKilledDescription' has a wrong offset!");
static_assert(offsetof(UOrionHUDDisplayData, DragonPortrait) == 0x000240, "Member 'UOrionHUDDisplayData::DragonPortrait' has a wrong offset!");
static_assert(offsetof(UOrionHUDDisplayData, DragonKillTitleText) == 0x000268, "Member 'UOrionHUDDisplayData::DragonKillTitleText' has a wrong offset!");
static_assert(offsetof(UOrionHUDDisplayData, DragonBuffDescriptions) == 0x000280, "Member 'UOrionHUDDisplayData::DragonBuffDescriptions' has a wrong offset!");
static_assert(offsetof(UOrionHUDDisplayData, FriendDescriptor) == 0x000290, "Member 'UOrionHUDDisplayData::FriendDescriptor' has a wrong offset!");
static_assert(offsetof(UOrionHUDDisplayData, EnemyDescriptor) == 0x0002A8, "Member 'UOrionHUDDisplayData::EnemyDescriptor' has a wrong offset!");

// Class OrionGame.OrionHUDVictoryScreen
// 0x0010 (0x0300 - 0x02F0)
class UOrionHUDVictoryScreen final : public UOrionHUDWidgetBase
{
public:
	uint8                                         Pad_2F0[0x10];                                     // 0x02F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ShowDefeat();
	void ShowVictory();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionHUDVictoryScreen">();
	}
	static class UOrionHUDVictoryScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionHUDVictoryScreen>();
	}
};
static_assert(alignof(UOrionHUDVictoryScreen) == 0x000008, "Wrong alignment on UOrionHUDVictoryScreen");
static_assert(sizeof(UOrionHUDVictoryScreen) == 0x000300, "Wrong size on UOrionHUDVictoryScreen");

// Class OrionGame.OrionInputDisplayData
// 0x03C0 (0x03F0 - 0x0030)
class UOrionInputDisplayData final : public UDataAsset
{
public:
	TMap<class FName, class FName>                GamepadActionEquivalencesMap;                      // 0x0030(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	float                                         ButtonIconHeights[0x3];                            // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGamepadButtonArt>              GamepadButtons;                                    // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FGamepadButtonArt>              SecondaryGamepadButtons;                           // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FMouseButtonArt>                MouseButtons;                                      // 0x00B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FSlateBrush                            KeyboardKeyBackground;                             // 0x00C0(0x0078)(Edit, NativeAccessSpecifierPrivate)
	TSubclassOf<class UOrionTextStyle>            KeyboardKeyTextStyle;                              // 0x0138(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FMargin                                KeyTextPadding;                                    // 0x0140(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         MinKeyWidth;                                       // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_154[0x4];                                      // 0x0154(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAxisBindingsRedirectStruct>    AxisRedirects;                                     // 0x0158(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FAxisKeyRedirect>               AxisKeyRedirects;                                  // 0x0168(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<class FName, class FText>                ReadableNamesMap;                                  // 0x0178(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<class FName, class FText>                KeyDisplayNameOverridesByKeyName;                  // 0x01C8(0x0050)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FInputChord>                    InputBlacklist;                                    // 0x0218(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_228[0x1C8];                                    // 0x0228(0x01C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionInputDisplayData">();
	}
	static class UOrionInputDisplayData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionInputDisplayData>();
	}
};
static_assert(alignof(UOrionInputDisplayData) == 0x000008, "Wrong alignment on UOrionInputDisplayData");
static_assert(sizeof(UOrionInputDisplayData) == 0x0003F0, "Wrong size on UOrionInputDisplayData");
static_assert(offsetof(UOrionInputDisplayData, GamepadActionEquivalencesMap) == 0x000030, "Member 'UOrionInputDisplayData::GamepadActionEquivalencesMap' has a wrong offset!");
static_assert(offsetof(UOrionInputDisplayData, ButtonIconHeights) == 0x000080, "Member 'UOrionInputDisplayData::ButtonIconHeights' has a wrong offset!");
static_assert(offsetof(UOrionInputDisplayData, GamepadButtons) == 0x000090, "Member 'UOrionInputDisplayData::GamepadButtons' has a wrong offset!");
static_assert(offsetof(UOrionInputDisplayData, SecondaryGamepadButtons) == 0x0000A0, "Member 'UOrionInputDisplayData::SecondaryGamepadButtons' has a wrong offset!");
static_assert(offsetof(UOrionInputDisplayData, MouseButtons) == 0x0000B0, "Member 'UOrionInputDisplayData::MouseButtons' has a wrong offset!");
static_assert(offsetof(UOrionInputDisplayData, KeyboardKeyBackground) == 0x0000C0, "Member 'UOrionInputDisplayData::KeyboardKeyBackground' has a wrong offset!");
static_assert(offsetof(UOrionInputDisplayData, KeyboardKeyTextStyle) == 0x000138, "Member 'UOrionInputDisplayData::KeyboardKeyTextStyle' has a wrong offset!");
static_assert(offsetof(UOrionInputDisplayData, KeyTextPadding) == 0x000140, "Member 'UOrionInputDisplayData::KeyTextPadding' has a wrong offset!");
static_assert(offsetof(UOrionInputDisplayData, MinKeyWidth) == 0x000150, "Member 'UOrionInputDisplayData::MinKeyWidth' has a wrong offset!");
static_assert(offsetof(UOrionInputDisplayData, AxisRedirects) == 0x000158, "Member 'UOrionInputDisplayData::AxisRedirects' has a wrong offset!");
static_assert(offsetof(UOrionInputDisplayData, AxisKeyRedirects) == 0x000168, "Member 'UOrionInputDisplayData::AxisKeyRedirects' has a wrong offset!");
static_assert(offsetof(UOrionInputDisplayData, ReadableNamesMap) == 0x000178, "Member 'UOrionInputDisplayData::ReadableNamesMap' has a wrong offset!");
static_assert(offsetof(UOrionInputDisplayData, KeyDisplayNameOverridesByKeyName) == 0x0001C8, "Member 'UOrionInputDisplayData::KeyDisplayNameOverridesByKeyName' has a wrong offset!");
static_assert(offsetof(UOrionInputDisplayData, InputBlacklist) == 0x000218, "Member 'UOrionInputDisplayData::InputBlacklist' has a wrong offset!");

// Class OrionGame.OrionInputKeySelector
// 0x0248 (0x0850 - 0x0608)
class UOrionInputKeySelector final : public UInputKeySelector
{
public:
	TSubclassOf<class UOrionButtonStyle>          OrionButtonStyle;                                  // 0x0608(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrionWidgetStyleSize                         StyleSize;                                         // 0x0610(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrionTextColor                               TextColorType;                                     // 0x0611(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_612[0x23E];                                    // 0x0612(0x023E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetOrionButtonStyle(TSubclassOf<class UOrionButtonStyle> InButtonStyleClass);
	void SetStyleSize(EOrionWidgetStyleSize InStyleSize);
	void SetTextColorType(EOrionTextColor InColor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionInputKeySelector">();
	}
	static class UOrionInputKeySelector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionInputKeySelector>();
	}
};
static_assert(alignof(UOrionInputKeySelector) == 0x000008, "Wrong alignment on UOrionInputKeySelector");
static_assert(sizeof(UOrionInputKeySelector) == 0x000850, "Wrong size on UOrionInputKeySelector");
static_assert(offsetof(UOrionInputKeySelector, OrionButtonStyle) == 0x000608, "Member 'UOrionInputKeySelector::OrionButtonStyle' has a wrong offset!");
static_assert(offsetof(UOrionInputKeySelector, StyleSize) == 0x000610, "Member 'UOrionInputKeySelector::StyleSize' has a wrong offset!");
static_assert(offsetof(UOrionInputKeySelector, TextColorType) == 0x000611, "Member 'UOrionInputKeySelector::TextColorType' has a wrong offset!");

// Class OrionGame.OrionInterrupt
// 0x0000 (0x0040 - 0x0040)
class UOrionInterrupt final : public UGameplayEffectExecutionCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionInterrupt">();
	}
	static class UOrionInterrupt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionInterrupt>();
	}
};
static_assert(alignof(UOrionInterrupt) == 0x000008, "Wrong alignment on UOrionInterrupt");
static_assert(sizeof(UOrionInterrupt) == 0x000040, "Wrong size on UOrionInterrupt");

// Class OrionGame.OrionItemizationComponent
// 0x0290 (0x0380 - 0x00F0)
class UOrionItemizationComponent final : public UActorComponent
{
public:
	TArray<class UOrionGameplayCard*>             AllCards;                                          // 0x00F0(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UOrionGameplayGem*>              AllGems;                                           // 0x0100(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UOrionGameplayCard*>             EquippedCards;                                     // 0x0110(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class UOrionGameplayGem*>              ActiveGems;                                        // 0x0120(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	bool                                          bHasEstablishedDeck;                               // 0x0130(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEligibleForReset;                                 // 0x0131(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_132[0x24E];                                    // 0x0132(0x024E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ActiveGems();
	void OnRep_EligibleForReset();
	void OnRep_EquippedCards();
	void OnRep_HasEstablishedDeck();
	void ServerPrintDebug_WithClientStrings(const TArray<class FString>& Strings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionItemizationComponent">();
	}
	static class UOrionItemizationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionItemizationComponent>();
	}
};
static_assert(alignof(UOrionItemizationComponent) == 0x000008, "Wrong alignment on UOrionItemizationComponent");
static_assert(sizeof(UOrionItemizationComponent) == 0x000380, "Wrong size on UOrionItemizationComponent");
static_assert(offsetof(UOrionItemizationComponent, AllCards) == 0x0000F0, "Member 'UOrionItemizationComponent::AllCards' has a wrong offset!");
static_assert(offsetof(UOrionItemizationComponent, AllGems) == 0x000100, "Member 'UOrionItemizationComponent::AllGems' has a wrong offset!");
static_assert(offsetof(UOrionItemizationComponent, EquippedCards) == 0x000110, "Member 'UOrionItemizationComponent::EquippedCards' has a wrong offset!");
static_assert(offsetof(UOrionItemizationComponent, ActiveGems) == 0x000120, "Member 'UOrionItemizationComponent::ActiveGems' has a wrong offset!");
static_assert(offsetof(UOrionItemizationComponent, bHasEstablishedDeck) == 0x000130, "Member 'UOrionItemizationComponent::bHasEstablishedDeck' has a wrong offset!");
static_assert(offsetof(UOrionItemizationComponent, bEligibleForReset) == 0x000131, "Member 'UOrionItemizationComponent::bEligibleForReset' has a wrong offset!");

// Class OrionGame.OrionItemizationSystemSettings
// 0x00F0 (0x0120 - 0x0030)
class UOrionItemizationSystemSettings final : public UDataAsset
{
public:
	int32                                         MaxItemAbilityLevel;                               // 0x0030(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PvPItemLevelOverride;                              // 0x0034(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGameplayEffect>            CardTraitElevateGameplayEffect;                    // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FScalableFloat                         CardTraitCultivateGoldReductionValue;              // 0x0040(0x0028)(Edit, NativeAccessSpecifierPrivate)
	int32                                         CardAbilityLevelBoost;                             // 0x0068(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         GemTreePipGoldCost;                                // 0x006C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NumMinorPipsBetweenMajors;                         // 0x0070(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGemTreeBranchPipEffects               GemTreePipGameplayEffects[0x3];                    // 0x0078(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionItemizationSystemSettings">();
	}
	static class UOrionItemizationSystemSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionItemizationSystemSettings>();
	}
};
static_assert(alignof(UOrionItemizationSystemSettings) == 0x000008, "Wrong alignment on UOrionItemizationSystemSettings");
static_assert(sizeof(UOrionItemizationSystemSettings) == 0x000120, "Wrong size on UOrionItemizationSystemSettings");
static_assert(offsetof(UOrionItemizationSystemSettings, MaxItemAbilityLevel) == 0x000030, "Member 'UOrionItemizationSystemSettings::MaxItemAbilityLevel' has a wrong offset!");
static_assert(offsetof(UOrionItemizationSystemSettings, PvPItemLevelOverride) == 0x000034, "Member 'UOrionItemizationSystemSettings::PvPItemLevelOverride' has a wrong offset!");
static_assert(offsetof(UOrionItemizationSystemSettings, CardTraitElevateGameplayEffect) == 0x000038, "Member 'UOrionItemizationSystemSettings::CardTraitElevateGameplayEffect' has a wrong offset!");
static_assert(offsetof(UOrionItemizationSystemSettings, CardTraitCultivateGoldReductionValue) == 0x000040, "Member 'UOrionItemizationSystemSettings::CardTraitCultivateGoldReductionValue' has a wrong offset!");
static_assert(offsetof(UOrionItemizationSystemSettings, CardAbilityLevelBoost) == 0x000068, "Member 'UOrionItemizationSystemSettings::CardAbilityLevelBoost' has a wrong offset!");
static_assert(offsetof(UOrionItemizationSystemSettings, GemTreePipGoldCost) == 0x00006C, "Member 'UOrionItemizationSystemSettings::GemTreePipGoldCost' has a wrong offset!");
static_assert(offsetof(UOrionItemizationSystemSettings, NumMinorPipsBetweenMajors) == 0x000070, "Member 'UOrionItemizationSystemSettings::NumMinorPipsBetweenMajors' has a wrong offset!");
static_assert(offsetof(UOrionItemizationSystemSettings, GemTreePipGameplayEffects) == 0x000078, "Member 'UOrionItemizationSystemSettings::GemTreePipGameplayEffects' has a wrong offset!");

// Class OrionGame.OrionJungleRefinerySet
// 0x0028 (0x0058 - 0x0030)
class UOrionJungleRefinerySet final : public UOrionAttributeSet
{
public:
	float                                         CurrentResourceAmount;                             // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CachedResourceAmount;                              // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CachedMaxResourceAmount;                           // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RefinementDelay;                                   // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RefinementProcessingDuration;                      // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RefinementPeriod;                                  // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RefinementScalar;                                  // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OnHitResourceSteal;                                // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResourceLeachScalar;                               // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResourceLeachXPScalar;                             // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionJungleRefinerySet">();
	}
	static class UOrionJungleRefinerySet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionJungleRefinerySet>();
	}
};
static_assert(alignof(UOrionJungleRefinerySet) == 0x000008, "Wrong alignment on UOrionJungleRefinerySet");
static_assert(sizeof(UOrionJungleRefinerySet) == 0x000058, "Wrong size on UOrionJungleRefinerySet");
static_assert(offsetof(UOrionJungleRefinerySet, CurrentResourceAmount) == 0x000030, "Member 'UOrionJungleRefinerySet::CurrentResourceAmount' has a wrong offset!");
static_assert(offsetof(UOrionJungleRefinerySet, CachedResourceAmount) == 0x000034, "Member 'UOrionJungleRefinerySet::CachedResourceAmount' has a wrong offset!");
static_assert(offsetof(UOrionJungleRefinerySet, CachedMaxResourceAmount) == 0x000038, "Member 'UOrionJungleRefinerySet::CachedMaxResourceAmount' has a wrong offset!");
static_assert(offsetof(UOrionJungleRefinerySet, RefinementDelay) == 0x00003C, "Member 'UOrionJungleRefinerySet::RefinementDelay' has a wrong offset!");
static_assert(offsetof(UOrionJungleRefinerySet, RefinementProcessingDuration) == 0x000040, "Member 'UOrionJungleRefinerySet::RefinementProcessingDuration' has a wrong offset!");
static_assert(offsetof(UOrionJungleRefinerySet, RefinementPeriod) == 0x000044, "Member 'UOrionJungleRefinerySet::RefinementPeriod' has a wrong offset!");
static_assert(offsetof(UOrionJungleRefinerySet, RefinementScalar) == 0x000048, "Member 'UOrionJungleRefinerySet::RefinementScalar' has a wrong offset!");
static_assert(offsetof(UOrionJungleRefinerySet, OnHitResourceSteal) == 0x00004C, "Member 'UOrionJungleRefinerySet::OnHitResourceSteal' has a wrong offset!");
static_assert(offsetof(UOrionJungleRefinerySet, ResourceLeachScalar) == 0x000050, "Member 'UOrionJungleRefinerySet::ResourceLeachScalar' has a wrong offset!");
static_assert(offsetof(UOrionJungleRefinerySet, ResourceLeachXPScalar) == 0x000054, "Member 'UOrionJungleRefinerySet::ResourceLeachXPScalar' has a wrong offset!");

// Class OrionGame.OrionKillcamPlayback
// 0x0088 (0x00B0 - 0x0028)
class UOrionKillcamPlayback final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorld*                                 KillcamWorld;                                      // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPackage*                               KillcamWorldPackage;                               // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x60];                                      // 0x0050(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionKillcamPlayback">();
	}
	static class UOrionKillcamPlayback* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionKillcamPlayback>();
	}
};
static_assert(alignof(UOrionKillcamPlayback) == 0x000008, "Wrong alignment on UOrionKillcamPlayback");
static_assert(sizeof(UOrionKillcamPlayback) == 0x0000B0, "Wrong size on UOrionKillcamPlayback");
static_assert(offsetof(UOrionKillcamPlayback, KillcamWorld) == 0x000040, "Member 'UOrionKillcamPlayback::KillcamWorld' has a wrong offset!");
static_assert(offsetof(UOrionKillcamPlayback, KillcamWorldPackage) == 0x000048, "Member 'UOrionKillcamPlayback::KillcamWorldPackage' has a wrong offset!");

// Class OrionGame.OrionKismetLibrary
// 0x0000 (0x0028 - 0x0028)
class UOrionKismetLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool AbilityTeleportActor(class AActor* TargetActor, const struct FVector& DestLocation, const struct FRotator& DestRotation, bool IsGroundLocation);
	static float AngleBetweenInDegrees(const struct FVector& V0, const struct FVector& V1);
	static float AngleBetweenInRadians(const struct FVector& V0, const struct FVector& V1);
	static void AnnouncerSayDialog(class UObject* WorldContextObject, class AActor* SoundInstigator, const class FString& Ident);
	static void ApplyAbilityTagsToSpecFilterContainer(struct FOrionFilterAndEffectsContainer& FilterContainer, class UGameplayAbility* Ability);
	static bool ApplyGameplayEffectsToTarget(class AActor* TargetActor, TArray<struct FGameplayEffectSpecHandle>& EffectSpecHandlesToApply, TArray<struct FActiveGameplayEffectHandle>* AppliedEffectHandles);
	static void ApplyGameplayEffectsToTargetData(struct FOrionFilterAndEffectsContainer& FilterContainer, const struct FGameplayAbilityTargetDataHandle& TargetData, TArray<struct FActiveGameplayEffectHandle>* AppliedEffectHandles);
	static bool CanActorSeeTargetInShadowPlane(const class AActor* Source, const class AActor* Target);
	static bool CanPerformRendering();
	static bool CanSeeInZoneVisionMask(uint8 CanSeeZoneVisionMask, class AActor* Target);
	static void ChangeTeamChar(class AOrionChar* OrionChar, EOrionTeam NewTeam);
	static void ChangeTeamController(class AController* Controller, EOrionTeam NewTeam);
	static int32 CheckCVarInt(const class FString& CVarString);
	static bool CloneEffectSpecsForFilters(struct FOrionFilterAndEffectsContainer& FilterContainer, class AActor* InNewInstigator, class AActor* InNewSourceActor, struct FOrionFilterAndEffectsContainer* FilterToClone);
	static struct FVector ClosestPointOnLineToLine(const struct FVector& A0, const struct FVector& A1, const struct FVector& B0, const struct FVector& B1);
	static struct FVector ClosestPointOnSegmentToLine(const struct FVector& SegmentP0, const struct FVector& SegmentP1, const struct FVector& LineP0, const struct FVector& LineP1);
	static struct FVector ClosestPointOnSegmentToPlane(const struct FVector& SegmentP0, const struct FVector& SegmentP1, const struct FPlane& Plane);
	static void ClosestPointsOnSegmentToSegment(const struct FVector& A0, const struct FVector& A1, const struct FVector& B0, const struct FVector& B1, struct FVector* OutA, struct FVector* OutB);
	static bool CompareActorTeams(const class AActor* A, const class AActor* B, EOrionTeamCompare CompareType);
	static bool CompareTeams(EOrionTeam TeamA, EOrionTeam TeamB, EOrionTeamCompare CompareType);
	static void DebugCapsuleSendToAll(class UObject* WorldContextObject, const struct FVector& Center, float HalfHeight, float Radius, const struct FQuat& Rotation, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness);
	static void DebugLineSendToAll(class UObject* WorldContextObject, const struct FVector& LineStart, const struct FVector& LineEnd, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness);
	static void DebugSphereSendToAll(class UObject* WorldContextObject, const struct FVector& Center, float Radius, int32 Segments, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness);
	static float DistanceSquaredBetweenSegments(const struct FVector& A0, const struct FVector& A1, const struct FVector& B0, const struct FVector& B1);
	static bool DoesActorHaveVisionOnTarget(const class AActor* Source, const class AActor* Target);
	static bool DoesTeamHaveVisionOnTarget(const EOrionTeam Team, const class AActor* Target);
	static bool DoVisionTestBetweenActors(class AActor* Target, class AActor* Viewer, int32 CheckMask, float Timeout);
	static bool EqualEqual_ActiveGameplayEffectHandle(const struct FActiveGameplayEffectHandle& ActiveGameplayEffectHandleA, const struct FActiveGameplayEffectHandle& ActiveGameplayEffectHandleB);
	static void EvaluateCurveTableRowHandle(const struct FCurveTableRowHandle& RowHandle, float InXY, EEvaluateCurveTableResult* OutResult, float* OutXY, const class FString& ContextString);
	static bool FilterActor(const struct FOrionActorFilter& Filter, const class AActor* Source, const class AActor* Target);
	static void FindPlayerStart(class AController* PlayerController, class AActor** StartPointActor, struct FVector* StartPointLocation, struct FRotator* StartPointRotation);
	static void GameplayCue_ApplyDecal(class AActor* Actor, class FName DecalName);
	static void GameplayCue_ApplyDecalForDuration(class AActor* Actor, class FName DecalName, float Duration);
	static class UAudioComponent* GameplayCue_PlaySoundTeamAdjustedForSource(class USoundBase* SoundToPlay, class AActor* MyTarget, const struct FGameplayCueParameters& Parameters, bool Attached, bool bStopWhenAttachedToDestroyed);
	static class UAudioComponent* GameplayCue_PlaySoundTeamAdjustedForTarget(class USoundBase* SoundToPlay, class AActor* MyTarget, const struct FGameplayCueParameters& Parameters, bool Attached, bool bStopWhenAttachedToDestroyed);
	static void GameplayCue_RemoveDecal(class AActor* Actor, class FName DecalName);
	static struct FVector GameplayCue_SourceLocation(const struct FGameplayCueParameters& Parameters);
	static class UParticleSystemComponent* GameplayCue_SpawnEmitter(class UObject* WorldContextObject, class UParticleSystem* ParticleSystem, class AActor* MyTarget, const struct FGameplayCueParameters& Parameters, bool Attached);
	static struct FOrionFilterAndEffectsContainer GenerateGameplayEffectSpecsForFilter(struct FOrionFilterAndEffectsContainer& FilterContainer, class AActor* Instigator, class AActor* Source, float InLevel);
	static const struct FGameplayTagContainer GetActiveRotationalContentTags(class UObject* WorldContextObject);
	static struct FVector GetActorAimPosition(const class AActor* Actor);
	static struct FVector GetActorBottom(const class AActor* Actor);
	static float GetActorRadius(const class AActor* Actor);
	static struct FVector GetActorTargetPosition(const class AActor* Actor);
	static EOrionTeam GetActorTeam(const class AActor* A);
	static bool GetEffectsToApplyToTargetFromFilters(struct FOrionFilterAndEffectsContainer& FilterContainer, class AActor* Target, TArray<struct FGameplayEffectSpecHandle>* EffectSpecHandlesToApply);
	static struct FLinearColor GetEnemyColorFromMPC();
	static struct FLinearColor GetFriendlyColorFromMPC();
	static TArray<struct FGameplayEffectSpecHandle> GetGameplayEffectSpecsFromFilter(struct FOrionFilterAndEffectsContainer& FilterContainer, class AActor* Instigator, class AActor* Source, float InLevel);
	static class AExponentialHeightFog* GetGlobalExponentialHeightFog(class UObject* WorldContextObject);
	static float GetHealth(class AActor* Target);
	static float GetHealthPCT(class AActor* Target);
	static struct FLinearColor GetHeroPrimaryColor(const class AActor* Actor);
	static struct FLinearColor GetHeroSecondaryColor(const class AActor* Actor);
	static class AOrionPlayerController_Base* GetLocalPlayerController_Base(class UObject* WorldContextObject);
	static class AOrionPlayerController_Game* GetLocalPlayerController_Game(class UObject* WorldContextObject);
	static class AOrionReplaySpectator* GetOrionReplaySpectator(class UObject* WorldContextObject);
	static class AOrionPlayerController_Game* GetPlayerControllerFromActor(class AActor* Actor);
	static class AActor* GetPrimaryActorFromTargetData(const struct FGameplayAbilityTargetDataHandle& TargetData, int32 Index_0);
	static float GetRigPlacementRange(class AActor* Target);
	static float GetSignificanceForLocation(class UObject* WorldContextObject, const struct FVector& Location);
	static void GetSpawnLocationForControllerAtStartPoint(class AController* PlayerController, class AActor* StartSpot, struct FVector* OutSpawnLocation);
	static class FString GetTagContainerString(const struct FGameplayTagContainer& InContainer);
	static class FString GetTagString(const struct FGameplayTag& InTag);
	static struct FLinearColor GetTeamColorFromMPC(class UObject* Target);
	static struct FLinearColor GetTeamColorFromMPCWithTeamNum(class UObject* WorldContextObject, EOrionTeam TargetTeamNum);
	static ETravelModeModes GetTravelModeMode(class AActor* WorldContextActor);
	static ELocalVisiblityState GetVisibilityRelativeToLocalPlayer(const class AActor* Target);
	static struct FVector GetWorldBackwardVector();
	static struct FVector GetWorldDownVector();
	static struct FVector GetWorldForwardVector();
	static struct FVector GetWorldLeftVector();
	static struct FVector GetWorldRightVector();
	static struct FVector GetWorldUpVector();
	static bool HasTrueSight(const class AActor* A);
	static bool IsDead(class AActor* Target);
	static bool IsEngineDoingAsyncLoading();
	static bool IsInShadowPlane(const class AActor* A);
	static bool IsLocallyControlledPlayer(const class AActor* Actor);
	static bool IsOnLocalTeam(class UObject* WorldContextObject, const class AActor* A);
	static bool IsPhaseShifted(const class AActor* A);
	static bool IsRunningOnLowEndClient();
	static bool IsSprintEnabled(class AActor* WorldContextActor);
	static bool IsVisibleToEnemy(const class AActor* A);
	static bool IsVisibleToTeam(const class AActor* A, EOrionTeam TeamNum);
	static void LaunchCharacterInDirection(class AActor* Actor, const struct FVector& Direction, float LaunchVelocity, bool bLockAirControl);
	static void LaunchCharacterInDirectionFromTargetData(class AActor* Actor, const struct FGameplayAbilityTargetDataHandle& TargetDataHandle, float LaunchVelocity, bool bLockAirControl);
	static void LaunchCharacterToPoint(class AActor* Actor, const struct FVector& EndPoint, float LaunchVelocityXY, bool bLockAirControl);
	static void LaunchCharacterToPointFromTargetData(class AActor* Actor, const struct FGameplayAbilityTargetDataHandle& TargetDataHandle, float LaunchVelocityXY, bool bLockAirControl);
	static struct FGameplayTargetDataFilterHandle MakeOrionFilterHandle(const struct FOrionAbilityTargetDataFilter& Filter, class AActor* FilterActor, EOrionTeam FilterTeam);
	static struct FGameplayAbilityTargetDataHandle MakeOrionTargetData(const struct FTransform& SourceTransform, const struct FTransform& TargetTransform, class AActor* TargetActor, bool bAllowExternalTargetSwaps);
	static bool NewVisionManagerEnabled(class UObject* WorldContextObject);
	static bool OnSameFormation(const class AOrionAIController* A, const class AOrionAIController* B);
	static bool OnSameFormationChar(const class AOrionChar* A, const class AOrionChar* B);
	static bool OnSameTeam(class AActor* A, class AActor* B);
	static void PingMinimap(class UObject* WorldContextObject, const struct FVector& Location, EOrionTeam TeamToPing);
	static void PlayCameraAnimOnActor(class AActor* Actor, class UCameraAnim* AnimToPlay, float Scale, float Rate, float BlendInTime, float BlendOutTime, bool bLoop, bool bRandomStartTime, ECameraAnimPlaySpace Space, const struct FRotator& CustomPlaySpace);
	static void PlayCameraShakeOnActor(class AActor* Actor, TSubclassOf<class UCameraShake> Shake, float Scale, ECameraAnimPlaySpace PlaySpace, const struct FRotator& UserPlaySpaceRot);
	static void PlayForceFeedbackOnActor(class AActor* Actor, class UForceFeedbackEffect* ForceFeedbackEffect, bool bLooping, class FName Tag);
	static void PlayViewKickOnActor(class AActor* Actor, TSubclassOf<class UOrionViewKick> ViewKickClass, float Scale);
	static struct FVector2D RotateVectorDegrees(const struct FVector2D& V0, float Radians);
	static struct FVector2D RotateVectorRadians(const struct FVector2D& V0, float Radians);
	static void SetFilterContextAbility(struct FOrionFilterAndEffectsContainer& FilterContainer, class UGameplayAbility* Ability);
	static void SetFilterContextActors(struct FOrionFilterAndEffectsContainer& FilterContainer, const TArray<class AActor*>& InActors);
	static void SetFilterContextHitResult(struct FOrionFilterAndEffectsContainer& FilterContainer, const struct FHitResult& InHitResult);
	static void SetFilterContextInstigator(struct FOrionFilterAndEffectsContainer& FilterContainer, class AActor* InInstigator, class AActor* InEffectCauser);
	static void SetFilterContextOrigin(struct FOrionFilterAndEffectsContainer& FilterContainer, const struct FVector& InOrigin);
	static void SetFilterContextSourceObject(struct FOrionFilterAndEffectsContainer& FilterContainer, const class UObject* NewSourceObject);
	static void SetFilterGameplayEffectLevel(struct FOrionFilterAndEffectsContainer& FilterContainer, TSubclassOf<class UGameplayEffect> InGE, float GameplayEffectLevel);
	static void SetFilterSetByCallerMagnitude(struct FOrionFilterAndEffectsContainer& FilterContainer, TSubclassOf<class UGameplayEffect> InGE, class FName SetByCallerName, float Magnitude);
	static void SetFilterStackCountForGameplayEffect(struct FOrionFilterAndEffectsContainer& FilterContainer, TSubclassOf<class UGameplayEffect> InGE, float InCount);
	static void SetFilterTagSetByCallerMagnitude(struct FOrionFilterAndEffectsContainer& FilterContainer, TSubclassOf<class UGameplayEffect> InGE, const struct FGameplayTag& SetByCallerTag, float Magnitude);
	static void SetTeamBarrierCollision(class UPrimitiveComponent* Primitive, EOrionTeam OwnerTeam);
	static bool ShouldShowRenderingAndResolutionSettings();
	static float SignedAngleBetweenInDegrees(const struct FVector2D& V0, const struct FVector2D& V1);
	static float SignedAngleBetweenInRadians(const struct FVector2D& V0, const struct FVector2D& V1);
	static void SpawnCoins(class UObject* WorldContextObject, int32 DesiredCoinsToSpawn, class AActor* Owner, class AController* OwnerController, class AActor* HomingActor, EOrionTeam OwnerTeam, const struct FVector& SpawnLocation, const struct FGameplayTagContainer& SourceTags, const struct FGameplayTagContainer& SourceAssetTags, EOrionPickUpSpeed LaunchSpeed, int32 MinCoinsToSpawnThreshold);
	static class UAudioComponent* SpawnSoundOnActor(class USoundBase* SoundToPlay, class AActor* SoundTarget, bool Attached, bool bStopWhenAttachedToDestroyed);
	static class UAudioComponent* SpawnSoundOnActorAtLocation(class USoundBase* SoundToPlay, class AActor* SoundTarget, const struct FVector& WorldLocation, bool bStopWhenAttachedToDestroyed);
	static class UAudioComponent* SpawnSoundTeamAdjusted(class USoundBase* SoundToPlay, class AActor* SoundInstigator, class AActor* SoundTarget, bool bForceCreateAudioComponent, bool bStopWhenDestroyed);
	static class UAudioComponent* SpawnSoundTeamAdjustedAtLocation(class USoundBase* SoundToPlay, class AActor* SoundInstigator, class AActor* SoundTarget, const struct FVector& WorldLocation, bool bStopWhenAttachedToDestroyed);
	static void SplitGameplayEffectSpecBetweenActors(const struct FGameplayEffectSpecHandle& SpecHandle, TArray<class AActor*>& TargetActors, TArray<class FName>& DataNames, TArray<struct FActiveGameplayEffectHandle>* AppliedEffectHandles);
	static void SplitGameplayEffectSpecBetweenTargetData(const struct FGameplayEffectSpecHandle& SpecHandle, const struct FGameplayAbilityTargetDataHandle& TargetDataHandle, TArray<class FName>& DataNames, TArray<struct FActiveGameplayEffectHandle>* AppliedEffectHandles);
	static TArray<struct FGameplayAbilityTargetDataHandle> SplitTargetData(const struct FGameplayAbilityTargetDataHandle& TargetData);
	static void StopCameraAnimOnActor(class AActor* Actor, class UCameraAnim* AnimToStop);
	static void StopCameraShakeOnActor(class AActor* Actor, TSubclassOf<class UCameraShake> Shake, bool bImmediately);
	static void StopForceFeedbackOnActor(class AActor* Actor, class UForceFeedbackEffect* ForceFeedbackEffect, class FName Tag);
	static void TagSplitGameplayEffectSpecBetweenActors(const struct FGameplayEffectSpecHandle& SpecHandle, TArray<class AActor*>& TargetActors, struct FGameplayTagContainer& DataTags, TArray<struct FActiveGameplayEffectHandle>* AppliedEffectHandles);
	static void TagSplitGameplayEffectSpecBetweenTargetData(const struct FGameplayEffectSpecHandle& SpecHandle, const struct FGameplayAbilityTargetDataHandle& TargetDataHandle, struct FGameplayTagContainer& DataTags, TArray<struct FActiveGameplayEffectHandle>* AppliedEffectHandles);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionKismetLibrary">();
	}
	static class UOrionKismetLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionKismetLibrary>();
	}
};
static_assert(alignof(UOrionKismetLibrary) == 0x000008, "Wrong alignment on UOrionKismetLibrary");
static_assert(sizeof(UOrionKismetLibrary) == 0x000028, "Wrong size on UOrionKismetLibrary");

// Class OrionGame.OrionKnockup
// 0x0008 (0x0048 - 0x0040)
class UOrionKnockup final : public UGameplayEffectExecutionCalculation
{
public:
	TSubclassOf<class UGameplayEffect>            KnockUpTagGameplayEffect;                          // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionKnockup">();
	}
	static class UOrionKnockup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionKnockup>();
	}
};
static_assert(alignof(UOrionKnockup) == 0x000008, "Wrong alignment on UOrionKnockup");
static_assert(sizeof(UOrionKnockup) == 0x000048, "Wrong size on UOrionKnockup");
static_assert(offsetof(UOrionKnockup, KnockUpTagGameplayEffect) == 0x000040, "Member 'UOrionKnockup::KnockUpTagGameplayEffect' has a wrong offset!");

// Class OrionGame.OrionListItem
// 0x0000 (0x0028 - 0x0028)
class IOrionListItem : public IInterface
{
public:
	void Private_OnExpanderArrowShiftClicked();
	void RegisterOnClicked(const TDelegate<void(class UUserWidget* Widget)>& Callback);
	void RegisterOnHovered(const TDelegate<void(class UUserWidget* Widget, bool bIsHovered)>& Callback);
	void SetIndexInList(int32 InIndexInList);
	void SetSelected(bool bSelected);
	void ToggleExpansion();

	int32 DoesItemHaveChildren() const;
	int32 GetIndentLevel() const;
	ESelectionMode GetSelectionMode() const;
	bool IsItemExpanded() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionListItem">();
	}
	static class IOrionListItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOrionListItem>();
	}
};
static_assert(alignof(IOrionListItem) == 0x000008, "Wrong alignment on IOrionListItem");
static_assert(sizeof(IOrionListItem) == 0x000028, "Wrong size on IOrionListItem");

// Class OrionGame.OrionLoadingActor
// 0x0010 (0x0328 - 0x0318)
class AOrionLoadingActor final : public AActor
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetComponent*                       WidgetComponent;                                   // 0x0320(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnSetSlotIndex(int32 SlotIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionLoadingActor">();
	}
	static class AOrionLoadingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionLoadingActor>();
	}
};
static_assert(alignof(AOrionLoadingActor) == 0x000008, "Wrong alignment on AOrionLoadingActor");
static_assert(sizeof(AOrionLoadingActor) == 0x000328, "Wrong size on AOrionLoadingActor");
static_assert(offsetof(AOrionLoadingActor, SceneComponent) == 0x000318, "Member 'AOrionLoadingActor::SceneComponent' has a wrong offset!");
static_assert(offsetof(AOrionLoadingActor, WidgetComponent) == 0x000320, "Member 'AOrionLoadingActor::WidgetComponent' has a wrong offset!");

// Class OrionGame.OrionLoadingScreen
// 0x0168 (0x05B0 - 0x0448)
class UOrionLoadingScreen : public UOrionActivatableWidget
{
public:
	TSoftClassPtr<class UClass>                   LoadingScreenClasses[0x8];                         // 0x0448(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOrionActivatableWidget*                CurrentLoadingScreenWidget;                        // 0x0588(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrionLoadingScreenMode                       Mode;                                              // 0x0590(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_591[0x7];                                      // 0x0591(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBorder*                                Border_Fallback;                                   // 0x0598(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOverlay*                               Overlay_Root;                                      // 0x05A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5A8[0x8];                                      // 0x05A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLoadingScreenHidden();
	void OnLoadingScreenShown(bool bIsUsingFallback);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionLoadingScreen">();
	}
	static class UOrionLoadingScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionLoadingScreen>();
	}
};
static_assert(alignof(UOrionLoadingScreen) == 0x000008, "Wrong alignment on UOrionLoadingScreen");
static_assert(sizeof(UOrionLoadingScreen) == 0x0005B0, "Wrong size on UOrionLoadingScreen");
static_assert(offsetof(UOrionLoadingScreen, LoadingScreenClasses) == 0x000448, "Member 'UOrionLoadingScreen::LoadingScreenClasses' has a wrong offset!");
static_assert(offsetof(UOrionLoadingScreen, CurrentLoadingScreenWidget) == 0x000588, "Member 'UOrionLoadingScreen::CurrentLoadingScreenWidget' has a wrong offset!");
static_assert(offsetof(UOrionLoadingScreen, Mode) == 0x000590, "Member 'UOrionLoadingScreen::Mode' has a wrong offset!");
static_assert(offsetof(UOrionLoadingScreen, Border_Fallback) == 0x000598, "Member 'UOrionLoadingScreen::Border_Fallback' has a wrong offset!");
static_assert(offsetof(UOrionLoadingScreen, Overlay_Root) == 0x0005A0, "Member 'UOrionLoadingScreen::Overlay_Root' has a wrong offset!");

// Class OrionGame.OrionMasteryInfo
// 0x0010 (0x0040 - 0x0030)
class UOrionMasteryInfo final : public UDataAsset
{
public:
	TArray<struct FOrionMasteryLevel>             Levels;                                            // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMasteryInfo">();
	}
	static class UOrionMasteryInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMasteryInfo>();
	}
};
static_assert(alignof(UOrionMasteryInfo) == 0x000008, "Wrong alignment on UOrionMasteryInfo");
static_assert(sizeof(UOrionMasteryInfo) == 0x000040, "Wrong size on UOrionMasteryInfo");
static_assert(offsetof(UOrionMasteryInfo, Levels) == 0x000030, "Member 'UOrionMasteryInfo::Levels' has a wrong offset!");

// Class OrionGame.OrionMatchmaking
// 0x0000 (0x0028 - 0x0028)
class UOrionMatchmaking final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMatchmaking">();
	}
	static class UOrionMatchmaking* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMatchmaking>();
	}
};
static_assert(alignof(UOrionMatchmaking) == 0x000008, "Wrong alignment on UOrionMatchmaking");
static_assert(sizeof(UOrionMatchmaking) == 0x000028, "Wrong size on UOrionMatchmaking");

// Class OrionGame.OrionMatchmakingDisplayData
// 0x1070 (0x10A0 - 0x0030)
class UOrionMatchmakingDisplayData final : public UDataAsset
{
public:
	class FText                                   MatchmakingBanReasons[0x6];                        // 0x0030(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   MissedReadyCheckWarning;                           // 0x00C0(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   PvPDisabled;                                       // 0x00D8(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   GameTypeSelectDisabled;                            // 0x00F0(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   AvailabilityNames[0x4];                            // 0x0108(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   AvailabilityMessageFormats[0x4];                   // 0x0168(0x0018)(Edit, NativeAccessSpecifierPublic)
	class UTexture2D*                             AvailabilityIcons[0x4];                            // 0x01C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionHeroAvailabilityInfo             HeroAvailabilities[0x4];                           // 0x01E8(0x0038)(Edit, NativeAccessSpecifierPublic)
	class FText                                   MatchmakingInProgress;                             // 0x02C8(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   SelectPosition;                                    // 0x02E0(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   SelectHero;                                        // 0x02F8(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   SelectGameType;                                    // 0x0310(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   InvalidSkin;                                       // 0x0328(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FLinearColor                           TeamColors[0x4];                                   // 0x0340(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UOrionQuickChatWrapper>     DefaultQuickChatWrapperClass;                      // 0x0380(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ToggleQuickChatAction;                             // 0x0388(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   QuickChatMessageActions[0x4];                      // 0x0390(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionQuickChatTopic                   QuickChatTopics[0x12];                             // 0x03B0(0x0098)(Edit, NativeAccessSpecifierPublic)
	struct FOrionDialogDescription                TeamFoundConfirmation;                             // 0x0E60(0x00B0)(Edit, NativeAccessSpecifierPublic)
	struct FOrionNotification                     SoloSearchingNotification;                         // 0x0F10(0x0180)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FMatchmakingDisplayEntry>       DisplayEntries;                                    // 0x1090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMatchmakingDisplayData">();
	}
	static class UOrionMatchmakingDisplayData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMatchmakingDisplayData>();
	}
};
static_assert(alignof(UOrionMatchmakingDisplayData) == 0x000010, "Wrong alignment on UOrionMatchmakingDisplayData");
static_assert(sizeof(UOrionMatchmakingDisplayData) == 0x0010A0, "Wrong size on UOrionMatchmakingDisplayData");
static_assert(offsetof(UOrionMatchmakingDisplayData, MatchmakingBanReasons) == 0x000030, "Member 'UOrionMatchmakingDisplayData::MatchmakingBanReasons' has a wrong offset!");
static_assert(offsetof(UOrionMatchmakingDisplayData, MissedReadyCheckWarning) == 0x0000C0, "Member 'UOrionMatchmakingDisplayData::MissedReadyCheckWarning' has a wrong offset!");
static_assert(offsetof(UOrionMatchmakingDisplayData, PvPDisabled) == 0x0000D8, "Member 'UOrionMatchmakingDisplayData::PvPDisabled' has a wrong offset!");
static_assert(offsetof(UOrionMatchmakingDisplayData, GameTypeSelectDisabled) == 0x0000F0, "Member 'UOrionMatchmakingDisplayData::GameTypeSelectDisabled' has a wrong offset!");
static_assert(offsetof(UOrionMatchmakingDisplayData, AvailabilityNames) == 0x000108, "Member 'UOrionMatchmakingDisplayData::AvailabilityNames' has a wrong offset!");
static_assert(offsetof(UOrionMatchmakingDisplayData, AvailabilityMessageFormats) == 0x000168, "Member 'UOrionMatchmakingDisplayData::AvailabilityMessageFormats' has a wrong offset!");
static_assert(offsetof(UOrionMatchmakingDisplayData, AvailabilityIcons) == 0x0001C8, "Member 'UOrionMatchmakingDisplayData::AvailabilityIcons' has a wrong offset!");
static_assert(offsetof(UOrionMatchmakingDisplayData, HeroAvailabilities) == 0x0001E8, "Member 'UOrionMatchmakingDisplayData::HeroAvailabilities' has a wrong offset!");
static_assert(offsetof(UOrionMatchmakingDisplayData, MatchmakingInProgress) == 0x0002C8, "Member 'UOrionMatchmakingDisplayData::MatchmakingInProgress' has a wrong offset!");
static_assert(offsetof(UOrionMatchmakingDisplayData, SelectPosition) == 0x0002E0, "Member 'UOrionMatchmakingDisplayData::SelectPosition' has a wrong offset!");
static_assert(offsetof(UOrionMatchmakingDisplayData, SelectHero) == 0x0002F8, "Member 'UOrionMatchmakingDisplayData::SelectHero' has a wrong offset!");
static_assert(offsetof(UOrionMatchmakingDisplayData, SelectGameType) == 0x000310, "Member 'UOrionMatchmakingDisplayData::SelectGameType' has a wrong offset!");
static_assert(offsetof(UOrionMatchmakingDisplayData, InvalidSkin) == 0x000328, "Member 'UOrionMatchmakingDisplayData::InvalidSkin' has a wrong offset!");
static_assert(offsetof(UOrionMatchmakingDisplayData, TeamColors) == 0x000340, "Member 'UOrionMatchmakingDisplayData::TeamColors' has a wrong offset!");
static_assert(offsetof(UOrionMatchmakingDisplayData, DefaultQuickChatWrapperClass) == 0x000380, "Member 'UOrionMatchmakingDisplayData::DefaultQuickChatWrapperClass' has a wrong offset!");
static_assert(offsetof(UOrionMatchmakingDisplayData, ToggleQuickChatAction) == 0x000388, "Member 'UOrionMatchmakingDisplayData::ToggleQuickChatAction' has a wrong offset!");
static_assert(offsetof(UOrionMatchmakingDisplayData, QuickChatMessageActions) == 0x000390, "Member 'UOrionMatchmakingDisplayData::QuickChatMessageActions' has a wrong offset!");
static_assert(offsetof(UOrionMatchmakingDisplayData, QuickChatTopics) == 0x0003B0, "Member 'UOrionMatchmakingDisplayData::QuickChatTopics' has a wrong offset!");
static_assert(offsetof(UOrionMatchmakingDisplayData, TeamFoundConfirmation) == 0x000E60, "Member 'UOrionMatchmakingDisplayData::TeamFoundConfirmation' has a wrong offset!");
static_assert(offsetof(UOrionMatchmakingDisplayData, SoloSearchingNotification) == 0x000F10, "Member 'UOrionMatchmakingDisplayData::SoloSearchingNotification' has a wrong offset!");
static_assert(offsetof(UOrionMatchmakingDisplayData, DisplayEntries) == 0x001090, "Member 'UOrionMatchmakingDisplayData::DisplayEntries' has a wrong offset!");

// Class OrionGame.OrionMatchmakingDisplayLibrary
// 0x0000 (0x0028 - 0x0028)
class UOrionMatchmakingDisplayLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void GetBanReasonText(EOrionBanReason BanReason, class FText* OutText);
	static void GetHeroAvailabilityText(EOrionHeroAvailability Availability, const class UOrionHeroData* HeroData, class FText* OutText);
	static void GetTeamColor(EOrionTeamMemberType TeamMemberType, struct FLinearColor* TeamColor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMatchmakingDisplayLibrary">();
	}
	static class UOrionMatchmakingDisplayLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMatchmakingDisplayLibrary>();
	}
};
static_assert(alignof(UOrionMatchmakingDisplayLibrary) == 0x000008, "Wrong alignment on UOrionMatchmakingDisplayLibrary");
static_assert(sizeof(UOrionMatchmakingDisplayLibrary) == 0x000028, "Wrong size on UOrionMatchmakingDisplayLibrary");

// Class OrionGame.OrionMatchmakingV2
// 0x0498 (0x04C0 - 0x0028)
class UOrionMatchmakingV2 final : public UObject
{
public:
	class FString                                 MMSVersionCompatability;                           // 0x0028(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 MMSTicketURLClient;                                // 0x0038(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MMSPingInterval;                                   // 0x0048(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C[0x474];                                     // 0x004C(0x0474)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMatchmakingV2">();
	}
	static class UOrionMatchmakingV2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMatchmakingV2>();
	}
};
static_assert(alignof(UOrionMatchmakingV2) == 0x000008, "Wrong alignment on UOrionMatchmakingV2");
static_assert(sizeof(UOrionMatchmakingV2) == 0x0004C0, "Wrong size on UOrionMatchmakingV2");
static_assert(offsetof(UOrionMatchmakingV2, MMSVersionCompatability) == 0x000028, "Member 'UOrionMatchmakingV2::MMSVersionCompatability' has a wrong offset!");
static_assert(offsetof(UOrionMatchmakingV2, MMSTicketURLClient) == 0x000038, "Member 'UOrionMatchmakingV2::MMSTicketURLClient' has a wrong offset!");
static_assert(offsetof(UOrionMatchmakingV2, MMSPingInterval) == 0x000048, "Member 'UOrionMatchmakingV2::MMSPingInterval' has a wrong offset!");

// Class OrionGame.OrionMcpBannerAlterationItem
// 0x0000 (0x0078 - 0x0078)
class UOrionMcpBannerAlterationItem final : public UOrionMcpItem
{
public:
	class UOrionMcpBannerAlterationItemDefinition* GetInternalData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpBannerAlterationItem">();
	}
	static class UOrionMcpBannerAlterationItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpBannerAlterationItem>();
	}
};
static_assert(alignof(UOrionMcpBannerAlterationItem) == 0x000008, "Wrong alignment on UOrionMcpBannerAlterationItem");
static_assert(sizeof(UOrionMcpBannerAlterationItem) == 0x000078, "Wrong size on UOrionMcpBannerAlterationItem");

// Class OrionGame.OrionMcpBannerItem
// 0x0030 (0x00A8 - 0x0078)
class UOrionMcpBannerItem final : public UOrionMcpItem
{
public:
	class FString                                 Name_0;                                            // 0x0078(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMcpBannerEntry>                Pieces;                                            // 0x0088(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FString>                         BannerAlterationNames;                             // 0x0098(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	class UOrionMcpBannerItemDefinition* GetInternalData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpBannerItem">();
	}
	static class UOrionMcpBannerItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpBannerItem>();
	}
};
static_assert(alignof(UOrionMcpBannerItem) == 0x000008, "Wrong alignment on UOrionMcpBannerItem");
static_assert(sizeof(UOrionMcpBannerItem) == 0x0000A8, "Wrong size on UOrionMcpBannerItem");
static_assert(offsetof(UOrionMcpBannerItem, Name_0) == 0x000078, "Member 'UOrionMcpBannerItem::Name_0' has a wrong offset!");
static_assert(offsetof(UOrionMcpBannerItem, Pieces) == 0x000088, "Member 'UOrionMcpBannerItem::Pieces' has a wrong offset!");
static_assert(offsetof(UOrionMcpBannerItem, BannerAlterationNames) == 0x000098, "Member 'UOrionMcpBannerItem::BannerAlterationNames' has a wrong offset!");

// Class OrionGame.OrionMcpBoostItem
// 0x0000 (0x0078 - 0x0078)
class UOrionMcpBoostItem final : public UOrionMcpItem
{
public:
	class UOrionBoostItemDefinition* GetInternalData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpBoostItem">();
	}
	static class UOrionMcpBoostItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpBoostItem>();
	}
};
static_assert(alignof(UOrionMcpBoostItem) == 0x000008, "Wrong alignment on UOrionMcpBoostItem");
static_assert(sizeof(UOrionMcpBoostItem) == 0x000078, "Wrong size on UOrionMcpBoostItem");

// Class OrionGame.OrionMcpCardItem
// 0x0008 (0x0080 - 0x0078)
class UOrionMcpCardItem final : public UOrionMcpItem
{
public:
	int32                                         Level;                                             // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UOrionMcpCardItemDefinition* GetInternalData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpCardItem">();
	}
	static class UOrionMcpCardItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpCardItem>();
	}
};
static_assert(alignof(UOrionMcpCardItem) == 0x000008, "Wrong alignment on UOrionMcpCardItem");
static_assert(sizeof(UOrionMcpCardItem) == 0x000080, "Wrong size on UOrionMcpCardItem");
static_assert(offsetof(UOrionMcpCardItem, Level) == 0x000078, "Member 'UOrionMcpCardItem::Level' has a wrong offset!");

// Class OrionGame.OrionMcpCardItemDefinition
// 0x0098 (0x0300 - 0x0268)
class UOrionMcpCardItemDefinition final : public UOrionMcpItemDefinition
{
public:
	class UOrionMcpRankUpRecipeItemDefinition*    RankUpRecipe;                                      // 0x0268(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           ItemSetTag;                                        // 0x0270(0x0008)(Edit, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EAffinityType                                 Affinity;                                          // 0x0278(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EOrionCardTraits                              CardTrait;                                         // 0x0279(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27A[0x2];                                      // 0x027A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayCurrencyBundle                CardCost;                                          // 0x027C(0x0010)(Edit, Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, float>              AttributeCoefficientsByParamTag;                   // 0x0290(0x0050)(Edit, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FSimpleAbilityKeywordTag>       SimpleAbilityKeywords;                             // 0x02E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         AccountLevelUnlock;                                // 0x02F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStarter;                                          // 0x02F4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPlayEnabled;                                      // 0x02F5(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShowInUI;                                         // 0x02F6(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F7[0x1];                                      // 0x02F7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DevelopmentSetName;                                // 0x02F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	EAffinityType GetAffinity() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpCardItemDefinition">();
	}
	static class UOrionMcpCardItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpCardItemDefinition>();
	}
};
static_assert(alignof(UOrionMcpCardItemDefinition) == 0x000008, "Wrong alignment on UOrionMcpCardItemDefinition");
static_assert(sizeof(UOrionMcpCardItemDefinition) == 0x000300, "Wrong size on UOrionMcpCardItemDefinition");
static_assert(offsetof(UOrionMcpCardItemDefinition, RankUpRecipe) == 0x000268, "Member 'UOrionMcpCardItemDefinition::RankUpRecipe' has a wrong offset!");
static_assert(offsetof(UOrionMcpCardItemDefinition, ItemSetTag) == 0x000270, "Member 'UOrionMcpCardItemDefinition::ItemSetTag' has a wrong offset!");
static_assert(offsetof(UOrionMcpCardItemDefinition, Affinity) == 0x000278, "Member 'UOrionMcpCardItemDefinition::Affinity' has a wrong offset!");
static_assert(offsetof(UOrionMcpCardItemDefinition, CardTrait) == 0x000279, "Member 'UOrionMcpCardItemDefinition::CardTrait' has a wrong offset!");
static_assert(offsetof(UOrionMcpCardItemDefinition, CardCost) == 0x00027C, "Member 'UOrionMcpCardItemDefinition::CardCost' has a wrong offset!");
static_assert(offsetof(UOrionMcpCardItemDefinition, AttributeCoefficientsByParamTag) == 0x000290, "Member 'UOrionMcpCardItemDefinition::AttributeCoefficientsByParamTag' has a wrong offset!");
static_assert(offsetof(UOrionMcpCardItemDefinition, SimpleAbilityKeywords) == 0x0002E0, "Member 'UOrionMcpCardItemDefinition::SimpleAbilityKeywords' has a wrong offset!");
static_assert(offsetof(UOrionMcpCardItemDefinition, AccountLevelUnlock) == 0x0002F0, "Member 'UOrionMcpCardItemDefinition::AccountLevelUnlock' has a wrong offset!");
static_assert(offsetof(UOrionMcpCardItemDefinition, bStarter) == 0x0002F4, "Member 'UOrionMcpCardItemDefinition::bStarter' has a wrong offset!");
static_assert(offsetof(UOrionMcpCardItemDefinition, bPlayEnabled) == 0x0002F5, "Member 'UOrionMcpCardItemDefinition::bPlayEnabled' has a wrong offset!");
static_assert(offsetof(UOrionMcpCardItemDefinition, bShowInUI) == 0x0002F6, "Member 'UOrionMcpCardItemDefinition::bShowInUI' has a wrong offset!");
static_assert(offsetof(UOrionMcpCardItemDefinition, DevelopmentSetName) == 0x0002F8, "Member 'UOrionMcpCardItemDefinition::DevelopmentSetName' has a wrong offset!");

// Class OrionGame.OrionMcpCardPackItem
// 0x0000 (0x0078 - 0x0078)
class UOrionMcpCardPackItem final : public UOrionMcpItem
{
public:
	class UOrionMcpCardPackItemDefinition* GetInternalData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpCardPackItem">();
	}
	static class UOrionMcpCardPackItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpCardPackItem>();
	}
};
static_assert(alignof(UOrionMcpCardPackItem) == 0x000008, "Wrong alignment on UOrionMcpCardPackItem");
static_assert(sizeof(UOrionMcpCardPackItem) == 0x000078, "Wrong size on UOrionMcpCardPackItem");

// Class OrionGame.OrionMcpClashMobItemDefinition
// 0x0098 (0x0300 - 0x0268)
class UOrionMcpClashMobItemDefinition final : public UOrionMcpItemDefinition
{
public:
	struct FGameplayStatTag                       GameplayStat;                                      // 0x0268(0x0010)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayStatTag                       GameplayStatForParticipation;                      // 0x0278(0x0010)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 OptionalSubcategory;                               // 0x0288(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDateTime                              StartTime;                                         // 0x0298(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDateTime                              EndTime;                                           // 0x02A0(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaximumCredits;                                    // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  TagsRequiredForCredit;                             // 0x02B0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  TagsRequiredForParticipation;                      // 0x02D0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TArray<struct FClashMobThreshold>             Thresholds;                                        // 0x02F0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpClashMobItemDefinition">();
	}
	static class UOrionMcpClashMobItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpClashMobItemDefinition>();
	}
};
static_assert(alignof(UOrionMcpClashMobItemDefinition) == 0x000008, "Wrong alignment on UOrionMcpClashMobItemDefinition");
static_assert(sizeof(UOrionMcpClashMobItemDefinition) == 0x000300, "Wrong size on UOrionMcpClashMobItemDefinition");
static_assert(offsetof(UOrionMcpClashMobItemDefinition, GameplayStat) == 0x000268, "Member 'UOrionMcpClashMobItemDefinition::GameplayStat' has a wrong offset!");
static_assert(offsetof(UOrionMcpClashMobItemDefinition, GameplayStatForParticipation) == 0x000278, "Member 'UOrionMcpClashMobItemDefinition::GameplayStatForParticipation' has a wrong offset!");
static_assert(offsetof(UOrionMcpClashMobItemDefinition, OptionalSubcategory) == 0x000288, "Member 'UOrionMcpClashMobItemDefinition::OptionalSubcategory' has a wrong offset!");
static_assert(offsetof(UOrionMcpClashMobItemDefinition, StartTime) == 0x000298, "Member 'UOrionMcpClashMobItemDefinition::StartTime' has a wrong offset!");
static_assert(offsetof(UOrionMcpClashMobItemDefinition, EndTime) == 0x0002A0, "Member 'UOrionMcpClashMobItemDefinition::EndTime' has a wrong offset!");
static_assert(offsetof(UOrionMcpClashMobItemDefinition, MaximumCredits) == 0x0002A8, "Member 'UOrionMcpClashMobItemDefinition::MaximumCredits' has a wrong offset!");
static_assert(offsetof(UOrionMcpClashMobItemDefinition, TagsRequiredForCredit) == 0x0002B0, "Member 'UOrionMcpClashMobItemDefinition::TagsRequiredForCredit' has a wrong offset!");
static_assert(offsetof(UOrionMcpClashMobItemDefinition, TagsRequiredForParticipation) == 0x0002D0, "Member 'UOrionMcpClashMobItemDefinition::TagsRequiredForParticipation' has a wrong offset!");
static_assert(offsetof(UOrionMcpClashMobItemDefinition, Thresholds) == 0x0002F0, "Member 'UOrionMcpClashMobItemDefinition::Thresholds' has a wrong offset!");

// Class OrionGame.OrionMcpCodeTokenItem
// 0x0000 (0x0078 - 0x0078)
class UOrionMcpCodeTokenItem final : public UOrionMcpItem
{
public:
	class UOrionMcpCodeTokenItemDefinition* GetInternalData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpCodeTokenItem">();
	}
	static class UOrionMcpCodeTokenItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpCodeTokenItem>();
	}
};
static_assert(alignof(UOrionMcpCodeTokenItem) == 0x000008, "Wrong alignment on UOrionMcpCodeTokenItem");
static_assert(sizeof(UOrionMcpCodeTokenItem) == 0x000078, "Wrong size on UOrionMcpCodeTokenItem");

// Class OrionGame.OrionMcpCodeTokenItemDefinition
// 0x0028 (0x0290 - 0x0268)
class UOrionMcpCodeTokenItemDefinition final : public UOrionMcpItemDefinition
{
public:
	class FString                                 RedemptionCodeRule;                                // 0x0268(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RedemptionCodeGroup;                               // 0x0278(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_288[0x8];                                      // 0x0288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpCodeTokenItemDefinition">();
	}
	static class UOrionMcpCodeTokenItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpCodeTokenItemDefinition>();
	}
};
static_assert(alignof(UOrionMcpCodeTokenItemDefinition) == 0x000008, "Wrong alignment on UOrionMcpCodeTokenItemDefinition");
static_assert(sizeof(UOrionMcpCodeTokenItemDefinition) == 0x000290, "Wrong size on UOrionMcpCodeTokenItemDefinition");
static_assert(offsetof(UOrionMcpCodeTokenItemDefinition, RedemptionCodeRule) == 0x000268, "Member 'UOrionMcpCodeTokenItemDefinition::RedemptionCodeRule' has a wrong offset!");
static_assert(offsetof(UOrionMcpCodeTokenItemDefinition, RedemptionCodeGroup) == 0x000278, "Member 'UOrionMcpCodeTokenItemDefinition::RedemptionCodeGroup' has a wrong offset!");

// Class OrionGame.OrionComponentItemDefinition
// 0x0038 (0x02A0 - 0x0268)
class UOrionComponentItemDefinition final : public UOrionMcpItemDefinition
{
public:
	bool                                          bEnableExport;                                     // 0x0268(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_269[0x7];                                      // 0x0269(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMaterialInterface>      WorldIconMaterial;                                 // 0x0270(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FOrionAffinityStruct                   Affinities;                                        // 0x0298(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionComponentItemDefinition">();
	}
	static class UOrionComponentItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionComponentItemDefinition>();
	}
};
static_assert(alignof(UOrionComponentItemDefinition) == 0x000008, "Wrong alignment on UOrionComponentItemDefinition");
static_assert(sizeof(UOrionComponentItemDefinition) == 0x0002A0, "Wrong size on UOrionComponentItemDefinition");
static_assert(offsetof(UOrionComponentItemDefinition, bEnableExport) == 0x000268, "Member 'UOrionComponentItemDefinition::bEnableExport' has a wrong offset!");
static_assert(offsetof(UOrionComponentItemDefinition, WorldIconMaterial) == 0x000270, "Member 'UOrionComponentItemDefinition::WorldIconMaterial' has a wrong offset!");
static_assert(offsetof(UOrionComponentItemDefinition, Affinities) == 0x000298, "Member 'UOrionComponentItemDefinition::Affinities' has a wrong offset!");

// Class OrionGame.OrionMcpCrownItemDefinition
// 0x0068 (0x02D0 - 0x0268)
class UOrionMcpCrownItemDefinition final : public UOrionMcpItemDefinition
{
public:
	TSoftObjectPtr<class UStaticMesh>             CrownMesh;                                         // 0x0268(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UParticleSystem>         GlowEffect;                                        // 0x0290(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            CrownMeshLoaded;                                   // 0x02B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        GlowEffectLoaded;                                  // 0x02C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpCrownItemDefinition">();
	}
	static class UOrionMcpCrownItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpCrownItemDefinition>();
	}
};
static_assert(alignof(UOrionMcpCrownItemDefinition) == 0x000008, "Wrong alignment on UOrionMcpCrownItemDefinition");
static_assert(sizeof(UOrionMcpCrownItemDefinition) == 0x0002D0, "Wrong size on UOrionMcpCrownItemDefinition");
static_assert(offsetof(UOrionMcpCrownItemDefinition, CrownMesh) == 0x000268, "Member 'UOrionMcpCrownItemDefinition::CrownMesh' has a wrong offset!");
static_assert(offsetof(UOrionMcpCrownItemDefinition, GlowEffect) == 0x000290, "Member 'UOrionMcpCrownItemDefinition::GlowEffect' has a wrong offset!");
static_assert(offsetof(UOrionMcpCrownItemDefinition, CrownMeshLoaded) == 0x0002B8, "Member 'UOrionMcpCrownItemDefinition::CrownMeshLoaded' has a wrong offset!");
static_assert(offsetof(UOrionMcpCrownItemDefinition, GlowEffectLoaded) == 0x0002C0, "Member 'UOrionMcpCrownItemDefinition::GlowEffectLoaded' has a wrong offset!");

// Class OrionGame.OrionMcpCuratedDeckItemDefinition
// 0x0078 (0x02E0 - 0x0268)
class UOrionMcpCuratedDeckItemDefinition final : public UOrionMcpItemDefinition
{
public:
	struct FGuid                                  CuratedDeckGuid;                                   // 0x0268(0x0010)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FOrionAffinityStruct                   AffinityStruct;                                    // 0x0278(0x0004)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCuratedCardData>               CuratedCards;                                      // 0x0280(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FCuratedGemData>                CuratedGems;                                       // 0x0290(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FOrionStarterDeckContextInfo           StarterDeckContextInfo;                            // 0x02A0(0x0038)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bUsableInGame;                                     // 0x02D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D9[0x7];                                      // 0x02D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpCuratedDeckItemDefinition">();
	}
	static class UOrionMcpCuratedDeckItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpCuratedDeckItemDefinition>();
	}
};
static_assert(alignof(UOrionMcpCuratedDeckItemDefinition) == 0x000008, "Wrong alignment on UOrionMcpCuratedDeckItemDefinition");
static_assert(sizeof(UOrionMcpCuratedDeckItemDefinition) == 0x0002E0, "Wrong size on UOrionMcpCuratedDeckItemDefinition");
static_assert(offsetof(UOrionMcpCuratedDeckItemDefinition, CuratedDeckGuid) == 0x000268, "Member 'UOrionMcpCuratedDeckItemDefinition::CuratedDeckGuid' has a wrong offset!");
static_assert(offsetof(UOrionMcpCuratedDeckItemDefinition, AffinityStruct) == 0x000278, "Member 'UOrionMcpCuratedDeckItemDefinition::AffinityStruct' has a wrong offset!");
static_assert(offsetof(UOrionMcpCuratedDeckItemDefinition, CuratedCards) == 0x000280, "Member 'UOrionMcpCuratedDeckItemDefinition::CuratedCards' has a wrong offset!");
static_assert(offsetof(UOrionMcpCuratedDeckItemDefinition, CuratedGems) == 0x000290, "Member 'UOrionMcpCuratedDeckItemDefinition::CuratedGems' has a wrong offset!");
static_assert(offsetof(UOrionMcpCuratedDeckItemDefinition, StarterDeckContextInfo) == 0x0002A0, "Member 'UOrionMcpCuratedDeckItemDefinition::StarterDeckContextInfo' has a wrong offset!");
static_assert(offsetof(UOrionMcpCuratedDeckItemDefinition, bUsableInGame) == 0x0002D8, "Member 'UOrionMcpCuratedDeckItemDefinition::bUsableInGame' has a wrong offset!");

// Class OrionGame.OrionMcpDeckItemDefinition
// 0x0008 (0x0270 - 0x0268)
class UOrionMcpDeckItemDefinition final : public UOrionMcpItemDefinition
{
public:
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpDeckItemDefinition">();
	}
	static class UOrionMcpDeckItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpDeckItemDefinition>();
	}
};
static_assert(alignof(UOrionMcpDeckItemDefinition) == 0x000008, "Wrong alignment on UOrionMcpDeckItemDefinition");
static_assert(sizeof(UOrionMcpDeckItemDefinition) == 0x000270, "Wrong size on UOrionMcpDeckItemDefinition");

// Class OrionGame.OrionEmoteItemDefinition
// 0x00B8 (0x0320 - 0x0268)
class UOrionEmoteItemDefinition final : public UOrionMcpItemDefinition
{
public:
	EOrionEmoteType                               EmoteType;                                         // 0x0268(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_269[0x3];                                      // 0x0269(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Rarity;                                            // 0x026C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 HeroName;                                          // 0x0270(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowInUI;                                         // 0x0280(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayEnabled;                                      // 0x0281(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_282[0x6];                                      // 0x0282(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSkinAnimMontagePair>           SkinToAnimMontagePairs;                            // 0x0288(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class UOrionSkinItemDefinition*, class UAnimMontage*> SkinToAnimMontageMapLoaded;                        // 0x0298(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAnimMontage>            DefaultAnimMontage;                                // 0x02E8(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           DefaultAnimMontageLoaded;                          // 0x0310(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UAnimMontage* GetAnimMontage(const class UOrionSkinItemDefinition* SkinItemDefinition) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionEmoteItemDefinition">();
	}
	static class UOrionEmoteItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionEmoteItemDefinition>();
	}
};
static_assert(alignof(UOrionEmoteItemDefinition) == 0x000008, "Wrong alignment on UOrionEmoteItemDefinition");
static_assert(sizeof(UOrionEmoteItemDefinition) == 0x000320, "Wrong size on UOrionEmoteItemDefinition");
static_assert(offsetof(UOrionEmoteItemDefinition, EmoteType) == 0x000268, "Member 'UOrionEmoteItemDefinition::EmoteType' has a wrong offset!");
static_assert(offsetof(UOrionEmoteItemDefinition, Rarity) == 0x00026C, "Member 'UOrionEmoteItemDefinition::Rarity' has a wrong offset!");
static_assert(offsetof(UOrionEmoteItemDefinition, HeroName) == 0x000270, "Member 'UOrionEmoteItemDefinition::HeroName' has a wrong offset!");
static_assert(offsetof(UOrionEmoteItemDefinition, bShowInUI) == 0x000280, "Member 'UOrionEmoteItemDefinition::bShowInUI' has a wrong offset!");
static_assert(offsetof(UOrionEmoteItemDefinition, bPlayEnabled) == 0x000281, "Member 'UOrionEmoteItemDefinition::bPlayEnabled' has a wrong offset!");
static_assert(offsetof(UOrionEmoteItemDefinition, SkinToAnimMontagePairs) == 0x000288, "Member 'UOrionEmoteItemDefinition::SkinToAnimMontagePairs' has a wrong offset!");
static_assert(offsetof(UOrionEmoteItemDefinition, SkinToAnimMontageMapLoaded) == 0x000298, "Member 'UOrionEmoteItemDefinition::SkinToAnimMontageMapLoaded' has a wrong offset!");
static_assert(offsetof(UOrionEmoteItemDefinition, DefaultAnimMontage) == 0x0002E8, "Member 'UOrionEmoteItemDefinition::DefaultAnimMontage' has a wrong offset!");
static_assert(offsetof(UOrionEmoteItemDefinition, DefaultAnimMontageLoaded) == 0x000310, "Member 'UOrionEmoteItemDefinition::DefaultAnimMontageLoaded' has a wrong offset!");

// Class OrionGame.OrionMcpGemItemDefinition
// 0x0038 (0x02A0 - 0x0268)
class UOrionMcpGemItemDefinition final : public UOrionMcpItemDefinition
{
public:
	class FName                                   DevelopmentSetName;                                // 0x0268(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           ItemSetTag;                                        // 0x0270(0x0008)(Edit, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EOrionGemBranchType                           GemBranch;                                         // 0x0278(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EOrionGemRank                                 GemRank;                                           // 0x0279(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EOrionGemType                                 GemType;                                           // 0x027A(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27B[0x5];                                      // 0x027B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSimpleAbilityKeywordTag               BaseGemAbilityKeyword;                             // 0x0280(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSoftObjectPtr<class UOrionMcpGemKeywordBucketItemDefinition>> GemAbilityKeywordBuckets;                          // 0x0288(0x0010)(Edit, ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	bool                                          bStarter;                                          // 0x0298(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPlayEnabled;                                      // 0x0299(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShowInUI;                                         // 0x029A(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29B[0x5];                                      // 0x029B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpGemItemDefinition">();
	}
	static class UOrionMcpGemItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpGemItemDefinition>();
	}
};
static_assert(alignof(UOrionMcpGemItemDefinition) == 0x000008, "Wrong alignment on UOrionMcpGemItemDefinition");
static_assert(sizeof(UOrionMcpGemItemDefinition) == 0x0002A0, "Wrong size on UOrionMcpGemItemDefinition");
static_assert(offsetof(UOrionMcpGemItemDefinition, DevelopmentSetName) == 0x000268, "Member 'UOrionMcpGemItemDefinition::DevelopmentSetName' has a wrong offset!");
static_assert(offsetof(UOrionMcpGemItemDefinition, ItemSetTag) == 0x000270, "Member 'UOrionMcpGemItemDefinition::ItemSetTag' has a wrong offset!");
static_assert(offsetof(UOrionMcpGemItemDefinition, GemBranch) == 0x000278, "Member 'UOrionMcpGemItemDefinition::GemBranch' has a wrong offset!");
static_assert(offsetof(UOrionMcpGemItemDefinition, GemRank) == 0x000279, "Member 'UOrionMcpGemItemDefinition::GemRank' has a wrong offset!");
static_assert(offsetof(UOrionMcpGemItemDefinition, GemType) == 0x00027A, "Member 'UOrionMcpGemItemDefinition::GemType' has a wrong offset!");
static_assert(offsetof(UOrionMcpGemItemDefinition, BaseGemAbilityKeyword) == 0x000280, "Member 'UOrionMcpGemItemDefinition::BaseGemAbilityKeyword' has a wrong offset!");
static_assert(offsetof(UOrionMcpGemItemDefinition, GemAbilityKeywordBuckets) == 0x000288, "Member 'UOrionMcpGemItemDefinition::GemAbilityKeywordBuckets' has a wrong offset!");
static_assert(offsetof(UOrionMcpGemItemDefinition, bStarter) == 0x000298, "Member 'UOrionMcpGemItemDefinition::bStarter' has a wrong offset!");
static_assert(offsetof(UOrionMcpGemItemDefinition, bPlayEnabled) == 0x000299, "Member 'UOrionMcpGemItemDefinition::bPlayEnabled' has a wrong offset!");
static_assert(offsetof(UOrionMcpGemItemDefinition, bShowInUI) == 0x00029A, "Member 'UOrionMcpGemItemDefinition::bShowInUI' has a wrong offset!");

// Class OrionGame.OrionMcpGiftBoxItem
// 0x0030 (0x00A8 - 0x0078)
class UOrionMcpGiftBoxItem final : public UOrionMcpItem
{
public:
	class FString                                 GiftBoxType;                                       // 0x0078(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMcpLootResult                         LootResult;                                        // 0x0088(0x0020)(NativeAccessSpecifierPublic)

public:
	class UOrionMcpGiftBoxItemDefinition* GetInternalData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpGiftBoxItem">();
	}
	static class UOrionMcpGiftBoxItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpGiftBoxItem>();
	}
};
static_assert(alignof(UOrionMcpGiftBoxItem) == 0x000008, "Wrong alignment on UOrionMcpGiftBoxItem");
static_assert(sizeof(UOrionMcpGiftBoxItem) == 0x0000A8, "Wrong size on UOrionMcpGiftBoxItem");
static_assert(offsetof(UOrionMcpGiftBoxItem, GiftBoxType) == 0x000078, "Member 'UOrionMcpGiftBoxItem::GiftBoxType' has a wrong offset!");
static_assert(offsetof(UOrionMcpGiftBoxItem, LootResult) == 0x000088, "Member 'UOrionMcpGiftBoxItem::LootResult' has a wrong offset!");

// Class OrionGame.OrionMcpGlyphItem
// 0x0008 (0x0080 - 0x0078)
class UOrionMcpGlyphItem final : public UOrionMcpItem
{
public:
	struct FColor                                 Color;                                             // 0x0078(0x0004)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UOrionMcpGlyphItemDefinition* GetInternalData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpGlyphItem">();
	}
	static class UOrionMcpGlyphItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpGlyphItem>();
	}
};
static_assert(alignof(UOrionMcpGlyphItem) == 0x000008, "Wrong alignment on UOrionMcpGlyphItem");
static_assert(sizeof(UOrionMcpGlyphItem) == 0x000080, "Wrong size on UOrionMcpGlyphItem");
static_assert(offsetof(UOrionMcpGlyphItem, Color) == 0x000078, "Member 'UOrionMcpGlyphItem::Color' has a wrong offset!");

// Class OrionGame.OrionMcpHeroItem
// 0x0328 (0x03A0 - 0x0078)
class UOrionMcpHeroItem final : public UOrionMcpItem
{
public:
	struct FOrionHeroMasteryProgression           Mastery;                                           // 0x0078(0x0020)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayStats                         PVP_Stats;                                         // 0x0098(0x0108)(NativeAccessSpecifierPublic)
	struct FGameplayStats                         Total_Stats;                                       // 0x01A0(0x0108)(NativeAccessSpecifierPublic)
	class FString                                 LastDeckUsed;                                      // 0x02A8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnlocked;                                         // 0x02B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionCosmeticPlayerChoices            CosmeticChoices;                                   // 0x02C0(0x00E0)(NativeAccessSpecifierPrivate)

public:
	class UOrionHeroData* GetInternalData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpHeroItem">();
	}
	static class UOrionMcpHeroItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpHeroItem>();
	}
};
static_assert(alignof(UOrionMcpHeroItem) == 0x000008, "Wrong alignment on UOrionMcpHeroItem");
static_assert(sizeof(UOrionMcpHeroItem) == 0x0003A0, "Wrong size on UOrionMcpHeroItem");
static_assert(offsetof(UOrionMcpHeroItem, Mastery) == 0x000078, "Member 'UOrionMcpHeroItem::Mastery' has a wrong offset!");
static_assert(offsetof(UOrionMcpHeroItem, PVP_Stats) == 0x000098, "Member 'UOrionMcpHeroItem::PVP_Stats' has a wrong offset!");
static_assert(offsetof(UOrionMcpHeroItem, Total_Stats) == 0x0001A0, "Member 'UOrionMcpHeroItem::Total_Stats' has a wrong offset!");
static_assert(offsetof(UOrionMcpHeroItem, LastDeckUsed) == 0x0002A8, "Member 'UOrionMcpHeroItem::LastDeckUsed' has a wrong offset!");
static_assert(offsetof(UOrionMcpHeroItem, bUnlocked) == 0x0002B8, "Member 'UOrionMcpHeroItem::bUnlocked' has a wrong offset!");
static_assert(offsetof(UOrionMcpHeroItem, CosmeticChoices) == 0x0002C0, "Member 'UOrionMcpHeroItem::CosmeticChoices' has a wrong offset!");

// Class OrionGame.OrionLegacyCardItemDefinition
// 0x0018 (0x0280 - 0x0268)
class UOrionLegacyCardItemDefinition final : public UOrionMcpItemDefinition
{
public:
	struct FOrionAffinityStruct                   Affinities;                                        // 0x0268(0x0004)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	EOrionCardSlottypes                           CardSlotType;                                      // 0x026C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionCardRarity                              CardRarity;                                        // 0x026D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26E[0x2];                                      // 0x026E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BaseSetQuantity;                                   // 0x0270(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_274[0xC];                                      // 0x0274(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionLegacyCardItemDefinition">();
	}
	static class UOrionLegacyCardItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionLegacyCardItemDefinition>();
	}
};
static_assert(alignof(UOrionLegacyCardItemDefinition) == 0x000008, "Wrong alignment on UOrionLegacyCardItemDefinition");
static_assert(sizeof(UOrionLegacyCardItemDefinition) == 0x000280, "Wrong size on UOrionLegacyCardItemDefinition");
static_assert(offsetof(UOrionLegacyCardItemDefinition, Affinities) == 0x000268, "Member 'UOrionLegacyCardItemDefinition::Affinities' has a wrong offset!");
static_assert(offsetof(UOrionLegacyCardItemDefinition, CardSlotType) == 0x00026C, "Member 'UOrionLegacyCardItemDefinition::CardSlotType' has a wrong offset!");
static_assert(offsetof(UOrionLegacyCardItemDefinition, CardRarity) == 0x00026D, "Member 'UOrionLegacyCardItemDefinition::CardRarity' has a wrong offset!");
static_assert(offsetof(UOrionLegacyCardItemDefinition, BaseSetQuantity) == 0x000270, "Member 'UOrionLegacyCardItemDefinition::BaseSetQuantity' has a wrong offset!");

// Class OrionGame.OrionMcpProfileAccount
// 0x0090 (0x0340 - 0x02B0)
class UOrionMcpProfileAccount final : public UOrionMcpProfile
{
public:
	struct FItemIdList                            NewItemsToClear;                                   // 0x02B0(0x0010)(NativeAccessSpecifierPrivate)
	struct FTimerHandle                           SendNewItemTimer;                                  // 0x02C0(0x0008)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C8[0x78];                                     // 0x02C8(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateBoost(const class FString& BoostId, struct FClientUrlContext* Context);
	void ApplyBannerAlteration(const class FString& bannerId, const class FString& AlterationId, int32 AlterationSlot, struct FClientUrlContext* Context);
	void AttachBanner(const class FString& AttacheeId, const class FString& AttachmentId, int32 SocketIndex, struct FClientUrlContext* Context);
	void BannerBulkEdit(const struct FBannerBulkCommandList& Commands, struct FClientUrlContext* Context);
	void CheckForStuff(struct FClientUrlContext* Context);
	void ClaimLoginReward(struct FClientUrlContext* Context);
	void CompleteMatch(const class FString& HeroTemplateName, const struct FGameplayStats& NewStatsV2, const struct FTeamOwnershipXPBonus& TeamOwnershipXPBonus, const struct FOrionPlayerEndMatchData& EndMatchData, struct FDedicatedServerUrlContext* Context);
	void CreateNewUserDeck(struct FClientUrlContext* Context);
	void CreditClientStat(const class FString& StatName, const int32 StatCount, struct FClientUrlContext* Context);
	void DeleteDeck(const class FString& DeckId, struct FClientUrlContext* Context);
	void ExtractBannerAlteration(const class FString& bannerId, int32 AlterationSlot, struct FClientUrlContext* Context);
	void IssueFriendCode(const class FString& CodeTokenType, struct FClientUrlContext* Context);
	void NoteNewItems(const struct FItemIdList& NewItemList, struct FClientUrlContext* Context);
	void OnRotationalContentChanged__DelegateSignature();
	void OpenCardPack(const class FString& CardPackItemId, const class FString& KeyId, struct FClientUrlContext* Context);
	void OpenGiftBox(const class FString& GiftBoxItemID, struct FClientUrlContext* Context);
	void OpenVault(const class FString& VaultTemplateName, struct FClientUrlContext* Context);
	void PrestigeAccount(struct FClientUrlContext* Context);
	void PurchaseDeckSlot(bool MtxEquivalency, struct FClientUrlContext* Context);
	void RankUpCard(const class FString& CardTemplateId, bool MtxEquivalency, struct FClientUrlContext* Context);
	void RankUpMastery(const class FString& HeroItemId, bool MtxEquivalency, bool ApplyLastMatch, struct FClientUrlContext* Context);
	void ReportQueueDodge(EOrionDodgeType DodgeType, struct FDedicatedServerUrlContext* Context);
	void SelectFreeMasteryHero(const class FString& HeroItemId, const class FString& TokenTemplateName, struct FClientUrlContext* Context);
	void SetBannerForAccount(const class FString& bannerId, struct FClientUrlContext* Context);
	void SetBannerName(const class FString& bannerName, const class FString& bannerId, struct FClientUrlContext* Context);
	void SetCosmeticChoices(const class FString& HeroId, const struct FOrionCosmeticPlayerChoices& CosmeticChoices, struct FClientUrlContext* Context);
	void SetDeckName(const class FString& DeckName, const class FString& DeckId, struct FClientUrlContext* Context);
	void SetPlatform(const EOrionPlatformType NewPlatform, struct FClientUrlContext* Context);
	void SetPlayerVeterancy(const EOrionVeterancy& Veterancy, struct FClientUrlContext* Context);
	void SetSkinCosmeticChoices(const class FString& SkinName, const class FString& ActiveSkinVariation, struct FClientUrlContext* Context);
	void SetUserCreatedDeck(const struct FUserCreatedDeck& UserCreatedDeck, const class FString& DeckId, struct FClientUrlContext* Context);
	void UpdateAccountStatus(struct FClientUrlContext* Context);
	void UpdateSimpleAchievements(const struct FSimpleAchievements& NewSimpleAchievements, const int32 RelayNotifictaion, struct FClientUrlContext* Context);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpProfileAccount">();
	}
	static class UOrionMcpProfileAccount* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpProfileAccount>();
	}
};
static_assert(alignof(UOrionMcpProfileAccount) == 0x000008, "Wrong alignment on UOrionMcpProfileAccount");
static_assert(sizeof(UOrionMcpProfileAccount) == 0x000340, "Wrong size on UOrionMcpProfileAccount");
static_assert(offsetof(UOrionMcpProfileAccount, NewItemsToClear) == 0x0002B0, "Member 'UOrionMcpProfileAccount::NewItemsToClear' has a wrong offset!");
static_assert(offsetof(UOrionMcpProfileAccount, SendNewItemTimer) == 0x0002C0, "Member 'UOrionMcpProfileAccount::SendNewItemTimer' has a wrong offset!");

// Class OrionGame.OrionMcpQuestItem
// 0x0238 (0x02B0 - 0x0078)
class UOrionMcpQuestItem final : public UOrionMcpItem
{
public:
	uint8                                         Pad_78[0x218];                                     // 0x0078(0x0218)(Fixing Size After Last Property [ Dumper-7 ])
	EOrionQuestState                              Quest_state;                                       // 0x0290(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_291[0x7];                                      // 0x0291(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              Last_state_change_time;                            // 0x0298(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllObjectivesComplete;                            // 0x02A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A1[0x3];                                      // 0x02A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentStage;                                      // 0x02A4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumberOfTimesRest;                                 // 0x02A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UOrionMcpQuestItemDefinition* GetInternalData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpQuestItem">();
	}
	static class UOrionMcpQuestItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpQuestItem>();
	}
};
static_assert(alignof(UOrionMcpQuestItem) == 0x000008, "Wrong alignment on UOrionMcpQuestItem");
static_assert(sizeof(UOrionMcpQuestItem) == 0x0002B0, "Wrong size on UOrionMcpQuestItem");
static_assert(offsetof(UOrionMcpQuestItem, Quest_state) == 0x000290, "Member 'UOrionMcpQuestItem::Quest_state' has a wrong offset!");
static_assert(offsetof(UOrionMcpQuestItem, Last_state_change_time) == 0x000298, "Member 'UOrionMcpQuestItem::Last_state_change_time' has a wrong offset!");
static_assert(offsetof(UOrionMcpQuestItem, bAllObjectivesComplete) == 0x0002A0, "Member 'UOrionMcpQuestItem::bAllObjectivesComplete' has a wrong offset!");
static_assert(offsetof(UOrionMcpQuestItem, CurrentStage) == 0x0002A4, "Member 'UOrionMcpQuestItem::CurrentStage' has a wrong offset!");
static_assert(offsetof(UOrionMcpQuestItem, NumberOfTimesRest) == 0x0002A8, "Member 'UOrionMcpQuestItem::NumberOfTimesRest' has a wrong offset!");

// Class OrionGame.OrionMcpQuestItemDefinition
// 0x0118 (0x0380 - 0x0268)
class UOrionMcpQuestItemDefinition final : public UOrionMcpItemDefinition
{
public:
	struct FGuid                                  QuestGuid;                                         // 0x0268(0x0010)(Edit, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrionQuestType                               QuestType;                                         // 0x0278(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_279[0x3];                                      // 0x0279(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         QuestPlaylistId;                                   // 0x027C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  Prerequisites;                                     // 0x0280(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TArray<struct FOrionQuestPrerequisites>       OrionPrerequisites;                                // 0x02A0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UOrionMcpQuestItemDefinition*           PrerequisiteQuest;                                 // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  TagsRequiredForCredit;                             // 0x02B8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   RewardDescription;                                 // 0x02D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   CompletionText;                                    // 0x02F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bHidden;                                           // 0x0308(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrionQuestRegistration                       RegistrationType;                                  // 0x0309(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30A[0x6];                                      // 0x030A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOrionMcpQuestObjectiveInfo>    Objectives;                                        // 0x0310(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         ResetCompletionCount;                              // 0x0320(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_324[0x4];                                      // 0x0324(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOrionItemQuantityPair>         Rewards;                                           // 0x0328(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FOrionGameQuestReward                  InGameRewards;                                     // 0x0338(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   QuestGrantedEventName;                             // 0x0370(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   QuestCompletedEventName;                           // 0x0378(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpQuestItemDefinition">();
	}
	static class UOrionMcpQuestItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpQuestItemDefinition>();
	}
};
static_assert(alignof(UOrionMcpQuestItemDefinition) == 0x000008, "Wrong alignment on UOrionMcpQuestItemDefinition");
static_assert(sizeof(UOrionMcpQuestItemDefinition) == 0x000380, "Wrong size on UOrionMcpQuestItemDefinition");
static_assert(offsetof(UOrionMcpQuestItemDefinition, QuestGuid) == 0x000268, "Member 'UOrionMcpQuestItemDefinition::QuestGuid' has a wrong offset!");
static_assert(offsetof(UOrionMcpQuestItemDefinition, QuestType) == 0x000278, "Member 'UOrionMcpQuestItemDefinition::QuestType' has a wrong offset!");
static_assert(offsetof(UOrionMcpQuestItemDefinition, QuestPlaylistId) == 0x00027C, "Member 'UOrionMcpQuestItemDefinition::QuestPlaylistId' has a wrong offset!");
static_assert(offsetof(UOrionMcpQuestItemDefinition, Prerequisites) == 0x000280, "Member 'UOrionMcpQuestItemDefinition::Prerequisites' has a wrong offset!");
static_assert(offsetof(UOrionMcpQuestItemDefinition, OrionPrerequisites) == 0x0002A0, "Member 'UOrionMcpQuestItemDefinition::OrionPrerequisites' has a wrong offset!");
static_assert(offsetof(UOrionMcpQuestItemDefinition, PrerequisiteQuest) == 0x0002B0, "Member 'UOrionMcpQuestItemDefinition::PrerequisiteQuest' has a wrong offset!");
static_assert(offsetof(UOrionMcpQuestItemDefinition, TagsRequiredForCredit) == 0x0002B8, "Member 'UOrionMcpQuestItemDefinition::TagsRequiredForCredit' has a wrong offset!");
static_assert(offsetof(UOrionMcpQuestItemDefinition, RewardDescription) == 0x0002D8, "Member 'UOrionMcpQuestItemDefinition::RewardDescription' has a wrong offset!");
static_assert(offsetof(UOrionMcpQuestItemDefinition, CompletionText) == 0x0002F0, "Member 'UOrionMcpQuestItemDefinition::CompletionText' has a wrong offset!");
static_assert(offsetof(UOrionMcpQuestItemDefinition, bHidden) == 0x000308, "Member 'UOrionMcpQuestItemDefinition::bHidden' has a wrong offset!");
static_assert(offsetof(UOrionMcpQuestItemDefinition, RegistrationType) == 0x000309, "Member 'UOrionMcpQuestItemDefinition::RegistrationType' has a wrong offset!");
static_assert(offsetof(UOrionMcpQuestItemDefinition, Objectives) == 0x000310, "Member 'UOrionMcpQuestItemDefinition::Objectives' has a wrong offset!");
static_assert(offsetof(UOrionMcpQuestItemDefinition, ResetCompletionCount) == 0x000320, "Member 'UOrionMcpQuestItemDefinition::ResetCompletionCount' has a wrong offset!");
static_assert(offsetof(UOrionMcpQuestItemDefinition, Rewards) == 0x000328, "Member 'UOrionMcpQuestItemDefinition::Rewards' has a wrong offset!");
static_assert(offsetof(UOrionMcpQuestItemDefinition, InGameRewards) == 0x000338, "Member 'UOrionMcpQuestItemDefinition::InGameRewards' has a wrong offset!");
static_assert(offsetof(UOrionMcpQuestItemDefinition, QuestGrantedEventName) == 0x000370, "Member 'UOrionMcpQuestItemDefinition::QuestGrantedEventName' has a wrong offset!");
static_assert(offsetof(UOrionMcpQuestItemDefinition, QuestCompletedEventName) == 0x000378, "Member 'UOrionMcpQuestItemDefinition::QuestCompletedEventName' has a wrong offset!");

// Class OrionGame.OrionMcpRecipeItemDefinition
// 0x0000 (0x0268 - 0x0268)
#pragma pack(push, 0x1)
class alignas(0x08) UOrionMcpRecipeItemDefinition : public UOrionMcpItemDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpRecipeItemDefinition">();
	}
	static class UOrionMcpRecipeItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpRecipeItemDefinition>();
	}
};
#pragma pack(pop)
static_assert(alignof(UOrionMcpRecipeItemDefinition) == 0x000008, "Wrong alignment on UOrionMcpRecipeItemDefinition");
static_assert(sizeof(UOrionMcpRecipeItemDefinition) == 0x000268, "Wrong size on UOrionMcpRecipeItemDefinition");

// Class OrionGame.OrionMcpRankUpRecipeItemDefinition
// 0x0028 (0x0290 - 0x0268)
class UOrionMcpRankUpRecipeItemDefinition final : public UOrionMcpRecipeItemDefinition
{
public:
	TArray<struct FMcpRankUpInfo>                 RankUpInfo;                                        // 0x0268(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UOrionMcpTokenItemDefinition*>   FreeTokens;                                        // 0x0278(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_288[0x8];                                      // 0x0288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpRankUpRecipeItemDefinition">();
	}
	static class UOrionMcpRankUpRecipeItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpRankUpRecipeItemDefinition>();
	}
};
static_assert(alignof(UOrionMcpRankUpRecipeItemDefinition) == 0x000008, "Wrong alignment on UOrionMcpRankUpRecipeItemDefinition");
static_assert(sizeof(UOrionMcpRankUpRecipeItemDefinition) == 0x000290, "Wrong size on UOrionMcpRankUpRecipeItemDefinition");
static_assert(offsetof(UOrionMcpRankUpRecipeItemDefinition, RankUpInfo) == 0x000268, "Member 'UOrionMcpRankUpRecipeItemDefinition::RankUpInfo' has a wrong offset!");
static_assert(offsetof(UOrionMcpRankUpRecipeItemDefinition, FreeTokens) == 0x000278, "Member 'UOrionMcpRankUpRecipeItemDefinition::FreeTokens' has a wrong offset!");

// Class OrionGame.OrionMcpSkinItem
// 0x0018 (0x0090 - 0x0078)
class UOrionMcpSkinItem final : public UOrionMcpItem
{
public:
	int32                                         OrderReceived;                                     // 0x0078(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionSkinCosmeticChoices              SkinCosmeticChoices;                               // 0x0080(0x0010)(NativeAccessSpecifierPrivate)

public:
	class UOrionSkinItemDefinition* GetInternalData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpSkinItem">();
	}
	static class UOrionMcpSkinItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpSkinItem>();
	}
};
static_assert(alignof(UOrionMcpSkinItem) == 0x000008, "Wrong alignment on UOrionMcpSkinItem");
static_assert(sizeof(UOrionMcpSkinItem) == 0x000090, "Wrong size on UOrionMcpSkinItem");
static_assert(offsetof(UOrionMcpSkinItem, OrderReceived) == 0x000078, "Member 'UOrionMcpSkinItem::OrderReceived' has a wrong offset!");
static_assert(offsetof(UOrionMcpSkinItem, SkinCosmeticChoices) == 0x000080, "Member 'UOrionMcpSkinItem::SkinCosmeticChoices' has a wrong offset!");

// Class OrionGame.OrionSkinItemDefinition
// 0x01A8 (0x0410 - 0x0268)
class UOrionSkinItemDefinition final : public UOrionMcpItemDefinition
{
public:
	TSoftClassPtr<class UClass>                   PawnClassOverride;                                 // 0x0268(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   AnimInstanceClass;                                 // 0x0290(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSkinSpawnOverrideItem>         SpawnOverrides;                                    // 0x02B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSkinAnimOverride>              AnimOverrides;                                     // 0x02C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   GameplayCueOverrideString;                         // 0x02D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   SimpleActor;                                       // 0x02E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSkinSkeletalAttachment                BaseMesh;                                          // 0x0308(0x0090)(Edit, NativeAccessSpecifierPrivate)
	TArray<struct FSkinSkeletalAttachment>        SkeletalAttachments;                               // 0x0398(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSkinSocketedAttachment>        SocketedAttachments;                               // 0x03A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class FString                                 HeroName;                                          // 0x03B8(0x0010)(Edit, ZeroConstructor, EditConst, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  SkinGuid;                                          // 0x03C8(0x0010)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShowInUI;                                         // 0x03D8(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPlayEnabled;                                      // 0x03D9(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAllowPreview;                                     // 0x03DA(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSelfDoubleXP;                                     // 0x03DB(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSelfDoubleTimeCurrency;                           // 0x03DC(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTeamDoubleXP;                                     // 0x03DD(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTeamDoubleTimeCurrency;                           // 0x03DE(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bMatchDoubleXP;                                    // 0x03DF(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bMatchTeamDoubleTimeCurrency;                      // 0x03E0(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bContagious;                                       // 0x03E1(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E2[0x6];                                      // 0x03E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         EventRestrictions;                                 // 0x03E8(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	TSubclassOf<class UAnimInstance>              AnimInstanceLoaded;                                // 0x03F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AOrionChar>                 LoadedPawnClass;                                   // 0x0400(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_408[0x8];                                      // 0x0408(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_ApplySkinToComponent(class USkinnedMeshComponent* MeshComponent, class UOrionSkinVariationItemDefinition* InSkinVariation) const;
	TSubclassOf<class UAnimInstance> GetAnimInstanceClass() const;
	TSubclassOf<class AOrionChar> GetPawnClassOverride() const;
	class USkeletalMesh* GetSkelMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionSkinItemDefinition">();
	}
	static class UOrionSkinItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionSkinItemDefinition>();
	}
};
static_assert(alignof(UOrionSkinItemDefinition) == 0x000008, "Wrong alignment on UOrionSkinItemDefinition");
static_assert(sizeof(UOrionSkinItemDefinition) == 0x000410, "Wrong size on UOrionSkinItemDefinition");
static_assert(offsetof(UOrionSkinItemDefinition, PawnClassOverride) == 0x000268, "Member 'UOrionSkinItemDefinition::PawnClassOverride' has a wrong offset!");
static_assert(offsetof(UOrionSkinItemDefinition, AnimInstanceClass) == 0x000290, "Member 'UOrionSkinItemDefinition::AnimInstanceClass' has a wrong offset!");
static_assert(offsetof(UOrionSkinItemDefinition, SpawnOverrides) == 0x0002B8, "Member 'UOrionSkinItemDefinition::SpawnOverrides' has a wrong offset!");
static_assert(offsetof(UOrionSkinItemDefinition, AnimOverrides) == 0x0002C8, "Member 'UOrionSkinItemDefinition::AnimOverrides' has a wrong offset!");
static_assert(offsetof(UOrionSkinItemDefinition, GameplayCueOverrideString) == 0x0002D8, "Member 'UOrionSkinItemDefinition::GameplayCueOverrideString' has a wrong offset!");
static_assert(offsetof(UOrionSkinItemDefinition, SimpleActor) == 0x0002E0, "Member 'UOrionSkinItemDefinition::SimpleActor' has a wrong offset!");
static_assert(offsetof(UOrionSkinItemDefinition, BaseMesh) == 0x000308, "Member 'UOrionSkinItemDefinition::BaseMesh' has a wrong offset!");
static_assert(offsetof(UOrionSkinItemDefinition, SkeletalAttachments) == 0x000398, "Member 'UOrionSkinItemDefinition::SkeletalAttachments' has a wrong offset!");
static_assert(offsetof(UOrionSkinItemDefinition, SocketedAttachments) == 0x0003A8, "Member 'UOrionSkinItemDefinition::SocketedAttachments' has a wrong offset!");
static_assert(offsetof(UOrionSkinItemDefinition, HeroName) == 0x0003B8, "Member 'UOrionSkinItemDefinition::HeroName' has a wrong offset!");
static_assert(offsetof(UOrionSkinItemDefinition, SkinGuid) == 0x0003C8, "Member 'UOrionSkinItemDefinition::SkinGuid' has a wrong offset!");
static_assert(offsetof(UOrionSkinItemDefinition, bShowInUI) == 0x0003D8, "Member 'UOrionSkinItemDefinition::bShowInUI' has a wrong offset!");
static_assert(offsetof(UOrionSkinItemDefinition, bPlayEnabled) == 0x0003D9, "Member 'UOrionSkinItemDefinition::bPlayEnabled' has a wrong offset!");
static_assert(offsetof(UOrionSkinItemDefinition, bAllowPreview) == 0x0003DA, "Member 'UOrionSkinItemDefinition::bAllowPreview' has a wrong offset!");
static_assert(offsetof(UOrionSkinItemDefinition, bSelfDoubleXP) == 0x0003DB, "Member 'UOrionSkinItemDefinition::bSelfDoubleXP' has a wrong offset!");
static_assert(offsetof(UOrionSkinItemDefinition, bSelfDoubleTimeCurrency) == 0x0003DC, "Member 'UOrionSkinItemDefinition::bSelfDoubleTimeCurrency' has a wrong offset!");
static_assert(offsetof(UOrionSkinItemDefinition, bTeamDoubleXP) == 0x0003DD, "Member 'UOrionSkinItemDefinition::bTeamDoubleXP' has a wrong offset!");
static_assert(offsetof(UOrionSkinItemDefinition, bTeamDoubleTimeCurrency) == 0x0003DE, "Member 'UOrionSkinItemDefinition::bTeamDoubleTimeCurrency' has a wrong offset!");
static_assert(offsetof(UOrionSkinItemDefinition, bMatchDoubleXP) == 0x0003DF, "Member 'UOrionSkinItemDefinition::bMatchDoubleXP' has a wrong offset!");
static_assert(offsetof(UOrionSkinItemDefinition, bMatchTeamDoubleTimeCurrency) == 0x0003E0, "Member 'UOrionSkinItemDefinition::bMatchTeamDoubleTimeCurrency' has a wrong offset!");
static_assert(offsetof(UOrionSkinItemDefinition, bContagious) == 0x0003E1, "Member 'UOrionSkinItemDefinition::bContagious' has a wrong offset!");
static_assert(offsetof(UOrionSkinItemDefinition, EventRestrictions) == 0x0003E8, "Member 'UOrionSkinItemDefinition::EventRestrictions' has a wrong offset!");
static_assert(offsetof(UOrionSkinItemDefinition, AnimInstanceLoaded) == 0x0003F8, "Member 'UOrionSkinItemDefinition::AnimInstanceLoaded' has a wrong offset!");
static_assert(offsetof(UOrionSkinItemDefinition, LoadedPawnClass) == 0x000400, "Member 'UOrionSkinItemDefinition::LoadedPawnClass' has a wrong offset!");

// Class OrionGame.OrionSkinVariationItemDefinition
// 0x01C8 (0x0430 - 0x0268)
class UOrionSkinVariationItemDefinition final : public UOrionMcpItemDefinition
{
public:
	class UOrionSkinItemDefinition*               ParentSkin;                                        // 0x0268(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAllowPreview;                                     // 0x0270(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanBeUsed;                                        // 0x0271(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_272[0x6];                                      // 0x0272(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLinearColor>                   SwatchIconColors;                                  // 0x0278(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FSkinVariantParamOverrides             HardOverrides;                                     // 0x0288(0x0150)(NativeAccessSpecifierPrivate)
	TMap<TSoftObjectPtr<class UMaterialInterface>, struct FSkinVariantParamOverrides> OverridesByMaterial;                               // 0x03D8(0x0050)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_428[0x8];                                      // 0x0428(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void GetAllValidVariantsOfSkin(const class UOrionSkinItemDefinition* Skin, TArray<class UOrionSkinVariationItemDefinition*>* AllVariantsOfSkin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionSkinVariationItemDefinition">();
	}
	static class UOrionSkinVariationItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionSkinVariationItemDefinition>();
	}
};
static_assert(alignof(UOrionSkinVariationItemDefinition) == 0x000008, "Wrong alignment on UOrionSkinVariationItemDefinition");
static_assert(sizeof(UOrionSkinVariationItemDefinition) == 0x000430, "Wrong size on UOrionSkinVariationItemDefinition");
static_assert(offsetof(UOrionSkinVariationItemDefinition, ParentSkin) == 0x000268, "Member 'UOrionSkinVariationItemDefinition::ParentSkin' has a wrong offset!");
static_assert(offsetof(UOrionSkinVariationItemDefinition, bAllowPreview) == 0x000270, "Member 'UOrionSkinVariationItemDefinition::bAllowPreview' has a wrong offset!");
static_assert(offsetof(UOrionSkinVariationItemDefinition, bCanBeUsed) == 0x000271, "Member 'UOrionSkinVariationItemDefinition::bCanBeUsed' has a wrong offset!");
static_assert(offsetof(UOrionSkinVariationItemDefinition, SwatchIconColors) == 0x000278, "Member 'UOrionSkinVariationItemDefinition::SwatchIconColors' has a wrong offset!");
static_assert(offsetof(UOrionSkinVariationItemDefinition, HardOverrides) == 0x000288, "Member 'UOrionSkinVariationItemDefinition::HardOverrides' has a wrong offset!");
static_assert(offsetof(UOrionSkinVariationItemDefinition, OverridesByMaterial) == 0x0003D8, "Member 'UOrionSkinVariationItemDefinition::OverridesByMaterial' has a wrong offset!");

// Class OrionGame.OrionMcpTokenItem
// 0x0000 (0x0078 - 0x0078)
class UOrionMcpTokenItem final : public UOrionMcpItem
{
public:
	class UOrionMcpTokenItemDefinition* GetInternalData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpTokenItem">();
	}
	static class UOrionMcpTokenItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpTokenItem>();
	}
};
static_assert(alignof(UOrionMcpTokenItem) == 0x000008, "Wrong alignment on UOrionMcpTokenItem");
static_assert(sizeof(UOrionMcpTokenItem) == 0x000078, "Wrong size on UOrionMcpTokenItem");

// Class OrionGame.OrionMcpTokenItemDefinition
// 0x00B8 (0x0320 - 0x0268)
class UOrionMcpTokenItemDefinition final : public UOrionMcpItemDefinition
{
public:
	class FText                                   LootCrateDisplayName;                              // 0x0268(0x0018)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              LootCrateDisplayAsset;                             // 0x0280(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsReward;                                         // 0x02A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A9[0x7];                                      // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UOrionMcpItemDefinition>> Substitutions;                                     // 0x02B0(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FCompositeSubtitution>          CompositeSubstitutions;                            // 0x02C0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UOrionMcpItemDefinition> EquivalencyType;                                   // 0x02D0(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         EquivalencyQuantity;                               // 0x02F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAlwaysReplaceStack;                               // 0x02FC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FD[0x3];                                      // 0x02FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PersistentNameOverride;                            // 0x0300(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMakeNewItemNotification;                          // 0x0310(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDirectGrantEnabled;                               // 0x0311(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_312[0xE];                                      // 0x0312(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpTokenItemDefinition">();
	}
	static class UOrionMcpTokenItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpTokenItemDefinition>();
	}
};
static_assert(alignof(UOrionMcpTokenItemDefinition) == 0x000008, "Wrong alignment on UOrionMcpTokenItemDefinition");
static_assert(sizeof(UOrionMcpTokenItemDefinition) == 0x000320, "Wrong size on UOrionMcpTokenItemDefinition");
static_assert(offsetof(UOrionMcpTokenItemDefinition, LootCrateDisplayName) == 0x000268, "Member 'UOrionMcpTokenItemDefinition::LootCrateDisplayName' has a wrong offset!");
static_assert(offsetof(UOrionMcpTokenItemDefinition, LootCrateDisplayAsset) == 0x000280, "Member 'UOrionMcpTokenItemDefinition::LootCrateDisplayAsset' has a wrong offset!");
static_assert(offsetof(UOrionMcpTokenItemDefinition, bIsReward) == 0x0002A8, "Member 'UOrionMcpTokenItemDefinition::bIsReward' has a wrong offset!");
static_assert(offsetof(UOrionMcpTokenItemDefinition, Substitutions) == 0x0002B0, "Member 'UOrionMcpTokenItemDefinition::Substitutions' has a wrong offset!");
static_assert(offsetof(UOrionMcpTokenItemDefinition, CompositeSubstitutions) == 0x0002C0, "Member 'UOrionMcpTokenItemDefinition::CompositeSubstitutions' has a wrong offset!");
static_assert(offsetof(UOrionMcpTokenItemDefinition, EquivalencyType) == 0x0002D0, "Member 'UOrionMcpTokenItemDefinition::EquivalencyType' has a wrong offset!");
static_assert(offsetof(UOrionMcpTokenItemDefinition, EquivalencyQuantity) == 0x0002F8, "Member 'UOrionMcpTokenItemDefinition::EquivalencyQuantity' has a wrong offset!");
static_assert(offsetof(UOrionMcpTokenItemDefinition, bAlwaysReplaceStack) == 0x0002FC, "Member 'UOrionMcpTokenItemDefinition::bAlwaysReplaceStack' has a wrong offset!");
static_assert(offsetof(UOrionMcpTokenItemDefinition, PersistentNameOverride) == 0x000300, "Member 'UOrionMcpTokenItemDefinition::PersistentNameOverride' has a wrong offset!");
static_assert(offsetof(UOrionMcpTokenItemDefinition, bMakeNewItemNotification) == 0x000310, "Member 'UOrionMcpTokenItemDefinition::bMakeNewItemNotification' has a wrong offset!");
static_assert(offsetof(UOrionMcpTokenItemDefinition, bDirectGrantEnabled) == 0x000311, "Member 'UOrionMcpTokenItemDefinition::bDirectGrantEnabled' has a wrong offset!");

// Class OrionGame.OrionMcpUtils
// 0x0030 (0x0058 - 0x0028)
class UOrionMcpUtils final : public UObject
{
public:
	int32                                         EndMatchHttpRetryCount;                            // 0x0028(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         EndMatchHttpRetryTimeout;                          // 0x002C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DefaultLogTailLengthKb;                            // 0x0048(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C[0xC];                                       // 0x004C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpUtils">();
	}
	static class UOrionMcpUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpUtils>();
	}
};
static_assert(alignof(UOrionMcpUtils) == 0x000008, "Wrong alignment on UOrionMcpUtils");
static_assert(sizeof(UOrionMcpUtils) == 0x000058, "Wrong size on UOrionMcpUtils");
static_assert(offsetof(UOrionMcpUtils, EndMatchHttpRetryCount) == 0x000028, "Member 'UOrionMcpUtils::EndMatchHttpRetryCount' has a wrong offset!");
static_assert(offsetof(UOrionMcpUtils, EndMatchHttpRetryTimeout) == 0x00002C, "Member 'UOrionMcpUtils::EndMatchHttpRetryTimeout' has a wrong offset!");
static_assert(offsetof(UOrionMcpUtils, DefaultLogTailLengthKb) == 0x000048, "Member 'UOrionMcpUtils::DefaultLogTailLengthKb' has a wrong offset!");

// Class OrionGame.OrionMcpVaultItemDefinition
// 0x0048 (0x02B0 - 0x0268)
class UOrionMcpVaultItemDefinition final : public UOrionMcpItemDefinition
{
public:
	TArray<struct FVaultEntry>                    MajorRewards;                                      // 0x0268(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FVaultEntry>                    MinorRewards;                                      // 0x0278(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UOrionMcpTokenItemDefinition> RequiredTokenToOpen;                               // 0x0288(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMcpVaultItemDefinition">();
	}
	static class UOrionMcpVaultItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMcpVaultItemDefinition>();
	}
};
static_assert(alignof(UOrionMcpVaultItemDefinition) == 0x000008, "Wrong alignment on UOrionMcpVaultItemDefinition");
static_assert(sizeof(UOrionMcpVaultItemDefinition) == 0x0002B0, "Wrong size on UOrionMcpVaultItemDefinition");
static_assert(offsetof(UOrionMcpVaultItemDefinition, MajorRewards) == 0x000268, "Member 'UOrionMcpVaultItemDefinition::MajorRewards' has a wrong offset!");
static_assert(offsetof(UOrionMcpVaultItemDefinition, MinorRewards) == 0x000278, "Member 'UOrionMcpVaultItemDefinition::MinorRewards' has a wrong offset!");
static_assert(offsetof(UOrionMcpVaultItemDefinition, RequiredTokenToOpen) == 0x000288, "Member 'UOrionMcpVaultItemDefinition::RequiredTokenToOpen' has a wrong offset!");

// Class OrionGame.OrionMenuManagerWidget2
// 0x0028 (0x02E0 - 0x02B8)
class UOrionMenuManagerWidget2 final : public UOrionUserWidgetBase
{
public:
	class UOverlay*                               MainOverlay;                                       // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FMenuClassEntry>                DynamicEntries;                                    // 0x02C0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FMenuWidgetEntry>               WidgetEntries;                                     // 0x02D0(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void OnMenuClose(class UWidget* NewOpenWidget);
	void OnMenuOpen(class UWidget* NewOpenWidget);
	void OnMenuOpenStateChange(EOrionMenuSlotTypes MenuSlot, bool bNewIsOpenState);
	void OnUpdateCursorState();

	class UWidget* FindWidgetFromSlot(EOrionMenuSlotTypes InSlotType) const;
	bool GetDoesMenuExist(EOrionMenuSlotTypes InSlotType) const;
	bool GetIsMenuVisible(EOrionMenuSlotTypes InSlotType) const;
	EOrionDesiredAnalogCursorState GetTopCursorState() const;
	class UWidget* GetTopOpenWidget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMenuManagerWidget2">();
	}
	static class UOrionMenuManagerWidget2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMenuManagerWidget2>();
	}
};
static_assert(alignof(UOrionMenuManagerWidget2) == 0x000008, "Wrong alignment on UOrionMenuManagerWidget2");
static_assert(sizeof(UOrionMenuManagerWidget2) == 0x0002E0, "Wrong size on UOrionMenuManagerWidget2");
static_assert(offsetof(UOrionMenuManagerWidget2, MainOverlay) == 0x0002B8, "Member 'UOrionMenuManagerWidget2::MainOverlay' has a wrong offset!");
static_assert(offsetof(UOrionMenuManagerWidget2, DynamicEntries) == 0x0002C0, "Member 'UOrionMenuManagerWidget2::DynamicEntries' has a wrong offset!");
static_assert(offsetof(UOrionMenuManagerWidget2, WidgetEntries) == 0x0002D0, "Member 'UOrionMenuManagerWidget2::WidgetEntries' has a wrong offset!");

// Class OrionGame.OrionMiniMapVolume
// 0x0020 (0x0370 - 0x0350)
class AOrionMiniMapVolume final : public AVolume
{
public:
	TArray<struct FMiniMapRotationEntry>          MapRotations;                                      // 0x0350(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UTexture2D*                             MiniMapBackground;                                 // 0x0360(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             LargeMiniMapBackground;                            // 0x0368(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMiniMapVolume">();
	}
	static class AOrionMiniMapVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionMiniMapVolume>();
	}
};
static_assert(alignof(AOrionMiniMapVolume) == 0x000008, "Wrong alignment on AOrionMiniMapVolume");
static_assert(sizeof(AOrionMiniMapVolume) == 0x000370, "Wrong size on AOrionMiniMapVolume");
static_assert(offsetof(AOrionMiniMapVolume, MapRotations) == 0x000350, "Member 'AOrionMiniMapVolume::MapRotations' has a wrong offset!");
static_assert(offsetof(AOrionMiniMapVolume, MiniMapBackground) == 0x000360, "Member 'AOrionMiniMapVolume::MiniMapBackground' has a wrong offset!");
static_assert(offsetof(AOrionMiniMapVolume, LargeMiniMapBackground) == 0x000368, "Member 'AOrionMiniMapVolume::LargeMiniMapBackground' has a wrong offset!");

// Class OrionGame.OrionMoveSet
// 0x0020 (0x0050 - 0x0030)
class UOrionMoveSet final : public UOrionAttributeSet
{
public:
	float                                         MaxMoveSpeed;                                      // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CombatSlow;                                        // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinionNudgeResistanceFactorEnemy;                  // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinionNudgeResistanceFactorFriendly;               // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockBack;                                         // 0x0040(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockUp;                                           // 0x0044(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvatarScale;                                       // 0x0048(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_AvatarScale();
	void OnRep_CombatSlow();
	void OnRep_MaxMoveSpeed();
	void OnRep_MinionNudgeResistanceFactorEnemy();
	void OnRep_MinionNudgeResistanceFactorFriendly();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMoveSet">();
	}
	static class UOrionMoveSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMoveSet>();
	}
};
static_assert(alignof(UOrionMoveSet) == 0x000008, "Wrong alignment on UOrionMoveSet");
static_assert(sizeof(UOrionMoveSet) == 0x000050, "Wrong size on UOrionMoveSet");
static_assert(offsetof(UOrionMoveSet, MaxMoveSpeed) == 0x000030, "Member 'UOrionMoveSet::MaxMoveSpeed' has a wrong offset!");
static_assert(offsetof(UOrionMoveSet, CombatSlow) == 0x000034, "Member 'UOrionMoveSet::CombatSlow' has a wrong offset!");
static_assert(offsetof(UOrionMoveSet, MinionNudgeResistanceFactorEnemy) == 0x000038, "Member 'UOrionMoveSet::MinionNudgeResistanceFactorEnemy' has a wrong offset!");
static_assert(offsetof(UOrionMoveSet, MinionNudgeResistanceFactorFriendly) == 0x00003C, "Member 'UOrionMoveSet::MinionNudgeResistanceFactorFriendly' has a wrong offset!");
static_assert(offsetof(UOrionMoveSet, KnockBack) == 0x000040, "Member 'UOrionMoveSet::KnockBack' has a wrong offset!");
static_assert(offsetof(UOrionMoveSet, KnockUp) == 0x000044, "Member 'UOrionMoveSet::KnockUp' has a wrong offset!");
static_assert(offsetof(UOrionMoveSet, AvatarScale) == 0x000048, "Member 'UOrionMoveSet::AvatarScale' has a wrong offset!");

// Class OrionGame.OrionMurielAnimInstance
// 0x0120 (0x0890 - 0x0770)
class UOrionMurielAnimInstance final : public UOrionBaseHeroAnimInstance
{
public:
	struct FCachedAnimStateData                   IdleCachedStateData;                               // 0x0770(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedAnimRelevancyData               CachedTravelStartRelevantAnimData;                 // 0x0790(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedAnimTransitionData              CachedTravelStartToTravelMovingTransitionData;     // 0x07B0(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedAnimTransitionData              CachedTravelStartToTravelIdleTransitionData;       // 0x07D8(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedAnimRelevancyData               CachedTravelPivot180ARelevantAnimData;             // 0x0800(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedAnimRelevancyData               CachedTravelPivot180BRelevantAnimData;             // 0x0820(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsPlayingTravelJumpingAnims;                      // 0x0840(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAccelerating;                                   // 0x0841(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_842[0x2];                                      // 0x0842(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AccelerationMagnitude;                             // 0x0844(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalAccelerationAngle;                            // 0x0848(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastNonZeroLocalAccelerationAngle;                 // 0x084C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawDeltaBetweenAccelAndVel;                        // 0x0850(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JogAdditiveAlpha;                                  // 0x0854(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JogPlayRate;                                       // 0x0858(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpLandEndAdditiveAlpha;                          // 0x085C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IsInTravelModeAlpha;                               // 0x0860(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CustomRootYawAdjustment;                           // 0x0864(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawInDegreesPerSecondOver4;                        // 0x0868(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBananaShotFired;                                  // 0x086C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPrimaryFirePoseActive;                            // 0x086D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTargeting;                                        // 0x086E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLifelockReady;                                    // 0x086F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlendJumpLandEnd;                                 // 0x0870(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMovingInTravelMode;                             // 0x0871(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMovingAndNotOnGround;                           // 0x0872(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotOnGroundAndNotIsJumping;                       // 0x0873(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNotInTravelModeAndOnGround;                     // 0x0874(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNotInTravelModeAndNotOnGround;                  // 0x0875(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseBackwardsTravelBlendspace;                     // 0x0876(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_IdleAndTurns_Idle_To_TurnInPlace;      // 0x0877(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_Travel_TravelStart_To_TravelIdle;      // 0x0878(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_Travel_TravelIdle_To_TravelStart;      // 0x0879(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_Travel_TravelIdle_To_TravelMoving;     // 0x087A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_Travel_TravelStart_To_TravelMoving;    // 0x087B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_Travel_TravelMoving_To_TravelPivot180; // 0x087C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_TravelPivot180_TravelPivot180A_To_TravelPivot180B; // 0x087D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_TravelPivot180_TravelPivot180B_To_TravelPivot180A; // 0x087E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJogAdditive                                  CurrentJogAdditive;                                // 0x087F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_880[0x10];                                     // 0x0880(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AnimNotify_Jump_Land_End(const class UAnimNotify* AnimNotify);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionMurielAnimInstance">();
	}
	static class UOrionMurielAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionMurielAnimInstance>();
	}
};
static_assert(alignof(UOrionMurielAnimInstance) == 0x000008, "Wrong alignment on UOrionMurielAnimInstance");
static_assert(sizeof(UOrionMurielAnimInstance) == 0x000890, "Wrong size on UOrionMurielAnimInstance");
static_assert(offsetof(UOrionMurielAnimInstance, IdleCachedStateData) == 0x000770, "Member 'UOrionMurielAnimInstance::IdleCachedStateData' has a wrong offset!");
static_assert(offsetof(UOrionMurielAnimInstance, CachedTravelStartRelevantAnimData) == 0x000790, "Member 'UOrionMurielAnimInstance::CachedTravelStartRelevantAnimData' has a wrong offset!");
static_assert(offsetof(UOrionMurielAnimInstance, CachedTravelStartToTravelMovingTransitionData) == 0x0007B0, "Member 'UOrionMurielAnimInstance::CachedTravelStartToTravelMovingTransitionData' has a wrong offset!");
static_assert(offsetof(UOrionMurielAnimInstance, CachedTravelStartToTravelIdleTransitionData) == 0x0007D8, "Member 'UOrionMurielAnimInstance::CachedTravelStartToTravelIdleTransitionData' has a wrong offset!");
static_assert(offsetof(UOrionMurielAnimInstance, CachedTravelPivot180ARelevantAnimData) == 0x000800, "Member 'UOrionMurielAnimInstance::CachedTravelPivot180ARelevantAnimData' has a wrong offset!");
static_assert(offsetof(UOrionMurielAnimInstance, CachedTravelPivot180BRelevantAnimData) == 0x000820, "Member 'UOrionMurielAnimInstance::CachedTravelPivot180BRelevantAnimData' has a wrong offset!");
static_assert(offsetof(UOrionMurielAnimInstance, bIsPlayingTravelJumpingAnims) == 0x000840, "Member 'UOrionMurielAnimInstance::bIsPlayingTravelJumpingAnims' has a wrong offset!");
static_assert(offsetof(UOrionMurielAnimInstance, bIsAccelerating) == 0x000841, "Member 'UOrionMurielAnimInstance::bIsAccelerating' has a wrong offset!");
static_assert(offsetof(UOrionMurielAnimInstance, AccelerationMagnitude) == 0x000844, "Member 'UOrionMurielAnimInstance::AccelerationMagnitude' has a wrong offset!");
static_assert(offsetof(UOrionMurielAnimInstance, LocalAccelerationAngle) == 0x000848, "Member 'UOrionMurielAnimInstance::LocalAccelerationAngle' has a wrong offset!");
static_assert(offsetof(UOrionMurielAnimInstance, LastNonZeroLocalAccelerationAngle) == 0x00084C, "Member 'UOrionMurielAnimInstance::LastNonZeroLocalAccelerationAngle' has a wrong offset!");
static_assert(offsetof(UOrionMurielAnimInstance, YawDeltaBetweenAccelAndVel) == 0x000850, "Member 'UOrionMurielAnimInstance::YawDeltaBetweenAccelAndVel' has a wrong offset!");
static_assert(offsetof(UOrionMurielAnimInstance, JogAdditiveAlpha) == 0x000854, "Member 'UOrionMurielAnimInstance::JogAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UOrionMurielAnimInstance, JogPlayRate) == 0x000858, "Member 'UOrionMurielAnimInstance::JogPlayRate' has a wrong offset!");
static_assert(offsetof(UOrionMurielAnimInstance, JumpLandEndAdditiveAlpha) == 0x00085C, "Member 'UOrionMurielAnimInstance::JumpLandEndAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UOrionMurielAnimInstance, IsInTravelModeAlpha) == 0x000860, "Member 'UOrionMurielAnimInstance::IsInTravelModeAlpha' has a wrong offset!");
static_assert(offsetof(UOrionMurielAnimInstance, CustomRootYawAdjustment) == 0x000864, "Member 'UOrionMurielAnimInstance::CustomRootYawAdjustment' has a wrong offset!");
static_assert(offsetof(UOrionMurielAnimInstance, YawInDegreesPerSecondOver4) == 0x000868, "Member 'UOrionMurielAnimInstance::YawInDegreesPerSecondOver4' has a wrong offset!");
static_assert(offsetof(UOrionMurielAnimInstance, bBananaShotFired) == 0x00086C, "Member 'UOrionMurielAnimInstance::bBananaShotFired' has a wrong offset!");
static_assert(offsetof(UOrionMurielAnimInstance, bPrimaryFirePoseActive) == 0x00086D, "Member 'UOrionMurielAnimInstance::bPrimaryFirePoseActive' has a wrong offset!");
static_assert(offsetof(UOrionMurielAnimInstance, bTargeting) == 0x00086E, "Member 'UOrionMurielAnimInstance::bTargeting' has a wrong offset!");
static_assert(offsetof(UOrionMurielAnimInstance, bLifelockReady) == 0x00086F, "Member 'UOrionMurielAnimInstance::bLifelockReady' has a wrong offset!");
static_assert(offsetof(UOrionMurielAnimInstance, bBlendJumpLandEnd) == 0x000870, "Member 'UOrionMurielAnimInstance::bBlendJumpLandEnd' has a wrong offset!");
static_assert(offsetof(UOrionMurielAnimInstance, bIsMovingInTravelMode) == 0x000871, "Member 'UOrionMurielAnimInstance::bIsMovingInTravelMode' has a wrong offset!");
static_assert(offsetof(UOrionMurielAnimInstance, bIsMovingAndNotOnGround) == 0x000872, "Member 'UOrionMurielAnimInstance::bIsMovingAndNotOnGround' has a wrong offset!");
static_assert(offsetof(UOrionMurielAnimInstance, bNotOnGroundAndNotIsJumping) == 0x000873, "Member 'UOrionMurielAnimInstance::bNotOnGroundAndNotIsJumping' has a wrong offset!");
static_assert(offsetof(UOrionMurielAnimInstance, bIsNotInTravelModeAndOnGround) == 0x000874, "Member 'UOrionMurielAnimInstance::bIsNotInTravelModeAndOnGround' has a wrong offset!");
static_assert(offsetof(UOrionMurielAnimInstance, bIsNotInTravelModeAndNotOnGround) == 0x000875, "Member 'UOrionMurielAnimInstance::bIsNotInTravelModeAndNotOnGround' has a wrong offset!");
static_assert(offsetof(UOrionMurielAnimInstance, bUseBackwardsTravelBlendspace) == 0x000876, "Member 'UOrionMurielAnimInstance::bUseBackwardsTravelBlendspace' has a wrong offset!");
static_assert(offsetof(UOrionMurielAnimInstance, bTransition_IdleAndTurns_Idle_To_TurnInPlace) == 0x000877, "Member 'UOrionMurielAnimInstance::bTransition_IdleAndTurns_Idle_To_TurnInPlace' has a wrong offset!");
static_assert(offsetof(UOrionMurielAnimInstance, bTransition_Travel_TravelStart_To_TravelIdle) == 0x000878, "Member 'UOrionMurielAnimInstance::bTransition_Travel_TravelStart_To_TravelIdle' has a wrong offset!");
static_assert(offsetof(UOrionMurielAnimInstance, bTransition_Travel_TravelIdle_To_TravelStart) == 0x000879, "Member 'UOrionMurielAnimInstance::bTransition_Travel_TravelIdle_To_TravelStart' has a wrong offset!");
static_assert(offsetof(UOrionMurielAnimInstance, bTransition_Travel_TravelIdle_To_TravelMoving) == 0x00087A, "Member 'UOrionMurielAnimInstance::bTransition_Travel_TravelIdle_To_TravelMoving' has a wrong offset!");
static_assert(offsetof(UOrionMurielAnimInstance, bTransition_Travel_TravelStart_To_TravelMoving) == 0x00087B, "Member 'UOrionMurielAnimInstance::bTransition_Travel_TravelStart_To_TravelMoving' has a wrong offset!");
static_assert(offsetof(UOrionMurielAnimInstance, bTransition_Travel_TravelMoving_To_TravelPivot180) == 0x00087C, "Member 'UOrionMurielAnimInstance::bTransition_Travel_TravelMoving_To_TravelPivot180' has a wrong offset!");
static_assert(offsetof(UOrionMurielAnimInstance, bTransition_TravelPivot180_TravelPivot180A_To_TravelPivot180B) == 0x00087D, "Member 'UOrionMurielAnimInstance::bTransition_TravelPivot180_TravelPivot180A_To_TravelPivot180B' has a wrong offset!");
static_assert(offsetof(UOrionMurielAnimInstance, bTransition_TravelPivot180_TravelPivot180B_To_TravelPivot180A) == 0x00087E, "Member 'UOrionMurielAnimInstance::bTransition_TravelPivot180_TravelPivot180B_To_TravelPivot180A' has a wrong offset!");
static_assert(offsetof(UOrionMurielAnimInstance, CurrentJogAdditive) == 0x00087F, "Member 'UOrionMurielAnimInstance::CurrentJogAdditive' has a wrong offset!");

// Class OrionGame.OrionNavField
// 0x0120 (0x05E0 - 0x04C0)
class AOrionNavField final : public ANavigationData
{
public:
	float                                         RequestedTileSize;                                 // 0x04C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RequestedCellSize;                                 // 0x04C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavTileSize;                                       // 0x04C8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavCellSize;                                       // 0x04CC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FNavFieldDirectionTile>         DirectionTiles;                                    // 0x04D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FNavFieldSingleDirectionTile>   SingleDirectionTiles;                              // 0x04E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FNavFieldHeightTile>            HeightTiles;                                       // 0x04F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FNavFieldLane>                  Routes;                                            // 0x0500(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FNavFieldLane>                  Lanes;                                             // 0x0510(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_520[0xA0];                                     // 0x0520(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBox                                   NavBounds;                                         // 0x05C0(0x001C)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bNeedsRebuild : 1;                                 // 0x05DC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseHeightDifferenceForJungleSamples : 1;          // 0x05DC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5DD[0x3];                                      // 0x05DD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionNavField">();
	}
	static class AOrionNavField* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionNavField>();
	}
};
static_assert(alignof(AOrionNavField) == 0x000008, "Wrong alignment on AOrionNavField");
static_assert(sizeof(AOrionNavField) == 0x0005E0, "Wrong size on AOrionNavField");
static_assert(offsetof(AOrionNavField, RequestedTileSize) == 0x0004C0, "Member 'AOrionNavField::RequestedTileSize' has a wrong offset!");
static_assert(offsetof(AOrionNavField, RequestedCellSize) == 0x0004C4, "Member 'AOrionNavField::RequestedCellSize' has a wrong offset!");
static_assert(offsetof(AOrionNavField, NavTileSize) == 0x0004C8, "Member 'AOrionNavField::NavTileSize' has a wrong offset!");
static_assert(offsetof(AOrionNavField, NavCellSize) == 0x0004CC, "Member 'AOrionNavField::NavCellSize' has a wrong offset!");
static_assert(offsetof(AOrionNavField, DirectionTiles) == 0x0004D0, "Member 'AOrionNavField::DirectionTiles' has a wrong offset!");
static_assert(offsetof(AOrionNavField, SingleDirectionTiles) == 0x0004E0, "Member 'AOrionNavField::SingleDirectionTiles' has a wrong offset!");
static_assert(offsetof(AOrionNavField, HeightTiles) == 0x0004F0, "Member 'AOrionNavField::HeightTiles' has a wrong offset!");
static_assert(offsetof(AOrionNavField, Routes) == 0x000500, "Member 'AOrionNavField::Routes' has a wrong offset!");
static_assert(offsetof(AOrionNavField, Lanes) == 0x000510, "Member 'AOrionNavField::Lanes' has a wrong offset!");
static_assert(offsetof(AOrionNavField, NavBounds) == 0x0005C0, "Member 'AOrionNavField::NavBounds' has a wrong offset!");

// Class OrionGame.OrionNavFieldRenderingComponent
// 0x0000 (0x0690 - 0x0690)
class UOrionNavFieldRenderingComponent final : public UPrimitiveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionNavFieldRenderingComponent">();
	}
	static class UOrionNavFieldRenderingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionNavFieldRenderingComponent>();
	}
};
static_assert(alignof(UOrionNavFieldRenderingComponent) == 0x000010, "Wrong alignment on UOrionNavFieldRenderingComponent");
static_assert(sizeof(UOrionNavFieldRenderingComponent) == 0x000690, "Wrong size on UOrionNavFieldRenderingComponent");

// Class OrionGame.OrionNavArea_TowerInactive
// 0x0000 (0x0040 - 0x0040)
class UOrionNavArea_TowerInactive final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionNavArea_TowerInactive">();
	}
	static class UOrionNavArea_TowerInactive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionNavArea_TowerInactive>();
	}
};
static_assert(alignof(UOrionNavArea_TowerInactive) == 0x000008, "Wrong alignment on UOrionNavArea_TowerInactive");
static_assert(sizeof(UOrionNavArea_TowerInactive) == 0x000040, "Wrong size on UOrionNavArea_TowerInactive");

// Class OrionGame.OrionNavArea_TowerRed
// 0x0000 (0x0040 - 0x0040)
class UOrionNavArea_TowerRed final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionNavArea_TowerRed">();
	}
	static class UOrionNavArea_TowerRed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionNavArea_TowerRed>();
	}
};
static_assert(alignof(UOrionNavArea_TowerRed) == 0x000008, "Wrong alignment on UOrionNavArea_TowerRed");
static_assert(sizeof(UOrionNavArea_TowerRed) == 0x000040, "Wrong size on UOrionNavArea_TowerRed");

// Class OrionGame.OrionNavArea_TowerBlue
// 0x0000 (0x0040 - 0x0040)
class UOrionNavArea_TowerBlue final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionNavArea_TowerBlue">();
	}
	static class UOrionNavArea_TowerBlue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionNavArea_TowerBlue>();
	}
};
static_assert(alignof(UOrionNavArea_TowerBlue) == 0x000008, "Wrong alignment on UOrionNavArea_TowerBlue");
static_assert(sizeof(UOrionNavArea_TowerBlue) == 0x000040, "Wrong size on UOrionNavArea_TowerBlue");

// Class OrionGame.OrionNavArea_FakeDefault
// 0x0000 (0x0040 - 0x0040)
class UOrionNavArea_FakeDefault final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionNavArea_FakeDefault">();
	}
	static class UOrionNavArea_FakeDefault* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionNavArea_FakeDefault>();
	}
};
static_assert(alignof(UOrionNavArea_FakeDefault) == 0x000008, "Wrong alignment on UOrionNavArea_FakeDefault");
static_assert(sizeof(UOrionNavArea_FakeDefault) == 0x000040, "Wrong size on UOrionNavArea_FakeDefault");

// Class OrionGame.OrionNavFilter_ExcludeRed
// 0x0000 (0x0048 - 0x0048)
class UOrionNavFilter_ExcludeRed final : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionNavFilter_ExcludeRed">();
	}
	static class UOrionNavFilter_ExcludeRed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionNavFilter_ExcludeRed>();
	}
};
static_assert(alignof(UOrionNavFilter_ExcludeRed) == 0x000008, "Wrong alignment on UOrionNavFilter_ExcludeRed");
static_assert(sizeof(UOrionNavFilter_ExcludeRed) == 0x000048, "Wrong size on UOrionNavFilter_ExcludeRed");

// Class OrionGame.OrionNavFilter_ExcludeBlue
// 0x0000 (0x0048 - 0x0048)
class UOrionNavFilter_ExcludeBlue final : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionNavFilter_ExcludeBlue">();
	}
	static class UOrionNavFilter_ExcludeBlue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionNavFilter_ExcludeBlue>();
	}
};
static_assert(alignof(UOrionNavFilter_ExcludeBlue) == 0x000008, "Wrong alignment on UOrionNavFilter_ExcludeBlue");
static_assert(sizeof(UOrionNavFilter_ExcludeBlue) == 0x000048, "Wrong size on UOrionNavFilter_ExcludeBlue");

// Class OrionGame.OrionNavFilter_ActiveTowerNoEntry
// 0x0000 (0x0048 - 0x0048)
class UOrionNavFilter_ActiveTowerNoEntry final : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionNavFilter_ActiveTowerNoEntry">();
	}
	static class UOrionNavFilter_ActiveTowerNoEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionNavFilter_ActiveTowerNoEntry>();
	}
};
static_assert(alignof(UOrionNavFilter_ActiveTowerNoEntry) == 0x000008, "Wrong alignment on UOrionNavFilter_ActiveTowerNoEntry");
static_assert(sizeof(UOrionNavFilter_ActiveTowerNoEntry) == 0x000048, "Wrong size on UOrionNavFilter_ActiveTowerNoEntry");

// Class OrionGame.OrionNavFilter_IgnoreTowerCostAndObstacles
// 0x0000 (0x0048 - 0x0048)
class UOrionNavFilter_IgnoreTowerCostAndObstacles final : public UOrionNavFilter_IgnoreTowerCost
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionNavFilter_IgnoreTowerCostAndObstacles">();
	}
	static class UOrionNavFilter_IgnoreTowerCostAndObstacles* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionNavFilter_IgnoreTowerCostAndObstacles>();
	}
};
static_assert(alignof(UOrionNavFilter_IgnoreTowerCostAndObstacles) == 0x000008, "Wrong alignment on UOrionNavFilter_IgnoreTowerCostAndObstacles");
static_assert(sizeof(UOrionNavFilter_IgnoreTowerCostAndObstacles) == 0x000048, "Wrong size on UOrionNavFilter_IgnoreTowerCostAndObstacles");

// Class OrionGame.OrionNavigationGraph
// 0x0010 (0x04D0 - 0x04C0)
class AOrionNavigationGraph final : public AAbstractNavData
{
public:
	class ABotObjectiveGraph*                     ObjectiveGraph;                                    // 0x04C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C8[0x8];                                      // 0x04C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionNavigationGraph">();
	}
	static class AOrionNavigationGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionNavigationGraph>();
	}
};
static_assert(alignof(AOrionNavigationGraph) == 0x000008, "Wrong alignment on AOrionNavigationGraph");
static_assert(sizeof(AOrionNavigationGraph) == 0x0004D0, "Wrong size on AOrionNavigationGraph");
static_assert(offsetof(AOrionNavigationGraph, ObjectiveGraph) == 0x0004C0, "Member 'AOrionNavigationGraph::ObjectiveGraph' has a wrong offset!");

// Class OrionGame.OrionNavMesh
// 0x0018 (0x05E0 - 0x05C8)
class AOrionNavMesh final : public ARecastNavMesh
{
public:
	TArray<class AOrionToggleableNavLinkProxy*>   TogglableLinks;                                    // 0x05C8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D8[0x8];                                      // 0x05D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionNavMesh">();
	}
	static class AOrionNavMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionNavMesh>();
	}
};
static_assert(alignof(AOrionNavMesh) == 0x000008, "Wrong alignment on AOrionNavMesh");
static_assert(sizeof(AOrionNavMesh) == 0x0005E0, "Wrong size on AOrionNavMesh");
static_assert(offsetof(AOrionNavMesh, TogglableLinks) == 0x0005C8, "Member 'AOrionNavMesh::TogglableLinks' has a wrong offset!");

// Class OrionGame.OrionNavSystem
// 0x0070 (0x04E0 - 0x0470)
class UOrionNavSystem final : public UNavigationSystem
{
public:
	uint8                                         Pad_470[0x70];                                     // 0x0470(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionNavSystem">();
	}
	static class UOrionNavSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionNavSystem>();
	}
};
static_assert(alignof(UOrionNavSystem) == 0x000008, "Wrong alignment on UOrionNavSystem");
static_assert(sizeof(UOrionNavSystem) == 0x0004E0, "Wrong size on UOrionNavSystem");

// Class OrionGame.OrionNavTowerComponent
// 0x0088 (0x01A8 - 0x0120)
class UOrionNavTowerComponent final : public UNavRelevantComponent
{
public:
	uint8                                         Pad_120[0x88];                                     // 0x0120(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnNavDataGenerationFinished(class ANavigationData* NavData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionNavTowerComponent">();
	}
	static class UOrionNavTowerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionNavTowerComponent>();
	}
};
static_assert(alignof(UOrionNavTowerComponent) == 0x000008, "Wrong alignment on UOrionNavTowerComponent");
static_assert(sizeof(UOrionNavTowerComponent) == 0x0001A8, "Wrong size on UOrionNavTowerComponent");

// Class OrionGame.OrionNotificationLibrary
// 0x0000 (0x0028 - 0x0028)
class UOrionNotificationLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddNotification(struct FOrionNotification& InNotification, class UObject* WorldContext);
	static void BindToNotificationResponse(struct FOrionNotification& InNotification, TDelegate<void(const struct FOrionNotification& Notification, ENotificationButton Response)> InCallback);
	static void ClearAllErrorNotifications(class UObject* WorldContext);
	static bool Equal(struct FOrionNotification& LHS, struct FOrionNotification& RHS);
	static class FText GetNotificationDisplayTimeText(struct FOrionNotification& InNotification);
	static bool IsNotificationValid(struct FOrionNotification& InNotification);
	static void KillNotification(class UObject* Context, class FName Identifier);
	static void OnNotificationActionTaken(struct FOrionNotification& InNotification, ENotificationButton InSelection);
	static bool RemoveNotification(struct FOrionNotification& InNotification, class UObject* WorldContext);
	static void SetNotificationDisplayTime(struct FOrionNotification& InNotification, struct FTimespan& Time, class UObject* WorldContext);
	static struct FOrionNotification ShowNotification(class UObject* Context, const class FText& TitleText, const class FText& BodyText, float DisplayTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionNotificationLibrary">();
	}
	static class UOrionNotificationLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionNotificationLibrary>();
	}
};
static_assert(alignof(UOrionNotificationLibrary) == 0x000008, "Wrong alignment on UOrionNotificationLibrary");
static_assert(sizeof(UOrionNotificationLibrary) == 0x000028, "Wrong size on UOrionNotificationLibrary");

// Class OrionGame.OrionNotificationInterface
// 0x0000 (0x0028 - 0x0028)
class IOrionNotificationInterface final : public IInterface
{
public:
	struct FOrionNotification GetNotification() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionNotificationInterface">();
	}
	static class IOrionNotificationInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOrionNotificationInterface>();
	}
};
static_assert(alignof(IOrionNotificationInterface) == 0x000008, "Wrong alignment on IOrionNotificationInterface");
static_assert(sizeof(IOrionNotificationInterface) == 0x000028, "Wrong size on IOrionNotificationInterface");

// Class OrionGame.OrionObjectiveData
// 0x0008 (0x0270 - 0x0268)
class UOrionObjectiveData final : public UOrionMcpItemDefinition
{
public:
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionObjectiveData">();
	}
	static class UOrionObjectiveData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionObjectiveData>();
	}
};
static_assert(alignof(UOrionObjectiveData) == 0x000008, "Wrong alignment on UOrionObjectiveData");
static_assert(sizeof(UOrionObjectiveData) == 0x000270, "Wrong size on UOrionObjectiveData");

// Class OrionGame.OrionObjectiveDependencyInterface
// 0x0000 (0x0028 - 0x0028)
class IOrionObjectiveDependencyInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionObjectiveDependencyInterface">();
	}
	static class IOrionObjectiveDependencyInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOrionObjectiveDependencyInterface>();
	}
};
static_assert(alignof(IOrionObjectiveDependencyInterface) == 0x000008, "Wrong alignment on IOrionObjectiveDependencyInterface");
static_assert(sizeof(IOrionObjectiveDependencyInterface) == 0x000028, "Wrong size on IOrionObjectiveDependencyInterface");

// Class OrionGame.OrionObjectiveSet
// 0x0010 (0x0040 - 0x0030)
class UOrionObjectiveSet final : public UOrionAttributeSet
{
public:
	float                                         ReviveSelfTimer;                                   // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackRadius;                                      // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackHeight;                                      // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetDelayTime;                                   // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionObjectiveSet">();
	}
	static class UOrionObjectiveSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionObjectiveSet>();
	}
};
static_assert(alignof(UOrionObjectiveSet) == 0x000008, "Wrong alignment on UOrionObjectiveSet");
static_assert(sizeof(UOrionObjectiveSet) == 0x000040, "Wrong size on UOrionObjectiveSet");
static_assert(offsetof(UOrionObjectiveSet, ReviveSelfTimer) == 0x000030, "Member 'UOrionObjectiveSet::ReviveSelfTimer' has a wrong offset!");
static_assert(offsetof(UOrionObjectiveSet, AttackRadius) == 0x000034, "Member 'UOrionObjectiveSet::AttackRadius' has a wrong offset!");
static_assert(offsetof(UOrionObjectiveSet, AttackHeight) == 0x000038, "Member 'UOrionObjectiveSet::AttackHeight' has a wrong offset!");
static_assert(offsetof(UOrionObjectiveSet, TargetDelayTime) == 0x00003C, "Member 'UOrionObjectiveSet::TargetDelayTime' has a wrong offset!");

// Class OrionGame.OrionOnlineAccount
// 0x0050 (0x0830 - 0x07E0)
class UOrionOnlineAccount final : public UOnlineAccountCommon
{
public:
	uint8                                         Pad_7E0[0x50];                                     // 0x07E0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionOnlineAccount">();
	}
	static class UOrionOnlineAccount* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionOnlineAccount>();
	}
};
static_assert(alignof(UOrionOnlineAccount) == 0x000008, "Wrong alignment on UOrionOnlineAccount");
static_assert(sizeof(UOrionOnlineAccount) == 0x000830, "Wrong size on UOrionOnlineAccount");

// Class OrionGame.OrionOnlineSessionClient
// 0x00F0 (0x03B0 - 0x02C0)
class UOrionOnlineSessionClient final : public UOnlineSessionClientCommon
{
public:
	uint8                                         Pad_2C0[0xF0];                                     // 0x02C0(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionOnlineSessionClient">();
	}
	static class UOrionOnlineSessionClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionOnlineSessionClient>();
	}
};
static_assert(alignof(UOrionOnlineSessionClient) == 0x000008, "Wrong alignment on UOrionOnlineSessionClient");
static_assert(sizeof(UOrionOnlineSessionClient) == 0x0003B0, "Wrong size on UOrionOnlineSessionClient");

// Class OrionGame.OrionParty
// 0x0090 (0x0520 - 0x0490)
class UOrionParty final : public UParty
{
public:
	uint8                                         Pad_490[0x90];                                     // 0x0490(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionParty">();
	}
	static class UOrionParty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionParty>();
	}
};
static_assert(alignof(UOrionParty) == 0x000008, "Wrong alignment on UOrionParty");
static_assert(sizeof(UOrionParty) == 0x000520, "Wrong size on UOrionParty");

// Class OrionGame.OrionPartyBeaconClient
// 0x0150 (0x0650 - 0x0500)
class AOrionPartyBeaconClient final : public APartyBeaconClient
{
public:
	float                                         ReconnectionInitialTimeout;                        // 0x0500(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ReconnectionTimeout;                               // 0x0504(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_508[0x148];                                    // 0x0508(0x0148)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientAllTeamsReady();
	void ClientSendAcceptMatchPlayersUpdate(const TArray<struct FOrionAcceptMatchData>& AcceptMatchPlayers);
	void ClientSendLobbyStateChanged(EOrionBeaconLobbyState NewState);
	void ClientSetTeamInfoResponse(EPartySetTeamInfoResult Result);
	void ServerConfigureMatchReservationRequest(const class FString& InSessionId, const struct FOrionMatchConfig& MatchConfig, const struct FPartyReservation& PartyReservation);
	void ServerSetAcceptedMatch(const struct FUniqueNetIdRepl& PartyLeader, const struct FUniqueNetIdRepl& MemberId, EOrionAcceptMatchState AcceptState);
	void ServerSetTeamInfoRequest(const struct FUniqueNetIdRepl& PartyLeader, bool bPlayerTeam, const struct FOrionTBTeamInfo& TeamInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPartyBeaconClient">();
	}
	static class AOrionPartyBeaconClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionPartyBeaconClient>();
	}
};
static_assert(alignof(AOrionPartyBeaconClient) == 0x000008, "Wrong alignment on AOrionPartyBeaconClient");
static_assert(sizeof(AOrionPartyBeaconClient) == 0x000650, "Wrong size on AOrionPartyBeaconClient");
static_assert(offsetof(AOrionPartyBeaconClient, ReconnectionInitialTimeout) == 0x000500, "Member 'AOrionPartyBeaconClient::ReconnectionInitialTimeout' has a wrong offset!");
static_assert(offsetof(AOrionPartyBeaconClient, ReconnectionTimeout) == 0x000504, "Member 'AOrionPartyBeaconClient::ReconnectionTimeout' has a wrong offset!");

// Class OrionGame.OrionPartyBeaconState
// 0x0108 (0x0178 - 0x0070)
class UOrionPartyBeaconState final : public UPartyBeaconState
{
public:
	struct FOrionMatchConfig                      MatchConfig;                                       // 0x0070(0x0040)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B0[0x50];                                      // 0x00B0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AveragePartyMMR;                                   // 0x0100(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_104[0x54];                                     // 0x0104(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	EOrionBeaconLobbyState                        LobbyState;                                        // 0x0158(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_159[0x7];                                      // 0x0159(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOrionAcceptMatchData>          AcceptMatchPlayers;                                // 0x0160(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_170[0x8];                                      // 0x0170(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPartyBeaconState">();
	}
	static class UOrionPartyBeaconState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionPartyBeaconState>();
	}
};
static_assert(alignof(UOrionPartyBeaconState) == 0x000008, "Wrong alignment on UOrionPartyBeaconState");
static_assert(sizeof(UOrionPartyBeaconState) == 0x000178, "Wrong size on UOrionPartyBeaconState");
static_assert(offsetof(UOrionPartyBeaconState, MatchConfig) == 0x000070, "Member 'UOrionPartyBeaconState::MatchConfig' has a wrong offset!");
static_assert(offsetof(UOrionPartyBeaconState, AveragePartyMMR) == 0x000100, "Member 'UOrionPartyBeaconState::AveragePartyMMR' has a wrong offset!");
static_assert(offsetof(UOrionPartyBeaconState, LobbyState) == 0x000158, "Member 'UOrionPartyBeaconState::LobbyState' has a wrong offset!");
static_assert(offsetof(UOrionPartyBeaconState, AcceptMatchPlayers) == 0x000160, "Member 'UOrionPartyBeaconState::AcceptMatchPlayers' has a wrong offset!");

// Class OrionGame.OrionPartyMemberState
// 0x0098 (0x0110 - 0x0078)
class UOrionPartyMemberState : public UPartyMemberState
{
public:
	UMulticastDelegateProperty_                   OnMemberUpdated;                                   // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UEnum*                                  DirtyFlagEnum;                                     // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_90[0x80];                                      // 0x0090(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMemberUpdated__DelegateSignature();

	int32 GetAccountLevel() const;
	int32 GetIsConsole() const;
	float GetLevelProgress() const;
	bool IsDirty(EOrionPartyMemberStateFlags Flag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPartyMemberState">();
	}
	static class UOrionPartyMemberState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionPartyMemberState>();
	}
};
static_assert(alignof(UOrionPartyMemberState) == 0x000008, "Wrong alignment on UOrionPartyMemberState");
static_assert(sizeof(UOrionPartyMemberState) == 0x000110, "Wrong size on UOrionPartyMemberState");
static_assert(offsetof(UOrionPartyMemberState, OnMemberUpdated) == 0x000078, "Member 'UOrionPartyMemberState::OnMemberUpdated' has a wrong offset!");
static_assert(offsetof(UOrionPartyMemberState, DirtyFlagEnum) == 0x000088, "Member 'UOrionPartyMemberState::DirtyFlagEnum' has a wrong offset!");

// Class OrionGame.OrionPathFollowingComponent
// 0x0020 (0x03F8 - 0x03D8)
#pragma pack(push, 0x1)
class alignas(0x08) UOrionPathFollowingComponent : public UGridPathFollowingComponent
{
public:
	class AOrionNavField*                         CachedFlowField;                                   // 0x03D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E0[0x18];                                     // 0x03E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPathFollowingComponent">();
	}
	static class UOrionPathFollowingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionPathFollowingComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UOrionPathFollowingComponent) == 0x000008, "Wrong alignment on UOrionPathFollowingComponent");
static_assert(sizeof(UOrionPathFollowingComponent) == 0x0003F8, "Wrong size on UOrionPathFollowingComponent");
static_assert(offsetof(UOrionPathFollowingComponent, CachedFlowField) == 0x0003D8, "Member 'UOrionPathFollowingComponent::CachedFlowField' has a wrong offset!");

// Class OrionGame.OrionPathFollowingComponent_Jungle
// 0x0038 (0x0430 - 0x03F8)
class UOrionPathFollowingComponent_Jungle final : public UOrionPathFollowingComponent
{
public:
	uint8                                         Pad_3F8[0x38];                                     // 0x03F8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPathFollowingComponent_Jungle">();
	}
	static class UOrionPathFollowingComponent_Jungle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionPathFollowingComponent_Jungle>();
	}
};
static_assert(alignof(UOrionPathFollowingComponent_Jungle) == 0x000008, "Wrong alignment on UOrionPathFollowingComponent_Jungle");
static_assert(sizeof(UOrionPathFollowingComponent_Jungle) == 0x000430, "Wrong size on UOrionPathFollowingComponent_Jungle");

// Class OrionGame.OrionPathFollowingComponent_Hero
// 0x0008 (0x0400 - 0x03F8)
class UOrionPathFollowingComponent_Hero final : public UOrionPathFollowingComponent
{
public:
	class AOrionAIBot*                            BotOwner;                                          // 0x03F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPathFollowingComponent_Hero">();
	}
	static class UOrionPathFollowingComponent_Hero* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionPathFollowingComponent_Hero>();
	}
};
static_assert(alignof(UOrionPathFollowingComponent_Hero) == 0x000008, "Wrong alignment on UOrionPathFollowingComponent_Hero");
static_assert(sizeof(UOrionPathFollowingComponent_Hero) == 0x000400, "Wrong size on UOrionPathFollowingComponent_Hero");
static_assert(offsetof(UOrionPathFollowingComponent_Hero, BotOwner) == 0x0003F8, "Member 'UOrionPathFollowingComponent_Hero::BotOwner' has a wrong offset!");

// Class OrionGame.OrionPersistentParty
// 0x07A0 (0x0E00 - 0x0660)
class UOrionPersistentParty final : public UOrionPartyGameState
{
public:
	struct FOrionPersistentPartyRepState          PersistentPartyState;                              // 0x0660(0x0098)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_6F8[0x708];                                    // 0x06F8(0x0708)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPersistentParty">();
	}
	static class UOrionPersistentParty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionPersistentParty>();
	}
};
static_assert(alignof(UOrionPersistentParty) == 0x000008, "Wrong alignment on UOrionPersistentParty");
static_assert(sizeof(UOrionPersistentParty) == 0x000E00, "Wrong size on UOrionPersistentParty");
static_assert(offsetof(UOrionPersistentParty, PersistentPartyState) == 0x000660, "Member 'UOrionPersistentParty::PersistentPartyState' has a wrong offset!");

// Class OrionGame.OrionPersistentPartyMember
// 0x0170 (0x0280 - 0x0110)
class UOrionPersistentPartyMember final : public UOrionPartyMemberState
{
public:
	struct FOrionPersistentPartyMemberRepState    PersistentMemberState;                             // 0x0110(0x0040)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_150[0x130];                                    // 0x0150(0x0130)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHero(class UOrionHeroData* InHero);
	void SetLoaded(bool InLoaded);
	void SetReady(bool bInReady);

	EOrionBanReason GetCurrentBanReason() const;
	class FString GetHero() const;
	EOrionPartyMemberLocation GetLocation() const;
	bool HasLockedInHero(class UOrionHeroData* HeroData) const;
	bool IsDirty(EOrionPersistentPartyMemberStateFlags Flag) const;
	bool IsLoaded() const;
	bool IsReady() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPersistentPartyMember">();
	}
	static class UOrionPersistentPartyMember* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionPersistentPartyMember>();
	}
};
static_assert(alignof(UOrionPersistentPartyMember) == 0x000008, "Wrong alignment on UOrionPersistentPartyMember");
static_assert(sizeof(UOrionPersistentPartyMember) == 0x000280, "Wrong size on UOrionPersistentPartyMember");
static_assert(offsetof(UOrionPersistentPartyMember, PersistentMemberState) == 0x000110, "Member 'UOrionPersistentPartyMember::PersistentMemberState' has a wrong offset!");

// Class OrionGame.SimpleAchievementDescriptions
// 0x0010 (0x0040 - 0x0030)
class USimpleAchievementDescriptions final : public UDataAsset
{
public:
	TArray<struct FSimpleAchievementDescription>  AchievementDescriptions;                           // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleAchievementDescriptions">();
	}
	static class USimpleAchievementDescriptions* GetDefaultObj()
	{
		return GetDefaultObjImpl<USimpleAchievementDescriptions>();
	}
};
static_assert(alignof(USimpleAchievementDescriptions) == 0x000008, "Wrong alignment on USimpleAchievementDescriptions");
static_assert(sizeof(USimpleAchievementDescriptions) == 0x000040, "Wrong size on USimpleAchievementDescriptions");
static_assert(offsetof(USimpleAchievementDescriptions, AchievementDescriptions) == 0x000030, "Member 'USimpleAchievementDescriptions::AchievementDescriptions' has a wrong offset!");

// Class OrionGame.OrionPickupManager
// 0x00B8 (0x03D0 - 0x0318)
class AOrionPickupManager final : public AInfo
{
public:
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AOrionCoin>                 CoinActorClass;                                    // 0x0320(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameplayEffect*                        CxpGameplayEffect;                                 // 0x0328(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_330[0x8];                                      // 0x0330(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPickupPoolData>                PickupPools;                                       // 0x0338(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FPickupSpawningData>            ServerPickupsToSpawn;                              // 0x0348(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FPickupSpawnInfo>               SpawnedPickups;                                    // 0x0358(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	TArray<struct FPickupSpawnInfo>               PostReplicationSpawnedPickup;                      // 0x0368(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_378[0x8];                                      // 0x0378(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<uint64, TWeakObjectPtr<class AOrionPickup>> FastMapLookup;                                     // 0x0380(0x0050)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void CheatRemoveAllPickupsFromTheWorld();
	void DeactivatePickupsOfType(TSubclassOf<class AOrionPickup> PickupClass);
	void OnRep_SpawnedPickups();
	void ReliableHandlePickupCollected(uint64 InPickupID, class AActor* Collector);
	void ReliableRelaunchPickup(const struct FPickupLaunchInfo& LaunchInfo);
	void ReliableSetExpireTimerTo(uint64 InPickupID, float NewExpireTime);
	void ReliableSetPickupLocation(uint64 InPickupID, const struct FVector& NewLocation);
	void ReliableSpawnPickup(const struct FPickupSpawnInfo& CoinSpawnInfo);
	void UnrealiableSpawnPickup(const struct FPickupSpawnInfo& CoinSpawnInfo);
	void UnreliableHandlePickupCollected(uint64 InPickupID, class AActor* Collector);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPickupManager">();
	}
	static class AOrionPickupManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionPickupManager>();
	}
};
static_assert(alignof(AOrionPickupManager) == 0x000008, "Wrong alignment on AOrionPickupManager");
static_assert(sizeof(AOrionPickupManager) == 0x0003D0, "Wrong size on AOrionPickupManager");
static_assert(offsetof(AOrionPickupManager, CoinActorClass) == 0x000320, "Member 'AOrionPickupManager::CoinActorClass' has a wrong offset!");
static_assert(offsetof(AOrionPickupManager, CxpGameplayEffect) == 0x000328, "Member 'AOrionPickupManager::CxpGameplayEffect' has a wrong offset!");
static_assert(offsetof(AOrionPickupManager, PickupPools) == 0x000338, "Member 'AOrionPickupManager::PickupPools' has a wrong offset!");
static_assert(offsetof(AOrionPickupManager, ServerPickupsToSpawn) == 0x000348, "Member 'AOrionPickupManager::ServerPickupsToSpawn' has a wrong offset!");
static_assert(offsetof(AOrionPickupManager, SpawnedPickups) == 0x000358, "Member 'AOrionPickupManager::SpawnedPickups' has a wrong offset!");
static_assert(offsetof(AOrionPickupManager, PostReplicationSpawnedPickup) == 0x000368, "Member 'AOrionPickupManager::PostReplicationSpawnedPickup' has a wrong offset!");
static_assert(offsetof(AOrionPickupManager, FastMapLookup) == 0x000380, "Member 'AOrionPickupManager::FastMapLookup' has a wrong offset!");

// Class OrionGame.OrionPipDifference_Base
// 0x0000 (0x0040 - 0x0040)
class UOrionPipDifference_Base : public UGameplayModMagnitudeCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPipDifference_Base">();
	}
	static class UOrionPipDifference_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionPipDifference_Base>();
	}
};
static_assert(alignof(UOrionPipDifference_Base) == 0x000008, "Wrong alignment on UOrionPipDifference_Base");
static_assert(sizeof(UOrionPipDifference_Base) == 0x000040, "Wrong size on UOrionPipDifference_Base");

// Class OrionGame.OrionPipDifference_Vitality
// 0x0000 (0x0040 - 0x0040)
class UOrionPipDifference_Vitality final : public UOrionPipDifference_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPipDifference_Vitality">();
	}
	static class UOrionPipDifference_Vitality* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionPipDifference_Vitality>();
	}
};
static_assert(alignof(UOrionPipDifference_Vitality) == 0x000008, "Wrong alignment on UOrionPipDifference_Vitality");
static_assert(sizeof(UOrionPipDifference_Vitality) == 0x000040, "Wrong size on UOrionPipDifference_Vitality");

// Class OrionGame.OrionPipDifference_Dexterity
// 0x0000 (0x0040 - 0x0040)
class UOrionPipDifference_Dexterity final : public UOrionPipDifference_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPipDifference_Dexterity">();
	}
	static class UOrionPipDifference_Dexterity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionPipDifference_Dexterity>();
	}
};
static_assert(alignof(UOrionPipDifference_Dexterity) == 0x000008, "Wrong alignment on UOrionPipDifference_Dexterity");
static_assert(sizeof(UOrionPipDifference_Dexterity) == 0x000040, "Wrong size on UOrionPipDifference_Dexterity");

// Class OrionGame.OrionPipDifference_Intellect
// 0x0000 (0x0040 - 0x0040)
class UOrionPipDifference_Intellect final : public UOrionPipDifference_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPipDifference_Intellect">();
	}
	static class UOrionPipDifference_Intellect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionPipDifference_Intellect>();
	}
};
static_assert(alignof(UOrionPipDifference_Intellect) == 0x000008, "Wrong alignment on UOrionPipDifference_Intellect");
static_assert(sizeof(UOrionPipDifference_Intellect) == 0x000040, "Wrong size on UOrionPipDifference_Intellect");

// Class OrionGame.OrionPlayerCamera
// 0x06D0 (0x2170 - 0x1AA0)
class AOrionPlayerCamera final : public APlayerCameraManager
{
public:
	class UOrionCameraModifier_ViewKick*          ViewKickModifier;                                  // 0x1A98(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AOrionDecalManager*                     DecalManager;                                      // 0x1AA0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AA8[0x8];                                     // 0x1AA8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGravesiteCamInfo                      GravesiteCamInfo;                                  // 0x1AB0(0x0110)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1BC0[0x10];                                    // 0x1BC0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTViewTarget                           PrePhotographySessionViewTarget;                   // 0x1BD0(0x0580)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2150[0x20];                                    // 0x2150(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPlayerCamera">();
	}
	static class AOrionPlayerCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionPlayerCamera>();
	}
};
static_assert(alignof(AOrionPlayerCamera) == 0x000010, "Wrong alignment on AOrionPlayerCamera");
static_assert(sizeof(AOrionPlayerCamera) == 0x002170, "Wrong size on AOrionPlayerCamera");
static_assert(offsetof(AOrionPlayerCamera, ViewKickModifier) == 0x001A98, "Member 'AOrionPlayerCamera::ViewKickModifier' has a wrong offset!");
static_assert(offsetof(AOrionPlayerCamera, DecalManager) == 0x001AA0, "Member 'AOrionPlayerCamera::DecalManager' has a wrong offset!");
static_assert(offsetof(AOrionPlayerCamera, GravesiteCamInfo) == 0x001AB0, "Member 'AOrionPlayerCamera::GravesiteCamInfo' has a wrong offset!");
static_assert(offsetof(AOrionPlayerCamera, PrePhotographySessionViewTarget) == 0x001BD0, "Member 'AOrionPlayerCamera::PrePhotographySessionViewTarget' has a wrong offset!");

// Class OrionGame.OrionPlayerController_ArcadeLobby
// 0x0000 (0x0950 - 0x0950)
class AOrionPlayerController_ArcadeLobby final : public AOrionPlayerController_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPlayerController_ArcadeLobby">();
	}
	static class AOrionPlayerController_ArcadeLobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionPlayerController_ArcadeLobby>();
	}
};
static_assert(alignof(AOrionPlayerController_ArcadeLobby) == 0x000008, "Wrong alignment on AOrionPlayerController_ArcadeLobby");
static_assert(sizeof(AOrionPlayerController_ArcadeLobby) == 0x000950, "Wrong size on AOrionPlayerController_ArcadeLobby");

// Class OrionGame.OrionPlayerController_Main
// 0x0110 (0x0A60 - 0x0950)
class AOrionPlayerController_Main final : public AOrionPlayerController_Base
{
public:
	bool                                          bCheckingPrereqs;                                  // 0x0950(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCheckingExistingMatch;                            // 0x0951(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPrereqsMet;                                       // 0x0952(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_953[0x10D];                                    // 0x0953(0x010D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPlayerController_Main">();
	}
	static class AOrionPlayerController_Main* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionPlayerController_Main>();
	}
};
static_assert(alignof(AOrionPlayerController_Main) == 0x000008, "Wrong alignment on AOrionPlayerController_Main");
static_assert(sizeof(AOrionPlayerController_Main) == 0x000A60, "Wrong size on AOrionPlayerController_Main");
static_assert(offsetof(AOrionPlayerController_Main, bCheckingPrereqs) == 0x000950, "Member 'AOrionPlayerController_Main::bCheckingPrereqs' has a wrong offset!");
static_assert(offsetof(AOrionPlayerController_Main, bCheckingExistingMatch) == 0x000951, "Member 'AOrionPlayerController_Main::bCheckingExistingMatch' has a wrong offset!");
static_assert(offsetof(AOrionPlayerController_Main, bPrereqsMet) == 0x000952, "Member 'AOrionPlayerController_Main::bPrereqsMet' has a wrong offset!");

// Class OrionGame.OrionPlayerController_PreGame
// 0x0000 (0x0950 - 0x0950)
class AOrionPlayerController_PreGame final : public AOrionPlayerController_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPlayerController_PreGame">();
	}
	static class AOrionPlayerController_PreGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionPlayerController_PreGame>();
	}
};
static_assert(alignof(AOrionPlayerController_PreGame) == 0x000008, "Wrong alignment on AOrionPlayerController_PreGame");
static_assert(sizeof(AOrionPlayerController_PreGame) == 0x000950, "Wrong size on AOrionPlayerController_PreGame");

// Class OrionGame.OrionPlayerController_Sandbox
// 0x0000 (0x0DD0 - 0x0DD0)
class AOrionPlayerController_Sandbox final : public AOrionPlayerController_Game
{
public:
	void AskForHero();
	void SetHero(class UOrionHeroData* SelectedHeroData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPlayerController_Sandbox">();
	}
	static class AOrionPlayerController_Sandbox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionPlayerController_Sandbox>();
	}
};
static_assert(alignof(AOrionPlayerController_Sandbox) == 0x000008, "Wrong alignment on AOrionPlayerController_Sandbox");
static_assert(sizeof(AOrionPlayerController_Sandbox) == 0x000DD0, "Wrong size on AOrionPlayerController_Sandbox");

// Class OrionGame.OrionPlayerController_Tutorial
// 0x0020 (0x0DF0 - 0x0DD0)
class AOrionPlayerController_Tutorial final : public AOrionPlayerController_Game
{
public:
	class AOrionTutorialPath*                     TutorialPathActor;                                 // 0x0DD0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 TargetActor;                                       // 0x0DD8(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVector>                        TutorialPathArray;                                 // 0x0DE0(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)

public:
	void OnRep_TutorialPathArray();
	void RecordTutorialAnalytics(const struct FGameplayStatTag& Stat);
	void ServerClearPath();
	void ServerFindPathToActor(class AActor* InTargetActor);
	void ServerForceStartGame();
	void ServerForceStartTutorialSpawner(class AOrionCharAISpawner* Spawner, EOrionCharAISpawnerType InType);
	void ServerForceStopTutorialSequencer(class ALevelSequenceActor* SequenceActor);
	void ServerOnMatchReady();
	void ServerRefreshPathToActor();
	void UpdateTutorialStat(const struct FGameplayStatTag& Stat);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPlayerController_Tutorial">();
	}
	static class AOrionPlayerController_Tutorial* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionPlayerController_Tutorial>();
	}
};
static_assert(alignof(AOrionPlayerController_Tutorial) == 0x000008, "Wrong alignment on AOrionPlayerController_Tutorial");
static_assert(sizeof(AOrionPlayerController_Tutorial) == 0x000DF0, "Wrong size on AOrionPlayerController_Tutorial");
static_assert(offsetof(AOrionPlayerController_Tutorial, TutorialPathActor) == 0x000DD0, "Member 'AOrionPlayerController_Tutorial::TutorialPathActor' has a wrong offset!");
static_assert(offsetof(AOrionPlayerController_Tutorial, TargetActor) == 0x000DD8, "Member 'AOrionPlayerController_Tutorial::TargetActor' has a wrong offset!");
static_assert(offsetof(AOrionPlayerController_Tutorial, TutorialPathArray) == 0x000DE0, "Member 'AOrionPlayerController_Tutorial::TutorialPathArray' has a wrong offset!");

// Class OrionGame.OrionPlayerInput
// 0x0248 (0x0270 - 0x0028)
class UOrionPlayerInput final : public UObject
{
public:
	uint8                                         Pad_28[0x248];                                     // 0x0028(0x0248)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPlayerInput">();
	}
	static class UOrionPlayerInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionPlayerInput>();
	}
};
static_assert(alignof(UOrionPlayerInput) == 0x000008, "Wrong alignment on UOrionPlayerInput");
static_assert(sizeof(UOrionPlayerInput) == 0x000270, "Wrong size on UOrionPlayerInput");

// Class OrionGame.OrionPlayerInput_GamepadConfig
// 0x0048 (0x0078 - 0x0030)
class UOrionPlayerInput_GamepadConfig final : public UDataAsset
{
public:
	class FName                                   ConfigName;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOrionPlayerInput_AxisMapping>  AxisMappings;                                      // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOrionPlayerInput_ActionMapping> ActionMappings;                                    // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   RightStickActionMappings[0x4];                     // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPlayerInput_GamepadConfig">();
	}
	static class UOrionPlayerInput_GamepadConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionPlayerInput_GamepadConfig>();
	}
};
static_assert(alignof(UOrionPlayerInput_GamepadConfig) == 0x000008, "Wrong alignment on UOrionPlayerInput_GamepadConfig");
static_assert(sizeof(UOrionPlayerInput_GamepadConfig) == 0x000078, "Wrong size on UOrionPlayerInput_GamepadConfig");
static_assert(offsetof(UOrionPlayerInput_GamepadConfig, ConfigName) == 0x000030, "Member 'UOrionPlayerInput_GamepadConfig::ConfigName' has a wrong offset!");
static_assert(offsetof(UOrionPlayerInput_GamepadConfig, AxisMappings) == 0x000038, "Member 'UOrionPlayerInput_GamepadConfig::AxisMappings' has a wrong offset!");
static_assert(offsetof(UOrionPlayerInput_GamepadConfig, ActionMappings) == 0x000048, "Member 'UOrionPlayerInput_GamepadConfig::ActionMappings' has a wrong offset!");
static_assert(offsetof(UOrionPlayerInput_GamepadConfig, RightStickActionMappings) == 0x000058, "Member 'UOrionPlayerInput_GamepadConfig::RightStickActionMappings' has a wrong offset!");

// Class OrionGame.OrionPlayerStart
// 0x0010 (0x0358 - 0x0348)
class AOrionPlayerStart final : public APlayerStart
{
public:
	uint8                                         Pad_348[0x8];                                      // 0x0348(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EOrionTeam                                    TeamIndex;                                         // 0x0350(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrionPosition                                PreferedPlayerPosition;                            // 0x0351(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnabled;                                          // 0x0352(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrionPlayerStartType                         PlayerStartType;                                   // 0x0353(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_354[0x4];                                      // 0x0354(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableStartingSpot();
	void EnableStartingSpot();

	EOrionPlayerStartType GetPlayerStartType() const;
	EOrionTeam GetTeamNum() const;
	bool IsEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPlayerStart">();
	}
	static class AOrionPlayerStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionPlayerStart>();
	}
};
static_assert(alignof(AOrionPlayerStart) == 0x000008, "Wrong alignment on AOrionPlayerStart");
static_assert(sizeof(AOrionPlayerStart) == 0x000358, "Wrong size on AOrionPlayerStart");
static_assert(offsetof(AOrionPlayerStart, TeamIndex) == 0x000350, "Member 'AOrionPlayerStart::TeamIndex' has a wrong offset!");
static_assert(offsetof(AOrionPlayerStart, PreferedPlayerPosition) == 0x000351, "Member 'AOrionPlayerStart::PreferedPlayerPosition' has a wrong offset!");
static_assert(offsetof(AOrionPlayerStart, bEnabled) == 0x000352, "Member 'AOrionPlayerStart::bEnabled' has a wrong offset!");
static_assert(offsetof(AOrionPlayerStart, PlayerStartType) == 0x000353, "Member 'AOrionPlayerStart::PlayerStartType' has a wrong offset!");

// Class OrionGame.OrionPlayerState_ArcadeLobby
// 0x0000 (0x0910 - 0x0910)
class AOrionPlayerState_ArcadeLobby final : public AOrionPlayerState_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPlayerState_ArcadeLobby">();
	}
	static class AOrionPlayerState_ArcadeLobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionPlayerState_ArcadeLobby>();
	}
};
static_assert(alignof(AOrionPlayerState_ArcadeLobby) == 0x000008, "Wrong alignment on AOrionPlayerState_ArcadeLobby");
static_assert(sizeof(AOrionPlayerState_ArcadeLobby) == 0x000910, "Wrong size on AOrionPlayerState_ArcadeLobby");

// Class OrionGame.OrionPlayerState_DemoSpectator
// 0x0000 (0x1400 - 0x1400)
class AOrionPlayerState_DemoSpectator final : public AOrionPlayerState_Game
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPlayerState_DemoSpectator">();
	}
	static class AOrionPlayerState_DemoSpectator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionPlayerState_DemoSpectator>();
	}
};
static_assert(alignof(AOrionPlayerState_DemoSpectator) == 0x000008, "Wrong alignment on AOrionPlayerState_DemoSpectator");
static_assert(sizeof(AOrionPlayerState_DemoSpectator) == 0x001400, "Wrong size on AOrionPlayerState_DemoSpectator");

// Class OrionGame.OrionPlayerState_DraftLobby
// 0x0330 (0x0C40 - 0x0910)
class AOrionPlayerState_DraftLobby final : public AOrionPlayerState_Base
{
public:
	EOrionDraftPickStatus                         PickStatus;                                        // 0x0910(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EOrionDraftAbortPenaltyReason                 AbortPenaltyReason;                                // 0x0911(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_912[0x6];                                      // 0x0912(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionDraftHeroSelectionInfo           LockedInHeroInfo;                                  // 0x0918(0x0030)(Net, RepNotify, NativeAccessSpecifierPrivate)
	struct FTeamSpecificDraftPlayerInfo           TeamSpecificInfo;                                  // 0x0948(0x0038)(Net, RepNotify, NativeAccessSpecifierPrivate)
	bool                                          bIsSoleHumanInDraft;                               // 0x0980(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_981[0x7];                                      // 0x0981(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrionHeroPlacementActor*               HeroPlacementActor;                                // 0x0988(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AOrionPlacementActor*                   BannerPlacementActor;                              // 0x0990(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_998[0x2A8];                                    // 0x0998(0x02A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_AbortPenaltyReason();
	void OnRep_IsSoleHumanInDraft();
	void OnRep_LockedInHeroInfo();
	void OnRep_PickStatus();
	void OnRep_TeamSpecificInfo(const struct FTeamSpecificDraftPlayerInfo& OldInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPlayerState_DraftLobby">();
	}
	static class AOrionPlayerState_DraftLobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionPlayerState_DraftLobby>();
	}
};
static_assert(alignof(AOrionPlayerState_DraftLobby) == 0x000008, "Wrong alignment on AOrionPlayerState_DraftLobby");
static_assert(sizeof(AOrionPlayerState_DraftLobby) == 0x000C40, "Wrong size on AOrionPlayerState_DraftLobby");
static_assert(offsetof(AOrionPlayerState_DraftLobby, PickStatus) == 0x000910, "Member 'AOrionPlayerState_DraftLobby::PickStatus' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_DraftLobby, AbortPenaltyReason) == 0x000911, "Member 'AOrionPlayerState_DraftLobby::AbortPenaltyReason' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_DraftLobby, LockedInHeroInfo) == 0x000918, "Member 'AOrionPlayerState_DraftLobby::LockedInHeroInfo' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_DraftLobby, TeamSpecificInfo) == 0x000948, "Member 'AOrionPlayerState_DraftLobby::TeamSpecificInfo' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_DraftLobby, bIsSoleHumanInDraft) == 0x000980, "Member 'AOrionPlayerState_DraftLobby::bIsSoleHumanInDraft' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_DraftLobby, HeroPlacementActor) == 0x000988, "Member 'AOrionPlayerState_DraftLobby::HeroPlacementActor' has a wrong offset!");
static_assert(offsetof(AOrionPlayerState_DraftLobby, BannerPlacementActor) == 0x000990, "Member 'AOrionPlayerState_DraftLobby::BannerPlacementActor' has a wrong offset!");

// Class OrionGame.OrionPlayerState_Main
// 0x0150 (0x0A60 - 0x0910)
class AOrionPlayerState_Main final : public AOrionPlayerState_Base
{
public:
	uint8                                         Pad_910[0x150];                                    // 0x0910(0x0150)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPlayerState_Main">();
	}
	static class AOrionPlayerState_Main* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionPlayerState_Main>();
	}
};
static_assert(alignof(AOrionPlayerState_Main) == 0x000008, "Wrong alignment on AOrionPlayerState_Main");
static_assert(sizeof(AOrionPlayerState_Main) == 0x000A60, "Wrong size on AOrionPlayerState_Main");

// Class OrionGame.OrionPlayerState_PreGame
// 0x0000 (0x0910 - 0x0910)
class AOrionPlayerState_PreGame final : public AOrionPlayerState_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPlayerState_PreGame">();
	}
	static class AOrionPlayerState_PreGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionPlayerState_PreGame>();
	}
};
static_assert(alignof(AOrionPlayerState_PreGame) == 0x000008, "Wrong alignment on AOrionPlayerState_PreGame");
static_assert(sizeof(AOrionPlayerState_PreGame) == 0x000910, "Wrong size on AOrionPlayerState_PreGame");

// Class OrionGame.OrionPlayerState_Sandbox
// 0x0000 (0x1400 - 0x1400)
class AOrionPlayerState_Sandbox final : public AOrionPlayerState_Game
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPlayerState_Sandbox">();
	}
	static class AOrionPlayerState_Sandbox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionPlayerState_Sandbox>();
	}
};
static_assert(alignof(AOrionPlayerState_Sandbox) == 0x000008, "Wrong alignment on AOrionPlayerState_Sandbox");
static_assert(sizeof(AOrionPlayerState_Sandbox) == 0x001400, "Wrong size on AOrionPlayerState_Sandbox");

// Class OrionGame.OrionPlayerState_Tutorial
// 0x0010 (0x1410 - 0x1400)
class AOrionPlayerState_Tutorial final : public AOrionPlayerState_Game
{
public:
	uint8                                         Pad_1400[0x10];                                    // 0x1400(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceHeroToLevel(int32 Level);
	void ServerUpdateStatFromTutorial(TSubclassOf<class UOrionTutorial> TutorialClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPlayerState_Tutorial">();
	}
	static class AOrionPlayerState_Tutorial* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionPlayerState_Tutorial>();
	}
};
static_assert(alignof(AOrionPlayerState_Tutorial) == 0x000008, "Wrong alignment on AOrionPlayerState_Tutorial");
static_assert(sizeof(AOrionPlayerState_Tutorial) == 0x001410, "Wrong size on AOrionPlayerState_Tutorial");

// Class OrionGame.OrionPlaylistLedger
// 0x0010 (0x0040 - 0x0030)
class UOrionPlaylistLedger final : public UDataAsset
{
public:
	TArray<struct FOrionPlaylistInfo>             PlaylistEntries;                                   // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPlaylistLedger">();
	}
	static class UOrionPlaylistLedger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionPlaylistLedger>();
	}
};
static_assert(alignof(UOrionPlaylistLedger) == 0x000008, "Wrong alignment on UOrionPlaylistLedger");
static_assert(sizeof(UOrionPlaylistLedger) == 0x000040, "Wrong size on UOrionPlaylistLedger");
static_assert(offsetof(UOrionPlaylistLedger, PlaylistEntries) == 0x000030, "Member 'UOrionPlaylistLedger::PlaylistEntries' has a wrong offset!");

// Class OrionGame.OrionPlaylistManager
// 0x0020 (0x0048 - 0x0028)
class UOrionPlaylistManager final : public UObject
{
public:
	TArray<struct FOrionPlaylistInfo>             Playlists;                                         // 0x0028(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	class FString                                 PostMatchMap;                                      // 0x0038(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static bool AllowsRejoin(int32 PlaylistId);
	static bool AllowsSurrender(int32 PlaylistId);
	static bool AwardsXP(int32 PlaylistId);
	static bool DoesPlaylistAllowMirrorMatches(int32 PlaylistId);
	static bool Exists(int32 PlaylistId);
	static bool FindPlaylist(int32 PlaylistId, struct FOrionPlaylistInfo* OutPlaylist);
	static class FString GetArcadeURL(int32 PlaylistId);
	static bool GetGameMapURL(int32 PlaylistId, class FString* OutMapURL);
	static class FString GetLoadingScreen(int32 PlaylistId);
	static bool GetLobbyMapURL(int32 PlaylistId, class FString* OutMapURL);
	static class FString GetPlaylistName(int32 PlaylistId);
	static class FString GetRatingType(int32 PlaylistId);
	static bool GetRawGameMapPath(int32 PlaylistId, class FString* OutMapPath);
	static class FString GetReplayFlag(int32 PlaylistId);
	static bool GetTeamInfo(int32 PlaylistId, int32* OutMaxPlayers, int32* OutMaxTeams, int32* OutTeamSize);
	static int32 GetTeamSize(const int32 PlaylistId);
	static bool HasBots(int32 PlaylistId);
	static bool HasEnemyBots(int32 PlaylistId);
	static bool HasFriendlyBots(int32 PlaylistId);
	static bool IsCoop(int32 PlaylistId);
	static bool IsPVP(int32 PlaylistId);
	static bool IsRanked(int32 PlaylistId);
	static bool IsSolo(int32 PlaylistId);
	static bool IsSoloVsAI(int32 PlaylistId);
	static bool IsTutorial(const int32 PlaylistId);
	static bool PlaylistHasLobby(int32 PlaylistId);
	static bool ShouldShowPostMatchSummary(const int32 PlaylistId);
	static bool SupportsCustomMMKey(int32 PlaylistId);
	static bool SupportsDraftInReplays(const int32 PlaylistId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPlaylistManager">();
	}
	static class UOrionPlaylistManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionPlaylistManager>();
	}
};
static_assert(alignof(UOrionPlaylistManager) == 0x000008, "Wrong alignment on UOrionPlaylistManager");
static_assert(sizeof(UOrionPlaylistManager) == 0x000048, "Wrong size on UOrionPlaylistManager");
static_assert(offsetof(UOrionPlaylistManager, Playlists) == 0x000028, "Member 'UOrionPlaylistManager::Playlists' has a wrong offset!");
static_assert(offsetof(UOrionPlaylistManager, PostMatchMap) == 0x000038, "Member 'UOrionPlaylistManager::PostMatchMap' has a wrong offset!");

// Class OrionGame.OrionPostGameDisplayData
// 0x0088 (0x00B8 - 0x0030)
class UOrionPostGameDisplayData final : public UDataAsset
{
public:
	class UTexture2D*                             DefaultIcon;                                       // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOrionIndividualPlayerRating>   GoodRatings;                                       // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FOrionIndividualPlayerRating>   BadRatings;                                        // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   BanTitle;                                          // 0x0058(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   BanMessage;                                        // 0x0070(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   AfkTitle;                                          // 0x0088(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   AfkMessage;                                        // 0x00A0(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPostGameDisplayData">();
	}
	static class UOrionPostGameDisplayData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionPostGameDisplayData>();
	}
};
static_assert(alignof(UOrionPostGameDisplayData) == 0x000008, "Wrong alignment on UOrionPostGameDisplayData");
static_assert(sizeof(UOrionPostGameDisplayData) == 0x0000B8, "Wrong size on UOrionPostGameDisplayData");
static_assert(offsetof(UOrionPostGameDisplayData, DefaultIcon) == 0x000030, "Member 'UOrionPostGameDisplayData::DefaultIcon' has a wrong offset!");
static_assert(offsetof(UOrionPostGameDisplayData, GoodRatings) == 0x000038, "Member 'UOrionPostGameDisplayData::GoodRatings' has a wrong offset!");
static_assert(offsetof(UOrionPostGameDisplayData, BadRatings) == 0x000048, "Member 'UOrionPostGameDisplayData::BadRatings' has a wrong offset!");
static_assert(offsetof(UOrionPostGameDisplayData, BanTitle) == 0x000058, "Member 'UOrionPostGameDisplayData::BanTitle' has a wrong offset!");
static_assert(offsetof(UOrionPostGameDisplayData, BanMessage) == 0x000070, "Member 'UOrionPostGameDisplayData::BanMessage' has a wrong offset!");
static_assert(offsetof(UOrionPostGameDisplayData, AfkTitle) == 0x000088, "Member 'UOrionPostGameDisplayData::AfkTitle' has a wrong offset!");
static_assert(offsetof(UOrionPostGameDisplayData, AfkMessage) == 0x0000A0, "Member 'UOrionPostGameDisplayData::AfkMessage' has a wrong offset!");

// Class OrionGame.OrionPriceAnimInstance
// 0x00C0 (0x0830 - 0x0770)
class UOrionPriceAnimInstance final : public UOrionBaseHeroAnimInstance
{
public:
	class UAnimMontage*                           ShieldMontage;                                     // 0x0770(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ShieldKnockBackMontage;                            // 0x0778(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FireSlowMontage;                                   // 0x0780(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FireMedMontage;                                    // 0x0788(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FireFastMontage;                                   // 0x0790(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           TheElevenMontage;                                  // 0x0798(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           TazerTrapMontage;                                  // 0x07A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SpreadShotFireRecoilMontage;                       // 0x07A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SpreadShotStartLoopMontage;                        // 0x07B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            SpreadShotBlendSpace;                              // 0x07B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            UltimateBlendSpace;                                // 0x07C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            ShieldBlendSpace;                                  // 0x07C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            IdleBlendSpace;                                    // 0x07D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DisableLeftHandIKCurveName;                        // 0x07D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpperBodyMSAMaskWeight;                            // 0x07E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmsAndHeadMaskWeight;                             // 0x07E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShotgunArmDynAlpha;                                // 0x07E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShotgunConstraintAlpha;                            // 0x07EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftHandIKAlpha;                                   // 0x07F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInSpreadShotMode;                               // 0x07F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSpreadShotFired;                               // 0x07F5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInShieldMode;                                   // 0x07F6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInShotgunMode;                                  // 0x07F7(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShieldKnockBack;                                // 0x07F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUsingUltimate;                                  // 0x07F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTheElevenKneel;                                   // 0x07FA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTheElevenFire;                                    // 0x07FB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RootBoneRotation;                                  // 0x07FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootIKAlpha;                                       // 0x0800(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimDynamicsAlpha;                                 // 0x0804(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplySpreadShotAdditive;                          // 0x0808(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_809[0x3];                                      // 0x0809(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpreadShotAdditiveAlpha;                           // 0x080C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyShieldLocomotionAdditive;                    // 0x0810(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_811[0x3];                                      // 0x0811(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShieldLocomotionAdditiveAlpha;                     // 0x0814(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            AimOffsetBlendSpace;                               // 0x0818(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShieldHitReactA;                                  // 0x0820(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShieldHitReactB;                                  // 0x0821(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShotGunSpreadIKToggle;                            // 0x0822(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_823[0x1];                                      // 0x0823(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeftHandShotGunIKAlpha;                            // 0x0824(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_ShieldAdditives_Default_To_Shield_Locomotion; // 0x0828(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransition_ShieldAdditives_Shield_Locomotion_To_Default; // 0x0829(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82A[0x6];                                      // 0x082A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AnimNotify_IK_HndShotGun_Off(const class UAnimNotify* AnimNotify);
	void AnimNotify_IK_HndShotGun_On(const class UAnimNotify* AnimNotify);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionPriceAnimInstance">();
	}
	static class UOrionPriceAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionPriceAnimInstance>();
	}
};
static_assert(alignof(UOrionPriceAnimInstance) == 0x000008, "Wrong alignment on UOrionPriceAnimInstance");
static_assert(sizeof(UOrionPriceAnimInstance) == 0x000830, "Wrong size on UOrionPriceAnimInstance");
static_assert(offsetof(UOrionPriceAnimInstance, ShieldMontage) == 0x000770, "Member 'UOrionPriceAnimInstance::ShieldMontage' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, ShieldKnockBackMontage) == 0x000778, "Member 'UOrionPriceAnimInstance::ShieldKnockBackMontage' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, FireSlowMontage) == 0x000780, "Member 'UOrionPriceAnimInstance::FireSlowMontage' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, FireMedMontage) == 0x000788, "Member 'UOrionPriceAnimInstance::FireMedMontage' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, FireFastMontage) == 0x000790, "Member 'UOrionPriceAnimInstance::FireFastMontage' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, TheElevenMontage) == 0x000798, "Member 'UOrionPriceAnimInstance::TheElevenMontage' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, TazerTrapMontage) == 0x0007A0, "Member 'UOrionPriceAnimInstance::TazerTrapMontage' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, SpreadShotFireRecoilMontage) == 0x0007A8, "Member 'UOrionPriceAnimInstance::SpreadShotFireRecoilMontage' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, SpreadShotStartLoopMontage) == 0x0007B0, "Member 'UOrionPriceAnimInstance::SpreadShotStartLoopMontage' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, SpreadShotBlendSpace) == 0x0007B8, "Member 'UOrionPriceAnimInstance::SpreadShotBlendSpace' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, UltimateBlendSpace) == 0x0007C0, "Member 'UOrionPriceAnimInstance::UltimateBlendSpace' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, ShieldBlendSpace) == 0x0007C8, "Member 'UOrionPriceAnimInstance::ShieldBlendSpace' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, IdleBlendSpace) == 0x0007D0, "Member 'UOrionPriceAnimInstance::IdleBlendSpace' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, DisableLeftHandIKCurveName) == 0x0007D8, "Member 'UOrionPriceAnimInstance::DisableLeftHandIKCurveName' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, UpperBodyMSAMaskWeight) == 0x0007E0, "Member 'UOrionPriceAnimInstance::UpperBodyMSAMaskWeight' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, ArmsAndHeadMaskWeight) == 0x0007E4, "Member 'UOrionPriceAnimInstance::ArmsAndHeadMaskWeight' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, ShotgunArmDynAlpha) == 0x0007E8, "Member 'UOrionPriceAnimInstance::ShotgunArmDynAlpha' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, ShotgunConstraintAlpha) == 0x0007EC, "Member 'UOrionPriceAnimInstance::ShotgunConstraintAlpha' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, LeftHandIKAlpha) == 0x0007F0, "Member 'UOrionPriceAnimInstance::LeftHandIKAlpha' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, bIsInSpreadShotMode) == 0x0007F4, "Member 'UOrionPriceAnimInstance::bIsInSpreadShotMode' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, bHasSpreadShotFired) == 0x0007F5, "Member 'UOrionPriceAnimInstance::bHasSpreadShotFired' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, bIsInShieldMode) == 0x0007F6, "Member 'UOrionPriceAnimInstance::bIsInShieldMode' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, bIsInShotgunMode) == 0x0007F7, "Member 'UOrionPriceAnimInstance::bIsInShotgunMode' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, bIsShieldKnockBack) == 0x0007F8, "Member 'UOrionPriceAnimInstance::bIsShieldKnockBack' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, bIsUsingUltimate) == 0x0007F9, "Member 'UOrionPriceAnimInstance::bIsUsingUltimate' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, bTheElevenKneel) == 0x0007FA, "Member 'UOrionPriceAnimInstance::bTheElevenKneel' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, bTheElevenFire) == 0x0007FB, "Member 'UOrionPriceAnimInstance::bTheElevenFire' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, RootBoneRotation) == 0x0007FC, "Member 'UOrionPriceAnimInstance::RootBoneRotation' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, FootIKAlpha) == 0x000800, "Member 'UOrionPriceAnimInstance::FootIKAlpha' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, AnimDynamicsAlpha) == 0x000804, "Member 'UOrionPriceAnimInstance::AnimDynamicsAlpha' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, bApplySpreadShotAdditive) == 0x000808, "Member 'UOrionPriceAnimInstance::bApplySpreadShotAdditive' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, SpreadShotAdditiveAlpha) == 0x00080C, "Member 'UOrionPriceAnimInstance::SpreadShotAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, bApplyShieldLocomotionAdditive) == 0x000810, "Member 'UOrionPriceAnimInstance::bApplyShieldLocomotionAdditive' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, ShieldLocomotionAdditiveAlpha) == 0x000814, "Member 'UOrionPriceAnimInstance::ShieldLocomotionAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, AimOffsetBlendSpace) == 0x000818, "Member 'UOrionPriceAnimInstance::AimOffsetBlendSpace' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, bShieldHitReactA) == 0x000820, "Member 'UOrionPriceAnimInstance::bShieldHitReactA' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, bShieldHitReactB) == 0x000821, "Member 'UOrionPriceAnimInstance::bShieldHitReactB' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, bShotGunSpreadIKToggle) == 0x000822, "Member 'UOrionPriceAnimInstance::bShotGunSpreadIKToggle' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, LeftHandShotGunIKAlpha) == 0x000824, "Member 'UOrionPriceAnimInstance::LeftHandShotGunIKAlpha' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, bTransition_ShieldAdditives_Default_To_Shield_Locomotion) == 0x000828, "Member 'UOrionPriceAnimInstance::bTransition_ShieldAdditives_Default_To_Shield_Locomotion' has a wrong offset!");
static_assert(offsetof(UOrionPriceAnimInstance, bTransition_ShieldAdditives_Shield_Locomotion_To_Default) == 0x000829, "Member 'UOrionPriceAnimInstance::bTransition_ShieldAdditives_Shield_Locomotion_To_Default' has a wrong offset!");

// Class OrionGame.OrionProfanityData
// 0x0010 (0x0040 - 0x0030)
class UOrionProfanityData final : public UDataAsset
{
public:
	TArray<struct FProfanityData>                 ProfanityData;                                     // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionProfanityData">();
	}
	static class UOrionProfanityData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionProfanityData>();
	}
};
static_assert(alignof(UOrionProfanityData) == 0x000008, "Wrong alignment on UOrionProfanityData");
static_assert(sizeof(UOrionProfanityData) == 0x000040, "Wrong size on UOrionProfanityData");
static_assert(offsetof(UOrionProfanityData, ProfanityData) == 0x000030, "Member 'UOrionProfanityData::ProfanityData' has a wrong offset!");

// Class OrionGame.OrionProjectileMovementComponent
// 0x0138 (0x0270 - 0x0138)
class UOrionProjectileMovementComponent : public UMovementComponent
{
public:
	float                                         InitialSpeed;                                      // 0x0138(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InitialDir;                                        // 0x013C(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0148(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRotationFollowsVelocity : 1;                      // 0x014C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_14D[0x3];                                      // 0x014D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               RotationalVelocity;                                // 0x0150(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bShouldBounce : 1;                                 // 0x015C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15D[0x3];                                      // 0x015D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SurfaceAngleTolerance;                             // 0x0160(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurfaceDotTolerance;                               // 0x0164(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_168[0xC];                                      // 0x0168(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bInitialVelocityInLocalSpace : 1;                  // 0x0174(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForceSubStepping : 1;                             // 0x0174(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bBounceAngleAffectsFriction : 1;                   // 0x0174(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsSliding : 1;                                    // 0x0174(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_175[0x3];                                      // 0x0175(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PreviousHitTime;                                   // 0x0178(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PreviousHitNormal;                                 // 0x017C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileGravityScale;                            // 0x0188(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Buoyancy;                                          // 0x018C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bounciness;                                        // 0x0190(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Friction;                                          // 0x0194(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumBouncesAllowedPerSubStep;                       // 0x0198(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BounceVelocityStopSimulatingThreshold;             // 0x019C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BounceImpactSpeedThreshold;                        // 0x01A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A4[0x4];                                      // 0x01A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnProjectileBounce;                                // 0x01A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnProjectileStop;                                  // 0x01B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnProjectileMaxRange;                              // 0x01C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnProjectileVelocityReversed;                      // 0x01D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EOrionProjectileMovementMode                  MovementMode;                                      // 0x01E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E9[0x3];                                      // 0x01E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BounceVelocityReversedThreshold;                   // 0x01EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  LockOnActor;                                       // 0x01F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HomingOffset;                                      // 0x01F8(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_204[0x4];                                      // 0x0204(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LockOnSocket;                                      // 0x0208(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HomingTurnRate;                                    // 0x0210(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HomingTurnRateMin;                                 // 0x0214(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HomingTurnRateMax;                                 // 0x0218(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HomingTurnAcceleration;                            // 0x021C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HomingAngleRange;                                  // 0x0220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bForceHomingEnabled : 1;                           // 0x0224(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHomingMaintainInitialSpeed : 1;                   // 0x0224(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_225[0x3];                                      // 0x0225(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHomingWithoutTargetData               HomingWithoutTargetData;                           // 0x0228(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MaxSimulationTimeStep;                             // 0x0240(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSimulationIterations;                           // 0x0244(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    CollisionOverlapComponent;                         // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDebugEnableLogging : 1;                           // 0x0250(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDebugDrawContactNormal : 1;                       // 0x0250(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDebugDrawContacts : 1;                            // 0x0250(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDebugDrawCornerContacts : 1;                      // 0x0250(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDebugDrawOverlappedComponent : 1;                 // 0x0250(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDebugDrawHoming : 1;                              // 0x0250(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDebugDrawUpdateComponentMovement : 1;             // 0x0250(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCheckForInvalidCornerNormals : 1;                 // 0x0250(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_251[0x3];                                      // 0x0251(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bFoundInvalidCornerNormal;                         // 0x0254(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_255[0x1B];                                     // 0x0255(0x001B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetHomingTargetLocation();
	void OnOrionProjectileBounceDelegate__DelegateSignature(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity);
	void OnOrionProjectileMaxRangeDelegate__DelegateSignature();
	void OnOrionProjectileStopDelegate__DelegateSignature(const struct FHitResult& ImpactResult);
	void OnOrionProjectileVelocityReversedDelegate__DelegateSignature();
	void SetHomingTargetLocation(const struct FVector& NewLocation);
	void SetVelocityInLocalSpace(const struct FVector& NewVelocity);
	void StopSimulating(const struct FHitResult& HitResult);

	void LimitVelocity(const struct FVector& InVelocity, const struct FVector& InUnlimitedVelocity, struct FVector* OutVelocity, struct FVector* OutUnlimitedVelocity) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionProjectileMovementComponent">();
	}
	static class UOrionProjectileMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionProjectileMovementComponent>();
	}
};
static_assert(alignof(UOrionProjectileMovementComponent) == 0x000008, "Wrong alignment on UOrionProjectileMovementComponent");
static_assert(sizeof(UOrionProjectileMovementComponent) == 0x000270, "Wrong size on UOrionProjectileMovementComponent");
static_assert(offsetof(UOrionProjectileMovementComponent, InitialSpeed) == 0x000138, "Member 'UOrionProjectileMovementComponent::InitialSpeed' has a wrong offset!");
static_assert(offsetof(UOrionProjectileMovementComponent, InitialDir) == 0x00013C, "Member 'UOrionProjectileMovementComponent::InitialDir' has a wrong offset!");
static_assert(offsetof(UOrionProjectileMovementComponent, MaxSpeed) == 0x000148, "Member 'UOrionProjectileMovementComponent::MaxSpeed' has a wrong offset!");
static_assert(offsetof(UOrionProjectileMovementComponent, RotationalVelocity) == 0x000150, "Member 'UOrionProjectileMovementComponent::RotationalVelocity' has a wrong offset!");
static_assert(offsetof(UOrionProjectileMovementComponent, SurfaceAngleTolerance) == 0x000160, "Member 'UOrionProjectileMovementComponent::SurfaceAngleTolerance' has a wrong offset!");
static_assert(offsetof(UOrionProjectileMovementComponent, SurfaceDotTolerance) == 0x000164, "Member 'UOrionProjectileMovementComponent::SurfaceDotTolerance' has a wrong offset!");
static_assert(offsetof(UOrionProjectileMovementComponent, PreviousHitTime) == 0x000178, "Member 'UOrionProjectileMovementComponent::PreviousHitTime' has a wrong offset!");
static_assert(offsetof(UOrionProjectileMovementComponent, PreviousHitNormal) == 0x00017C, "Member 'UOrionProjectileMovementComponent::PreviousHitNormal' has a wrong offset!");
static_assert(offsetof(UOrionProjectileMovementComponent, ProjectileGravityScale) == 0x000188, "Member 'UOrionProjectileMovementComponent::ProjectileGravityScale' has a wrong offset!");
static_assert(offsetof(UOrionProjectileMovementComponent, Buoyancy) == 0x00018C, "Member 'UOrionProjectileMovementComponent::Buoyancy' has a wrong offset!");
static_assert(offsetof(UOrionProjectileMovementComponent, Bounciness) == 0x000190, "Member 'UOrionProjectileMovementComponent::Bounciness' has a wrong offset!");
static_assert(offsetof(UOrionProjectileMovementComponent, Friction) == 0x000194, "Member 'UOrionProjectileMovementComponent::Friction' has a wrong offset!");
static_assert(offsetof(UOrionProjectileMovementComponent, NumBouncesAllowedPerSubStep) == 0x000198, "Member 'UOrionProjectileMovementComponent::NumBouncesAllowedPerSubStep' has a wrong offset!");
static_assert(offsetof(UOrionProjectileMovementComponent, BounceVelocityStopSimulatingThreshold) == 0x00019C, "Member 'UOrionProjectileMovementComponent::BounceVelocityStopSimulatingThreshold' has a wrong offset!");
static_assert(offsetof(UOrionProjectileMovementComponent, BounceImpactSpeedThreshold) == 0x0001A0, "Member 'UOrionProjectileMovementComponent::BounceImpactSpeedThreshold' has a wrong offset!");
static_assert(offsetof(UOrionProjectileMovementComponent, OnProjectileBounce) == 0x0001A8, "Member 'UOrionProjectileMovementComponent::OnProjectileBounce' has a wrong offset!");
static_assert(offsetof(UOrionProjectileMovementComponent, OnProjectileStop) == 0x0001B8, "Member 'UOrionProjectileMovementComponent::OnProjectileStop' has a wrong offset!");
static_assert(offsetof(UOrionProjectileMovementComponent, OnProjectileMaxRange) == 0x0001C8, "Member 'UOrionProjectileMovementComponent::OnProjectileMaxRange' has a wrong offset!");
static_assert(offsetof(UOrionProjectileMovementComponent, OnProjectileVelocityReversed) == 0x0001D8, "Member 'UOrionProjectileMovementComponent::OnProjectileVelocityReversed' has a wrong offset!");
static_assert(offsetof(UOrionProjectileMovementComponent, MovementMode) == 0x0001E8, "Member 'UOrionProjectileMovementComponent::MovementMode' has a wrong offset!");
static_assert(offsetof(UOrionProjectileMovementComponent, BounceVelocityReversedThreshold) == 0x0001EC, "Member 'UOrionProjectileMovementComponent::BounceVelocityReversedThreshold' has a wrong offset!");
static_assert(offsetof(UOrionProjectileMovementComponent, LockOnActor) == 0x0001F0, "Member 'UOrionProjectileMovementComponent::LockOnActor' has a wrong offset!");
static_assert(offsetof(UOrionProjectileMovementComponent, HomingOffset) == 0x0001F8, "Member 'UOrionProjectileMovementComponent::HomingOffset' has a wrong offset!");
static_assert(offsetof(UOrionProjectileMovementComponent, LockOnSocket) == 0x000208, "Member 'UOrionProjectileMovementComponent::LockOnSocket' has a wrong offset!");
static_assert(offsetof(UOrionProjectileMovementComponent, HomingTurnRate) == 0x000210, "Member 'UOrionProjectileMovementComponent::HomingTurnRate' has a wrong offset!");
static_assert(offsetof(UOrionProjectileMovementComponent, HomingTurnRateMin) == 0x000214, "Member 'UOrionProjectileMovementComponent::HomingTurnRateMin' has a wrong offset!");
static_assert(offsetof(UOrionProjectileMovementComponent, HomingTurnRateMax) == 0x000218, "Member 'UOrionProjectileMovementComponent::HomingTurnRateMax' has a wrong offset!");
static_assert(offsetof(UOrionProjectileMovementComponent, HomingTurnAcceleration) == 0x00021C, "Member 'UOrionProjectileMovementComponent::HomingTurnAcceleration' has a wrong offset!");
static_assert(offsetof(UOrionProjectileMovementComponent, HomingAngleRange) == 0x000220, "Member 'UOrionProjectileMovementComponent::HomingAngleRange' has a wrong offset!");
static_assert(offsetof(UOrionProjectileMovementComponent, HomingWithoutTargetData) == 0x000228, "Member 'UOrionProjectileMovementComponent::HomingWithoutTargetData' has a wrong offset!");
static_assert(offsetof(UOrionProjectileMovementComponent, MaxSimulationTimeStep) == 0x000240, "Member 'UOrionProjectileMovementComponent::MaxSimulationTimeStep' has a wrong offset!");
static_assert(offsetof(UOrionProjectileMovementComponent, MaxSimulationIterations) == 0x000244, "Member 'UOrionProjectileMovementComponent::MaxSimulationIterations' has a wrong offset!");
static_assert(offsetof(UOrionProjectileMovementComponent, CollisionOverlapComponent) == 0x000248, "Member 'UOrionProjectileMovementComponent::CollisionOverlapComponent' has a wrong offset!");
static_assert(offsetof(UOrionProjectileMovementComponent, bFoundInvalidCornerNormal) == 0x000254, "Member 'UOrionProjectileMovementComponent::bFoundInvalidCornerNormal' has a wrong offset!");

// Class OrionGame.OrionProjFloorMovementComponent
// 0x00C0 (0x0330 - 0x0270)
class UOrionProjFloorMovementComponent final : public UOrionProjectileMovementComponent
{
public:
	uint8                                         bDebugDrawComputeFloor : 1;                        // 0x0270(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDebugDrawSteppingSweeps : 1;                      // 0x0270(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDebugDrawSteppingSweepLines : 1;                  // 0x0270(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMovesAlongGround : 1;                             // 0x0270(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_271[0x3];                                      // 0x0271(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxStepHeight;                                     // 0x0274(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkableFloorAngle;                                // 0x0278(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkableFloorZ;                                    // 0x027C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bJustTeleported : 1;                               // 0x0280(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMaintainHorizontalGroundVelocity : 1;             // 0x0280(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_281[0x7];                                      // 0x0281(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FProjFindFloorResult                   CurrentFloor;                                      // 0x0288(0x0098)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         PerchRadiusThreshold;                              // 0x0320(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerchAdditionalHeight;                             // 0x0324(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetWalkableFloorAngle(float InWalkableFloorAngle);
	void SetWalkableFloorZ(float InWalkableFloorZ);

	float GetPerchRadiusThreshold() const;
	float GetValidPerchRadius() const;
	bool IsWalkable(const struct FHitResult& Hit) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionProjFloorMovementComponent">();
	}
	static class UOrionProjFloorMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionProjFloorMovementComponent>();
	}
};
static_assert(alignof(UOrionProjFloorMovementComponent) == 0x000008, "Wrong alignment on UOrionProjFloorMovementComponent");
static_assert(sizeof(UOrionProjFloorMovementComponent) == 0x000330, "Wrong size on UOrionProjFloorMovementComponent");
static_assert(offsetof(UOrionProjFloorMovementComponent, MaxStepHeight) == 0x000274, "Member 'UOrionProjFloorMovementComponent::MaxStepHeight' has a wrong offset!");
static_assert(offsetof(UOrionProjFloorMovementComponent, WalkableFloorAngle) == 0x000278, "Member 'UOrionProjFloorMovementComponent::WalkableFloorAngle' has a wrong offset!");
static_assert(offsetof(UOrionProjFloorMovementComponent, WalkableFloorZ) == 0x00027C, "Member 'UOrionProjFloorMovementComponent::WalkableFloorZ' has a wrong offset!");
static_assert(offsetof(UOrionProjFloorMovementComponent, CurrentFloor) == 0x000288, "Member 'UOrionProjFloorMovementComponent::CurrentFloor' has a wrong offset!");
static_assert(offsetof(UOrionProjFloorMovementComponent, PerchRadiusThreshold) == 0x000320, "Member 'UOrionProjFloorMovementComponent::PerchRadiusThreshold' has a wrong offset!");
static_assert(offsetof(UOrionProjFloorMovementComponent, PerchAdditionalHeight) == 0x000324, "Member 'UOrionProjFloorMovementComponent::PerchAdditionalHeight' has a wrong offset!");

// Class OrionGame.GameplayQualifierKeywordFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UGameplayQualifierKeywordFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void EvaluateQualifierSpec(const struct FGameplayQualifierParameters& QualifierSpec, EQualifierEvaluationResult* OutResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayQualifierKeywordFunctionLibrary">();
	}
	static class UGameplayQualifierKeywordFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayQualifierKeywordFunctionLibrary>();
	}
};
static_assert(alignof(UGameplayQualifierKeywordFunctionLibrary) == 0x000008, "Wrong alignment on UGameplayQualifierKeywordFunctionLibrary");
static_assert(sizeof(UGameplayQualifierKeywordFunctionLibrary) == 0x000028, "Wrong size on UGameplayQualifierKeywordFunctionLibrary");

// Class OrionGame.OrionQueryContext_AllEnemies
// 0x0000 (0x0028 - 0x0028)
class UOrionQueryContext_AllEnemies final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionQueryContext_AllEnemies">();
	}
	static class UOrionQueryContext_AllEnemies* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionQueryContext_AllEnemies>();
	}
};
static_assert(alignof(UOrionQueryContext_AllEnemies) == 0x000008, "Wrong alignment on UOrionQueryContext_AllEnemies");
static_assert(sizeof(UOrionQueryContext_AllEnemies) == 0x000028, "Wrong size on UOrionQueryContext_AllEnemies");

// Class OrionGame.OrionQueryContext_CurrentDestination
// 0x0000 (0x0028 - 0x0028)
class UOrionQueryContext_CurrentDestination final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionQueryContext_CurrentDestination">();
	}
	static class UOrionQueryContext_CurrentDestination* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionQueryContext_CurrentDestination>();
	}
};
static_assert(alignof(UOrionQueryContext_CurrentDestination) == 0x000008, "Wrong alignment on UOrionQueryContext_CurrentDestination");
static_assert(sizeof(UOrionQueryContext_CurrentDestination) == 0x000028, "Wrong size on UOrionQueryContext_CurrentDestination");

// Class OrionGame.OrionQueryContext_CurrentEnemy
// 0x0000 (0x0028 - 0x0028)
class UOrionQueryContext_CurrentEnemy final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionQueryContext_CurrentEnemy">();
	}
	static class UOrionQueryContext_CurrentEnemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionQueryContext_CurrentEnemy>();
	}
};
static_assert(alignof(UOrionQueryContext_CurrentEnemy) == 0x000008, "Wrong alignment on UOrionQueryContext_CurrentEnemy");
static_assert(sizeof(UOrionQueryContext_CurrentEnemy) == 0x000028, "Wrong size on UOrionQueryContext_CurrentEnemy");

// Class OrionGame.OrionQueryContext_FrontWaveLocation
// 0x0000 (0x0028 - 0x0028)
class UOrionQueryContext_FrontWaveLocation final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionQueryContext_FrontWaveLocation">();
	}
	static class UOrionQueryContext_FrontWaveLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionQueryContext_FrontWaveLocation>();
	}
};
static_assert(alignof(UOrionQueryContext_FrontWaveLocation) == 0x000008, "Wrong alignment on UOrionQueryContext_FrontWaveLocation");
static_assert(sizeof(UOrionQueryContext_FrontWaveLocation) == 0x000028, "Wrong size on UOrionQueryContext_FrontWaveLocation");

// Class OrionGame.OrionQueryContext_LaneGoal
// 0x0000 (0x0028 - 0x0028)
class UOrionQueryContext_LaneGoal final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionQueryContext_LaneGoal">();
	}
	static class UOrionQueryContext_LaneGoal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionQueryContext_LaneGoal>();
	}
};
static_assert(alignof(UOrionQueryContext_LaneGoal) == 0x000008, "Wrong alignment on UOrionQueryContext_LaneGoal");
static_assert(sizeof(UOrionQueryContext_LaneGoal) == 0x000028, "Wrong size on UOrionQueryContext_LaneGoal");

// Class OrionGame.OrionQueryContext_ObjectiveActor
// 0x0000 (0x0028 - 0x0028)
class UOrionQueryContext_ObjectiveActor final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionQueryContext_ObjectiveActor">();
	}
	static class UOrionQueryContext_ObjectiveActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionQueryContext_ObjectiveActor>();
	}
};
static_assert(alignof(UOrionQueryContext_ObjectiveActor) == 0x000008, "Wrong alignment on UOrionQueryContext_ObjectiveActor");
static_assert(sizeof(UOrionQueryContext_ObjectiveActor) == 0x000028, "Wrong size on UOrionQueryContext_ObjectiveActor");

// Class OrionGame.OrionQueryContext_OwnTowerInLane
// 0x0000 (0x0028 - 0x0028)
class UOrionQueryContext_OwnTowerInLane final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionQueryContext_OwnTowerInLane">();
	}
	static class UOrionQueryContext_OwnTowerInLane* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionQueryContext_OwnTowerInLane>();
	}
};
static_assert(alignof(UOrionQueryContext_OwnTowerInLane) == 0x000008, "Wrong alignment on UOrionQueryContext_OwnTowerInLane");
static_assert(sizeof(UOrionQueryContext_OwnTowerInLane) == 0x000028, "Wrong size on UOrionQueryContext_OwnTowerInLane");

// Class OrionGame.OrionQueryContext_ReceivedDamageLocations
// 0x0000 (0x0028 - 0x0028)
class UOrionQueryContext_ReceivedDamageLocations final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionQueryContext_ReceivedDamageLocations">();
	}
	static class UOrionQueryContext_ReceivedDamageLocations* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionQueryContext_ReceivedDamageLocations>();
	}
};
static_assert(alignof(UOrionQueryContext_ReceivedDamageLocations) == 0x000008, "Wrong alignment on UOrionQueryContext_ReceivedDamageLocations");
static_assert(sizeof(UOrionQueryContext_ReceivedDamageLocations) == 0x000028, "Wrong size on UOrionQueryContext_ReceivedDamageLocations");

// Class OrionGame.OrionQueryContext_SafeHouseLocation
// 0x0000 (0x0028 - 0x0028)
class UOrionQueryContext_SafeHouseLocation final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionQueryContext_SafeHouseLocation">();
	}
	static class UOrionQueryContext_SafeHouseLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionQueryContext_SafeHouseLocation>();
	}
};
static_assert(alignof(UOrionQueryContext_SafeHouseLocation) == 0x000008, "Wrong alignment on UOrionQueryContext_SafeHouseLocation");
static_assert(sizeof(UOrionQueryContext_SafeHouseLocation) == 0x000028, "Wrong size on UOrionQueryContext_SafeHouseLocation");

// Class OrionGame.OrionQueryContext_WeakestMinion
// 0x0000 (0x0028 - 0x0028)
class UOrionQueryContext_WeakestMinion final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionQueryContext_WeakestMinion">();
	}
	static class UOrionQueryContext_WeakestMinion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionQueryContext_WeakestMinion>();
	}
};
static_assert(alignof(UOrionQueryContext_WeakestMinion) == 0x000008, "Wrong alignment on UOrionQueryContext_WeakestMinion");
static_assert(sizeof(UOrionQueryContext_WeakestMinion) == 0x000028, "Wrong size on UOrionQueryContext_WeakestMinion");

// Class OrionGame.OrionQueryGenerator_CharacterEnemies
// 0x0040 (0x0090 - 0x0050)
class UOrionQueryGenerator_CharacterEnemies final : public UEnvQueryGenerator
{
public:
	float                                         DistanceLimit;                                     // 0x0050(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DistanceLimitMultiplier;                           // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              DistanceLimitProvider;                             // 0x0058(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         bIncludeCreeps : 1;                                // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bIncludeLaneMinions : 1;                           // 0x0088(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bIncludeHeros : 1;                                 // 0x0088(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bIncludeDamagables : 1;                            // 0x0088(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bTestAgainstLaneGoal : 1;                          // 0x0088(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bIgnoreMinionsIfEnrouteToObjective : 1;            // 0x0088(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bIgnoreHeroesNotInEngageRangeIfEnrouteToObjective : 1; // 0x0088(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bConsiderRememberedEnemies : 1;                    // 0x0088(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bLimitDistance : 1;                                // 0x0089(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_8A[0x6];                                       // 0x008A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionQueryGenerator_CharacterEnemies">();
	}
	static class UOrionQueryGenerator_CharacterEnemies* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionQueryGenerator_CharacterEnemies>();
	}
};
static_assert(alignof(UOrionQueryGenerator_CharacterEnemies) == 0x000008, "Wrong alignment on UOrionQueryGenerator_CharacterEnemies");
static_assert(sizeof(UOrionQueryGenerator_CharacterEnemies) == 0x000090, "Wrong size on UOrionQueryGenerator_CharacterEnemies");
static_assert(offsetof(UOrionQueryGenerator_CharacterEnemies, DistanceLimit) == 0x000050, "Member 'UOrionQueryGenerator_CharacterEnemies::DistanceLimit' has a wrong offset!");
static_assert(offsetof(UOrionQueryGenerator_CharacterEnemies, DistanceLimitMultiplier) == 0x000054, "Member 'UOrionQueryGenerator_CharacterEnemies::DistanceLimitMultiplier' has a wrong offset!");
static_assert(offsetof(UOrionQueryGenerator_CharacterEnemies, DistanceLimitProvider) == 0x000058, "Member 'UOrionQueryGenerator_CharacterEnemies::DistanceLimitProvider' has a wrong offset!");

// Class OrionGame.OrionQueryGenerator_Enemies
// 0x0008 (0x0058 - 0x0050)
class UOrionQueryGenerator_Enemies final : public UEnvQueryGenerator
{
public:
	bool                                          bPerceivedEnemiesOnly;                             // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxTimeSincePerceived;                             // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionQueryGenerator_Enemies">();
	}
	static class UOrionQueryGenerator_Enemies* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionQueryGenerator_Enemies>();
	}
};
static_assert(alignof(UOrionQueryGenerator_Enemies) == 0x000008, "Wrong alignment on UOrionQueryGenerator_Enemies");
static_assert(sizeof(UOrionQueryGenerator_Enemies) == 0x000058, "Wrong size on UOrionQueryGenerator_Enemies");
static_assert(offsetof(UOrionQueryGenerator_Enemies, bPerceivedEnemiesOnly) == 0x000050, "Member 'UOrionQueryGenerator_Enemies::bPerceivedEnemiesOnly' has a wrong offset!");
static_assert(offsetof(UOrionQueryGenerator_Enemies, MaxTimeSincePerceived) == 0x000054, "Member 'UOrionQueryGenerator_Enemies::MaxTimeSincePerceived' has a wrong offset!");

// Class OrionGame.OrionQueryGenerator_SelectionModeEnemies
// 0x0040 (0x0090 - 0x0050)
class UOrionQueryGenerator_SelectionModeEnemies final : public UEnvQueryGenerator
{
public:
	float                                         DistanceLimitMultiplier;                           // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIDataProviderFloatValue              DistanceLimit;                                     // 0x0058(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	EBotEnemySelectionMode                        SelectionMode;                                     // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         SelectionModeTeamMask;                             // 0x0089(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8A[0x2];                                       // 0x008A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bLimitDistance : 1;                                // 0x008C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionQueryGenerator_SelectionModeEnemies">();
	}
	static class UOrionQueryGenerator_SelectionModeEnemies* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionQueryGenerator_SelectionModeEnemies>();
	}
};
static_assert(alignof(UOrionQueryGenerator_SelectionModeEnemies) == 0x000008, "Wrong alignment on UOrionQueryGenerator_SelectionModeEnemies");
static_assert(sizeof(UOrionQueryGenerator_SelectionModeEnemies) == 0x000090, "Wrong size on UOrionQueryGenerator_SelectionModeEnemies");
static_assert(offsetof(UOrionQueryGenerator_SelectionModeEnemies, DistanceLimitMultiplier) == 0x000050, "Member 'UOrionQueryGenerator_SelectionModeEnemies::DistanceLimitMultiplier' has a wrong offset!");
static_assert(offsetof(UOrionQueryGenerator_SelectionModeEnemies, DistanceLimit) == 0x000058, "Member 'UOrionQueryGenerator_SelectionModeEnemies::DistanceLimit' has a wrong offset!");
static_assert(offsetof(UOrionQueryGenerator_SelectionModeEnemies, SelectionMode) == 0x000088, "Member 'UOrionQueryGenerator_SelectionModeEnemies::SelectionMode' has a wrong offset!");
static_assert(offsetof(UOrionQueryGenerator_SelectionModeEnemies, SelectionModeTeamMask) == 0x000089, "Member 'UOrionQueryGenerator_SelectionModeEnemies::SelectionModeTeamMask' has a wrong offset!");

// Class OrionGame.OrionQueryTest_CharacterWeight
// 0x0048 (0x0208 - 0x01C0)
class UOrionQueryTest_CharacterWeight final : public UEnvQueryTest
{
public:
	float                                         MaxScore;                                          // 0x01C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinScore;                                          // 0x01C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              Range;                                             // 0x01C8(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         InRangeScoreBump;                                  // 0x01F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AssistPerHeroMultiplier;                           // 0x01FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_200[0x8];                                      // 0x0200(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionQueryTest_CharacterWeight">();
	}
	static class UOrionQueryTest_CharacterWeight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionQueryTest_CharacterWeight>();
	}
};
static_assert(alignof(UOrionQueryTest_CharacterWeight) == 0x000008, "Wrong alignment on UOrionQueryTest_CharacterWeight");
static_assert(sizeof(UOrionQueryTest_CharacterWeight) == 0x000208, "Wrong size on UOrionQueryTest_CharacterWeight");
static_assert(offsetof(UOrionQueryTest_CharacterWeight, MaxScore) == 0x0001C0, "Member 'UOrionQueryTest_CharacterWeight::MaxScore' has a wrong offset!");
static_assert(offsetof(UOrionQueryTest_CharacterWeight, MinScore) == 0x0001C4, "Member 'UOrionQueryTest_CharacterWeight::MinScore' has a wrong offset!");
static_assert(offsetof(UOrionQueryTest_CharacterWeight, Range) == 0x0001C8, "Member 'UOrionQueryTest_CharacterWeight::Range' has a wrong offset!");
static_assert(offsetof(UOrionQueryTest_CharacterWeight, InRangeScoreBump) == 0x0001F8, "Member 'UOrionQueryTest_CharacterWeight::InRangeScoreBump' has a wrong offset!");
static_assert(offsetof(UOrionQueryTest_CharacterWeight, AssistPerHeroMultiplier) == 0x0001FC, "Member 'UOrionQueryTest_CharacterWeight::AssistPerHeroMultiplier' has a wrong offset!");

// Class OrionGame.OrionQueryTest_FlowfieldDistance
// 0x0028 (0x01E8 - 0x01C0)
class UOrionQueryTest_FlowfieldDistance final : public UEnvQueryTest
{
public:
	float                                         OnLaneWeight;                                      // 0x01C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NearLaneWeight;                                    // 0x01C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JungleModifier;                                    // 0x01C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoDataModifier;                                    // 0x01CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D0[0x10];                                     // 0x01D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UEnvQueryContext>           LaneIndicator;                                     // 0x01E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionQueryTest_FlowfieldDistance">();
	}
	static class UOrionQueryTest_FlowfieldDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionQueryTest_FlowfieldDistance>();
	}
};
static_assert(alignof(UOrionQueryTest_FlowfieldDistance) == 0x000008, "Wrong alignment on UOrionQueryTest_FlowfieldDistance");
static_assert(sizeof(UOrionQueryTest_FlowfieldDistance) == 0x0001E8, "Wrong size on UOrionQueryTest_FlowfieldDistance");
static_assert(offsetof(UOrionQueryTest_FlowfieldDistance, OnLaneWeight) == 0x0001C0, "Member 'UOrionQueryTest_FlowfieldDistance::OnLaneWeight' has a wrong offset!");
static_assert(offsetof(UOrionQueryTest_FlowfieldDistance, NearLaneWeight) == 0x0001C4, "Member 'UOrionQueryTest_FlowfieldDistance::NearLaneWeight' has a wrong offset!");
static_assert(offsetof(UOrionQueryTest_FlowfieldDistance, JungleModifier) == 0x0001C8, "Member 'UOrionQueryTest_FlowfieldDistance::JungleModifier' has a wrong offset!");
static_assert(offsetof(UOrionQueryTest_FlowfieldDistance, NoDataModifier) == 0x0001CC, "Member 'UOrionQueryTest_FlowfieldDistance::NoDataModifier' has a wrong offset!");
static_assert(offsetof(UOrionQueryTest_FlowfieldDistance, LaneIndicator) == 0x0001E0, "Member 'UOrionQueryTest_FlowfieldDistance::LaneIndicator' has a wrong offset!");

// Class OrionGame.OrionQueryTest_InfluenceMap
// 0x0010 (0x01D0 - 0x01C0)
class UOrionQueryTest_InfluenceMap final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           TeamMember;                                        // 0x01C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEQSAIInfluenceQuery                          InfluenceType;                                     // 0x01C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C9[0x7];                                      // 0x01C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionQueryTest_InfluenceMap">();
	}
	static class UOrionQueryTest_InfluenceMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionQueryTest_InfluenceMap>();
	}
};
static_assert(alignof(UOrionQueryTest_InfluenceMap) == 0x000008, "Wrong alignment on UOrionQueryTest_InfluenceMap");
static_assert(sizeof(UOrionQueryTest_InfluenceMap) == 0x0001D0, "Wrong size on UOrionQueryTest_InfluenceMap");
static_assert(offsetof(UOrionQueryTest_InfluenceMap, TeamMember) == 0x0001C0, "Member 'UOrionQueryTest_InfluenceMap::TeamMember' has a wrong offset!");
static_assert(offsetof(UOrionQueryTest_InfluenceMap, InfluenceType) == 0x0001C8, "Member 'UOrionQueryTest_InfluenceMap::InfluenceType' has a wrong offset!");

// Class OrionGame.OrionQueryTest_LoSCache
// 0x0010 (0x01D0 - 0x01C0)
class UOrionQueryTest_LoSCache final : public UEnvQueryTest
{
public:
	class UEnvQueryContext*                       Context;                                           // 0x01C0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFromItem;                                         // 0x01C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C9[0x7];                                      // 0x01C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionQueryTest_LoSCache">();
	}
	static class UOrionQueryTest_LoSCache* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionQueryTest_LoSCache>();
	}
};
static_assert(alignof(UOrionQueryTest_LoSCache) == 0x000008, "Wrong alignment on UOrionQueryTest_LoSCache");
static_assert(sizeof(UOrionQueryTest_LoSCache) == 0x0001D0, "Wrong size on UOrionQueryTest_LoSCache");
static_assert(offsetof(UOrionQueryTest_LoSCache, Context) == 0x0001C0, "Member 'UOrionQueryTest_LoSCache::Context' has a wrong offset!");
static_assert(offsetof(UOrionQueryTest_LoSCache, bFromItem) == 0x0001C8, "Member 'UOrionQueryTest_LoSCache::bFromItem' has a wrong offset!");

// Class OrionGame.OrionQuickChatMessage
// 0x0078 (0x0330 - 0x02B8)
class UOrionQuickChatMessage : public UOrionUserWidgetBase
{
public:
	uint8                                         Pad_2B8[0x58];                                     // 0x02B8(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	EOrionQuickChatMessageSlot                    MessageSlot;                                       // 0x0310(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_311[0x7];                                      // 0x0311(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionInputVisualizer*                  Input_SendMessage;                                 // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionRichText*                         RichText_Message;                                  // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnMessageSelected();
	void HandleMessageInputReceived();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionQuickChatMessage">();
	}
	static class UOrionQuickChatMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionQuickChatMessage>();
	}
};
static_assert(alignof(UOrionQuickChatMessage) == 0x000008, "Wrong alignment on UOrionQuickChatMessage");
static_assert(sizeof(UOrionQuickChatMessage) == 0x000330, "Wrong size on UOrionQuickChatMessage");
static_assert(offsetof(UOrionQuickChatMessage, MessageSlot) == 0x000310, "Member 'UOrionQuickChatMessage::MessageSlot' has a wrong offset!");
static_assert(offsetof(UOrionQuickChatMessage, Input_SendMessage) == 0x000318, "Member 'UOrionQuickChatMessage::Input_SendMessage' has a wrong offset!");
static_assert(offsetof(UOrionQuickChatMessage, RichText_Message) == 0x000320, "Member 'UOrionQuickChatMessage::RichText_Message' has a wrong offset!");

// Class OrionGame.OrionQuickChatWrapper
// 0x0058 (0x04A0 - 0x0448)
class UOrionQuickChatWrapper : public UOrionActivatableWidget
{
public:
	TArray<class UOrionQuickChatMessage*>         MessageWidgets;                                    // 0x0448(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_458[0x20];                                     // 0x0458(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionInputVisualizer*                  Input_ToggleQuickChat;                             // 0x0478(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionTextBlock*                        Text_TopicName;                                    // 0x0480(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPanelWidget*                           Panel_Messages;                                    // 0x0488(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNamedSlot*                             Slot_WrappedContent;                               // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPanelWidget*                           Panel_Header;                                      // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void HandleToggleChatOptions();
	void OnToggleChatOptions(bool bShowChatOptions);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionQuickChatWrapper">();
	}
	static class UOrionQuickChatWrapper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionQuickChatWrapper>();
	}
};
static_assert(alignof(UOrionQuickChatWrapper) == 0x000008, "Wrong alignment on UOrionQuickChatWrapper");
static_assert(sizeof(UOrionQuickChatWrapper) == 0x0004A0, "Wrong size on UOrionQuickChatWrapper");
static_assert(offsetof(UOrionQuickChatWrapper, MessageWidgets) == 0x000448, "Member 'UOrionQuickChatWrapper::MessageWidgets' has a wrong offset!");
static_assert(offsetof(UOrionQuickChatWrapper, Input_ToggleQuickChat) == 0x000478, "Member 'UOrionQuickChatWrapper::Input_ToggleQuickChat' has a wrong offset!");
static_assert(offsetof(UOrionQuickChatWrapper, Text_TopicName) == 0x000480, "Member 'UOrionQuickChatWrapper::Text_TopicName' has a wrong offset!");
static_assert(offsetof(UOrionQuickChatWrapper, Panel_Messages) == 0x000488, "Member 'UOrionQuickChatWrapper::Panel_Messages' has a wrong offset!");
static_assert(offsetof(UOrionQuickChatWrapper, Slot_WrappedContent) == 0x000490, "Member 'UOrionQuickChatWrapper::Slot_WrappedContent' has a wrong offset!");
static_assert(offsetof(UOrionQuickChatWrapper, Panel_Header) == 0x000498, "Member 'UOrionQuickChatWrapper::Panel_Header' has a wrong offset!");

// Class OrionGame.OrionRandUtilData
// 0x0008 (0x0030 - 0x0028)
class UOrionRandUtilData final : public UObject
{
public:
	class UCurveTable*                            RandomDistributionCurves;                          // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionRandUtilData">();
	}
	static class UOrionRandUtilData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionRandUtilData>();
	}
};
static_assert(alignof(UOrionRandUtilData) == 0x000008, "Wrong alignment on UOrionRandUtilData");
static_assert(sizeof(UOrionRandUtilData) == 0x000030, "Wrong size on UOrionRandUtilData");
static_assert(offsetof(UOrionRandUtilData, RandomDistributionCurves) == 0x000028, "Member 'UOrionRandUtilData::RandomDistributionCurves' has a wrong offset!");

// Class OrionGame.OrionReplayDetailsManager
// 0x0080 (0x00A8 - 0x0028)
class UOrionReplayDetailsManager final : public UObject
{
public:
	uint8                                         Pad_28[0x80];                                      // 0x0028(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionReplayDetailsManager">();
	}
	static class UOrionReplayDetailsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionReplayDetailsManager>();
	}
};
static_assert(alignof(UOrionReplayDetailsManager) == 0x000008, "Wrong alignment on UOrionReplayDetailsManager");
static_assert(sizeof(UOrionReplayDetailsManager) == 0x0000A8, "Wrong size on UOrionReplayDetailsManager");

// Class OrionGame.OrionReplaySpectator
// 0x01A0 (0x0AF0 - 0x0950)
class AOrionReplaySpectator final : public AOrionPlayerController_Base
{
public:
	uint8                                         Pad_950[0x88];                                     // 0x0950(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionReplaySpectatorCameraComponent*   CurrentViewTargetSpectatorCameraComponent;         // 0x09D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9E0[0x98];                                     // 0x09E0(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 HoverDroneClass;                                   // 0x0A78(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FWatchedActorInfo                      WatchedActorInfo;                                  // 0x0A80(0x0040)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AC0[0x8];                                      // 0x0AC0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AOrionArenaCamera*>              AvailableArenaCameras;                             // 0x0AC8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AD8[0x18];                                     // 0x0AD8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DebugSetSpectatorCameraType(const class FString& Type);
	void NotifyHeroPortraitClicked(EOrionTeam HeroTeam, int32 PlayerIndex);
	void ReplaceSpectatorPawn(class ASpectatorPawn* NewSpectatorPawn);
	void SetHUDVisibility(bool bShowHUD);
	void SetSpectatorCameraType(ESpectatorCameraType NewCameraType);
	void StartWatchingActor();
	void StopWatchingActor();
	void WatchActor(class AActor* NewActorToWatch);
	bool WatchHero(EOrionTeam Team, int32 HeroIndex);

	ESpectatorCameraType GetCurrentCameraType() const;
	class AActor* GetWatchedActor() const;
	bool IsForPlayback() const;
	bool IsShowingDebugCameraOptions() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionReplaySpectator">();
	}
	static class AOrionReplaySpectator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionReplaySpectator>();
	}
};
static_assert(alignof(AOrionReplaySpectator) == 0x000008, "Wrong alignment on AOrionReplaySpectator");
static_assert(sizeof(AOrionReplaySpectator) == 0x000AF0, "Wrong size on AOrionReplaySpectator");
static_assert(offsetof(AOrionReplaySpectator, CurrentViewTargetSpectatorCameraComponent) == 0x0009D8, "Member 'AOrionReplaySpectator::CurrentViewTargetSpectatorCameraComponent' has a wrong offset!");
static_assert(offsetof(AOrionReplaySpectator, HoverDroneClass) == 0x000A78, "Member 'AOrionReplaySpectator::HoverDroneClass' has a wrong offset!");
static_assert(offsetof(AOrionReplaySpectator, WatchedActorInfo) == 0x000A80, "Member 'AOrionReplaySpectator::WatchedActorInfo' has a wrong offset!");
static_assert(offsetof(AOrionReplaySpectator, AvailableArenaCameras) == 0x000AC8, "Member 'AOrionReplaySpectator::AvailableArenaCameras' has a wrong offset!");

// Class OrionGame.OrionReplaySpectatorPawn
// 0x0010 (0x03B8 - 0x03A8)
class AOrionReplaySpectatorPawn final : public AOrionReplaySpectatorPawnBase
{
public:
	uint8                                         Pad_3A8[0x10];                                     // 0x03A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionReplaySpectatorPawn">();
	}
	static class AOrionReplaySpectatorPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionReplaySpectatorPawn>();
	}
};
static_assert(alignof(AOrionReplaySpectatorPawn) == 0x000008, "Wrong alignment on AOrionReplaySpectatorPawn");
static_assert(sizeof(AOrionReplaySpectatorPawn) == 0x0003B8, "Wrong size on AOrionReplaySpectatorPawn");

// Class OrionGame.OrionRequireTargetDirection_Front
// 0x0000 (0x0028 - 0x0028)
class UOrionRequireTargetDirection_Front final : public UGameplayEffectCustomApplicationRequirement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionRequireTargetDirection_Front">();
	}
	static class UOrionRequireTargetDirection_Front* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionRequireTargetDirection_Front>();
	}
};
static_assert(alignof(UOrionRequireTargetDirection_Front) == 0x000008, "Wrong alignment on UOrionRequireTargetDirection_Front");
static_assert(sizeof(UOrionRequireTargetDirection_Front) == 0x000028, "Wrong size on UOrionRequireTargetDirection_Front");

// Class OrionGame.OrionRequireTargetDirection_Back
// 0x0000 (0x0028 - 0x0028)
class UOrionRequireTargetDirection_Back final : public UGameplayEffectCustomApplicationRequirement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionRequireTargetDirection_Back">();
	}
	static class UOrionRequireTargetDirection_Back* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionRequireTargetDirection_Back>();
	}
};
static_assert(alignof(UOrionRequireTargetDirection_Back) == 0x000008, "Wrong alignment on UOrionRequireTargetDirection_Back");
static_assert(sizeof(UOrionRequireTargetDirection_Back) == 0x000028, "Wrong size on UOrionRequireTargetDirection_Back");

// Class OrionGame.OrionRewardDisplayData
// 0x06F0 (0x0720 - 0x0030)
class UOrionRewardDisplayData final : public UDataAsset
{
public:
	class UTexture2D*                             DefaultRewardIcon;                                 // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            BoostIcon;                                         // 0x0038(0x0078)(Edit, NativeAccessSpecifierPublic)
	TMap<class FString, class FText>              RewardSourceTextByNameString;                      // 0x00B0(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UOrionMcpItemDefinition*                MtxCurrencyItemDefinition;                         // 0x0100(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionRewardTypeInfo                   Currencies[0x5];                                   // 0x0108(0x0068)(Edit, NativeAccessSpecifierPublic)
	struct FLinearColor                           RewardQualityColors[0x5];                          // 0x0310(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   LevelTypeNames;                                    // 0x0360(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FLinearColor                           BaseXPColors;                                      // 0x0378(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DeltaXPColors;                                     // 0x0388(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BoostXPColors;                                     // 0x0398(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           FakeBoostXPColors;                                 // 0x03A8(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionMcpTokenItemDefinition*           DailyLoginToken;                                   // 0x03B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOrionRarityInfo                       Rarities[0x5];                                     // 0x03C0(0x0028)(Edit, NativeAccessSpecifierPublic)
	class UOrionMcpTokenItemDefinition*           StarToken;                                         // 0x0488(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UObject>                 VariationSwatchAsset;                              // 0x0490(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionMcpItemDefinition*                ReachRewards[0x4];                                 // 0x04B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UOrionMcpCardPackItemDefinition*> ChestOrder;                                        // 0x04D8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UOrionMcpCardPackItemDefinition*        LootCrate;                                         // 0x04E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionMcpTokenItemDefinition*           LootCrateKey;                                      // 0x04F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOrionMcpTokenItemDefinition*           LootCrateGoldenKey;                                // 0x04F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOrionBannerSetDefinition>      BannerSetDefinitions;                              // 0x0500(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         RewardTypeSortBias[0x1E];                          // 0x0510(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOrionRewardSourceInfo>         RewardSources;                                     // 0x0588(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FOrionRewardSourceInfo                 DefaultRewardSource;                               // 0x0598(0x0058)(Edit, NativeAccessSpecifierPrivate)
	TMap<class FString, struct FExplicitLootTierInfo> ExplicitLootTierContentsByName;                    // 0x05F0(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FOrionItemRewardInfo>           ItemRewardTypes;                                   // 0x0640(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_650[0x50];                                     // 0x0650(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOrionLootTierRewardInfo>       LootRewardTypes;                                   // 0x06A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6B0[0x50];                                     // 0x06B0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOrionCoinLootCrateRewards>     LootCrateCoinRewards;                              // 0x0700(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_710[0x10];                                     // 0x0710(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionRewardDisplayData">();
	}
	static class UOrionRewardDisplayData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionRewardDisplayData>();
	}
};
static_assert(alignof(UOrionRewardDisplayData) == 0x000008, "Wrong alignment on UOrionRewardDisplayData");
static_assert(sizeof(UOrionRewardDisplayData) == 0x000720, "Wrong size on UOrionRewardDisplayData");
static_assert(offsetof(UOrionRewardDisplayData, DefaultRewardIcon) == 0x000030, "Member 'UOrionRewardDisplayData::DefaultRewardIcon' has a wrong offset!");
static_assert(offsetof(UOrionRewardDisplayData, BoostIcon) == 0x000038, "Member 'UOrionRewardDisplayData::BoostIcon' has a wrong offset!");
static_assert(offsetof(UOrionRewardDisplayData, RewardSourceTextByNameString) == 0x0000B0, "Member 'UOrionRewardDisplayData::RewardSourceTextByNameString' has a wrong offset!");
static_assert(offsetof(UOrionRewardDisplayData, MtxCurrencyItemDefinition) == 0x000100, "Member 'UOrionRewardDisplayData::MtxCurrencyItemDefinition' has a wrong offset!");
static_assert(offsetof(UOrionRewardDisplayData, Currencies) == 0x000108, "Member 'UOrionRewardDisplayData::Currencies' has a wrong offset!");
static_assert(offsetof(UOrionRewardDisplayData, RewardQualityColors) == 0x000310, "Member 'UOrionRewardDisplayData::RewardQualityColors' has a wrong offset!");
static_assert(offsetof(UOrionRewardDisplayData, LevelTypeNames) == 0x000360, "Member 'UOrionRewardDisplayData::LevelTypeNames' has a wrong offset!");
static_assert(offsetof(UOrionRewardDisplayData, BaseXPColors) == 0x000378, "Member 'UOrionRewardDisplayData::BaseXPColors' has a wrong offset!");
static_assert(offsetof(UOrionRewardDisplayData, DeltaXPColors) == 0x000388, "Member 'UOrionRewardDisplayData::DeltaXPColors' has a wrong offset!");
static_assert(offsetof(UOrionRewardDisplayData, BoostXPColors) == 0x000398, "Member 'UOrionRewardDisplayData::BoostXPColors' has a wrong offset!");
static_assert(offsetof(UOrionRewardDisplayData, FakeBoostXPColors) == 0x0003A8, "Member 'UOrionRewardDisplayData::FakeBoostXPColors' has a wrong offset!");
static_assert(offsetof(UOrionRewardDisplayData, DailyLoginToken) == 0x0003B8, "Member 'UOrionRewardDisplayData::DailyLoginToken' has a wrong offset!");
static_assert(offsetof(UOrionRewardDisplayData, Rarities) == 0x0003C0, "Member 'UOrionRewardDisplayData::Rarities' has a wrong offset!");
static_assert(offsetof(UOrionRewardDisplayData, StarToken) == 0x000488, "Member 'UOrionRewardDisplayData::StarToken' has a wrong offset!");
static_assert(offsetof(UOrionRewardDisplayData, VariationSwatchAsset) == 0x000490, "Member 'UOrionRewardDisplayData::VariationSwatchAsset' has a wrong offset!");
static_assert(offsetof(UOrionRewardDisplayData, ReachRewards) == 0x0004B8, "Member 'UOrionRewardDisplayData::ReachRewards' has a wrong offset!");
static_assert(offsetof(UOrionRewardDisplayData, ChestOrder) == 0x0004D8, "Member 'UOrionRewardDisplayData::ChestOrder' has a wrong offset!");
static_assert(offsetof(UOrionRewardDisplayData, LootCrate) == 0x0004E8, "Member 'UOrionRewardDisplayData::LootCrate' has a wrong offset!");
static_assert(offsetof(UOrionRewardDisplayData, LootCrateKey) == 0x0004F0, "Member 'UOrionRewardDisplayData::LootCrateKey' has a wrong offset!");
static_assert(offsetof(UOrionRewardDisplayData, LootCrateGoldenKey) == 0x0004F8, "Member 'UOrionRewardDisplayData::LootCrateGoldenKey' has a wrong offset!");
static_assert(offsetof(UOrionRewardDisplayData, BannerSetDefinitions) == 0x000500, "Member 'UOrionRewardDisplayData::BannerSetDefinitions' has a wrong offset!");
static_assert(offsetof(UOrionRewardDisplayData, RewardTypeSortBias) == 0x000510, "Member 'UOrionRewardDisplayData::RewardTypeSortBias' has a wrong offset!");
static_assert(offsetof(UOrionRewardDisplayData, RewardSources) == 0x000588, "Member 'UOrionRewardDisplayData::RewardSources' has a wrong offset!");
static_assert(offsetof(UOrionRewardDisplayData, DefaultRewardSource) == 0x000598, "Member 'UOrionRewardDisplayData::DefaultRewardSource' has a wrong offset!");
static_assert(offsetof(UOrionRewardDisplayData, ExplicitLootTierContentsByName) == 0x0005F0, "Member 'UOrionRewardDisplayData::ExplicitLootTierContentsByName' has a wrong offset!");
static_assert(offsetof(UOrionRewardDisplayData, ItemRewardTypes) == 0x000640, "Member 'UOrionRewardDisplayData::ItemRewardTypes' has a wrong offset!");
static_assert(offsetof(UOrionRewardDisplayData, LootRewardTypes) == 0x0006A0, "Member 'UOrionRewardDisplayData::LootRewardTypes' has a wrong offset!");
static_assert(offsetof(UOrionRewardDisplayData, LootCrateCoinRewards) == 0x000700, "Member 'UOrionRewardDisplayData::LootCrateCoinRewards' has a wrong offset!");

// Class OrionGame.OrionRichText
// 0x0058 (0x0178 - 0x0120)
class UOrionRichText final : public UTextLayoutWidget
{
public:
	class FText                                   Text;                                              // 0x0120(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FMargin                                TextMargin;                                        // 0x0138(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	ERichTextInlineIconDisplayMode                InlineIconDisplayMode;                             // 0x0148(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UOrionTextStyle>            NormalTextStyle;                                   // 0x0150(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrionWidgetStyleSize                         StyleSize;                                         // 0x0158(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrionTextColor                               ColorType;                                         // 0x0159(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrionTextColor                               InlineIconColorType;                               // 0x015A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15B[0x1];                                      // 0x015B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDesiredWidth;                                   // 0x015C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisplayAllCaps;                                   // 0x0160(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableDropShadow;                                 // 0x0161(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWrapWithInvalidationPanel;                        // 0x0162(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_163[0x15];                                     // 0x0163(0x0015)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EOrionTextColor GetColorType();
	EOrionTextColor GetInlineIconColorType();
	EOrionWidgetStyleSize GetStyleSize();
	void Refresh();
	void SetColorType(EOrionTextColor Color);
	void SetInlineIconDisplayMode(ERichTextInlineIconDisplayMode DisplayMode);
	void SetSize(EOrionWidgetStyleSize Size);
	void SetText(const class FText& InText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionRichText">();
	}
	static class UOrionRichText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionRichText>();
	}
};
static_assert(alignof(UOrionRichText) == 0x000008, "Wrong alignment on UOrionRichText");
static_assert(sizeof(UOrionRichText) == 0x000178, "Wrong size on UOrionRichText");
static_assert(offsetof(UOrionRichText, Text) == 0x000120, "Member 'UOrionRichText::Text' has a wrong offset!");
static_assert(offsetof(UOrionRichText, TextMargin) == 0x000138, "Member 'UOrionRichText::TextMargin' has a wrong offset!");
static_assert(offsetof(UOrionRichText, InlineIconDisplayMode) == 0x000148, "Member 'UOrionRichText::InlineIconDisplayMode' has a wrong offset!");
static_assert(offsetof(UOrionRichText, NormalTextStyle) == 0x000150, "Member 'UOrionRichText::NormalTextStyle' has a wrong offset!");
static_assert(offsetof(UOrionRichText, StyleSize) == 0x000158, "Member 'UOrionRichText::StyleSize' has a wrong offset!");
static_assert(offsetof(UOrionRichText, ColorType) == 0x000159, "Member 'UOrionRichText::ColorType' has a wrong offset!");
static_assert(offsetof(UOrionRichText, InlineIconColorType) == 0x00015A, "Member 'UOrionRichText::InlineIconColorType' has a wrong offset!");
static_assert(offsetof(UOrionRichText, MinDesiredWidth) == 0x00015C, "Member 'UOrionRichText::MinDesiredWidth' has a wrong offset!");
static_assert(offsetof(UOrionRichText, bDisplayAllCaps) == 0x000160, "Member 'UOrionRichText::bDisplayAllCaps' has a wrong offset!");
static_assert(offsetof(UOrionRichText, bEnableDropShadow) == 0x000161, "Member 'UOrionRichText::bEnableDropShadow' has a wrong offset!");
static_assert(offsetof(UOrionRichText, bWrapWithInvalidationPanel) == 0x000162, "Member 'UOrionRichText::bWrapWithInvalidationPanel' has a wrong offset!");

// Class OrionGame.OrionRichTextStyleData
// 0x0328 (0x0358 - 0x0030)
class UOrionRichTextStyleData final : public UDataAsset
{
public:
	TMap<class FString, TSubclassOf<class UOrionRichTextInlineWidget>> InlineWidgetsByTag;                                // 0x0030(0x0050)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class FString                                 StyleSizeSubtags[0x3];                             // 0x0080(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ColorTypeSubtags[0x4];                             // 0x00B0(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 KeywordMarkupTag;                                  // 0x00F0(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UOrionTextStyle>            KeywordStyle;                                      // 0x0100(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InlineIconSizes[0x3];                              // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InlineIconBaselines[0x3];                          // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StatusEffectMarkupTag;                             // 0x0120(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AttributeMarkupTag;                                // 0x0130(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UOrionTextStyle>            AttributeValueTextStyle;                           // 0x0140(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AttributeValueMarkupTag;                           // 0x0148(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AttributeValueSummandSubTags[0x3];                 // 0x0158(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           AttributeSummandColors[0x3];                       // 0x0188(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CurrencyMarkupTag;                                 // 0x01B8(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CurrencyTypeIDs[0x5];                              // 0x01C8(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   CurrencyNames[0x5];                                // 0x0218(0x0018)(Edit, NativeAccessSpecifierPublic)
	class UTexture2D*                             CurrencyIcons[0x5];                                // 0x0290(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AbilityMarkupTag;                                  // 0x02B8(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InputMarkupTag;                                    // 0x02C8(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InputAxisMarkupTag;                                // 0x02D8(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SpecificKeyMarkupSubtag;                           // 0x02E8(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOrionGenericInlineIcon>        AdditionalInlineIcons;                             // 0x02F8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FString, struct FOrionKeywordIcon> IconsByKeyword;                                    // 0x0308(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionRichTextStyleData">();
	}
	static class UOrionRichTextStyleData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionRichTextStyleData>();
	}
};
static_assert(alignof(UOrionRichTextStyleData) == 0x000008, "Wrong alignment on UOrionRichTextStyleData");
static_assert(sizeof(UOrionRichTextStyleData) == 0x000358, "Wrong size on UOrionRichTextStyleData");
static_assert(offsetof(UOrionRichTextStyleData, InlineWidgetsByTag) == 0x000030, "Member 'UOrionRichTextStyleData::InlineWidgetsByTag' has a wrong offset!");
static_assert(offsetof(UOrionRichTextStyleData, StyleSizeSubtags) == 0x000080, "Member 'UOrionRichTextStyleData::StyleSizeSubtags' has a wrong offset!");
static_assert(offsetof(UOrionRichTextStyleData, ColorTypeSubtags) == 0x0000B0, "Member 'UOrionRichTextStyleData::ColorTypeSubtags' has a wrong offset!");
static_assert(offsetof(UOrionRichTextStyleData, KeywordMarkupTag) == 0x0000F0, "Member 'UOrionRichTextStyleData::KeywordMarkupTag' has a wrong offset!");
static_assert(offsetof(UOrionRichTextStyleData, KeywordStyle) == 0x000100, "Member 'UOrionRichTextStyleData::KeywordStyle' has a wrong offset!");
static_assert(offsetof(UOrionRichTextStyleData, InlineIconSizes) == 0x000108, "Member 'UOrionRichTextStyleData::InlineIconSizes' has a wrong offset!");
static_assert(offsetof(UOrionRichTextStyleData, InlineIconBaselines) == 0x000114, "Member 'UOrionRichTextStyleData::InlineIconBaselines' has a wrong offset!");
static_assert(offsetof(UOrionRichTextStyleData, StatusEffectMarkupTag) == 0x000120, "Member 'UOrionRichTextStyleData::StatusEffectMarkupTag' has a wrong offset!");
static_assert(offsetof(UOrionRichTextStyleData, AttributeMarkupTag) == 0x000130, "Member 'UOrionRichTextStyleData::AttributeMarkupTag' has a wrong offset!");
static_assert(offsetof(UOrionRichTextStyleData, AttributeValueTextStyle) == 0x000140, "Member 'UOrionRichTextStyleData::AttributeValueTextStyle' has a wrong offset!");
static_assert(offsetof(UOrionRichTextStyleData, AttributeValueMarkupTag) == 0x000148, "Member 'UOrionRichTextStyleData::AttributeValueMarkupTag' has a wrong offset!");
static_assert(offsetof(UOrionRichTextStyleData, AttributeValueSummandSubTags) == 0x000158, "Member 'UOrionRichTextStyleData::AttributeValueSummandSubTags' has a wrong offset!");
static_assert(offsetof(UOrionRichTextStyleData, AttributeSummandColors) == 0x000188, "Member 'UOrionRichTextStyleData::AttributeSummandColors' has a wrong offset!");
static_assert(offsetof(UOrionRichTextStyleData, CurrencyMarkupTag) == 0x0001B8, "Member 'UOrionRichTextStyleData::CurrencyMarkupTag' has a wrong offset!");
static_assert(offsetof(UOrionRichTextStyleData, CurrencyTypeIDs) == 0x0001C8, "Member 'UOrionRichTextStyleData::CurrencyTypeIDs' has a wrong offset!");
static_assert(offsetof(UOrionRichTextStyleData, CurrencyNames) == 0x000218, "Member 'UOrionRichTextStyleData::CurrencyNames' has a wrong offset!");
static_assert(offsetof(UOrionRichTextStyleData, CurrencyIcons) == 0x000290, "Member 'UOrionRichTextStyleData::CurrencyIcons' has a wrong offset!");
static_assert(offsetof(UOrionRichTextStyleData, AbilityMarkupTag) == 0x0002B8, "Member 'UOrionRichTextStyleData::AbilityMarkupTag' has a wrong offset!");
static_assert(offsetof(UOrionRichTextStyleData, InputMarkupTag) == 0x0002C8, "Member 'UOrionRichTextStyleData::InputMarkupTag' has a wrong offset!");
static_assert(offsetof(UOrionRichTextStyleData, InputAxisMarkupTag) == 0x0002D8, "Member 'UOrionRichTextStyleData::InputAxisMarkupTag' has a wrong offset!");
static_assert(offsetof(UOrionRichTextStyleData, SpecificKeyMarkupSubtag) == 0x0002E8, "Member 'UOrionRichTextStyleData::SpecificKeyMarkupSubtag' has a wrong offset!");
static_assert(offsetof(UOrionRichTextStyleData, AdditionalInlineIcons) == 0x0002F8, "Member 'UOrionRichTextStyleData::AdditionalInlineIcons' has a wrong offset!");
static_assert(offsetof(UOrionRichTextStyleData, IconsByKeyword) == 0x000308, "Member 'UOrionRichTextStyleData::IconsByKeyword' has a wrong offset!");

// Class OrionGame.OrionRichTextHelperLibrary
// 0x0000 (0x0028 - 0x0028)
class UOrionRichTextHelperLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ConvertToKeyword(class FText& Text);
	static void ConvertToKeywordSpecific(class FText& Text, EOrionWidgetStyleSize Size, EOrionTextColor Color);
	static class FString FormatAsAttributeValue(const class FString& Value, EOrionAttributeSummand SummandType);
	static class FText FormatAsCurrency(EOrionCurrencyType Currency, const class FText& DisplayValue, EOrionWidgetStyleSize Size);
	static class FString FormatAsKeyword(const class FString& Text);
	static class FString FormatAsKeywordSpecific(const class FString& Text, EOrionWidgetStyleSize Size, EOrionTextColor Color);
	static class FString GetAttributeAbbreviationMarkup(const class FString& Abbreviation);
	static class FString GetAttributeMarkup(const struct FOrionAttributeViewItem& AttributeItem);
	static void GetAttributeValueTag(EOrionAttributeSummand SummandType, class FString* ValueTag);
	static class FString GetCurrencyIconTag(EOrionCurrencyType Currency);
	static class FString GetCurrencyIconTagSpecific(EOrionCurrencyType Currency, EOrionWidgetStyleSize Size);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionRichTextHelperLibrary">();
	}
	static class UOrionRichTextHelperLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionRichTextHelperLibrary>();
	}
};
static_assert(alignof(UOrionRichTextHelperLibrary) == 0x000008, "Wrong alignment on UOrionRichTextHelperLibrary");
static_assert(sizeof(UOrionRichTextHelperLibrary) == 0x000028, "Wrong size on UOrionRichTextHelperLibrary");

// Class OrionGame.OrionRigs
// 0x0198 (0x0B50 - 0x09B8)
class AOrionRigs final : public AOrionDamageableObjective_Base
{
public:
	uint8                                         Pad_9B8[0x78];                                     // 0x09B8(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrionWell_Base*                        AttachedToWell;                                    // 0x0A30(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AOrionPlayerState_Game>  PlayerThatPlacedRig;                               // 0x0A38(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            HealGameplayEffectData;                            // 0x0A40(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayEffectSpecHandle              HealingEffectSpecToApply;                          // 0x0A48(0x0018)(Protected, NativeAccessSpecifierProtected)
	class FName                                   MagnitudeName;                                     // 0x0A60(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FScalableFloat                         StartingHealthPercent;                             // 0x0A68(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bFinishedBuilding;                                 // 0x0A90(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A91[0x3];                                      // 0x0A91(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastCollectionGameTime;                            // 0x0A94(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MatchTimePlaced;                                   // 0x0A98(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A9C[0x4];                                      // 0x0A9C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionRigCues                          RigGameplayCues;                                   // 0x0AA0(0x0018)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  DynamicSourceTags;                                 // 0x0AB8(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  DynamicAssetTags;                                  // 0x0AD8(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	EOrionPickUpSpeed                             CoinLaunchSpeed;                                   // 0x0AF8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AF9[0x3];                                      // 0x0AF9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinCoinsToSpawn;                                   // 0x0AFC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            BuildExtrationGE;                                  // 0x0B00(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UGameplayEffect>>    FinishBuildingGE;                                  // 0x0B08(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_B18[0x8];                                      // 0x0B18(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GeyserBounsRowName;                                // 0x0B20(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveTable*                            GeyserBounsCurveTable;                             // 0x0B28(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOrionRigSet*                           RigSet;                                            // 0x0B30(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B38[0x18];                                     // 0x0B38(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AOrionWell_Base* GetAttchedToWell();
	float GetBoostedRigScaler();
	struct FVector GetCoinSpawnLocation();
	int32 GetMatchTimePlaced();
	class AOrionPlayerState_Game* GetPlayerThatPlacedRig();
	float GetWellResourcePercentLeft();
	void OnAttachedToWell(class AOrionWell_Base* InWell);
	void OnRep_AttachedToWell(const class AOrionWell_Base* OldAttachedToWell);
	void OnSpawnCoins(float ResourceAmount, class AActor* Target);
	void PlayerCollectCoins(class AOrionCharHero* CollectingPlayer);
	void SetPlayerThatPlacedThisRig(class AOrionPlayerState_Game* InPlayer);
	void WellTagCallback_VisibleToEnemy(const struct FGameplayTag& Tag, int32 NewCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionRigs">();
	}
	static class AOrionRigs* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionRigs>();
	}
};
static_assert(alignof(AOrionRigs) == 0x000008, "Wrong alignment on AOrionRigs");
static_assert(sizeof(AOrionRigs) == 0x000B50, "Wrong size on AOrionRigs");
static_assert(offsetof(AOrionRigs, AttachedToWell) == 0x000A30, "Member 'AOrionRigs::AttachedToWell' has a wrong offset!");
static_assert(offsetof(AOrionRigs, PlayerThatPlacedRig) == 0x000A38, "Member 'AOrionRigs::PlayerThatPlacedRig' has a wrong offset!");
static_assert(offsetof(AOrionRigs, HealGameplayEffectData) == 0x000A40, "Member 'AOrionRigs::HealGameplayEffectData' has a wrong offset!");
static_assert(offsetof(AOrionRigs, HealingEffectSpecToApply) == 0x000A48, "Member 'AOrionRigs::HealingEffectSpecToApply' has a wrong offset!");
static_assert(offsetof(AOrionRigs, MagnitudeName) == 0x000A60, "Member 'AOrionRigs::MagnitudeName' has a wrong offset!");
static_assert(offsetof(AOrionRigs, StartingHealthPercent) == 0x000A68, "Member 'AOrionRigs::StartingHealthPercent' has a wrong offset!");
static_assert(offsetof(AOrionRigs, bFinishedBuilding) == 0x000A90, "Member 'AOrionRigs::bFinishedBuilding' has a wrong offset!");
static_assert(offsetof(AOrionRigs, LastCollectionGameTime) == 0x000A94, "Member 'AOrionRigs::LastCollectionGameTime' has a wrong offset!");
static_assert(offsetof(AOrionRigs, MatchTimePlaced) == 0x000A98, "Member 'AOrionRigs::MatchTimePlaced' has a wrong offset!");
static_assert(offsetof(AOrionRigs, RigGameplayCues) == 0x000AA0, "Member 'AOrionRigs::RigGameplayCues' has a wrong offset!");
static_assert(offsetof(AOrionRigs, DynamicSourceTags) == 0x000AB8, "Member 'AOrionRigs::DynamicSourceTags' has a wrong offset!");
static_assert(offsetof(AOrionRigs, DynamicAssetTags) == 0x000AD8, "Member 'AOrionRigs::DynamicAssetTags' has a wrong offset!");
static_assert(offsetof(AOrionRigs, CoinLaunchSpeed) == 0x000AF8, "Member 'AOrionRigs::CoinLaunchSpeed' has a wrong offset!");
static_assert(offsetof(AOrionRigs, MinCoinsToSpawn) == 0x000AFC, "Member 'AOrionRigs::MinCoinsToSpawn' has a wrong offset!");
static_assert(offsetof(AOrionRigs, BuildExtrationGE) == 0x000B00, "Member 'AOrionRigs::BuildExtrationGE' has a wrong offset!");
static_assert(offsetof(AOrionRigs, FinishBuildingGE) == 0x000B08, "Member 'AOrionRigs::FinishBuildingGE' has a wrong offset!");
static_assert(offsetof(AOrionRigs, GeyserBounsRowName) == 0x000B20, "Member 'AOrionRigs::GeyserBounsRowName' has a wrong offset!");
static_assert(offsetof(AOrionRigs, GeyserBounsCurveTable) == 0x000B28, "Member 'AOrionRigs::GeyserBounsCurveTable' has a wrong offset!");
static_assert(offsetof(AOrionRigs, RigSet) == 0x000B30, "Member 'AOrionRigs::RigSet' has a wrong offset!");

// Class OrionGame.OrionRotationalContentHandlerInterface
// 0x0000 (0x0028 - 0x0028)
class IOrionRotationalContentHandlerInterface final : public IInterface
{
public:
	void HandleRotationalContent(const struct FGameplayTagContainer& TagsToHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionRotationalContentHandlerInterface">();
	}
	static class IOrionRotationalContentHandlerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOrionRotationalContentHandlerInterface>();
	}
};
static_assert(alignof(IOrionRotationalContentHandlerInterface) == 0x000008, "Wrong alignment on IOrionRotationalContentHandlerInterface");
static_assert(sizeof(IOrionRotationalContentHandlerInterface) == 0x000028, "Wrong size on IOrionRotationalContentHandlerInterface");

// Class OrionGame.OrionRotationalContentManager
// 0x0060 (0x0088 - 0x0028)
class UOrionRotationalContentManager final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasInitializedTags;                               // 0x0040(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  RotationalGameplayTags;                            // 0x0048(0x0020)(Transient, NativeAccessSpecifierPrivate)
	class FString                                 DebugTagString;                                    // 0x0068(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x10];                                      // 0x0078(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void RegisterHandler(class UObject* Handler, class UOrionRotationalContentManager* SpecificManager);
	static void UnRegisterHandler(class UObject* Handler, class UOrionRotationalContentManager* SpecificManager);

	void OnMCPTagsUpdated();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionRotationalContentManager">();
	}
	static class UOrionRotationalContentManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionRotationalContentManager>();
	}
};
static_assert(alignof(UOrionRotationalContentManager) == 0x000008, "Wrong alignment on UOrionRotationalContentManager");
static_assert(sizeof(UOrionRotationalContentManager) == 0x000088, "Wrong size on UOrionRotationalContentManager");
static_assert(offsetof(UOrionRotationalContentManager, bHasInitializedTags) == 0x000040, "Member 'UOrionRotationalContentManager::bHasInitializedTags' has a wrong offset!");
static_assert(offsetof(UOrionRotationalContentManager, RotationalGameplayTags) == 0x000048, "Member 'UOrionRotationalContentManager::RotationalGameplayTags' has a wrong offset!");
static_assert(offsetof(UOrionRotationalContentManager, DebugTagString) == 0x000068, "Member 'UOrionRotationalContentManager::DebugTagString' has a wrong offset!");

// Class OrionGame.OrionRotationalContentPreloadData
// 0x0010 (0x0040 - 0x0030)
class UOrionRotationalContentPreloadData final : public UDataAsset
{
public:
	TArray<struct FOrionGameplayTagContentMapping> RotationalContentPreloadTagMappings;               // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionRotationalContentPreloadData">();
	}
	static class UOrionRotationalContentPreloadData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionRotationalContentPreloadData>();
	}
};
static_assert(alignof(UOrionRotationalContentPreloadData) == 0x000008, "Wrong alignment on UOrionRotationalContentPreloadData");
static_assert(sizeof(UOrionRotationalContentPreloadData) == 0x000040, "Wrong size on UOrionRotationalContentPreloadData");
static_assert(offsetof(UOrionRotationalContentPreloadData, RotationalContentPreloadTagMappings) == 0x000030, "Member 'UOrionRotationalContentPreloadData::RotationalContentPreloadTagMappings' has a wrong offset!");

// Class OrionGame.OrionRotationalEventDisplayData
// 0x0050 (0x0080 - 0x0030)
class UOrionRotationalEventDisplayData final : public UDataAsset
{
public:
	TMap<class FString, class UStringTable*>      EventStringTables;                                 // 0x0030(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionRotationalEventDisplayData">();
	}
	static class UOrionRotationalEventDisplayData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionRotationalEventDisplayData>();
	}
};
static_assert(alignof(UOrionRotationalEventDisplayData) == 0x000008, "Wrong alignment on UOrionRotationalEventDisplayData");
static_assert(sizeof(UOrionRotationalEventDisplayData) == 0x000080, "Wrong size on UOrionRotationalEventDisplayData");
static_assert(offsetof(UOrionRotationalEventDisplayData, EventStringTables) == 0x000030, "Member 'UOrionRotationalEventDisplayData::EventStringTables' has a wrong offset!");

// Class OrionGame.OrionRuntimeOptions
// 0x01E0 (0x0208 - 0x0028)
class UOrionRuntimeOptions final : public UObject
{
public:
	UMulticastDelegateProperty_                   OnHotfixApplied;                                   // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          DisableImageViewer;                                // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Version;                                           // 0x003C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableReplayVideoRecording;                       // 0x0040(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisallowMTXStorePurchaesPC;                       // 0x0041(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisallowMTXStorePurchaesPS4;                      // 0x0042(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisallowCoinPurchases;                            // 0x0043(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPSPlusFreeAccess;                                 // 0x0044(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFreeAccess;                                       // 0x0045(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableReplays;                                    // 0x0046(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowSoloRewards;                                 // 0x0047(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableFriendCodes;                                // 0x0048(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableSoloVsAIReplays;                           // 0x0049(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableCoopVsAIReplays;                           // 0x004A(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableTutorialReplays;                            // 0x004B(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowUsingShaderModel4;                           // 0x004C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequireGamePlayedForDeckBuilderAccess;            // 0x004D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowEarlyAccessWarning;                           // 0x004E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisablePlayerRatingButton;                        // 0x004F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisablePostGameContinueDelay;                     // 0x0050(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableGemRefining;                                // 0x0051(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableFeaturedTab;                               // 0x0052(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableEmoteTab;                                  // 0x0053(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableBundleTab;                                 // 0x0054(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableCoinTab;                                   // 0x0055(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableSkinVariations;                            // 0x0056(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableCardOnboardingFlowState;                   // 0x0057(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuperMinionBonusOnInhibDeath;                     // 0x0058(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableBanMessagesInPostGame;                     // 0x0059(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDeathcamPC;                                 // 0x005A(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDeathcamPS4;                                // 0x005B(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableAllyXPHeroPortrait;                        // 0x005C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ShowNewUserVideoPercentPC;                         // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShowNewUserVideoPercentPS4;                        // 0x0064(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowVideoSkips;                                  // 0x0068(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowNewDawnVideo;                                 // 0x0069(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x2];                                       // 0x006A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinGamesForSovereignUpdate;                        // 0x006C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxGamesForDeckBuilderOnboarding;                  // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SovereignLearnMoreURL;                             // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowNewDawnPlayBanner;                            // 0x0088(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowLegacyPlayBanner;                             // 0x0089(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowPlayAnnouncementBanner;                       // 0x008A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8B[0x5];                                       // 0x008B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlayAnnouncementURL;                               // 0x0090(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowLegacyDecks;                                 // 0x00A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowMasteryOnboardUIScreens;                      // 0x00A1(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A2[0x2];                                       // 0x00A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UIAnalyticsLevel;                                  // 0x00A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableLearningTips;                               // 0x00A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableToxicityTips;                               // 0x00A9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableNewUserTips;                                // 0x00AA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AB[0x1];                                       // 0x00AB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NewPlayerPvPWarningGameCount;                      // 0x00AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewPlayerPvPWarningWinCount;                       // 0x00B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewPlayerCoopWarningGameCount;                     // 0x00B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerRatingCalloutPvPGameCount;                   // 0x00B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerRatingCalloutCoopLevel;                      // 0x00BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerRatingCalloutChance;                         // 0x00C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableLootCrateOpening;                           // 0x00C4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoJoinTutorial;                                 // 0x00C5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C6[0x2];                                       // 0x00C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AutoJoinTutorialLevelCap;                          // 0x00C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AutoJoinTutorialGamesPlayedCap;                    // 0x00CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowHDROnPS4;                                    // 0x00D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDailyLoginBonus;                            // 0x00D1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCMSPopup;                                   // 0x00D2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCommunityTab;                               // 0x00D3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableVaultTokenPurchases;                        // 0x00D4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClientCommitAlwaysPass;                           // 0x00D5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowM42PVPLock;                                  // 0x00D6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D7[0x1];                                       // 0x00D7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NonPVPGamesToDisableM42Lock;                       // 0x00D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeckBuilderSaveOccuranceInSeconds;                 // 0x00DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowArcadeMode;                                  // 0x00E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bQueueSimulatedProxyOnRepMovement;                 // 0x00E1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowSpecateOptionInCustomMatchWidget;             // 0x00E2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E3[0x1];                                       // 0x00E3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DraftPreloadDelaySeconds;                          // 0x00E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowSandbox;                                      // 0x00E8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x3];                                       // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KRMinutesBeforeMinorShutdownToDisablePlayButton;   // 0x00EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ActiveEventNames;                                  // 0x00F0(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	float                                         MemoryHeartbeatPeriod;                             // 0x0100(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ObjectUsageReportPeriod;                           // 0x0104(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ObjectUsageClassList;                              // 0x0108(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	int32                                         CreateMinionsVersion;                              // 0x0118(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMinionLastHitVisualizationMode               MinionLastHitVisualization;                        // 0x011C(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11D[0x1];                                      // 0x011D(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EOrionFirstGameMatchmakingType                FirstGameMatchmakingType;                          // 0x011E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11F[0x1];                                      // 0x011F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableMMS;                                        // 0x0120(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         EnabledMMSRegions;                                 // 0x0128(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TArray<class FString>                         DefaultMMSBackends;                                // 0x0138(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	class FString                                 MMSTicketURLClient;                                // 0x0148(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MMSTicketURLServer;                                // 0x0158(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MMSVersionCompatability;                           // 0x0168(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MMSPingInterval;                                   // 0x0178(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableCustomMatchmakingKey;                      // 0x017C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableSBMatchmaking;                             // 0x017D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowMatchmakingTimeWarning;                       // 0x017E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowMatchmakingPlayerPips;                        // 0x017F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReadyCheckTimeoutValue;                            // 0x0180(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UseNewPlayerHeroBotsUntilThisAccountLevel;         // 0x0184(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UseEasyBotsUntilThisAccountLevel;                  // 0x0188(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UseIntermediateBotsUntilThisAccountLevel;          // 0x018C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UseExperiencedBotsUntilThisAccountLevel;           // 0x0190(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_194[0x4];                                      // 0x0194(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 NewPlayerFriendlyBotHeroList;                      // 0x0198(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NewPlayerEnemyBotHeroList;                         // 0x01A8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoopVsAIMMRRatingScale;                            // 0x01B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoopVsAIMMRTimeScale;                              // 0x01BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRoboCaptainAutoAcceptTeamInvite;                  // 0x01C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCardInspect;                                // 0x01C1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowCardNotificationsInChat;                      // 0x01C2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCardShopAutoOpen;                           // 0x01C3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreCuratedDeckGamesPlayedCheck;                // 0x01C4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreCuratedDeckClassCheck;                      // 0x01C5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceCountdownCardOnboarding;                     // 0x01C6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceCardShopGameOneTutorial;                     // 0x01C7(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceCardShopGameTwoTutorial;                     // 0x01C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseLegacyDeathTimers;                             // 0x01C9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProjectileCustomHitsEnabled;                      // 0x01CA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDecoySwapsEnabled;                                // 0x01CB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBannersEnabled;                                   // 0x01CC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBannerActivationFXEnabled;                        // 0x01CD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CE[0x2];                                      // 0x01CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BannerLingerOnDeathSeconds;                        // 0x01D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGravesitesEnabled;                                // 0x01D4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEveryoneHasADefaultBanner;                        // 0x01D5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActorPoolingEnabled;                              // 0x01D6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableTeamCompMatchmaking;                       // 0x01D7(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableTeamBuilderBack;                           // 0x01D8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D9[0x3];                                      // 0x01D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TeamBuilderBackTimerSeconds;                       // 0x01DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CardNotificationsInitialDelay;                     // 0x01E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowGameMode_Tutorial_1v1;                        // 0x01E4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowGameMode_PvP_3v3;                             // 0x01E5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowGameMode_PvP_Astrolabe_5v5;                   // 0x01E6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowGameMode_PvP_Astrolabe_3v3;                   // 0x01E7(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSubmitTBMatchmakingLogs;                          // 0x01E8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSubmitLBMatchmakingLogs;                          // 0x01E9(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSubmitLoginFailureLogs;                           // 0x01EA(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EB[0x1];                                      // 0x01EB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LoginFailureLogTailKb;                             // 0x01EC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSubmitReturnToMenuErrorLogs;                      // 0x01F0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F1[0x3];                                      // 0x01F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnToMenuErrorLogTailKb;                        // 0x01F4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bDisableTeamAdvantageCalculation;                  // 0x01F8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableLowCrosshair;                               // 0x01FC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FD[0x3];                                      // 0x01FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AccountLevelToUnlockDifficultySelector;            // 0x0200(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_204[0x4];                                      // 0x0204(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOrionRuntimeOptions* GetRuntimeOptions();

	void OnHotfixApplied__DelegateSignature();

	class FString GetBuildTime() const;
	bool GetDecoySwapsEnabled() const;
	int32 GetFirstGamePlaylistID() const;
	class FString GetGameVersion() const;
	bool IsDeathcamEnabled() const;
	bool IsImageViewer() const;
	bool ProjectileCustomHitsEnabled() const;
	bool UseLegacyDeathTimers() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionRuntimeOptions">();
	}
	static class UOrionRuntimeOptions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionRuntimeOptions>();
	}
};
static_assert(alignof(UOrionRuntimeOptions) == 0x000008, "Wrong alignment on UOrionRuntimeOptions");
static_assert(sizeof(UOrionRuntimeOptions) == 0x000208, "Wrong size on UOrionRuntimeOptions");
static_assert(offsetof(UOrionRuntimeOptions, OnHotfixApplied) == 0x000028, "Member 'UOrionRuntimeOptions::OnHotfixApplied' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, DisableImageViewer) == 0x000038, "Member 'UOrionRuntimeOptions::DisableImageViewer' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, Version) == 0x00003C, "Member 'UOrionRuntimeOptions::Version' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bEnableReplayVideoRecording) == 0x000040, "Member 'UOrionRuntimeOptions::bEnableReplayVideoRecording' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bDisallowMTXStorePurchaesPC) == 0x000041, "Member 'UOrionRuntimeOptions::bDisallowMTXStorePurchaesPC' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bDisallowMTXStorePurchaesPS4) == 0x000042, "Member 'UOrionRuntimeOptions::bDisallowMTXStorePurchaesPS4' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bDisallowCoinPurchases) == 0x000043, "Member 'UOrionRuntimeOptions::bDisallowCoinPurchases' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bPSPlusFreeAccess) == 0x000044, "Member 'UOrionRuntimeOptions::bPSPlusFreeAccess' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bFreeAccess) == 0x000045, "Member 'UOrionRuntimeOptions::bFreeAccess' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bEnableReplays) == 0x000046, "Member 'UOrionRuntimeOptions::bEnableReplays' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bAllowSoloRewards) == 0x000047, "Member 'UOrionRuntimeOptions::bAllowSoloRewards' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bEnableFriendCodes) == 0x000048, "Member 'UOrionRuntimeOptions::bEnableFriendCodes' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bDisableSoloVsAIReplays) == 0x000049, "Member 'UOrionRuntimeOptions::bDisableSoloVsAIReplays' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bDisableCoopVsAIReplays) == 0x00004A, "Member 'UOrionRuntimeOptions::bDisableCoopVsAIReplays' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bEnableTutorialReplays) == 0x00004B, "Member 'UOrionRuntimeOptions::bEnableTutorialReplays' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bAllowUsingShaderModel4) == 0x00004C, "Member 'UOrionRuntimeOptions::bAllowUsingShaderModel4' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bRequireGamePlayedForDeckBuilderAccess) == 0x00004D, "Member 'UOrionRuntimeOptions::bRequireGamePlayedForDeckBuilderAccess' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bShowEarlyAccessWarning) == 0x00004E, "Member 'UOrionRuntimeOptions::bShowEarlyAccessWarning' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bDisablePlayerRatingButton) == 0x00004F, "Member 'UOrionRuntimeOptions::bDisablePlayerRatingButton' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bDisablePostGameContinueDelay) == 0x000050, "Member 'UOrionRuntimeOptions::bDisablePostGameContinueDelay' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bEnableGemRefining) == 0x000051, "Member 'UOrionRuntimeOptions::bEnableGemRefining' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bDisableFeaturedTab) == 0x000052, "Member 'UOrionRuntimeOptions::bDisableFeaturedTab' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bDisableEmoteTab) == 0x000053, "Member 'UOrionRuntimeOptions::bDisableEmoteTab' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bDisableBundleTab) == 0x000054, "Member 'UOrionRuntimeOptions::bDisableBundleTab' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bDisableCoinTab) == 0x000055, "Member 'UOrionRuntimeOptions::bDisableCoinTab' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bDisableSkinVariations) == 0x000056, "Member 'UOrionRuntimeOptions::bDisableSkinVariations' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bDisableCardOnboardingFlowState) == 0x000057, "Member 'UOrionRuntimeOptions::bDisableCardOnboardingFlowState' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bSuperMinionBonusOnInhibDeath) == 0x000058, "Member 'UOrionRuntimeOptions::bSuperMinionBonusOnInhibDeath' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bDisableBanMessagesInPostGame) == 0x000059, "Member 'UOrionRuntimeOptions::bDisableBanMessagesInPostGame' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bEnableDeathcamPC) == 0x00005A, "Member 'UOrionRuntimeOptions::bEnableDeathcamPC' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bEnableDeathcamPS4) == 0x00005B, "Member 'UOrionRuntimeOptions::bEnableDeathcamPS4' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bDisableAllyXPHeroPortrait) == 0x00005C, "Member 'UOrionRuntimeOptions::bDisableAllyXPHeroPortrait' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, ShowNewUserVideoPercentPC) == 0x000060, "Member 'UOrionRuntimeOptions::ShowNewUserVideoPercentPC' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, ShowNewUserVideoPercentPS4) == 0x000064, "Member 'UOrionRuntimeOptions::ShowNewUserVideoPercentPS4' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bAllowVideoSkips) == 0x000068, "Member 'UOrionRuntimeOptions::bAllowVideoSkips' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bShowNewDawnVideo) == 0x000069, "Member 'UOrionRuntimeOptions::bShowNewDawnVideo' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, MinGamesForSovereignUpdate) == 0x00006C, "Member 'UOrionRuntimeOptions::MinGamesForSovereignUpdate' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, MaxGamesForDeckBuilderOnboarding) == 0x000070, "Member 'UOrionRuntimeOptions::MaxGamesForDeckBuilderOnboarding' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, SovereignLearnMoreURL) == 0x000078, "Member 'UOrionRuntimeOptions::SovereignLearnMoreURL' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bShowNewDawnPlayBanner) == 0x000088, "Member 'UOrionRuntimeOptions::bShowNewDawnPlayBanner' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bShowLegacyPlayBanner) == 0x000089, "Member 'UOrionRuntimeOptions::bShowLegacyPlayBanner' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bShowPlayAnnouncementBanner) == 0x00008A, "Member 'UOrionRuntimeOptions::bShowPlayAnnouncementBanner' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, PlayAnnouncementURL) == 0x000090, "Member 'UOrionRuntimeOptions::PlayAnnouncementURL' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bAllowLegacyDecks) == 0x0000A0, "Member 'UOrionRuntimeOptions::bAllowLegacyDecks' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bShowMasteryOnboardUIScreens) == 0x0000A1, "Member 'UOrionRuntimeOptions::bShowMasteryOnboardUIScreens' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, UIAnalyticsLevel) == 0x0000A4, "Member 'UOrionRuntimeOptions::UIAnalyticsLevel' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bEnableLearningTips) == 0x0000A8, "Member 'UOrionRuntimeOptions::bEnableLearningTips' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bEnableToxicityTips) == 0x0000A9, "Member 'UOrionRuntimeOptions::bEnableToxicityTips' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bEnableNewUserTips) == 0x0000AA, "Member 'UOrionRuntimeOptions::bEnableNewUserTips' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, NewPlayerPvPWarningGameCount) == 0x0000AC, "Member 'UOrionRuntimeOptions::NewPlayerPvPWarningGameCount' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, NewPlayerPvPWarningWinCount) == 0x0000B0, "Member 'UOrionRuntimeOptions::NewPlayerPvPWarningWinCount' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, NewPlayerCoopWarningGameCount) == 0x0000B4, "Member 'UOrionRuntimeOptions::NewPlayerCoopWarningGameCount' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, PlayerRatingCalloutPvPGameCount) == 0x0000B8, "Member 'UOrionRuntimeOptions::PlayerRatingCalloutPvPGameCount' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, PlayerRatingCalloutCoopLevel) == 0x0000BC, "Member 'UOrionRuntimeOptions::PlayerRatingCalloutCoopLevel' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, PlayerRatingCalloutChance) == 0x0000C0, "Member 'UOrionRuntimeOptions::PlayerRatingCalloutChance' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bEnableLootCrateOpening) == 0x0000C4, "Member 'UOrionRuntimeOptions::bEnableLootCrateOpening' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bAutoJoinTutorial) == 0x0000C5, "Member 'UOrionRuntimeOptions::bAutoJoinTutorial' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, AutoJoinTutorialLevelCap) == 0x0000C8, "Member 'UOrionRuntimeOptions::AutoJoinTutorialLevelCap' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, AutoJoinTutorialGamesPlayedCap) == 0x0000CC, "Member 'UOrionRuntimeOptions::AutoJoinTutorialGamesPlayedCap' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bAllowHDROnPS4) == 0x0000D0, "Member 'UOrionRuntimeOptions::bAllowHDROnPS4' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bEnableDailyLoginBonus) == 0x0000D1, "Member 'UOrionRuntimeOptions::bEnableDailyLoginBonus' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bEnableCMSPopup) == 0x0000D2, "Member 'UOrionRuntimeOptions::bEnableCMSPopup' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bEnableCommunityTab) == 0x0000D3, "Member 'UOrionRuntimeOptions::bEnableCommunityTab' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bEnableVaultTokenPurchases) == 0x0000D4, "Member 'UOrionRuntimeOptions::bEnableVaultTokenPurchases' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bClientCommitAlwaysPass) == 0x0000D5, "Member 'UOrionRuntimeOptions::bClientCommitAlwaysPass' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bAllowM42PVPLock) == 0x0000D6, "Member 'UOrionRuntimeOptions::bAllowM42PVPLock' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, NonPVPGamesToDisableM42Lock) == 0x0000D8, "Member 'UOrionRuntimeOptions::NonPVPGamesToDisableM42Lock' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, DeckBuilderSaveOccuranceInSeconds) == 0x0000DC, "Member 'UOrionRuntimeOptions::DeckBuilderSaveOccuranceInSeconds' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bAllowArcadeMode) == 0x0000E0, "Member 'UOrionRuntimeOptions::bAllowArcadeMode' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bQueueSimulatedProxyOnRepMovement) == 0x0000E1, "Member 'UOrionRuntimeOptions::bQueueSimulatedProxyOnRepMovement' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bShowSpecateOptionInCustomMatchWidget) == 0x0000E2, "Member 'UOrionRuntimeOptions::bShowSpecateOptionInCustomMatchWidget' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, DraftPreloadDelaySeconds) == 0x0000E4, "Member 'UOrionRuntimeOptions::DraftPreloadDelaySeconds' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bShowSandbox) == 0x0000E8, "Member 'UOrionRuntimeOptions::bShowSandbox' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, KRMinutesBeforeMinorShutdownToDisablePlayButton) == 0x0000EC, "Member 'UOrionRuntimeOptions::KRMinutesBeforeMinorShutdownToDisablePlayButton' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, ActiveEventNames) == 0x0000F0, "Member 'UOrionRuntimeOptions::ActiveEventNames' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, MemoryHeartbeatPeriod) == 0x000100, "Member 'UOrionRuntimeOptions::MemoryHeartbeatPeriod' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, ObjectUsageReportPeriod) == 0x000104, "Member 'UOrionRuntimeOptions::ObjectUsageReportPeriod' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, ObjectUsageClassList) == 0x000108, "Member 'UOrionRuntimeOptions::ObjectUsageClassList' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, CreateMinionsVersion) == 0x000118, "Member 'UOrionRuntimeOptions::CreateMinionsVersion' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, MinionLastHitVisualization) == 0x00011C, "Member 'UOrionRuntimeOptions::MinionLastHitVisualization' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, FirstGameMatchmakingType) == 0x00011E, "Member 'UOrionRuntimeOptions::FirstGameMatchmakingType' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bEnableMMS) == 0x000120, "Member 'UOrionRuntimeOptions::bEnableMMS' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, EnabledMMSRegions) == 0x000128, "Member 'UOrionRuntimeOptions::EnabledMMSRegions' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, DefaultMMSBackends) == 0x000138, "Member 'UOrionRuntimeOptions::DefaultMMSBackends' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, MMSTicketURLClient) == 0x000148, "Member 'UOrionRuntimeOptions::MMSTicketURLClient' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, MMSTicketURLServer) == 0x000158, "Member 'UOrionRuntimeOptions::MMSTicketURLServer' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, MMSVersionCompatability) == 0x000168, "Member 'UOrionRuntimeOptions::MMSVersionCompatability' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, MMSPingInterval) == 0x000178, "Member 'UOrionRuntimeOptions::MMSPingInterval' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bDisableCustomMatchmakingKey) == 0x00017C, "Member 'UOrionRuntimeOptions::bDisableCustomMatchmakingKey' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bDisableSBMatchmaking) == 0x00017D, "Member 'UOrionRuntimeOptions::bDisableSBMatchmaking' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bShowMatchmakingTimeWarning) == 0x00017E, "Member 'UOrionRuntimeOptions::bShowMatchmakingTimeWarning' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bShowMatchmakingPlayerPips) == 0x00017F, "Member 'UOrionRuntimeOptions::bShowMatchmakingPlayerPips' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, ReadyCheckTimeoutValue) == 0x000180, "Member 'UOrionRuntimeOptions::ReadyCheckTimeoutValue' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, UseNewPlayerHeroBotsUntilThisAccountLevel) == 0x000184, "Member 'UOrionRuntimeOptions::UseNewPlayerHeroBotsUntilThisAccountLevel' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, UseEasyBotsUntilThisAccountLevel) == 0x000188, "Member 'UOrionRuntimeOptions::UseEasyBotsUntilThisAccountLevel' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, UseIntermediateBotsUntilThisAccountLevel) == 0x00018C, "Member 'UOrionRuntimeOptions::UseIntermediateBotsUntilThisAccountLevel' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, UseExperiencedBotsUntilThisAccountLevel) == 0x000190, "Member 'UOrionRuntimeOptions::UseExperiencedBotsUntilThisAccountLevel' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, NewPlayerFriendlyBotHeroList) == 0x000198, "Member 'UOrionRuntimeOptions::NewPlayerFriendlyBotHeroList' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, NewPlayerEnemyBotHeroList) == 0x0001A8, "Member 'UOrionRuntimeOptions::NewPlayerEnemyBotHeroList' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, CoopVsAIMMRRatingScale) == 0x0001B8, "Member 'UOrionRuntimeOptions::CoopVsAIMMRRatingScale' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, CoopVsAIMMRTimeScale) == 0x0001BC, "Member 'UOrionRuntimeOptions::CoopVsAIMMRTimeScale' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bRoboCaptainAutoAcceptTeamInvite) == 0x0001C0, "Member 'UOrionRuntimeOptions::bRoboCaptainAutoAcceptTeamInvite' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bEnableCardInspect) == 0x0001C1, "Member 'UOrionRuntimeOptions::bEnableCardInspect' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bShowCardNotificationsInChat) == 0x0001C2, "Member 'UOrionRuntimeOptions::bShowCardNotificationsInChat' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bEnableCardShopAutoOpen) == 0x0001C3, "Member 'UOrionRuntimeOptions::bEnableCardShopAutoOpen' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bIgnoreCuratedDeckGamesPlayedCheck) == 0x0001C4, "Member 'UOrionRuntimeOptions::bIgnoreCuratedDeckGamesPlayedCheck' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bIgnoreCuratedDeckClassCheck) == 0x0001C5, "Member 'UOrionRuntimeOptions::bIgnoreCuratedDeckClassCheck' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bForceCountdownCardOnboarding) == 0x0001C6, "Member 'UOrionRuntimeOptions::bForceCountdownCardOnboarding' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bForceCardShopGameOneTutorial) == 0x0001C7, "Member 'UOrionRuntimeOptions::bForceCardShopGameOneTutorial' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bForceCardShopGameTwoTutorial) == 0x0001C8, "Member 'UOrionRuntimeOptions::bForceCardShopGameTwoTutorial' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bUseLegacyDeathTimers) == 0x0001C9, "Member 'UOrionRuntimeOptions::bUseLegacyDeathTimers' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bProjectileCustomHitsEnabled) == 0x0001CA, "Member 'UOrionRuntimeOptions::bProjectileCustomHitsEnabled' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bDecoySwapsEnabled) == 0x0001CB, "Member 'UOrionRuntimeOptions::bDecoySwapsEnabled' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bBannersEnabled) == 0x0001CC, "Member 'UOrionRuntimeOptions::bBannersEnabled' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bBannerActivationFXEnabled) == 0x0001CD, "Member 'UOrionRuntimeOptions::bBannerActivationFXEnabled' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, BannerLingerOnDeathSeconds) == 0x0001D0, "Member 'UOrionRuntimeOptions::BannerLingerOnDeathSeconds' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bGravesitesEnabled) == 0x0001D4, "Member 'UOrionRuntimeOptions::bGravesitesEnabled' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bEveryoneHasADefaultBanner) == 0x0001D5, "Member 'UOrionRuntimeOptions::bEveryoneHasADefaultBanner' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bActorPoolingEnabled) == 0x0001D6, "Member 'UOrionRuntimeOptions::bActorPoolingEnabled' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bDisableTeamCompMatchmaking) == 0x0001D7, "Member 'UOrionRuntimeOptions::bDisableTeamCompMatchmaking' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bDisableTeamBuilderBack) == 0x0001D8, "Member 'UOrionRuntimeOptions::bDisableTeamBuilderBack' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, TeamBuilderBackTimerSeconds) == 0x0001DC, "Member 'UOrionRuntimeOptions::TeamBuilderBackTimerSeconds' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, CardNotificationsInitialDelay) == 0x0001E0, "Member 'UOrionRuntimeOptions::CardNotificationsInitialDelay' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bShowGameMode_Tutorial_1v1) == 0x0001E4, "Member 'UOrionRuntimeOptions::bShowGameMode_Tutorial_1v1' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bShowGameMode_PvP_3v3) == 0x0001E5, "Member 'UOrionRuntimeOptions::bShowGameMode_PvP_3v3' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bShowGameMode_PvP_Astrolabe_5v5) == 0x0001E6, "Member 'UOrionRuntimeOptions::bShowGameMode_PvP_Astrolabe_5v5' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bShowGameMode_PvP_Astrolabe_3v3) == 0x0001E7, "Member 'UOrionRuntimeOptions::bShowGameMode_PvP_Astrolabe_3v3' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bSubmitTBMatchmakingLogs) == 0x0001E8, "Member 'UOrionRuntimeOptions::bSubmitTBMatchmakingLogs' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bSubmitLBMatchmakingLogs) == 0x0001E9, "Member 'UOrionRuntimeOptions::bSubmitLBMatchmakingLogs' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bSubmitLoginFailureLogs) == 0x0001EA, "Member 'UOrionRuntimeOptions::bSubmitLoginFailureLogs' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, LoginFailureLogTailKb) == 0x0001EC, "Member 'UOrionRuntimeOptions::LoginFailureLogTailKb' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bSubmitReturnToMenuErrorLogs) == 0x0001F0, "Member 'UOrionRuntimeOptions::bSubmitReturnToMenuErrorLogs' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, ReturnToMenuErrorLogTailKb) == 0x0001F4, "Member 'UOrionRuntimeOptions::ReturnToMenuErrorLogTailKb' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bDisableTeamAdvantageCalculation) == 0x0001F8, "Member 'UOrionRuntimeOptions::bDisableTeamAdvantageCalculation' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, bEnableLowCrosshair) == 0x0001FC, "Member 'UOrionRuntimeOptions::bEnableLowCrosshair' has a wrong offset!");
static_assert(offsetof(UOrionRuntimeOptions, AccountLevelToUnlockDifficultySelector) == 0x000200, "Member 'UOrionRuntimeOptions::AccountLevelToUnlockDifficultySelector' has a wrong offset!");

// Class OrionGame.OrionSentryTurretAnimInstance
// 0x0538 (0x0950 - 0x0418)
class UOrionSentryTurretAnimInstance : public UOrionAnimInstance
{
public:
	class FName                                   PivotSocketName;                                   // 0x0418(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FiringCurveName;                                   // 0x0420(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AimingCurveName;                                   // 0x0428(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetWorldLocation;                               // 0x0430(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43C[0x4];                                      // 0x043C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionSentryTurretAnimInstanceProxy    Proxy;                                             // 0x0440(0x0510)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionSentryTurretAnimInstance">();
	}
	static class UOrionSentryTurretAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionSentryTurretAnimInstance>();
	}
};
static_assert(alignof(UOrionSentryTurretAnimInstance) == 0x000010, "Wrong alignment on UOrionSentryTurretAnimInstance");
static_assert(sizeof(UOrionSentryTurretAnimInstance) == 0x000950, "Wrong size on UOrionSentryTurretAnimInstance");
static_assert(offsetof(UOrionSentryTurretAnimInstance, PivotSocketName) == 0x000418, "Member 'UOrionSentryTurretAnimInstance::PivotSocketName' has a wrong offset!");
static_assert(offsetof(UOrionSentryTurretAnimInstance, FiringCurveName) == 0x000420, "Member 'UOrionSentryTurretAnimInstance::FiringCurveName' has a wrong offset!");
static_assert(offsetof(UOrionSentryTurretAnimInstance, AimingCurveName) == 0x000428, "Member 'UOrionSentryTurretAnimInstance::AimingCurveName' has a wrong offset!");
static_assert(offsetof(UOrionSentryTurretAnimInstance, TargetWorldLocation) == 0x000430, "Member 'UOrionSentryTurretAnimInstance::TargetWorldLocation' has a wrong offset!");
static_assert(offsetof(UOrionSentryTurretAnimInstance, Proxy) == 0x000440, "Member 'UOrionSentryTurretAnimInstance::Proxy' has a wrong offset!");

// Class OrionGame.OrionShadowPad
// 0x0068 (0x0380 - 0x0318)
class AOrionShadowPad final : public AActor
{
public:
	class USphereComponent*                       OverlapCollision;                                  // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOrionGameplayVolumeComponent*          GameplayVolumeComp;                                // 0x0320(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_328[0x58];                                     // 0x0328(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GameplayTagCallback_ShadowPlanePadOff(const struct FGameplayTag& Tag, int32 NewCount);
	void HandleOverlappingCharDeath(class AOrionChar* DeadChar, class AController* Killer, class AActor* DamageCauser);
	void HandleOverlappingCharEnteredPhaseShift(class AOrionChar* PhaseShifedChar);
	void OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void UpdateLocalEffects(bool Enabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionShadowPad">();
	}
	static class AOrionShadowPad* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionShadowPad>();
	}
};
static_assert(alignof(AOrionShadowPad) == 0x000008, "Wrong alignment on AOrionShadowPad");
static_assert(sizeof(AOrionShadowPad) == 0x000380, "Wrong size on AOrionShadowPad");
static_assert(offsetof(AOrionShadowPad, OverlapCollision) == 0x000318, "Member 'AOrionShadowPad::OverlapCollision' has a wrong offset!");
static_assert(offsetof(AOrionShadowPad, GameplayVolumeComp) == 0x000320, "Member 'AOrionShadowPad::GameplayVolumeComp' has a wrong offset!");

// Class OrionGame.OrionShape
// 0x0010 (0x0038 - 0x0028)
class UOrionShape final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionShape">();
	}
	static class UOrionShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionShape>();
	}
};
static_assert(alignof(UOrionShape) == 0x000008, "Wrong alignment on UOrionShape");
static_assert(sizeof(UOrionShape) == 0x000038, "Wrong size on UOrionShape");

// Class OrionGame.OrionSignificanceManager
// 0x0528 (0x0620 - 0x00F8)
class UOrionSignificanceManager final : public USignificanceManager
{
public:
	uint8                                         Pad_F8[0x528];                                     // 0x00F8(0x0528)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionSignificanceManager">();
	}
	static class UOrionSignificanceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionSignificanceManager>();
	}
};
static_assert(alignof(UOrionSignificanceManager) == 0x000008, "Wrong alignment on UOrionSignificanceManager");
static_assert(sizeof(UOrionSignificanceManager) == 0x000620, "Wrong size on UOrionSignificanceManager");

// Class OrionGame.OrionSourceItemAbility
// 0x0190 (0x0D00 - 0x0B70)
class UOrionSourceItemAbility final : public UOrionAbility
{
public:
	uint8                                         Pad_B70[0x190];                                    // 0x0B70(0x0190)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionSourceItemAbility">();
	}
	static class UOrionSourceItemAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionSourceItemAbility>();
	}
};
static_assert(alignof(UOrionSourceItemAbility) == 0x000010, "Wrong alignment on UOrionSourceItemAbility");
static_assert(sizeof(UOrionSourceItemAbility) == 0x000D00, "Wrong size on UOrionSourceItemAbility");

// Class OrionGame.OrionSparrowAnimInstance
// 0x0010 (0x0780 - 0x0770)
class UOrionSparrowAnimInstance final : public UOrionBaseHeroAnimInstance
{
public:
	bool                                          bOverrideUltimateAdditive;                         // 0x0770(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUltimateActive;                                 // 0x0771(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_772[0x2];                                      // 0x0772(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UltimateAlpha;                                     // 0x0774(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArrowLookAtAlpha;                                  // 0x0778(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BowStringCopyBoneAlpha;                            // 0x077C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionSparrowAnimInstance">();
	}
	static class UOrionSparrowAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionSparrowAnimInstance>();
	}
};
static_assert(alignof(UOrionSparrowAnimInstance) == 0x000008, "Wrong alignment on UOrionSparrowAnimInstance");
static_assert(sizeof(UOrionSparrowAnimInstance) == 0x000780, "Wrong size on UOrionSparrowAnimInstance");
static_assert(offsetof(UOrionSparrowAnimInstance, bOverrideUltimateAdditive) == 0x000770, "Member 'UOrionSparrowAnimInstance::bOverrideUltimateAdditive' has a wrong offset!");
static_assert(offsetof(UOrionSparrowAnimInstance, bIsUltimateActive) == 0x000771, "Member 'UOrionSparrowAnimInstance::bIsUltimateActive' has a wrong offset!");
static_assert(offsetof(UOrionSparrowAnimInstance, UltimateAlpha) == 0x000774, "Member 'UOrionSparrowAnimInstance::UltimateAlpha' has a wrong offset!");
static_assert(offsetof(UOrionSparrowAnimInstance, ArrowLookAtAlpha) == 0x000778, "Member 'UOrionSparrowAnimInstance::ArrowLookAtAlpha' has a wrong offset!");
static_assert(offsetof(UOrionSparrowAnimInstance, BowStringCopyBoneAlpha) == 0x00077C, "Member 'UOrionSparrowAnimInstance::BowStringCopyBoneAlpha' has a wrong offset!");

// Class OrionGame.OrionSpectatorCamComp_Arena
// 0x0020 (0x08B0 - 0x0890)
class UOrionSpectatorCamComp_Arena final : public UOrionReplaySpectatorCameraComponent
{
public:
	uint8                                         Pad_890[0x14];                                     // 0x0890(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraRotationInterpSpeed;                         // 0x08A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bEnforce180Rule : 1;                               // 0x08A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_8A9[0x7];                                      // 0x08A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AddMoveForwardInput(float InputVal);
	bool AddMoveRightInput(float InputVal);
	void SetCameraPositionOnRail(float DistanceAlongRail);
	void SetEnforce180Rule(bool bNewEnforce180);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionSpectatorCamComp_Arena">();
	}
	static class UOrionSpectatorCamComp_Arena* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionSpectatorCamComp_Arena>();
	}
};
static_assert(alignof(UOrionSpectatorCamComp_Arena) == 0x000010, "Wrong alignment on UOrionSpectatorCamComp_Arena");
static_assert(sizeof(UOrionSpectatorCamComp_Arena) == 0x0008B0, "Wrong size on UOrionSpectatorCamComp_Arena");
static_assert(offsetof(UOrionSpectatorCamComp_Arena, CameraRotationInterpSpeed) == 0x0008A4, "Member 'UOrionSpectatorCamComp_Arena::CameraRotationInterpSpeed' has a wrong offset!");

// Class OrionGame.OrionSpectatorCamComp_Chase
// 0x0120 (0x09B0 - 0x0890)
class UOrionSpectatorCamComp_Chase final : public UOrionReplaySpectatorCameraComponent
{
public:
	struct FOrionChaseCameraHelper                ChaseImplementation;                               // 0x0890(0x0120)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void SetAutoFollow(bool bNewAutoFollow);
	void SetLazyAutoFollow(bool bNewLazyAutoFollow);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionSpectatorCamComp_Chase">();
	}
	static class UOrionSpectatorCamComp_Chase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionSpectatorCamComp_Chase>();
	}
};
static_assert(alignof(UOrionSpectatorCamComp_Chase) == 0x000010, "Wrong alignment on UOrionSpectatorCamComp_Chase");
static_assert(sizeof(UOrionSpectatorCamComp_Chase) == 0x0009B0, "Wrong size on UOrionSpectatorCamComp_Chase");
static_assert(offsetof(UOrionSpectatorCamComp_Chase, ChaseImplementation) == 0x000890, "Member 'UOrionSpectatorCamComp_Chase::ChaseImplementation' has a wrong offset!");

// Class OrionGame.OrionSpectatorCamComp_Isometric
// 0x00C0 (0x0950 - 0x0890)
class UOrionSpectatorCamComp_Isometric final : public UOrionReplaySpectatorCameraComponent
{
public:
	uint8                                         Pad_890[0x30];                                     // 0x0890(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraTruckRate;                                   // 0x08C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraToCameraRootAlphaInterpSpeed;                // 0x08C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8C8[0x8];                                      // 0x08C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             MinCameraToCameraRoot;                             // 0x08D0(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTransform                             MaxCameraToCameraRoot;                             // 0x0900(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_930[0x14];                                     // 0x0930(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	EIsometricCamAngle                            CurrentCameraAngle;                                // 0x0944(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_945[0xB];                                      // 0x0945(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCameraAngle(EIsometricCamAngle NewAngle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionSpectatorCamComp_Isometric">();
	}
	static class UOrionSpectatorCamComp_Isometric* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionSpectatorCamComp_Isometric>();
	}
};
static_assert(alignof(UOrionSpectatorCamComp_Isometric) == 0x000010, "Wrong alignment on UOrionSpectatorCamComp_Isometric");
static_assert(sizeof(UOrionSpectatorCamComp_Isometric) == 0x000950, "Wrong size on UOrionSpectatorCamComp_Isometric");
static_assert(offsetof(UOrionSpectatorCamComp_Isometric, CameraTruckRate) == 0x0008C0, "Member 'UOrionSpectatorCamComp_Isometric::CameraTruckRate' has a wrong offset!");
static_assert(offsetof(UOrionSpectatorCamComp_Isometric, CameraToCameraRootAlphaInterpSpeed) == 0x0008C4, "Member 'UOrionSpectatorCamComp_Isometric::CameraToCameraRootAlphaInterpSpeed' has a wrong offset!");
static_assert(offsetof(UOrionSpectatorCamComp_Isometric, MinCameraToCameraRoot) == 0x0008D0, "Member 'UOrionSpectatorCamComp_Isometric::MinCameraToCameraRoot' has a wrong offset!");
static_assert(offsetof(UOrionSpectatorCamComp_Isometric, MaxCameraToCameraRoot) == 0x000900, "Member 'UOrionSpectatorCamComp_Isometric::MaxCameraToCameraRoot' has a wrong offset!");
static_assert(offsetof(UOrionSpectatorCamComp_Isometric, CurrentCameraAngle) == 0x000944, "Member 'UOrionSpectatorCamComp_Isometric::CurrentCameraAngle' has a wrong offset!");

// Class OrionGame.OrionSpectatorCamComp_OTS
// 0x00A0 (0x0930 - 0x0890)
class UOrionSpectatorCamComp_OTS final : public UOrionReplaySpectatorCameraComponent
{
public:
	struct FTransform                             PivotToViewTarget;                                 // 0x0890(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bAutoFollow : 1;                                   // 0x08C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_8C1[0x3];                                      // 0x08C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PivotLocationInterpSpeed;                          // 0x08C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PivotRotationInterpSpeed;                          // 0x08C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraCollisionSphereRadius;                       // 0x08CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8D0[0x60];                                     // 0x08D0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAutoFollow(bool bNewAutoFollow);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionSpectatorCamComp_OTS">();
	}
	static class UOrionSpectatorCamComp_OTS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionSpectatorCamComp_OTS>();
	}
};
static_assert(alignof(UOrionSpectatorCamComp_OTS) == 0x000010, "Wrong alignment on UOrionSpectatorCamComp_OTS");
static_assert(sizeof(UOrionSpectatorCamComp_OTS) == 0x000930, "Wrong size on UOrionSpectatorCamComp_OTS");
static_assert(offsetof(UOrionSpectatorCamComp_OTS, PivotToViewTarget) == 0x000890, "Member 'UOrionSpectatorCamComp_OTS::PivotToViewTarget' has a wrong offset!");
static_assert(offsetof(UOrionSpectatorCamComp_OTS, PivotLocationInterpSpeed) == 0x0008C4, "Member 'UOrionSpectatorCamComp_OTS::PivotLocationInterpSpeed' has a wrong offset!");
static_assert(offsetof(UOrionSpectatorCamComp_OTS, PivotRotationInterpSpeed) == 0x0008C8, "Member 'UOrionSpectatorCamComp_OTS::PivotRotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(UOrionSpectatorCamComp_OTS, CameraCollisionSphereRadius) == 0x0008CC, "Member 'UOrionSpectatorCamComp_OTS::CameraCollisionSphereRadius' has a wrong offset!");

// Class OrionGame.OrionStatusEffectData
// 0x0010 (0x0040 - 0x0030)
class UOrionStatusEffectData final : public UDataAsset
{
public:
	TArray<struct FOrionStatusEffectDisplayInfo>  StatusEffects;                                     // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionStatusEffectData">();
	}
	static class UOrionStatusEffectData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionStatusEffectData>();
	}
};
static_assert(alignof(UOrionStatusEffectData) == 0x000008, "Wrong alignment on UOrionStatusEffectData");
static_assert(sizeof(UOrionStatusEffectData) == 0x000040, "Wrong size on UOrionStatusEffectData");
static_assert(offsetof(UOrionStatusEffectData, StatusEffects) == 0x000030, "Member 'UOrionStatusEffectData::StatusEffects' has a wrong offset!");

// Class OrionGame.OrionSteelAnimInstance
// 0x0160 (0x08C0 - 0x0760)
class UOrionSteelAnimInstance final : public UOrionCPPHeroBaseAnimInstance
{
public:
	bool                                          bIsUsingShield;                                    // 0x0760(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDoingAirAttack;                                 // 0x0761(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDoingCowCatcher;                                // 0x0762(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDoingShieldDive;                                // 0x0763(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShieldOverhead;                                 // 0x0764(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_765[0x3];                                      // 0x0765(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShieldOverheadAlpha;                               // 0x0768(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_76C[0x4];                                      // 0x076C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           AirAttackMontage;                                  // 0x0770(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisableShieldScaleAlpha;                           // 0x0778(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpLandAdditiveAlpha;                             // 0x077C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldWalkPlayRate;                                // 0x0780(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayAbilityOnFullBody;                            // 0x0784(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_785[0x3];                                      // 0x0785(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TravelModeAimOffsetYaw;                            // 0x0788(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimOffsetPitch;                                    // 0x078C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimOffsetYaw;                                      // 0x0790(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRecallingOrStunned;                             // 0x0794(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMovingInTravelModeOnGround;                     // 0x0795(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_796[0x2];                                      // 0x0796(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CringeHitReactAlpha;                               // 0x0798(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               SlopeBlendspaceRotation;                           // 0x079C(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ScaledLocomotionAdditiveAlpha;                     // 0x07A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLowerBodyTurnsDirection;                          // 0x07AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7AD[0x3];                                      // 0x07AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LowerBodyTurnsPlayRate;                            // 0x07B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurnInPlaceDirection;                             // 0x07B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B5[0x3];                                      // 0x07B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultJogRunLeanAngle;                            // 0x07B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultJogLocomotionDirection;                     // 0x07BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultTravelModeScaledSpeed;                      // 0x07C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDefaultTravelModeDirection;                       // 0x07C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C5[0x3];                                      // 0x07C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShieldedTurnsPlayRate;                             // 0x07C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShieldedTurnsDirection;                           // 0x07CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7CD[0x3];                                      // 0x07CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShieldedWalkPlayrate;                              // 0x07D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldedWalkLeanAngle;                             // 0x07D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldedJumpFallPlayRate;                          // 0x07D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShieldedJumpFallDirection;                        // 0x07DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7DD[0x3];                                      // 0x07DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShieldedJumpFallJogAlpha;                          // 0x07E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShieldedKnockBackDirection;                       // 0x07E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShieldOverheadTurnDirection;                      // 0x07E5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E6[0x2];                                      // 0x07E6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShieldOverheadTurnPlayrate;                        // 0x07E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldOverheadJogRunScaledSpeed;                   // 0x07EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldOverheadJogRunLeanAngle;                     // 0x07F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldOverheadJumpFallPlayRate;                    // 0x07F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShieldOverheadJumpFallDirection;                  // 0x07F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7F9[0x3];                                      // 0x07F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShieldOverheadJumpFallJogAlpha;                    // 0x07FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionsDefaultAdditiveAlpha;                   // 0x0800(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionsIdleToJogDirectionChangeDeltaStrength;  // 0x0804(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionsIdleToJogTravelModePlayRateScale;       // 0x0808(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionsIdleToJogAdditiveAlpha;                 // 0x080C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionsJogToIdleDeltaStrength;                 // 0x0810(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionsDipAScaledSpeed;                        // 0x0814(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransitionsDipAUsingShield;                       // 0x0818(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_819[0x3];                                      // 0x0819(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TransitionsDipADeltaStrength;                      // 0x081C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionsDipAAdditiveAlpha;                      // 0x0820(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionsSlopeChangeAdditiveAlpha;               // 0x0824(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransitionsSlopeChangeDirection;                  // 0x0828(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLeftFootPlanted;                                // 0x0829(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRightFootPlanted;                               // 0x082A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82B[0x1];                                      // 0x082B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeftFootPlantAlpha;                                // 0x082C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightFootPlantAlpha;                               // 0x0830(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_834[0x8C];                                     // 0x0834(0x008C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionSteelAnimInstance">();
	}
	static class UOrionSteelAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionSteelAnimInstance>();
	}
};
static_assert(alignof(UOrionSteelAnimInstance) == 0x000008, "Wrong alignment on UOrionSteelAnimInstance");
static_assert(sizeof(UOrionSteelAnimInstance) == 0x0008C0, "Wrong size on UOrionSteelAnimInstance");
static_assert(offsetof(UOrionSteelAnimInstance, bIsUsingShield) == 0x000760, "Member 'UOrionSteelAnimInstance::bIsUsingShield' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, bIsDoingAirAttack) == 0x000761, "Member 'UOrionSteelAnimInstance::bIsDoingAirAttack' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, bIsDoingCowCatcher) == 0x000762, "Member 'UOrionSteelAnimInstance::bIsDoingCowCatcher' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, bIsDoingShieldDive) == 0x000763, "Member 'UOrionSteelAnimInstance::bIsDoingShieldDive' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, bIsShieldOverhead) == 0x000764, "Member 'UOrionSteelAnimInstance::bIsShieldOverhead' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, ShieldOverheadAlpha) == 0x000768, "Member 'UOrionSteelAnimInstance::ShieldOverheadAlpha' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, AirAttackMontage) == 0x000770, "Member 'UOrionSteelAnimInstance::AirAttackMontage' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, DisableShieldScaleAlpha) == 0x000778, "Member 'UOrionSteelAnimInstance::DisableShieldScaleAlpha' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, JumpLandAdditiveAlpha) == 0x00077C, "Member 'UOrionSteelAnimInstance::JumpLandAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, ShieldWalkPlayRate) == 0x000780, "Member 'UOrionSteelAnimInstance::ShieldWalkPlayRate' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, bPlayAbilityOnFullBody) == 0x000784, "Member 'UOrionSteelAnimInstance::bPlayAbilityOnFullBody' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, TravelModeAimOffsetYaw) == 0x000788, "Member 'UOrionSteelAnimInstance::TravelModeAimOffsetYaw' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, AimOffsetPitch) == 0x00078C, "Member 'UOrionSteelAnimInstance::AimOffsetPitch' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, AimOffsetYaw) == 0x000790, "Member 'UOrionSteelAnimInstance::AimOffsetYaw' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, bIsRecallingOrStunned) == 0x000794, "Member 'UOrionSteelAnimInstance::bIsRecallingOrStunned' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, bIsMovingInTravelModeOnGround) == 0x000795, "Member 'UOrionSteelAnimInstance::bIsMovingInTravelModeOnGround' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, CringeHitReactAlpha) == 0x000798, "Member 'UOrionSteelAnimInstance::CringeHitReactAlpha' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, SlopeBlendspaceRotation) == 0x00079C, "Member 'UOrionSteelAnimInstance::SlopeBlendspaceRotation' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, ScaledLocomotionAdditiveAlpha) == 0x0007A8, "Member 'UOrionSteelAnimInstance::ScaledLocomotionAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, bLowerBodyTurnsDirection) == 0x0007AC, "Member 'UOrionSteelAnimInstance::bLowerBodyTurnsDirection' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, LowerBodyTurnsPlayRate) == 0x0007B0, "Member 'UOrionSteelAnimInstance::LowerBodyTurnsPlayRate' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, bTurnInPlaceDirection) == 0x0007B4, "Member 'UOrionSteelAnimInstance::bTurnInPlaceDirection' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, DefaultJogRunLeanAngle) == 0x0007B8, "Member 'UOrionSteelAnimInstance::DefaultJogRunLeanAngle' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, DefaultJogLocomotionDirection) == 0x0007BC, "Member 'UOrionSteelAnimInstance::DefaultJogLocomotionDirection' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, DefaultTravelModeScaledSpeed) == 0x0007C0, "Member 'UOrionSteelAnimInstance::DefaultTravelModeScaledSpeed' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, bDefaultTravelModeDirection) == 0x0007C4, "Member 'UOrionSteelAnimInstance::bDefaultTravelModeDirection' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, ShieldedTurnsPlayRate) == 0x0007C8, "Member 'UOrionSteelAnimInstance::ShieldedTurnsPlayRate' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, bShieldedTurnsDirection) == 0x0007CC, "Member 'UOrionSteelAnimInstance::bShieldedTurnsDirection' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, ShieldedWalkPlayrate) == 0x0007D0, "Member 'UOrionSteelAnimInstance::ShieldedWalkPlayrate' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, ShieldedWalkLeanAngle) == 0x0007D4, "Member 'UOrionSteelAnimInstance::ShieldedWalkLeanAngle' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, ShieldedJumpFallPlayRate) == 0x0007D8, "Member 'UOrionSteelAnimInstance::ShieldedJumpFallPlayRate' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, bShieldedJumpFallDirection) == 0x0007DC, "Member 'UOrionSteelAnimInstance::bShieldedJumpFallDirection' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, ShieldedJumpFallJogAlpha) == 0x0007E0, "Member 'UOrionSteelAnimInstance::ShieldedJumpFallJogAlpha' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, bShieldedKnockBackDirection) == 0x0007E4, "Member 'UOrionSteelAnimInstance::bShieldedKnockBackDirection' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, bShieldOverheadTurnDirection) == 0x0007E5, "Member 'UOrionSteelAnimInstance::bShieldOverheadTurnDirection' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, ShieldOverheadTurnPlayrate) == 0x0007E8, "Member 'UOrionSteelAnimInstance::ShieldOverheadTurnPlayrate' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, ShieldOverheadJogRunScaledSpeed) == 0x0007EC, "Member 'UOrionSteelAnimInstance::ShieldOverheadJogRunScaledSpeed' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, ShieldOverheadJogRunLeanAngle) == 0x0007F0, "Member 'UOrionSteelAnimInstance::ShieldOverheadJogRunLeanAngle' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, ShieldOverheadJumpFallPlayRate) == 0x0007F4, "Member 'UOrionSteelAnimInstance::ShieldOverheadJumpFallPlayRate' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, bShieldOverheadJumpFallDirection) == 0x0007F8, "Member 'UOrionSteelAnimInstance::bShieldOverheadJumpFallDirection' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, ShieldOverheadJumpFallJogAlpha) == 0x0007FC, "Member 'UOrionSteelAnimInstance::ShieldOverheadJumpFallJogAlpha' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, TransitionsDefaultAdditiveAlpha) == 0x000800, "Member 'UOrionSteelAnimInstance::TransitionsDefaultAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, TransitionsIdleToJogDirectionChangeDeltaStrength) == 0x000804, "Member 'UOrionSteelAnimInstance::TransitionsIdleToJogDirectionChangeDeltaStrength' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, TransitionsIdleToJogTravelModePlayRateScale) == 0x000808, "Member 'UOrionSteelAnimInstance::TransitionsIdleToJogTravelModePlayRateScale' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, TransitionsIdleToJogAdditiveAlpha) == 0x00080C, "Member 'UOrionSteelAnimInstance::TransitionsIdleToJogAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, TransitionsJogToIdleDeltaStrength) == 0x000810, "Member 'UOrionSteelAnimInstance::TransitionsJogToIdleDeltaStrength' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, TransitionsDipAScaledSpeed) == 0x000814, "Member 'UOrionSteelAnimInstance::TransitionsDipAScaledSpeed' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, bTransitionsDipAUsingShield) == 0x000818, "Member 'UOrionSteelAnimInstance::bTransitionsDipAUsingShield' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, TransitionsDipADeltaStrength) == 0x00081C, "Member 'UOrionSteelAnimInstance::TransitionsDipADeltaStrength' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, TransitionsDipAAdditiveAlpha) == 0x000820, "Member 'UOrionSteelAnimInstance::TransitionsDipAAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, TransitionsSlopeChangeAdditiveAlpha) == 0x000824, "Member 'UOrionSteelAnimInstance::TransitionsSlopeChangeAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, bTransitionsSlopeChangeDirection) == 0x000828, "Member 'UOrionSteelAnimInstance::bTransitionsSlopeChangeDirection' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, bIsLeftFootPlanted) == 0x000829, "Member 'UOrionSteelAnimInstance::bIsLeftFootPlanted' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, bIsRightFootPlanted) == 0x00082A, "Member 'UOrionSteelAnimInstance::bIsRightFootPlanted' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, LeftFootPlantAlpha) == 0x00082C, "Member 'UOrionSteelAnimInstance::LeftFootPlantAlpha' has a wrong offset!");
static_assert(offsetof(UOrionSteelAnimInstance, RightFootPlantAlpha) == 0x000830, "Member 'UOrionSteelAnimInstance::RightFootPlantAlpha' has a wrong offset!");

// Class OrionGame.OrionStoreDisplayData
// 0x0460 (0x0490 - 0x0030)
class UOrionStoreDisplayData final : public UDataAsset
{
public:
	struct FOrionStorefrontInfo                   StorefrontInfo[0xD];                               // 0x0030(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionNotification                     NoOffersFoundNotification;                         // 0x0310(0x0180)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionStoreDisplayData">();
	}
	static class UOrionStoreDisplayData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionStoreDisplayData>();
	}
};
static_assert(alignof(UOrionStoreDisplayData) == 0x000010, "Wrong alignment on UOrionStoreDisplayData");
static_assert(sizeof(UOrionStoreDisplayData) == 0x000490, "Wrong size on UOrionStoreDisplayData");
static_assert(offsetof(UOrionStoreDisplayData, StorefrontInfo) == 0x000030, "Member 'UOrionStoreDisplayData::StorefrontInfo' has a wrong offset!");
static_assert(offsetof(UOrionStoreDisplayData, NoOffersFoundNotification) == 0x000310, "Member 'UOrionStoreDisplayData::NoOffersFoundNotification' has a wrong offset!");

// Class OrionGame.SocialAsset
// 0x5CA0 (0x5CD0 - 0x0030)
class USocialAsset final : public UDataAsset
{
public:
	struct FSocialStyle                           Style;                                             // 0x0030(0x5CA0)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SocialAsset">();
	}
	static class USocialAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USocialAsset>();
	}
};
static_assert(alignof(USocialAsset) == 0x000008, "Wrong alignment on USocialAsset");
static_assert(sizeof(USocialAsset) == 0x005CD0, "Wrong size on USocialAsset");
static_assert(offsetof(USocialAsset, Style) == 0x000030, "Member 'USocialAsset::Style' has a wrong offset!");

// Class OrionGame.OrionEULAStyleData
// 0x1128 (0x1158 - 0x0030)
class UOrionEULAStyleData final : public UDataAsset
{
public:
	struct FTextBlockStyle                        EULARichTextStyle;                                 // 0x0030(0x01C8)(Edit, NativeAccessSpecifierPublic)
	struct FTextBlockStyle                        EULAHeaderStyle;                                   // 0x01F8(0x01C8)(Edit, NativeAccessSpecifierPublic)
	struct FTextBlockStyle                        EULASubHeaderStyle;                                // 0x03C0(0x01C8)(Edit, NativeAccessSpecifierPublic)
	struct FTextBlockStyle                        EULAHighlightItalicstyle;                          // 0x0588(0x01C8)(Edit, NativeAccessSpecifierPublic)
	struct FTextBlockStyle                        EULAHighlightStyle;                                // 0x0750(0x01C8)(Edit, NativeAccessSpecifierPublic)
	struct FTextBlockStyle                        EULAHyperLinkRichTextStyle;                        // 0x0918(0x01C8)(Edit, NativeAccessSpecifierPublic)
	struct FButtonStyle                           EULAHyperlinkButtonStyle;                          // 0x0AE0(0x0238)(Edit, NativeAccessSpecifierPublic)
	struct FScrollBarStyle                        EULAScrollBarStyle;                                // 0x0D18(0x0440)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionEULAStyleData">();
	}
	static class UOrionEULAStyleData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionEULAStyleData>();
	}
};
static_assert(alignof(UOrionEULAStyleData) == 0x000008, "Wrong alignment on UOrionEULAStyleData");
static_assert(sizeof(UOrionEULAStyleData) == 0x001158, "Wrong size on UOrionEULAStyleData");
static_assert(offsetof(UOrionEULAStyleData, EULARichTextStyle) == 0x000030, "Member 'UOrionEULAStyleData::EULARichTextStyle' has a wrong offset!");
static_assert(offsetof(UOrionEULAStyleData, EULAHeaderStyle) == 0x0001F8, "Member 'UOrionEULAStyleData::EULAHeaderStyle' has a wrong offset!");
static_assert(offsetof(UOrionEULAStyleData, EULASubHeaderStyle) == 0x0003C0, "Member 'UOrionEULAStyleData::EULASubHeaderStyle' has a wrong offset!");
static_assert(offsetof(UOrionEULAStyleData, EULAHighlightItalicstyle) == 0x000588, "Member 'UOrionEULAStyleData::EULAHighlightItalicstyle' has a wrong offset!");
static_assert(offsetof(UOrionEULAStyleData, EULAHighlightStyle) == 0x000750, "Member 'UOrionEULAStyleData::EULAHighlightStyle' has a wrong offset!");
static_assert(offsetof(UOrionEULAStyleData, EULAHyperLinkRichTextStyle) == 0x000918, "Member 'UOrionEULAStyleData::EULAHyperLinkRichTextStyle' has a wrong offset!");
static_assert(offsetof(UOrionEULAStyleData, EULAHyperlinkButtonStyle) == 0x000AE0, "Member 'UOrionEULAStyleData::EULAHyperlinkButtonStyle' has a wrong offset!");
static_assert(offsetof(UOrionEULAStyleData, EULAScrollBarStyle) == 0x000D18, "Member 'UOrionEULAStyleData::EULAScrollBarStyle' has a wrong offset!");

// Class OrionGame.OrionStyleData
// 0x0130 (0x0160 - 0x0030)
class UOrionStyleData final : public UDataAsset
{
public:
	TArray<struct FOrionStyleEntry>               Styles;                                            // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USocialAsset>            SocialStyle;                                       // 0x0040(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UOrionEULAStyleData>     EULAStyle;                                         // 0x0068(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            LoadingScreenImage;                                // 0x0090(0x0078)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         LoadingScreenFont;                                 // 0x0108(0x0058)(Edit, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionStyleData">();
	}
	static class UOrionStyleData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionStyleData>();
	}
};
static_assert(alignof(UOrionStyleData) == 0x000008, "Wrong alignment on UOrionStyleData");
static_assert(sizeof(UOrionStyleData) == 0x000160, "Wrong size on UOrionStyleData");
static_assert(offsetof(UOrionStyleData, Styles) == 0x000030, "Member 'UOrionStyleData::Styles' has a wrong offset!");
static_assert(offsetof(UOrionStyleData, SocialStyle) == 0x000040, "Member 'UOrionStyleData::SocialStyle' has a wrong offset!");
static_assert(offsetof(UOrionStyleData, EULAStyle) == 0x000068, "Member 'UOrionStyleData::EULAStyle' has a wrong offset!");
static_assert(offsetof(UOrionStyleData, LoadingScreenImage) == 0x000090, "Member 'UOrionStyleData::LoadingScreenImage' has a wrong offset!");
static_assert(offsetof(UOrionStyleData, LoadingScreenFont) == 0x000108, "Member 'UOrionStyleData::LoadingScreenFont' has a wrong offset!");

// Class OrionGame.OrionSurveyConfig
// 0x0060 (0x0088 - 0x0028)
class UOrionSurveyConfig final : public UObject
{
public:
	uint32                                        TrainingSurveyChancePercent;                       // 0x0028(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           TrainingQuestionGroup;                             // 0x0030(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	uint32                                        PvPSurveyChancePercent;                            // 0x0040(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           PvPQuestionGroup;                                  // 0x0048(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	uint32                                        CoopSurveyChancePercent;                           // 0x0058(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           CoopQuestionGroup;                                 // 0x0060(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	uint32                                        SoloSurveyChancePercent;                           // 0x0070(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           SoloQuestionGroup;                                 // 0x0078(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionSurveyConfig">();
	}
	static class UOrionSurveyConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionSurveyConfig>();
	}
};
static_assert(alignof(UOrionSurveyConfig) == 0x000008, "Wrong alignment on UOrionSurveyConfig");
static_assert(sizeof(UOrionSurveyConfig) == 0x000088, "Wrong size on UOrionSurveyConfig");
static_assert(offsetof(UOrionSurveyConfig, TrainingSurveyChancePercent) == 0x000028, "Member 'UOrionSurveyConfig::TrainingSurveyChancePercent' has a wrong offset!");
static_assert(offsetof(UOrionSurveyConfig, TrainingQuestionGroup) == 0x000030, "Member 'UOrionSurveyConfig::TrainingQuestionGroup' has a wrong offset!");
static_assert(offsetof(UOrionSurveyConfig, PvPSurveyChancePercent) == 0x000040, "Member 'UOrionSurveyConfig::PvPSurveyChancePercent' has a wrong offset!");
static_assert(offsetof(UOrionSurveyConfig, PvPQuestionGroup) == 0x000048, "Member 'UOrionSurveyConfig::PvPQuestionGroup' has a wrong offset!");
static_assert(offsetof(UOrionSurveyConfig, CoopSurveyChancePercent) == 0x000058, "Member 'UOrionSurveyConfig::CoopSurveyChancePercent' has a wrong offset!");
static_assert(offsetof(UOrionSurveyConfig, CoopQuestionGroup) == 0x000060, "Member 'UOrionSurveyConfig::CoopQuestionGroup' has a wrong offset!");
static_assert(offsetof(UOrionSurveyConfig, SoloSurveyChancePercent) == 0x000070, "Member 'UOrionSurveyConfig::SoloSurveyChancePercent' has a wrong offset!");
static_assert(offsetof(UOrionSurveyConfig, SoloQuestionGroup) == 0x000078, "Member 'UOrionSurveyConfig::SoloQuestionGroup' has a wrong offset!");

// Class OrionGame.OrionSurveyDisplayData
// 0x0028 (0x0058 - 0x0030)
class UOrionSurveyDisplayData final : public UDataAsset
{
public:
	TArray<struct FOrionQuestionGroupInfo>        QuestionGroups;                                    // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         NumResponseValues;                                 // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           ResponseDescriptions;                              // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionSurveyDisplayData">();
	}
	static class UOrionSurveyDisplayData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionSurveyDisplayData>();
	}
};
static_assert(alignof(UOrionSurveyDisplayData) == 0x000008, "Wrong alignment on UOrionSurveyDisplayData");
static_assert(sizeof(UOrionSurveyDisplayData) == 0x000058, "Wrong size on UOrionSurveyDisplayData");
static_assert(offsetof(UOrionSurveyDisplayData, QuestionGroups) == 0x000030, "Member 'UOrionSurveyDisplayData::QuestionGroups' has a wrong offset!");
static_assert(offsetof(UOrionSurveyDisplayData, NumResponseValues) == 0x000040, "Member 'UOrionSurveyDisplayData::NumResponseValues' has a wrong offset!");
static_assert(offsetof(UOrionSurveyDisplayData, ResponseDescriptions) == 0x000048, "Member 'UOrionSurveyDisplayData::ResponseDescriptions' has a wrong offset!");

// Class OrionGame.OrionTaggedContainer
// 0x0020 (0x0130 - 0x0110)
class UOrionTaggedContainer final : public UContentWidget
{
public:
	class FName                                   WidgetId;                                          // 0x0110(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EMenuPlacement                                AttachedMessagePlacement;                          // 0x0118(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_119[0x17];                                     // 0x0119(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTaggedContainer">();
	}
	static class UOrionTaggedContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionTaggedContainer>();
	}
};
static_assert(alignof(UOrionTaggedContainer) == 0x000008, "Wrong alignment on UOrionTaggedContainer");
static_assert(sizeof(UOrionTaggedContainer) == 0x000130, "Wrong size on UOrionTaggedContainer");
static_assert(offsetof(UOrionTaggedContainer, WidgetId) == 0x000110, "Member 'UOrionTaggedContainer::WidgetId' has a wrong offset!");
static_assert(offsetof(UOrionTaggedContainer, AttachedMessagePlacement) == 0x000118, "Member 'UOrionTaggedContainer::AttachedMessagePlacement' has a wrong offset!");

// Class OrionGame.OrionTagTableMerger
// 0x0018 (0x0040 - 0x0028)
class UOrionTagTableMerger final : public UObject
{
public:
	bool                                          PerformBackupOnStartup;                            // 0x0028(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOrionTagTableMergeSet>         TableSets;                                         // 0x0030(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTagTableMerger">();
	}
	static class UOrionTagTableMerger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionTagTableMerger>();
	}
};
static_assert(alignof(UOrionTagTableMerger) == 0x000008, "Wrong alignment on UOrionTagTableMerger");
static_assert(sizeof(UOrionTagTableMerger) == 0x000040, "Wrong size on UOrionTagTableMerger");
static_assert(offsetof(UOrionTagTableMerger, PerformBackupOnStartup) == 0x000028, "Member 'UOrionTagTableMerger::PerformBackupOnStartup' has a wrong offset!");
static_assert(offsetof(UOrionTagTableMerger, TableSets) == 0x000030, "Member 'UOrionTagTableMerger::TableSets' has a wrong offset!");

// Class OrionGame.OrionTargetingFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UOrionTargetingFunctionLibrary final : public UObject
{
public:
	static struct FGameplayAbilityTargetDataHandle SphereAroundActor(class AActor* TargetingActor, class AActor* AroundActor, float Radius, const struct FOrionActorFilter& Filter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTargetingFunctionLibrary">();
	}
	static class UOrionTargetingFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionTargetingFunctionLibrary>();
	}
};
static_assert(alignof(UOrionTargetingFunctionLibrary) == 0x000008, "Wrong alignment on UOrionTargetingFunctionLibrary");
static_assert(sizeof(UOrionTargetingFunctionLibrary) == 0x000028, "Wrong size on UOrionTargetingFunctionLibrary");

// Class OrionGame.OrionTargetingInterface
// 0x0000 (0x0028 - 0x0028)
class IOrionTargetingInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTargetingInterface">();
	}
	static class IOrionTargetingInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOrionTargetingInterface>();
	}
};
static_assert(alignof(IOrionTargetingInterface) == 0x000008, "Wrong alignment on IOrionTargetingInterface");
static_assert(sizeof(IOrionTargetingInterface) == 0x000028, "Wrong size on IOrionTargetingInterface");

// Class OrionGame.OrionTBRoboCaptain
// 0x03B8 (0x03E0 - 0x0028)
class UOrionTBRoboCaptain final : public UObject
{
public:
	float                                         MatchmakeRetryDelay;                               // 0x0028(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WaitForSocialMembersTimeout;                       // 0x002C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AbandonTeamCompTimeout;                            // 0x0030(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CheckShouldBecomeCaptainInterval;                  // 0x0034(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FSkillRatingTimeRestriction>    ChanceToBecomeCaptain;                             // 0x0038(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	class UOrionTeamBuilder*                      TeamBuilder;                                       // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionTeamComposer*                     TeamComposer;                                      // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionTBSkillRatingTimer*               ChanceToBecomeCaptainTimer;                        // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FOrionTBParams                         Params_0;                                          // 0x0060(0x0160)(Transient, NativeAccessSpecifierPrivate)
	ETBRoboCaptainState                           CurrentState;                                      // 0x01C0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHandlingError;                                    // 0x01C1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCancelMMToBuildTeam;                              // 0x01C2(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C3[0x1AD];                                    // 0x01C3(0x01AD)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionTeamCompDebugData                TeamCompDebugData;                                 // 0x0370(0x0018)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_388[0x58];                                     // 0x0388(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTBRoboCaptain">();
	}
	static class UOrionTBRoboCaptain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionTBRoboCaptain>();
	}
};
static_assert(alignof(UOrionTBRoboCaptain) == 0x000008, "Wrong alignment on UOrionTBRoboCaptain");
static_assert(sizeof(UOrionTBRoboCaptain) == 0x0003E0, "Wrong size on UOrionTBRoboCaptain");
static_assert(offsetof(UOrionTBRoboCaptain, MatchmakeRetryDelay) == 0x000028, "Member 'UOrionTBRoboCaptain::MatchmakeRetryDelay' has a wrong offset!");
static_assert(offsetof(UOrionTBRoboCaptain, WaitForSocialMembersTimeout) == 0x00002C, "Member 'UOrionTBRoboCaptain::WaitForSocialMembersTimeout' has a wrong offset!");
static_assert(offsetof(UOrionTBRoboCaptain, AbandonTeamCompTimeout) == 0x000030, "Member 'UOrionTBRoboCaptain::AbandonTeamCompTimeout' has a wrong offset!");
static_assert(offsetof(UOrionTBRoboCaptain, CheckShouldBecomeCaptainInterval) == 0x000034, "Member 'UOrionTBRoboCaptain::CheckShouldBecomeCaptainInterval' has a wrong offset!");
static_assert(offsetof(UOrionTBRoboCaptain, ChanceToBecomeCaptain) == 0x000038, "Member 'UOrionTBRoboCaptain::ChanceToBecomeCaptain' has a wrong offset!");
static_assert(offsetof(UOrionTBRoboCaptain, TeamBuilder) == 0x000048, "Member 'UOrionTBRoboCaptain::TeamBuilder' has a wrong offset!");
static_assert(offsetof(UOrionTBRoboCaptain, TeamComposer) == 0x000050, "Member 'UOrionTBRoboCaptain::TeamComposer' has a wrong offset!");
static_assert(offsetof(UOrionTBRoboCaptain, ChanceToBecomeCaptainTimer) == 0x000058, "Member 'UOrionTBRoboCaptain::ChanceToBecomeCaptainTimer' has a wrong offset!");
static_assert(offsetof(UOrionTBRoboCaptain, Params_0) == 0x000060, "Member 'UOrionTBRoboCaptain::Params_0' has a wrong offset!");
static_assert(offsetof(UOrionTBRoboCaptain, CurrentState) == 0x0001C0, "Member 'UOrionTBRoboCaptain::CurrentState' has a wrong offset!");
static_assert(offsetof(UOrionTBRoboCaptain, bHandlingError) == 0x0001C1, "Member 'UOrionTBRoboCaptain::bHandlingError' has a wrong offset!");
static_assert(offsetof(UOrionTBRoboCaptain, bCancelMMToBuildTeam) == 0x0001C2, "Member 'UOrionTBRoboCaptain::bCancelMMToBuildTeam' has a wrong offset!");
static_assert(offsetof(UOrionTBRoboCaptain, TeamCompDebugData) == 0x000370, "Member 'UOrionTBRoboCaptain::TeamCompDebugData' has a wrong offset!");

// Class OrionGame.OrionTBSkillRatingTimer
// 0x0028 (0x0050 - 0x0028)
class UOrionTBSkillRatingTimer final : public UObject
{
public:
	float                                         RatingScale;                                       // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeScale;                                         // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTBSkillRatingTimer">();
	}
	static class UOrionTBSkillRatingTimer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionTBSkillRatingTimer>();
	}
};
static_assert(alignof(UOrionTBSkillRatingTimer) == 0x000008, "Wrong alignment on UOrionTBSkillRatingTimer");
static_assert(sizeof(UOrionTBSkillRatingTimer) == 0x000050, "Wrong size on UOrionTBSkillRatingTimer");
static_assert(offsetof(UOrionTBSkillRatingTimer, RatingScale) == 0x000028, "Member 'UOrionTBSkillRatingTimer::RatingScale' has a wrong offset!");
static_assert(offsetof(UOrionTBSkillRatingTimer, TimeScale) == 0x00002C, "Member 'UOrionTBSkillRatingTimer::TimeScale' has a wrong offset!");

// Class OrionGame.OrionTBStats
// 0x02A0 (0x02C8 - 0x0028)
class UOrionTBStats final : public UObject
{
public:
	uint8                                         Pad_28[0x289];                                     // 0x0028(0x0289)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsRecordingSoloDuration;                          // 0x02B1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsRecordingTeamDuration;                          // 0x02B2(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsRecordingEnemyDuration;                         // 0x02B3(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B4[0x14];                                     // 0x02B4(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTBStats">();
	}
	static class UOrionTBStats* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionTBStats>();
	}
};
static_assert(alignof(UOrionTBStats) == 0x000008, "Wrong alignment on UOrionTBStats");
static_assert(sizeof(UOrionTBStats) == 0x0002C8, "Wrong size on UOrionTBStats");
static_assert(offsetof(UOrionTBStats, bIsRecordingSoloDuration) == 0x0002B1, "Member 'UOrionTBStats::bIsRecordingSoloDuration' has a wrong offset!");
static_assert(offsetof(UOrionTBStats, bIsRecordingTeamDuration) == 0x0002B2, "Member 'UOrionTBStats::bIsRecordingTeamDuration' has a wrong offset!");
static_assert(offsetof(UOrionTBStats, bIsRecordingEnemyDuration) == 0x0002B3, "Member 'UOrionTBStats::bIsRecordingEnemyDuration' has a wrong offset!");

// Class OrionGame.OrionTeamBuilderParty
// 0x0AD0 (0x1130 - 0x0660)
class UOrionTeamBuilderParty final : public UOrionPartyGameState
{
public:
	struct FOrionTeamBuilderRepState              TeamBuilderState;                                  // 0x0660(0x0090)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_6F0[0xA40];                                    // 0x06F0(0x0A40)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTeamBuilderParty">();
	}
	static class UOrionTeamBuilderParty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionTeamBuilderParty>();
	}
};
static_assert(alignof(UOrionTeamBuilderParty) == 0x000008, "Wrong alignment on UOrionTeamBuilderParty");
static_assert(sizeof(UOrionTeamBuilderParty) == 0x001130, "Wrong size on UOrionTeamBuilderParty");
static_assert(offsetof(UOrionTeamBuilderParty, TeamBuilderState) == 0x000660, "Member 'UOrionTeamBuilderParty::TeamBuilderState' has a wrong offset!");

// Class OrionGame.OrionTeamBuilderPartyMember
// 0x0160 (0x0270 - 0x0110)
class UOrionTeamBuilderPartyMember final : public UOrionPartyMemberState
{
public:
	struct FOrionTeamBuilderPartyMemberRepState   TeamBuilderMemberState;                            // 0x0110(0x0070)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_180[0xF0];                                     // 0x0180(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetDeck(const class FString& DeckId);
	void SetHeroName(const class FString& HeroName);
	void SetPlatform(EOrionPlayerPlatform InPlatform);
	void SetPosition(EOrionPosition Position);
	void SetReady(bool InReady);
	void SetRole(EOrionRole Role);

	struct FOrionCosmeticPlayerChoices GetCosmeticChoices() const;
	class FString GetDeck() const;
	class FString GetHeroName() const;
	EOrionPlayerPlatform GetPlatform() const;
	EOrionPosition GetPosition() const;
	EOrionRole GetRole() const;
	int32 GetSlotIdx() const;
	bool IsDirty(EOrionTeamBuilderPartyMemberStateFlags Flag) const;
	bool IsReady() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTeamBuilderPartyMember">();
	}
	static class UOrionTeamBuilderPartyMember* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionTeamBuilderPartyMember>();
	}
};
static_assert(alignof(UOrionTeamBuilderPartyMember) == 0x000008, "Wrong alignment on UOrionTeamBuilderPartyMember");
static_assert(sizeof(UOrionTeamBuilderPartyMember) == 0x000270, "Wrong size on UOrionTeamBuilderPartyMember");
static_assert(offsetof(UOrionTeamBuilderPartyMember, TeamBuilderMemberState) == 0x000110, "Member 'UOrionTeamBuilderPartyMember::TeamBuilderMemberState' has a wrong offset!");

// Class OrionGame.OrionTeamColorComponent
// 0x0050 (0x02E0 - 0x0290)
class UOrionTeamColorComponent final : public USceneComponent
{
public:
	class UMaterialInterface*                     Material;                                          // 0x0290(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaterialIndex;                                     // 0x0298(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ParameterNames;                                    // 0x02A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 ElementIndices;                                    // 0x02B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bColorOnDeath;                                     // 0x02C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C1[0x3];                                      // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           DeathColor;                                        // 0x02C4(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D4[0xC];                                      // 0x02D4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetupTeamColors(EOrionTeam TeamNum, bool bIsDead);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTeamColorComponent">();
	}
	static class UOrionTeamColorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionTeamColorComponent>();
	}
};
static_assert(alignof(UOrionTeamColorComponent) == 0x000008, "Wrong alignment on UOrionTeamColorComponent");
static_assert(sizeof(UOrionTeamColorComponent) == 0x0002E0, "Wrong size on UOrionTeamColorComponent");
static_assert(offsetof(UOrionTeamColorComponent, Material) == 0x000290, "Member 'UOrionTeamColorComponent::Material' has a wrong offset!");
static_assert(offsetof(UOrionTeamColorComponent, MaterialIndex) == 0x000298, "Member 'UOrionTeamColorComponent::MaterialIndex' has a wrong offset!");
static_assert(offsetof(UOrionTeamColorComponent, ParameterNames) == 0x0002A0, "Member 'UOrionTeamColorComponent::ParameterNames' has a wrong offset!");
static_assert(offsetof(UOrionTeamColorComponent, ElementIndices) == 0x0002B0, "Member 'UOrionTeamColorComponent::ElementIndices' has a wrong offset!");
static_assert(offsetof(UOrionTeamColorComponent, bColorOnDeath) == 0x0002C0, "Member 'UOrionTeamColorComponent::bColorOnDeath' has a wrong offset!");
static_assert(offsetof(UOrionTeamColorComponent, DeathColor) == 0x0002C4, "Member 'UOrionTeamColorComponent::DeathColor' has a wrong offset!");

// Class OrionGame.OrionTeamInfo
// 0x0568 (0x0880 - 0x0318)
class AOrionTeamInfo final : public AInfo
{
public:
	uint8                                         Pad_318[0x158];                                    // 0x0318(0x0158)(Fixing Size After Last Property [ Dumper-7 ])
	EOrionTeam                                    TeamIndex;                                         // 0x0470(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_471[0x7];                                      // 0x0471(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TeamName;                                          // 0x0478(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayerTeam;                                       // 0x0480(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_481[0x3];                                      // 0x0481(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxPlayers;                                        // 0x0484(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TeamKills;                                         // 0x0488(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TeamDeaths;                                        // 0x048C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TeamAssists;                                       // 0x0490(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TeamMinionKills;                                   // 0x0494(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TeamTowerKills;                                    // 0x0498(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TeamTowerTakedowns;                                // 0x049C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TeamInhibitorKills;                                // 0x04A0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TeamInhibitorTakedowns;                            // 0x04A4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TeamPlacedRigs;                                    // 0x04A8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TeamDestroyedRigs;                                 // 0x04AC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DragonKills;                                       // 0x04B0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B4[0x4];                                      // 0x04B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         PlayerCardPointCurve;                              // 0x04B8(0x0028)(Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         PrimeHelixTimeCurve;                               // 0x04E0(0x0028)(Protected, NativeAccessSpecifierProtected)
	TArray<class AController*>                    TeamMembers;                                       // 0x0508(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AController*>                    TeamChumps;                                        // 0x0518(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UOrionAIFormation*>              TeamAIFormations;                                  // 0x0528(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         XPTrickleRate;                                     // 0x0538(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_53C[0x4];                                      // 0x053C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            PrimeHelixBuffEffect;                              // 0x0540(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FOrionTBTeamInfo                       TeamBuilderInfo;                                   // 0x0548(0x0188)(Net, Protected, NativeAccessSpecifierProtected)
	ETeamSurrenderStatus                          SurrenderVoteStatus;                               // 0x06D0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6D1[0x7];                                      // 0x06D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrionPlayerState_Game*                 SurrenderVoteInstigator;                           // 0x06D8(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SurrenderVoteTimeLimitSeconds;                     // 0x06E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SurrenderVoteInitialCooldownSeconds;               // 0x06E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SurrenderVoteCooldownSeconds;                      // 0x06E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SurrenderVoteSecondsRemaining;                     // 0x06EC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SurrenderVoteCooldownSecondsRemaining;             // 0x06F0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SurrenderNumberOfEligibleVoters;                   // 0x06F4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SurrenderNumberOfVotesRequired;                    // 0x06F8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SurrenderNumberOfPlayersVoted;                     // 0x06FC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSurrenderBallot>               SurrenderVotes;                                    // 0x0700(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_710[0x170];                                    // 0x0710(0x0170)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class AController*> GetPlayerArray();
	void OnRep_DragonKills();
	void OnRep_SurrenderVoteInstigator();
	void OnRep_SurrenderVoteStatus();
	void OnRep_XPTrickleRate();
	void UpdateXPTrickleRate();

	int32 GetDragonKillCount() const;
	int32 GetMaxPlayers() const;
	int32 GetNumPlayersOnTeam() const;
	class FText GetSurrenderButtonText() const;
	int32 GetSurrenderVoteCooldownSecondsRemaining() const;
	int32 GetSurrenderVoteSecondsRemaining() const;
	ETeamSurrenderStatus GetSurrenderVoteStatus() const;
	float GetSurrenderVoteText(class FText* VoteText) const;
	int32 GetTeamAssists() const;
	struct FOrionTBTeamInfo GetTeamBuilderInfo() const;
	int32 GetTeamDeaths() const;
	int32 GetTeamDestroyedRigs() const;
	int32 GetTeamInhibitorKills() const;
	int32 GetTeamInhibitorTakedowns() const;
	int32 GetTeamKills() const;
	int32 GetTeamMinionKills() const;
	int32 GetTeamPlacedRigs() const;
	int32 GetTeamTowerKills() const;
	int32 GetTeamTowerTakedowns() const;
	float GetXPTrickleRate() const;
	bool HasRoomForAPlayer() const;
	bool IsPlayerTeam() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTeamInfo">();
	}
	static class AOrionTeamInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionTeamInfo>();
	}
};
static_assert(alignof(AOrionTeamInfo) == 0x000008, "Wrong alignment on AOrionTeamInfo");
static_assert(sizeof(AOrionTeamInfo) == 0x000880, "Wrong size on AOrionTeamInfo");
static_assert(offsetof(AOrionTeamInfo, TeamIndex) == 0x000470, "Member 'AOrionTeamInfo::TeamIndex' has a wrong offset!");
static_assert(offsetof(AOrionTeamInfo, TeamName) == 0x000478, "Member 'AOrionTeamInfo::TeamName' has a wrong offset!");
static_assert(offsetof(AOrionTeamInfo, bPlayerTeam) == 0x000480, "Member 'AOrionTeamInfo::bPlayerTeam' has a wrong offset!");
static_assert(offsetof(AOrionTeamInfo, MaxPlayers) == 0x000484, "Member 'AOrionTeamInfo::MaxPlayers' has a wrong offset!");
static_assert(offsetof(AOrionTeamInfo, TeamKills) == 0x000488, "Member 'AOrionTeamInfo::TeamKills' has a wrong offset!");
static_assert(offsetof(AOrionTeamInfo, TeamDeaths) == 0x00048C, "Member 'AOrionTeamInfo::TeamDeaths' has a wrong offset!");
static_assert(offsetof(AOrionTeamInfo, TeamAssists) == 0x000490, "Member 'AOrionTeamInfo::TeamAssists' has a wrong offset!");
static_assert(offsetof(AOrionTeamInfo, TeamMinionKills) == 0x000494, "Member 'AOrionTeamInfo::TeamMinionKills' has a wrong offset!");
static_assert(offsetof(AOrionTeamInfo, TeamTowerKills) == 0x000498, "Member 'AOrionTeamInfo::TeamTowerKills' has a wrong offset!");
static_assert(offsetof(AOrionTeamInfo, TeamTowerTakedowns) == 0x00049C, "Member 'AOrionTeamInfo::TeamTowerTakedowns' has a wrong offset!");
static_assert(offsetof(AOrionTeamInfo, TeamInhibitorKills) == 0x0004A0, "Member 'AOrionTeamInfo::TeamInhibitorKills' has a wrong offset!");
static_assert(offsetof(AOrionTeamInfo, TeamInhibitorTakedowns) == 0x0004A4, "Member 'AOrionTeamInfo::TeamInhibitorTakedowns' has a wrong offset!");
static_assert(offsetof(AOrionTeamInfo, TeamPlacedRigs) == 0x0004A8, "Member 'AOrionTeamInfo::TeamPlacedRigs' has a wrong offset!");
static_assert(offsetof(AOrionTeamInfo, TeamDestroyedRigs) == 0x0004AC, "Member 'AOrionTeamInfo::TeamDestroyedRigs' has a wrong offset!");
static_assert(offsetof(AOrionTeamInfo, DragonKills) == 0x0004B0, "Member 'AOrionTeamInfo::DragonKills' has a wrong offset!");
static_assert(offsetof(AOrionTeamInfo, PlayerCardPointCurve) == 0x0004B8, "Member 'AOrionTeamInfo::PlayerCardPointCurve' has a wrong offset!");
static_assert(offsetof(AOrionTeamInfo, PrimeHelixTimeCurve) == 0x0004E0, "Member 'AOrionTeamInfo::PrimeHelixTimeCurve' has a wrong offset!");
static_assert(offsetof(AOrionTeamInfo, TeamMembers) == 0x000508, "Member 'AOrionTeamInfo::TeamMembers' has a wrong offset!");
static_assert(offsetof(AOrionTeamInfo, TeamChumps) == 0x000518, "Member 'AOrionTeamInfo::TeamChumps' has a wrong offset!");
static_assert(offsetof(AOrionTeamInfo, TeamAIFormations) == 0x000528, "Member 'AOrionTeamInfo::TeamAIFormations' has a wrong offset!");
static_assert(offsetof(AOrionTeamInfo, XPTrickleRate) == 0x000538, "Member 'AOrionTeamInfo::XPTrickleRate' has a wrong offset!");
static_assert(offsetof(AOrionTeamInfo, PrimeHelixBuffEffect) == 0x000540, "Member 'AOrionTeamInfo::PrimeHelixBuffEffect' has a wrong offset!");
static_assert(offsetof(AOrionTeamInfo, TeamBuilderInfo) == 0x000548, "Member 'AOrionTeamInfo::TeamBuilderInfo' has a wrong offset!");
static_assert(offsetof(AOrionTeamInfo, SurrenderVoteStatus) == 0x0006D0, "Member 'AOrionTeamInfo::SurrenderVoteStatus' has a wrong offset!");
static_assert(offsetof(AOrionTeamInfo, SurrenderVoteInstigator) == 0x0006D8, "Member 'AOrionTeamInfo::SurrenderVoteInstigator' has a wrong offset!");
static_assert(offsetof(AOrionTeamInfo, SurrenderVoteTimeLimitSeconds) == 0x0006E0, "Member 'AOrionTeamInfo::SurrenderVoteTimeLimitSeconds' has a wrong offset!");
static_assert(offsetof(AOrionTeamInfo, SurrenderVoteInitialCooldownSeconds) == 0x0006E4, "Member 'AOrionTeamInfo::SurrenderVoteInitialCooldownSeconds' has a wrong offset!");
static_assert(offsetof(AOrionTeamInfo, SurrenderVoteCooldownSeconds) == 0x0006E8, "Member 'AOrionTeamInfo::SurrenderVoteCooldownSeconds' has a wrong offset!");
static_assert(offsetof(AOrionTeamInfo, SurrenderVoteSecondsRemaining) == 0x0006EC, "Member 'AOrionTeamInfo::SurrenderVoteSecondsRemaining' has a wrong offset!");
static_assert(offsetof(AOrionTeamInfo, SurrenderVoteCooldownSecondsRemaining) == 0x0006F0, "Member 'AOrionTeamInfo::SurrenderVoteCooldownSecondsRemaining' has a wrong offset!");
static_assert(offsetof(AOrionTeamInfo, SurrenderNumberOfEligibleVoters) == 0x0006F4, "Member 'AOrionTeamInfo::SurrenderNumberOfEligibleVoters' has a wrong offset!");
static_assert(offsetof(AOrionTeamInfo, SurrenderNumberOfVotesRequired) == 0x0006F8, "Member 'AOrionTeamInfo::SurrenderNumberOfVotesRequired' has a wrong offset!");
static_assert(offsetof(AOrionTeamInfo, SurrenderNumberOfPlayersVoted) == 0x0006FC, "Member 'AOrionTeamInfo::SurrenderNumberOfPlayersVoted' has a wrong offset!");
static_assert(offsetof(AOrionTeamInfo, SurrenderVotes) == 0x000700, "Member 'AOrionTeamInfo::SurrenderVotes' has a wrong offset!");

// Class OrionGame.OrionTestControllerAssetReport
// 0x0008 (0x0058 - 0x0050)
class UOrionTestControllerAssetReport final : public UOrionTestControllerBase
{
public:
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTestControllerAssetReport">();
	}
	static class UOrionTestControllerAssetReport* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionTestControllerAssetReport>();
	}
};
static_assert(alignof(UOrionTestControllerAssetReport) == 0x000008, "Wrong alignment on UOrionTestControllerAssetReport");
static_assert(sizeof(UOrionTestControllerAssetReport) == 0x000058, "Wrong size on UOrionTestControllerAssetReport");

// Class OrionGame.OrionTestControllerBootTest
// 0x0000 (0x0050 - 0x0050)
class UOrionTestControllerBootTest final : public UOrionTestControllerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTestControllerBootTest">();
	}
	static class UOrionTestControllerBootTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionTestControllerBootTest>();
	}
};
static_assert(alignof(UOrionTestControllerBootTest) == 0x000008, "Wrong alignment on UOrionTestControllerBootTest");
static_assert(sizeof(UOrionTestControllerBootTest) == 0x000050, "Wrong size on UOrionTestControllerBootTest");

// Class OrionGame.OrionTestControllerDelayedExec
// 0x0010 (0x0060 - 0x0050)
class UOrionTestControllerDelayedExec final : public UOrionTestControllerBase
{
public:
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTestControllerDelayedExec">();
	}
	static class UOrionTestControllerDelayedExec* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionTestControllerDelayedExec>();
	}
};
static_assert(alignof(UOrionTestControllerDelayedExec) == 0x000008, "Wrong alignment on UOrionTestControllerDelayedExec");
static_assert(sizeof(UOrionTestControllerDelayedExec) == 0x000060, "Wrong size on UOrionTestControllerDelayedExec");

// Class OrionGame.OrionTestControllerLoadTest
// 0x0040 (0x0090 - 0x0050)
class UOrionTestControllerLoadTest final : public UOrionTestControllerBase
{
public:
	uint8                                         Pad_50[0x40];                                      // 0x0050(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTestControllerLoadTest">();
	}
	static class UOrionTestControllerLoadTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionTestControllerLoadTest>();
	}
};
static_assert(alignof(UOrionTestControllerLoadTest) == 0x000008, "Wrong alignment on UOrionTestControllerLoadTest");
static_assert(sizeof(UOrionTestControllerLoadTest) == 0x000090, "Wrong size on UOrionTestControllerLoadTest");

// Class OrionGame.OrionTestControllerMemoryReport
// 0x0070 (0x00C0 - 0x0050)
class UOrionTestControllerMemoryReport final : public UOrionTestControllerBase
{
public:
	uint8                                         Pad_50[0x70];                                      // 0x0050(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTestControllerMemoryReport">();
	}
	static class UOrionTestControllerMemoryReport* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionTestControllerMemoryReport>();
	}
};
static_assert(alignof(UOrionTestControllerMemoryReport) == 0x000008, "Wrong alignment on UOrionTestControllerMemoryReport");
static_assert(sizeof(UOrionTestControllerMemoryReport) == 0x0000C0, "Wrong size on UOrionTestControllerMemoryReport");

// Class OrionGame.OrionTextStyle
// 0x0200 (0x0228 - 0x0028)
class UOrionTextStyle : public UObject
{
public:
	struct FSlateFontInfo                         Font[0x3];                                         // 0x0028(0x0058)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color[0x5];                                        // 0x0130(0x0010)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ShadowOffset[0x3];                                 // 0x0180(0x0008)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ShadowColor[0x5];                                  // 0x0198(0x0010)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMargin                                Margin[0x3];                                       // 0x01E8(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LineHeightPercentage[0x3];                         // 0x0218(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_224[0x4];                                      // 0x0224(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetColor(EOrionTextColor ColorType, struct FLinearColor* OutColor) const;
	void GetFont(EOrionWidgetStyleSize Size, struct FSlateFontInfo* OutFont) const;
	float GetLineHeightPercentage(EOrionWidgetStyleSize Size) const;
	void GetMargin(EOrionWidgetStyleSize Size, struct FMargin* OutMargin) const;
	void GetShadowColor(EOrionTextColor ColorType, struct FLinearColor* OutColor) const;
	void GetShadowOffset(EOrionWidgetStyleSize Size, struct FVector2D* OutShadowOffset) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTextStyle">();
	}
	static class UOrionTextStyle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionTextStyle>();
	}
};
static_assert(alignof(UOrionTextStyle) == 0x000008, "Wrong alignment on UOrionTextStyle");
static_assert(sizeof(UOrionTextStyle) == 0x000228, "Wrong size on UOrionTextStyle");
static_assert(offsetof(UOrionTextStyle, Font) == 0x000028, "Member 'UOrionTextStyle::Font' has a wrong offset!");
static_assert(offsetof(UOrionTextStyle, Color) == 0x000130, "Member 'UOrionTextStyle::Color' has a wrong offset!");
static_assert(offsetof(UOrionTextStyle, ShadowOffset) == 0x000180, "Member 'UOrionTextStyle::ShadowOffset' has a wrong offset!");
static_assert(offsetof(UOrionTextStyle, ShadowColor) == 0x000198, "Member 'UOrionTextStyle::ShadowColor' has a wrong offset!");
static_assert(offsetof(UOrionTextStyle, Margin) == 0x0001E8, "Member 'UOrionTextStyle::Margin' has a wrong offset!");
static_assert(offsetof(UOrionTextStyle, LineHeightPercentage) == 0x000218, "Member 'UOrionTextStyle::LineHeightPercentage' has a wrong offset!");

// Class OrionGame.OrionTextBlock
// 0x0060 (0x0278 - 0x0218)
class UOrionTextBlock final : public UTextBlock
{
public:
	TSubclassOf<class UOrionTextStyle>            Style;                                             // 0x0218(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrionWidgetStyleSize                         StyleSize;                                         // 0x0220(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrionTextColor                               ColorType;                                         // 0x0221(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseDropShadow;                                    // 0x0222(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllCaps;                                          // 0x0223(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bScroll;                                           // 0x0224(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_225[0x3];                                      // 0x0225(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Speed;                                             // 0x0228(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartDelay;                                        // 0x022C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndDelay;                                          // 0x0230(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeInDelay;                                       // 0x0234(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeOutDelay;                                      // 0x0238(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23C[0x3C];                                     // 0x023C(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetColorType(EOrionTextColor Color);
	void SetProperties(TSubclassOf<class UOrionTextStyle> InStyle, EOrionWidgetStyleSize Size, EOrionTextColor Color, int32 InWrapTextAt, bool bShouldUseDropShadow);
	void SetSize(EOrionWidgetStyleSize Size);
	void SetStyle(TSubclassOf<class UOrionTextStyle> InStyle);
	void SetUseDropShadow(bool bShouldUseDropShadow);
	void SetWrapTextWidth(int32 InWrapTextAt);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTextBlock">();
	}
	static class UOrionTextBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionTextBlock>();
	}
};
static_assert(alignof(UOrionTextBlock) == 0x000008, "Wrong alignment on UOrionTextBlock");
static_assert(sizeof(UOrionTextBlock) == 0x000278, "Wrong size on UOrionTextBlock");
static_assert(offsetof(UOrionTextBlock, Style) == 0x000218, "Member 'UOrionTextBlock::Style' has a wrong offset!");
static_assert(offsetof(UOrionTextBlock, StyleSize) == 0x000220, "Member 'UOrionTextBlock::StyleSize' has a wrong offset!");
static_assert(offsetof(UOrionTextBlock, ColorType) == 0x000221, "Member 'UOrionTextBlock::ColorType' has a wrong offset!");
static_assert(offsetof(UOrionTextBlock, bUseDropShadow) == 0x000222, "Member 'UOrionTextBlock::bUseDropShadow' has a wrong offset!");
static_assert(offsetof(UOrionTextBlock, bAllCaps) == 0x000223, "Member 'UOrionTextBlock::bAllCaps' has a wrong offset!");
static_assert(offsetof(UOrionTextBlock, bScroll) == 0x000224, "Member 'UOrionTextBlock::bScroll' has a wrong offset!");
static_assert(offsetof(UOrionTextBlock, Speed) == 0x000228, "Member 'UOrionTextBlock::Speed' has a wrong offset!");
static_assert(offsetof(UOrionTextBlock, StartDelay) == 0x00022C, "Member 'UOrionTextBlock::StartDelay' has a wrong offset!");
static_assert(offsetof(UOrionTextBlock, EndDelay) == 0x000230, "Member 'UOrionTextBlock::EndDelay' has a wrong offset!");
static_assert(offsetof(UOrionTextBlock, FadeInDelay) == 0x000234, "Member 'UOrionTextBlock::FadeInDelay' has a wrong offset!");
static_assert(offsetof(UOrionTextBlock, FadeOutDelay) == 0x000238, "Member 'UOrionTextBlock::FadeOutDelay' has a wrong offset!");

// Class OrionGame.OrionToggleableNavLinksRenderingComponent
// 0x0000 (0x0690 - 0x0690)
class UOrionToggleableNavLinksRenderingComponent final : public UNavLinkRenderingComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionToggleableNavLinksRenderingComponent">();
	}
	static class UOrionToggleableNavLinksRenderingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionToggleableNavLinksRenderingComponent>();
	}
};
static_assert(alignof(UOrionToggleableNavLinksRenderingComponent) == 0x000010, "Wrong alignment on UOrionToggleableNavLinksRenderingComponent");
static_assert(sizeof(UOrionToggleableNavLinksRenderingComponent) == 0x000690, "Wrong size on UOrionToggleableNavLinksRenderingComponent");

// Class OrionGame.OrionTooltipAnchor
// 0x0050 (0x0160 - 0x0110)
class UOrionTooltipAnchor final : public UContentWidget
{
public:
	uint8                                         Pad_110[0x50];                                     // 0x0110(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOrionBasicTooltipWidget* BasicTooltip(const class FText& Title, const class FText& Body);
	static void ForceHideCurrentTooltip();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTooltipAnchor">();
	}
	static class UOrionTooltipAnchor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionTooltipAnchor>();
	}
};
static_assert(alignof(UOrionTooltipAnchor) == 0x000008, "Wrong alignment on UOrionTooltipAnchor");
static_assert(sizeof(UOrionTooltipAnchor) == 0x000160, "Wrong size on UOrionTooltipAnchor");

// Class OrionGame.OrionTotemAnimInstance
// 0x0060 (0x07D0 - 0x0770)
class UOrionTotemAnimInstance final : public UOrionBaseHeroAnimInstance
{
public:
	TArray<class UAnimMontage*>                   FireMontages;                                      // 0x0770(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsFireMontagePlaying;                             // 0x0780(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_781[0x3];                                      // 0x0781(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LHandIKAlpha;                                      // 0x0784(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedAnimRelevancyData               JumpLandRelevantAnim;                              // 0x0788(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedAnimTransitionData              JumpLandToDefaultTransition;                       // 0x07A8(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTotemAnimInstance">();
	}
	static class UOrionTotemAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionTotemAnimInstance>();
	}
};
static_assert(alignof(UOrionTotemAnimInstance) == 0x000008, "Wrong alignment on UOrionTotemAnimInstance");
static_assert(sizeof(UOrionTotemAnimInstance) == 0x0007D0, "Wrong size on UOrionTotemAnimInstance");
static_assert(offsetof(UOrionTotemAnimInstance, FireMontages) == 0x000770, "Member 'UOrionTotemAnimInstance::FireMontages' has a wrong offset!");
static_assert(offsetof(UOrionTotemAnimInstance, bIsFireMontagePlaying) == 0x000780, "Member 'UOrionTotemAnimInstance::bIsFireMontagePlaying' has a wrong offset!");
static_assert(offsetof(UOrionTotemAnimInstance, LHandIKAlpha) == 0x000784, "Member 'UOrionTotemAnimInstance::LHandIKAlpha' has a wrong offset!");
static_assert(offsetof(UOrionTotemAnimInstance, JumpLandRelevantAnim) == 0x000788, "Member 'UOrionTotemAnimInstance::JumpLandRelevantAnim' has a wrong offset!");
static_assert(offsetof(UOrionTotemAnimInstance, JumpLandToDefaultTransition) == 0x0007A8, "Member 'UOrionTotemAnimInstance::JumpLandToDefaultTransition' has a wrong offset!");

// Class OrionGame.OrionTraversablePathway
// 0x0148 (0x0460 - 0x0318)
class AOrionTraversablePathway : public AActor
{
public:
	TArray<struct FEvenlySpacedPoint>             EvenlySpacedPoints;                                // 0x0318(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         LeadDistanceToEatPath;                             // 0x0328(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32C[0x4];                                      // 0x032C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 PathPointToEvenlySpacedPoints;                     // 0x0330(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTraversablePathway                    TraversablePathway;                                // 0x0340(0x0040)(Net, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_380[0xC];                                      // 0x0380(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShowOnLocalPlayerOnly;                            // 0x038C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayInitialized;                               // 0x038D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayEnabled;                                   // 0x038E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38F[0x1];                                      // 0x038F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            StaticMesh;                                        // 0x0390(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              Material;                                          // 0x0398(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              StaticMeshScale;                                   // 0x03A0(0x0008)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceBetweenPathwayPoints;                   // 0x03A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceZOffsetStart;                                 // 0x03AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceZOffsetEnd;                                   // 0x03B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EvenlySpacedPointsDistance;                        // 0x03B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TangentDistance;                                   // 0x03B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PathUpdateSecondIntervals;                         // 0x03BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddOneOutOfXHeroBreadCrumbs;                       // 0x03C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PathTestRadius;                                    // 0x03C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistanceForAddingPathwayPoint;                  // 0x03C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGameplayEffectsApplied;                           // 0x03CC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSourceInRange;                                    // 0x03CD(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEatPathWay;                                       // 0x03CE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDisplay;                                     // 0x03CF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckingPathRange;                                // 0x03D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D1[0x3];                                      // 0x03D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CleanupTime;                                       // 0x03D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PathwayPointOffsetFromGround;                      // 0x03D8(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineMeshAxis                               ForwardAxis;                                       // 0x03E4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPathToDestinationDirty;                           // 0x03E5(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddHeroBreadCrumbsToPath;                         // 0x03E6(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E7[0x9];                                      // 0x03E7(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceRemainingToNextEvenlySpacedPoint;          // 0x03F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextPathwayPointUsedForEvenlySpacedPoints;         // 0x03F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PositionFinalizedParameterName;                    // 0x03F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GrowthParameterName;                               // 0x0400(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OpacityParameterName;                              // 0x0408(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalFadeInTime;                                   // 0x0410(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalFadeOutTime;                                  // 0x0414(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShrinkTimeMult;                                    // 0x0418(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShrinkSmoothingStrength;                           // 0x041C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationLerpTimeMult;                              // 0x0420(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentFadeInTime;                                 // 0x0424(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentFadeOutTime;                                // 0x0428(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalSplineMeshesToFadeIn;                         // 0x042C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_430[0x10];                                     // 0x0430(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOrionFilterAndEffectsContainer        OnWithinRangeFilterAndEffectsContainters;          // 0x0440(0x0020)(Edit, BlueprintVisible, Net, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)

public:
	void CheckPathPointsRange(class AActor* SourceActor, const struct FVector& CheckLocation);
	void CreateDebugTraversablePathway(const struct FVector& PathStart, const struct FVector& PathEnd);
	void FadeOutAndDestroyPathway();
	class AActor* GetBreadCrumpActor();
	TArray<struct FEvenlySpacedPoint> GetEvenlySpacedPointsFromPointArray();
	void OnAddedEvenlySpacedPoint(int32 ArrayIndex);
	void OnFirstEvenlySpacedPointChanged(int32 PrevFirstEvenlySpacedPointIndex, int32 NewFirstEvenlySpacedPointIndex);
	void OnLastEvenlySpacedPointChanged(int32 PrevLastEvenlySpacedPointIndex, int32 NewLastEvenlySpacedPointIndex);
	void OnRep_OrionReplicatedPathToDestination();
	void OnSourceInRange(class AActor* SourceActor);
	void OnSourceOutOfRange(class AActor* SourceActor);
	void UpdateCheckPathPoints();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTraversablePathway">();
	}
	static class AOrionTraversablePathway* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionTraversablePathway>();
	}
};
static_assert(alignof(AOrionTraversablePathway) == 0x000008, "Wrong alignment on AOrionTraversablePathway");
static_assert(sizeof(AOrionTraversablePathway) == 0x000460, "Wrong size on AOrionTraversablePathway");
static_assert(offsetof(AOrionTraversablePathway, EvenlySpacedPoints) == 0x000318, "Member 'AOrionTraversablePathway::EvenlySpacedPoints' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, LeadDistanceToEatPath) == 0x000328, "Member 'AOrionTraversablePathway::LeadDistanceToEatPath' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, PathPointToEvenlySpacedPoints) == 0x000330, "Member 'AOrionTraversablePathway::PathPointToEvenlySpacedPoints' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, TraversablePathway) == 0x000340, "Member 'AOrionTraversablePathway::TraversablePathway' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, bShowOnLocalPlayerOnly) == 0x00038C, "Member 'AOrionTraversablePathway::bShowOnLocalPlayerOnly' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, bDisplayInitialized) == 0x00038D, "Member 'AOrionTraversablePathway::bDisplayInitialized' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, bDisplayEnabled) == 0x00038E, "Member 'AOrionTraversablePathway::bDisplayEnabled' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, StaticMesh) == 0x000390, "Member 'AOrionTraversablePathway::StaticMesh' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, Material) == 0x000398, "Member 'AOrionTraversablePathway::Material' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, StaticMeshScale) == 0x0003A0, "Member 'AOrionTraversablePathway::StaticMeshScale' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, MaxDistanceBetweenPathwayPoints) == 0x0003A8, "Member 'AOrionTraversablePathway::MaxDistanceBetweenPathwayPoints' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, TraceZOffsetStart) == 0x0003AC, "Member 'AOrionTraversablePathway::TraceZOffsetStart' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, TraceZOffsetEnd) == 0x0003B0, "Member 'AOrionTraversablePathway::TraceZOffsetEnd' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, EvenlySpacedPointsDistance) == 0x0003B4, "Member 'AOrionTraversablePathway::EvenlySpacedPointsDistance' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, TangentDistance) == 0x0003B8, "Member 'AOrionTraversablePathway::TangentDistance' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, PathUpdateSecondIntervals) == 0x0003BC, "Member 'AOrionTraversablePathway::PathUpdateSecondIntervals' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, AddOneOutOfXHeroBreadCrumbs) == 0x0003C0, "Member 'AOrionTraversablePathway::AddOneOutOfXHeroBreadCrumbs' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, PathTestRadius) == 0x0003C4, "Member 'AOrionTraversablePathway::PathTestRadius' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, MinDistanceForAddingPathwayPoint) == 0x0003C8, "Member 'AOrionTraversablePathway::MinDistanceForAddingPathwayPoint' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, bGameplayEffectsApplied) == 0x0003CC, "Member 'AOrionTraversablePathway::bGameplayEffectsApplied' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, bSourceInRange) == 0x0003CD, "Member 'AOrionTraversablePathway::bSourceInRange' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, bEatPathWay) == 0x0003CE, "Member 'AOrionTraversablePathway::bEatPathWay' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, bDebugDisplay) == 0x0003CF, "Member 'AOrionTraversablePathway::bDebugDisplay' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, bCheckingPathRange) == 0x0003D0, "Member 'AOrionTraversablePathway::bCheckingPathRange' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, CleanupTime) == 0x0003D4, "Member 'AOrionTraversablePathway::CleanupTime' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, PathwayPointOffsetFromGround) == 0x0003D8, "Member 'AOrionTraversablePathway::PathwayPointOffsetFromGround' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, ForwardAxis) == 0x0003E4, "Member 'AOrionTraversablePathway::ForwardAxis' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, bPathToDestinationDirty) == 0x0003E5, "Member 'AOrionTraversablePathway::bPathToDestinationDirty' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, bAddHeroBreadCrumbsToPath) == 0x0003E6, "Member 'AOrionTraversablePathway::bAddHeroBreadCrumbsToPath' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, DistanceRemainingToNextEvenlySpacedPoint) == 0x0003F0, "Member 'AOrionTraversablePathway::DistanceRemainingToNextEvenlySpacedPoint' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, NextPathwayPointUsedForEvenlySpacedPoints) == 0x0003F4, "Member 'AOrionTraversablePathway::NextPathwayPointUsedForEvenlySpacedPoints' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, PositionFinalizedParameterName) == 0x0003F8, "Member 'AOrionTraversablePathway::PositionFinalizedParameterName' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, GrowthParameterName) == 0x000400, "Member 'AOrionTraversablePathway::GrowthParameterName' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, OpacityParameterName) == 0x000408, "Member 'AOrionTraversablePathway::OpacityParameterName' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, TotalFadeInTime) == 0x000410, "Member 'AOrionTraversablePathway::TotalFadeInTime' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, TotalFadeOutTime) == 0x000414, "Member 'AOrionTraversablePathway::TotalFadeOutTime' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, ShrinkTimeMult) == 0x000418, "Member 'AOrionTraversablePathway::ShrinkTimeMult' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, ShrinkSmoothingStrength) == 0x00041C, "Member 'AOrionTraversablePathway::ShrinkSmoothingStrength' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, LocationLerpTimeMult) == 0x000420, "Member 'AOrionTraversablePathway::LocationLerpTimeMult' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, CurrentFadeInTime) == 0x000424, "Member 'AOrionTraversablePathway::CurrentFadeInTime' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, CurrentFadeOutTime) == 0x000428, "Member 'AOrionTraversablePathway::CurrentFadeOutTime' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, TotalSplineMeshesToFadeIn) == 0x00042C, "Member 'AOrionTraversablePathway::TotalSplineMeshesToFadeIn' has a wrong offset!");
static_assert(offsetof(AOrionTraversablePathway, OnWithinRangeFilterAndEffectsContainters) == 0x000440, "Member 'AOrionTraversablePathway::OnWithinRangeFilterAndEffectsContainters' has a wrong offset!");

// Class OrionGame.OrionTutorial
// 0x01B8 (0x01E0 - 0x0028)
class UOrionTutorial : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UOrionTutorialMessageWidget> MessageWidgetClass;                                // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    QuestStat_DEPECATED;                               // 0x0038(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayStatTag                       QuestGameplayStat;                                 // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FOrionTutorialStage>            TutorialStages;                                    // 0x0058(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UOrionTutorialMessageWidget*            MessageWidget;                                     // 0x0068(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_70[0x170];                                     // 0x0070(0x0170)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTutorial">();
	}
	static class UOrionTutorial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionTutorial>();
	}
};
static_assert(alignof(UOrionTutorial) == 0x000008, "Wrong alignment on UOrionTutorial");
static_assert(sizeof(UOrionTutorial) == 0x0001E0, "Wrong size on UOrionTutorial");
static_assert(offsetof(UOrionTutorial, MessageWidgetClass) == 0x000030, "Member 'UOrionTutorial::MessageWidgetClass' has a wrong offset!");
static_assert(offsetof(UOrionTutorial, QuestStat_DEPECATED) == 0x000038, "Member 'UOrionTutorial::QuestStat_DEPECATED' has a wrong offset!");
static_assert(offsetof(UOrionTutorial, QuestGameplayStat) == 0x000048, "Member 'UOrionTutorial::QuestGameplayStat' has a wrong offset!");
static_assert(offsetof(UOrionTutorial, TutorialStages) == 0x000058, "Member 'UOrionTutorial::TutorialStages' has a wrong offset!");
static_assert(offsetof(UOrionTutorial, MessageWidget) == 0x000068, "Member 'UOrionTutorial::MessageWidget' has a wrong offset!");

// Class OrionGame.OrionTutorialMessageWidget
// 0x0128 (0x03E0 - 0x02B8)
class UOrionTutorialMessageWidget : public UOrionUserWidgetBase
{
public:
	uint8                                         Pad_2B8[0xF0];                                     // 0x02B8(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionMcpQuestItemDefinition*           RequiredQuest;                                     // 0x03A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B0[0x8];                                      // 0x03B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionTextBlock*                        Text_Title;                                        // 0x03B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionTextBlock*                        Text_Progress;                                     // 0x03C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionRichText*                         RichText_Message;                                  // 0x03C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionBaseButton*                       DefaultButton_Previous;                            // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionBaseButton*                       DefaultButton_Next;                                // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnShowNewStage();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTutorialMessageWidget">();
	}
	static class UOrionTutorialMessageWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionTutorialMessageWidget>();
	}
};
static_assert(alignof(UOrionTutorialMessageWidget) == 0x000008, "Wrong alignment on UOrionTutorialMessageWidget");
static_assert(sizeof(UOrionTutorialMessageWidget) == 0x0003E0, "Wrong size on UOrionTutorialMessageWidget");
static_assert(offsetof(UOrionTutorialMessageWidget, RequiredQuest) == 0x0003A8, "Member 'UOrionTutorialMessageWidget::RequiredQuest' has a wrong offset!");
static_assert(offsetof(UOrionTutorialMessageWidget, Text_Title) == 0x0003B8, "Member 'UOrionTutorialMessageWidget::Text_Title' has a wrong offset!");
static_assert(offsetof(UOrionTutorialMessageWidget, Text_Progress) == 0x0003C0, "Member 'UOrionTutorialMessageWidget::Text_Progress' has a wrong offset!");
static_assert(offsetof(UOrionTutorialMessageWidget, RichText_Message) == 0x0003C8, "Member 'UOrionTutorialMessageWidget::RichText_Message' has a wrong offset!");
static_assert(offsetof(UOrionTutorialMessageWidget, DefaultButton_Previous) == 0x0003D0, "Member 'UOrionTutorialMessageWidget::DefaultButton_Previous' has a wrong offset!");
static_assert(offsetof(UOrionTutorialMessageWidget, DefaultButton_Next) == 0x0003D8, "Member 'UOrionTutorialMessageWidget::DefaultButton_Next' has a wrong offset!");

// Class OrionGame.OrionTypes
// 0x0000 (0x0028 - 0x0028)
class UOrionTypes final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTypes">();
	}
	static class UOrionTypes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionTypes>();
	}
};
static_assert(alignof(UOrionTypes) == 0x000008, "Wrong alignment on UOrionTypes");
static_assert(sizeof(UOrionTypes) == 0x000028, "Wrong size on UOrionTypes");

// Class OrionGame.OrionTextObject
// 0x0018 (0x0040 - 0x0028)
class UOrionTextObject final : public UObject
{
public:
	class FText                                   Label;                                             // 0x0028(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionTextObject">();
	}
	static class UOrionTextObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionTextObject>();
	}
};
static_assert(alignof(UOrionTextObject) == 0x000008, "Wrong alignment on UOrionTextObject");
static_assert(sizeof(UOrionTextObject) == 0x000040, "Wrong size on UOrionTextObject");
static_assert(offsetof(UOrionTextObject, Label) == 0x000028, "Member 'UOrionTextObject::Label' has a wrong offset!");

// Class OrionGame.OrionUI_Base
// 0x0000 (0x0408 - 0x0408)
class AOrionUI_Base : public AHUD
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionUI_Base">();
	}
	static class AOrionUI_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionUI_Base>();
	}
};
static_assert(alignof(AOrionUI_Base) == 0x000008, "Wrong alignment on AOrionUI_Base");
static_assert(sizeof(AOrionUI_Base) == 0x000408, "Wrong size on AOrionUI_Base");

// Class OrionGame.OrionUI_Game
// 0x0098 (0x04A0 - 0x0408)
class AOrionUI_Game : public AOrionUI_Base
{
public:
	uint8                                         Pad_408[0x90];                                     // 0x0408(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                DebugASC;                                          // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OrionCycleShowDebug();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionUI_Game">();
	}
	static class AOrionUI_Game* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionUI_Game>();
	}
};
static_assert(alignof(AOrionUI_Game) == 0x000008, "Wrong alignment on AOrionUI_Game");
static_assert(sizeof(AOrionUI_Game) == 0x0004A0, "Wrong size on AOrionUI_Game");
static_assert(offsetof(AOrionUI_Game, DebugASC) == 0x000498, "Member 'AOrionUI_Game::DebugASC' has a wrong offset!");

// Class OrionGame.OrionUI_Menu
// 0x0000 (0x0408 - 0x0408)
class AOrionUI_Menu final : public AOrionUI_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionUI_Menu">();
	}
	static class AOrionUI_Menu* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionUI_Menu>();
	}
};
static_assert(alignof(AOrionUI_Menu) == 0x000008, "Wrong alignment on AOrionUI_Menu");
static_assert(sizeof(AOrionUI_Menu) == 0x000408, "Wrong size on AOrionUI_Menu");

// Class OrionGame.OrionUIBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UOrionUIBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ClearFocusForModalWindow();
	static bool Contains_OrionAffinityStruct(const struct FOrionAffinityStruct& Authority, const struct FOrionAffinityStruct& Test);
	static void CopyToClipboard(const class FString& ClipboardText);
	static bool EqualEqual_OrionPlayerStateUIID(const struct FOrionPlayerStateUIID& A, const struct FOrionPlayerStateUIID& B);
	static TArray<class FString> GetAvailableLanguages();
	static struct FVector2D GetCleanOffset(const struct FVector2D& InVec);
	static class FString GetCurrentLanguageCode();
	static float GetCurrentMaterialTime();
	static float GetHealthPipValue();
	static TArray<class UOrionHeroData*> GetHeroesForWelcomeScreen();
	static class FString GetLanguageDisplayName(const class FString& LanguageCode);
	static void GetSegmentAngles(float Center, float WedgeSize, float* Min, float* Max);
	static void GetStoreOfferFrom(class UObject* Source, struct FStoreOfferBP* Result);
	static void GetTimespanAsSimpleText(const struct FTimespan& Timespan, class FText* Text);
	static class FString GetTwoLetterLanguageCode();
	static bool HasCommandLineParameter(const class FString& CommandLine);
	static bool IsConsoleBuild();
	static bool IsConsoleOpen();
	static bool IsDemoMode();
	static bool IsGeForceNowBuild();
	static bool IsInSegment(float Center, float WedgeSize, float TestAngle);
	static bool IsInWorld(class UObject* TestObject);
	static bool IsMTXPaymentAllowed();
	static bool IsPS4Build();
	static bool IsTencentBuild();
	static bool IsWIPUIEnabled();
	static bool NotEqual_OrionPlayerStateUIID(const struct FOrionPlayerStateUIID& A, const struct FOrionPlayerStateUIID& B);
	static void OrionAffinityStructToEnum(const struct FOrionAffinityStruct& Authority, EAffinityType* First, EAffinityType* Second);
	static void OrionLaunchURL(class UObject* WorldContextObject, const class FString& URL);
	static bool OrionTBFindMemberByIndex(struct FOrionTBState& Members, int32 SlotIndex, struct FOrionTBSlotState* Result);
	static float SafePercent(const float Value, const float ValueMax, bool bIfInvalidReturnOne);
	static void SetInputModeGameAndUI(class APlayerController* Target, class UWidget* WidgetToFocus, bool bHideCursorDuringCapture, bool bEnableParallax, bool bAnalogCursor);
	static void SetInputModeGameOnly(class APlayerController* Target);
	static void SetInputModeUIOnly(class APlayerController* Target, class UWidget* WidgetToFocus, bool bEnableParallax);
	static void SetNeedsMouse(class UObject* WorldContextObject, bool bNeedsMouse);
	static class FText StatToText(EOrionStatTypes InType);
	static bool SupportsHDR();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionUIBlueprintLibrary">();
	}
	static class UOrionUIBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionUIBlueprintLibrary>();
	}
};
static_assert(alignof(UOrionUIBlueprintLibrary) == 0x000008, "Wrong alignment on UOrionUIBlueprintLibrary");
static_assert(sizeof(UOrionUIBlueprintLibrary) == 0x000028, "Wrong size on UOrionUIBlueprintLibrary");

// Class OrionGame.OrionUIManagerWidget
// 0x0350 (0x0550 - 0x0200)
class UOrionUIManagerWidget : public UUserWidget
{
public:
	uint8                                         Pad_200[0x70];                                     // 0x0200(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FWorldMusicCue>                 WorldMusicCues;                                    // 0x0270(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class UOrionTutorial*                         ActiveTutorial;                                    // 0x0280(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionUIStateManager*                   StateManager;                                      // 0x0288(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_290[0x1A0];                                    // 0x0290(0x01A0)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        WorldMusicComponent;                               // 0x0430(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   DebugHeroSelectClass;                              // 0x0438(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_460[0x8];                                      // 0x0460(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   CardCountdownTutorialClass;                        // 0x0468(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_490[0x10];                                     // 0x0490(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   LoadingScreenWidgetClass;                          // 0x04A0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionLoadingScreen*                    LoadingScreenWidget;                               // 0x04C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D0[0x58];                                     // 0x04D0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class USizeBox*                               Box_StateContentLayer;                             // 0x0528(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionDialogWidget*                     Dialog_Confirmation;                               // 0x0530(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionLightBox*                         LightBox_ModalContent;                             // 0x0538(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionActivatableWidget*                Activatable_ControllerDisconnectWarning;           // 0x0540(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Image_TutorialGuard;                               // 0x0548(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static void BP_RegisterInputHandlerWidget(class UObject* WorldContextObject, const TScriptInterface<class IOrionInputHandlerWidget>& WidgetToRegister, const struct FKey& InKey);
	static void BP_UnregisterInputHandlerWidget(class UObject* WorldContextObject, const TScriptInterface<class IOrionInputHandlerWidget>& WidgetToUnregister, const struct FKey& InKey);
	static void EstablishCurrentBackHandlerStack(class UObject* WorldContextObject, class FName StackName);
	static class UOrionUIManagerWidget* GetUIManagerWidget(class UObject* WorldContextObject);
	static void HideLoadingScreen(class UObject* WorldContextObject);
	static void HideLoadingScreenIfMode(class UObject* WorldContextObject, EOrionLoadingScreenMode Mode);
	static bool IsLoadingScreenVisible(class UObject* WorldContextObject);
	static void KillConfirmationDialog(class UObject* WorldContextObject);
	static bool PlayVideo(class UObject* WorldContextObject, class FName VideoID);
	static void SetActiveTutorial(class UObject* WorldContextObject, class UOrionTutorial* Tutorial, bool bOverrideTutorialInProgress);
	static void ShowErrorNotification(class UObject* WorldContextObject, const class FText& DisplayMessage, bool bClearExistingErrors);
	static void ShowLoadingScreen(class UObject* WorldContextObject, EOrionLoadingScreenMode Mode);
	static void StopActiveTutorial(class UObject* WorldContextObject, TSubclassOf<class UOrionTutorial> TutorialClass);

	void AddMovingWidget(class UWidget* WidgetToMove, const struct FGeometry& SourceGeometry, class FName DestinationId, float MoveDuration, int32 NumCopies, float CopyDelay, const EMovingWidgetMotion MotionType, int32 SpreadAngleDegrees);
	void ClearAllMovingWidgets();
	void FadeInWorldMusic();
	void FadeOutWorldMusic();
	void HandleEnterModalMode();
	void HandleExitModalMode();
	void HandleMusicChanged();
	bool IsModalMode();
	void KillConfirmation();
	void KillMovingWidget(class FName MovingWidgetId);
	void OnEnterModalMode__DelegateSignature();
	void OnExitModalMode__DelegateSignature();
	void OnLoadingScreenProgressUpdated__DelegateSignature(float LoadingPercent);
	void OnSetMatchInfoText(const class FText& InText);
	void OnSetMatchInfoVisibility(bool bVisible);
	void OnShowError(const struct FOrionDialogDescription& Description);
	void OnShowPreMatchLoadingScreen__DelegateSignature();
	void OnStateTransitionComplete();
	void RouteBackAction();
	void SetStateContentDisplayed(bool bDisplay);
	void ShowModalContent(class UOrionActivatableWidget* ActivatableContent);

	class UOrionUIStateWidget* BP_GetCurrentUIStateWidget() const;
	EOrionUIState GetCurrentUIState() const;
	bool IsStateContentDisplayed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionUIManagerWidget">();
	}
	static class UOrionUIManagerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionUIManagerWidget>();
	}
};
static_assert(alignof(UOrionUIManagerWidget) == 0x000008, "Wrong alignment on UOrionUIManagerWidget");
static_assert(sizeof(UOrionUIManagerWidget) == 0x000550, "Wrong size on UOrionUIManagerWidget");
static_assert(offsetof(UOrionUIManagerWidget, WorldMusicCues) == 0x000270, "Member 'UOrionUIManagerWidget::WorldMusicCues' has a wrong offset!");
static_assert(offsetof(UOrionUIManagerWidget, ActiveTutorial) == 0x000280, "Member 'UOrionUIManagerWidget::ActiveTutorial' has a wrong offset!");
static_assert(offsetof(UOrionUIManagerWidget, StateManager) == 0x000288, "Member 'UOrionUIManagerWidget::StateManager' has a wrong offset!");
static_assert(offsetof(UOrionUIManagerWidget, WorldMusicComponent) == 0x000430, "Member 'UOrionUIManagerWidget::WorldMusicComponent' has a wrong offset!");
static_assert(offsetof(UOrionUIManagerWidget, DebugHeroSelectClass) == 0x000438, "Member 'UOrionUIManagerWidget::DebugHeroSelectClass' has a wrong offset!");
static_assert(offsetof(UOrionUIManagerWidget, CardCountdownTutorialClass) == 0x000468, "Member 'UOrionUIManagerWidget::CardCountdownTutorialClass' has a wrong offset!");
static_assert(offsetof(UOrionUIManagerWidget, LoadingScreenWidgetClass) == 0x0004A0, "Member 'UOrionUIManagerWidget::LoadingScreenWidgetClass' has a wrong offset!");
static_assert(offsetof(UOrionUIManagerWidget, LoadingScreenWidget) == 0x0004C8, "Member 'UOrionUIManagerWidget::LoadingScreenWidget' has a wrong offset!");
static_assert(offsetof(UOrionUIManagerWidget, Box_StateContentLayer) == 0x000528, "Member 'UOrionUIManagerWidget::Box_StateContentLayer' has a wrong offset!");
static_assert(offsetof(UOrionUIManagerWidget, Dialog_Confirmation) == 0x000530, "Member 'UOrionUIManagerWidget::Dialog_Confirmation' has a wrong offset!");
static_assert(offsetof(UOrionUIManagerWidget, LightBox_ModalContent) == 0x000538, "Member 'UOrionUIManagerWidget::LightBox_ModalContent' has a wrong offset!");
static_assert(offsetof(UOrionUIManagerWidget, Activatable_ControllerDisconnectWarning) == 0x000540, "Member 'UOrionUIManagerWidget::Activatable_ControllerDisconnectWarning' has a wrong offset!");
static_assert(offsetof(UOrionUIManagerWidget, Image_TutorialGuard) == 0x000548, "Member 'UOrionUIManagerWidget::Image_TutorialGuard' has a wrong offset!");

// Class OrionGame.OrionUIStateManager
// 0x0268 (0x0290 - 0x0028)
class UOrionUIStateManager final : public UObject
{
public:
	uint8                                         Pad_28[0x48];                                      // 0x0028(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   StateWidgetClasses[0xD];                           // 0x0070(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionUIStateWidget*                    CurrentStateWidget;                                // 0x0278(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_280[0x10];                                     // 0x0280(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionUIStateManager">();
	}
	static class UOrionUIStateManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionUIStateManager>();
	}
};
static_assert(alignof(UOrionUIStateManager) == 0x000008, "Wrong alignment on UOrionUIStateManager");
static_assert(sizeof(UOrionUIStateManager) == 0x000290, "Wrong size on UOrionUIStateManager");
static_assert(offsetof(UOrionUIStateManager, StateWidgetClasses) == 0x000070, "Member 'UOrionUIStateManager::StateWidgetClasses' has a wrong offset!");
static_assert(offsetof(UOrionUIStateManager, CurrentStateWidget) == 0x000278, "Member 'UOrionUIStateManager::CurrentStateWidget' has a wrong offset!");

// Class OrionGame.OrionUIStateWidget
// 0x0000 (0x02B8 - 0x02B8)
#pragma pack(push, 0x1)
class alignas(0x08) UOrionUIStateWidget : public UOrionUserWidgetBase
{
public:
	void OnEnterState();
	void OnExitState();
	void UpdateButtonLegend(const TArray<struct FButtonLegendItem>& LegendSource);

	bool IsReadyForNextState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionUIStateWidget">();
	}
	static class UOrionUIStateWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionUIStateWidget>();
	}
};
#pragma pack(pop)
static_assert(alignof(UOrionUIStateWidget) == 0x000008, "Wrong alignment on UOrionUIStateWidget");
static_assert(sizeof(UOrionUIStateWidget) == 0x0002B8, "Wrong size on UOrionUIStateWidget");

// Class OrionGame.OrionUpdateManager
// 0x0000 (0x0270 - 0x0270)
class UOrionUpdateManager final : public UUpdateManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionUpdateManager">();
	}
	static class UOrionUpdateManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionUpdateManager>();
	}
};
static_assert(alignof(UOrionUpdateManager) == 0x000008, "Wrong alignment on UOrionUpdateManager");
static_assert(sizeof(UOrionUpdateManager) == 0x000270, "Wrong size on UOrionUpdateManager");

// Class OrionGame.OrionUserWidget_GameEventMessage
// 0x00F0 (0x02F0 - 0x0200)
class UOrionUserWidget_GameEventMessage : public UUserWidget
{
public:
	uint8                                         Pad_200[0x8];                                      // 0x0200(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionGameEventMessageContainer*        ParentContainer;                                   // 0x0208(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FOrionGameEventMessageData             MessageData;                                       // 0x0210(0x00D0)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	EOrionGameEventMessageType                    MessageType;                                       // 0x02E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E1[0xF];                                      // 0x02E1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MessageIsFinished();
	void PlayMessage();

	EOrionTeam GetEnemyTeam() const;
	EOrionTeam GetMyTeam() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionUserWidget_GameEventMessage">();
	}
	static class UOrionUserWidget_GameEventMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionUserWidget_GameEventMessage>();
	}
};
static_assert(alignof(UOrionUserWidget_GameEventMessage) == 0x000008, "Wrong alignment on UOrionUserWidget_GameEventMessage");
static_assert(sizeof(UOrionUserWidget_GameEventMessage) == 0x0002F0, "Wrong size on UOrionUserWidget_GameEventMessage");
static_assert(offsetof(UOrionUserWidget_GameEventMessage, ParentContainer) == 0x000208, "Member 'UOrionUserWidget_GameEventMessage::ParentContainer' has a wrong offset!");
static_assert(offsetof(UOrionUserWidget_GameEventMessage, MessageData) == 0x000210, "Member 'UOrionUserWidget_GameEventMessage::MessageData' has a wrong offset!");
static_assert(offsetof(UOrionUserWidget_GameEventMessage, MessageType) == 0x0002E0, "Member 'UOrionUserWidget_GameEventMessage::MessageType' has a wrong offset!");

// Class OrionGame.OrionGameEventMessageContainer
// 0x0050 (0x0340 - 0x02F0)
class UOrionGameEventMessageContainer final : public UOrionHUDWidgetBase
{
public:
	class UScaleBox*                              GameEventBox;                                      // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FOrionGameEventMessageData>     GameEventMessages;                                 // 0x02F8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UOrionUserWidget_GameEventMessage*      CurrentMessageWidget;                              // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UOrionUserWidget_GameEventMessage*> MessageWidgets;                                    // 0x0310(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_320[0x20];                                     // 0x0320(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddNewGameEventMessage(const struct FOrionGameEventMessageData& NewMessageData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionGameEventMessageContainer">();
	}
	static class UOrionGameEventMessageContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionGameEventMessageContainer>();
	}
};
static_assert(alignof(UOrionGameEventMessageContainer) == 0x000008, "Wrong alignment on UOrionGameEventMessageContainer");
static_assert(sizeof(UOrionGameEventMessageContainer) == 0x000340, "Wrong size on UOrionGameEventMessageContainer");
static_assert(offsetof(UOrionGameEventMessageContainer, GameEventBox) == 0x0002F0, "Member 'UOrionGameEventMessageContainer::GameEventBox' has a wrong offset!");
static_assert(offsetof(UOrionGameEventMessageContainer, GameEventMessages) == 0x0002F8, "Member 'UOrionGameEventMessageContainer::GameEventMessages' has a wrong offset!");
static_assert(offsetof(UOrionGameEventMessageContainer, CurrentMessageWidget) == 0x000308, "Member 'UOrionGameEventMessageContainer::CurrentMessageWidget' has a wrong offset!");
static_assert(offsetof(UOrionGameEventMessageContainer, MessageWidgets) == 0x000310, "Member 'UOrionGameEventMessageContainer::MessageWidgets' has a wrong offset!");

// Class OrionGame.OrionUserWidget_Reticle
// 0x0040 (0x0240 - 0x0200)
class UOrionUserWidget_Reticle : public UUserWidget
{
public:
	int32                                         InputID;                                           // 0x0200(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_204[0x4];                                      // 0x0204(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       SuccessfulHitAnimation;                            // 0x0208(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OnTargetingAnimation;                              // 0x0210(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               CooldownMID;                                       // 0x0218(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               TargetingRingMID;                                  // 0x0220(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasCooldown;                                      // 0x0228(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_229[0x7];                                      // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UReticleContext*                        RetConPtr;                                         // 0x0230(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_238[0x8];                                      // 0x0238(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSuccesfulHit();
	void OnTargetingUpdate(bool bIsTargeting);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionUserWidget_Reticle">();
	}
	static class UOrionUserWidget_Reticle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionUserWidget_Reticle>();
	}
};
static_assert(alignof(UOrionUserWidget_Reticle) == 0x000008, "Wrong alignment on UOrionUserWidget_Reticle");
static_assert(sizeof(UOrionUserWidget_Reticle) == 0x000240, "Wrong size on UOrionUserWidget_Reticle");
static_assert(offsetof(UOrionUserWidget_Reticle, InputID) == 0x000200, "Member 'UOrionUserWidget_Reticle::InputID' has a wrong offset!");
static_assert(offsetof(UOrionUserWidget_Reticle, SuccessfulHitAnimation) == 0x000208, "Member 'UOrionUserWidget_Reticle::SuccessfulHitAnimation' has a wrong offset!");
static_assert(offsetof(UOrionUserWidget_Reticle, OnTargetingAnimation) == 0x000210, "Member 'UOrionUserWidget_Reticle::OnTargetingAnimation' has a wrong offset!");
static_assert(offsetof(UOrionUserWidget_Reticle, CooldownMID) == 0x000218, "Member 'UOrionUserWidget_Reticle::CooldownMID' has a wrong offset!");
static_assert(offsetof(UOrionUserWidget_Reticle, TargetingRingMID) == 0x000220, "Member 'UOrionUserWidget_Reticle::TargetingRingMID' has a wrong offset!");
static_assert(offsetof(UOrionUserWidget_Reticle, bHasCooldown) == 0x000228, "Member 'UOrionUserWidget_Reticle::bHasCooldown' has a wrong offset!");
static_assert(offsetof(UOrionUserWidget_Reticle, RetConPtr) == 0x000230, "Member 'UOrionUserWidget_Reticle::RetConPtr' has a wrong offset!");

// Class OrionGame.OrionVideoDisplayData
// 0x0020 (0x0050 - 0x0030)
class UOrionVideoDisplayData final : public UDataAsset
{
public:
	class UMediaPlayer*                           OrionVideoPlayer;                                  // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMediaPlayer*                           OrionAudioPlayer;                                  // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOrionVideoInfo>                Videos;                                            // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionVideoDisplayData">();
	}
	static class UOrionVideoDisplayData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionVideoDisplayData>();
	}
};
static_assert(alignof(UOrionVideoDisplayData) == 0x000008, "Wrong alignment on UOrionVideoDisplayData");
static_assert(sizeof(UOrionVideoDisplayData) == 0x000050, "Wrong size on UOrionVideoDisplayData");
static_assert(offsetof(UOrionVideoDisplayData, OrionVideoPlayer) == 0x000030, "Member 'UOrionVideoDisplayData::OrionVideoPlayer' has a wrong offset!");
static_assert(offsetof(UOrionVideoDisplayData, OrionAudioPlayer) == 0x000038, "Member 'UOrionVideoDisplayData::OrionAudioPlayer' has a wrong offset!");
static_assert(offsetof(UOrionVideoDisplayData, Videos) == 0x000040, "Member 'UOrionVideoDisplayData::Videos' has a wrong offset!");

// Class OrionGame.OrionVisionDef
// 0x0040 (0x0068 - 0x0028)
class UOrionVisionDef : public UObject
{
public:
	EOrionVisionDef                               Type;                                              // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldTeamColor;                                   // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RequiresLOS;                                       // 0x002A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RequiresFOV;                                       // 0x002B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZOffsetForVisionTest;                              // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultVisionDistance;                             // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultVisionDistanceSquared;                      // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IconSizeX;                                         // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IconSizeY;                                         // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             IconTexture;                                       // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     IconMaterial;                                      // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZOffset;                                           // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxIndicatorDrawDistance;                          // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxIndicatorDrawDistanceSquared;                   // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxIndicatorDrawDistanceRear;                      // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxIndicatorDrawDistanceRearSquared;               // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionVisionDef">();
	}
	static class UOrionVisionDef* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionVisionDef>();
	}
};
static_assert(alignof(UOrionVisionDef) == 0x000008, "Wrong alignment on UOrionVisionDef");
static_assert(sizeof(UOrionVisionDef) == 0x000068, "Wrong size on UOrionVisionDef");
static_assert(offsetof(UOrionVisionDef, Type) == 0x000028, "Member 'UOrionVisionDef::Type' has a wrong offset!");
static_assert(offsetof(UOrionVisionDef, ShouldTeamColor) == 0x000029, "Member 'UOrionVisionDef::ShouldTeamColor' has a wrong offset!");
static_assert(offsetof(UOrionVisionDef, RequiresLOS) == 0x00002A, "Member 'UOrionVisionDef::RequiresLOS' has a wrong offset!");
static_assert(offsetof(UOrionVisionDef, RequiresFOV) == 0x00002B, "Member 'UOrionVisionDef::RequiresFOV' has a wrong offset!");
static_assert(offsetof(UOrionVisionDef, ZOffsetForVisionTest) == 0x00002C, "Member 'UOrionVisionDef::ZOffsetForVisionTest' has a wrong offset!");
static_assert(offsetof(UOrionVisionDef, DefaultVisionDistance) == 0x000030, "Member 'UOrionVisionDef::DefaultVisionDistance' has a wrong offset!");
static_assert(offsetof(UOrionVisionDef, DefaultVisionDistanceSquared) == 0x000034, "Member 'UOrionVisionDef::DefaultVisionDistanceSquared' has a wrong offset!");
static_assert(offsetof(UOrionVisionDef, IconSizeX) == 0x000038, "Member 'UOrionVisionDef::IconSizeX' has a wrong offset!");
static_assert(offsetof(UOrionVisionDef, IconSizeY) == 0x000039, "Member 'UOrionVisionDef::IconSizeY' has a wrong offset!");
static_assert(offsetof(UOrionVisionDef, IconTexture) == 0x000040, "Member 'UOrionVisionDef::IconTexture' has a wrong offset!");
static_assert(offsetof(UOrionVisionDef, IconMaterial) == 0x000048, "Member 'UOrionVisionDef::IconMaterial' has a wrong offset!");
static_assert(offsetof(UOrionVisionDef, ZOffset) == 0x000050, "Member 'UOrionVisionDef::ZOffset' has a wrong offset!");
static_assert(offsetof(UOrionVisionDef, MaxIndicatorDrawDistance) == 0x000054, "Member 'UOrionVisionDef::MaxIndicatorDrawDistance' has a wrong offset!");
static_assert(offsetof(UOrionVisionDef, MaxIndicatorDrawDistanceSquared) == 0x000058, "Member 'UOrionVisionDef::MaxIndicatorDrawDistanceSquared' has a wrong offset!");
static_assert(offsetof(UOrionVisionDef, MaxIndicatorDrawDistanceRear) == 0x00005C, "Member 'UOrionVisionDef::MaxIndicatorDrawDistanceRear' has a wrong offset!");
static_assert(offsetof(UOrionVisionDef, MaxIndicatorDrawDistanceRearSquared) == 0x000060, "Member 'UOrionVisionDef::MaxIndicatorDrawDistanceRearSquared' has a wrong offset!");

// Class OrionGame.OrionVisionManager2
// 0x49FB8 (0x4A2D0 - 0x0318)
class AOrionVisionManager2 : public AActor
{
public:
	uint8                                         Pad_318[0xD8];                                     // 0x0318(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVisionManagerRuntimeData              VisionData;                                        // 0x03F0(0x488E0)(Net, Protected, NativeAccessSpecifierProtected)
	struct FOrionVisionDefOverride                VisionDefOverrides[0xA];                           // 0x48CD0(0x0010)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UOrionVisionDef>            DefaultMappings[0xF];                              // 0x48D70(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48DE8[0xC8];                                   // 0x48DE8(0x00C8)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMinimapPingStyle                      MinimapPingStyles[0x6];                            // 0x48EB0(0x0090)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_49210[0x10];                                   // 0x49210(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionVisionDef*                        DefaultVisionDef;                                  // 0x49220(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49228[0x1020];                                 // 0x49228(0x1020)(Fixing Size After Last Property [ Dumper-7 ])
	EVisionManagerDebugMode                       DebugMode;                                         // 0x4A248(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVisionManagerDebugFilter                     DebugFilter;                                       // 0x4A249(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A24A[0x6];                                    // 0x4A24A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVisionManagerDebugInfoDump            ReplicatedDebugDump;                               // 0x4A250(0x0018)(Net, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A268[0x8];                                    // 0x4A268(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DebugFilterIndex;                                  // 0x4A270(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A274[0x5C];                                   // 0x4A274(0x005C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MulticastDebugLog(const TArray<class FString>& Strs);
	void OnRep_ReplicatedDebugDump();
	void OnRep_VisionDataOverrides();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionVisionManager2">();
	}
	static class AOrionVisionManager2* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionVisionManager2>();
	}
};
static_assert(alignof(AOrionVisionManager2) == 0x000010, "Wrong alignment on AOrionVisionManager2");
static_assert(sizeof(AOrionVisionManager2) == 0x04A2D0, "Wrong size on AOrionVisionManager2");
static_assert(offsetof(AOrionVisionManager2, VisionData) == 0x0003F0, "Member 'AOrionVisionManager2::VisionData' has a wrong offset!");
static_assert(offsetof(AOrionVisionManager2, VisionDefOverrides) == 0x048CD0, "Member 'AOrionVisionManager2::VisionDefOverrides' has a wrong offset!");
static_assert(offsetof(AOrionVisionManager2, DefaultMappings) == 0x048D70, "Member 'AOrionVisionManager2::DefaultMappings' has a wrong offset!");
static_assert(offsetof(AOrionVisionManager2, MinimapPingStyles) == 0x048EB0, "Member 'AOrionVisionManager2::MinimapPingStyles' has a wrong offset!");
static_assert(offsetof(AOrionVisionManager2, DefaultVisionDef) == 0x049220, "Member 'AOrionVisionManager2::DefaultVisionDef' has a wrong offset!");
static_assert(offsetof(AOrionVisionManager2, DebugMode) == 0x04A248, "Member 'AOrionVisionManager2::DebugMode' has a wrong offset!");
static_assert(offsetof(AOrionVisionManager2, DebugFilter) == 0x04A249, "Member 'AOrionVisionManager2::DebugFilter' has a wrong offset!");
static_assert(offsetof(AOrionVisionManager2, ReplicatedDebugDump) == 0x04A250, "Member 'AOrionVisionManager2::ReplicatedDebugDump' has a wrong offset!");
static_assert(offsetof(AOrionVisionManager2, DebugFilterIndex) == 0x04A270, "Member 'AOrionVisionManager2::DebugFilterIndex' has a wrong offset!");

// Class OrionGame.OrionVisionSet
// 0x0008 (0x0038 - 0x0030)
class UOrionVisionSet final : public UOrionAttributeSet
{
public:
	float                                         VisionRadius;                                      // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_VisionRadius();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionVisionSet">();
	}
	static class UOrionVisionSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionVisionSet>();
	}
};
static_assert(alignof(UOrionVisionSet) == 0x000008, "Wrong alignment on UOrionVisionSet");
static_assert(sizeof(UOrionVisionSet) == 0x000038, "Wrong size on UOrionVisionSet");
static_assert(offsetof(UOrionVisionSet, VisionRadius) == 0x000030, "Member 'UOrionVisionSet::VisionRadius' has a wrong offset!");

// Class OrionGame.OrionVisionWard
// 0x0080 (0x05A8 - 0x0528)
class AOrionVisionWard : public AOrionDamageableActor
{
public:
	float                                         LifeSpanOnceWardExpires;                           // 0x0528(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PingDelay;                                         // 0x052C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DeltaBetweenLosChecks;                             // 0x0530(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WardDeathTime;                                     // 0x0534(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_538[0x8];                                      // 0x0538(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UOrionWardSet*                          WardSet;                                           // 0x0540(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_548[0x60];                                     // 0x0548(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleTrackedHeroDeath(class AOrionChar* DeadChar, class AController* Killer, class AActor* DamageCauser);
	void OnPlayerSightedPing(class AActor* SightedPlayer);
	void OnVisionWardTimedOut();

	float GetLifeSpanPercentage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionVisionWard">();
	}
	static class AOrionVisionWard* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionVisionWard>();
	}
};
static_assert(alignof(AOrionVisionWard) == 0x000008, "Wrong alignment on AOrionVisionWard");
static_assert(sizeof(AOrionVisionWard) == 0x0005A8, "Wrong size on AOrionVisionWard");
static_assert(offsetof(AOrionVisionWard, LifeSpanOnceWardExpires) == 0x000528, "Member 'AOrionVisionWard::LifeSpanOnceWardExpires' has a wrong offset!");
static_assert(offsetof(AOrionVisionWard, PingDelay) == 0x00052C, "Member 'AOrionVisionWard::PingDelay' has a wrong offset!");
static_assert(offsetof(AOrionVisionWard, DeltaBetweenLosChecks) == 0x000530, "Member 'AOrionVisionWard::DeltaBetweenLosChecks' has a wrong offset!");
static_assert(offsetof(AOrionVisionWard, WardDeathTime) == 0x000534, "Member 'AOrionVisionWard::WardDeathTime' has a wrong offset!");
static_assert(offsetof(AOrionVisionWard, WardSet) == 0x000540, "Member 'AOrionVisionWard::WardSet' has a wrong offset!");

// Class OrionGame.OrionWell_Base
// 0x02C8 (0x06B0 - 0x03E8)
class AOrionWell_Base final : public AOrionBaseActor
{
public:
	uint8                                         Pad_3E8[0x20];                                     // 0x03E8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReplicatedGeyserTime;                              // 0x0408(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40C[0x4];                                      // 0x040C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsInTargetingVolume;                           // 0x0410(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UOrionAbilitySystemComponent*           AbilitySystemComponent;                            // 0x0420(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionWellSet*                          WellSet;                                           // 0x0428(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOrionXPSet*                            XPSet;                                             // 0x0430(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AOrionRigs*                             PlacedRig;                                         // 0x0438(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrionTeam                                    LastPlacedRigTeam;                                 // 0x0440(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_441[0x7];                                      // 0x0441(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AVolume*                                TargetingVolume;                                   // 0x0448(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   WellDataName;                                      // 0x0450(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOrionAbilitySet*                       Abilities;                                         // 0x0458(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InitalSpawnDelayScalar;                            // 0x0460(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GeyserTimeScalar;                                  // 0x0464(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ActiveTimeScalar;                                  // 0x0468(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DeadZoneTimeScalar;                                // 0x046C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowWellToCycleThroughDormant;                   // 0x0470(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnforcePlayerBlockingPlacement;                   // 0x0471(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceToDeadZoneAfterRigRemovalWhenActive;         // 0x0472(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceToActiveAfterRigAttachedWhenGeyser;          // 0x0473(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCheckCharges;                                     // 0x0474(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_475[0x3];                                      // 0x0475(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrionCharHero*                         InteractingHeroPawn;                               // 0x0478(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AOrionCharHero*>                 OverlappingHeroes;                                 // 0x0480(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AOrionCharHero*>                 ContestingHeroes;                                  // 0x0490(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         StateTimers[0x3];                                  // 0x04A0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrionWellState                               CurrentWellState;                                  // 0x04AC(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4AD[0x3];                                      // 0x04AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      OverlapCollision;                                  // 0x04B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FOrionWellCues                         WellGameplayCues;                                  // 0x04B8(0x0038)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F0[0xC];                                      // 0x04F0(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IndicatorZOffset;                                  // 0x04FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRelevantToStrategicAI;                            // 0x0500(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_501[0x1AF];                                    // 0x0501(0x01AF)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DetachRig(class AOrionRigs* RigToRemove);
	void ForceWellToState(EOrionWellState NewState);
	class AOrionRigs* GetAttachedRig();
	EOrionWellState GetCurrentWellState();
	class AOrionPlayerState_Game* GetPlayerThatPlacedRig();
	float GetResourcePercent();
	struct FVector GetRigAttachLocation();
	struct FRotator GetRigAttachRotaion();
	float GetRigBoostedScale();
	void HandleMatchStarted();
	bool K2_IsRigPlaced();
	void OnAttachRig(class AOrionRigs* NewAttachedRig);
	void OnDetachRig();
	void OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnRep_InteractingHeroPawn();
	void OnRep_PlacedRig();
	void OnRep_StateTimers();
	void OnRep_WellStateUpdate(EOrionWellState OldState);
	void PlaceRig();
	void RanDry();
	void ShowRigGatherAmount(float AmountGathered);
	void StartCollectingFromRig();
	void UpdateCollectionPadOverlaps(class AActor* InActorToUpdate);

	float GetMaxResource() const;
	float GetRemainingDeadZoneTime() const;
	float GetRemainingInitalSpawnDelay() const;
	float GetResource() const;
	float GetWellActiveTime() const;
	float GetWellDeadZoneTime() const;
	float GetWellGeyserTime() const;
	float GetWellInitalSpawnDelay() const;
	bool IsActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionWell_Base">();
	}
	static class AOrionWell_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionWell_Base>();
	}
};
static_assert(alignof(AOrionWell_Base) == 0x000008, "Wrong alignment on AOrionWell_Base");
static_assert(sizeof(AOrionWell_Base) == 0x0006B0, "Wrong size on AOrionWell_Base");
static_assert(offsetof(AOrionWell_Base, ReplicatedGeyserTime) == 0x000408, "Member 'AOrionWell_Base::ReplicatedGeyserTime' has a wrong offset!");
static_assert(offsetof(AOrionWell_Base, ActorsInTargetingVolume) == 0x000410, "Member 'AOrionWell_Base::ActorsInTargetingVolume' has a wrong offset!");
static_assert(offsetof(AOrionWell_Base, AbilitySystemComponent) == 0x000420, "Member 'AOrionWell_Base::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(AOrionWell_Base, WellSet) == 0x000428, "Member 'AOrionWell_Base::WellSet' has a wrong offset!");
static_assert(offsetof(AOrionWell_Base, XPSet) == 0x000430, "Member 'AOrionWell_Base::XPSet' has a wrong offset!");
static_assert(offsetof(AOrionWell_Base, PlacedRig) == 0x000438, "Member 'AOrionWell_Base::PlacedRig' has a wrong offset!");
static_assert(offsetof(AOrionWell_Base, LastPlacedRigTeam) == 0x000440, "Member 'AOrionWell_Base::LastPlacedRigTeam' has a wrong offset!");
static_assert(offsetof(AOrionWell_Base, TargetingVolume) == 0x000448, "Member 'AOrionWell_Base::TargetingVolume' has a wrong offset!");
static_assert(offsetof(AOrionWell_Base, WellDataName) == 0x000450, "Member 'AOrionWell_Base::WellDataName' has a wrong offset!");
static_assert(offsetof(AOrionWell_Base, Abilities) == 0x000458, "Member 'AOrionWell_Base::Abilities' has a wrong offset!");
static_assert(offsetof(AOrionWell_Base, InitalSpawnDelayScalar) == 0x000460, "Member 'AOrionWell_Base::InitalSpawnDelayScalar' has a wrong offset!");
static_assert(offsetof(AOrionWell_Base, GeyserTimeScalar) == 0x000464, "Member 'AOrionWell_Base::GeyserTimeScalar' has a wrong offset!");
static_assert(offsetof(AOrionWell_Base, ActiveTimeScalar) == 0x000468, "Member 'AOrionWell_Base::ActiveTimeScalar' has a wrong offset!");
static_assert(offsetof(AOrionWell_Base, DeadZoneTimeScalar) == 0x00046C, "Member 'AOrionWell_Base::DeadZoneTimeScalar' has a wrong offset!");
static_assert(offsetof(AOrionWell_Base, bAllowWellToCycleThroughDormant) == 0x000470, "Member 'AOrionWell_Base::bAllowWellToCycleThroughDormant' has a wrong offset!");
static_assert(offsetof(AOrionWell_Base, bEnforcePlayerBlockingPlacement) == 0x000471, "Member 'AOrionWell_Base::bEnforcePlayerBlockingPlacement' has a wrong offset!");
static_assert(offsetof(AOrionWell_Base, bForceToDeadZoneAfterRigRemovalWhenActive) == 0x000472, "Member 'AOrionWell_Base::bForceToDeadZoneAfterRigRemovalWhenActive' has a wrong offset!");
static_assert(offsetof(AOrionWell_Base, bForceToActiveAfterRigAttachedWhenGeyser) == 0x000473, "Member 'AOrionWell_Base::bForceToActiveAfterRigAttachedWhenGeyser' has a wrong offset!");
static_assert(offsetof(AOrionWell_Base, bCheckCharges) == 0x000474, "Member 'AOrionWell_Base::bCheckCharges' has a wrong offset!");
static_assert(offsetof(AOrionWell_Base, InteractingHeroPawn) == 0x000478, "Member 'AOrionWell_Base::InteractingHeroPawn' has a wrong offset!");
static_assert(offsetof(AOrionWell_Base, OverlappingHeroes) == 0x000480, "Member 'AOrionWell_Base::OverlappingHeroes' has a wrong offset!");
static_assert(offsetof(AOrionWell_Base, ContestingHeroes) == 0x000490, "Member 'AOrionWell_Base::ContestingHeroes' has a wrong offset!");
static_assert(offsetof(AOrionWell_Base, StateTimers) == 0x0004A0, "Member 'AOrionWell_Base::StateTimers' has a wrong offset!");
static_assert(offsetof(AOrionWell_Base, CurrentWellState) == 0x0004AC, "Member 'AOrionWell_Base::CurrentWellState' has a wrong offset!");
static_assert(offsetof(AOrionWell_Base, OverlapCollision) == 0x0004B0, "Member 'AOrionWell_Base::OverlapCollision' has a wrong offset!");
static_assert(offsetof(AOrionWell_Base, WellGameplayCues) == 0x0004B8, "Member 'AOrionWell_Base::WellGameplayCues' has a wrong offset!");
static_assert(offsetof(AOrionWell_Base, IndicatorZOffset) == 0x0004FC, "Member 'AOrionWell_Base::IndicatorZOffset' has a wrong offset!");
static_assert(offsetof(AOrionWell_Base, bRelevantToStrategicAI) == 0x000500, "Member 'AOrionWell_Base::bRelevantToStrategicAI' has a wrong offset!");

// Class OrionGame.OrionWellSet
// 0x0048 (0x0078 - 0x0030)
class UOrionWellSet final : public UOrionAttributeSet
{
public:
	float                                         ReductionResource;                                 // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxResourcePoints;                                 // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResourcePoints;                                    // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResourceGatheringScaler;                           // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerXPScalar;                                    // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BuilderXPRewardXP;                                 // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AwardPlayerXP;                                     // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitalSpawnDelay;                                  // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeadZoneTime;                                      // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GeyserTime;                                        // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActiveTime;                                        // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x1C];                                      // 0x005C(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionWellSet">();
	}
	static class UOrionWellSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionWellSet>();
	}
};
static_assert(alignof(UOrionWellSet) == 0x000008, "Wrong alignment on UOrionWellSet");
static_assert(sizeof(UOrionWellSet) == 0x000078, "Wrong size on UOrionWellSet");
static_assert(offsetof(UOrionWellSet, ReductionResource) == 0x000030, "Member 'UOrionWellSet::ReductionResource' has a wrong offset!");
static_assert(offsetof(UOrionWellSet, MaxResourcePoints) == 0x000034, "Member 'UOrionWellSet::MaxResourcePoints' has a wrong offset!");
static_assert(offsetof(UOrionWellSet, ResourcePoints) == 0x000038, "Member 'UOrionWellSet::ResourcePoints' has a wrong offset!");
static_assert(offsetof(UOrionWellSet, ResourceGatheringScaler) == 0x00003C, "Member 'UOrionWellSet::ResourceGatheringScaler' has a wrong offset!");
static_assert(offsetof(UOrionWellSet, PlayerXPScalar) == 0x000040, "Member 'UOrionWellSet::PlayerXPScalar' has a wrong offset!");
static_assert(offsetof(UOrionWellSet, BuilderXPRewardXP) == 0x000044, "Member 'UOrionWellSet::BuilderXPRewardXP' has a wrong offset!");
static_assert(offsetof(UOrionWellSet, AwardPlayerXP) == 0x000048, "Member 'UOrionWellSet::AwardPlayerXP' has a wrong offset!");
static_assert(offsetof(UOrionWellSet, InitalSpawnDelay) == 0x00004C, "Member 'UOrionWellSet::InitalSpawnDelay' has a wrong offset!");
static_assert(offsetof(UOrionWellSet, DeadZoneTime) == 0x000050, "Member 'UOrionWellSet::DeadZoneTime' has a wrong offset!");
static_assert(offsetof(UOrionWellSet, GeyserTime) == 0x000054, "Member 'UOrionWellSet::GeyserTime' has a wrong offset!");
static_assert(offsetof(UOrionWellSet, ActiveTime) == 0x000058, "Member 'UOrionWellSet::ActiveTime' has a wrong offset!");

// Class OrionGame.OrionWidget_HUDIndicatorOverlay
// 0x00C0 (0x01B8 - 0x00F8)
class UOrionWidget_HUDIndicatorOverlay final : public UWidget
{
public:
	float                                         MaxViewableDistanceDuringReplays;                  // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DistanceCurve;                                     // 0x0100(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USlateVectorArtData*                    MinionIndicatorMeshData;                           // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USlateVectorArtData*                    FriendlyHeroIndicatorMeshData;                     // 0x0110(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USlateVectorArtData*                    EnemyHeroIndicatorMeshData;                        // 0x0118(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USlateVectorArtData*                    OffscreenHeroIndicatorMeshData;                    // 0x0120(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USlateVectorArtData*                    TowerIndicatorMeshData;                            // 0x0128(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USlateVectorArtData*                    OffscreenTowerIndicatorMeshData;                   // 0x0130(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USlateVectorArtData*                    DistantObjectiveIndicatorMeshData;                 // 0x0138(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USlateVectorArtData*                    SpawnerIndicatorMeshData;                          // 0x0140(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USlateVectorArtData*                    MiscIndicatorMeshData;                             // 0x0148(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USlateWidgetStyleAsset*                 HeroNameTextStyle;                                 // 0x0150(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USlateWidgetStyleAsset*                 HeroNameEffectTextStyle;                           // 0x0158(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             HeroDataTexture;                                   // 0x0160(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 HeroNamesTexture;                                  // 0x0168(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 HeroPortraitsTexture;                              // 0x0170(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_178[0x40];                                     // 0x0178(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DynamicHandleHUDSettingsChanged();
	void SetLocalPlayerController(class APlayerController* LocalPlayerController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionWidget_HUDIndicatorOverlay">();
	}
	static class UOrionWidget_HUDIndicatorOverlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionWidget_HUDIndicatorOverlay>();
	}
};
static_assert(alignof(UOrionWidget_HUDIndicatorOverlay) == 0x000008, "Wrong alignment on UOrionWidget_HUDIndicatorOverlay");
static_assert(sizeof(UOrionWidget_HUDIndicatorOverlay) == 0x0001B8, "Wrong size on UOrionWidget_HUDIndicatorOverlay");
static_assert(offsetof(UOrionWidget_HUDIndicatorOverlay, MaxViewableDistanceDuringReplays) == 0x0000F8, "Member 'UOrionWidget_HUDIndicatorOverlay::MaxViewableDistanceDuringReplays' has a wrong offset!");
static_assert(offsetof(UOrionWidget_HUDIndicatorOverlay, DistanceCurve) == 0x000100, "Member 'UOrionWidget_HUDIndicatorOverlay::DistanceCurve' has a wrong offset!");
static_assert(offsetof(UOrionWidget_HUDIndicatorOverlay, MinionIndicatorMeshData) == 0x000108, "Member 'UOrionWidget_HUDIndicatorOverlay::MinionIndicatorMeshData' has a wrong offset!");
static_assert(offsetof(UOrionWidget_HUDIndicatorOverlay, FriendlyHeroIndicatorMeshData) == 0x000110, "Member 'UOrionWidget_HUDIndicatorOverlay::FriendlyHeroIndicatorMeshData' has a wrong offset!");
static_assert(offsetof(UOrionWidget_HUDIndicatorOverlay, EnemyHeroIndicatorMeshData) == 0x000118, "Member 'UOrionWidget_HUDIndicatorOverlay::EnemyHeroIndicatorMeshData' has a wrong offset!");
static_assert(offsetof(UOrionWidget_HUDIndicatorOverlay, OffscreenHeroIndicatorMeshData) == 0x000120, "Member 'UOrionWidget_HUDIndicatorOverlay::OffscreenHeroIndicatorMeshData' has a wrong offset!");
static_assert(offsetof(UOrionWidget_HUDIndicatorOverlay, TowerIndicatorMeshData) == 0x000128, "Member 'UOrionWidget_HUDIndicatorOverlay::TowerIndicatorMeshData' has a wrong offset!");
static_assert(offsetof(UOrionWidget_HUDIndicatorOverlay, OffscreenTowerIndicatorMeshData) == 0x000130, "Member 'UOrionWidget_HUDIndicatorOverlay::OffscreenTowerIndicatorMeshData' has a wrong offset!");
static_assert(offsetof(UOrionWidget_HUDIndicatorOverlay, DistantObjectiveIndicatorMeshData) == 0x000138, "Member 'UOrionWidget_HUDIndicatorOverlay::DistantObjectiveIndicatorMeshData' has a wrong offset!");
static_assert(offsetof(UOrionWidget_HUDIndicatorOverlay, SpawnerIndicatorMeshData) == 0x000140, "Member 'UOrionWidget_HUDIndicatorOverlay::SpawnerIndicatorMeshData' has a wrong offset!");
static_assert(offsetof(UOrionWidget_HUDIndicatorOverlay, MiscIndicatorMeshData) == 0x000148, "Member 'UOrionWidget_HUDIndicatorOverlay::MiscIndicatorMeshData' has a wrong offset!");
static_assert(offsetof(UOrionWidget_HUDIndicatorOverlay, HeroNameTextStyle) == 0x000150, "Member 'UOrionWidget_HUDIndicatorOverlay::HeroNameTextStyle' has a wrong offset!");
static_assert(offsetof(UOrionWidget_HUDIndicatorOverlay, HeroNameEffectTextStyle) == 0x000158, "Member 'UOrionWidget_HUDIndicatorOverlay::HeroNameEffectTextStyle' has a wrong offset!");
static_assert(offsetof(UOrionWidget_HUDIndicatorOverlay, HeroDataTexture) == 0x000160, "Member 'UOrionWidget_HUDIndicatorOverlay::HeroDataTexture' has a wrong offset!");
static_assert(offsetof(UOrionWidget_HUDIndicatorOverlay, HeroNamesTexture) == 0x000168, "Member 'UOrionWidget_HUDIndicatorOverlay::HeroNamesTexture' has a wrong offset!");
static_assert(offsetof(UOrionWidget_HUDIndicatorOverlay, HeroPortraitsTexture) == 0x000170, "Member 'UOrionWidget_HUDIndicatorOverlay::HeroPortraitsTexture' has a wrong offset!");

// Class OrionGame.OrionWorldSettings
// 0x0018 (0x04E0 - 0x04C8)
class AOrionWorldSettings final : public AWorldSettings
{
public:
	uint8                                         bAICommanderEnabled : 1;                           // 0x04C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4C9[0x7];                                      // 0x04C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEventKeywordCollectionItem>    EventKeywords;                                     // 0x04D0(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionWorldSettings">();
	}
	static class AOrionWorldSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrionWorldSettings>();
	}
};
static_assert(alignof(AOrionWorldSettings) == 0x000008, "Wrong alignment on AOrionWorldSettings");
static_assert(sizeof(AOrionWorldSettings) == 0x0004E0, "Wrong size on AOrionWorldSettings");
static_assert(offsetof(AOrionWorldSettings, EventKeywords) == 0x0004D0, "Member 'AOrionWorldSettings::EventKeywords' has a wrong offset!");

// Class OrionGame.OrionWorldStateMonitor
// 0x02D8 (0x0300 - 0x0028)
class UOrionWorldStateMonitor final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTeamHeroRecord                        Teams[0x2];                                        // 0x0030(0x0020)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FAILaneInfoManager                     LaneInfoManager;                                   // 0x0070(0x0178)(Transient, Protected, NativeAccessSpecifierProtected)
	class UOrionAISystem*                         AISystem;                                          // 0x01E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOrionAIMinionAggroManager*             MinionAggroManager;                                // 0x01F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAIRefineryManager                     RefineryManager;                                   // 0x01F8(0x0010)(Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AOrionCharAISpawner_Jungle*>     JungleCamps;                                       // 0x0208(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_218[0x18];                                     // 0x0218(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOrionAILane>                   MapLanes;                                          // 0x0230(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class AOrionDamageableObjective_Base*         TeamCores[0x2];                                    // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_250[0xB0];                                     // 0x0250(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionWorldStateMonitor">();
	}
	static class UOrionWorldStateMonitor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionWorldStateMonitor>();
	}
};
static_assert(alignof(UOrionWorldStateMonitor) == 0x000008, "Wrong alignment on UOrionWorldStateMonitor");
static_assert(sizeof(UOrionWorldStateMonitor) == 0x000300, "Wrong size on UOrionWorldStateMonitor");
static_assert(offsetof(UOrionWorldStateMonitor, Teams) == 0x000030, "Member 'UOrionWorldStateMonitor::Teams' has a wrong offset!");
static_assert(offsetof(UOrionWorldStateMonitor, LaneInfoManager) == 0x000070, "Member 'UOrionWorldStateMonitor::LaneInfoManager' has a wrong offset!");
static_assert(offsetof(UOrionWorldStateMonitor, AISystem) == 0x0001E8, "Member 'UOrionWorldStateMonitor::AISystem' has a wrong offset!");
static_assert(offsetof(UOrionWorldStateMonitor, MinionAggroManager) == 0x0001F0, "Member 'UOrionWorldStateMonitor::MinionAggroManager' has a wrong offset!");
static_assert(offsetof(UOrionWorldStateMonitor, RefineryManager) == 0x0001F8, "Member 'UOrionWorldStateMonitor::RefineryManager' has a wrong offset!");
static_assert(offsetof(UOrionWorldStateMonitor, JungleCamps) == 0x000208, "Member 'UOrionWorldStateMonitor::JungleCamps' has a wrong offset!");
static_assert(offsetof(UOrionWorldStateMonitor, MapLanes) == 0x000230, "Member 'UOrionWorldStateMonitor::MapLanes' has a wrong offset!");
static_assert(offsetof(UOrionWorldStateMonitor, TeamCores) == 0x000240, "Member 'UOrionWorldStateMonitor::TeamCores' has a wrong offset!");

// Class OrionGame.OrionYouTubeUpload
// 0x0098 (0x00C0 - 0x0028)
class UOrionYouTubeUpload final : public UObject
{
public:
	uint8                                         Pad_28[0x78];                                      // 0x0028(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 YoutubeAccessToken;                                // 0x00A0(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 YoutubeRefreshToken;                               // 0x00B0(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OrionYouTubeUpload">();
	}
	static class UOrionYouTubeUpload* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOrionYouTubeUpload>();
	}
};
static_assert(alignof(UOrionYouTubeUpload) == 0x000008, "Wrong alignment on UOrionYouTubeUpload");
static_assert(sizeof(UOrionYouTubeUpload) == 0x0000C0, "Wrong size on UOrionYouTubeUpload");
static_assert(offsetof(UOrionYouTubeUpload, YoutubeAccessToken) == 0x0000A0, "Member 'UOrionYouTubeUpload::YoutubeAccessToken' has a wrong offset!");
static_assert(offsetof(UOrionYouTubeUpload, YoutubeRefreshToken) == 0x0000B0, "Member 'UOrionYouTubeUpload::YoutubeRefreshToken' has a wrong offset!");

// Class OrionGame.PCTeamCommunicationsData
// 0x0060 (0x0090 - 0x0030)
class UPCTeamCommunicationsData final : public UDataAsset
{
public:
	class USoundCue*                              MessageSound;                                      // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   OptionLabel;                                       // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ChatMessage;                                       // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   TeamCommMessage;                                   // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bPingMinimap;                                      // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMinimapLocation                              MapPingLocation;                                   // 0x0081(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrionAbilityBinding                          EmoteAbilityBinding;                               // 0x0082(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAITeamCommEvent                              AITeamCommEvent;                                   // 0x0083(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           CharacterTag;                                      // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCTeamCommunicationsData">();
	}
	static class UPCTeamCommunicationsData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPCTeamCommunicationsData>();
	}
};
static_assert(alignof(UPCTeamCommunicationsData) == 0x000008, "Wrong alignment on UPCTeamCommunicationsData");
static_assert(sizeof(UPCTeamCommunicationsData) == 0x000090, "Wrong size on UPCTeamCommunicationsData");
static_assert(offsetof(UPCTeamCommunicationsData, MessageSound) == 0x000030, "Member 'UPCTeamCommunicationsData::MessageSound' has a wrong offset!");
static_assert(offsetof(UPCTeamCommunicationsData, OptionLabel) == 0x000038, "Member 'UPCTeamCommunicationsData::OptionLabel' has a wrong offset!");
static_assert(offsetof(UPCTeamCommunicationsData, ChatMessage) == 0x000050, "Member 'UPCTeamCommunicationsData::ChatMessage' has a wrong offset!");
static_assert(offsetof(UPCTeamCommunicationsData, TeamCommMessage) == 0x000068, "Member 'UPCTeamCommunicationsData::TeamCommMessage' has a wrong offset!");
static_assert(offsetof(UPCTeamCommunicationsData, bPingMinimap) == 0x000080, "Member 'UPCTeamCommunicationsData::bPingMinimap' has a wrong offset!");
static_assert(offsetof(UPCTeamCommunicationsData, MapPingLocation) == 0x000081, "Member 'UPCTeamCommunicationsData::MapPingLocation' has a wrong offset!");
static_assert(offsetof(UPCTeamCommunicationsData, EmoteAbilityBinding) == 0x000082, "Member 'UPCTeamCommunicationsData::EmoteAbilityBinding' has a wrong offset!");
static_assert(offsetof(UPCTeamCommunicationsData, AITeamCommEvent) == 0x000083, "Member 'UPCTeamCommunicationsData::AITeamCommEvent' has a wrong offset!");
static_assert(offsetof(UPCTeamCommunicationsData, CharacterTag) == 0x000088, "Member 'UPCTeamCommunicationsData::CharacterTag' has a wrong offset!");

// Class OrionGame.PhasedAutomatedTestManager
// 0x0018 (0x0330 - 0x0318)
class APhasedAutomatedTestManager final : public APhasedAutomationActorBase
{
public:
	bool                                          UpdateTestList;                                    // 0x0318(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_319[0x7];                                      // 0x0319(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APhasedFunctionalTest*>          TestActors;                                        // 0x0320(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhasedAutomatedTestManager">();
	}
	static class APhasedAutomatedTestManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<APhasedAutomatedTestManager>();
	}
};
static_assert(alignof(APhasedAutomatedTestManager) == 0x000008, "Wrong alignment on APhasedAutomatedTestManager");
static_assert(sizeof(APhasedAutomatedTestManager) == 0x000330, "Wrong size on APhasedAutomatedTestManager");
static_assert(offsetof(APhasedAutomatedTestManager, UpdateTestList) == 0x000318, "Member 'APhasedAutomatedTestManager::UpdateTestList' has a wrong offset!");
static_assert(offsetof(APhasedAutomatedTestManager, TestActors) == 0x000320, "Member 'APhasedAutomatedTestManager::TestActors' has a wrong offset!");

// Class OrionGame.PlayerBotSpawner
// 0x0058 (0x0370 - 0x0318)
class APlayerBotSpawner final : public AActor
{
public:
	class UOrionHeroData*                         HeroData;                                          // 0x0318(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UOrionHeroData*>                 AllHeroes;                                         // 0x0320(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	EOrionTeam                                    TeamNum;                                           // 0x0330(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAIBotDifficulty                              BotDifficulty;                                     // 0x0331(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_332[0x6];                                      // 0x0332(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIScriptedBehavior*                    ScriptedBehavior;                                  // 0x0338(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AOrionAIBot*                            SpawnedBot;                                        // 0x0340(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         StartingLevel;                                     // 0x0348(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartingHealthPercent;                             // 0x034C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bEnabled : 1;                                      // 0x0350(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_351[0xF];                                      // 0x0351(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnBotFinishedSpawning;                             // 0x0360(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	void HandleMatchStarted();
	void SetPosition(EOrionPosition InPosition);
	class AOrionAIBot* Spawn();

	EOrionTeam GetTeamNum() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerBotSpawner">();
	}
	static class APlayerBotSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerBotSpawner>();
	}
};
static_assert(alignof(APlayerBotSpawner) == 0x000008, "Wrong alignment on APlayerBotSpawner");
static_assert(sizeof(APlayerBotSpawner) == 0x000370, "Wrong size on APlayerBotSpawner");
static_assert(offsetof(APlayerBotSpawner, HeroData) == 0x000318, "Member 'APlayerBotSpawner::HeroData' has a wrong offset!");
static_assert(offsetof(APlayerBotSpawner, AllHeroes) == 0x000320, "Member 'APlayerBotSpawner::AllHeroes' has a wrong offset!");
static_assert(offsetof(APlayerBotSpawner, TeamNum) == 0x000330, "Member 'APlayerBotSpawner::TeamNum' has a wrong offset!");
static_assert(offsetof(APlayerBotSpawner, BotDifficulty) == 0x000331, "Member 'APlayerBotSpawner::BotDifficulty' has a wrong offset!");
static_assert(offsetof(APlayerBotSpawner, ScriptedBehavior) == 0x000338, "Member 'APlayerBotSpawner::ScriptedBehavior' has a wrong offset!");
static_assert(offsetof(APlayerBotSpawner, SpawnedBot) == 0x000340, "Member 'APlayerBotSpawner::SpawnedBot' has a wrong offset!");
static_assert(offsetof(APlayerBotSpawner, StartingLevel) == 0x000348, "Member 'APlayerBotSpawner::StartingLevel' has a wrong offset!");
static_assert(offsetof(APlayerBotSpawner, StartingHealthPercent) == 0x00034C, "Member 'APlayerBotSpawner::StartingHealthPercent' has a wrong offset!");
static_assert(offsetof(APlayerBotSpawner, OnBotFinishedSpawning) == 0x000360, "Member 'APlayerBotSpawner::OnBotFinishedSpawning' has a wrong offset!");

// Class OrionGame.ScalableFloatUtils
// 0x0000 (0x0028 - 0x0028)
class UScalableFloatUtils final : public UBlueprintFunctionLibrary
{
public:
	static float GetValue(const struct FScalableFloat& Input);
	static float GetValueAtLevel(const struct FScalableFloat& Input, float Level);
	static bool IsStatic(const struct FScalableFloat& Input);
	static void SetScalingValue(struct FScalableFloat& Input, float InCoeffecient, const class FName InRowName, class UCurveTable* InTable);
	static void SetValue(struct FScalableFloat& Input, float NewValue);
	static class FString ToSimpleString(const struct FScalableFloat& Input);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScalableFloatUtils">();
	}
	static class UScalableFloatUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScalableFloatUtils>();
	}
};
static_assert(alignof(UScalableFloatUtils) == 0x000008, "Wrong alignment on UScalableFloatUtils");
static_assert(sizeof(UScalableFloatUtils) == 0x000028, "Wrong size on UScalableFloatUtils");

// Class OrionGame.TeamCommunicationsActor
// 0x0008 (0x03F0 - 0x03E8)
class ATeamCommunicationsActor final : public AOrionBaseActor
{
public:
	class AOrionPlayerState_Game*                 OwningPlayerState;                                 // 0x03E8(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Blueprint_StartHidingBeforeDestroy(bool bIsOwningPlayer);
	void HideMiniMapIcon();
	void HideVisuals(bool bIsOwningPlayer);
	void HideVisualsImmediately();
	void ShowVisuals(bool bIsOwningPlayer);
	void StartHidingBeforeDestroy();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamCommunicationsActor">();
	}
	static class ATeamCommunicationsActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATeamCommunicationsActor>();
	}
};
static_assert(alignof(ATeamCommunicationsActor) == 0x000008, "Wrong alignment on ATeamCommunicationsActor");
static_assert(sizeof(ATeamCommunicationsActor) == 0x0003F0, "Wrong size on ATeamCommunicationsActor");
static_assert(offsetof(ATeamCommunicationsActor, OwningPlayerState) == 0x0003E8, "Member 'ATeamCommunicationsActor::OwningPlayerState' has a wrong offset!");

// Class OrionGame.TeamCommunicationsData
// 0x0000 (0x0030 - 0x0030)
class UTeamCommunicationsData final : public UDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamCommunicationsData">();
	}
	static class UTeamCommunicationsData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamCommunicationsData>();
	}
};
static_assert(alignof(UTeamCommunicationsData) == 0x000008, "Wrong alignment on UTeamCommunicationsData");
static_assert(sizeof(UTeamCommunicationsData) == 0x000030, "Wrong size on UTeamCommunicationsData");

// Class OrionGame.TimeAgoLibrary
// 0x0000 (0x0028 - 0x0028)
class UTimeAgoLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void RefreshTime(struct FTimeAgo& TimeAgo, const struct FDateTime& InTimepoint);
	static void RegisterEditableText(struct FTimeAgo& TimeAgo, class UMultiLineEditableText* InEditableText, const struct FDateTime& InTimepoint);
	static void RegisterText(struct FTimeAgo& TimeAgo, class UTextBlock* InTextBlock, const struct FDateTime& InTimepoint);
	static void RegisterTextBox(struct FTimeAgo& TimeAgo, class UMultiLineEditableTextBox* InEditableTextBox, const struct FDateTime& InTimepoint);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimeAgoLibrary">();
	}
	static class UTimeAgoLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimeAgoLibrary>();
	}
};
static_assert(alignof(UTimeAgoLibrary) == 0x000008, "Wrong alignment on UTimeAgoLibrary");
static_assert(sizeof(UTimeAgoLibrary) == 0x000028, "Wrong size on UTimeAgoLibrary");

// Class OrionGame.WidgetStack
// 0x0020 (0x0118 - 0x00F8)
class UWidgetStack final : public UWidget
{
public:
	TArray<class UWidget*>                        Stack;                                             // 0x00F8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x10];                                     // 0x0108(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Clear();
	void PopWidget();
	void PushWidget(class UWidget* InWidget);

	int32 NumWidgets() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetStack">();
	}
	static class UWidgetStack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetStack>();
	}
};
static_assert(alignof(UWidgetStack) == 0x000008, "Wrong alignment on UWidgetStack");
static_assert(sizeof(UWidgetStack) == 0x000118, "Wrong size on UWidgetStack");
static_assert(offsetof(UWidgetStack, Stack) == 0x0000F8, "Member 'UWidgetStack::Stack' has a wrong offset!");

}

